{"files":[{"patch":"@@ -96,0 +96,5 @@\n+    @Override\n+    public Content getOutputInstance() {\n+        return new ContentBuilder();\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ClassWriterImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,4 @@\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Path;\n@@ -30,0 +34,1 @@\n+import java.util.Arrays;\n@@ -42,0 +47,1 @@\n+import javax.tools.DocumentationTool;\n@@ -52,1 +58,1 @@\n-import jdk.javadoc.internal.doclets.formats.html.taglets.HtmlTagletManager;\n+import jdk.javadoc.internal.doclets.formats.html.taglets.TagletManager;\n@@ -59,1 +65,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.taglets.TagletManager;\n@@ -66,0 +71,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.util.SimpleDocletException;\n@@ -148,0 +154,5 @@\n+    \/**\n+     * The taglet manager.\n+     *\/\n+    public TagletManager tagletManager;\n+\n@@ -292,5 +303,0 @@\n-    @Override\n-    protected TagletManager newTagletManager() {\n-        return new HtmlTagletManager(this);\n-    }\n-\n@@ -434,0 +440,25 @@\n+\n+\n+        String snippetPath = options.snippetPath();\n+        if (snippetPath != null) {\n+            Messages messages = getMessages();\n+            JavaFileManager fm = getFileManager();\n+            if (fm instanceof StandardJavaFileManager) {\n+                try {\n+                    List<Path> sp = Arrays.stream(snippetPath.split(File.pathSeparator))\n+                            .map(Path::of)\n+                            .toList();\n+                    StandardJavaFileManager sfm = (StandardJavaFileManager) fm;\n+                    sfm.setLocationFromPaths(DocumentationTool.Location.SNIPPET_PATH, sp);\n+                } catch (IOException | InvalidPathException e) {\n+                    throw new SimpleDocletException(messages.getResources().getText(\n+                            \"doclet.error_setting_snippet_path\", snippetPath, e), e);\n+                }\n+            } else {\n+                throw new SimpleDocletException(messages.getResources().getText(\n+                        \"doclet.cannot_use_snippet_path\", snippetPath));\n+            }\n+        }\n+\n+        initTagletManager(options.customTagStrs());\n+\n@@ -436,0 +467,95 @@\n+\n+    \/**\n+     * Initialize the taglet manager.  The strings to initialize the simple custom tags should\n+     * be in the following format:  \"[tag name]:[location str]:[heading]\".\n+     *\n+     * @param customTagStrs the set two-dimensional arrays of strings.  These arrays contain\n+     *                      either -tag or -taglet arguments.\n+     *\/\n+    private void initTagletManager(Set<List<String>> customTagStrs) {\n+        tagletManager = tagletManager != null ? tagletManager : new TagletManager(this);\n+        JavaFileManager fileManager = getFileManager();\n+        Messages messages = getMessages();\n+        try {\n+            tagletManager.initTagletPath(fileManager);\n+            tagletManager.loadTaglets(fileManager);\n+\n+            for (List<String> args : customTagStrs) {\n+                if (args.get(0).equals(\"-taglet\")) {\n+                    tagletManager.addCustomTag(args.get(1), fileManager);\n+                    continue;\n+                }\n+                \/* Since there are few constraints on the characters in a tag name,\n+                 * and real world examples with ':' in the tag name, we cannot simply use\n+                 * String.split(regex);  instead, we tokenize the string, allowing\n+                 * special characters to be escaped with '\\'. *\/\n+                List<String> tokens = tokenize(args.get(1), 3);\n+                switch (tokens.size()) {\n+                    case 1 -> {\n+                        String tagName = args.get(1);\n+                        if (tagletManager.isKnownCustomTag(tagName)) {\n+                            \/\/reorder a standard tag\n+                            tagletManager.addNewSimpleCustomTag(tagName, null, \"\");\n+                        } else {\n+                            \/\/Create a simple tag with the heading that has the same name as the tag.\n+                            StringBuilder heading = new StringBuilder(tagName + \":\");\n+                            heading.setCharAt(0, Character.toUpperCase(tagName.charAt(0)));\n+                            tagletManager.addNewSimpleCustomTag(tagName, heading.toString(), \"a\");\n+                        }\n+                    }\n+\n+                    case 2 ->\n+                        \/\/Add simple taglet without heading, probably to excluding it in the output.\n+                            tagletManager.addNewSimpleCustomTag(tokens.get(0), tokens.get(1), \"\");\n+\n+                    case 3 ->\n+                            tagletManager.addNewSimpleCustomTag(tokens.get(0), tokens.get(2), tokens.get(1));\n+\n+                    default ->\n+                            messages.error(\"doclet.Error_invalid_custom_tag_argument\", args.get(1));\n+                }\n+            }\n+        } catch (IOException e) {\n+            messages.error(\"doclet.taglet_could_not_set_location\", e.toString());\n+        }\n+    }\n+\n+    \/**\n+     * Given a string, return an array of tokens, separated by ':'.\n+     * The separator character can be escaped with the '\\' character.\n+     * The '\\' character may also be escaped with the '\\' character.\n+     *\n+     * @param s         the string to tokenize\n+     * @param maxTokens the maximum number of tokens returned.  If the\n+     *                  max is reached, the remaining part of s is appended\n+     *                  to the end of the last token.\n+     * @return an array of tokens\n+     *\/\n+    private List<String> tokenize(String s, int maxTokens) {\n+        List<String> tokens = new ArrayList<>();\n+        StringBuilder token = new StringBuilder();\n+        boolean prevIsEscapeChar = false;\n+        for (int i = 0; i < s.length(); i += Character.charCount(i)) {\n+            int currentChar = s.codePointAt(i);\n+            if (prevIsEscapeChar) {\n+                \/\/ Case 1:  escaped character\n+                token.appendCodePoint(currentChar);\n+                prevIsEscapeChar = false;\n+            } else if (currentChar == ':' && tokens.size() < maxTokens - 1) {\n+                \/\/ Case 2:  separator\n+                tokens.add(token.toString());\n+                token = new StringBuilder();\n+            } else if (currentChar == '\\\\') {\n+                \/\/ Case 3:  escape character\n+                prevIsEscapeChar = true;\n+            } else {\n+                \/\/ Case 4:  regular character\n+                token.appendCodePoint(currentChar);\n+            }\n+        }\n+        if (token.length() > 0) {\n+            tokens.add(token.toString());\n+        }\n+        return tokens;\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlConfiguration.java","additions":133,"deletions":7,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -322,0 +322,10 @@\n+    @Override\n+    protected void generateFiles() throws DocletException {\n+        super.generateFiles();\n+\n+        if (configuration.tagletManager != null) { \/\/ may be null, if no files generated, perhaps because of errros\n+            configuration.tagletManager.printReport();\n+        }\n+\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDoclet.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -93,1 +93,2 @@\n-import jdk.javadoc.internal.doclets.formats.html.taglets.TagletWriterImpl;\n+import jdk.javadoc.internal.doclets.formats.html.taglets.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.taglets.TagletWriter;\n@@ -97,2 +98,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.taglets.Taglet;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.TagletWriter;\n@@ -371,1 +370,1 @@\n-    private Content getInlineTagOutput(Element element, DocTree tree, TagletWriterImpl.Context context) {\n+    private Content getInlineTagOutput(Element element, DocTree tree, TagletWriter.Context context) {\n@@ -382,1 +381,1 @@\n-        return new TagletWriterImpl(this, isFirstSentence);\n+        return new TagletWriter(this, isFirstSentence);\n@@ -391,2 +390,2 @@\n-    public TagletWriterImpl getTagletWriterInstance(TagletWriterImpl.Context context) {\n-        return new TagletWriterImpl(this, context);\n+    public TagletWriter getTagletWriterInstance(TagletWriter.Context context) {\n+        return new TagletWriter(this, context);\n@@ -1173,1 +1172,1 @@\n-                new TagletWriterImpl.Context(isFirstSentence, inSummary));\n+                new TagletWriter.Context(isFirstSentence, inSummary));\n@@ -1190,1 +1189,1 @@\n-                                        TagletWriterImpl.Context context)\n+                                        TagletWriter.Context context)\n@@ -1424,1 +1423,1 @@\n-                                         Element element, TagletWriterImpl.Context context) {\n+                                         Element element, TagletWriter.Context context) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.LinkedHashSet;\n@@ -103,0 +104,5 @@\n+    \/**\n+     * Arguments for command-line option {@code -tag} and {@code -taglet}.\n+     *\/\n+    private final LinkedHashSet<List<String>> customTagStrs = new LinkedHashSet<>();\n+\n@@ -178,0 +184,6 @@\n+    \/**\n+     * Argument for command-line option {@code --snippet-path}.\n+     * The path for external snippets.\n+     *\/\n+    private String snippetPath = null;\n+\n@@ -185,0 +197,6 @@\n+    \/**\n+     * Argument for command-line option {@code --show-taglets}.\n+     * Show taglets (internal debug switch)\n+     *\/\n+    private boolean showTaglets = false;\n+\n@@ -190,0 +208,6 @@\n+    \/**\n+     * Argument for command-line option {@code -tagletpath}.\n+     * The path to Taglets\n+     *\/\n+    private String tagletPath = null;\n+\n@@ -409,0 +433,38 @@\n+                new Option(resources, \"--snippet-path\", 1) {\n+                    @Override\n+                    public boolean process(String opt, List<String> args) {\n+                        snippetPath = args.get(0);\n+                        return true;\n+                    }\n+                },\n+\n+                new Option(resources, \"-tag\", 1) {\n+                    @Override\n+                    public boolean process(String opt, List<String> args) {\n+                        ArrayList<String> list = new ArrayList<>();\n+                        list.add(opt);\n+                        list.add(args.get(0));\n+                        customTagStrs.add(list);\n+                        return true;\n+                    }\n+                },\n+\n+                new Option(resources, \"-taglet\", 1) {\n+                    @Override\n+                    public boolean process(String opt, List<String> args) {\n+                        ArrayList<String> list = new ArrayList<>();\n+                        list.add(opt);\n+                        list.add(args.get(0));\n+                        customTagStrs.add(list);\n+                        return true;\n+                    }\n+                },\n+\n+                new Option(resources, \"-tagletpath\", 1) {\n+                    @Override\n+                    public boolean process(String opt, List<String> args) {\n+                        tagletPath = args.get(0);\n+                        return true;\n+                    }\n+                },\n+\n@@ -492,0 +554,8 @@\n+                },\n+\n+                new Hidden(resources, \"--show-taglets\") {\n+                    @Override\n+                    public boolean process(String opt, List<String> args) {\n+                        showTaglets = true;\n+                        return true;\n+                    }\n@@ -623,0 +693,7 @@\n+    \/**\n+     * Arguments for command-line option {@code -tag} and {@code -taglet}.\n+     *\/\n+    LinkedHashSet<List<String>> customTagStrs() {\n+        return customTagStrs;\n+    }\n+\n@@ -724,0 +801,16 @@\n+    \/**\n+     * Argument for command-line option {@code --show-taglets}.\n+     * Show taglets (internal debug switch)\n+     *\/\n+    public boolean showTaglets() {\n+        return showTaglets;\n+    }\n+\n+    \/**\n+     * Argument for command-line option {@code --snippet-path}.\n+     * The path for external snippets.\n+     *\/\n+    public String snippetPath() {\n+        return snippetPath;\n+    }\n+\n@@ -740,0 +833,8 @@\n+    \/**\n+     * Argument for command-line option {@code -tagletpath}.\n+     * The path to Taglets\n+     *\/\n+    public String tagletPath() {\n+        return tagletPath;\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlOptions.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import jdk.javadoc.internal.doclets.formats.html.taglets.TagletWriterImpl;\n+import jdk.javadoc.internal.doclets.formats.html.taglets.TagletWriter;\n@@ -139,1 +139,1 @@\n-                    new TagletWriterImpl.Context(false, false));\n+                    new TagletWriter.Context(false, false));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlSerialFieldWriter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.taglets.TagletManager;\n+import jdk.javadoc.internal.doclets.formats.html.taglets.TagletManager;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlSerialMethodWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n@@ -36,1 +36,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n@@ -47,1 +47,1 @@\n-    protected final BaseConfiguration config;\n+    protected final HtmlConfiguration config;\n@@ -63,1 +63,1 @@\n-    public BaseTaglet(BaseConfiguration config, DocTree.Kind tagKind, boolean inline, Set<Location> sites) {\n+    public BaseTaglet(HtmlConfiguration config, DocTree.Kind tagKind, boolean inline, Set<Location> sites) {\n@@ -67,1 +67,1 @@\n-    BaseTaglet(BaseConfiguration config, String name, boolean inline, Set<Location> sites) {\n+    protected BaseTaglet(HtmlConfiguration config, String name, boolean inline, Set<Location> sites) {\n@@ -71,1 +71,1 @@\n-    private BaseTaglet(BaseConfiguration config, String name, DocTree.Kind tagKind, boolean inline, Set<Location> sites) {\n+    private BaseTaglet(HtmlConfiguration config, String name, DocTree.Kind tagKind, boolean inline, Set<Location> sites) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/BaseTaglet.java","additions":7,"deletions":7,"binary":false,"changes":14,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/BaseTaglet.java","status":"renamed"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DeprecatedTree;\n+import com.sun.source.doctree.DocTree;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n+\n+\/**\n+ * A taglet that represents the {@code @deprecated} tag.\n+ *\/\n+public class DeprecatedTaglet extends BaseTaglet {\n+    DeprecatedTaglet(HtmlConfiguration config) {\n+        super(config, DocTree.Kind.DEPRECATED, false,\n+                EnumSet.of(Taglet.Location.MODULE, Taglet.Location.TYPE, Taglet.Location.CONSTRUCTOR, Taglet.Location.METHOD, Taglet.Location.FIELD));\n+\n+    }\n+    @Override\n+    public Content getAllBlockTagOutput(Element element, TagletWriter tagletWriter) {\n+        var htmlWriter = tagletWriter.htmlWriter;\n+\n+        ContentBuilder result = new ContentBuilder();\n+        CommentHelper ch = utils.getCommentHelper(element);\n+        List<? extends DeprecatedTree> deprs = utils.getDeprecatedTrees(element);\n+        if (utils.isTypeElement(element)) {\n+            if (utils.isDeprecated(element)) {\n+                result.add(HtmlTree.SPAN(HtmlStyle.deprecatedLabel,\n+                        htmlWriter.getDeprecatedPhrase(element)));\n+                if (!deprs.isEmpty()) {\n+                    List<? extends DocTree> commentTrees = ch.getDescription(deprs.get(0));\n+                    if (!commentTrees.isEmpty()) {\n+                        result.add(tagletWriter.commentTagsToOutput(element, null, commentTrees, false));\n+                    }\n+                }\n+            }\n+        } else {\n+            if (utils.isDeprecated(element)) {\n+                result.add(HtmlTree.SPAN(HtmlStyle.deprecatedLabel,\n+                        htmlWriter.getDeprecatedPhrase(element)));\n+                if (!deprs.isEmpty()) {\n+                    List<? extends DocTree> bodyTrees = ch.getBody(deprs.get(0));\n+                    Content body = tagletWriter.commentTagsToOutput(element, null, bodyTrees, false);\n+                    if (!body.isEmpty())\n+                        result.add(HtmlTree.DIV(HtmlStyle.deprecationComment, body));\n+                }\n+            } else {\n+                Element ee = utils.getEnclosingTypeElement(element);\n+                if (utils.isDeprecated(ee)) {\n+                    result.add(HtmlTree.SPAN(HtmlStyle.deprecatedLabel,\n+                            htmlWriter.getDeprecatedPhrase(ee)));\n+                }\n+            }\n+        }\n+        return result;\n+\n+    }\n+\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/DeprecatedTaglet.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.EnumSet;\n+\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DocTree;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+\n+\/**\n+ * An inline taglet representing {@code {@docRoot}}.  This taglet is\n+ * used to get the relative path to the document's root output\n+ * directory.\n+ *\/\n+public class DocRootTaglet extends BaseTaglet {\n+    DocRootTaglet(HtmlConfiguration config) {\n+        super(config, DocTree.Kind.DOC_ROOT, true, EnumSet.allOf(Taglet.Location.class));\n+    }\n+\n+    @Override\n+    public Content getInlineTagOutput(Element holder, DocTree tag, TagletWriter tagletWriter) {\n+        var htmlWriter = tagletWriter.htmlWriter;\n+        var pathToRoot = htmlWriter.pathToRoot;\n+        return Text.of(pathToRoot.isEmpty() ? \".\" : pathToRoot.getPath());\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/DocRootTaglet.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -1,90 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html.taglets;\n-\n-import java.util.List;\n-\n-import javax.lang.model.element.Element;\n-\n-import com.sun.source.doctree.DeprecatedTree;\n-import com.sun.source.doctree.DocTree;\n-\n-import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.DeprecatedTaglet;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.TagletWriter;\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n-\n-public class HtmlDeprecatedTaglet extends DeprecatedTaglet {\n-    HtmlDeprecatedTaglet(HtmlConfiguration config) {\n-        super(config);\n-    }\n-\n-    @Override\n-    public Content getAllBlockTagOutput(Element element, TagletWriter tagletWriter) {\n-        var tw = (TagletWriterImpl) tagletWriter;\n-        var htmlWriter = tw.getHtmlWriter();\n-\n-        ContentBuilder result = new ContentBuilder();\n-        CommentHelper ch = utils.getCommentHelper(element);\n-        List<? extends DeprecatedTree> deprs = utils.getDeprecatedTrees(element);\n-        if (utils.isTypeElement(element)) {\n-            if (utils.isDeprecated(element)) {\n-                result.add(HtmlTree.SPAN(HtmlStyle.deprecatedLabel,\n-                        htmlWriter.getDeprecatedPhrase(element)));\n-                if (!deprs.isEmpty()) {\n-                    List<? extends DocTree> commentTrees = ch.getDescription(deprs.get(0));\n-                    if (!commentTrees.isEmpty()) {\n-                        result.add(tw.commentTagsToOutput(element, null, commentTrees, false));\n-                    }\n-                }\n-            }\n-        } else {\n-            if (utils.isDeprecated(element)) {\n-                result.add(HtmlTree.SPAN(HtmlStyle.deprecatedLabel,\n-                        tw.getHtmlWriter().getDeprecatedPhrase(element)));\n-                if (!deprs.isEmpty()) {\n-                    List<? extends DocTree> bodyTrees = ch.getBody(deprs.get(0));\n-                    Content body = tw.commentTagsToOutput(element, null, bodyTrees, false);\n-                    if (!body.isEmpty())\n-                        result.add(HtmlTree.DIV(HtmlStyle.deprecationComment, body));\n-                }\n-            } else {\n-                Element ee = utils.getEnclosingTypeElement(element);\n-                if (utils.isDeprecated(ee)) {\n-                    result.add(HtmlTree.SPAN(HtmlStyle.deprecatedLabel,\n-                            htmlWriter.getDeprecatedPhrase(ee)));\n-                }\n-            }\n-        }\n-        return result;\n-\n-    }\n-\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/HtmlDeprecatedTaglet.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html.taglets;\n-\n-import javax.lang.model.element.Element;\n-\n-import com.sun.source.doctree.DocTree;\n-\n-import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.DocRootTaglet;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.TagletWriter;\n-\n-public class HtmlDocRootTaglet extends DocRootTaglet {\n-    HtmlDocRootTaglet(HtmlConfiguration config) {\n-        super(config);\n-    }\n-\n-    @Override\n-    public Content getInlineTagOutput(Element holder, DocTree tag, TagletWriter tagletWriter) {\n-        var tw = (TagletWriterImpl) tagletWriter;\n-        var pathToRoot = tw.getHtmlWriter().pathToRoot;\n-        return Text.of(pathToRoot.isEmpty() ? \".\" : pathToRoot.getPath());\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/HtmlDocRootTaglet.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,68 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html.taglets;\n-\n-import javax.lang.model.element.Element;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.IndexTree;\n-import com.sun.source.doctree.TextTree;\n-\n-import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.IndexTaglet;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.TagletWriter;\n-\n-public class HtmlIndexTaglet extends IndexTaglet {\n-    HtmlIndexTaglet(HtmlConfiguration config) {\n-        super(config);\n-    }\n-\n-    @Override\n-    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter tagletWriter) {\n-        var indexTree = (IndexTree) tag;\n-        var tw = (TagletWriterImpl) tagletWriter;\n-\n-        DocTree searchTerm = indexTree.getSearchTerm();\n-        String tagText = (searchTerm instanceof TextTree tt) ? tt.getBody() : \"\";\n-        if (tagText.charAt(0) == '\"' && tagText.charAt(tagText.length() - 1) == '\"') {\n-            tagText = tagText.substring(1, tagText.length() - 1);\n-        }\n-        tagText = tagText.replaceAll(\"\\\\s+\", \" \");\n-\n-        Content desc = tw.getHtmlWriter().commentTagsToContent(element, indexTree.getDescription(), tw.getContext().within(indexTree));\n-        String descText = extractText(desc);\n-\n-        return tw.createAnchorAndSearchIndex(element, tagText, descText, tag);\n-    }\n-\n-\n-    \/\/ ugly but simple;\n-    \/\/ alternatives would be to walk the Content's tree structure, or to add new functionality to Content\n-    private String extractText(Content c) {\n-        return c.toString().replaceAll(\"<[^>]+>\", \"\");\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/HtmlIndexTaglet.java","additions":0,"deletions":68,"binary":false,"changes":68,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html.taglets;\n-\n-import javax.lang.model.element.Element;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.LiteralTree;\n-\n-import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.LiteralTaglet;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.TagletWriter;\n-\n-public class HtmlLiteralTaglet extends LiteralTaglet {\n-    HtmlLiteralTaglet(HtmlConfiguration config, DocTree.Kind tagKind) {\n-        super(config, tagKind);\n-    }\n-\n-    @Override\n-    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter tagletWriter) {\n-        var literalTree = (LiteralTree) tag;\n-        var body = Text.of(Text.normalizeNewlines(literalTree.getBody().getBody()));\n-        return tag.getKind() == DocTree.Kind.CODE ? HtmlTree.CODE(body) : body;\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/HtmlLiteralTaglet.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,79 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html.taglets;\n-\n-import java.util.List;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ElementKind;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.ParamTree;\n-\n-import jdk.javadoc.internal.doclets.formats.html.Contents;\n-import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n-import jdk.javadoc.internal.doclets.formats.html.HtmlIds;\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.ParamTaglet;\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n-\n-public class HtmlParamTaglet extends ParamTaglet {\n-    private final Contents contents;\n-\n-    HtmlParamTaglet(HtmlConfiguration config) {\n-        super(config);\n-        contents = config.contents;\n-    }\n-\n-    @Override\n-    public Content getParamHeader(ParamTaglet.ParamKind kind) {\n-        var header = switch (kind) {\n-            case PARAMETER -> contents.parameters;\n-            case TYPE_PARAMETER -> contents.typeParameters;\n-            case RECORD_COMPONENT -> contents.recordComponents;\n-        };\n-        return HtmlTree.DT(header);\n-    }\n-\n-    @Override\n-    public Content paramTagOutput(Element element, ParamTree paramTag, String paramName) {\n-        var body = new ContentBuilder();\n-        var tw = (TagletWriterImpl) tagletWriter;\n-        CommentHelper ch = utils.getCommentHelper(element);\n-        \/\/ define id attributes for state components so that generated descriptions may refer to them\n-        boolean defineID = (element.getKind() == ElementKind.RECORD)\n-                && !paramTag.isTypeParameter();\n-        Content nameContent = Text.of(paramName);\n-        body.add(HtmlTree.CODE(defineID ? HtmlTree.SPAN_ID(HtmlIds.forParam(paramName), nameContent) : nameContent));\n-        body.add(\" - \");\n-        List<? extends DocTree> description = ch.getDescription(paramTag);\n-        body.add(tw.getHtmlWriter().commentTagsToContent(element, description, tw.getContext().within(paramTag)));\n-        return HtmlTree.DD(body);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/HtmlParamTaglet.java","additions":0,"deletions":79,"binary":false,"changes":79,"status":"deleted"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html.taglets;\n-\n-import java.util.List;\n-\n-import javax.lang.model.element.Element;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.ReturnTree;\n-\n-import jdk.javadoc.internal.doclets.formats.html.Contents;\n-import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.ReturnTaglet;\n-\n-public class HtmlReturnTaglet extends ReturnTaglet {\n-    private final Contents contents;\n-\n-    HtmlReturnTaglet(HtmlConfiguration config) {\n-        super(config);\n-        contents = config.contents;\n-    }\n-\n-    @Override\n-    public Content returnTagOutput(Element element, ReturnTree returnTag, boolean inline) {\n-        var tw = (TagletWriterImpl) tagletWriter;\n-        var ch = utils.getCommentHelper(element);\n-        List<? extends DocTree> desc = ch.getDescription(returnTag);\n-        Content content = tw.getHtmlWriter().commentTagsToContent(element, desc, tw.getContext().within(returnTag));\n-        return inline\n-                ? new ContentBuilder(contents.getContent(\"doclet.Returns_0\", content))\n-                : new ContentBuilder(HtmlTree.DT(contents.returns), HtmlTree.DD(content));\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/HtmlReturnTaglet.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -1,159 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html.taglets;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Optional;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.SeeTree;\n-\n-import jdk.javadoc.internal.doclets.formats.html.ClassWriterImpl;\n-import jdk.javadoc.internal.doclets.formats.html.Contents;\n-import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n-import jdk.javadoc.internal.doclets.formats.html.HtmlDocletWriter;\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.builders.SerializedFormBuilder;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.SeeTaglet;\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocLink;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocPath;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;\n-\n-public class HtmlSeeTaglet extends SeeTaglet {\n-    HtmlSeeTaglet(HtmlConfiguration config) {\n-        super(config);\n-        contents = config.contents;\n-    }\n-\n-    private final Contents contents;\n-    private HtmlDocletWriter htmlWriter;\n-\n-    @Override\n-    public Content seeTagOutput(Element holder, List<? extends SeeTree> seeTags) {\n-        var tw = (TagletWriterImpl) tagletWriter;\n-        htmlWriter = tw.getHtmlWriter();\n-\n-        List<Content> links = new ArrayList<>();\n-        for (SeeTree dt : seeTags) {\n-            links.add(seeTagOutput(holder, dt));\n-        }\n-        if (utils.isVariableElement(holder) && ((VariableElement)holder).getConstantValue() != null &&\n-                htmlWriter instanceof ClassWriterImpl classWriter) {\n-            \/\/Automatically add link to constant values page for constant fields.\n-            DocPath constantsPath =\n-                    htmlWriter.pathToRoot.resolve(DocPaths.CONSTANT_VALUES);\n-            String whichConstant =\n-                    classWriter.getTypeElement().getQualifiedName() + \".\" +\n-                            utils.getSimpleName(holder);\n-            DocLink link = constantsPath.fragment(whichConstant);\n-            links.add(htmlWriter.links.createLink(link,\n-                    contents.getContent(\"doclet.Constants_Summary\")));\n-        }\n-        if (utils.isClass(holder) && utils.isSerializable((TypeElement)holder)) {\n-            \/\/Automatically add link to serialized form page for serializable classes.\n-            if (SerializedFormBuilder.serialInclude(utils, holder) &&\n-                    SerializedFormBuilder.serialInclude(utils, utils.containingPackage(holder))) {\n-                DocPath serialPath = htmlWriter.pathToRoot.resolve(DocPaths.SERIALIZED_FORM);\n-                DocLink link = serialPath.fragment(utils.getFullyQualifiedName(holder));\n-                links.add(htmlWriter.links.createLink(link,\n-                        contents.getContent(\"doclet.Serialized_Form\")));\n-            }\n-        }\n-        if (links.isEmpty()) {\n-            return Text.EMPTY;\n-        }\n-\n-        var seeList = tw.tagList(links);\n-        return new ContentBuilder(\n-                HtmlTree.DT(contents.seeAlso),\n-                HtmlTree.DD(seeList));\n-    }\n-\n-\/\/    private boolean isLongOrHasComma(Content c) {\n-\/\/        String s = c.toString()\n-\/\/                .replaceAll(\"<.*?>\", \"\")              \/\/ ignore HTML\n-\/\/                .replaceAll(\"&#?[A-Za-z0-9]+;\", \" \")  \/\/ entities count as a single character\n-\/\/                .replaceAll(\"\\\\R\", \"\\n\");             \/\/ normalize newlines\n-\/\/        return s.length() > TAG_LIST_ITEM_MAX_INLINE_LENGTH || s.contains(\",\");\n-\/\/    }\n-\n-    \/**\n-     * {@return the output for a single {@code @see} tag}\n-     *\n-     * @param element the element that has the documentation comment containing this tag\n-     * @param seeTag  the tag\n-     *\/\n-    private Content seeTagOutput(Element element, SeeTree seeTag) {\n-\n-        List<? extends DocTree> ref = seeTag.getReference();\n-        assert !ref.isEmpty();\n-        DocTree ref0 = ref.get(0);\n-        switch (ref0.getKind()) {\n-            case TEXT, START_ELEMENT -> {\n-                \/\/ @see \"Reference\"\n-                \/\/ @see <a href=\"...\">...<\/a>\n-                return htmlWriter.commentTagsToContent(element, ref, false, false);\n-            }\n-\n-            case REFERENCE -> {\n-                \/\/ @see reference label...\n-                CommentHelper ch = utils.getCommentHelper(element);\n-                String refSignature = ch.getReferencedSignature(ref0);\n-                List<? extends DocTree> label = ref.subList(1, ref.size());\n-\n-                var lt = (HtmlLinkTaglet) config.tagletManager.getTaglet(DocTree.Kind.LINK);\n-                return lt.linkSeeReferenceOutput(element,\n-                        seeTag,\n-                        refSignature,\n-                        ch.getReferencedElement(seeTag),\n-                        false,\n-                        htmlWriter.commentTagsToContent(element, label, tagletWriter.getContext().within(seeTag)),\n-                        (key, args) -> messages.warning(ch.getDocTreePath(seeTag), key, args),\n-                        tagletWriter\n-                );\n-            }\n-\n-            case ERRONEOUS -> {\n-                return tagletWriter.invalidTagOutput(resources.getText(\"doclet.tag.invalid_input\",\n-                                ref0.toString()),\n-                        Optional.empty());\n-            }\n-\n-            default -> throw new IllegalStateException(ref0.getKind().toString());\n-        }\n-\n-    }\n-\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/HtmlSeeTaglet.java","additions":0,"deletions":159,"binary":false,"changes":159,"status":"deleted"},{"patch":"@@ -1,158 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html.taglets;\n-\n-import java.util.EnumSet;\n-import java.util.List;\n-import java.util.Set;\n-\n-import javax.lang.model.element.Element;\n-\n-import com.sun.source.doctree.DocTree;\n-\n-import jdk.javadoc.doclet.Taglet;\n-import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.SimpleTaglet;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.TagletWriter;\n-\n-public class HtmlSimpleTaglet extends SimpleTaglet {\n-\n-\n-    \/**\n-     * Constructs a {@code HtmlSimpleTaglet}.\n-     *\n-     * @param tagName   the name of this tag\n-     * @param header    the header to output\n-     * @param locations the possible locations that this tag can appear in\n-     *                  The string can contain 'p' for package, 't' for type,\n-     *                  'm' for method, 'c' for constructor and 'f' for field.\n-     *                  See {@link #getLocations(String) getLocations} for the\n-     *                  complete list.\n-     *\/\n-    HtmlSimpleTaglet(HtmlConfiguration config, String tagName, String header, String locations) {\n-        super(config, tagName, header, getLocations(locations), isEnabled(locations));\n-    }\n-\n-    \/**\n-     * Constructs a {@code HtmlSimpleTaglet}.\n-     *\n-     * @param tagKind   the kind of this tag\n-     * @param header    the header to output\n-     * @param locations the possible locations that this tag can appear in\n-     *\/\n-    HtmlSimpleTaglet(HtmlConfiguration config, DocTree.Kind tagKind, String header, Set<Taglet.Location> locations) {\n-        super(config, tagKind, header, locations, true);\n-    }\n-\n-    \/**\n-     * Constructs a {@code HtmlSimpleTaglet}.\n-     *\n-     * @param tagName   the name of this tag\n-     * @param header    the header to output\n-     * @param locations the possible locations that this tag can appear in\n-     *\/\n-    HtmlSimpleTaglet(HtmlConfiguration config, String tagName, String header, Set<Taglet.Location> locations) {\n-        super(config, tagName, header, locations, true);\n-    }\n-\n-    \/**\n-     * Constructs a {@code HtmlSimpleTaglet}.\n-     *\n-     * @param tagKind   the kind of this tag\n-     * @param header    the header to output\n-     * @param locations the possible locations that this tag can appear in\n-     *\/\n-    HtmlSimpleTaglet(HtmlConfiguration config, DocTree.Kind tagKind, String header, Set<Taglet.Location> locations, boolean enabled) {\n-        super(config, tagKind, header, locations, enabled);\n-    }\n-\n-    private static Set<Taglet.Location> getLocations(String locations) {\n-        Set<Taglet.Location> set = EnumSet.noneOf(Taglet.Location.class);\n-        for (int i = 0; i < locations.length(); i++) {\n-            switch (locations.charAt(i)) {\n-                case 'a':  case 'A':\n-                    return EnumSet.allOf(Taglet.Location.class);\n-                case 'c':  case 'C':\n-                    set.add(Taglet.Location.CONSTRUCTOR);\n-                    break;\n-                case 'f':  case 'F':\n-                    set.add(Taglet.Location.FIELD);\n-                    break;\n-                case 'm':  case 'M':\n-                    set.add(Taglet.Location.METHOD);\n-                    break;\n-                case 'o':  case 'O':\n-                    set.add(Taglet.Location.OVERVIEW);\n-                    break;\n-                case 'p':  case 'P':\n-                    set.add(Taglet.Location.PACKAGE);\n-                    break;\n-                case 's':  case 'S':        \/\/ super-packages, anyone?\n-                    set.add(Taglet.Location.MODULE);\n-                    break;\n-                case 't':  case 'T':\n-                    set.add(Taglet.Location.TYPE);\n-                    break;\n-                case 'x':  case 'X':\n-                    break;\n-            }\n-        }\n-        return set;\n-    }\n-\n-    private static boolean isEnabled(String locations) {\n-        return locations.matches(\"[^Xx]*\");\n-    }\n-\n-    @Override\n-    public Content simpleBlockTagOutput(Element element,\n-                                        List<? extends DocTree> simpleTags,\n-                                        String header,\n-                                        TagletWriter writer) {\n-        TagletWriterImpl tw = (TagletWriterImpl) writer;\n-        var ch = utils.getCommentHelper(element);\n-        var htmlWriter = tw.getHtmlWriter();\n-        var context = tw.getContext();\n-\n-        ContentBuilder body = new ContentBuilder();\n-        boolean many = false;\n-        for (DocTree simpleTag : simpleTags) {\n-            if (many) {\n-                body.add(\", \");\n-            }\n-            List<? extends DocTree> bodyTags = ch.getBody(simpleTag);\n-            body.add(htmlWriter.commentTagsToContent(element, bodyTags, context.within(simpleTag)));\n-            many = true;\n-        }\n-        return new ContentBuilder(\n-                HtmlTree.DT(RawHtml.of(header)),\n-                HtmlTree.DD(body));\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/HtmlSimpleTaglet.java","additions":0,"deletions":158,"binary":false,"changes":158,"status":"deleted"},{"patch":"@@ -1,161 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html.taglets;\n-\n-import java.util.HashSet;\n-import java.util.Set;\n-\n-import javax.lang.model.element.Element;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.SnippetTree;\n-import com.sun.source.util.DocTreePath;\n-\n-import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlAttr;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.SnippetTaglet;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.Style;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.StyledText;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-public class HtmlSnippetTaglet extends SnippetTaglet {\n-    HtmlSnippetTaglet(HtmlConfiguration config) {\n-        super(config);\n-    }\n-\n-    @Override\n-    protected Content snippetTagOutput(Element element, SnippetTree tag, StyledText content,\n-                                       String id, String lang) {\n-        var tw = (TagletWriterImpl) tagletWriter;\n-        var pre = new HtmlTree(TagName.PRE).setStyle(HtmlStyle.snippet);\n-        if (id != null && !id.isBlank()) {\n-            pre.put(HtmlAttr.ID, id);\n-        }\n-        var code = new HtmlTree(TagName.CODE)\n-                .addUnchecked(Text.EMPTY); \/\/ Make sure the element is always rendered\n-        if (lang != null && !lang.isBlank()) {\n-            code.addStyle(\"language-\" + lang);\n-        }\n-\n-        content.consumeBy((styles, sequence) -> {\n-            CharSequence text = Text.normalizeNewlines(sequence);\n-            if (styles.isEmpty()) {\n-                code.add(text);\n-            } else {\n-                Element e = null;\n-                String t = null;\n-                boolean linkEncountered = false;\n-                boolean markupEncountered = false;\n-                Set<String> classes = new HashSet<>();\n-                for (Style s : styles) {\n-                    if (s instanceof Style.Name n) {\n-                        classes.add(n.name());\n-                    } else if (s instanceof Style.Link l) {\n-                        assert !linkEncountered; \/\/ TODO: do not assert; pick the first link report on subsequent\n-                        linkEncountered = true;\n-                        t = l.target();\n-                        e = getLinkedElement(element, t);\n-                        if (e == null) {\n-                            \/\/ TODO: diagnostic output\n-                        }\n-                    } else if (s instanceof Style.Markup) {\n-                        markupEncountered = true;\n-                        break;\n-                    } else {\n-                        \/\/ TODO: transform this if...else into an exhaustive\n-                        \/\/ switch over the sealed Style hierarchy when \"Pattern\n-                        \/\/ Matching for switch\" has been implemented (JEP 406\n-                        \/\/ and friends)\n-                        throw new AssertionError(styles);\n-                    }\n-                }\n-                Content c;\n-                if (markupEncountered) {\n-                    return;\n-                } else if (linkEncountered) {\n-                    assert e != null;\n-                    \/\/disable preview tagging inside the snippets:\n-                    Utils.PreviewFlagProvider prevPreviewProvider = utils.setPreviewFlagProvider(el -> false);\n-                    try {\n-                        var lt = (HtmlLinkTaglet) config.tagletManager.getTaglet(DocTree.Kind.LINK);\n-                        c = lt.linkSeeReferenceOutput(element,\n-                                null,\n-                                t,\n-                                e,\n-                                false, \/\/ TODO: for now\n-                                Text.of(sequence.toString()),\n-                                (key, args) -> { \/* TODO: report diagnostic *\/ },\n-                                tagletWriter);\n-                    } finally {\n-                        utils.setPreviewFlagProvider(prevPreviewProvider);\n-                    }\n-                } else {\n-                    c = HtmlTree.SPAN(Text.of(text));\n-                    classes.forEach(((HtmlTree) c)::addStyle);\n-                }\n-                code.add(c);\n-            }\n-        });\n-        String copyText = resources.getText(\"doclet.Copy_to_clipboard\");\n-        String copiedText = resources.getText(\"doclet.Copied_to_clipboard\");\n-        String copySnippetText = resources.getText(\"doclet.Copy_snippet_to_clipboard\");\n-        var snippetContainer = HtmlTree.DIV(HtmlStyle.snippetContainer,\n-                new HtmlTree(TagName.BUTTON)\n-                        .add(HtmlTree.SPAN(Text.of(copyText))\n-                                .put(HtmlAttr.DATA_COPIED, copiedText))\n-                        .add(new HtmlTree(TagName.IMG)\n-                                .put(HtmlAttr.SRC, tw.getHtmlWriter().pathToRoot.resolve(DocPaths.CLIPBOARD_SVG).getPath())\n-                                .put(HtmlAttr.ALT, copySnippetText))\n-                        .addStyle(HtmlStyle.copy)\n-                        .addStyle(HtmlStyle.snippetCopy)\n-                        .put(HtmlAttr.ARIA_LABEL, copySnippetText)\n-                        .put(HtmlAttr.ONCLICK, \"copySnippet(this)\"));\n-        return snippetContainer.add(pre.add(code));\n-    }\n-\n-    \/*\n-     * Returns the element that is linked from the context of the referrer using\n-     * the provided signature; returns null if such element could not be found.\n-     *\n-     * This method is to be used when it is the target of the link that is\n-     * important, not the container of the link (e.g. was it an @see,\n-     * @link\/@linkplain or @snippet tags, etc.)\n-     *\/\n-    public Element getLinkedElement(Element referer, String signature) {\n-        var factory = utils.docTrees.getDocTreeFactory();\n-        var docCommentTree = utils.getDocCommentTree(referer);\n-        var rootPath = new DocTreePath(utils.getTreePath(referer), docCommentTree);\n-        var reference = factory.newReferenceTree(signature);\n-        var fabricatedPath = new DocTreePath(rootPath, reference);\n-        return utils.docTrees.getElement(fabricatedPath);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/HtmlSnippetTaglet.java","additions":0,"deletions":161,"binary":false,"changes":161,"status":"deleted"},{"patch":"@@ -1,126 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html.taglets;\n-\n-import java.net.URI;\n-import java.net.URISyntaxException;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-import javax.lang.model.element.Element;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.SpecTree;\n-import com.sun.source.doctree.TextTree;\n-import com.sun.source.util.DocTreePath;\n-\n-import jdk.javadoc.internal.doclets.formats.html.Contents;\n-import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.SpecTaglet;\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n-\n-public class HtmlSpecTaglet extends SpecTaglet {\n-\n-    private final Contents contents;\n-\n-    HtmlSpecTaglet(HtmlConfiguration config) {\n-        super(config);\n-        this.contents = config.contents;\n-    }\n-\n-    @Override\n-    public Content specTagOutput(Element holder, List<? extends SpecTree> specTags) {\n-        if (specTags.isEmpty()) {\n-            return Text.EMPTY;\n-        }\n-\n-        var tw = (TagletWriterImpl) tagletWriter;\n-\n-        var links = specTags.stream()\n-                .map(st -> specTagToContent(holder, st)).toList();\n-\n-        var specList = tw.tagList(links);\n-        return new ContentBuilder(\n-                HtmlTree.DT(contents.externalSpecifications),\n-                HtmlTree.DD(specList));\n-    }\n-\n-    private Content specTagToContent(Element holder, SpecTree specTree) {\n-        TagletWriterImpl tw = (TagletWriterImpl) tagletWriter;\n-        String specTreeURL = specTree.getURL().getBody();\n-        List<? extends DocTree> specTreeLabel = specTree.getTitle();\n-        Content label = tw.getHtmlWriter().commentTagsToContent(holder, specTreeLabel, tagletWriter.context.isFirstSentence);\n-        return getExternalSpecContent(holder, specTree, specTreeURL,\n-                textOf(specTreeLabel).replaceAll(\"\\\\s+\", \" \"), label,\n-                tw);\n-    }\n-\n-    private String textOf(List<? extends DocTree> trees) {\n-        return trees.stream()\n-                .filter(dt -> dt instanceof TextTree)\n-                .map(dt -> ((TextTree) dt).getBody().trim())\n-                .collect(Collectors.joining(\" \"));\n-    }\n-\n-    Content getExternalSpecContent(Element holder, DocTree docTree, String url, String searchText, Content title, TagletWriterImpl w) {\n-        URI specURI;\n-        try {\n-            \/\/ Use the canonical title of the spec if one is available\n-            specURI = new URI(url);\n-        } catch (URISyntaxException e) {\n-            CommentHelper ch = utils.getCommentHelper(holder);\n-            DocTreePath dtp = ch.getDocTreePath(docTree);\n-            w.getHtmlWriter().messages.error(dtp, \"doclet.Invalid_URL\", e.getMessage());\n-            specURI = null;\n-        }\n-\n-        Content titleWithAnchor = w.createAnchorAndSearchIndex(holder,\n-                searchText,\n-                title,\n-                resources.getText(\"doclet.External_Specification\"),\n-                docTree);\n-\n-        if (specURI == null) {\n-            return titleWithAnchor;\n-        } else {\n-            return HtmlTree.A(w.getHtmlWriter().resolveExternalSpecURI(specURI), titleWithAnchor);\n-        }\n-\n-    }\n-\n-\n-\/\/    private boolean isLongOrHasComma(Content c) {\n-\/\/        String s = c.toString()\n-\/\/                .replaceAll(\"<.*?>\", \"\")              \/\/ ignore HTML\n-\/\/                .replaceAll(\"&#?[A-Za-z0-9]+;\", \" \")  \/\/ entities count as a single character\n-\/\/                .replaceAll(\"\\\\R\", \"\\n\");             \/\/ normalize newlines\n-\/\/        return s.length() > TAG_LIST_ITEM_MAX_INLINE_LENGTH || s.contains(\",\");\n-\/\/    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/HtmlSpecTaglet.java","additions":0,"deletions":126,"binary":false,"changes":126,"status":"deleted"},{"patch":"@@ -1,25 +0,0 @@\n-package jdk.javadoc.internal.doclets.formats.html.taglets;\n-\n-import javax.lang.model.element.Element;\n-\n-import com.sun.source.doctree.SystemPropertyTree;\n-\n-import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.SystemPropertyTaglet;\n-\n-public class HtmlSystemPropertyTaglet extends SystemPropertyTaglet {\n-    HtmlSystemPropertyTaglet(HtmlConfiguration config) {\n-        super(config);\n-    }\n-\n-\n-    @Override\n-    protected Content systemPropertyTagOutput(Element element, SystemPropertyTree tag) {\n-        TagletWriterImpl tw = (TagletWriterImpl) tagletWriter;\n-        String tagText = tag.getPropertyName().toString();\n-        return HtmlTree.CODE(tw.createAnchorAndSearchIndex(element, tagText,\n-                resources.getText(\"doclet.System_Property\"), tag));\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/HtmlSystemPropertyTaglet.java","additions":0,"deletions":25,"binary":false,"changes":25,"status":"deleted"},{"patch":"@@ -1,144 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html.taglets;\n-\n-import java.util.EnumSet;\n-\n-import com.sun.source.doctree.DocTree;\n-\n-import jdk.javadoc.doclet.Taglet;\n-import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.Resources;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.BaseTaglet;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.InheritDocTaglet;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.SummaryTaglet;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.TagletManager;\n-\n-import static com.sun.source.doctree.DocTree.Kind.AUTHOR;\n-import static com.sun.source.doctree.DocTree.Kind.EXCEPTION;\n-import static com.sun.source.doctree.DocTree.Kind.HIDDEN;\n-import static com.sun.source.doctree.DocTree.Kind.PROVIDES;\n-import static com.sun.source.doctree.DocTree.Kind.SERIAL;\n-import static com.sun.source.doctree.DocTree.Kind.SERIAL_DATA;\n-import static com.sun.source.doctree.DocTree.Kind.SERIAL_FIELD;\n-import static com.sun.source.doctree.DocTree.Kind.SINCE;\n-import static com.sun.source.doctree.DocTree.Kind.USES;\n-import static com.sun.source.doctree.DocTree.Kind.VERSION;\n-\n-public class HtmlTagletManager extends TagletManager {\n-    private final HtmlConfiguration config;\n-    private final Resources resources;\n-\n-    public HtmlTagletManager(HtmlConfiguration config) {\n-        super(config);\n-        this.config = config;\n-        resources = config.docResources;\n-        initStandardTaglets();\n-    }\n-\n-    \/**\n-     * Initialize standard Javadoc tags for ordering purposes.\n-     *\/\n-    private void initStandardTaglets() {\n-        if (javafx) {\n-            initJavaFXTaglets();\n-        }\n-\n-        addStandardTaglet(new HtmlParamTaglet(config));\n-        addStandardTaglet(new HtmlReturnTaglet(config));\n-        addStandardTaglet(new HtmlThrowsTaglet(config), EXCEPTION);\n-        addStandardTaglet(\n-                new HtmlSimpleTaglet(config, SINCE, resources.getText(\"doclet.Since\"),\n-                        EnumSet.allOf(Taglet.Location.class), !nosince));\n-        addStandardTaglet(\n-                new HtmlSimpleTaglet(config, VERSION, resources.getText(\"doclet.Version\"),\n-                        EnumSet.of(Taglet.Location.OVERVIEW, Taglet.Location.MODULE, Taglet.Location.PACKAGE, Taglet.Location.TYPE), showversion));\n-        addStandardTaglet(\n-                new HtmlSimpleTaglet(config, AUTHOR, resources.getText(\"doclet.Author\"),\n-                        EnumSet.of(Taglet.Location.OVERVIEW, Taglet.Location.MODULE, Taglet.Location.PACKAGE, Taglet.Location.TYPE), showauthor));\n-        addStandardTaglet(\n-                new HtmlSimpleTaglet(config, SERIAL_DATA, resources.getText(\"doclet.SerialData\"),\n-                        EnumSet.noneOf(Taglet.Location.class)));\n-        addStandardTaglet(\n-                new HtmlSimpleTaglet(config, HIDDEN, null,\n-                        EnumSet.of(Taglet.Location.TYPE, Taglet.Location.METHOD, Taglet.Location.FIELD)));\n-\n-        \/\/ This appears to be a default custom (non-standard) taglet\n-        jdk.javadoc.internal.doclets.toolkit.taglets.Taglet factoryTaglet =\n-                new HtmlSimpleTaglet(config, \"factory\", resources.getText(\"doclet.Factory\"),\n-                        EnumSet.of(Taglet.Location.METHOD));\n-        allTaglets.put(factoryTaglet.getName(), factoryTaglet);\n-\n-        addStandardTaglet(new HtmlSeeTaglet(config));\n-        addStandardTaglet(new HtmlSpecTaglet(config));\n-\n-        \/\/ Standard inline tags\n-        addStandardTaglet(new HtmlDocRootTaglet(config));\n-        addStandardTaglet(new InheritDocTaglet(config));\n-        addStandardTaglet(new HtmlValueTaglet(config));\n-        addStandardTaglet(new HtmlLinkTaglet(config, DocTree.Kind.LINK));\n-        addStandardTaglet(new HtmlLinkTaglet(config, DocTree.Kind.LINK_PLAIN));\n-        addStandardTaglet(new HtmlLiteralTaglet(config, DocTree.Kind.CODE));\n-        addStandardTaglet(new HtmlLiteralTaglet(config, DocTree.Kind.LITERAL));\n-        addStandardTaglet(new HtmlSnippetTaglet(config));\n-        addStandardTaglet(new HtmlIndexTaglet(config));\n-        addStandardTaglet(new SummaryTaglet(config));\n-        addStandardTaglet(new HtmlSystemPropertyTaglet(config));\n-\n-        \/\/ Keep track of the names of standard tags for error checking purposes.\n-        \/\/ The following are not handled above.\n-        addStandardTaglet(new HtmlDeprecatedTaglet(config));\n-        addStandardTaglet(new BaseTaglet(config, USES, false, EnumSet.of(Taglet.Location.MODULE)));\n-        addStandardTaglet(new BaseTaglet(config, PROVIDES, false, EnumSet.of(Taglet.Location.MODULE)));\n-        addStandardTaglet(\n-                new HtmlSimpleTaglet(config, SERIAL, null,\n-                        EnumSet.of(Taglet.Location.PACKAGE, Taglet.Location.TYPE, Taglet.Location.FIELD)));\n-        addStandardTaglet(\n-                new HtmlSimpleTaglet(config, SERIAL_FIELD, null, EnumSet.of(Taglet.Location.FIELD)));\n-    }\n-\n-    \/**\n-     * Initialize JavaFX-related tags.\n-     *\/\n-    private void initJavaFXTaglets() {\n-        addStandardTaglet(new HtmlSimpleTaglet(config, \"propertyDescription\",\n-                resources.getText(\"doclet.PropertyDescription\"),\n-                EnumSet.of(Taglet.Location.METHOD, Taglet.Location.FIELD)));\n-        addStandardTaglet(new HtmlSimpleTaglet(config, \"defaultValue\", resources.getText(\"doclet.DefaultValue\"),\n-                EnumSet.of(Taglet.Location.METHOD, Taglet.Location.FIELD)));\n-        addStandardTaglet(new HtmlSimpleTaglet(config, \"treatAsPrivate\", null,\n-                EnumSet.of(Taglet.Location.TYPE, Taglet.Location.METHOD, Taglet.Location.FIELD)));\n-    }\n-\n-    @Override\n-    protected jdk.javadoc.internal.doclets.toolkit.taglets.Taglet wrapTaglet(Taglet instance) {\n-        return new UserTaglet(instance);\n-    }\n-\n-    protected jdk.javadoc.internal.doclets.toolkit.taglets.Taglet newSimpleTaglet(String tagName, String header, String locations) {\n-        return new HtmlSimpleTaglet(config, tagName, header, locations);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/HtmlTagletManager.java","additions":0,"deletions":144,"binary":false,"changes":144,"status":"deleted"},{"patch":"@@ -1,44 +0,0 @@\n-package jdk.javadoc.internal.doclets.formats.html.taglets;\n-\n-import java.util.Optional;\n-\n-import javax.lang.model.type.TypeMirror;\n-\n-import jdk.javadoc.internal.doclets.formats.html.Contents;\n-import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n-import jdk.javadoc.internal.doclets.formats.html.HtmlLinkInfo;\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.ThrowsTaglet;\n-\n-public class HtmlThrowsTaglet extends ThrowsTaglet {\n-    private final HtmlConfiguration config;\n-    private final Contents contents;\n-\n-    HtmlThrowsTaglet(HtmlConfiguration config) {\n-        super(config);\n-        this.config = config;\n-        contents = config.contents;\n-    }\n-\n-\n-    @Override\n-    public Content getThrowsHeader() {\n-        return HtmlTree.DT(contents.throws_);\n-    }\n-\n-\n-    @Override\n-    public Content throwsTagOutput(TypeMirror throwsType, Optional<Content> content) {\n-        var tw = (TagletWriterImpl) tagletWriter;\n-        var linkInfo = new HtmlLinkInfo(config, HtmlLinkInfo.Kind.PLAIN, throwsType);\n-        var link = tw.getHtmlWriter().getLink(linkInfo);\n-        var concat = new ContentBuilder(HtmlTree.CODE(link));\n-        if (content.isPresent()) {\n-            concat.add(\" - \");\n-            concat.add(content.get());\n-        }\n-        return HtmlTree.DD(concat);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/HtmlThrowsTaglet.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -1,24 +0,0 @@\n-package jdk.javadoc.internal.doclets.formats.html.taglets;\n-\n-import javax.lang.model.element.VariableElement;\n-\n-import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n-import jdk.javadoc.internal.doclets.formats.html.HtmlLinkInfo;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.ValueTaglet;\n-\n-public class HtmlValueTaglet extends ValueTaglet {\n-    HtmlValueTaglet(HtmlConfiguration config) {\n-        super(config);\n-    }\n-\n-\n-    @Override\n-    public Content valueTagOutput(VariableElement field, String constantVal, boolean includeLink) {\n-        TagletWriterImpl tw = (TagletWriterImpl) tagletWriter;\n-        return includeLink\n-                ? tw.getHtmlWriter().getDocLink(HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS, field, constantVal)\n-                : Text.of(constantVal);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/HtmlValueTaglet.java","additions":0,"deletions":24,"binary":false,"changes":24,"status":"deleted"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.EnumSet;\n+\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.IndexTree;\n+import com.sun.source.doctree.TextTree;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+\n+\/**\n+ * An inline taglet used to index a word or a phrase.\n+ * The enclosed text is interpreted as not containing HTML markup or\n+ * nested javadoc tags.\n+ *\/\n+public class IndexTaglet extends BaseTaglet {\n+    IndexTaglet(HtmlConfiguration config) {\n+        super(config, DocTree.Kind.INDEX, true, EnumSet.allOf(Taglet.Location.class));\n+    }\n+\n+    @Override\n+    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter tagletWriter) {\n+        var context = tagletWriter.context;\n+        var indexTree = (IndexTree) tag;\n+\n+        DocTree searchTerm = indexTree.getSearchTerm();\n+        String tagText = (searchTerm instanceof TextTree tt) ? tt.getBody() : \"\";\n+        if (tagText.charAt(0) == '\"' && tagText.charAt(tagText.length() - 1) == '\"') {\n+            tagText = tagText.substring(1, tagText.length() - 1);\n+        }\n+        tagText = tagText.replaceAll(\"\\\\s+\", \" \");\n+\n+        Content desc = tagletWriter.htmlWriter.commentTagsToContent(element, indexTree.getDescription(), context.within(indexTree));\n+        String descText = extractText(desc);\n+\n+        return tagletWriter.createAnchorAndSearchIndex(element, tagText, descText, tag);\n+    }\n+\n+\n+    \/\/ ugly but simple;\n+    \/\/ alternatives would be to walk the Content's tree structure, or to add new functionality to Content\n+    private String extractText(Content c) {\n+        return c.toString().replaceAll(\"<[^>]+>\", \"\");\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/IndexTaglet.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n@@ -41,1 +41,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n@@ -57,1 +57,1 @@\n-    public InheritDocTaglet(BaseConfiguration config) {\n+    public InheritDocTaglet(HtmlConfiguration config) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/InheritDocTaglet.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/InheritDocTaglet.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/InheritableTaglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/InheritableTaglet.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.EnumSet;\n@@ -44,0 +45,1 @@\n+import jdk.javadoc.doclet.Taglet;\n@@ -50,2 +52,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.taglets.LinkTaglet;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.TagletWriter;\n@@ -60,3 +60,8 @@\n-public class HtmlLinkTaglet extends LinkTaglet {\n-    HtmlLinkTaglet(HtmlConfiguration config, DocTree.Kind tagKind) {\n-        super(config, tagKind);\n+\/**\n+ * A taglet that represents the {@code {@link ...}} and {@linkplain ...} tags,\n+ * with support for links to program elements in {@code @see} and\n+ * {@code {@snippet ...}} tags.\n+ *\/\n+public class LinkTaglet extends BaseTaglet {\n+    LinkTaglet(HtmlConfiguration config, DocTree.Kind tagKind) {\n+        super(config, tagKind, true, EnumSet.allOf(Taglet.Location.class));\n@@ -67,0 +72,1 @@\n+        this.tagletWriter = tagletWriter;\n@@ -68,1 +74,0 @@\n-        var tw = (TagletWriterImpl) tagletWriter;\n@@ -70,1 +75,2 @@\n-        var context = tw.getContext();\n+        var context = tagletWriter.context;\n+        var htmlWriter = tagletWriter.htmlWriter;\n@@ -78,1 +84,1 @@\n-            Content label = tw.getHtmlWriter().commentTagsToContent(element, linkTree.getLabel(), context.within(linkTree));\n+            Content label = htmlWriter.commentTagsToContent(element, linkTree.getLabel(), context.within(linkTree));\n@@ -100,1 +106,1 @@\n-                tw.getHtmlWriter().commentTagsToContent(element, linkTree.getLabel(), context.within(linkTree)),\n+                htmlWriter.commentTagsToContent(element, linkTree.getLabel(), context.within(linkTree)),\n@@ -119,0 +125,1 @@\n+     * @param tagletWriter  the writer providing the context for this call\n@@ -129,4 +136,3 @@\n-                                   TagletWriter writer) {\n-        var config = (HtmlConfiguration) this.config;\n-        var tw = (TagletWriterImpl) writer;\n-        var htmlWriter = tw.getHtmlWriter();\n+                                   TagletWriter tagletWriter) {\n+        var config = tagletWriter.configuration;\n+        var htmlWriter = tagletWriter.htmlWriter;\n@@ -152,1 +158,1 @@\n-                return writer.invalidTagOutput(resources.getText(\"doclet.link.see.no_label\"),\n+                return tagletWriter.invalidTagOutput(resources.getText(\"doclet.link.see.no_label\"),\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/LinkTaglet.java","additions":21,"deletions":15,"binary":false,"changes":36,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/HtmlLinkTaglet.java","status":"renamed"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.EnumSet;\n+\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.LiteralTree;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+\n+\/**\n+ * An inline taglet used to denote literal text, possibly in monospace font.\n+ *\n+ * For example, the text:\n+ * <blockquote>  {@code {@literal a<B>c}}  <\/blockquote>\n+ * displays as:\n+ * <blockquote>  {@literal a<B>c}  <\/blockquote>\n+ *\n+ * <p> The tag {@code {@code ...}} is equivalent to\n+ * {@code <code>{@literal ...}<\/code>}.\n+ *\n+ * For example, the text:\n+ * <blockquote>  The type {@code {@code List<P>}}  <\/blockquote>\n+ * displays as:\n+ * <blockquote>  The type {@code List<P>}  <\/blockquote>\n+ *\/\n+public class LiteralTaglet extends BaseTaglet {\n+    LiteralTaglet(HtmlConfiguration config, DocTree.Kind tagKind) {\n+        super(config, tagKind, true, EnumSet.allOf(Taglet.Location.class));\n+    }\n+\n+    @Override\n+    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter tagletWriter) {\n+        var literalTree = (LiteralTree) tag;\n+        var body = Text.of(Text.normalizeNewlines(literalTree.getBody().getBody()));\n+        return tag.getKind() == DocTree.Kind.CODE ? HtmlTree.CODE(body) : body;\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/LiteralTaglet.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,316 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.ParamTree;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.Contents;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlIds;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+\n+\/**\n+ * A taglet that represents the {@code @param} tag.\n+ *\/\n+public class ParamTaglet extends BaseTaglet implements InheritableTaglet {\n+\n+    public enum ParamKind {\n+        \/** Parameter of an executable element. *\/\n+        PARAMETER,\n+        \/** State components of a record. *\/\n+        RECORD_COMPONENT,\n+        \/** Type parameters of an executable element or type element. *\/\n+        TYPE_PARAMETER\n+    }\n+\n+    private final Contents contents;\n+\n+    ParamTaglet(HtmlConfiguration config) {\n+        super(config, DocTree.Kind.PARAM, false, EnumSet.of(Taglet.Location.TYPE, Taglet.Location.CONSTRUCTOR, Taglet.Location.METHOD));\n+        contents = config.contents;\n+    }\n+\n+    @Override\n+    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence) {\n+        assert dst.getKind() == ElementKind.METHOD;\n+        assert tag.getKind() == DocTree.Kind.PARAM;\n+        var method = (ExecutableElement) dst;\n+        var param = (ParamTree) tag;\n+        \/\/ find the position of an owner parameter described by the given tag\n+        List<? extends Element> parameterElements;\n+        if (param.isTypeParameter()) {\n+            parameterElements = method.getTypeParameters();\n+        } else {\n+            parameterElements = method.getParameters();\n+        }\n+        Map<String, Integer> stringIntegerMap = mapNameToPosition(utils, parameterElements);\n+        CommentHelper ch = utils.getCommentHelper(dst);\n+        Integer position = stringIntegerMap.get(ch.getParameterName(param));\n+        if (position == null) {\n+            return new Output(null, null, List.of(), true);\n+        }\n+        \/\/ try to inherit description of the respective parameter in an overridden method\n+        try {\n+            var docFinder = utils.docFinder();\n+\n+            Optional<Documentation> r;\n+            if (src != null){\n+                r = docFinder.search((ExecutableElement) src,\n+                                m -> DocFinder.Result.fromOptional(extract(utils, m, position, param.isTypeParameter())))\n+                        .toOptional();\n+            } else {\n+                r = docFinder.find((ExecutableElement) dst,\n+                                m -> DocFinder.Result.fromOptional(extract(utils, m, position, param.isTypeParameter())))\n+                        .toOptional();\n+            }\n+            return r.map(result -> new Output(result.paramTree, result.method, result.paramTree.getDescription(), true))\n+                    .orElseGet(() -> new Output(null, null, List.of(), true));\n+        } catch (DocFinder.NoOverriddenMethodFound e) {\n+            return new Output(null, null, List.of(), false);\n+        }\n+    }\n+\n+    \/**\n+     * Given a list of parameter elements, returns a name-position map.\n+     * @param params the list of parameters from a type or an executable member\n+     * @return a name-position map\n+     *\/\n+    private static Map<String, Integer> mapNameToPosition(Utils utils, List<? extends Element> params) {\n+        Map<String, Integer> result = new HashMap<>();\n+        int position = 0;\n+        for (Element e : params) {\n+            String name = utils.isTypeParameterElement(e)\n+                    ? utils.getTypeName(e.asType(), false)\n+                    : utils.getSimpleName(e);\n+            result.put(name, position);\n+            position++;\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Content getAllBlockTagOutput(Element holder, TagletWriter tagletWriter) {\n+        this.tagletWriter = tagletWriter;\n+        if (utils.isExecutableElement(holder)) {\n+            ExecutableElement member = (ExecutableElement) holder;\n+            Content output = convertParams(member, ParamKind.TYPE_PARAMETER,\n+                    utils.getTypeParamTrees(member), member.getTypeParameters(), tagletWriter);\n+            output.add(convertParams(member, ParamKind.PARAMETER,\n+                    utils.getParamTrees(member), member.getParameters(), tagletWriter));\n+            return output;\n+        } else {\n+            TypeElement typeElement = (TypeElement) holder;\n+            Content output = convertParams(typeElement, ParamKind.TYPE_PARAMETER,\n+                    utils.getTypeParamTrees(typeElement), typeElement.getTypeParameters(), tagletWriter);\n+            output.add(convertParams(typeElement, ParamKind.RECORD_COMPONENT,\n+                    utils.getParamTrees(typeElement), typeElement.getRecordComponents(), tagletWriter));\n+            return output;\n+        }\n+    }\n+\n+    \/**\n+     * Returns a {@code Content} representation of a list of {@code ParamTree}\n+     * of the specified kind.\n+     *\n+     * <p> This method correlates a {@code ParamTree} with a parameter\n+     * {@code Element} by name. Once it's done, a particular {@code ParamTree}\n+     * is addressed by the position (index) of the correlated {@code Element}\n+     * in the list of parameter elements. This is needed for documentation\n+     * inheritance because the corresponding parameters in the inheritance\n+     * hierarchy may be named differently.\n+     *\n+     * <p> This method warns about {@code @param} tags that do not map to\n+     * parameter elements and param tags that are duplicated. <\/p>\n+     *\n+     * @param kind the kind of <em>all<\/em> parameters in the lists\n+     *\/\n+    private Content convertParams(Element e,\n+                                  ParamKind kind,\n+                                  List<ParamTree> tags,\n+                                  List<? extends Element> parameters,\n+                                  TagletWriter writer) {\n+        Map<Integer, ParamTree> tagOfPosition = new HashMap<>();\n+        CommentHelper ch = utils.getCommentHelper(e);\n+        if (!tags.isEmpty()) {\n+            Map<String, Integer> positionOfName = mapNameToPosition(utils, parameters);\n+            for (ParamTree tag : tags) {\n+                String name = ch.getParameterName(tag);\n+                String paramName = kind == ParamKind.TYPE_PARAMETER ? \"<\" + name + \">\" : name;\n+                if (!positionOfName.containsKey(name)) {\n+                    String key = switch (kind) {\n+                        case PARAMETER -> \"doclet.Parameters_warn\";\n+                        case TYPE_PARAMETER -> \"doclet.TypeParameters_warn\";\n+                        case RECORD_COMPONENT -> \"doclet.RecordComponents_warn\";\n+                    };\n+                    if (!config.isDocLintReferenceGroupEnabled()) {\n+                        messages.warning(ch.getDocTreePath(tag), key, paramName);\n+                    }\n+                }\n+                Integer position = positionOfName.get(name);\n+                if (position != null) {\n+                    if (tagOfPosition.containsKey(position)) {\n+                        String key = switch (kind) {\n+                            case PARAMETER -> \"doclet.Parameters_dup_warn\";\n+                            case TYPE_PARAMETER -> \"doclet.TypeParameters_dup_warn\";\n+                            case RECORD_COMPONENT -> \"doclet.RecordComponents_dup_warn\";\n+                        };\n+                        if (!config.isDocLintReferenceGroupEnabled()) {\n+                            messages.warning(ch.getDocTreePath(tag), key, paramName);\n+                        }\n+                    } else {\n+                        tagOfPosition.put(position, tag);\n+                    }\n+                }\n+            }\n+        }\n+        \/\/ Document declared parameters for which tag documentation is available\n+        \/\/ (either directly or inherited) in order of their declaration.\n+        Content result = writer.getOutputInstance();\n+        for (int i = 0; i < parameters.size(); i++) {\n+            ParamTree tag = tagOfPosition.get(i);\n+            if (tag != null) {\n+                result.add(convertParam(e, kind, writer, tag,\n+                        ch.getParameterName(tag), result.isEmpty()));\n+            } else if (utils.isMethod(e)) {\n+                result.add(getInheritedTagletOutput(kind, e, writer,\n+                        parameters.get(i), i, result.isEmpty()));\n+            }\n+        }\n+        if (tags.size() > tagOfPosition.size()) {\n+            \/\/ Generate documentation for remaining tags that do not match a declared parameter.\n+            \/\/ These are erroneous but we generate them anyway.\n+            for (ParamTree tag : tags) {\n+                if (!tagOfPosition.containsValue(tag)) {\n+                    result.add(convertParam(e, kind, writer, tag,\n+                            ch.getParameterName(tag), result.isEmpty()));\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n+    \/**\n+     * Tries to inherit documentation for a specific parameter (element).\n+     * If unsuccessful, the returned content is empty.\n+     *\/\n+    private Content getInheritedTagletOutput(ParamKind kind,\n+                                             Element holder,\n+                                             TagletWriter writer,\n+                                             Element param,\n+                                             int position,\n+                                             boolean isFirst) {\n+        Content result = writer.getOutputInstance();\n+        var r = utils.docFinder().search((ExecutableElement) holder,\n+                        m -> DocFinder.Result.fromOptional(extract(utils, m, position, kind == ParamTaglet.ParamKind.TYPE_PARAMETER)))\n+                .toOptional();\n+        if (r.isPresent()) {\n+            String name = kind != ParamKind.TYPE_PARAMETER\n+                    ? utils.getSimpleName(param)\n+                    : utils.getTypeName(param.asType(), false);\n+            Content content = convertParam(r.get().method, kind, writer,\n+                    r.get().paramTree, name, isFirst);\n+            result.add(content);\n+        }\n+        return result;\n+    }\n+\n+    private Content getParamHeader(ParamKind kind) {\n+        var header = switch (kind) {\n+            case PARAMETER -> contents.parameters;\n+            case TYPE_PARAMETER -> contents.typeParameters;\n+            case RECORD_COMPONENT -> contents.recordComponents;\n+        };\n+        return HtmlTree.DT(header);\n+    }\n+\n+    private Content paramTagOutput(Element element, ParamTree paramTag, String paramName) {\n+        var context = tagletWriter.context;\n+        var htmlWriter = tagletWriter.htmlWriter;\n+        var body = new ContentBuilder();\n+        CommentHelper ch = utils.getCommentHelper(element);\n+        \/\/ define id attributes for state components so that generated descriptions may refer to them\n+        boolean defineID = (element.getKind() == ElementKind.RECORD)\n+                && !paramTag.isTypeParameter();\n+        Content nameContent = Text.of(paramName);\n+        body.add(HtmlTree.CODE(defineID ? HtmlTree.SPAN_ID(HtmlIds.forParam(paramName), nameContent) : nameContent));\n+        body.add(\" - \");\n+        List<? extends DocTree> description = ch.getDescription(paramTag);\n+        body.add(htmlWriter.commentTagsToContent(element, description, context.within(paramTag)));\n+        return HtmlTree.DD(body);\n+    }\n+\n+    private record Documentation(ParamTree paramTree, ExecutableElement method) { }\n+\n+    private static Optional<Documentation> extract(Utils utils, ExecutableElement method, Integer position, boolean typeParam) {\n+        var ch = utils.getCommentHelper(method);\n+        List<ParamTree> tags = typeParam\n+                ? utils.getTypeParamTrees(method)\n+                : utils.getParamTrees(method);\n+        List<? extends Element> parameters = typeParam\n+                ? method.getTypeParameters()\n+                : method.getParameters();\n+        var positionOfName = mapNameToPosition(utils, parameters);\n+        return tags.stream().filter(t -> position.equals(positionOfName.get(ch.getParameterName(t))))\n+                .map(t -> new Documentation(t, method)).findAny();\n+    }\n+\n+    \/**\n+     * Converts an individual {@code ParamTree} to {@code Content}, which is\n+     * prepended with the header if the parameter is first in the list.\n+     *\/\n+    private Content convertParam(Element e,\n+                                 ParamKind kind,\n+                                 TagletWriter writer,\n+                                 ParamTree paramTag,\n+                                 String name,\n+                                 boolean isFirstParam) {\n+        Content result = writer.getOutputInstance();\n+        if (isFirstParam) {\n+            result.add(getParamHeader(kind));\n+        }\n+        result.add(paramTagOutput(e, paramTag, name));\n+        return result;\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/ParamTaglet.java","additions":316,"deletions":0,"binary":false,"changes":316,"status":"added"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.type.TypeMirror;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.ReturnTree;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.Contents;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+\n+\/**\n+ * A taglet that represents the {@code @return} and {@code {@return }} tags.\n+ *\/\n+public class ReturnTaglet extends BaseTaglet implements InheritableTaglet {\n+    private final Contents contents;\n+\n+    ReturnTaglet(HtmlConfiguration config) {\n+        super(config, DocTree.Kind.RETURN, true, EnumSet.of(Taglet.Location.METHOD));\n+        contents = config.contents;\n+    }\n+\n+    @Override\n+    public boolean isBlockTag() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence) {\n+        try {\n+            var docFinder = utils.docFinder();\n+            Optional<Documentation> r;\n+            if (src == null) {\n+                r = docFinder.find((ExecutableElement) dst, m -> DocFinder.Result.fromOptional(extract(utils, m))).toOptional();\n+            } else {\n+                r = docFinder.search((ExecutableElement) src, m -> DocFinder.Result.fromOptional(extract(utils, m))).toOptional();\n+            }\n+            return r.map(result -> new Output(result.returnTree, result.method, result.returnTree.getDescription(), true))\n+                    .orElseGet(() -> new Output(null, null, List.of(), true));\n+        } catch (DocFinder.NoOverriddenMethodFound e) {\n+            return new Output(null, null, List.of(), false);\n+        }\n+    }\n+\n+    @Override\n+    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter tagletWriter) {\n+        this.tagletWriter = tagletWriter;\n+        return returnTagOutput(element, (ReturnTree) tag, true);\n+    }\n+\n+    @Override\n+    public Content getAllBlockTagOutput(Element holder, TagletWriter tagletWriter) {\n+        assert holder.getKind() == ElementKind.METHOD : holder.getKind();\n+        var method = (ExecutableElement) holder;\n+        this.tagletWriter = tagletWriter;\n+        List<? extends ReturnTree> tags = utils.getReturnTrees(holder);\n+\n+        \/\/ make sure we are not using @return on a method with the void return type\n+        TypeMirror returnType = utils.getReturnType(tagletWriter.getCurrentPageElement(), method);\n+        if (returnType != null && utils.isVoid(returnType)) {\n+            if (!tags.isEmpty() && !config.isDocLintReferenceGroupEnabled()) {\n+                messages.warning(holder, \"doclet.Return_tag_on_void_method\");\n+            }\n+            return null;\n+        }\n+\n+        \/\/ it would also be good to check if there are more than one @return\n+        \/\/ tags and produce a warning or error similarly to how it's done\n+        \/\/ above for a case where @return is used for void\n+\n+        var docFinder = utils.docFinder();\n+        return docFinder.search(method, m -> DocFinder.Result.fromOptional(extract(utils, m))).toOptional()\n+                .map(r -> returnTagOutput(r.method, r.returnTree, false))\n+                .orElse(null);\n+    }\n+\n+    \/**\n+     * Returns the output for a {@code @return} tag.\n+     *\n+     * @param element   the element that owns the doc comment\n+     * @param returnTag the return tag to document\n+     * @param inline    whether this should be written as an inline instance or block instance\n+     *\n+     * @return the output\n+     *\/\n+    public Content returnTagOutput(Element element, ReturnTree returnTag, boolean inline) {\n+        var context = tagletWriter.context;\n+        var htmlWriter = tagletWriter.htmlWriter;\n+        var ch = utils.getCommentHelper(element);\n+        List<? extends DocTree> desc = ch.getDescription(returnTag);\n+        Content content = htmlWriter.commentTagsToContent(element, desc, context.within(returnTag));\n+        return inline\n+                ? new ContentBuilder(contents.getContent(\"doclet.Returns_0\", content))\n+                : new ContentBuilder(HtmlTree.DT(contents.returns), HtmlTree.DD(content));\n+    }\n+\n+    private record Documentation(ReturnTree returnTree, ExecutableElement method) { }\n+\n+    private static Optional<Documentation> extract(Utils utils, ExecutableElement method) {\n+        \/\/ TODO\n+        \/\/  Using getBlockTags(..., Kind.RETURN) for clarity. Since @return has become a bimodal tag,\n+        \/\/  Utils.getReturnTrees is now a misnomer: it returns only block returns, not all returns.\n+        \/\/  We could revisit this later.\n+        Stream<? extends ReturnTree> blockTags = utils.getBlockTags(method, DocTree.Kind.RETURN, ReturnTree.class).stream();\n+        Stream<? extends ReturnTree> mainDescriptionTags = utils.getFirstSentenceTrees(method).stream()\n+                .mapMulti((t, c) -> {\n+                    if (t.getKind() == DocTree.Kind.RETURN) c.accept((ReturnTree) t);\n+                });\n+        \/\/ this method should not check validity of @return tags, hence findAny and not findFirst or what have you\n+        return Stream.concat(blockTags, mainDescriptionTags)\n+                .map(t -> new Documentation(t, method)).findAny();\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/ReturnTaglet.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -0,0 +1,195 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.SeeTree;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.ClassWriterImpl;\n+import jdk.javadoc.internal.doclets.formats.html.Contents;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlDocletWriter;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.builders.SerializedFormBuilder;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocLink;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocPath;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+\n+public class SeeTaglet extends BaseTaglet implements InheritableTaglet {\n+    SeeTaglet(HtmlConfiguration config) {\n+        super(config, DocTree.Kind.SEE, false, EnumSet.allOf(Taglet.Location.class));\n+        contents = config.contents;\n+    }\n+\n+    private final Contents contents;\n+    private HtmlDocletWriter htmlWriter;\n+\n+\n+    @Override\n+    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence) {\n+        CommentHelper ch = utils.getCommentHelper(dst);\n+        var path = ch.getDocTreePath(tag);\n+        messages.warning(path, \"doclet.inheritDocWithinInappropriateTag\");\n+        return new Output(null, null, List.of(), true \/* true, otherwise there will be an exception up the stack *\/);\n+    }\n+\n+    @Override\n+    public Content getAllBlockTagOutput(Element holder, TagletWriter tagletWriter) {\n+        this.tagletWriter = tagletWriter;\n+        List<? extends SeeTree> tags = utils.getSeeTrees(holder);\n+        Element e = holder;\n+        if (utils.isMethod(holder)) {\n+            var docFinder = utils.docFinder();\n+            Optional<Documentation> result = docFinder.search((ExecutableElement) holder,\n+                    m -> DocFinder.Result.fromOptional(extract(utils, m))).toOptional();\n+            if (result.isPresent()) {\n+                ExecutableElement m = result.get().method();\n+                tags = utils.getSeeTrees(m);\n+                e = m;\n+            }\n+        }\n+        return seeTagOutput(e, tags);\n+    }\n+\n+    \/**\n+     * Returns the output for {@code @see} tags.\n+     *\n+     * @param holder The element that owns the doc comment\n+     * @param seeTags the list of tags\n+     *\n+     * @return the output\n+     *\/\n+    public Content seeTagOutput(Element holder, List<? extends SeeTree> seeTags) {\n+        htmlWriter = tagletWriter.htmlWriter;\n+\n+        List<Content> links = new ArrayList<>();\n+        for (SeeTree dt : seeTags) {\n+            links.add(seeTagOutput(holder, dt));\n+        }\n+        if (utils.isVariableElement(holder) && ((VariableElement)holder).getConstantValue() != null &&\n+                htmlWriter instanceof ClassWriterImpl classWriter) {\n+            \/\/Automatically add link to constant values page for constant fields.\n+            DocPath constantsPath =\n+                    htmlWriter.pathToRoot.resolve(DocPaths.CONSTANT_VALUES);\n+            String whichConstant =\n+                    classWriter.getTypeElement().getQualifiedName() + \".\" +\n+                            utils.getSimpleName(holder);\n+            DocLink link = constantsPath.fragment(whichConstant);\n+            links.add(htmlWriter.links.createLink(link,\n+                    contents.getContent(\"doclet.Constants_Summary\")));\n+        }\n+        if (utils.isClass(holder) && utils.isSerializable((TypeElement)holder)) {\n+            \/\/Automatically add link to serialized form page for serializable classes.\n+            if (SerializedFormBuilder.serialInclude(utils, holder) &&\n+                    SerializedFormBuilder.serialInclude(utils, utils.containingPackage(holder))) {\n+                DocPath serialPath = htmlWriter.pathToRoot.resolve(DocPaths.SERIALIZED_FORM);\n+                DocLink link = serialPath.fragment(utils.getFullyQualifiedName(holder));\n+                links.add(htmlWriter.links.createLink(link,\n+                        contents.getContent(\"doclet.Serialized_Form\")));\n+            }\n+        }\n+        if (links.isEmpty()) {\n+            return Text.EMPTY;\n+        }\n+\n+        var seeList = tagletWriter.tagList(links);\n+        return new ContentBuilder(\n+                HtmlTree.DT(contents.seeAlso),\n+                HtmlTree.DD(seeList));\n+    }\n+\n+    private record Documentation(List<? extends SeeTree> seeTrees, ExecutableElement method) { }\n+\n+    private static Optional<Documentation> extract(Utils utils, ExecutableElement method) {\n+        List<? extends SeeTree> tags = utils.getSeeTrees(method);\n+        return tags.isEmpty() ? Optional.empty() : Optional.of(new Documentation(tags, method));\n+    }\n+\n+    \/**\n+     * {@return the output for a single {@code @see} tag}\n+     *\n+     * @param element the element that has the documentation comment containing this tag\n+     * @param seeTag  the tag\n+     *\/\n+    private Content seeTagOutput(Element element, SeeTree seeTag) {\n+\n+        List<? extends DocTree> ref = seeTag.getReference();\n+        assert !ref.isEmpty();\n+        DocTree ref0 = ref.get(0);\n+        switch (ref0.getKind()) {\n+            case TEXT, START_ELEMENT -> {\n+                \/\/ @see \"Reference\"\n+                \/\/ @see <a href=\"...\">...<\/a>\n+                return htmlWriter.commentTagsToContent(element, ref, false, false);\n+            }\n+\n+            case REFERENCE -> {\n+                \/\/ @see reference label...\n+                CommentHelper ch = utils.getCommentHelper(element);\n+                String refSignature = ch.getReferencedSignature(ref0);\n+                List<? extends DocTree> label = ref.subList(1, ref.size());\n+\n+                var lt = (LinkTaglet) config.tagletManager.getTaglet(DocTree.Kind.LINK);\n+                return lt.linkSeeReferenceOutput(element,\n+                        seeTag,\n+                        refSignature,\n+                        ch.getReferencedElement(seeTag),\n+                        false,\n+                        htmlWriter.commentTagsToContent(element, label, tagletWriter.getContext().within(seeTag)),\n+                        (key, args) -> messages.warning(ch.getDocTreePath(seeTag), key, args),\n+                        tagletWriter\n+                );\n+            }\n+\n+            case ERRONEOUS -> {\n+                return tagletWriter.invalidTagOutput(resources.getText(\"doclet.tag.invalid_input\",\n+                                ref0.toString()),\n+                        Optional.empty());\n+            }\n+\n+            default -> throw new IllegalStateException(ref0.getKind().toString());\n+        }\n+\n+    }\n+\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SeeTaglet.java","additions":195,"deletions":0,"binary":false,"changes":195,"status":"added"},{"patch":"@@ -0,0 +1,243 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+\n+import com.sun.source.doctree.DocTree;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n+\n+\/**\n+ * A custom single-argument block tag.\n+ *\/\n+public class SimpleTaglet extends BaseTaglet implements InheritableTaglet {\n+\n+    \/**\n+     * The header to output.\n+     *\/\n+    private final String header;\n+\n+    private final boolean enabled;\n+\n+    \/**\n+     * Constructs a {@code SimpleTaglet}.\n+     *\n+     * @param tagName   the name of this tag\n+     * @param header    the header to output\n+     * @param locations the possible locations that this tag can appear in\n+     *                  The string can contain 'p' for package, 't' for type,\n+     *                  'm' for method, 'c' for constructor and 'f' for field.\n+     *                  See {@link #getLocations(String) getLocations} for the\n+     *                  complete list.\n+     *\/\n+    SimpleTaglet(HtmlConfiguration config, String tagName, String header, String locations) {\n+        this(config, tagName, header, getLocations(locations), isEnabled(locations));\n+    }\n+\n+    \/**\n+     * Constructs a {@code SimpleTaglet}.\n+     *\n+     * @param tagKind   the kind of this tag\n+     * @param header    the header to output\n+     * @param locations the possible locations that this tag can appear in\n+     *\/\n+    SimpleTaglet(HtmlConfiguration config, DocTree.Kind tagKind, String header, Set<Taglet.Location> locations) {\n+        this(config, tagKind, header, locations, true);\n+    }\n+\n+    \/**\n+     * Constructs a {@code SimpleTaglet}.\n+     *\n+     * @param tagName   the name of this tag\n+     * @param header    the header to output\n+     * @param locations the possible locations that this tag can appear in\n+     *\/\n+    SimpleTaglet(HtmlConfiguration config, String tagName, String header, Set<Taglet.Location> locations) {\n+        this(config, tagName, header, locations, true);\n+    }\n+\n+    \/**\n+     * Constructs a {@code SimpleTaglet}.\n+     *\n+     * @param tagName   the name of this tag\n+     * @param header    the header to output\n+     * @param locations the possible locations that this tag can appear in\n+     *\/\n+    private SimpleTaglet(HtmlConfiguration config, String tagName, String header, Set<Taglet.Location> locations, boolean enabled) {\n+        super(config, tagName, false, locations);\n+        this.header = header;\n+        this.enabled = enabled;\n+    }\n+\n+    \/**\n+     * Constructs a {@code SimpleTaglet}.\n+     *\n+     * @param tagKind   the kind of this tag\n+     * @param header    the header to output\n+     * @param locations the possible locations that this tag can appear in\n+     *\/\n+    protected SimpleTaglet(HtmlConfiguration config, DocTree.Kind tagKind, String header, Set<Taglet.Location> locations, boolean enabled) {\n+        super(config, tagKind, false, locations);\n+        this.header = header;\n+        this.enabled = enabled;\n+    }\n+\n+    @Override\n+    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence) {\n+        assert dst.getKind() == ElementKind.METHOD;\n+        assert !isFirstSentence;\n+        try {\n+            var docFinder = utils.docFinder();\n+            Optional<Documentation> r;\n+            if (src == null) {\n+                r = docFinder.find((ExecutableElement) dst,\n+                        m -> DocFinder.Result.fromOptional(extractFirst(m))).toOptional();\n+            } else {\n+                r = docFinder.search((ExecutableElement) src,\n+                        m -> DocFinder.Result.fromOptional(extractFirst(m))).toOptional();\n+            }\n+            return r.map(result -> new Output(result.tag, result.method, result.description, true))\n+                    .orElseGet(()->new Output(null, null, List.of(), true));\n+        } catch (DocFinder.NoOverriddenMethodFound e) {\n+            return new Output(null, null, List.of(), false);\n+        }\n+    }\n+\n+    \/**\n+     * Whether the taglet should generate output.\n+     * Standard tags like {@code @author}, {@code @since}, {@code @version} can\n+     * be disabled by command-line options; custom tags created with -tag can be\n+     * disabled with an X in the defining string.\n+     *\/\n+    boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    record Documentation(DocTree tag, List<? extends DocTree> description, ExecutableElement method) { }\n+\n+    private Optional<Documentation> extractFirst(ExecutableElement m) {\n+        List<? extends DocTree> tags = utils.getBlockTags(m, this::accepts);\n+        if (tags.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        DocTree t = tags.get(0);\n+        return Optional.of(new Documentation(t, utils.getCommentHelper(m).getDescription(t), m));\n+    }\n+\n+    @Override\n+    public Content getAllBlockTagOutput(Element holder, TagletWriter tagletWriter) {\n+        this.tagletWriter = tagletWriter;\n+        List<? extends DocTree> tags = utils.getBlockTags(holder, this::accepts);\n+        if (header == null || tags.isEmpty()) {\n+            return null;\n+        }\n+        return simpleBlockTagOutput(holder, tags, header, tagletWriter);\n+    }\n+\n+    \/**\n+     * Returns the output for a series of simple tags.\n+     *\n+     * @param element    The element that owns the doc comment\n+     * @param simpleTags the list of simple tags\n+     * @param header     the header for the series of tags\n+     *\n+     * @return the output\n+     *\/\n+    private Content simpleBlockTagOutput(Element element,\n+                                        List<? extends DocTree> simpleTags,\n+                                        String header,\n+                                        TagletWriter writer) {\n+        var ch = utils.getCommentHelper(element);\n+        var context = tagletWriter.context;\n+        var htmlWriter = tagletWriter.htmlWriter;\n+\n+        ContentBuilder body = new ContentBuilder();\n+        boolean many = false;\n+        for (DocTree simpleTag : simpleTags) {\n+            if (many) {\n+                body.add(\", \");\n+            }\n+            List<? extends DocTree> bodyTags = ch.getBody(simpleTag);\n+            body.add(htmlWriter.commentTagsToContent(element, bodyTags, context.within(simpleTag)));\n+            many = true;\n+        }\n+        return new ContentBuilder(\n+                HtmlTree.DT(RawHtml.of(header)),\n+                HtmlTree.DD(body));\n+    }\n+\n+    private static Set<Taglet.Location> getLocations(String locations) {\n+        Set<Taglet.Location> set = EnumSet.noneOf(Taglet.Location.class);\n+        for (int i = 0; i < locations.length(); i++) {\n+            switch (locations.charAt(i)) {\n+                case 'a':  case 'A':\n+                    return EnumSet.allOf(Taglet.Location.class);\n+                case 'c':  case 'C':\n+                    set.add(Taglet.Location.CONSTRUCTOR);\n+                    break;\n+                case 'f':  case 'F':\n+                    set.add(Taglet.Location.FIELD);\n+                    break;\n+                case 'm':  case 'M':\n+                    set.add(Taglet.Location.METHOD);\n+                    break;\n+                case 'o':  case 'O':\n+                    set.add(Taglet.Location.OVERVIEW);\n+                    break;\n+                case 'p':  case 'P':\n+                    set.add(Taglet.Location.PACKAGE);\n+                    break;\n+                case 's':  case 'S':        \/\/ super-packages, anyone?\n+                    set.add(Taglet.Location.MODULE);\n+                    break;\n+                case 't':  case 'T':\n+                    set.add(Taglet.Location.TYPE);\n+                    break;\n+                case 'x':  case 'X':\n+                    break;\n+            }\n+        }\n+        return set;\n+    }\n+\n+    private static boolean isEnabled(String locations) {\n+        return locations.matches(\"[^Xx]*\");\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SimpleTaglet.java","additions":243,"deletions":0,"binary":false,"changes":243,"status":"added"},{"patch":"@@ -0,0 +1,590 @@\n+\/*\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.io.IOException;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.PackageElement;\n+import javax.tools.Diagnostic;\n+import javax.tools.DocumentationTool;\n+import javax.tools.FileObject;\n+\n+import com.sun.source.doctree.AttributeTree;\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.SnippetTree;\n+import com.sun.source.doctree.TextTree;\n+import com.sun.source.util.DocTreePath;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlAttr;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.formats.html.taglets.snippet.Action;\n+import jdk.javadoc.internal.doclets.formats.html.taglets.snippet.ParseException;\n+import jdk.javadoc.internal.doclets.formats.html.taglets.snippet.Parser;\n+import jdk.javadoc.internal.doclets.formats.html.taglets.snippet.Style;\n+import jdk.javadoc.internal.doclets.formats.html.taglets.snippet.StyledText;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.DocletElement;\n+import jdk.javadoc.internal.doclets.toolkit.Resources;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+\n+\/**\n+ * A taglet that represents the {@code @snippet} tag.\n+ *\/\n+public class SnippetTaglet extends BaseTaglet {\n+\n+    public enum Language {\n+\n+        JAVA(\"java\"),\n+        PROPERTIES(\"properties\");\n+\n+        private static final Map<String, Language> languages;\n+\n+        static {\n+            Map<String, Language> tmp = new HashMap<>();\n+            for (var language : values()) {\n+                String id = Objects.requireNonNull(language.identifier);\n+                if (tmp.put(id, language) != null)\n+                    throw new IllegalStateException(); \/\/ 1-1 correspondence\n+            }\n+            languages = Map.copyOf(tmp);\n+        }\n+\n+        Language(String id) {\n+            identifier = id;\n+        }\n+\n+        private final String identifier;\n+\n+        public static Optional<Language> of(String identifier) {\n+            if (identifier == null)\n+                return Optional.empty();\n+            return Optional.ofNullable(languages.get(identifier));\n+        }\n+\n+        public String getIdentifier() {return identifier;}\n+    }\n+\n+    SnippetTaglet(HtmlConfiguration config) {\n+        super(config, DocTree.Kind.SNIPPET, true, EnumSet.allOf(Taglet.Location.class));\n+    }\n+\n+    \/*\n+     * A snippet can specify content by value (inline), by reference (external)\n+     * or both (hybrid).\n+     *\n+     * To specify content by value, a snippet uses its body; the body of\n+     * a snippet is the content.\n+     *\n+     * To specify content by reference, a snippet uses either the \"class\"\n+     * or \"file\" attribute; the value of that attribute refers to the content.\n+     *\n+     * A snippet can specify the \"region\" attribute. That attribute refines\n+     * the location of the content. The value of that attribute must match\n+     * one of the named regions in the snippets content.\n+     *\/\n+    @Override\n+    public Content getInlineTagOutput(Element holder, DocTree tag, TagletWriter tagletWriter) {\n+        this.tagletWriter = tagletWriter;\n+        try {\n+            return generateContent(holder, tag);\n+        } catch (BadSnippetException e) {\n+            error(tagletWriter, holder, e.tag(), e.key(), e.args());\n+            String details = config.getDocResources().getText(e.key(), e.args());\n+            return badSnippet(tagletWriter, Optional.of(details));\n+        }\n+    }\n+\n+    \/**\n+     * Returns the output for a {@code {@snippet ...}} tag.\n+     *\n+     * @param element    The element that owns the doc comment\n+     * @param tag        the snippet tag\n+     * @param id         the value of the id attribute, or null if not defined\n+     * @param lang       the value of the lang attribute, or null if not defined\n+     *\n+     * @return the output\n+     *\/\n+    private Content snippetTagOutput(Element element, SnippetTree tag, StyledText content,\n+                                       String id, String lang) {\n+        var pathToRoot = tagletWriter.htmlWriter.pathToRoot;\n+        var pre = new HtmlTree(TagName.PRE).setStyle(HtmlStyle.snippet);\n+        if (id != null && !id.isBlank()) {\n+            pre.put(HtmlAttr.ID, id);\n+        }\n+        var code = new HtmlTree(TagName.CODE)\n+                .addUnchecked(Text.EMPTY); \/\/ Make sure the element is always rendered\n+        if (lang != null && !lang.isBlank()) {\n+            code.addStyle(\"language-\" + lang);\n+        }\n+\n+        content.consumeBy((styles, sequence) -> {\n+            CharSequence text = Text.normalizeNewlines(sequence);\n+            if (styles.isEmpty()) {\n+                code.add(text);\n+            } else {\n+                Element e = null;\n+                String t = null;\n+                boolean linkEncountered = false;\n+                boolean markupEncountered = false;\n+                Set<String> classes = new HashSet<>();\n+                for (Style s : styles) {\n+                    if (s instanceof Style.Name n) {\n+                        classes.add(n.name());\n+                    } else if (s instanceof Style.Link l) {\n+                        assert !linkEncountered; \/\/ TODO: do not assert; pick the first link report on subsequent\n+                        linkEncountered = true;\n+                        t = l.target();\n+                        e = getLinkedElement(element, t);\n+                        if (e == null) {\n+                            \/\/ TODO: diagnostic output\n+                        }\n+                    } else if (s instanceof Style.Markup) {\n+                        markupEncountered = true;\n+                        break;\n+                    } else {\n+                        \/\/ TODO: transform this if...else into an exhaustive\n+                        \/\/ switch over the sealed Style hierarchy when \"Pattern\n+                        \/\/ Matching for switch\" has been implemented (JEP 406\n+                        \/\/ and friends)\n+                        throw new AssertionError(styles);\n+                    }\n+                }\n+                Content c;\n+                if (markupEncountered) {\n+                    return;\n+                } else if (linkEncountered) {\n+                    assert e != null;\n+                    \/\/disable preview tagging inside the snippets:\n+                    Utils.PreviewFlagProvider prevPreviewProvider = utils.setPreviewFlagProvider(el -> false);\n+                    try {\n+                        var lt = (LinkTaglet) config.tagletManager.getTaglet(DocTree.Kind.LINK);\n+                        c = lt.linkSeeReferenceOutput(element,\n+                                null,\n+                                t,\n+                                e,\n+                                false, \/\/ TODO: for now\n+                                Text.of(sequence.toString()),\n+                                (key, args) -> { \/* TODO: report diagnostic *\/ },\n+                                tagletWriter);\n+                    } finally {\n+                        utils.setPreviewFlagProvider(prevPreviewProvider);\n+                    }\n+                } else {\n+                    c = HtmlTree.SPAN(Text.of(text));\n+                    classes.forEach(((HtmlTree) c)::addStyle);\n+                }\n+                code.add(c);\n+            }\n+        });\n+        String copyText = resources.getText(\"doclet.Copy_to_clipboard\");\n+        String copiedText = resources.getText(\"doclet.Copied_to_clipboard\");\n+        String copySnippetText = resources.getText(\"doclet.Copy_snippet_to_clipboard\");\n+        var snippetContainer = HtmlTree.DIV(HtmlStyle.snippetContainer,\n+                new HtmlTree(TagName.BUTTON)\n+                        .add(HtmlTree.SPAN(Text.of(copyText))\n+                                .put(HtmlAttr.DATA_COPIED, copiedText))\n+                        .add(new HtmlTree(TagName.IMG)\n+                                .put(HtmlAttr.SRC, pathToRoot.resolve(DocPaths.CLIPBOARD_SVG).getPath())\n+                                .put(HtmlAttr.ALT, copySnippetText))\n+                        .addStyle(HtmlStyle.copy)\n+                        .addStyle(HtmlStyle.snippetCopy)\n+                        .put(HtmlAttr.ARIA_LABEL, copySnippetText)\n+                        .put(HtmlAttr.ONCLICK, \"copySnippet(this)\"));\n+        return snippetContainer.add(pre.add(code));\n+    }\n+\n+    private static final class BadSnippetException extends Exception {\n+\n+        @java.io.Serial\n+        private static final long serialVersionUID = 1;\n+\n+        private final transient DocTree tag;\n+        private final String key;\n+        private final transient Object[] args;\n+\n+        BadSnippetException(DocTree tag, String key, Object... args) {\n+            this.tag = tag;\n+            this.key = key;\n+            this.args = args;\n+        }\n+\n+        DocTree tag() {\n+            return tag;\n+        }\n+\n+        String key() {\n+            return key;\n+        }\n+\n+        Object[] args() {\n+            return args;\n+        }\n+    }\n+\n+    private Content generateContent(Element holder, DocTree tag)\n+            throws BadSnippetException\n+    {\n+        SnippetTree snippetTag = (SnippetTree) tag;\n+\n+        \/\/ organize snippet attributes in a map, performing basic checks along the way\n+        Map<String, AttributeTree> attributes = new HashMap<>();\n+        for (DocTree d : snippetTag.getAttributes()) {\n+            if (!(d instanceof AttributeTree a)) {\n+                continue; \/\/ this might be an ErroneousTree\n+            }\n+            if (attributes.putIfAbsent(a.getName().toString(), a) == null) {\n+                continue;\n+            }\n+            \/\/ two like-named attributes found; although we report on the most\n+            \/\/ recently encountered of the two, the iteration order might differ\n+            \/\/ from the source order (see JDK-8266826)\n+            throw new BadSnippetException(a, \"doclet.tag.attribute.repeated\",\n+                    a.getName().toString());\n+        }\n+\n+        final String CLASS = \"class\";\n+        final String FILE = \"file\";\n+\n+        final boolean containsClass = attributes.containsKey(CLASS);\n+        final boolean containsFile = attributes.containsKey(FILE);\n+        final boolean containsBody = snippetTag.getBody() != null;\n+\n+        if (containsClass && containsFile) {\n+            throw new BadSnippetException(attributes.get(CLASS),\n+                    \"doclet.snippet.contents.ambiguity.external\");\n+        } else if (!containsClass && !containsFile && !containsBody) {\n+            throw new BadSnippetException(tag, \"doclet.snippet.contents.none\");\n+        }\n+\n+        String regionName = null;\n+        AttributeTree region = attributes.get(\"region\");\n+        if (region != null) {\n+            regionName = stringValueOf(region);\n+            if (regionName.isBlank()) {\n+                throw new BadSnippetException(region, \"doclet.tag.attribute.value.illegal\",\n+                        \"region\", region.getValue());\n+            }\n+        }\n+\n+        String inlineContent = null, externalContent = null;\n+\n+        if (containsBody) {\n+            inlineContent = snippetTag.getBody().getBody();\n+        }\n+\n+        FileObject fileObject = null;\n+\n+        if (containsFile || containsClass) {\n+            AttributeTree a;\n+            String v = containsFile\n+                    ? stringValueOf((a = attributes.get(FILE)))\n+                    : stringValueOf((a = attributes.get(CLASS))).replace(\".\", \"\/\") + \".java\";\n+\n+            if (v.isBlank()) {\n+                throw new BadSnippetException(a, \"doclet.tag.attribute.value.illegal\",\n+                        containsFile ? FILE : CLASS, v);\n+            }\n+\n+            \/\/ we didn't create JavaFileManager, so we won't close it; even if an error occurs\n+            var fileManager = config.getFileManager();\n+\n+            try {\n+                \/\/ first, look in local snippet-files subdirectory\n+                var pkg = getPackageElement(holder, utils);\n+                var pkgLocation = utils.getLocationForPackage(pkg);\n+                var pkgName = pkg.getQualifiedName().toString(); \/\/ note: empty string for unnamed package\n+                var relativeName = \"snippet-files\/\" + v;\n+                fileObject = fileManager.getFileForInput(pkgLocation, pkgName, relativeName);\n+\n+                \/\/ if not found in local snippet-files directory, look on snippet path\n+                if (fileObject == null && fileManager.hasLocation(DocumentationTool.Location.SNIPPET_PATH)) {\n+                    fileObject = fileManager.getFileForInput(DocumentationTool.Location.SNIPPET_PATH, \"\", v);\n+                }\n+            } catch (IOException | IllegalArgumentException e) { \/\/ TODO: test this when JDK-8276892 is integrated\n+                \/\/ JavaFileManager.getFileForInput can throw IllegalArgumentException in certain cases\n+                throw new BadSnippetException(a, \"doclet.exception.read.file\", v, e);\n+            }\n+\n+            if (fileObject == null) {\n+                \/\/ i.e. the file does not exist\n+                throw new BadSnippetException(a, \"doclet.snippet_file_not_found\", v);\n+            }\n+\n+            try {\n+                externalContent = fileObject.getCharContent(true).toString();\n+            } catch (IOException e) {  \/\/ TODO: test this when JDK-8276892 is integrated\n+                throw new BadSnippetException(a, \"doclet.exception.read.file\",\n+                        fileObject.getName(), e);\n+            }\n+        }\n+\n+        String lang = null;\n+        AttributeTree langAttr = attributes.get(\"lang\");\n+        if (langAttr != null) {\n+            lang = stringValueOf(langAttr);\n+        } else if (containsClass) {\n+            lang = \"java\";\n+        } else if (containsFile) {\n+            lang = languageFromFileName(fileObject.getName());\n+        }\n+\n+        Optional<Language> language = Language.of(lang);\n+\n+\n+        \/\/ TODO cache parsed external snippet (WeakHashMap)\n+\n+        StyledText inlineSnippet = null;\n+        StyledText externalSnippet = null;\n+\n+        try {\n+            Diags d = (text, pos) -> {\n+                var path = utils.getCommentHelper(holder)\n+                        .getDocTreePath(snippetTag.getBody());\n+                config.getReporter().print(Diagnostic.Kind.WARNING,\n+                        path, pos, pos, pos, text);\n+            };\n+            if (inlineContent != null) {\n+                inlineSnippet = parse(resources, d, language, inlineContent);\n+            }\n+        } catch (ParseException e) {\n+            var path = utils.getCommentHelper(holder)\n+                    .getDocTreePath(snippetTag.getBody());\n+            \/\/ TODO: there should be a method in Messages; that method should mirror Reporter's; use that method instead accessing Reporter.\n+            String msg = resources.getText(\"doclet.snippet.markup\", e.getMessage());\n+            config.getReporter().print(Diagnostic.Kind.ERROR,\n+                    path, e.getPosition(), e.getPosition(), e.getPosition(), msg);\n+            return badSnippet(tagletWriter, Optional.of(e.getMessage()));\n+        }\n+\n+        try {\n+            var finalFileObject = fileObject;\n+            Diags d = (text, pos) -> messages.warning(finalFileObject, pos, pos, pos, text);\n+            if (externalContent != null) {\n+                externalSnippet = parse(resources, d, language, externalContent);\n+            }\n+        } catch (ParseException e) {\n+            assert fileObject != null;\n+            messages.error(fileObject, e.getPosition(),\n+                    e.getPosition(), e.getPosition(), \"doclet.snippet.markup\", e.getMessage());\n+            return badSnippet(tagletWriter, Optional.of(e.getMessage()));\n+        }\n+\n+        \/\/ the region must be matched at least in one content: it can be matched\n+        \/\/ in both, but never in none\n+        if (regionName != null) {\n+            StyledText r1 = null;\n+            StyledText r2 = null;\n+            if (inlineSnippet != null) {\n+                r1 = inlineSnippet.getBookmarkedText(regionName);\n+                if (r1 != null) {\n+                    inlineSnippet = r1;\n+                }\n+            }\n+            if (externalSnippet != null) {\n+                r2 = externalSnippet.getBookmarkedText(regionName);\n+                if (r2 != null) {\n+                    externalSnippet = r2;\n+                }\n+            }\n+            if (r1 == null && r2 == null) {\n+                throw new BadSnippetException(tag, \"doclet.snippet.region.not_found\", regionName);\n+            }\n+        }\n+\n+        if (inlineSnippet != null) {\n+            inlineSnippet = toDisplayForm(inlineSnippet);\n+        }\n+\n+        if (externalSnippet != null) {\n+            externalSnippet = toDisplayForm(externalSnippet);\n+        }\n+\n+        if (inlineSnippet != null && externalSnippet != null) {\n+            String inlineStr = inlineSnippet.asCharSequence().toString();\n+            String externalStr = externalSnippet.asCharSequence().toString();\n+            if (!Objects.equals(inlineStr, externalStr)) {\n+                throw new BadSnippetException(tag, \"doclet.snippet.contents.mismatch\", diff(inlineStr, externalStr));\n+            }\n+        }\n+\n+        assert inlineSnippet != null || externalSnippet != null;\n+        StyledText text = inlineSnippet != null ? inlineSnippet : externalSnippet;\n+\n+        AttributeTree idAttr = attributes.get(\"id\");\n+        String id = idAttr == null\n+                ? null\n+                : stringValueOf(idAttr);\n+\n+        return snippetTagOutput(holder, snippetTag, text, id, lang);\n+    }\n+\n+    \/*\n+     * Maybe there's a case for implementing a proper (or at least more helpful)\n+     * diff view, but for now simply outputting both sides of a hybrid snippet\n+     * would do. A user could then use a diff tool of their choice to compare\n+     * those sides.\n+     *\n+     * There's a separate issue of mapping discrepancies back to their\n+     * originating source in the doc comment and the external file. Maybe there\n+     * is a value in it, or maybe there isn't. In any case, accurate mapping\n+     * would not be trivial to code.\n+     *\/\n+    private static String diff(String inline, String external) {\n+        return \"\"\"\n+               ----------------- inline -------------------\n+               %s\n+               ----------------- external -----------------\n+               %s\n+               \"\"\".formatted(inline, external);\n+    }\n+\n+    private StyledText parse(Resources resources, Diags diags, Optional<Language> language, String content) throws ParseException {\n+        Parser.Result result = new Parser(resources).parse(diags, language, content);\n+        result.actions().forEach(Action::perform);\n+        return result.text();\n+    }\n+\n+    public interface Diags {\n+        void warn(String text, int pos);\n+    }\n+\n+    private static String stringValueOf(AttributeTree at) throws BadSnippetException {\n+        if (at.getValueKind() == AttributeTree.ValueKind.EMPTY) {\n+            throw new BadSnippetException(at, \"doclet.tag.attribute.value.missing\",\n+                    at.getName().toString());\n+        }\n+        return at.getValue().stream()\n+                \/\/ value consists of TextTree or ErroneousTree nodes;\n+                \/\/ ErroneousTree is a subtype of TextTree\n+                .map(t -> ((TextTree) t).getBody())\n+                .collect(Collectors.joining());\n+    }\n+\n+    private String languageFromFileName(String fileName) {\n+        \/\/ TODO: find a way to extend\/customize the list of recognized file name extensions\n+        if (fileName.endsWith(\".java\")) {\n+            return \"java\";\n+        } else if (fileName.endsWith(\".properties\")) {\n+            return \"properties\";\n+        }\n+        return null;\n+    }\n+\n+    private void error(TagletWriter writer, Element holder, DocTree tag, String key, Object... args) {\n+        messages.error(utils.getCommentHelper(holder).getDocTreePath(tag), key, args);\n+    }\n+\n+    private Content badSnippet(TagletWriter writer, Optional<String> details) {\n+        var resources = config.getDocResources();\n+        return writer.invalidTagOutput(resources.getText(\"doclet.tag.invalid\", \"snippet\"), details);\n+    }\n+\n+    private static PackageElement getPackageElement(Element e, Utils utils) {\n+        if (e instanceof DocletElement de) {\n+            return de.getPackageElement();\n+        } else {\n+            return utils.elementUtils.getPackageOf(e);\n+        }\n+    }\n+\n+    \/*\n+     * Returns a version of styled text that can be rendered into HTML or\n+     * compared to another such version. The latter is used to decide if inline\n+     * and external parts of a hybrid snippet match.\n+     *\n+     * Use this method to obtain a final version of text. After all\n+     * transformations on text have been performed, call this method with that\n+     * text and then use the returned result as described above.\n+     *\/\n+    private static StyledText toDisplayForm(StyledText source) {\n+        var sourceString = source.asCharSequence().toString();\n+        var result = new StyledText();\n+        var originalLines = sourceString.lines().iterator();\n+        var unindentedLines = sourceString.stripIndent().lines().iterator();\n+        \/\/ done; the rest of the method translates the stripIndent\n+        \/\/ transformation performed on a character sequence to the styled\n+        \/\/ text that this sequence originates from, line by line\n+        int pos = 0;\n+        \/\/ overcome a \"quirk\" of String.lines\n+        boolean endsWithLineFeed = !sourceString.isEmpty() && sourceString.charAt(source.length() - 1) == '\\n';\n+        while (originalLines.hasNext() && unindentedLines.hasNext()) { \/\/ [^1]\n+            String originalLine = originalLines.next();\n+            String unindentedLine = unindentedLines.next();\n+            \/\/ the search MUST succeed\n+            int idx = originalLine.indexOf(unindentedLine);\n+            \/\/ assume newlines are always of the \\n form\n+            \/\/ append the found fragment\n+            result.append(source.subText(pos + idx, pos + idx + unindentedLine.length()));\n+            \/\/ append the possibly styled newline, but not if it's the last line\n+            int eol = pos + originalLine.length();\n+            if (originalLines.hasNext() || endsWithLineFeed) {\n+                result.append(source.subText(eol, eol + 1));\n+            }\n+            pos = eol + 1;\n+        }\n+        return result;\n+        \/\/ [^1]: Checking hasNext() on both iterators might look unnecessary.\n+        \/\/ However, there are strings for which those iterators return different\n+        \/\/ number of lines. That is, there exists a string s, such that\n+        \/\/\n+        \/\/     s.lines().count() != s.stripIndent().lines().count()\n+        \/\/\n+        \/\/ The most trivial example of such a string is \" \". In fact, any string\n+        \/\/ with a trailing non-empty blank line would do.\n+    }\n+\n+    \/*\n+     * Returns the element that is linked from the context of the referrer using\n+     * the provided signature; returns null if such element could not be found.\n+     *\n+     * This method is to be used when it is the target of the link that is\n+     * important, not the container of the link (e.g. was it an @see,\n+     * @link\/@linkplain or @snippet tags, etc.)\n+     *\/\n+    private Element getLinkedElement(Element referer, String signature) {\n+        var factory = utils.docTrees.getDocTreeFactory();\n+        var docCommentTree = utils.getDocCommentTree(referer);\n+        var rootPath = new DocTreePath(utils.getTreePath(referer), docCommentTree);\n+        var reference = factory.newReferenceTree(signature);\n+        var fabricatedPath = new DocTreePath(rootPath, reference);\n+        return utils.docTrees.getElement(fabricatedPath);\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SnippetTaglet.java","additions":590,"deletions":0,"binary":false,"changes":590,"status":"added"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.SpecTree;\n+import com.sun.source.doctree.TextTree;\n+import com.sun.source.util.DocTreePath;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.Contents;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+\n+\/**\n+ * A taglet that represents the {@code @spec} tag.\n+ *\/\n+public class SpecTaglet extends BaseTaglet implements InheritableTaglet {\n+    private final Contents contents;\n+\n+    SpecTaglet(HtmlConfiguration config) {\n+        super(config, DocTree.Kind.SPEC, false, EnumSet.allOf(Taglet.Location.class));\n+        this.contents = config.contents;\n+    }\n+\n+\n+    @Override\n+    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence) {\n+        CommentHelper ch = utils.getCommentHelper(dst);\n+        var path = ch.getDocTreePath(tag);\n+        messages.warning(path, \"doclet.inheritDocWithinInappropriateTag\");\n+        return new Output(null, null, List.of(), true \/* true, otherwise there will be an exception up the stack *\/);\n+    }\n+\n+    @Override\n+    public Content getAllBlockTagOutput(Element holder, TagletWriter tagletWriter) {\n+        this.tagletWriter = tagletWriter;\n+        List<? extends SpecTree> tags = utils.getSpecTrees(holder);\n+        Element e = holder;\n+        if (utils.isMethod(holder)) {\n+            var docFinder = utils.docFinder();\n+            Optional<Documentation> result = docFinder.search((ExecutableElement) holder,\n+                    m -> DocFinder.Result.fromOptional(extract(utils, m))).toOptional();\n+            if (result.isPresent()) {\n+                e = result.get().method();\n+                tags = result.get().specTrees();\n+            }\n+        }\n+        return specTagOutput(e, tags);\n+    }\n+\n+    \/**\n+     * Returns the output for one or more {@code @spec} tags.\n+     *\n+     * @param holder  the element that owns the doc comment\n+     * @param specTags the array of @spec tags.\n+     *\n+     * @return the output\n+     *\/\n+    public Content specTagOutput(Element holder, List<? extends SpecTree> specTags) {\n+        if (specTags.isEmpty()) {\n+            return Text.EMPTY;\n+        }\n+\n+        var links = specTags.stream()\n+                .map(st -> specTagToContent(holder, st)).toList();\n+\n+        var specList = tagletWriter.tagList(links);\n+        return new ContentBuilder(\n+                HtmlTree.DT(contents.externalSpecifications),\n+                HtmlTree.DD(specList));\n+    }\n+\n+    private record Documentation(List<? extends SpecTree> specTrees, ExecutableElement method) { }\n+\n+    private static Optional<Documentation> extract(Utils utils, ExecutableElement method) {\n+        List<? extends SpecTree> tags = utils.getSpecTrees(method);\n+        return tags.isEmpty() ? Optional.empty() : Optional.of(new Documentation(tags, method));\n+    }\n+\n+    private Content specTagToContent(Element holder, SpecTree specTree) {\n+        var htmlWriter = tagletWriter.htmlWriter;\n+        String specTreeURL = specTree.getURL().getBody();\n+        List<? extends DocTree> specTreeLabel = specTree.getTitle();\n+        Content label = htmlWriter.commentTagsToContent(holder, specTreeLabel, tagletWriter.context.isFirstSentence);\n+        return getExternalSpecContent(holder, specTree, specTreeURL,\n+                textOf(specTreeLabel).replaceAll(\"\\\\s+\", \" \"), label);\n+    }\n+\n+    private String textOf(List<? extends DocTree> trees) {\n+        return trees.stream()\n+                .filter(dt -> dt instanceof TextTree)\n+                .map(dt -> ((TextTree) dt).getBody().trim())\n+                .collect(Collectors.joining(\" \"));\n+    }\n+\n+    Content getExternalSpecContent(Element holder,\n+                                   DocTree docTree,\n+                                   String url,\n+                                   String searchText,\n+                                   Content title) {\n+        URI specURI;\n+        try {\n+            \/\/ Use the canonical title of the spec if one is available\n+            specURI = new URI(url);\n+        } catch (URISyntaxException e) {\n+            CommentHelper ch = utils.getCommentHelper(holder);\n+            DocTreePath dtp = ch.getDocTreePath(docTree);\n+            tagletWriter.htmlWriter.messages.error(dtp, \"doclet.Invalid_URL\", e.getMessage());\n+            specURI = null;\n+        }\n+\n+        Content titleWithAnchor = tagletWriter.createAnchorAndSearchIndex(holder,\n+                searchText,\n+                title,\n+                resources.getText(\"doclet.External_Specification\"),\n+                docTree);\n+\n+        if (specURI == null) {\n+            return titleWithAnchor;\n+        } else {\n+            var htmlWriter = tagletWriter.htmlWriter;\n+            return HtmlTree.A(htmlWriter.resolveExternalSpecURI(specURI), titleWithAnchor);\n+        }\n+\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SpecTaglet.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n@@ -29,0 +29,1 @@\n+\n@@ -32,1 +33,0 @@\n-import jdk.javadoc.doclet.Taglet.Location;\n@@ -35,1 +35,2 @@\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n+import jdk.javadoc.doclet.Taglet.Location;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n@@ -43,1 +44,1 @@\n-    public SummaryTaglet(BaseConfiguration config) {\n+    public SummaryTaglet(HtmlConfiguration config) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SummaryTaglet.java","additions":5,"deletions":4,"binary":false,"changes":9,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SummaryTaglet.java","status":"renamed"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.EnumSet;\n+\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.SystemPropertyTree;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+\n+\/**\n+ * A taglet that represents the {@code @systemProperty} tag.\n+ *\/\n+public class SystemPropertyTaglet extends BaseTaglet {\n+    SystemPropertyTaglet(HtmlConfiguration config) {\n+        super(config, DocTree.Kind.SYSTEM_PROPERTY, true, EnumSet.allOf(Taglet.Location.class));\n+    }\n+\n+    @Override\n+    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter tagletWriter) {\n+        this.tagletWriter = tagletWriter;\n+        return systemPropertyTagOutput(element, (SystemPropertyTree) tag);\n+    }\n+\n+    \/**\n+     * Returns the output for a {@code {@systemProperty...}} tag.\n+     *\n+     * @param element the element that owns the doc comment\n+     * @param tag     the system property tag\n+     *\n+     * @return the output\n+     *\/\n+    private Content systemPropertyTagOutput(Element element, SystemPropertyTree tag) {\n+        String tagText = tag.getPropertyName().toString();\n+        return HtmlTree.CODE(tagletWriter.createAnchorAndSearchIndex(element, tagText,\n+                resources.getText(\"doclet.System_Property\"), tag));\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SystemPropertyTaglet.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/Taglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/Taglet.java","status":"renamed"},{"patch":"@@ -0,0 +1,749 @@\n+\/*\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.EnumSet;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ServiceLoader;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.ModuleElement;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.util.SimpleElementVisitor14;\n+import javax.tools.JavaFileManager;\n+import javax.tools.StandardJavaFileManager;\n+\n+import com.sun.source.doctree.DocTree;\n+\n+import jdk.javadoc.doclet.Doclet;\n+import jdk.javadoc.doclet.DocletEnvironment;\n+import jdk.javadoc.doclet.Taglet.Location;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlOptions;\n+import jdk.javadoc.internal.doclets.toolkit.DocletElement;\n+import jdk.javadoc.internal.doclets.toolkit.Messages;\n+import jdk.javadoc.internal.doclets.toolkit.Resources;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+\n+import static com.sun.source.doctree.DocTree.Kind.AUTHOR;\n+import static com.sun.source.doctree.DocTree.Kind.EXCEPTION;\n+import static com.sun.source.doctree.DocTree.Kind.HIDDEN;\n+import static com.sun.source.doctree.DocTree.Kind.PARAM;\n+import static com.sun.source.doctree.DocTree.Kind.PROVIDES;\n+import static com.sun.source.doctree.DocTree.Kind.SEE;\n+import static com.sun.source.doctree.DocTree.Kind.SERIAL;\n+import static com.sun.source.doctree.DocTree.Kind.SERIAL_DATA;\n+import static com.sun.source.doctree.DocTree.Kind.SERIAL_FIELD;\n+import static com.sun.source.doctree.DocTree.Kind.SINCE;\n+import static com.sun.source.doctree.DocTree.Kind.THROWS;\n+import static com.sun.source.doctree.DocTree.Kind.USES;\n+import static com.sun.source.doctree.DocTree.Kind.VERSION;\n+\n+import static javax.tools.DocumentationTool.Location.TAGLET_PATH;\n+\n+\/**\n+ * Manages the {@code Taglet}s used by the standard doclet.\n+ *\/\n+public class TagletManager {\n+\n+    \/**\n+     * All taglets, keyed either by their {@link Taglet#getName() name},\n+     * or by an alias.\n+     *\n+     * In general, taglets do <i>not<\/i> provide aliases;\n+     * the one instance that does is {@code ThrowsTaglet}, which handles\n+     * both {@code @throws} tags and {@code @exception} tags.\n+     *\/\n+    private final LinkedHashMap<String, Taglet> allTaglets;\n+\n+    \/**\n+     * Block (non-inline) taglets, grouped by {@link Location location}.\n+     *\/\n+    private Map<Location, List<Taglet>> blockTagletsByLocation;\n+\n+    \/**\n+     * The taglets that can appear inline in descriptive text.\n+     *\/\n+    private Map<String, Taglet> inlineTags;\n+\n+    \/**\n+     * The taglets that can appear in the serialized form.\n+     *\/\n+    private List<Taglet> serializedFormTags;\n+\n+    private final DocletEnvironment docEnv;\n+    private final Doclet doclet;\n+\n+    private final Utils utils;\n+    private final Messages messages;\n+    private final Resources resources;\n+\n+    \/**\n+     * Keep track of standard tags.\n+     *\/\n+    private final Set<String> standardTags;\n+\n+    \/**\n+     * Keep track of standard tags in lowercase to compare for better\n+     * error messages when a tag like {@code @docRoot} is mistakenly spelled\n+     * lowercase {@code @docroot}.\n+     *\/\n+    private final Set<String> standardTagsLowercase;\n+\n+    \/**\n+     * Keep track of overridden standard tags.\n+     *\/\n+    private final Set<String> overriddenStandardTags;\n+\n+    \/**\n+     * Keep track of the tags that may conflict\n+     * with standard tags in the future (any custom tag without\n+     * a period in its name).\n+     *\/\n+    private final Set<String> potentiallyConflictingTags;\n+\n+    \/**\n+     * The set of unseen custom tags.\n+     *\/\n+    private final Set<String> unseenCustomTags;\n+\n+    \/**\n+     * True if we do not want to use {@code @since} tags.\n+     *\/\n+    private final boolean nosince;\n+\n+    \/**\n+     * True if we want to use {@code @version} tags.\n+     *\/\n+    private final boolean showversion;\n+\n+    \/**\n+     * True if we want to use {@code @author} tags.\n+     *\/\n+    private final boolean showauthor;\n+\n+    \/**\n+     * True if we want to use JavaFX-related tags ({@code @defaultValue}, {@code @treatAsPrivate}).\n+     *\/\n+    private final boolean javafx;\n+\n+    \/**\n+     * Show the taglets table when it has been initialized.\n+     *\/\n+    private final boolean showTaglets;\n+\n+    private final String tagletPath;\n+\n+    private final HtmlConfiguration config;\n+\n+    \/**\n+     * Constructs a new {@code TagletManager}.\n+     *\n+     * @param config the configuration for this taglet manager\n+     *\/\n+    public TagletManager(HtmlConfiguration config) {\n+        overriddenStandardTags = new HashSet<>();\n+        potentiallyConflictingTags = new HashSet<>();\n+        standardTags = new HashSet<>();\n+        standardTagsLowercase = new HashSet<>();\n+        unseenCustomTags = new HashSet<>();\n+        allTaglets = new LinkedHashMap<>();\n+        this.config = config;\n+        HtmlOptions options = config.getOptions();\n+        this.nosince = options.noSince();\n+        this.showversion = options.showVersion();\n+        this.showauthor = options.showAuthor();\n+        this.javafx = options.javafx();\n+        this.docEnv = config.docEnv;\n+        this.doclet = config.doclet;\n+        this.messages = config.getMessages();\n+        this.resources = config.getDocResources();\n+        this.showTaglets = options.showTaglets();\n+        this.utils = config.utils;\n+        this.tagletPath = options.tagletPath();\n+        initStandardTaglets();\n+    }\n+\n+    public Set<String> getAllTagletNames() {\n+        return allTaglets.keySet();\n+    }\n+\n+    \/**\n+     * Initializes the location TAGLET_PATH which is used to locate the custom taglets.\n+     *\n+     * @param fileManager the file manager to load classes and resources\n+     * @throws IOException if an error occurs while setting the location\n+     *\/\n+    public void initTagletPath(JavaFileManager fileManager) throws IOException {\n+        if (fileManager instanceof StandardJavaFileManager sfm) {\n+            if (tagletPath != null) {\n+                List<File> paths = new ArrayList<>();\n+                for (String pathname : tagletPath.split(File.pathSeparator)) {\n+                    paths.add(new File(pathname));\n+                }\n+                sfm.setLocation(TAGLET_PATH, paths);\n+            } else if (!sfm.hasLocation(TAGLET_PATH)) {\n+                sfm.setLocation(TAGLET_PATH, List.of());\n+            }\n+        } else if (tagletPath != null) {\n+            messages.error(\"doclet.not_standard_file_manager\");\n+        }\n+    }\n+\n+    \/**\n+     * Adds a new {@code Taglet}.\n+     *\n+     * Prints a message to indicate whether or not the Taglet was registered properly.\n+     *\n+     * @param classname  the name of the class representing the custom tag\n+     * @param fileManager the file manager to load classes and resources\n+     *\/\n+    public void addCustomTag(String classname, JavaFileManager fileManager) {\n+        ClassLoader tagClassLoader = fileManager.getClassLoader(TAGLET_PATH);\n+        if (config.workArounds.accessInternalAPI()) {\n+            Module thisModule = getClass().getModule();\n+            Module tagletLoaderUnnamedModule = tagClassLoader.getUnnamedModule();\n+            List<String> pkgs = List.of(\n+                    \"jdk.javadoc.doclet\",\n+                    \"jdk.javadoc.internal.doclets.toolkit\",\n+                    \"jdk.javadoc.internal.doclets.formats.html\");\n+            pkgs.forEach(p -> thisModule.addOpens(p, tagletLoaderUnnamedModule));\n+        }\n+        try {\n+            Class<? extends jdk.javadoc.doclet.Taglet> customTagClass =\n+                    tagClassLoader.loadClass(classname).asSubclass(jdk.javadoc.doclet.Taglet.class);\n+            jdk.javadoc.doclet.Taglet instance = customTagClass.getConstructor().newInstance();\n+            registerTaglet(instance);\n+        } catch (ReflectiveOperationException | ExceptionInInitializerError | ClassCastException exc) {\n+            messages.error(\"doclet.Error_taglet_not_registered\", exc.getClass().getName(),\n+                    classname);\n+        }\n+    }\n+\n+    \/**\n+     * Loads taglets from a taglet path using the service loader.\n+     *\n+     * @param fileManager the file manager to load the taglets\n+     * @throws IOException if an error occurs while getting the service loader\n+     *\/\n+    public void loadTaglets(JavaFileManager fileManager) throws IOException {\n+        Iterable<? extends File> location = ((StandardJavaFileManager) fileManager).getLocation(TAGLET_PATH);\n+        if (location != null && location.iterator().hasNext()) {\n+            ServiceLoader<jdk.javadoc.doclet.Taglet> serviceLoader =\n+                    fileManager.getServiceLoader(TAGLET_PATH, jdk.javadoc.doclet.Taglet.class);\n+            for (jdk.javadoc.doclet.Taglet taglet : serviceLoader) {\n+                registerTaglet(taglet);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Registers the {@code Taglet}.\n+     *\n+     * Prints a message if the {@code Taglet} got registered properly.\n+     *\n+     * @param instance the {@code Taglet} instance\n+     *\/\n+    private void registerTaglet(jdk.javadoc.doclet.Taglet instance) {\n+        instance.init(docEnv, doclet);\n+        Taglet newLegacy = new UserTaglet(instance);\n+        allTaglets.put(newLegacy.getName(), newLegacy);\n+        messages.notice(\"doclet.Notice_taglet_registered\", instance.getClass().getName());\n+    }\n+\n+    \/**\n+     * Adds a new {@code SimpleTaglet}.\n+     *\n+     * If this tag already exists and the header passed as an argument is {@code null},\n+     * move tag to the back of the list. If this tag already exists and the\n+     * header passed as an argument is not {@code null}, overwrite previous tag\n+     * with the new one. Otherwise, add a new SimpleTaglet to the list.\n+     *\n+     * @param tagName the name of this tag\n+     * @param header the header to output\n+     * @param locations the possible locations that this tag can appear in\n+     *\/\n+    public void addNewSimpleCustomTag(String tagName, String header, String locations) {\n+        if (tagName == null || locations == null) {\n+            return;\n+        }\n+        \/\/ remove + put in both branches below move the tag to the back of the map's ordering\n+        Taglet tag = allTaglets.remove(tagName);\n+        if (tag == null || header != null) {\n+            allTaglets.put(tagName, new SimpleTaglet(config, tagName, header, locations));\n+            if (Utils.toLowerCase(locations).indexOf('x') == -1) {\n+                checkTagName(tagName);\n+            }\n+        } else {\n+            \/\/ Move existing tag to the back\n+            allTaglets.put(tagName, tag);\n+        }\n+    }\n+\n+    \/**\n+     * Given a tag name, add it to the set of tags it belongs to.\n+     *\/\n+    private void checkTagName(String name) {\n+        if (standardTags.contains(name)) {\n+            overriddenStandardTags.add(name);\n+        } else {\n+            if (name.indexOf('.') == -1) {\n+                potentiallyConflictingTags.add(name);\n+            }\n+            unseenCustomTags.add(name);\n+        }\n+    }\n+\n+    \/**\n+     * Reports that a tag was seen in a doc comment.\n+     * It is removed from the list of custom tags that have not yet been seen.\n+     *\n+     * @param name the name of the tag\n+     *\/\n+    void seenTag(String name) {\n+        unseenCustomTags.remove(name);\n+    }\n+\n+    \/**\n+     * Given a series of {@code DocTree}s, check for misuse and spelling mistakes.\n+     *\n+     * @param element the tags holder\n+     * @param trees the trees containing the comments\n+     *\/\n+    public void checkTags(Element element, Iterable<? extends DocTree> trees) {\n+        CommentHelper ch = utils.getCommentHelper(element);\n+        for (DocTree tag : trees) {\n+            String name = tag.getKind().tagName;\n+            if (name == null) {\n+                continue;\n+            }\n+            if (!name.isEmpty() && name.charAt(0) == '@') {\n+                name = name.substring(1);\n+            }\n+            if (! (standardTags.contains(name) || allTaglets.containsKey(name))) {\n+                if (standardTagsLowercase.contains(Utils.toLowerCase(name))) {\n+                    messages.warning(ch.getDocTreePath(tag), \"doclet.UnknownTagLowercase\", ch.getTagName(tag));\n+                    continue;\n+                } else {\n+                    messages.warning(ch.getDocTreePath(tag), \"doclet.UnknownTag\", ch.getTagName(tag));\n+                    continue;\n+                }\n+            }\n+            final Taglet taglet = allTaglets.get(name);\n+            \/\/ Check and verify tag usage\n+            if (taglet != null) {\n+                if (taglet instanceof SimpleTaglet st && !st.isEnabled()) {\n+                    \/\/ taglet has been disabled\n+                    return;\n+                }\n+\n+                new SimpleElementVisitor14<Void, Void>() {\n+                    @Override\n+                    public Void visitModule(ModuleElement e, Void p) {\n+                        if (!taglet.inModule()) {\n+                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"module\");\n+                        }\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    public Void visitPackage(PackageElement e, Void p) {\n+                        if (!taglet.inPackage()) {\n+                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"package\");\n+                        }\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    public Void visitType(TypeElement e, Void p) {\n+                        if (!taglet.inType()) {\n+                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"class\");\n+                        }\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    public Void visitExecutable(ExecutableElement e, Void p) {\n+                        if (utils.isConstructor(e) && !taglet.inConstructor()) {\n+                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"constructor\");\n+                        } else if (!taglet.inMethod()) {\n+                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"method\");\n+                        }\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    public Void visitVariable(VariableElement e, Void p) {\n+                        if (utils.isField(e) && !taglet.inField()) {\n+                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"field\");\n+                        }\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    public Void visitUnknown(Element e, Void p) {\n+                        if (utils.isOverviewElement(e) && !taglet.inOverview()) {\n+                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"overview\");\n+                        }\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    protected Void defaultAction(Element e, Void p) {\n+                        return null;\n+                    }\n+                }.visit(element);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Given the taglet, the tag and the type of documentation that the tag\n+     * was found in, print a tag misuse warning.\n+     *\n+     * @param taglet the taglet representing the misused tag\n+     * @param tag the misused tag\n+     * @param holderType the type of documentation that the misused tag was found in\n+     *\/\n+    private void printTagMisuseWarn(CommentHelper ch, Taglet taglet, DocTree tag, String holderType) {\n+        Set<String> locationsSet = new LinkedHashSet<>();\n+        \/\/ The following names should be localized\n+        if (taglet.inOverview()) {\n+            locationsSet.add(\"overview\");\n+        }\n+        if (taglet.inModule()) {\n+            locationsSet.add(\"module\");\n+        }\n+        if (taglet.inPackage()) {\n+            locationsSet.add(\"package\");\n+        }\n+        if (taglet.inType()) {\n+            locationsSet.add(\"class\/interface\");\n+        }\n+        if (taglet.inConstructor())  {\n+            locationsSet.add(\"constructor\");\n+        }\n+        if (taglet.inField()) {\n+            locationsSet.add(\"field\");\n+        }\n+        if (taglet.inMethod()) {\n+            locationsSet.add(\"method\");\n+        }\n+        if (locationsSet.isEmpty()) {\n+            \/\/This known tag is excluded.\n+            return;\n+        }\n+        var combined_locations = String.join(\", \", locationsSet);\n+        messages.warning(ch.getDocTreePath(tag), \"doclet.tag_misuse\",\n+            \"@\" + taglet.getName(), holderType, combined_locations);\n+    }\n+\n+    \/**\n+     * Returns the taglets that can appear inline, in descriptive text.\n+     * @return the taglets that can appear inline\n+     *\/\n+    Map<String, Taglet> getInlineTaglets() {\n+        if (inlineTags == null) {\n+            initTaglets();\n+        }\n+        return inlineTags;\n+    }\n+\n+    \/**\n+     * Returns the taglets that can appear in the serialized form.\n+     * @return the taglet that can appear in the serialized form\n+     *\/\n+    public List<Taglet> getSerializedFormTaglets() {\n+        if (serializedFormTags == null) {\n+            initTaglets();\n+        }\n+        return serializedFormTags;\n+    }\n+\n+    \/**\n+     * Returns the custom tags for a given element.\n+     *\n+     * @param e the element to get custom tags for\n+     * @return the array of {@code Taglet}s that can\n+     * appear in the given element\n+     *\/\n+    @SuppressWarnings(\"fallthrough\")\n+    public List<Taglet> getBlockTaglets(Element e) {\n+        if (blockTagletsByLocation == null) {\n+            initTaglets();\n+        }\n+\n+        switch (e.getKind()) {\n+            case CONSTRUCTOR:\n+                return blockTagletsByLocation.get(Location.CONSTRUCTOR);\n+            case METHOD:\n+                return blockTagletsByLocation.get(Location.METHOD);\n+            case ENUM_CONSTANT:\n+            case FIELD:\n+                return blockTagletsByLocation.get(Location.FIELD);\n+            case ANNOTATION_TYPE:\n+            case INTERFACE:\n+            case CLASS:\n+            case ENUM:\n+            case RECORD:\n+                return blockTagletsByLocation.get(Location.TYPE);\n+            case MODULE:\n+                return blockTagletsByLocation.get(Location.MODULE);\n+            case PACKAGE:\n+                return blockTagletsByLocation.get(Location.PACKAGE);\n+            case OTHER:\n+                if (e instanceof DocletElement de) {\n+                    switch (de.getSubKind()) {\n+                        case DOCFILE:\n+                            return blockTagletsByLocation.get(Location.PACKAGE);\n+                        case OVERVIEW:\n+                            return blockTagletsByLocation.get(Location.OVERVIEW);\n+                        default:\n+                            \/\/ fall through\n+                    }\n+                }\n+                \/\/ fall through\n+            default:\n+                throw new AssertionError(\"unknown element: \" + e + \" ,kind: \" + e.getKind());\n+        }\n+    }\n+\n+    \/**\n+     * Initialize the tag collections.\n+     *\/\n+    private void initTaglets() {\n+\n+        blockTagletsByLocation = new EnumMap<>(Location.class);\n+        for (Location site : Location.values()) {\n+            blockTagletsByLocation.put(site, new ArrayList<>());\n+        }\n+\n+        inlineTags = new LinkedHashMap<>();\n+\n+        allTaglets.forEach((name, t) -> {\n+            if (t.isInlineTag()) {\n+                inlineTags.put(t.getName(), t);\n+            }\n+\n+            if (t.isBlockTag() && t.getName().equals(name)) {\n+                t.getAllowedLocations().forEach(l -> blockTagletsByLocation.get(l).add(t));\n+            }\n+        });\n+\n+        \/\/ init the serialized form tags for the serialized form page\n+        serializedFormTags = new ArrayList<>();\n+        serializedFormTags.add(allTaglets.get(SERIAL_DATA.tagName));\n+        serializedFormTags.add(allTaglets.get(PARAM.tagName));\n+        serializedFormTags.add(allTaglets.get(THROWS.tagName));\n+        if (!nosince)\n+            serializedFormTags.add(allTaglets.get(SINCE.tagName));\n+        serializedFormTags.add(allTaglets.get(SEE.tagName));\n+\n+        if (showTaglets) {\n+            showTaglets(System.out);\n+        }\n+    }\n+\n+    \/**\n+     * Initialize standard Javadoc tags for ordering purposes.\n+     *\/\n+    private void initStandardTaglets() {\n+        if (javafx) {\n+            initJavaFXTaglets();\n+        }\n+\n+        addStandardTaglet(new ParamTaglet(config));\n+        addStandardTaglet(new ReturnTaglet(config));\n+        addStandardTaglet(new ThrowsTaglet(config), EXCEPTION);\n+        addStandardTaglet(\n+                new SimpleTaglet(config, SINCE, resources.getText(\"doclet.Since\"),\n+                    EnumSet.allOf(Location.class), !nosince));\n+        addStandardTaglet(\n+                new SimpleTaglet(config, VERSION, resources.getText(\"doclet.Version\"),\n+                    EnumSet.of(Location.OVERVIEW, Location.MODULE, Location.PACKAGE, Location.TYPE), showversion));\n+        addStandardTaglet(\n+                new SimpleTaglet(config, AUTHOR, resources.getText(\"doclet.Author\"),\n+                    EnumSet.of(Location.OVERVIEW, Location.MODULE, Location.PACKAGE, Location.TYPE), showauthor));\n+        addStandardTaglet(\n+                new SimpleTaglet(config, SERIAL_DATA, resources.getText(\"doclet.SerialData\"),\n+                    EnumSet.noneOf(Location.class)));\n+        addStandardTaglet(\n+                new SimpleTaglet(config, HIDDEN, null,\n+                    EnumSet.of(Location.TYPE, Location.METHOD, Location.FIELD)));\n+\n+        \/\/ This appears to be a default custom (non-standard) taglet\n+        Taglet factoryTaglet = new SimpleTaglet(config, \"factory\", resources.getText(\"doclet.Factory\"),\n+                EnumSet.of(Location.METHOD));\n+        allTaglets.put(factoryTaglet.getName(), factoryTaglet);\n+\n+        addStandardTaglet(new SeeTaglet(config));\n+        addStandardTaglet(new SpecTaglet(config));\n+\n+        \/\/ Standard inline tags\n+        addStandardTaglet(new DocRootTaglet(config));\n+        addStandardTaglet(new InheritDocTaglet(config));\n+        addStandardTaglet(new ValueTaglet(config));\n+        addStandardTaglet(new LinkTaglet(config, DocTree.Kind.LINK));\n+        addStandardTaglet(new LinkTaglet(config, DocTree.Kind.LINK_PLAIN));\n+        addStandardTaglet(new LiteralTaglet(config, DocTree.Kind.CODE));\n+        addStandardTaglet(new LiteralTaglet(config, DocTree.Kind.LITERAL));\n+        addStandardTaglet(new SnippetTaglet(config));\n+        addStandardTaglet(new IndexTaglet(config));\n+        addStandardTaglet(new SummaryTaglet(config));\n+        addStandardTaglet(new SystemPropertyTaglet(config));\n+\n+        \/\/ Keep track of the names of standard tags for error checking purposes.\n+        \/\/ The following are not handled above.\n+        addStandardTaglet(new DeprecatedTaglet(config));\n+        addStandardTaglet(new BaseTaglet(config, USES, false, EnumSet.of(jdk.javadoc.doclet.Taglet.Location.MODULE)));\n+        addStandardTaglet(new BaseTaglet(config, PROVIDES, false, EnumSet.of(jdk.javadoc.doclet.Taglet.Location.MODULE)));\n+        addStandardTaglet(\n+                new SimpleTaglet(config, SERIAL, null,\n+                        EnumSet.of(jdk.javadoc.doclet.Taglet.Location.PACKAGE, jdk.javadoc.doclet.Taglet.Location.TYPE, jdk.javadoc.doclet.Taglet.Location.FIELD)));\n+        addStandardTaglet(\n+                new SimpleTaglet(config, SERIAL_FIELD, null, EnumSet.of(jdk.javadoc.doclet.Taglet.Location.FIELD)));\n+    }\n+\n+    \/**\n+     * Initialize JavaFX-related tags.\n+     *\/\n+    private void initJavaFXTaglets() {\n+        addStandardTaglet(new SimpleTaglet(config, \"propertyDescription\",\n+                resources.getText(\"doclet.PropertyDescription\"),\n+                EnumSet.of(jdk.javadoc.doclet.Taglet.Location.METHOD, jdk.javadoc.doclet.Taglet.Location.FIELD)));\n+        addStandardTaglet(new SimpleTaglet(config, \"defaultValue\", resources.getText(\"doclet.DefaultValue\"),\n+                EnumSet.of(jdk.javadoc.doclet.Taglet.Location.METHOD, jdk.javadoc.doclet.Taglet.Location.FIELD)));\n+        addStandardTaglet(new SimpleTaglet(config, \"treatAsPrivate\", null,\n+                EnumSet.of(jdk.javadoc.doclet.Taglet.Location.TYPE, jdk.javadoc.doclet.Taglet.Location.METHOD, jdk.javadoc.doclet.Taglet.Location.FIELD)));\n+    }\n+\n+    private void addStandardTaglet(Taglet taglet) {\n+        String name = taglet.getName();\n+        allTaglets.put(name, taglet);\n+        standardTags.add(name);\n+        standardTagsLowercase.add(Utils.toLowerCase(name));\n+    }\n+\n+    private void addStandardTaglet(Taglet taglet, DocTree.Kind alias) {\n+        addStandardTaglet(taglet);\n+        String name = alias.tagName;\n+        allTaglets.put(name, taglet);\n+        standardTags.add(name);\n+        standardTagsLowercase.add(Utils.toLowerCase(name));\n+    }\n+\n+    public boolean isKnownCustomTag(String tagName) {\n+        return allTaglets.containsKey(tagName);\n+    }\n+\n+    \/**\n+     * Print a list of {@link Taglet}s that might conflict with\n+     * standard tags in the future and a list of standard tags\n+     * that have been overridden.\n+     *\/\n+    public void printReport() {\n+        printReportHelper(\"doclet.Notice_taglet_conflict_warn\", potentiallyConflictingTags);\n+        printReportHelper(\"doclet.Notice_taglet_overridden\", overriddenStandardTags);\n+        printReportHelper(\"doclet.Notice_taglet_unseen\", unseenCustomTags);\n+    }\n+\n+    private void printReportHelper(String noticeKey, Set<String> names) {\n+        if (!names.isEmpty()) {\n+            StringBuilder result = new StringBuilder();\n+            for (String name : names) {\n+                result.append(result.length() == 0 ? \" \" : \", \");\n+                result.append(\"@\").append(name);\n+            }\n+            messages.notice(noticeKey, result);\n+        }\n+    }\n+\n+    \/**\n+     * Given the name of a tag, return the corresponding taglet.\n+     *\n+     * @param name the name of the taglet to retrieve\n+     * @return the corresponding taglet or {@code null} if the tag is unknown\n+     *\/\n+    Taglet getTaglet(String name) {\n+        if (name.indexOf(\"@\") == 0) {\n+            return allTaglets.get(name.substring(1));\n+        } else {\n+            return allTaglets.get(name);\n+        }\n+    }\n+\n+    public Taglet getTaglet(DocTree.Kind kind) {\n+        return switch (kind) {\n+            case DEPRECATED, LINK, LINK_PLAIN, PARAM, RETURN, THROWS -> getTaglet(kind.tagName);\n+            default ->\n+                throw new IllegalArgumentException(kind.toString());\n+        };\n+    }\n+\n+    \/*\n+     * The output of this method is the basis for a table at the end of the\n+     * doc comment specification, so any changes in the output may indicate\n+     * a need for a corresponding update to the spec.\n+     *\/\n+    private void showTaglets(PrintStream out) {\n+        Map<String, Taglet> taglets = new TreeMap<>(allTaglets);\n+\n+        taglets.forEach((n, t) -> {\n+            \/\/ give preference to simpler block form if a tag can be either\n+            String name = t.isBlockTag() ? \"@\" + n : \"{@\" + n + \"}\";\n+            out.println(String.format(\"%20s\", name) + \": \"\n+                    + format(t.isBlockTag(), \"block\")+ \" \"\n+                    + format(t.inOverview(), \"overview\") + \" \"\n+                    + format(t.inModule(), \"module\") + \" \"\n+                    + format(t.inPackage(), \"package\") + \" \"\n+                    + format(t.inType(), \"type\") + \" \"\n+                    + format(t.inConstructor(),\"constructor\") + \" \"\n+                    + format(t.inMethod(), \"method\") + \" \"\n+                    + format(t.inField(), \"field\") + \" \"\n+                    + format(t.isInlineTag(), \"inline\")+ \" \"\n+                    + format((t instanceof SimpleTaglet st) && !st.isEnabled(), \"disabled\"));\n+        });\n+    }\n+\n+    private String format(boolean b, String s) {\n+        return b ? s : \".\".repeat(s.length()); \/\/ \"replace\" all with \".\"\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/TagletManager.java","additions":749,"deletions":0,"binary":false,"changes":749,"status":"added"},{"patch":"@@ -0,0 +1,474 @@\n+\/*\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.ModuleElement;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.util.SimpleElementVisitor14;\n+\n+import com.sun.source.doctree.DocTree;\n+\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlDocletWriter;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlIds;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlOptions;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlId;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.taglets.Taglet.UnsupportedTagletOperationException;\n+import jdk.javadoc.internal.doclets.toolkit.DocletElement;\n+import jdk.javadoc.internal.doclets.toolkit.Resources;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocLink;\n+import jdk.javadoc.internal.doclets.toolkit.util.IndexItem;\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+\n+\/**\n+ * Context and utility methods for taglet classes.\n+ *\/\n+public class TagletWriter {\n+\n+    \/**\n+     * A class that provides the information about the enclosing context for\n+     * a series of {@code DocTree} nodes.\n+     * This context may be used to determine the content that should be generated from the tree nodes.\n+     *\/\n+    public static class Context {\n+        \/**\n+         * Whether the trees are appearing in a context of just the first sentence,\n+         * such as in the summary table of the enclosing element.\n+         *\/\n+        public final boolean isFirstSentence;\n+        \/**\n+         * Whether the trees are appearing in the \"summary\" section of the\n+         * page for a declaration.\n+         *\/\n+        public final boolean inSummary;\n+        \/**\n+         * The set of enclosing kinds of tags.\n+         *\/\n+        public final Set<DocTree.Kind> inTags;\n+\n+        \/**\n+         * Creates an outermost context, with no enclosing tags.\n+         *\n+         * @param isFirstSentence {@code true} if the trees are appearing in a context of just the\n+         *                        first sentence and {@code false} otherwise\n+         * @param inSummary       {@code true} if the trees are appearing in the \"summary\" section\n+         *                        of the page for a declaration and {@code false} otherwise\n+         *\/\n+        public Context(boolean isFirstSentence, boolean inSummary) {\n+            this(isFirstSentence, inSummary, EnumSet.noneOf(DocTree.Kind.class));\n+        }\n+\n+        private Context(boolean isFirstSentence, boolean inSummary, Set<DocTree.Kind> inTags) {\n+            this.isFirstSentence = isFirstSentence;\n+            this.inSummary = inSummary;\n+            this.inTags = inTags;\n+        }\n+\n+        \/**\n+         * Creates a new {@code Context} that includes an extra tag kind in the set of enclosing\n+         * kinds of tags.\n+         *\n+         * @param tree the enclosing tree\n+         *\n+         * @return the new {@code Context}\n+         *\/\n+        public Context within(DocTree tree) {\n+            var newInTags = EnumSet.copyOf(inTags);\n+            newInTags.add(tree.getKind());\n+            return new Context(isFirstSentence, inSummary, newInTags);\n+        }\n+    }\n+\n+    public final HtmlDocletWriter htmlWriter;\n+    public final HtmlConfiguration configuration;\n+    public final HtmlOptions options;\n+    public final Utils utils;\n+    public final Resources resources;\n+\n+    \/**\n+     * The context in which to generate the output for a series of {@code DocTree} nodes.\n+     *\/\n+    public final Context context;\n+    \/**\n+     * Creates a taglet writer.\n+     *\n+     * @param htmlWriter      the {@code HtmlDocletWriter} for the page\n+     * @param isFirstSentence {@code true} if this taglet writer is being used for a\n+     *                        \"first sentence\" summary\n+     *\/\n+    public TagletWriter(HtmlDocletWriter htmlWriter, boolean isFirstSentence) {\n+        this(htmlWriter, isFirstSentence, false);\n+    }\n+\n+    \/**\n+     * Creates a taglet writer.\n+     *\n+     * @param htmlWriter      the {@code HtmlDocletWriter} for the page\n+     * @param isFirstSentence {@code true} if this taglet writer is being used for a\n+     *                        \"first sentence\" summary, and {@code false} otherwise\n+     * @param inSummary       {@code true} if this taglet writer is being used for the content\n+     *                        of a {@code {@summary ...}} tag, and {@code false} otherwise\n+     *\/\n+    public TagletWriter(HtmlDocletWriter htmlWriter, boolean isFirstSentence, boolean inSummary) {\n+        this(htmlWriter, new Context(isFirstSentence, inSummary));\n+    }\n+\n+    \/**\n+     * Creates a taglet writer.\n+     *\n+     * @param htmlWriter the {@code HtmlDocletWriter} for the page\n+     * @param context    the enclosing context for any tags\n+     *\/\n+    public TagletWriter(HtmlDocletWriter htmlWriter, Context context) {\n+        this.htmlWriter = Objects.requireNonNull(htmlWriter);\n+        this.context = Objects.requireNonNull(context);\n+        configuration = htmlWriter.configuration;\n+        options = configuration.getOptions();\n+        utils = configuration.utils;\n+        resources = configuration.getDocResources();\n+    }\n+\n+    public Context getContext() {\n+        return context;\n+    }\n+\n+    \/**\n+     * Returns an instance of an output object.\n+     *\n+     * @return an instance of an output object\n+     *\/\n+    public Content getOutputInstance() {\n+        return new ContentBuilder();\n+    }\n+\n+    \/**\n+     * Returns the output for an invalid tag. The returned content uses special styling to\n+     * highlight the problem. Depending on the presence of the {@code detail} string the method\n+     * returns a plain text span or an expandable component.\n+     *\n+     * @param summary the single-line summary message\n+     * @param detail the optional detail message which may contain preformatted text\n+     * @return the output\n+     *\/\n+    public Content invalidTagOutput(String summary, Optional<String> detail) {\n+        return htmlWriter.invalidTagOutput(summary,\n+                detail.isEmpty() || detail.get().isEmpty()\n+                        ? Optional.empty()\n+                        : Optional.of(Text.of(Text.normalizeNewlines(detail.get()))));\n+    }\n+\n+    \/**\n+     * Returns the main type element of the current page or null for pages that don't have one.\n+     *\n+     * @return the type element of the current page or null.\n+     *\/\n+    public TypeElement getCurrentPageElement() {\n+        return htmlWriter.getCurrentPageElement();\n+    }\n+\n+    \/**\n+     * Returns the content generated from the block tags for a given element.\n+     * The content is generated according to the order of the list of taglets.\n+     * The result is a possibly-empty list of the output generated by each\n+     * of the given taglets for all of the tags they individually support.\n+     *\n+     * @param tagletManager the manager that manages the taglets\n+     * @param element       the element that we are to write tags for\n+     * @param taglets       the taglets for the tags to write\n+     *\n+     * @return the content\n+     *\/\n+    public Content getBlockTagOutput(TagletManager tagletManager,\n+                                    Element element,\n+                                    List<Taglet> taglets) {\n+        for (Taglet t : taglets) {\n+            if (!t.isBlockTag()) {\n+                throw new IllegalArgumentException(t.getName());\n+            }\n+        }\n+\n+        Content output = getOutputInstance();\n+        tagletManager.checkTags(element, utils.getBlockTags(element));\n+        tagletManager.checkTags(element, utils.getFullBody(element));\n+        for (Taglet taglet : taglets) {\n+            if (utils.isTypeElement(element) && taglet instanceof ParamTaglet) {\n+                \/\/ The type parameters and state components are documented in a special\n+                \/\/ section away from the tag info, so skip here.\n+                continue;\n+            }\n+\n+            if (element.getKind() == ElementKind.MODULE && taglet instanceof BaseTaglet t) {\n+                switch (t.getTagKind()) {\n+                    \/\/ @uses and @provides are handled separately, so skip here.\n+                    \/\/ See ModuleWriterImpl.computeModulesData\n+                    case USES:\n+                    case PROVIDES:\n+                        continue;\n+                }\n+            }\n+\n+            if (taglet instanceof DeprecatedTaglet) {\n+                \/\/Deprecated information is documented \"inline\", not in tag info\n+                \/\/section.\n+                continue;\n+            }\n+\n+            if (taglet instanceof SimpleTaglet st && !st.isEnabled()) {\n+                \/\/ taglet has been disabled\n+                continue;\n+            }\n+\n+            try {\n+                Content tagletOutput = taglet.getAllBlockTagOutput(element, this);\n+                if (tagletOutput != null) {\n+                    tagletManager.seenTag(taglet.getName());\n+                    output.add(tagletOutput);\n+                }\n+            } catch (UnsupportedTagletOperationException e) {\n+                \/\/ malformed taglet:\n+                \/\/ claims to support block tags (see Taglet.isBlockTag) but does not provide the\n+                \/\/ appropriate method, Taglet.getAllBlockTagOutput.\n+            }\n+        }\n+        return output;\n+    }\n+\n+    \/**\n+     * Returns the content generated from an inline tag in the doc comment for a given element,\n+     * or {@code null} if the tag is not supported or does not return any output.\n+     *\n+     * @param holder        the element associated with the doc comment\n+     * @param inlineTag     the inline tag to be documented\n+     *\n+     * @return the content, or {@code null}\n+     *\/\n+    public Content getInlineTagOutput(Element holder,\n+                                      DocTree inlineTag) {\n+        var tagletManager = configuration.tagletManager;\n+        Map<String, Taglet> inlineTags = tagletManager.getInlineTaglets();\n+        CommentHelper ch = configuration.utils.getCommentHelper(holder);\n+        final String inlineTagName = ch.getTagName(inlineTag);\n+        Taglet t = inlineTags.get(inlineTagName);\n+        if (t == null) {\n+            return null;\n+        }\n+\n+        try {\n+            Content tagletOutput = t.getInlineTagOutput(holder, inlineTag, this);\n+            tagletManager.seenTag(t.getName());\n+            return tagletOutput;\n+        } catch (UnsupportedTagletOperationException e) {\n+            \/\/ malformed taglet:\n+            \/\/ claims to support inline tags (see Taglet.isInlineTag) but does not provide the\n+            \/\/ appropriate method, Taglet.getInlineTagOutput.\n+            return null;\n+        }\n+    }\n+\n+    \/**\n+     * Converts inline tags and text to content, expanding the\n+     * inline tags along the way.  Called wherever text can contain\n+     * an inline tag, such as in comments or in free-form text arguments\n+     * to block tags.\n+     *\n+     * @param holderTree the tree that holds the documentation\n+     * @param trees      list of {@code DocTree} nodes containing text and inline tags (often alternating)\n+     *                   present in the text of interest for this doc\n+     *\n+     * @return the generated content\n+     *\/\n+    public Content commentTagsToOutput(DocTree holderTree, List<? extends DocTree> trees) {\n+        return commentTagsToOutput(null, holderTree, trees, false);\n+    }\n+\n+    \/**\n+     * Converts inline tags and text to content, expanding the\n+     * inline tags along the way.  Called wherever text can contain\n+     * an inline tag, such as in comments or in free-form text arguments\n+     * to block tags.\n+     *\n+     * @param element The element that owns the documentation\n+     * @param trees  list of {@code DocTree} nodes containing text and inline tags (often alternating)\n+     *               present in the text of interest for this doc\n+     *\n+     * @return the generated content\n+     *\/\n+    public Content commentTagsToOutput(Element element, List<? extends DocTree> trees) {\n+        return commentTagsToOutput(element, null, trees, false);\n+    }\n+\n+    \/**\n+     * Converts inline tags and text to content, expanding the\n+     * inline tags along the way.  Called wherever text can contain\n+     * an inline tag, such as in comments or in free-form text arguments\n+     * to non-inline tags.\n+     *\n+     * @param element          the element where comment resides\n+     * @param holder       the tag that holds the documentation\n+     * @param trees           array of text tags and inline tags (often alternating)\n+     *                        present in the text of interest for this doc\n+     * @param isFirstSentence true if this is the first sentence\n+     *\n+     * @return the generated content\n+     *\/\n+    public Content commentTagsToOutput(Element element,\n+                                       DocTree holder,\n+                                       List<? extends DocTree> trees,\n+                                       boolean isFirstSentence)\n+    {\n+        return htmlWriter.commentTagsToContent(element,\n+                trees, holder == null ? context : context.within(holder));\n+    }\n+\n+    public Content createAnchorAndSearchIndex(Element element, String tagText, String desc, DocTree tree) {\n+        return createAnchorAndSearchIndex(element, tagText, Text.of(tagText), desc, tree);\n+    }\n+\n+    @SuppressWarnings(\"preview\")\n+    Content createAnchorAndSearchIndex(Element element, String tagText, Content tagContent, String desc, DocTree tree) {\n+        Content result;\n+        if (context.isFirstSentence && context.inSummary || context.inTags.contains(DocTree.Kind.INDEX)) {\n+            result = tagContent;\n+        } else {\n+            HtmlId id = HtmlIds.forText(tagText, htmlWriter.indexAnchorTable);\n+            result = HtmlTree.SPAN(id, HtmlStyle.searchTagResult, tagContent);\n+            if (options.createIndex() && !tagText.isEmpty()) {\n+                String holder = getHolderName(element);\n+                IndexItem item = IndexItem.of(element, tree, tagText, holder, desc,\n+                        new DocLink(htmlWriter.path, id.name()));\n+                configuration.mainIndex.add(item);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    public String getHolderName(Element element) {\n+        return new SimpleElementVisitor14<String, Void>() {\n+\n+            @Override\n+            public String visitModule(ModuleElement e, Void p) {\n+                return resources.getText(\"doclet.module\")\n+                        + \" \" + utils.getFullyQualifiedName(e);\n+            }\n+\n+            @Override\n+            public String visitPackage(PackageElement e, Void p) {\n+                return resources.getText(\"doclet.package\")\n+                        + \" \" + utils.getFullyQualifiedName(e);\n+            }\n+\n+            @Override\n+            public String visitType(TypeElement e, Void p) {\n+                return utils.getTypeElementKindName(e, true)\n+                        + \" \" + utils.getFullyQualifiedName(e);\n+            }\n+\n+            @Override\n+            public String visitExecutable(ExecutableElement e, Void p) {\n+                return utils.getFullyQualifiedName(utils.getEnclosingTypeElement(e))\n+                        + \".\" + utils.getSimpleName(e)\n+                        + utils.flatSignature(e, htmlWriter.getCurrentPageElement());\n+            }\n+\n+            @Override\n+            public String visitVariable(VariableElement e, Void p) {\n+                return utils.getFullyQualifiedName(utils.getEnclosingTypeElement(e))\n+                        + \".\" + utils.getSimpleName(e);\n+            }\n+\n+            @Override\n+            public String visitUnknown(Element e, Void p) {\n+                if (e instanceof DocletElement de) {\n+                    return switch (de.getSubKind()) {\n+                        case OVERVIEW -> resources.getText(\"doclet.Overview\");\n+                        case DOCFILE -> getHolderName(de);\n+                    };\n+                } else {\n+                    return super.visitUnknown(e, p);\n+                }\n+            }\n+\n+            @Override\n+            protected String defaultAction(Element e, Void p) {\n+                return utils.getFullyQualifiedName(e);\n+            }\n+        }.visit(element);\n+    }\n+\n+    private String getHolderName(DocletElement de) {\n+        PackageElement pe = de.getPackageElement();\n+        if (pe.isUnnamed()) {\n+            \/\/ if package is unnamed use enclosing module only if it is named\n+            Element ee = pe.getEnclosingElement();\n+            if (ee instanceof ModuleElement && !((ModuleElement)ee).isUnnamed()) {\n+                return resources.getText(\"doclet.module\") + \" \" + utils.getFullyQualifiedName(ee);\n+            }\n+            return pe.toString(); \/\/ \"Unnamed package\" or similar\n+        }\n+        return resources.getText(\"doclet.package\") + \" \" + utils.getFullyQualifiedName(pe);\n+    }\n+\n+    Content tagList(List<Content> items) {\n+        \/\/ Use a different style if any list item is longer than 30 chars or contains commas.\n+        boolean hasLongLabels = items.stream().anyMatch(this::isLongOrHasComma);\n+        var list = HtmlTree.UL(hasLongLabels ? HtmlStyle.tagListLong : HtmlStyle.tagList);\n+        items.stream()\n+                .filter(Predicate.not(Content::isEmpty))\n+                .forEach(item -> list.add(HtmlTree.LI(item)));\n+        return list;\n+    }\n+\n+\n+    \/\/ Threshold for length of list item for switching from inline to block layout.\n+    private static final int TAG_LIST_ITEM_MAX_INLINE_LENGTH = 30;\n+\n+    private boolean isLongOrHasComma(Content c) {\n+        String s = c.toString()\n+                .replaceAll(\"<.*?>\", \"\")              \/\/ ignore HTML\n+                .replaceAll(\"&#?[A-Za-z0-9]+;\", \" \")  \/\/ entities count as a single character\n+                .replaceAll(\"\\\\R\", \"\\n\");             \/\/ normalize newlines\n+        return s.length() > TAG_LIST_ITEM_MAX_INLINE_LENGTH || s.contains(\",\");\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/TagletWriter.java","additions":474,"deletions":0,"binary":false,"changes":474,"status":"added"},{"patch":"@@ -1,272 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html.taglets;\n-\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.function.Predicate;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.ModuleElement;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-import javax.lang.model.util.SimpleElementVisitor14;\n-\n-import com.sun.source.doctree.DocTree;\n-\n-import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n-import jdk.javadoc.internal.doclets.formats.html.HtmlDocletWriter;\n-import jdk.javadoc.internal.doclets.formats.html.HtmlIds;\n-import jdk.javadoc.internal.doclets.formats.html.HtmlOptions;\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlId;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.DocletElement;\n-import jdk.javadoc.internal.doclets.toolkit.Resources;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.TagletWriter;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocLink;\n-import jdk.javadoc.internal.doclets.toolkit.util.IndexItem;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-\/**\n- * The taglet writer that writes HTML.\n- *\/\n-public class TagletWriterImpl extends TagletWriter {\n-\n-    private final HtmlDocletWriter htmlWriter;\n-    private final HtmlConfiguration configuration;\n-    private final HtmlOptions options;\n-    private final Utils utils;\n-    private final Resources resources;\n-\n-    private final Context context;\n-    \/**\n-     * Creates a taglet writer.\n-     *\n-     * @param htmlWriter      the {@code HtmlDocletWriter} for the page\n-     * @param isFirstSentence {@code true} if this taglet writer is being used for a\n-     *                        \"first sentence\" summary\n-     *\/\n-    public TagletWriterImpl(HtmlDocletWriter htmlWriter, boolean isFirstSentence) {\n-        this(htmlWriter, isFirstSentence, false);\n-    }\n-\n-    \/**\n-     * Creates a taglet writer.\n-     *\n-     * @param htmlWriter      the {@code HtmlDocletWriter} for the page\n-     * @param isFirstSentence {@code true} if this taglet writer is being used for a\n-     *                        \"first sentence\" summary, and {@code false} otherwise\n-     * @param inSummary       {@code true} if this taglet writer is being used for the content\n-     *                        of a {@code {@summary ...}} tag, and {@code false} otherwise\n-     *\/\n-    public TagletWriterImpl(HtmlDocletWriter htmlWriter, boolean isFirstSentence, boolean inSummary) {\n-        this(htmlWriter, new Context(isFirstSentence, inSummary));\n-    }\n-\n-    \/**\n-     * Creates a taglet writer.\n-     *\n-     * @param htmlWriter the {@code HtmlDocletWriter} for the page\n-     * @param context    the enclosing context for any tags\n-     *\/\n-    public TagletWriterImpl(HtmlDocletWriter htmlWriter, Context context) {\n-        super(context);\n-        this.htmlWriter = htmlWriter;\n-        this.context = context;\n-        configuration = htmlWriter.configuration;\n-        options = configuration.getOptions();\n-        utils = configuration.utils;\n-        resources = configuration.getDocResources();\n-    }\n-\n-    @Override\n-    public Content getOutputInstance() {\n-        return new ContentBuilder();\n-    }\n-\n-    Content tagList(List<Content> items) {\n-        \/\/ Use a different style if any list item is longer than 30 chars or contains commas.\n-        boolean hasLongLabels = items.stream().anyMatch(this::isLongOrHasComma);\n-        var list = HtmlTree.UL(hasLongLabels ? HtmlStyle.tagListLong : HtmlStyle.tagList);\n-        items.stream()\n-                .filter(Predicate.not(Content::isEmpty))\n-                .forEach(item -> list.add(HtmlTree.LI(item)));\n-        return list;\n-    }\n-\n-\n-    \/\/ Threshold for length of list item for switching from inline to block layout.\n-    private static final int TAG_LIST_ITEM_MAX_INLINE_LENGTH = 30;\n-\n-    private boolean isLongOrHasComma(Content c) {\n-        String s = c.toString()\n-                .replaceAll(\"<.*?>\", \"\")              \/\/ ignore HTML\n-                .replaceAll(\"&#?[A-Za-z0-9]+;\", \" \")  \/\/ entities count as a single character\n-                .replaceAll(\"\\\\R\", \"\\n\");             \/\/ normalize newlines\n-        return s.length() > TAG_LIST_ITEM_MAX_INLINE_LENGTH || s.contains(\",\");\n-    }\n-\n-    @Override\n-    public Content invalidTagOutput(String summary, Optional<String> detail) {\n-        return htmlWriter.invalidTagOutput(summary,\n-                detail.isEmpty() || detail.get().isEmpty()\n-                        ? Optional.empty()\n-                        : Optional.of(Text.of(Text.normalizeNewlines(detail.get()))));\n-    }\n-\n-    @Override\n-    public Content commentTagsToOutput(DocTree holder, List<? extends DocTree> tags) {\n-        return commentTagsToOutput(null, holder, tags, false);\n-    }\n-\n-    @Override\n-    public Content commentTagsToOutput(Element element, List<? extends DocTree> tags) {\n-        return commentTagsToOutput(element, null, tags, false);\n-    }\n-\n-    @Override\n-    public Content commentTagsToOutput(Element holder,\n-                                       DocTree holderTag,\n-                                       List<? extends DocTree> tags,\n-                                       boolean isFirstSentence)\n-    {\n-        return htmlWriter.commentTagsToContent(holder,\n-                tags, holderTag == null ? context : context.within(holderTag));\n-    }\n-\n-    @Override\n-    public BaseConfiguration configuration() {\n-        return configuration;\n-    }\n-\n-    @Override\n-    protected TypeElement getCurrentPageElement() {\n-        return htmlWriter.getCurrentPageElement();\n-    }\n-\n-    public HtmlDocletWriter getHtmlWriter() {\n-        return htmlWriter;\n-    }\n-\n-    public Utils getUtils() {\n-        return utils;\n-    }\n-\n-    public Content createAnchorAndSearchIndex(Element element, String tagText, String desc, DocTree tree) {\n-        return createAnchorAndSearchIndex(element, tagText, Text.of(tagText), desc, tree);\n-    }\n-\n-    @SuppressWarnings(\"preview\")\n-    Content createAnchorAndSearchIndex(Element element, String tagText, Content tagContent, String desc, DocTree tree) {\n-        Content result;\n-        if (context.isFirstSentence && context.inSummary || context.inTags.contains(DocTree.Kind.INDEX)) {\n-            result = tagContent;\n-        } else {\n-            HtmlId id = HtmlIds.forText(tagText, htmlWriter.indexAnchorTable);\n-            result = HtmlTree.SPAN(id, HtmlStyle.searchTagResult, tagContent);\n-            if (options.createIndex() && !tagText.isEmpty()) {\n-                String holder = getHolderName(element);\n-                IndexItem item = IndexItem.of(element, tree, tagText, holder, desc,\n-                        new DocLink(htmlWriter.path, id.name()));\n-                configuration.mainIndex.add(item);\n-            }\n-        }\n-        return result;\n-    }\n-\n-    public String getHolderName(Element element) {\n-        return new SimpleElementVisitor14<String, Void>() {\n-\n-            @Override\n-            public String visitModule(ModuleElement e, Void p) {\n-                return resources.getText(\"doclet.module\")\n-                        + \" \" + utils.getFullyQualifiedName(e);\n-            }\n-\n-            @Override\n-            public String visitPackage(PackageElement e, Void p) {\n-                return resources.getText(\"doclet.package\")\n-                        + \" \" + utils.getFullyQualifiedName(e);\n-            }\n-\n-            @Override\n-            public String visitType(TypeElement e, Void p) {\n-                return utils.getTypeElementKindName(e, true)\n-                        + \" \" + utils.getFullyQualifiedName(e);\n-            }\n-\n-            @Override\n-            public String visitExecutable(ExecutableElement e, Void p) {\n-                return utils.getFullyQualifiedName(utils.getEnclosingTypeElement(e))\n-                        + \".\" + utils.getSimpleName(e)\n-                        + utils.flatSignature(e, htmlWriter.getCurrentPageElement());\n-            }\n-\n-            @Override\n-            public String visitVariable(VariableElement e, Void p) {\n-                return utils.getFullyQualifiedName(utils.getEnclosingTypeElement(e))\n-                        + \".\" + utils.getSimpleName(e);\n-            }\n-\n-            @Override\n-            public String visitUnknown(Element e, Void p) {\n-                if (e instanceof DocletElement de) {\n-                    return switch (de.getSubKind()) {\n-                        case OVERVIEW -> resources.getText(\"doclet.Overview\");\n-                        case DOCFILE -> getHolderName(de);\n-                    };\n-                } else {\n-                    return super.visitUnknown(e, p);\n-                }\n-            }\n-\n-            @Override\n-            protected String defaultAction(Element e, Void p) {\n-                return utils.getFullyQualifiedName(e);\n-            }\n-        }.visit(element);\n-    }\n-\n-    private String getHolderName(DocletElement de) {\n-        PackageElement pe = de.getPackageElement();\n-        if (pe.isUnnamed()) {\n-            \/\/ if package is unnamed use enclosing module only if it is named\n-            Element ee = pe.getEnclosingElement();\n-            if (ee instanceof ModuleElement && !((ModuleElement)ee).isUnnamed()) {\n-                return resources.getText(\"doclet.module\") + \" \" + utils.getFullyQualifiedName(ee);\n-            }\n-            return pe.toString(); \/\/ \"Unnamed package\" or similar\n-        }\n-        return resources.getText(\"doclet.package\") + \" \" + utils.getFullyQualifiedName(pe);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/TagletWriterImpl.java","additions":0,"deletions":272,"binary":false,"changes":272,"status":"deleted"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n@@ -56,2 +56,6 @@\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.Contents;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlLinkInfo;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n@@ -60,1 +64,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Result;\n@@ -68,1 +71,1 @@\n-public abstract class ThrowsTaglet extends BaseTaglet implements InheritableTaglet {\n+public class ThrowsTaglet extends BaseTaglet implements InheritableTaglet {\n@@ -157,1 +160,4 @@\n-    protected ThrowsTaglet(BaseConfiguration configuration) {\n+    private final HtmlConfiguration config;\n+    private final Contents contents;\n+\n+    ThrowsTaglet(HtmlConfiguration config) {\n@@ -160,1 +166,3 @@\n-        super(configuration, DocTree.Kind.THROWS, false, EnumSet.of(Location.CONSTRUCTOR, Location.METHOD));\n+        super(config, DocTree.Kind.THROWS, false, EnumSet.of(Taglet.Location.CONSTRUCTOR, Taglet.Location.METHOD));\n+        this.config = config;\n+        contents = config.contents;\n@@ -299,1 +307,3 @@\n-    protected abstract Content getThrowsHeader();\n+    private Content getThrowsHeader() {\n+        return HtmlTree.DT(contents.throws_);\n+    }\n@@ -309,1 +319,11 @@\n-    protected abstract Content throwsTagOutput(TypeMirror throwsType, Optional<Content> content);\n+    private Content throwsTagOutput(TypeMirror throwsType, Optional<Content> content) {\n+        var htmlWriter = tagletWriter.htmlWriter;\n+        var linkInfo = new HtmlLinkInfo(config, HtmlLinkInfo.Kind.PLAIN, throwsType);\n+        var link = htmlWriter.getLink(linkInfo);\n+        var concat = new ContentBuilder(HtmlTree.CODE(link));\n+        if (content.isPresent()) {\n+            concat.add(\" - \");\n+            concat.add(content.get());\n+        }\n+        return HtmlTree.DD(concat);\n+    }\n@@ -614,1 +634,1 @@\n-        Result<Map<ThrowsTree, ExecutableElement>> result;\n+        DocFinder.Result<Map<ThrowsTree, ExecutableElement>> result;\n@@ -633,1 +653,1 @@\n-        if (result instanceof Result.Conclude<Map<ThrowsTree, ExecutableElement>> c) {\n+        if (result instanceof DocFinder.Result.Conclude<Map<ThrowsTree, ExecutableElement>> c) {\n@@ -639,3 +659,3 @@\n-    private static Result<Map<ThrowsTree, ExecutableElement>> toResult(Element target,\n-                                                                       ExecutableElement holder,\n-                                                                       List<ThrowsTree> tags) {\n+    private static DocFinder.Result<Map<ThrowsTree, ExecutableElement>> toResult(Element target,\n+                                                                                 ExecutableElement holder,\n+                                                                                 List<ThrowsTree> tags) {\n@@ -644,1 +664,1 @@\n-            return Result.CONCLUDE(toExceptionTags(holder, tags));\n+            return DocFinder.Result.CONCLUDE(toExceptionTags(holder, tags));\n@@ -646,1 +666,1 @@\n-        return Result.CONTINUE();\n+        return DocFinder.Result.CONTINUE();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/ThrowsTaglet.java","additions":36,"deletions":16,"binary":false,"changes":52,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ThrowsTaglet.java","status":"renamed"},{"patch":"@@ -37,2 +37,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.taglets.Taglet;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.TagletWriter;\n@@ -82,2 +80,2 @@\n-        var utils = tagletWriter.configuration().utils;\n-        List<? extends DocTree> tags = utils.getBlockTags(holder, this);\n+        var utils = tagletWriter.utils;\n+        List<? extends DocTree> tags = utils.getBlockTags(holder, getName());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/UserTaglet.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.EnumSet;\n+import java.util.IllegalFormatException;\n+import java.util.Optional;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.VariableElement;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.TextTree;\n+import com.sun.source.doctree.ValueTree;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlLinkInfo;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n+\n+\/**\n+ * An inline taglet representing the value tag. This tag should only be used with\n+ * constant fields that have a value.  It is used to access the value of constant\n+ * fields.  This inline tag has an optional field name parameter.  If the name is\n+ * specified, the constant value is retrieved from the specified field.  A link\n+ * is also created to the specified field.  If a name is not specified, the value\n+ * is retrieved for the field that the inline tag appears on.  The name is specified\n+ * in the following format:  [fully qualified class name]#[constant field name].\n+ *\/\n+public class ValueTaglet extends BaseTaglet {\n+    ValueTaglet(HtmlConfiguration config) {\n+        super(config, DocTree.Kind.VALUE, true, EnumSet.allOf(Taglet.Location.class));\n+    }\n+\n+    \/**\n+     * Returns the referenced field or a null if the value tag\n+     * is empty or the reference is invalid.\n+     *\n+     * @param holder the tag holder.\n+     * @param config the  configuration of the doclet.\n+     * @param tag the value tag.\n+     *\n+     * @return the referenced field or null.\n+     *\/\n+    private VariableElement getVariableElement(Element holder, BaseConfiguration config, DocTree tag) {\n+        CommentHelper ch = config.utils.getCommentHelper(holder);\n+        String signature = ch.getReferencedSignature(tag);\n+\n+        Element e = signature == null\n+                ? holder\n+                : ch.getReferencedMember(tag);\n+\n+        return (e != null && config.utils.isVariableElement(e))\n+                ? (VariableElement) e\n+                : null;\n+    }\n+\n+    @Override\n+    public Content getInlineTagOutput(Element holder, DocTree tag, TagletWriter tagletWriter) {\n+        this.tagletWriter = tagletWriter;\n+        VariableElement field = getVariableElement(holder, config, tag);\n+        if (field == null) {\n+            if (tag.toString().isEmpty()) {\n+                \/\/Invalid use of @value\n+                messages.warning(holder,\n+                        \"doclet.value_tag_invalid_use\");\n+            } else {\n+                \/\/Reference is unknown.\n+                messages.warning(holder,\n+                        \"doclet.value_tag_invalid_reference\", tag.toString());\n+            }\n+        } else if (field.getConstantValue() != null) {\n+            TextTree format = ((ValueTree) tag).getFormat();\n+            String text;\n+            if (format != null) {\n+                String f = format.getBody();\n+                if (f.startsWith(\"\\\"\")) {\n+                    f = f.substring(1, f.length() - 1);\n+                }\n+                try {\n+                    text = String.format(config.getLocale(), f, field.getConstantValue());\n+                } catch (IllegalFormatException e) {\n+                    messages.error(holder,\n+                            \"doclet.value_tag_invalid_format\", format);\n+                    return tagletWriter.invalidTagOutput(\n+                            messages.getResources().getText(\"doclet.value_tag_invalid_format\", format),\n+                            Optional.empty());\n+                }\n+            } else {\n+                text = utils.constantValueExpression(field);\n+            }\n+            return valueTagOutput(field, text, !field.equals(holder));\n+        } else {\n+            \/\/Referenced field is not a constant.\n+            messages.warning(holder,\n+                    \"doclet.value_tag_invalid_constant\", utils.getSimpleName(field));\n+        }\n+        return tagletWriter.getOutputInstance();\n+    }\n+\n+\n+    \/**\n+     * Returns the output for a {@code {@value}} tag.\n+     *\n+     * @param field       the constant field that holds the value tag\n+     * @param constantVal the constant value to document\n+     * @param includeLink true if we should link the constant text to the\n+     *                    constant field itself\n+     *\n+     * @return the output\n+     *\/\n+    private Content valueTagOutput(VariableElement field, String constantVal, boolean includeLink) {\n+        var htmlWriter = tagletWriter.htmlWriter;\n+        return includeLink\n+                ? htmlWriter.getDocLink(HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS, field, constantVal)\n+                : Text.of(constantVal);\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/ValueTaglet.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * This package has classes used to generate output for documentation comment tags.\n+ *\/\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/package-info.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+package jdk.javadoc.internal.doclets.formats.html.taglets.snippet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/snippet\/Action.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Action.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+package jdk.javadoc.internal.doclets.formats.html.taglets.snippet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/snippet\/AddStyle.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/AddStyle.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+package jdk.javadoc.internal.doclets.formats.html.taglets.snippet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/snippet\/Attribute.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Attribute.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+package jdk.javadoc.internal.doclets.formats.html.taglets.snippet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/snippet\/Attributes.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Attributes.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+package jdk.javadoc.internal.doclets.formats.html.taglets.snippet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/snippet\/Bookmark.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Bookmark.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+package jdk.javadoc.internal.doclets.formats.html.taglets.snippet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/snippet\/MarkupParser.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/MarkupParser.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+package jdk.javadoc.internal.doclets.formats.html.taglets.snippet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/snippet\/ParseException.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/ParseException.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+package jdk.javadoc.internal.doclets.formats.html.taglets.snippet;\n@@ -41,0 +41,1 @@\n+import jdk.javadoc.internal.doclets.formats.html.taglets.SnippetTaglet;\n@@ -42,1 +43,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.taglets.SnippetTaglet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/snippet\/Parser.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Parser.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+package jdk.javadoc.internal.doclets.formats.html.taglets.snippet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/snippet\/Replace.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Replace.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+package jdk.javadoc.internal.doclets.formats.html.taglets.snippet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/snippet\/Style.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Style.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+package jdk.javadoc.internal.doclets.formats.html.taglets.snippet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/snippet\/StyledText.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/StyledText.java","status":"renamed"},{"patch":"@@ -28,1 +28,0 @@\n-import java.util.Map;\n@@ -39,2 +38,0 @@\n-import jdk.javadoc.doclet.StandardDoclet;\n-import jdk.javadoc.internal.doclets.formats.html.HtmlDoclet;\n@@ -71,19 +68,0 @@\n-    \/**\n-     * The only doclet that may use this toolkit is {@value}\n-     *\/\n-    private static final String TOOLKIT_DOCLET_NAME =\n-        jdk.javadoc.internal.doclets.formats.html.HtmlDoclet.class.getName();\n-\n-    \/**\n-     * Verify that the only doclet that is using this toolkit is\n-     * #TOOLKIT_DOCLET_NAME.\n-     *\/\n-    private boolean isValidDoclet() {\n-        if (!getClass().getName().equals(TOOLKIT_DOCLET_NAME)) {\n-            messages.error(\"doclet.Toolkit_Usage_Violation\",\n-                TOOLKIT_DOCLET_NAME);\n-            return false;\n-        }\n-        return true;\n-    }\n-\n@@ -104,4 +82,0 @@\n-        if (!isValidDoclet()) {\n-            return false;\n-        }\n-\n@@ -110,1 +84,1 @@\n-                startGeneration();\n+                generateFiles();\n@@ -154,1 +128,1 @@\n-        if (getClass().equals(StandardDoclet.class) || getClass().equals(HtmlDoclet.class)) {\n+        if (getClass().getModule() == AbstractDoclet.class.getModule()) {\n@@ -191,1 +165,1 @@\n-    private void startGeneration() throws DocletException {\n+    protected void generateFiles() throws DocletException {\n@@ -214,1 +188,0 @@\n-        configuration.tagletManager.printReport();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/AbstractDoclet.java","additions":3,"deletions":30,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -29,4 +29,0 @@\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.InvalidPathException;\n-import java.nio.file.Path;\n@@ -34,1 +30,0 @@\n-import java.util.Arrays;\n@@ -56,1 +51,0 @@\n-import javax.tools.DocumentationTool;\n@@ -59,1 +53,0 @@\n-import javax.tools.StandardJavaFileManager;\n@@ -71,1 +64,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.taglets.TagletManager;\n@@ -103,5 +95,0 @@\n-    \/**\n-     * The taglet manager.\n-     *\/\n-    public TagletManager tagletManager;\n-\n@@ -377,22 +364,0 @@\n-        String snippetPath = options.snippetPath();\n-        if (snippetPath != null) {\n-            Messages messages = getMessages();\n-            JavaFileManager fm = getFileManager();\n-            if (fm instanceof StandardJavaFileManager) {\n-                try {\n-                    List<Path> sp = Arrays.stream(snippetPath.split(File.pathSeparator))\n-                            .map(Path::of)\n-                            .toList();\n-                    StandardJavaFileManager sfm = (StandardJavaFileManager) fm;\n-                    sfm.setLocationFromPaths(DocumentationTool.Location.SNIPPET_PATH, sp);\n-                } catch (IOException | InvalidPathException e) {\n-                    throw new SimpleDocletException(messages.getResources().getText(\n-                            \"doclet.error_setting_snippet_path\", snippetPath, e), e);\n-                }\n-            } else {\n-                throw new SimpleDocletException(messages.getResources().getText(\n-                        \"doclet.cannot_use_snippet_path\", snippetPath));\n-            }\n-        }\n-\n-        initTagletManager(options.customTagStrs());\n@@ -454,96 +419,0 @@\n-    \/**\n-     * Initialize the taglet manager.  The strings to initialize the simple custom tags should\n-     * be in the following format:  \"[tag name]:[location str]:[heading]\".\n-     *\n-     * @param customTagStrs the set two dimensional arrays of strings.  These arrays contain\n-     *                      either -tag or -taglet arguments.\n-     *\/\n-    private void initTagletManager(Set<List<String>> customTagStrs) {\n-        tagletManager = tagletManager != null ? tagletManager : newTagletManager();\n-        JavaFileManager fileManager = getFileManager();\n-        Messages messages = getMessages();\n-        try {\n-            tagletManager.initTagletPath(fileManager);\n-            tagletManager.loadTaglets(fileManager);\n-\n-            for (List<String> args : customTagStrs) {\n-                if (args.get(0).equals(\"-taglet\")) {\n-                    tagletManager.addCustomTag(args.get(1), fileManager);\n-                    continue;\n-                }\n-                \/* Since there are few constraints on the characters in a tag name,\n-                 * and real world examples with ':' in the tag name, we cannot simply use\n-                 * String.split(regex);  instead, we tokenize the string, allowing\n-                 * special characters to be escaped with '\\'. *\/\n-                List<String> tokens = tokenize(args.get(1), 3);\n-                switch (tokens.size()) {\n-                    case 1 -> {\n-                        String tagName = args.get(1);\n-                        if (tagletManager.isKnownCustomTag(tagName)) {\n-                            \/\/reorder a standard tag\n-                            tagletManager.addNewSimpleCustomTag(tagName, null, \"\");\n-                        } else {\n-                            \/\/Create a simple tag with the heading that has the same name as the tag.\n-                            StringBuilder heading = new StringBuilder(tagName + \":\");\n-                            heading.setCharAt(0, Character.toUpperCase(tagName.charAt(0)));\n-                            tagletManager.addNewSimpleCustomTag(tagName, heading.toString(), \"a\");\n-                        }\n-                    }\n-\n-                    case 2 ->\n-                        \/\/Add simple taglet without heading, probably to excluding it in the output.\n-                        tagletManager.addNewSimpleCustomTag(tokens.get(0), tokens.get(1), \"\");\n-\n-                    case 3 ->\n-                        tagletManager.addNewSimpleCustomTag(tokens.get(0), tokens.get(2), tokens.get(1));\n-\n-                    default ->\n-                        messages.error(\"doclet.Error_invalid_custom_tag_argument\", args.get(1));\n-                }\n-            }\n-        } catch (IOException e) {\n-            messages.error(\"doclet.taglet_could_not_set_location\", e.toString());\n-        }\n-    }\n-\n-    protected abstract TagletManager newTagletManager();\n-\n-    \/**\n-     * Given a string, return an array of tokens, separated by ':'.\n-     * The separator character can be escaped with the '\\' character.\n-     * The '\\' character may also be escaped with the '\\' character.\n-     *\n-     * @param s         the string to tokenize\n-     * @param maxTokens the maximum number of tokens returned.  If the\n-     *                  max is reached, the remaining part of s is appended\n-     *                  to the end of the last token.\n-     * @return an array of tokens\n-     *\/\n-    private List<String> tokenize(String s, int maxTokens) {\n-        List<String> tokens = new ArrayList<>();\n-        StringBuilder token = new StringBuilder();\n-        boolean prevIsEscapeChar = false;\n-        for (int i = 0; i < s.length(); i += Character.charCount(i)) {\n-            int currentChar = s.codePointAt(i);\n-            if (prevIsEscapeChar) {\n-                \/\/ Case 1:  escaped character\n-                token.appendCodePoint(currentChar);\n-                prevIsEscapeChar = false;\n-            } else if (currentChar == ':' && tokens.size() < maxTokens - 1) {\n-                \/\/ Case 2:  separator\n-                tokens.add(token.toString());\n-                token = new StringBuilder();\n-            } else if (currentChar == '\\\\') {\n-                \/\/ Case 3:  escape character\n-                prevIsEscapeChar = true;\n-            } else {\n-                \/\/ Case 4:  regular character\n-                token.appendCodePoint(currentChar);\n-            }\n-        }\n-        if (token.length() > 0) {\n-            tokens.add(token.toString());\n-        }\n-        return tokens;\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/BaseConfiguration.java","additions":0,"deletions":131,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -35,3 +35,0 @@\n-import java.nio.file.Path;\n-import java.time.Instant;\n-import java.time.ZoneOffset;\n@@ -41,2 +38,0 @@\n-import java.time.temporal.ChronoUnit;\n-import java.time.temporal.TemporalUnit;\n@@ -45,1 +40,0 @@\n-import java.util.Calendar;\n@@ -47,1 +41,0 @@\n-import java.util.LinkedHashSet;\n@@ -52,1 +45,0 @@\n-import java.util.StringTokenizer;\n@@ -57,1 +49,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;\n@@ -90,5 +81,0 @@\n-    \/**\n-     * Arguments for command-line option {@code -tag} and {@code -taglet}.\n-     *\/\n-    private final LinkedHashSet<List<String>> customTagStrs = new LinkedHashSet<>();\n-\n@@ -268,6 +254,0 @@\n-    \/**\n-     * Argument for command-line option {@code --show-taglets}.\n-     * Show taglets (internal debug switch)\n-     *\/\n-    private boolean showTaglets = false;\n-\n@@ -316,12 +296,0 @@\n-    \/**\n-     * Argument for command-line option {@code -tagletpath}.\n-     * The path to Taglets\n-     *\/\n-    private String tagletPath = null;\n-\n-    \/**\n-     * Argument for command-line option {@code --snippet-path}.\n-     * The path for external snippets.\n-     *\/\n-    private String snippetPath = null;\n-\n@@ -620,38 +588,0 @@\n-                new Option(resources, \"-tag\", 1) {\n-                    @Override\n-                    public boolean process(String opt, List<String> args) {\n-                        ArrayList<String> list = new ArrayList<>();\n-                        list.add(opt);\n-                        list.add(args.get(0));\n-                        customTagStrs.add(list);\n-                        return true;\n-                    }\n-                },\n-\n-                new Option(resources, \"-taglet\", 1) {\n-                    @Override\n-                    public boolean process(String opt, List<String> args) {\n-                        ArrayList<String> list = new ArrayList<>();\n-                        list.add(opt);\n-                        list.add(args.get(0));\n-                        customTagStrs.add(list);\n-                        return true;\n-                    }\n-                },\n-\n-                new Option(resources, \"-tagletpath\", 1) {\n-                    @Override\n-                    public boolean process(String opt, List<String> args) {\n-                        tagletPath = args.get(0);\n-                        return true;\n-                    }\n-                },\n-\n-                new Option(resources, \"--snippet-path\", 1) {\n-                    @Override\n-                    public boolean process(String opt, List<String> args) {\n-                        snippetPath = args.get(0);\n-                        return true;\n-                    }\n-                },\n-\n@@ -708,8 +638,0 @@\n-                },\n-\n-                new Hidden(resources, \"--show-taglets\") {\n-                    @Override\n-                    public boolean process(String opt, List<String> args) {\n-                        showTaglets = true;\n-                        return true;\n-                    }\n@@ -804,7 +726,0 @@\n-    \/**\n-     * Arguments for command-line option {@code -tag} and {@code -taglet}.\n-     *\/\n-    LinkedHashSet<List<String>> customTagStrs() {\n-        return customTagStrs;\n-    }\n-\n@@ -1026,1 +941,1 @@\n-     * Default is don't show author information.\n+     * Default is to not show author information.\n@@ -1032,8 +947,0 @@\n-    \/**\n-     * Argument for command-line option {@code --show-taglets}.\n-     * Show taglets (internal debug switch)\n-     *\/\n-    public boolean showTaglets() {\n-        return showTaglets;\n-    }\n-\n@@ -1092,16 +999,0 @@\n-    \/**\n-     * Argument for command-line option {@code -tagletpath}.\n-     * The path to Taglets\n-     *\/\n-    public String tagletPath() {\n-        return tagletPath;\n-    }\n-\n-    \/**\n-     * Argument for command-line option {@code --snippet-path}.\n-     * The path for external snippets.\n-     *\/\n-    public String snippetPath() {\n-        return snippetPath;\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/BaseOptions.java","additions":1,"deletions":110,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -36,0 +36,6 @@\n+    \/**\n+     * Returns an instance of an output object.\n+     *\n+     * @return an instance of an output object\n+     *\/\n+    Content getOutputInstance();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/ClassWriter.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n@@ -146,1 +145,1 @@\n-        Content c = new ContentBuilder();\n+        Content c = writer.getOutputInstance();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/ClassBuilder.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-doclet.Toolkit_Usage_Violation=The Doclet Toolkit can only be used by {0}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets.properties","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.EnumSet;\n-\n-import javax.lang.model.element.Element;\n-\n-import com.sun.source.doctree.DocTree;\n-\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-\n-\/**\n- * A taglet that represents the {@code @deprecated} tag.\n- *\/\n-public abstract class DeprecatedTaglet extends BaseTaglet {\n-\n-    protected DeprecatedTaglet(BaseConfiguration config) {\n-        super(config, DocTree.Kind.DEPRECATED, false,\n-                EnumSet.of(Location.MODULE, Location.TYPE, Location.CONSTRUCTOR, Location.METHOD, Location.FIELD));\n-    }\n-\n-    @Override\n-    public abstract Content getAllBlockTagOutput(Element holder, TagletWriter tagletWriter);\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/DeprecatedTaglet.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.EnumSet;\n-\n-import javax.lang.model.element.Element;\n-\n-import com.sun.source.doctree.DocTree;\n-\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-\n-\/**\n- * An inline taglet representing {@code {@docRoot}}.  This taglet is\n- * used to get the relative path to the document's root output\n- * directory.\n- *\/\n-public abstract class DocRootTaglet extends BaseTaglet {\n-\n-    \/**\n-     * Construct a new DocRootTaglet.\n-     *\/\n-    protected DocRootTaglet(BaseConfiguration config) {\n-        super(config, DocTree.Kind.DOC_ROOT, true, EnumSet.allOf(Location.class));\n-    }\n-\n-    public abstract Content getInlineTagOutput(Element holder, DocTree tag, TagletWriter tagletWriter);\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/DocRootTaglet.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.EnumSet;\n-\n-import javax.lang.model.element.Element;\n-\n-import com.sun.source.doctree.DocTree;\n-\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-\n-\/**\n- * An inline taglet used to index a word or a phrase.\n- * The enclosed text is interpreted as not containing HTML markup or\n- * nested javadoc tags.\n- *\/\n-public abstract class IndexTaglet extends BaseTaglet {\n-\n-    protected IndexTaglet(BaseConfiguration config) {\n-        super(config, DocTree.Kind.INDEX, true, EnumSet.allOf(Location.class));\n-    }\n-\n-    @Override\n-    public abstract Content getInlineTagOutput(Element owner, DocTree tag, TagletWriter tagletWriter) throws\n-            UnsupportedTagletOperationException;\n-\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/IndexTaglet.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.EnumSet;\n-\n-import javax.lang.model.element.Element;\n-\n-import com.sun.source.doctree.DocTree;\n-\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-\n-public abstract class LinkTaglet extends BaseTaglet {\n-\n-    protected LinkTaglet(BaseConfiguration config, DocTree.Kind tagKind) {\n-        super(config, tagKind, true, EnumSet.allOf(Location.class));\n-    }\n-\n-    @Override\n-    public abstract Content getInlineTagOutput(Element e, DocTree tag, TagletWriter tagletWriter);\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/LinkTaglet.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,62 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.EnumSet;\n-\n-import javax.lang.model.element.Element;\n-\n-import com.sun.source.doctree.DocTree;\n-\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-\n-\/**\n- * An inline taglet used to denote literal text, possibly in monospace font.\n- *\n- * For example, the text:\n- * <blockquote>  {@code {@literal a<B>c}}  <\/blockquote>\n- * displays as:\n- * <blockquote>  {@literal a<B>c}  <\/blockquote>\n- *\n- * <p> The tag {@code {@code ...}} is equivalent to\n- * {@code <code>{@literal ...}<\/code>}.\n- *\n- * For example, the text:\n- * <blockquote>  The type {@code {@code List<P>}}  <\/blockquote>\n- * displays as:\n- * <blockquote>  The type {@code List<P>}  <\/blockquote>\n- *\/\n-public abstract class LiteralTaglet extends BaseTaglet {\n-\n-    protected LiteralTaglet(BaseConfiguration config, DocTree.Kind tagKind) {\n-        super(config, tagKind, true, EnumSet.allOf(Location.class));\n-    }\n-\n-    @Override\n-    public abstract Content getInlineTagOutput(Element e, DocTree tag, TagletWriter tagletWriter);\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/LiteralTaglet.java","additions":0,"deletions":62,"binary":false,"changes":62,"status":"deleted"},{"patch":"@@ -1,291 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.EnumSet;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ElementKind;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.TypeElement;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.ParamTree;\n-\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Result;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-\/**\n- * A taglet that represents the {@code @param} tag.\n- *\/\n-public abstract class ParamTaglet extends BaseTaglet implements InheritableTaglet {\n-\n-    public enum ParamKind {\n-        \/** Parameter of an executable element. *\/\n-        PARAMETER,\n-        \/** State components of a record. *\/\n-        RECORD_COMPONENT,\n-        \/** Type parameters of an executable element or type element. *\/\n-        TYPE_PARAMETER\n-    }\n-\n-    \/**\n-     * Construct a ParamTaglet.\n-     *\/\n-    protected ParamTaglet(BaseConfiguration config) {\n-        super(config, DocTree.Kind.PARAM, false, EnumSet.of(Location.TYPE, Location.CONSTRUCTOR, Location.METHOD));\n-    }\n-\n-    @Override\n-    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence) {\n-        assert dst.getKind() == ElementKind.METHOD;\n-        assert tag.getKind() == DocTree.Kind.PARAM;\n-        var method = (ExecutableElement) dst;\n-        var param = (ParamTree) tag;\n-        \/\/ find the position of an owner parameter described by the given tag\n-        List<? extends Element> parameterElements;\n-        if (param.isTypeParameter()) {\n-            parameterElements = method.getTypeParameters();\n-        } else {\n-            parameterElements = method.getParameters();\n-        }\n-        Map<String, Integer> stringIntegerMap = mapNameToPosition(utils, parameterElements);\n-        CommentHelper ch = utils.getCommentHelper(dst);\n-        Integer position = stringIntegerMap.get(ch.getParameterName(param));\n-        if (position == null) {\n-            return new Output(null, null, List.of(), true);\n-        }\n-        \/\/ try to inherit description of the respective parameter in an overridden method\n-        try {\n-            var docFinder = utils.docFinder();\n-\n-            Optional<Documentation> r;\n-            if (src != null){\n-                r = docFinder.search((ExecutableElement) src,\n-                                m -> Result.fromOptional(extract(utils, m, position, param.isTypeParameter())))\n-                        .toOptional();\n-            } else {\n-                r = docFinder.find((ExecutableElement) dst,\n-                                m -> Result.fromOptional(extract(utils, m, position, param.isTypeParameter())))\n-                        .toOptional();\n-            }\n-            return r.map(result -> new Output(result.paramTree, result.method, result.paramTree.getDescription(), true))\n-                    .orElseGet(() -> new Output(null, null, List.of(), true));\n-        } catch (DocFinder.NoOverriddenMethodFound e) {\n-            return new Output(null, null, List.of(), false);\n-        }\n-    }\n-\n-    \/**\n-     * Given a list of parameter elements, returns a name-position map.\n-     * @param params the list of parameters from a type or an executable member\n-     * @return a name-position map\n-     *\/\n-    private static Map<String, Integer> mapNameToPosition(Utils utils, List<? extends Element> params) {\n-        Map<String, Integer> result = new HashMap<>();\n-        int position = 0;\n-        for (Element e : params) {\n-            String name = utils.isTypeParameterElement(e)\n-                    ? utils.getTypeName(e.asType(), false)\n-                    : utils.getSimpleName(e);\n-            result.put(name, position);\n-            position++;\n-        }\n-        return result;\n-    }\n-\n-    @Override\n-    public Content getAllBlockTagOutput(Element holder, TagletWriter tagletWriter) {\n-        this.tagletWriter = tagletWriter;\n-        if (utils.isExecutableElement(holder)) {\n-            ExecutableElement member = (ExecutableElement) holder;\n-            Content output = convertParams(member, ParamKind.TYPE_PARAMETER,\n-                    utils.getTypeParamTrees(member), member.getTypeParameters(), tagletWriter);\n-            output.add(convertParams(member, ParamKind.PARAMETER,\n-                    utils.getParamTrees(member), member.getParameters(), tagletWriter));\n-            return output;\n-        } else {\n-            TypeElement typeElement = (TypeElement) holder;\n-            Content output = convertParams(typeElement, ParamKind.TYPE_PARAMETER,\n-                    utils.getTypeParamTrees(typeElement), typeElement.getTypeParameters(), tagletWriter);\n-            output.add(convertParams(typeElement, ParamKind.RECORD_COMPONENT,\n-                    utils.getParamTrees(typeElement), typeElement.getRecordComponents(), tagletWriter));\n-            return output;\n-        }\n-    }\n-\n-    \/**\n-     * Returns a {@code Content} representation of a list of {@code ParamTree}\n-     * of the specified kind.\n-     *\n-     * <p> This method correlates a {@code ParamTree} with a parameter\n-     * {@code Element} by name. Once it's done, a particular {@code ParamTree}\n-     * is addressed by the position (index) of the correlated {@code Element}\n-     * in the list of parameter elements. This is needed for documentation\n-     * inheritance because the corresponding parameters in the inheritance\n-     * hierarchy may be named differently.\n-     *\n-     * <p> This method warns about {@code @param} tags that do not map to\n-     * parameter elements and param tags that are duplicated. <\/p>\n-     *\n-     * @param kind the kind of <em>all<\/em> parameters in the lists\n-     *\/\n-    private Content convertParams(Element e,\n-                                  ParamKind kind,\n-                                  List<ParamTree> tags,\n-                                  List<? extends Element> parameters,\n-                                  TagletWriter writer) {\n-        Map<Integer, ParamTree> tagOfPosition = new HashMap<>();\n-        CommentHelper ch = utils.getCommentHelper(e);\n-        if (!tags.isEmpty()) {\n-            Map<String, Integer> positionOfName = mapNameToPosition(utils, parameters);\n-            for (ParamTree tag : tags) {\n-                String name = ch.getParameterName(tag);\n-                String paramName = kind == ParamKind.TYPE_PARAMETER ? \"<\" + name + \">\" : name;\n-                if (!positionOfName.containsKey(name)) {\n-                    String key = switch (kind) {\n-                        case PARAMETER -> \"doclet.Parameters_warn\";\n-                        case TYPE_PARAMETER -> \"doclet.TypeParameters_warn\";\n-                        case RECORD_COMPONENT -> \"doclet.RecordComponents_warn\";\n-                    };\n-                    if (!config.isDocLintReferenceGroupEnabled()) {\n-                        messages.warning(ch.getDocTreePath(tag), key, paramName);\n-                    }\n-                }\n-                Integer position = positionOfName.get(name);\n-                if (position != null) {\n-                    if (tagOfPosition.containsKey(position)) {\n-                        String key = switch (kind) {\n-                            case PARAMETER -> \"doclet.Parameters_dup_warn\";\n-                            case TYPE_PARAMETER -> \"doclet.TypeParameters_dup_warn\";\n-                            case RECORD_COMPONENT -> \"doclet.RecordComponents_dup_warn\";\n-                        };\n-                        if (!config.isDocLintReferenceGroupEnabled()) {\n-                            messages.warning(ch.getDocTreePath(tag), key, paramName);\n-                        }\n-                    } else {\n-                        tagOfPosition.put(position, tag);\n-                    }\n-                }\n-            }\n-        }\n-        \/\/ Document declared parameters for which tag documentation is available\n-        \/\/ (either directly or inherited) in order of their declaration.\n-        Content result = writer.getOutputInstance();\n-        for (int i = 0; i < parameters.size(); i++) {\n-            ParamTree tag = tagOfPosition.get(i);\n-            if (tag != null) {\n-                result.add(convertParam(e, kind, writer, tag,\n-                        ch.getParameterName(tag), result.isEmpty()));\n-            } else if (utils.isMethod(e)) {\n-                result.add(getInheritedTagletOutput(kind, e, writer,\n-                        parameters.get(i), i, result.isEmpty()));\n-            }\n-        }\n-        if (tags.size() > tagOfPosition.size()) {\n-            \/\/ Generate documentation for remaining tags that do not match a declared parameter.\n-            \/\/ These are erroneous but we generate them anyway.\n-            for (ParamTree tag : tags) {\n-                if (!tagOfPosition.containsValue(tag)) {\n-                    result.add(convertParam(e, kind, writer, tag,\n-                            ch.getParameterName(tag), result.isEmpty()));\n-                }\n-            }\n-        }\n-        return result;\n-    }\n-\n-    \/**\n-     * Tries to inherit documentation for a specific parameter (element).\n-     * If unsuccessful, the returned content is empty.\n-     *\/\n-    private Content getInheritedTagletOutput(ParamKind kind,\n-                                             Element holder,\n-                                             TagletWriter writer,\n-                                             Element param,\n-                                             int position,\n-                                             boolean isFirst) {\n-        Content result = writer.getOutputInstance();\n-        var r = utils.docFinder().search((ExecutableElement) holder,\n-                        m -> Result.fromOptional(extract(utils, m, position, kind == ParamKind.TYPE_PARAMETER)))\n-                .toOptional();\n-        if (r.isPresent()) {\n-            String name = kind != ParamKind.TYPE_PARAMETER\n-                    ? utils.getSimpleName(param)\n-                    : utils.getTypeName(param.asType(), false);\n-            Content content = convertParam(r.get().method, kind, writer,\n-                    r.get().paramTree, name, isFirst);\n-            result.add(content);\n-        }\n-        return result;\n-    }\n-\n-    public abstract Content getParamHeader(ParamKind kind);\n-\n-    public abstract Content paramTagOutput(Element element, ParamTree paramTag, String paramName);\n-\n-    private record Documentation(ParamTree paramTree, ExecutableElement method) { }\n-\n-    private static Optional<Documentation> extract(Utils utils, ExecutableElement method, Integer position, boolean typeParam) {\n-        var ch = utils.getCommentHelper(method);\n-        List<ParamTree> tags = typeParam\n-                ? utils.getTypeParamTrees(method)\n-                : utils.getParamTrees(method);\n-        List<? extends Element> parameters = typeParam\n-                ? method.getTypeParameters()\n-                : method.getParameters();\n-        var positionOfName = mapNameToPosition(utils, parameters);\n-        return tags.stream().filter(t -> position.equals(positionOfName.get(ch.getParameterName(t))))\n-                .map(t -> new Documentation(t, method)).findAny();\n-    }\n-\n-    \/**\n-     * Converts an individual {@code ParamTree} to {@code Content}, which is\n-     * prepended with the header if the parameter is first in the list.\n-     *\/\n-    private Content convertParam(Element e,\n-                                 ParamKind kind,\n-                                 TagletWriter writer,\n-                                 ParamTree paramTag,\n-                                 String name,\n-                                 boolean isFirstParam) {\n-        Content result = writer.getOutputInstance();\n-        if (isFirstParam) {\n-            result.add(getParamHeader(kind));\n-        }\n-        result.add(paramTagOutput(e, paramTag, name));\n-        return result;\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ParamTaglet.java","additions":0,"deletions":291,"binary":false,"changes":291,"status":"deleted"},{"patch":"@@ -1,138 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.EnumSet;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.stream.Stream;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ElementKind;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.type.TypeMirror;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.ReturnTree;\n-\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Result;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-\/**\n- * A taglet that represents the {@code @return} and {@code {@return }} tags.\n- *\/\n-public abstract class ReturnTaglet extends BaseTaglet implements InheritableTaglet {\n-\n-    protected ReturnTaglet(BaseConfiguration config) {\n-        super(config, DocTree.Kind.RETURN, true, EnumSet.of(Location.METHOD));\n-    }\n-\n-    @Override\n-    public boolean isBlockTag() {\n-        return true;\n-    }\n-\n-    @Override\n-    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence) {\n-        try {\n-            var docFinder = utils.docFinder();\n-            Optional<Documentation> r;\n-            if (src == null) {\n-                r = docFinder.find((ExecutableElement) dst, m -> Result.fromOptional(extract(utils, m))).toOptional();\n-            } else {\n-                r = docFinder.search((ExecutableElement) src, m -> Result.fromOptional(extract(utils, m))).toOptional();\n-            }\n-            return r.map(result -> new Output(result.returnTree, result.method, result.returnTree.getDescription(), true))\n-                    .orElseGet(() -> new Output(null, null, List.of(), true));\n-        } catch (DocFinder.NoOverriddenMethodFound e) {\n-            return new Output(null, null, List.of(), false);\n-        }\n-    }\n-\n-    @Override\n-    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter tagletWriter) {\n-        this.tagletWriter = tagletWriter;\n-        return returnTagOutput(element, (ReturnTree) tag, true);\n-    }\n-\n-    @Override\n-    public Content getAllBlockTagOutput(Element holder, TagletWriter tagletWriter) {\n-        assert holder.getKind() == ElementKind.METHOD : holder.getKind();\n-        var method = (ExecutableElement) holder;\n-        this.tagletWriter = tagletWriter;\n-        List<? extends ReturnTree> tags = utils.getReturnTrees(holder);\n-\n-        \/\/ make sure we are not using @return on a method with the void return type\n-        TypeMirror returnType = utils.getReturnType(tagletWriter.getCurrentPageElement(), method);\n-        if (returnType != null && utils.isVoid(returnType)) {\n-            if (!tags.isEmpty() && !config.isDocLintReferenceGroupEnabled()) {\n-                messages.warning(holder, \"doclet.Return_tag_on_void_method\");\n-            }\n-            return null;\n-        }\n-\n-        \/\/ it would also be good to check if there are more than one @return\n-        \/\/ tags and produce a warning or error similarly to how it's done\n-        \/\/ above for a case where @return is used for void\n-\n-        var docFinder = utils.docFinder();\n-        return docFinder.search(method, m -> Result.fromOptional(extract(utils, m))).toOptional()\n-                .map(r -> returnTagOutput(r.method, r.returnTree, false))\n-                .orElse(null);\n-    }\n-\n-    \/**\n-     * Returns the output for a {@code @return} tag.\n-     *\n-     * @param element   the element that owns the doc comment\n-     * @param returnTag the return tag to document\n-     * @param inline    whether this should be written as an inline instance or block instance\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content returnTagOutput(Element element, ReturnTree returnTag, boolean inline);\n-\n-    private record Documentation(ReturnTree returnTree, ExecutableElement method) { }\n-\n-    private static Optional<Documentation> extract(Utils utils, ExecutableElement method) {\n-        \/\/ TODO\n-        \/\/  Using getBlockTags(..., Kind.RETURN) for clarity. Since @return has become a bimodal tag,\n-        \/\/  Utils.getReturnTrees is now a misnomer: it returns only block returns, not all returns.\n-        \/\/  We could revisit this later.\n-        Stream<? extends ReturnTree> blockTags = utils.getBlockTags(method, DocTree.Kind.RETURN, ReturnTree.class).stream();\n-        Stream<? extends ReturnTree> mainDescriptionTags = utils.getFirstSentenceTrees(method).stream()\n-                .mapMulti((t, c) -> {\n-                    if (t.getKind() == DocTree.Kind.RETURN) c.accept((ReturnTree) t);\n-                });\n-        \/\/ this method should not check validity of @return tags, hence findAny and not findFirst or what have you\n-        return Stream.concat(blockTags, mainDescriptionTags)\n-                .map(t -> new Documentation(t, method)).findAny();\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ReturnTaglet.java","additions":0,"deletions":138,"binary":false,"changes":138,"status":"deleted"},{"patch":"@@ -1,95 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.EnumSet;\n-import java.util.List;\n-import java.util.Optional;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ExecutableElement;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.SeeTree;\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Result;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-\/**\n- * A taglet that represents the {@code @see} tag.\n- *\/\n-public abstract class SeeTaglet extends BaseTaglet implements InheritableTaglet {\n-\n-    protected SeeTaglet(BaseConfiguration config) {\n-        super(config, DocTree.Kind.SEE, false, EnumSet.allOf(Location.class));\n-    }\n-\n-    @Override\n-    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence) {\n-        CommentHelper ch = utils.getCommentHelper(dst);\n-        var path = ch.getDocTreePath(tag);\n-        messages.warning(path, \"doclet.inheritDocWithinInappropriateTag\");\n-        return new Output(null, null, List.of(), true \/* true, otherwise there will be an exception up the stack *\/);\n-    }\n-\n-    @Override\n-    public Content getAllBlockTagOutput(Element holder, TagletWriter tagletWriter) {\n-        this.tagletWriter = tagletWriter;\n-        List<? extends SeeTree> tags = utils.getSeeTrees(holder);\n-        Element e = holder;\n-        if (utils.isMethod(holder)) {\n-            var docFinder = utils.docFinder();\n-            Optional<Documentation> result = docFinder.search((ExecutableElement) holder,\n-                    m -> Result.fromOptional(extract(utils, m))).toOptional();\n-            if (result.isPresent()) {\n-                ExecutableElement m = result.get().method();\n-                tags = utils.getSeeTrees(m);\n-                e = m;\n-            }\n-        }\n-        return seeTagOutput(e, tags);\n-    }\n-\n-    \/**\n-     * Returns the output for {@code @see} tags.\n-     *\n-     * @param element The element that owns the doc comment\n-     * @param seeTags the list of tags\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content seeTagOutput(Element element, List<? extends SeeTree> seeTags);\n-\n-    private record Documentation(List<? extends SeeTree> seeTrees, ExecutableElement method) { }\n-\n-    private static Optional<Documentation> extract(Utils utils, ExecutableElement method) {\n-        List<? extends SeeTree> tags = utils.getSeeTrees(method);\n-        return tags.isEmpty() ? Optional.empty() : Optional.of(new Documentation(tags, method));\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SeeTaglet.java","additions":0,"deletions":95,"binary":false,"changes":95,"status":"deleted"},{"patch":"@@ -1,143 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ElementKind;\n-import javax.lang.model.element.ExecutableElement;\n-\n-import com.sun.source.doctree.DocTree;\n-\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Result;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-\/**\n- * A custom single-argument block tag.\n- *\/\n-public abstract class SimpleTaglet extends BaseTaglet implements InheritableTaglet {\n-\n-    \/**\n-     * The header to output.\n-     *\/\n-    protected String header;\n-\n-    \/**\n-     * Whether or not the taglet should generate output.\n-     * Standard tags like {@code @author}, {@code @since}, {@code @version} can\n-     * be disabled by command-line options; custom tags created with -tag can be\n-     * disabled with an X in the defining string.\n-     *\/\n-    protected final boolean enabled;\n-\n-    \/**\n-     * Constructs a {@code SimpleTaglet}.\n-     *\n-     * @param tagName   the name of this tag\n-     * @param header    the header to output\n-     * @param locations the possible locations that this tag can appear in\n-     *\/\n-    protected SimpleTaglet(BaseConfiguration config, String tagName, String header, Set<Location> locations, boolean enabled) {\n-        super(config, tagName, false, locations);\n-        this.header = header;\n-        this.enabled = enabled;\n-    }\n-\n-    \/**\n-     * Constructs a {@code SimpleTaglet}.\n-     *\n-     * @param tagKind   the kind of this tag\n-     * @param header    the header to output\n-     * @param locations the possible locations that this tag can appear in\n-     *\/\n-    protected SimpleTaglet(BaseConfiguration config, DocTree.Kind tagKind, String header, Set<Location> locations, boolean enabled) {\n-        super(config, tagKind, false, locations);\n-        this.header = header;\n-        this.enabled = enabled;\n-    }\n-\n-    @Override\n-    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence) {\n-        assert dst.getKind() == ElementKind.METHOD;\n-        assert !isFirstSentence;\n-        try {\n-            var docFinder = utils.docFinder();\n-            Optional<Documentation> r;\n-            if (src == null) {\n-                r = docFinder.find((ExecutableElement) dst,\n-                        m -> Result.fromOptional(extractFirst(m, utils))).toOptional();\n-            } else {\n-                r = docFinder.search((ExecutableElement) src,\n-                        m -> Result.fromOptional(extractFirst(m, utils))).toOptional();\n-            }\n-            return r.map(result -> new Output(result.tag, result.method, result.description, true))\n-                    .orElseGet(()->new Output(null, null, List.of(), true));\n-        } catch (DocFinder.NoOverriddenMethodFound e) {\n-            return new Output(null, null, List.of(), false);\n-        }\n-    }\n-\n-    record Documentation(DocTree tag, List<? extends DocTree> description, ExecutableElement method) { }\n-\n-    private Optional<Documentation> extractFirst(ExecutableElement m, Utils utils) {\n-        List<? extends DocTree> tags = utils.getBlockTags(m, this);\n-        if (tags.isEmpty()) {\n-            return Optional.empty();\n-        }\n-        DocTree t = tags.get(0);\n-        return Optional.of(new Documentation(t, utils.getCommentHelper(m).getDescription(t), m));\n-    }\n-\n-    @Override\n-    public Content getAllBlockTagOutput(Element holder, TagletWriter tagletWriter) {\n-        List<? extends DocTree> tags = utils.getBlockTags(holder, this);\n-        if (header == null || tags.isEmpty()) {\n-            return null;\n-        }\n-        return simpleBlockTagOutput(holder, tags, header, tagletWriter);\n-    }\n-\n-    \/**\n-     * Returns the output for a series of simple tags.\n-     *\n-     * @param element    The element that owns the doc comment\n-     * @param simpleTags the list of simple tags\n-     * @param header     the header for the series of tags\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content simpleBlockTagOutput(Element element,\n-                                                    List<? extends DocTree> simpleTags,\n-                                                    String header,\n-                                                    TagletWriter writer);\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SimpleTaglet.java","additions":0,"deletions":143,"binary":false,"changes":143,"status":"deleted"},{"patch":"@@ -1,476 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.io.IOException;\n-import java.util.EnumSet;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.PackageElement;\n-import javax.tools.Diagnostic;\n-import javax.tools.DocumentationTool.Location;\n-import javax.tools.FileObject;\n-\n-import com.sun.source.doctree.AttributeTree;\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.SnippetTree;\n-import com.sun.source.doctree.TextTree;\n-import jdk.javadoc.doclet.Taglet;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.DocletElement;\n-import jdk.javadoc.internal.doclets.toolkit.Resources;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.Action;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.ParseException;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.Parser;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.StyledText;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-\/**\n- * A taglet that represents the {@code @snippet} tag.\n- *\/\n-public abstract class SnippetTaglet extends BaseTaglet {\n-\n-    public enum Language {\n-\n-        JAVA(\"java\"),\n-        PROPERTIES(\"properties\");\n-\n-        private static final Map<String, Language> languages;\n-\n-        static {\n-            Map<String, Language> tmp = new HashMap<>();\n-            for (var language : values()) {\n-                String id = Objects.requireNonNull(language.identifier);\n-                if (tmp.put(id, language) != null)\n-                    throw new IllegalStateException(); \/\/ 1-1 correspondence\n-            }\n-            languages = Map.copyOf(tmp);\n-        }\n-\n-        Language(String id) {\n-            identifier = id;\n-        }\n-\n-        private final String identifier;\n-\n-        public static Optional<Language> of(String identifier) {\n-            if (identifier == null)\n-                return Optional.empty();\n-            return Optional.ofNullable(languages.get(identifier));\n-        }\n-\n-        public String getIdentifier() {return identifier;}\n-    }\n-\n-    protected SnippetTaglet(BaseConfiguration config) {\n-        super(config, DocTree.Kind.SNIPPET, true, EnumSet.allOf(Taglet.Location.class));\n-    }\n-\n-    \/*\n-     * A snippet can specify content by value (inline), by reference (external)\n-     * or both (hybrid).\n-     *\n-     * To specify content by value, a snippet uses its body; the body of\n-     * a snippet is the content.\n-     *\n-     * To specify content by reference, a snippet uses either the \"class\"\n-     * or \"file\" attribute; the value of that attribute refers to the content.\n-     *\n-     * A snippet can specify the \"region\" attribute. That attribute refines\n-     * the location of the content. The value of that attribute must match\n-     * one of the named regions in the snippets content.\n-     *\/\n-    @Override\n-    public Content getInlineTagOutput(Element holder, DocTree tag, TagletWriter tagletWriter) {\n-        this.tagletWriter = tagletWriter;\n-        try {\n-            return generateContent(holder, tag);\n-        } catch (BadSnippetException e) {\n-            error(tagletWriter, holder, e.tag(), e.key(), e.args());\n-            String details = config.getDocResources().getText(e.key(), e.args());\n-            return badSnippet(tagletWriter, Optional.of(details));\n-        }\n-    }\n-\n-    \/**\n-     * Returns the output for a {@code {@snippet ...}} tag.\n-     *\n-     * @param element    The element that owns the doc comment\n-     * @param snippetTag the snippet tag\n-     * @param id         the value of the id attribute, or null if not defined\n-     * @param lang       the value of the lang attribute, or null if not defined\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content snippetTagOutput(Element element, SnippetTree snippetTag, StyledText text,\n-                                                String id, String lang);\n-\n-    private static final class BadSnippetException extends Exception {\n-\n-        @java.io.Serial\n-        private static final long serialVersionUID = 1;\n-\n-        private final transient DocTree tag;\n-        private final String key;\n-        private final transient Object[] args;\n-\n-        BadSnippetException(DocTree tag, String key, Object... args) {\n-            this.tag = tag;\n-            this.key = key;\n-            this.args = args;\n-        }\n-\n-        DocTree tag() {\n-            return tag;\n-        }\n-\n-        String key() {\n-            return key;\n-        }\n-\n-        Object[] args() {\n-            return args;\n-        }\n-    }\n-\n-    private Content generateContent(Element holder, DocTree tag)\n-            throws BadSnippetException\n-    {\n-        SnippetTree snippetTag = (SnippetTree) tag;\n-\n-        \/\/ organize snippet attributes in a map, performing basic checks along the way\n-        Map<String, AttributeTree> attributes = new HashMap<>();\n-        for (DocTree d : snippetTag.getAttributes()) {\n-            if (!(d instanceof AttributeTree a)) {\n-                continue; \/\/ this might be an ErroneousTree\n-            }\n-            if (attributes.putIfAbsent(a.getName().toString(), a) == null) {\n-                continue;\n-            }\n-            \/\/ two like-named attributes found; although we report on the most\n-            \/\/ recently encountered of the two, the iteration order might differ\n-            \/\/ from the source order (see JDK-8266826)\n-            throw new BadSnippetException(a, \"doclet.tag.attribute.repeated\",\n-                    a.getName().toString());\n-        }\n-\n-        final String CLASS = \"class\";\n-        final String FILE = \"file\";\n-\n-        final boolean containsClass = attributes.containsKey(CLASS);\n-        final boolean containsFile = attributes.containsKey(FILE);\n-        final boolean containsBody = snippetTag.getBody() != null;\n-\n-        if (containsClass && containsFile) {\n-            throw new BadSnippetException(attributes.get(CLASS),\n-                    \"doclet.snippet.contents.ambiguity.external\");\n-        } else if (!containsClass && !containsFile && !containsBody) {\n-            throw new BadSnippetException(tag, \"doclet.snippet.contents.none\");\n-        }\n-\n-        String regionName = null;\n-        AttributeTree region = attributes.get(\"region\");\n-        if (region != null) {\n-            regionName = stringValueOf(region);\n-            if (regionName.isBlank()) {\n-                throw new BadSnippetException(region, \"doclet.tag.attribute.value.illegal\",\n-                        \"region\", region.getValue());\n-            }\n-        }\n-\n-        String inlineContent = null, externalContent = null;\n-\n-        if (containsBody) {\n-            inlineContent = snippetTag.getBody().getBody();\n-        }\n-\n-        FileObject fileObject = null;\n-\n-        if (containsFile || containsClass) {\n-            AttributeTree a;\n-            String v = containsFile\n-                    ? stringValueOf((a = attributes.get(FILE)))\n-                    : stringValueOf((a = attributes.get(CLASS))).replace(\".\", \"\/\") + \".java\";\n-\n-            if (v.isBlank()) {\n-                throw new BadSnippetException(a, \"doclet.tag.attribute.value.illegal\",\n-                        containsFile ? FILE : CLASS, v);\n-            }\n-\n-            \/\/ we didn't create JavaFileManager, so we won't close it; even if an error occurs\n-            var fileManager = config.getFileManager();\n-\n-            try {\n-                \/\/ first, look in local snippet-files subdirectory\n-                var pkg = getPackageElement(holder, utils);\n-                var pkgLocation = utils.getLocationForPackage(pkg);\n-                var pkgName = pkg.getQualifiedName().toString(); \/\/ note: empty string for unnamed package\n-                var relativeName = \"snippet-files\/\" + v;\n-                fileObject = fileManager.getFileForInput(pkgLocation, pkgName, relativeName);\n-\n-                \/\/ if not found in local snippet-files directory, look on snippet path\n-                if (fileObject == null && fileManager.hasLocation(Location.SNIPPET_PATH)) {\n-                    fileObject = fileManager.getFileForInput(Location.SNIPPET_PATH, \"\", v);\n-                }\n-            } catch (IOException | IllegalArgumentException e) { \/\/ TODO: test this when JDK-8276892 is integrated\n-                \/\/ JavaFileManager.getFileForInput can throw IllegalArgumentException in certain cases\n-                throw new BadSnippetException(a, \"doclet.exception.read.file\", v, e);\n-            }\n-\n-            if (fileObject == null) {\n-                \/\/ i.e. the file does not exist\n-                throw new BadSnippetException(a, \"doclet.snippet_file_not_found\", v);\n-            }\n-\n-            try {\n-                externalContent = fileObject.getCharContent(true).toString();\n-            } catch (IOException e) {  \/\/ TODO: test this when JDK-8276892 is integrated\n-                throw new BadSnippetException(a, \"doclet.exception.read.file\",\n-                        fileObject.getName(), e);\n-            }\n-        }\n-\n-        String lang = null;\n-        AttributeTree langAttr = attributes.get(\"lang\");\n-        if (langAttr != null) {\n-            lang = stringValueOf(langAttr);\n-        } else if (containsClass) {\n-            lang = \"java\";\n-        } else if (containsFile) {\n-            lang = languageFromFileName(fileObject.getName());\n-        }\n-\n-        Optional<Language> language = Language.of(lang);\n-\n-\n-        \/\/ TODO cache parsed external snippet (WeakHashMap)\n-\n-        StyledText inlineSnippet = null;\n-        StyledText externalSnippet = null;\n-\n-        try {\n-            Diags d = (text, pos) -> {\n-                var path = utils.getCommentHelper(holder)\n-                        .getDocTreePath(snippetTag.getBody());\n-                config.getReporter().print(Diagnostic.Kind.WARNING,\n-                        path, pos, pos, pos, text);\n-            };\n-            if (inlineContent != null) {\n-                inlineSnippet = parse(resources, d, language, inlineContent);\n-            }\n-        } catch (ParseException e) {\n-            var path = utils.getCommentHelper(holder)\n-                    .getDocTreePath(snippetTag.getBody());\n-            \/\/ TODO: there should be a method in Messages; that method should mirror Reporter's; use that method instead accessing Reporter.\n-            String msg = resources.getText(\"doclet.snippet.markup\", e.getMessage());\n-            config.getReporter().print(Diagnostic.Kind.ERROR,\n-                    path, e.getPosition(), e.getPosition(), e.getPosition(), msg);\n-            return badSnippet(tagletWriter, Optional.of(e.getMessage()));\n-        }\n-\n-        try {\n-            var finalFileObject = fileObject;\n-            Diags d = (text, pos) -> messages.warning(finalFileObject, pos, pos, pos, text);\n-            if (externalContent != null) {\n-                externalSnippet = parse(resources, d, language, externalContent);\n-            }\n-        } catch (ParseException e) {\n-            assert fileObject != null;\n-            messages.error(fileObject, e.getPosition(),\n-                    e.getPosition(), e.getPosition(), \"doclet.snippet.markup\", e.getMessage());\n-            return badSnippet(tagletWriter, Optional.of(e.getMessage()));\n-        }\n-\n-        \/\/ the region must be matched at least in one content: it can be matched\n-        \/\/ in both, but never in none\n-        if (regionName != null) {\n-            StyledText r1 = null;\n-            StyledText r2 = null;\n-            if (inlineSnippet != null) {\n-                r1 = inlineSnippet.getBookmarkedText(regionName);\n-                if (r1 != null) {\n-                    inlineSnippet = r1;\n-                }\n-            }\n-            if (externalSnippet != null) {\n-                r2 = externalSnippet.getBookmarkedText(regionName);\n-                if (r2 != null) {\n-                    externalSnippet = r2;\n-                }\n-            }\n-            if (r1 == null && r2 == null) {\n-                throw new BadSnippetException(tag, \"doclet.snippet.region.not_found\", regionName);\n-            }\n-        }\n-\n-        if (inlineSnippet != null) {\n-            inlineSnippet = toDisplayForm(inlineSnippet);\n-        }\n-\n-        if (externalSnippet != null) {\n-            externalSnippet = toDisplayForm(externalSnippet);\n-        }\n-\n-        if (inlineSnippet != null && externalSnippet != null) {\n-            String inlineStr = inlineSnippet.asCharSequence().toString();\n-            String externalStr = externalSnippet.asCharSequence().toString();\n-            if (!Objects.equals(inlineStr, externalStr)) {\n-                throw new BadSnippetException(tag, \"doclet.snippet.contents.mismatch\", diff(inlineStr, externalStr));\n-            }\n-        }\n-\n-        assert inlineSnippet != null || externalSnippet != null;\n-        StyledText text = inlineSnippet != null ? inlineSnippet : externalSnippet;\n-\n-        AttributeTree idAttr = attributes.get(\"id\");\n-        String id = idAttr == null\n-                ? null\n-                : stringValueOf(idAttr);\n-\n-        return snippetTagOutput(holder, snippetTag, text, id, lang);\n-    }\n-\n-    \/*\n-     * Maybe there's a case for implementing a proper (or at least more helpful)\n-     * diff view, but for now simply outputting both sides of a hybrid snippet\n-     * would do. A user could then use a diff tool of their choice to compare\n-     * those sides.\n-     *\n-     * There's a separate issue of mapping discrepancies back to their\n-     * originating source in the doc comment and the external file. Maybe there\n-     * is a value in it, or maybe there isn't. In any case, accurate mapping\n-     * would not be trivial to code.\n-     *\/\n-    private static String diff(String inline, String external) {\n-        return \"\"\"\n-               ----------------- inline -------------------\n-               %s\n-               ----------------- external -----------------\n-               %s\n-               \"\"\".formatted(inline, external);\n-    }\n-\n-    private StyledText parse(Resources resources, Diags diags, Optional<Language> language, String content) throws ParseException {\n-        Parser.Result result = new Parser(resources).parse(diags, language, content);\n-        result.actions().forEach(Action::perform);\n-        return result.text();\n-    }\n-\n-    public interface Diags {\n-        void warn(String text, int pos);\n-    }\n-\n-    private static String stringValueOf(AttributeTree at) throws BadSnippetException {\n-        if (at.getValueKind() == AttributeTree.ValueKind.EMPTY) {\n-            throw new BadSnippetException(at, \"doclet.tag.attribute.value.missing\",\n-                    at.getName().toString());\n-        }\n-        return at.getValue().stream()\n-            \/\/ value consists of TextTree or ErroneousTree nodes;\n-            \/\/ ErroneousTree is a subtype of TextTree\n-            .map(t -> ((TextTree) t).getBody())\n-            .collect(Collectors.joining());\n-    }\n-\n-    private String languageFromFileName(String fileName) {\n-        \/\/ TODO: find a way to extend\/customize the list of recognized file name extensions\n-        if (fileName.endsWith(\".java\")) {\n-            return \"java\";\n-        } else if (fileName.endsWith(\".properties\")) {\n-            return \"properties\";\n-        }\n-        return null;\n-    }\n-\n-    private void error(TagletWriter writer, Element holder, DocTree tag, String key, Object... args) {\n-        messages.error(utils.getCommentHelper(holder).getDocTreePath(tag), key, args);\n-    }\n-\n-    private Content badSnippet(TagletWriter writer, Optional<String> details) {\n-        var resources = config.getDocResources();\n-        return writer.invalidTagOutput(resources.getText(\"doclet.tag.invalid\", \"snippet\"), details);\n-    }\n-\n-    private static PackageElement getPackageElement(Element e, Utils utils) {\n-        if (e instanceof DocletElement de) {\n-            return de.getPackageElement();\n-        } else {\n-            return utils.elementUtils.getPackageOf(e);\n-        }\n-    }\n-\n-    \/*\n-     * Returns a version of styled text that can be rendered into HTML or\n-     * compared to another such version. The latter is used to decide if inline\n-     * and external parts of a hybrid snippet match.\n-     *\n-     * Use this method to obtain a final version of text. After all\n-     * transformations on text have been performed, call this method with that\n-     * text and then use the returned result as described above.\n-     *\/\n-    private static StyledText toDisplayForm(StyledText source) {\n-        var sourceString = source.asCharSequence().toString();\n-        var result = new StyledText();\n-        var originalLines = sourceString.lines().iterator();\n-        var unindentedLines = sourceString.stripIndent().lines().iterator();\n-        \/\/ done; the rest of the method translates the stripIndent\n-        \/\/ transformation performed on a character sequence to the styled\n-        \/\/ text that this sequence originates from, line by line\n-        int pos = 0;\n-        \/\/ overcome a \"quirk\" of String.lines\n-        boolean endsWithLineFeed = !sourceString.isEmpty() && sourceString.charAt(source.length() - 1) == '\\n';\n-        while (originalLines.hasNext() && unindentedLines.hasNext()) { \/\/ [^1]\n-            String originalLine = originalLines.next();\n-            String unindentedLine = unindentedLines.next();\n-            \/\/ the search MUST succeed\n-            int idx = originalLine.indexOf(unindentedLine);\n-            \/\/ assume newlines are always of the \\n form\n-            \/\/ append the found fragment\n-            result.append(source.subText(pos + idx, pos + idx + unindentedLine.length()));\n-            \/\/ append the possibly styled newline, but not if it's the last line\n-            int eol = pos + originalLine.length();\n-            if (originalLines.hasNext() || endsWithLineFeed) {\n-                result.append(source.subText(eol, eol + 1));\n-            }\n-            pos = eol + 1;\n-        }\n-        return result;\n-        \/\/ [^1]: Checking hasNext() on both iterators might look unnecessary.\n-        \/\/ However, there are strings for which those iterators return different\n-        \/\/ number of lines. That is, there exists a string s, such that\n-        \/\/\n-        \/\/     s.lines().count() != s.stripIndent().lines().count()\n-        \/\/\n-        \/\/ The most trivial example of such a string is \" \". In fact, any string\n-        \/\/ with a trailing non-empty blank line would do.\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SnippetTaglet.java","additions":0,"deletions":476,"binary":false,"changes":476,"status":"deleted"},{"patch":"@@ -1,93 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.EnumSet;\n-import java.util.List;\n-import java.util.Optional;\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ExecutableElement;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.SpecTree;\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Result;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-\/**\n- * A taglet that represents the {@code @spec} tag.\n- *\/\n-public abstract class SpecTaglet extends BaseTaglet implements InheritableTaglet {\n-\n-    protected SpecTaglet(BaseConfiguration config) {\n-        super(config, DocTree.Kind.SPEC, false, EnumSet.allOf(Location.class));\n-    }\n-\n-    @Override\n-    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence) {\n-        CommentHelper ch = utils.getCommentHelper(dst);\n-        var path = ch.getDocTreePath(tag);\n-        messages.warning(path, \"doclet.inheritDocWithinInappropriateTag\");\n-        return new Output(null, null, List.of(), true \/* true, otherwise there will be an exception up the stack *\/);\n-    }\n-\n-    @Override\n-    public Content getAllBlockTagOutput(Element holder, TagletWriter tagletWriter) {\n-        this.tagletWriter = tagletWriter;\n-        List<? extends SpecTree> tags = utils.getSpecTrees(holder);\n-        Element e = holder;\n-        if (utils.isMethod(holder)) {\n-            var docFinder = utils.docFinder();\n-            Optional<Documentation> result = docFinder.search((ExecutableElement) holder,\n-                    m -> Result.fromOptional(extract(utils, m))).toOptional();\n-            if (result.isPresent()) {\n-                e = result.get().method();\n-                tags = result.get().specTrees();\n-            }\n-        }\n-        return specTagOutput(e, tags);\n-    }\n-\n-    \/**\n-     * Returns the output for one or more {@code @spec} tags.\n-     *\n-     * @param element  the element that owns the doc comment\n-     * @param specTags the array of @spec tags.\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content specTagOutput(Element element, List<? extends SpecTree> specTags);\n-\n-    private record Documentation(List<? extends SpecTree> specTrees, ExecutableElement method) { }\n-\n-    private static Optional<Documentation> extract(Utils utils, ExecutableElement method) {\n-        List<? extends SpecTree> tags = utils.getSpecTrees(method);\n-        return tags.isEmpty() ? Optional.empty() : Optional.of(new Documentation(tags, method));\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SpecTaglet.java","additions":0,"deletions":93,"binary":false,"changes":93,"status":"deleted"},{"patch":"@@ -1,63 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.EnumSet;\n-\n-import javax.lang.model.element.Element;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.SystemPropertyTree;\n-\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-\n-\/**\n- * A taglet that represents the {@code @systemProperty} tag.\n- *\/\n-public abstract class SystemPropertyTaglet extends BaseTaglet {\n-\n-    protected SystemPropertyTaglet(BaseConfiguration config) {\n-        super(config, DocTree.Kind.SYSTEM_PROPERTY, true, EnumSet.allOf(Location.class));\n-    }\n-\n-    @Override\n-    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter tagletWriter) {\n-        this.tagletWriter = tagletWriter;\n-        return systemPropertyTagOutput(element, (SystemPropertyTree) tag);\n-    }\n-\n-    \/**\n-     * Returns the output for a {@code {@systemProperty...}} tag.\n-     *\n-     * @param element           the element that owns the doc comment\n-     * @param systemPropertyTag the system property tag\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content systemPropertyTagOutput(Element element, SystemPropertyTree systemPropertyTag);\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SystemPropertyTaglet.java","additions":0,"deletions":63,"binary":false,"changes":63,"status":"deleted"},{"patch":"@@ -1,668 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.PrintStream;\n-import java.util.ArrayList;\n-import java.util.EnumMap;\n-import java.util.HashSet;\n-import java.util.LinkedHashMap;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.ServiceLoader;\n-import java.util.Set;\n-import java.util.TreeMap;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.ModuleElement;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-import javax.lang.model.util.SimpleElementVisitor14;\n-import javax.tools.JavaFileManager;\n-import javax.tools.StandardJavaFileManager;\n-\n-import com.sun.source.doctree.DocTree;\n-\n-import jdk.javadoc.doclet.Doclet;\n-import jdk.javadoc.doclet.DocletEnvironment;\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.BaseOptions;\n-import jdk.javadoc.internal.doclets.toolkit.DocletElement;\n-import jdk.javadoc.internal.doclets.toolkit.Messages;\n-import jdk.javadoc.internal.doclets.toolkit.Resources;\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-import static com.sun.source.doctree.DocTree.Kind.PARAM;\n-import static com.sun.source.doctree.DocTree.Kind.SEE;\n-import static com.sun.source.doctree.DocTree.Kind.SERIAL_DATA;\n-import static com.sun.source.doctree.DocTree.Kind.SINCE;\n-import static com.sun.source.doctree.DocTree.Kind.THROWS;\n-import static javax.tools.DocumentationTool.Location.TAGLET_PATH;\n-\n-\/**\n- * Manages the {@code Taglet}s used by doclets.\n- *\/\n-public abstract class TagletManager {\n-\n-    \/**\n-     * All taglets, keyed either by their {@link Taglet#getName() name},\n-     * or by an alias.\n-     *\n-     * In general, taglets do <i>not<\/i> provide aliases;\n-     * the one instance that does is {@code ThrowsTaglet}, which handles\n-     * both {@code @throws} tags and {@code @exception} tags.\n-     *\/\n-    protected final LinkedHashMap<String, Taglet> allTaglets;\n-\n-    \/**\n-     * Block (non-inline) taglets, grouped by {@link Location location}.\n-     *\/\n-    protected Map<Location, List<Taglet>> blockTagletsByLocation;\n-\n-    \/**\n-     * The taglets that can appear inline in descriptive text.\n-     *\/\n-    protected Map<String, Taglet> inlineTags;\n-\n-    \/**\n-     * The taglets that can appear in the serialized form.\n-     *\/\n-    protected List<Taglet> serializedFormTags;\n-\n-    private final DocletEnvironment docEnv;\n-    private final Doclet doclet;\n-\n-    private final Utils utils;\n-    private final Messages messages;\n-\n-    \/**\n-     * Keep track of standard tags.\n-     *\/\n-    private final Set<String> standardTags;\n-\n-    \/**\n-     * Keep track of standard tags in lowercase to compare for better\n-     * error messages when a tag like {@code @docRoot} is mistakenly spelled\n-     * lowercase {@code @docroot}.\n-     *\/\n-    private final Set<String> standardTagsLowercase;\n-\n-    \/**\n-     * Keep track of overridden standard tags.\n-     *\/\n-    private final Set<String> overriddenStandardTags;\n-\n-    \/**\n-     * Keep track of the tags that may conflict\n-     * with standard tags in the future (any custom tag without\n-     * a period in its name).\n-     *\/\n-    private final Set<String> potentiallyConflictingTags;\n-\n-    \/**\n-     * The set of unseen custom tags.\n-     *\/\n-    private final Set<String> unseenCustomTags;\n-\n-    \/**\n-     * True if we do not want to use {@code @since} tags.\n-     *\/\n-    protected final boolean nosince;\n-\n-    \/**\n-     * True if we want to use {@code @version} tags.\n-     *\/\n-    protected final boolean showversion;\n-\n-    \/**\n-     * True if we want to use {@code @author} tags.\n-     *\/\n-    protected final boolean showauthor;\n-\n-    \/**\n-     * True if we want to use JavaFX-related tags ({@code @defaultValue}, {@code @treatAsPrivate}).\n-     *\/\n-    protected final boolean javafx;\n-\n-    \/**\n-     * Show the taglets table when it has been initialized.\n-     *\/\n-    protected final boolean showTaglets;\n-\n-    private final String tagletPath;\n-\n-    private final BaseConfiguration configuration;\n-\n-    \/**\n-     * Constructs a new {@code TagletManager}.\n-     *\n-     * @param configuration the configuration for this taglet manager\n-     *\/\n-    public TagletManager(BaseConfiguration configuration) {\n-        overriddenStandardTags = new HashSet<>();\n-        potentiallyConflictingTags = new HashSet<>();\n-        standardTags = new HashSet<>();\n-        standardTagsLowercase = new HashSet<>();\n-        unseenCustomTags = new HashSet<>();\n-        allTaglets = new LinkedHashMap<>();\n-        this.configuration = configuration;\n-        BaseOptions options = configuration.getOptions();\n-        this.nosince = options.noSince();\n-        this.showversion = options.showVersion();\n-        this.showauthor = options.showAuthor();\n-        this.javafx = options.javafx();\n-        this.docEnv = configuration.docEnv;\n-        this.doclet = configuration.doclet;\n-        this.messages = configuration.getMessages();\n-        this.showTaglets = options.showTaglets();\n-        this.utils = configuration.utils;\n-        this.tagletPath = options.tagletPath();\n-\/\/        initStandardTaglets();\n-    }\n-\n-    public Set<String> getAllTagletNames() {\n-        return allTaglets.keySet();\n-    }\n-\n-    \/**\n-     * Initializes the location TAGLET_PATH which is used to locate the custom taglets.\n-     *\n-     * @param fileManager the file manager to load classes and resources\n-     * @throws IOException if an error occurs while setting the location\n-     *\/\n-    public void initTagletPath(JavaFileManager fileManager) throws IOException {\n-        if (fileManager instanceof StandardJavaFileManager sfm) {\n-            if (tagletPath != null) {\n-                List<File> paths = new ArrayList<>();\n-                for (String pathname : tagletPath.split(File.pathSeparator)) {\n-                    paths.add(new File(pathname));\n-                }\n-                sfm.setLocation(TAGLET_PATH, paths);\n-            } else if (!sfm.hasLocation(TAGLET_PATH)) {\n-                sfm.setLocation(TAGLET_PATH, List.of());\n-            }\n-        } else if (tagletPath != null) {\n-            messages.error(\"doclet.not_standard_file_manager\");\n-        }\n-    }\n-\n-    \/**\n-     * Adds a new {@code Taglet}.\n-     *\n-     * Prints a message to indicate whether or not the Taglet was registered properly.\n-     *\n-     * @param classname  the name of the class representing the custom tag\n-     * @param fileManager the file manager to load classes and resources\n-     *\/\n-    public void addCustomTag(String classname, JavaFileManager fileManager) {\n-        ClassLoader tagClassLoader = fileManager.getClassLoader(TAGLET_PATH);\n-        if (configuration.workArounds.accessInternalAPI()) {\n-            Module thisModule = getClass().getModule();\n-            Module tagletLoaderUnnamedModule = tagClassLoader.getUnnamedModule();\n-            List<String> pkgs = List.of(\n-                    \"jdk.javadoc.doclet\",\n-                    \"jdk.javadoc.internal.doclets.toolkit\",\n-                    \"jdk.javadoc.internal.doclets.formats.html\");\n-            pkgs.forEach(p -> thisModule.addOpens(p, tagletLoaderUnnamedModule));\n-        }\n-        try {\n-            Class<? extends jdk.javadoc.doclet.Taglet> customTagClass =\n-                    tagClassLoader.loadClass(classname).asSubclass(jdk.javadoc.doclet.Taglet.class);\n-            jdk.javadoc.doclet.Taglet instance = customTagClass.getConstructor().newInstance();\n-            registerTaglet(instance);\n-        } catch (ReflectiveOperationException | ExceptionInInitializerError | ClassCastException exc) {\n-            messages.error(\"doclet.Error_taglet_not_registered\", exc.getClass().getName(),\n-                    classname);\n-        }\n-    }\n-\n-    \/**\n-     * Loads taglets from a taglet path using the service loader.\n-     *\n-     * @param fileManager the file manager to load the taglets\n-     * @throws IOException if an error occurs while getting the service loader\n-     *\/\n-    public void loadTaglets(JavaFileManager fileManager) throws IOException {\n-        Iterable<? extends File> location = ((StandardJavaFileManager) fileManager).getLocation(TAGLET_PATH);\n-        if (location != null && location.iterator().hasNext()) {\n-            ServiceLoader<jdk.javadoc.doclet.Taglet> serviceLoader =\n-                    fileManager.getServiceLoader(TAGLET_PATH, jdk.javadoc.doclet.Taglet.class);\n-            for (jdk.javadoc.doclet.Taglet taglet : serviceLoader) {\n-                registerTaglet(taglet);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Registers the {@code Taglet}.\n-     *\n-     * Prints a message if the {@code Taglet} got registered properly.\n-     *\n-     * @param instance the {@code Taglet} instance\n-     *\/\n-    private void registerTaglet(jdk.javadoc.doclet.Taglet instance) {\n-        instance.init(docEnv, doclet);\n-        Taglet newLegacy = wrapTaglet(instance);\n-        allTaglets.put(newLegacy.getName(), newLegacy);\n-        messages.notice(\"doclet.Notice_taglet_registered\", instance.getClass().getName());\n-    }\n-\n-    protected abstract Taglet wrapTaglet(jdk.javadoc.doclet.Taglet instance);\n-\n-    \/**\n-     * Adds a new {@code SimpleTaglet}.\n-     *\n-     * If this tag already exists and the header passed as an argument is {@code null},\n-     * move tag to the back of the list. If this tag already exists and the\n-     * header passed as an argument is not {@code null}, overwrite previous tag\n-     * with the new one. Otherwise, add a new SimpleTaglet to the list.\n-     *\n-     * @param tagName the name of this tag\n-     * @param header the header to output\n-     * @param locations the possible locations that this tag can appear in\n-     *\/\n-    public void addNewSimpleCustomTag(String tagName, String header, String locations) {\n-        if (tagName == null || locations == null) {\n-            return;\n-        }\n-        \/\/ remove + put in both branches below move the tag to the back of the map's ordering\n-        Taglet tag = allTaglets.remove(tagName);\n-        if (tag == null || header != null) {\n-            allTaglets.put(tagName, newSimpleTaglet(tagName, header, locations));\n-            if (Utils.toLowerCase(locations).indexOf('x') == -1) {\n-                checkTagName(tagName);\n-            }\n-        } else {\n-            \/\/ Move existing tag to the back\n-            allTaglets.put(tagName, tag);\n-        }\n-    }\n-\n-    protected abstract Taglet newSimpleTaglet(String tagname, String header, String locations);\n-\n-    \/**\n-     * Given a tag name, add it to the set of tags it belongs to.\n-     *\/\n-    private void checkTagName(String name) {\n-        if (standardTags.contains(name)) {\n-            overriddenStandardTags.add(name);\n-        } else {\n-            if (name.indexOf('.') == -1) {\n-                potentiallyConflictingTags.add(name);\n-            }\n-            unseenCustomTags.add(name);\n-        }\n-    }\n-\n-    \/**\n-     * Reports that a tag was seen in a doc comment.\n-     * It is removed from the list of custom tags that have not yet been seen.\n-     *\n-     * @param name the name of the tag\n-     *\/\n-    void seenTag(String name) {\n-        unseenCustomTags.remove(name);\n-    }\n-\n-    \/**\n-     * Given a series of {@code DocTree}s, check for misuse and spelling mistakes.\n-     *\n-     * @param element the tags holder\n-     * @param trees the trees containing the comments\n-     *\/\n-    public void checkTags(Element element, Iterable<? extends DocTree> trees) {\n-        CommentHelper ch = utils.getCommentHelper(element);\n-        for (DocTree tag : trees) {\n-            String name = tag.getKind().tagName;\n-            if (name == null) {\n-                continue;\n-            }\n-            if (!name.isEmpty() && name.charAt(0) == '@') {\n-                name = name.substring(1);\n-            }\n-            if (! (standardTags.contains(name) || allTaglets.containsKey(name))) {\n-                if (standardTagsLowercase.contains(Utils.toLowerCase(name))) {\n-                    messages.warning(ch.getDocTreePath(tag), \"doclet.UnknownTagLowercase\", ch.getTagName(tag));\n-                    continue;\n-                } else {\n-                    messages.warning(ch.getDocTreePath(tag), \"doclet.UnknownTag\", ch.getTagName(tag));\n-                    continue;\n-                }\n-            }\n-            final Taglet taglet = allTaglets.get(name);\n-            \/\/ Check and verify tag usage\n-            if (taglet != null) {\n-                if (taglet instanceof SimpleTaglet st && !st.enabled) {\n-                    \/\/ taglet has been disabled\n-                    return;\n-                }\n-\n-                new SimpleElementVisitor14<Void, Void>() {\n-                    @Override\n-                    public Void visitModule(ModuleElement e, Void p) {\n-                        if (!taglet.inModule()) {\n-                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"module\");\n-                        }\n-                        return null;\n-                    }\n-\n-                    @Override\n-                    public Void visitPackage(PackageElement e, Void p) {\n-                        if (!taglet.inPackage()) {\n-                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"package\");\n-                        }\n-                        return null;\n-                    }\n-\n-                    @Override\n-                    public Void visitType(TypeElement e, Void p) {\n-                        if (!taglet.inType()) {\n-                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"class\");\n-                        }\n-                        return null;\n-                    }\n-\n-                    @Override\n-                    public Void visitExecutable(ExecutableElement e, Void p) {\n-                        if (utils.isConstructor(e) && !taglet.inConstructor()) {\n-                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"constructor\");\n-                        } else if (!taglet.inMethod()) {\n-                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"method\");\n-                        }\n-                        return null;\n-                    }\n-\n-                    @Override\n-                    public Void visitVariable(VariableElement e, Void p) {\n-                        if (utils.isField(e) && !taglet.inField()) {\n-                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"field\");\n-                        }\n-                        return null;\n-                    }\n-\n-                    @Override\n-                    public Void visitUnknown(Element e, Void p) {\n-                        if (utils.isOverviewElement(e) && !taglet.inOverview()) {\n-                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"overview\");\n-                        }\n-                        return null;\n-                    }\n-\n-                    @Override\n-                    protected Void defaultAction(Element e, Void p) {\n-                        return null;\n-                    }\n-                }.visit(element);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Given the taglet, the tag and the type of documentation that the tag\n-     * was found in, print a tag misuse warning.\n-     *\n-     * @param taglet the taglet representing the misused tag\n-     * @param tag the misused tag\n-     * @param holderType the type of documentation that the misused tag was found in\n-     *\/\n-    private void printTagMisuseWarn(CommentHelper ch, Taglet taglet, DocTree tag, String holderType) {\n-        Set<String> locationsSet = new LinkedHashSet<>();\n-        \/\/ The following names should be localized\n-        if (taglet.inOverview()) {\n-            locationsSet.add(\"overview\");\n-        }\n-        if (taglet.inModule()) {\n-            locationsSet.add(\"module\");\n-        }\n-        if (taglet.inPackage()) {\n-            locationsSet.add(\"package\");\n-        }\n-        if (taglet.inType()) {\n-            locationsSet.add(\"class\/interface\");\n-        }\n-        if (taglet.inConstructor())  {\n-            locationsSet.add(\"constructor\");\n-        }\n-        if (taglet.inField()) {\n-            locationsSet.add(\"field\");\n-        }\n-        if (taglet.inMethod()) {\n-            locationsSet.add(\"method\");\n-        }\n-        if (locationsSet.isEmpty()) {\n-            \/\/This known tag is excluded.\n-            return;\n-        }\n-        var combined_locations = String.join(\", \", locationsSet);\n-        messages.warning(ch.getDocTreePath(tag), \"doclet.tag_misuse\",\n-            \"@\" + taglet.getName(), holderType, combined_locations);\n-    }\n-\n-    \/**\n-     * Returns the taglets that can appear inline, in descriptive text.\n-     * @return the taglets that can appear inline\n-     *\/\n-    Map<String, Taglet> getInlineTaglets() {\n-        if (inlineTags == null) {\n-            initTaglets();\n-        }\n-        return inlineTags;\n-    }\n-\n-    \/**\n-     * Returns the taglets that can appear in the serialized form.\n-     * @return the taglet that can appear in the serialized form\n-     *\/\n-    public List<Taglet> getSerializedFormTaglets() {\n-        if (serializedFormTags == null) {\n-            initTaglets();\n-        }\n-        return serializedFormTags;\n-    }\n-\n-    \/**\n-     * Returns the custom tags for a given element.\n-     *\n-     * @param e the element to get custom tags for\n-     * @return the array of {@code Taglet}s that can\n-     * appear in the given element\n-     *\/\n-    @SuppressWarnings(\"fallthrough\")\n-    public List<Taglet> getBlockTaglets(Element e) {\n-        if (blockTagletsByLocation == null) {\n-            initTaglets();\n-        }\n-\n-        switch (e.getKind()) {\n-            case CONSTRUCTOR:\n-                return blockTagletsByLocation.get(Location.CONSTRUCTOR);\n-            case METHOD:\n-                return blockTagletsByLocation.get(Location.METHOD);\n-            case ENUM_CONSTANT:\n-            case FIELD:\n-                return blockTagletsByLocation.get(Location.FIELD);\n-            case ANNOTATION_TYPE:\n-            case INTERFACE:\n-            case CLASS:\n-            case ENUM:\n-            case RECORD:\n-                return blockTagletsByLocation.get(Location.TYPE);\n-            case MODULE:\n-                return blockTagletsByLocation.get(Location.MODULE);\n-            case PACKAGE:\n-                return blockTagletsByLocation.get(Location.PACKAGE);\n-            case OTHER:\n-                if (e instanceof DocletElement de) {\n-                    switch (de.getSubKind()) {\n-                        case DOCFILE:\n-                            return blockTagletsByLocation.get(Location.PACKAGE);\n-                        case OVERVIEW:\n-                            return blockTagletsByLocation.get(Location.OVERVIEW);\n-                        default:\n-                            \/\/ fall through\n-                    }\n-                }\n-                \/\/ fall through\n-            default:\n-                throw new AssertionError(\"unknown element: \" + e + \" ,kind: \" + e.getKind());\n-        }\n-    }\n-\n-    \/**\n-     * Initialize the tag collections.\n-     *\/\n-    private void initTaglets() {\n-\n-        blockTagletsByLocation = new EnumMap<>(Location.class);\n-        for (Location site : Location.values()) {\n-            blockTagletsByLocation.put(site, new ArrayList<>());\n-        }\n-\n-        inlineTags = new LinkedHashMap<>();\n-\n-        allTaglets.forEach((name, t) -> {\n-            if (t.isInlineTag()) {\n-                inlineTags.put(t.getName(), t);\n-            }\n-\n-            if (t.isBlockTag() && t.getName().equals(name)) {\n-                t.getAllowedLocations().forEach(l -> blockTagletsByLocation.get(l).add(t));\n-            }\n-        });\n-\n-        \/\/ init the serialized form tags for the serialized form page\n-        serializedFormTags = new ArrayList<>();\n-        serializedFormTags.add(allTaglets.get(SERIAL_DATA.tagName));\n-        serializedFormTags.add(allTaglets.get(PARAM.tagName));\n-        serializedFormTags.add(allTaglets.get(THROWS.tagName));\n-        if (!nosince)\n-            serializedFormTags.add(allTaglets.get(SINCE.tagName));\n-        serializedFormTags.add(allTaglets.get(SEE.tagName));\n-\n-        if (showTaglets) {\n-            showTaglets(System.out);\n-        }\n-    }\n-\n-    protected void addStandardTaglet(Taglet taglet) {\n-        String name = taglet.getName();\n-        allTaglets.put(name, taglet);\n-        standardTags.add(name);\n-        standardTagsLowercase.add(Utils.toLowerCase(name));\n-    }\n-\n-    protected void addStandardTaglet(Taglet taglet, DocTree.Kind alias) {\n-        addStandardTaglet(taglet);\n-        String name = alias.tagName;\n-        allTaglets.put(name, taglet);\n-        standardTags.add(name);\n-        standardTagsLowercase.add(Utils.toLowerCase(name));\n-    }\n-\n-    public boolean isKnownCustomTag(String tagName) {\n-        return allTaglets.containsKey(tagName);\n-    }\n-\n-    \/**\n-     * Print a list of {@link Taglet}s that might conflict with\n-     * standard tags in the future and a list of standard tags\n-     * that have been overridden.\n-     *\/\n-    public void printReport() {\n-        printReportHelper(\"doclet.Notice_taglet_conflict_warn\", potentiallyConflictingTags);\n-        printReportHelper(\"doclet.Notice_taglet_overridden\", overriddenStandardTags);\n-        printReportHelper(\"doclet.Notice_taglet_unseen\", unseenCustomTags);\n-    }\n-\n-    private void printReportHelper(String noticeKey, Set<String> names) {\n-        if (!names.isEmpty()) {\n-            StringBuilder result = new StringBuilder();\n-            for (String name : names) {\n-                result.append(result.length() == 0 ? \" \" : \", \");\n-                result.append(\"@\").append(name);\n-            }\n-            messages.notice(noticeKey, result);\n-        }\n-    }\n-\n-    \/**\n-     * Given the name of a tag, return the corresponding taglet.\n-     *\n-     * @param name the name of the taglet to retrieve\n-     * @return the corresponding taglet or {@code null} if the tag is unknown\n-     *\/\n-    Taglet getTaglet(String name) {\n-        if (name.indexOf(\"@\") == 0) {\n-            return allTaglets.get(name.substring(1));\n-        } else {\n-            return allTaglets.get(name);\n-        }\n-    }\n-\n-    public Taglet getTaglet(DocTree.Kind kind) {\n-        return switch (kind) {\n-            case DEPRECATED, LINK, LINK_PLAIN, PARAM, RETURN, THROWS -> getTaglet(kind.tagName);\n-            default ->\n-                throw new IllegalArgumentException(kind.toString());\n-        };\n-    }\n-\n-    \/*\n-     * The output of this method is the basis for a table at the end of the\n-     * doc comment specification, so any changes in the output may indicate\n-     * a need for a corresponding update to the spec.\n-     *\/\n-    protected void showTaglets(PrintStream out) {\n-        Map<String, Taglet> taglets = new TreeMap<>(allTaglets);\n-\n-        taglets.forEach((n, t) -> {\n-            \/\/ give preference to simpler block form if a tag can be either\n-            String name = t.isBlockTag() ? \"@\" + n : \"{@\" + n + \"}\";\n-            out.println(String.format(\"%20s\", name) + \": \"\n-                    + format(t.isBlockTag(), \"block\")+ \" \"\n-                    + format(t.inOverview(), \"overview\") + \" \"\n-                    + format(t.inModule(), \"module\") + \" \"\n-                    + format(t.inPackage(), \"package\") + \" \"\n-                    + format(t.inType(), \"type\") + \" \"\n-                    + format(t.inConstructor(),\"constructor\") + \" \"\n-                    + format(t.inMethod(), \"method\") + \" \"\n-                    + format(t.inField(), \"field\") + \" \"\n-                    + format(t.isInlineTag(), \"inline\")+ \" \"\n-                    + format((t instanceof SimpleTaglet st) && !st.enabled, \"disabled\"));\n-        });\n-    }\n-\n-    private String format(boolean b, String s) {\n-        return b ? s : \".\".repeat(s.length()); \/\/ \"replace\" all with \".\"\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/TagletManager.java","additions":0,"deletions":668,"binary":false,"changes":668,"status":"deleted"},{"patch":"@@ -1,294 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.EnumSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.Set;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ElementKind;\n-import javax.lang.model.element.TypeElement;\n-\n-import com.sun.source.doctree.DocTree;\n-\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.Taglet.UnsupportedTagletOperationException;\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n-\n-\/**\n- * The interface for the taglet writer.\n- *\/\n-public abstract class TagletWriter {\n-\n-    \/**\n-     * A class that provides the information about the enclosing context for\n-     * a series of {@code DocTree} nodes.\n-     * This context may be used to determine the content that should be generated from the tree nodes.\n-     *\/\n-    public static class Context {\n-        \/**\n-         * Whether the trees are appearing in a context of just the first sentence,\n-         * such as in the summary table of the enclosing element.\n-         *\/\n-        public final boolean isFirstSentence;\n-        \/**\n-         * Whether the trees are appearing in the \"summary\" section of the\n-         * page for a declaration.\n-         *\/\n-        public final boolean inSummary;\n-        \/**\n-         * The set of enclosing kinds of tags.\n-         *\/\n-        public final Set<DocTree.Kind> inTags;\n-\n-        \/**\n-         * Creates an outermost context, with no enclosing tags.\n-         *\n-         * @param isFirstSentence {@code true} if the trees are appearing in a context of just the\n-         *                        first sentence and {@code false} otherwise\n-         * @param inSummary       {@code true} if the trees are appearing in the \"summary\" section\n-         *                        of the page for a declaration and {@code false} otherwise\n-         *\/\n-        public Context(boolean isFirstSentence, boolean inSummary) {\n-            this(isFirstSentence, inSummary, EnumSet.noneOf(DocTree.Kind.class));\n-        }\n-\n-        private Context(boolean isFirstSentence, boolean inSummary, Set<DocTree.Kind> inTags) {\n-            this.isFirstSentence = isFirstSentence;\n-            this.inSummary = inSummary;\n-            this.inTags = inTags;\n-        }\n-\n-        \/**\n-         * Creates a new {@code Context} that includes an extra tag kind in the set of enclosing\n-         * kinds of tags.\n-         *\n-         * @param tree the enclosing tree\n-         *\n-         * @return the new {@code Context}\n-         *\/\n-        public Context within(DocTree tree) {\n-            var newInTags = EnumSet.copyOf(inTags);\n-            newInTags.add(tree.getKind());\n-            return new Context(isFirstSentence, inSummary, newInTags);\n-        }\n-    }\n-\n-    \/**\n-     * The context in which to generate the output for a series of {@code DocTree} nodes.\n-     *\/\n-    public final Context context;\n-\n-    protected TagletWriter(Context context) {\n-        this.context = context;\n-    }\n-\n-    public Context getContext() {\n-        return context;\n-    }\n-\n-    \/**\n-     * Returns an instance of an output object.\n-     *\n-     * @return an instance of an output object\n-     *\/\n-    public abstract Content getOutputInstance();\n-\n-    \/**\n-     * Returns the output for an invalid tag. The returned content uses special styling to\n-     * highlight the problem. Depending on the presence of the {@code detail} string the method\n-     * returns a plain text span or an expandable component.\n-     *\n-     * @param summary the single-line summary message\n-     * @param detail the optional detail message which may contain preformatted text\n-     * @return the output\n-     *\/\n-    public abstract Content invalidTagOutput(String summary, Optional<String> detail);\n-\n-    \/**\n-     * Returns the main type element of the current page or null for pages that don't have one.\n-     *\n-     * @return the type element of the current page or null.\n-     *\/\n-    protected abstract TypeElement getCurrentPageElement();\n-\n-    \/**\n-     * Returns the content generated from the block tags for a given element.\n-     * The content is generated according to the order of the list of taglets.\n-     * The result is a possibly-empty list of the output generated by each\n-     * of the given taglets for all of the tags they individually support.\n-     *\n-     * @param tagletManager the manager that manages the taglets\n-     * @param element       the element that we are to write tags for\n-     * @param taglets       the taglets for the tags to write\n-     *\n-     * @return the content\n-     *\/\n-    public Content getBlockTagOutput(TagletManager tagletManager,\n-                                    Element element,\n-                                    List<Taglet> taglets) {\n-        for (Taglet t : taglets) {\n-            if (!t.isBlockTag()) {\n-                throw new IllegalArgumentException(t.getName());\n-            }\n-        }\n-\n-        Content output = getOutputInstance();\n-        var utils = configuration().utils;\n-        tagletManager.checkTags(element, utils.getBlockTags(element));\n-        tagletManager.checkTags(element, utils.getFullBody(element));\n-        for (Taglet taglet : taglets) {\n-            if (utils.isTypeElement(element) && taglet instanceof ParamTaglet) {\n-                \/\/ The type parameters and state components are documented in a special\n-                \/\/ section away from the tag info, so skip here.\n-                continue;\n-            }\n-\n-            if (element.getKind() == ElementKind.MODULE && taglet instanceof BaseTaglet t) {\n-                switch (t.getTagKind()) {\n-                    \/\/ @uses and @provides are handled separately, so skip here.\n-                    \/\/ See ModuleWriterImpl.computeModulesData\n-                    case USES:\n-                    case PROVIDES:\n-                        continue;\n-                }\n-            }\n-\n-            if (taglet instanceof DeprecatedTaglet) {\n-                \/\/Deprecated information is documented \"inline\", not in tag info\n-                \/\/section.\n-                continue;\n-            }\n-\n-            if (taglet instanceof SimpleTaglet st && !st.enabled) {\n-                \/\/ taglet has been disabled\n-                continue;\n-            }\n-\n-            try {\n-                Content tagletOutput = taglet.getAllBlockTagOutput(element, this);\n-                if (tagletOutput != null) {\n-                    tagletManager.seenTag(taglet.getName());\n-                    output.add(tagletOutput);\n-                }\n-            } catch (UnsupportedTagletOperationException e) {\n-                \/\/ malformed taglet:\n-                \/\/ claims to support block tags (see Taglet.isBlockTag) but does not provide the\n-                \/\/ appropriate method, Taglet.getAllBlockTagOutput.\n-            }\n-        }\n-        return output;\n-    }\n-\n-    \/**\n-     * Returns the content generated from an inline tag in the doc comment for a given element,\n-     * or {@code null} if the tag is not supported or does not return any output.\n-     *\n-     * @param holder        the element associated with the doc comment\n-     * @param inlineTag     the inline tag to be documented\n-     *\n-     * @return the content, or {@code null}\n-     *\/\n-    public Content getInlineTagOutput(Element holder,\n-                                      DocTree inlineTag) {\n-        var config = configuration();\n-        var tagletManager = config.tagletManager;\n-        Map<String, Taglet> inlineTags = tagletManager.getInlineTaglets();\n-        CommentHelper ch = config.utils.getCommentHelper(holder);\n-        final String inlineTagName = ch.getTagName(inlineTag);\n-        Taglet t = inlineTags.get(inlineTagName);\n-        if (t == null) {\n-            return null;\n-        }\n-\n-        try {\n-            Content tagletOutput = t.getInlineTagOutput(holder, inlineTag, this);\n-            tagletManager.seenTag(t.getName());\n-            return tagletOutput;\n-        } catch (UnsupportedTagletOperationException e) {\n-            \/\/ malformed taglet:\n-            \/\/ claims to support inline tags (see Taglet.isInlineTag) but does not provide the\n-            \/\/ appropriate method, Taglet.getInlineTagOutput.\n-            return null;\n-        }\n-    }\n-\n-    \/**\n-     * Converts inline tags and text to content, expanding the\n-     * inline tags along the way.  Called wherever text can contain\n-     * an inline tag, such as in comments or in free-form text arguments\n-     * to block tags.\n-     *\n-     * @param holderTree the tree that holds the documentation\n-     * @param trees      list of {@code DocTree} nodes containing text and inline tags (often alternating)\n-     *                   present in the text of interest for this doc\n-     *\n-     * @return the generated content\n-     *\/\n-    public abstract Content commentTagsToOutput(DocTree holderTree, List<? extends DocTree> trees);\n-\n-    \/**\n-     * Converts inline tags and text to content, expanding the\n-     * inline tags along the way.  Called wherever text can contain\n-     * an inline tag, such as in comments or in free-form text arguments\n-     * to block tags.\n-     *\n-     * @param element The element that owns the documentation\n-     * @param trees  list of {@code DocTree} nodes containing text and inline tags (often alternating)\n-     *               present in the text of interest for this doc\n-     *\n-     * @return the generated content\n-     *\/\n-    public abstract Content commentTagsToOutput(Element element, List<? extends DocTree> trees);\n-\n-    \/**\n-     * Converts inline tags and text to content, expanding the\n-     * inline tags along the way.  Called wherever text can contain\n-     * an inline tag, such as in comments or in free-form text arguments\n-     * to non-inline tags.\n-     *\n-     * @param element         the element where comment resides\n-     * @param holder          the tag that holds the documentation\n-     * @param trees           array of text tags and inline tags (often alternating)\n-     *                        present in the text of interest for this doc\n-     * @param isFirstSentence true if this is the first sentence\n-     *\n-     * @return the generated content\n-     *\/\n-    public abstract Content commentTagsToOutput(Element element, DocTree holder,\n-                                                List<? extends DocTree> trees, boolean isFirstSentence);\n-\n-    \/**\n-     * Returns an instance of the configuration used for this doclet.\n-     *\n-     * @return an instance of the configuration used for this doclet\n-     *\/\n-    public abstract BaseConfiguration configuration();\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/TagletWriter.java","additions":0,"deletions":294,"binary":false,"changes":294,"status":"deleted"},{"patch":"@@ -1,140 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.EnumSet;\n-import java.util.IllegalFormatException;\n-import java.util.Optional;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.VariableElement;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.TextTree;\n-import com.sun.source.doctree.ValueTree;\n-\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n-\n-\/**\n- * An inline taglet representing the value tag. This tag should only be used with\n- * constant fields that have a value.  It is used to access the value of constant\n- * fields.  This inline tag has an optional field name parameter.  If the name is\n- * specified, the constant value is retrieved from the specified field.  A link\n- * is also created to the specified field.  If a name is not specified, the value\n- * is retrieved for the field that the inline tag appears on.  The name is specified\n- * in the following format:  [fully qualified class name]#[constant field name].\n- *\/\n-public abstract class ValueTaglet extends BaseTaglet {\n-\n-    \/**\n-     * Construct a new ValueTaglet.\n-     *\/\n-    protected ValueTaglet(BaseConfiguration config) {\n-        super(config, DocTree.Kind.VALUE, true, EnumSet.allOf(Location.class));\n-    }\n-\n-    \/**\n-     * Returns the referenced field or a null if the value tag\n-     * is empty or the reference is invalid.\n-     *\n-     * @param holder the tag holder.\n-     * @param config the  configuration of the doclet.\n-     * @param tag the value tag.\n-     *\n-     * @return the referenced field or null.\n-     *\/\n-    private VariableElement getVariableElement(Element holder, BaseConfiguration config, DocTree tag) {\n-        CommentHelper ch = config.utils.getCommentHelper(holder);\n-        String signature = ch.getReferencedSignature(tag);\n-\n-        Element e = signature == null\n-                ? holder\n-                : ch.getReferencedMember(tag);\n-\n-        return (e != null && config.utils.isVariableElement(e))\n-                ? (VariableElement) e\n-                : null;\n-    }\n-\n-    @Override\n-    public Content getInlineTagOutput(Element holder, DocTree tag, TagletWriter tagletWriter) {\n-        this.tagletWriter = tagletWriter;\n-        VariableElement field = getVariableElement(holder, config, tag);\n-        if (field == null) {\n-            if (tag.toString().isEmpty()) {\n-                \/\/Invalid use of @value\n-                messages.warning(holder,\n-                        \"doclet.value_tag_invalid_use\");\n-            } else {\n-                \/\/Reference is unknown.\n-                messages.warning(holder,\n-                        \"doclet.value_tag_invalid_reference\", tag.toString());\n-            }\n-        } else if (field.getConstantValue() != null) {\n-            TextTree format = ((ValueTree) tag).getFormat();\n-            String text;\n-            if (format != null) {\n-                String f = format.getBody();\n-                if (f.startsWith(\"\\\"\")) {\n-                    f = f.substring(1, f.length() - 1);\n-                }\n-                try {\n-                    text = String.format(config.getLocale(), f, field.getConstantValue());\n-                } catch (IllegalFormatException e) {\n-                    messages.error(holder,\n-                            \"doclet.value_tag_invalid_format\", format);\n-                    return tagletWriter.invalidTagOutput(\n-                            messages.getResources().getText(\"doclet.value_tag_invalid_format\", format),\n-                            Optional.empty());\n-                }\n-            } else {\n-                text = utils.constantValueExpression(field);\n-            }\n-            return valueTagOutput(field, text, !field.equals(holder));\n-        } else {\n-            \/\/Referenced field is not a constant.\n-            messages.warning(holder,\n-                \"doclet.value_tag_invalid_constant\", utils.getSimpleName(field));\n-        }\n-        return tagletWriter.getOutputInstance();\n-    }\n-\n-\n-    \/**\n-     * Returns the output for a {@code {@value}} tag.\n-     *\n-     * @param field       the constant field that holds the value tag\n-     * @param constantVal the constant value to document\n-     * @param includeLink true if we should link the constant text to the\n-     *                    constant field itself\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content valueTagOutput(VariableElement field, String constantVal, boolean includeLink);\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ValueTaglet.java","additions":0,"deletions":140,"binary":false,"changes":140,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * This package has classes used to generate output for Javadoc tags.\n- *\n- * <p>Doclets no longer have to implement their own version of standard tags\n- * such as &#64;param and &#64;throws.  Individual taglets provide\n- * common processing, independent of the output format.\n- * Each doclet must have a taglet writer that takes a taglet\n- * as input and writes doclet-dependent output. The taglet itself will\n- * do the tag processing. For example, suppose we are outputting\n- * &#64;throws tags. The taglet would:\n- * <ul>\n- *     <li> Retrieve the list of throws tags to be documented.\n- *     <li> Replace {&#64;inheritDoc} with the appropriate documentation.\n- *     <li> Add throws documentation for exceptions that are declared in\n- *          the signature of the method but not documented with the throws tags.\n- * <\/ul>\n- * After doing the steps above, the taglet would pass the information to\n- * the taglet writer for writing. The taglets are essentially builders for\n- * tags.\n- *\/\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/package-info.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -37,1 +37,0 @@\n-import java.util.Arrays;\n@@ -119,0 +118,1 @@\n+\n@@ -124,2 +124,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.taglets.BaseTaglet;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.Taglet;\n@@ -2121,10 +2119,3 @@\n-    public List<? extends DocTree> getBlockTags(Element element, Taglet taglet) {\n-        return getBlockTags(element, t -> {\n-            if (taglet instanceof BaseTaglet baseTaglet) {\n-                return baseTaglet.accepts(t);\n-            } else if (t instanceof BlockTagTree blockTagTree) {\n-                return blockTagTree.getTagName().equals(taglet.getName());\n-            } else {\n-                return false;\n-            }\n-        });\n+    public List<? extends DocTree> getBlockTags(Element element, String tagName) {\n+        return getBlockTags(element,\n+                t -> (t instanceof BlockTagTree blockTagTree) && blockTagTree.getTagName().equals(tagName));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":4,"deletions":13,"binary":false,"changes":17,"status":"modified"}]}