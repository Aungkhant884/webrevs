{"files":[{"patch":"@@ -329,19 +329,21 @@\n-    if( was_store ) {\n-      Block *b = mb;            \/\/ Start searching here for a local load\n-      \/\/ mach use (faulting) trying to hoist\n-      \/\/ n might be blocker to hoisting\n-      while( b != block ) {\n-        uint k;\n-        for( k = 1; k < b->number_of_nodes(); k++ ) {\n-          Node *n = b->get_node(k);\n-          if( n->needs_anti_dependence_check() &&\n-              n->in(LoadNode::Memory) == mach->in(StoreNode::Memory) )\n-            break;              \/\/ Found anti-dependent load\n-        }\n-        if( k < b->number_of_nodes() )\n-          break;                \/\/ Found anti-dependent load\n-        \/\/ Make sure control does not do a merge (would have to check allpaths)\n-        if( b->num_preds() != 2 ) break;\n-        b = get_block_for_node(b->pred(1)); \/\/ Move up to predecessor block\n-      }\n-      if( b != block ) continue;\n+    if (was_store) {\n+       \/\/ Make sure control does not do a merge (would have to check allpaths)\n+       if (mb->num_preds() != 2) {\n+         continue;\n+       } \n+       \/\/mach is a store, hence block is the immediate dominator of mb. \n+       \/\/Due to the null-check shape of block (where its successors cannot re-join), \n+       \/\/block must be the direct predecessor of mb.       \n+       assert(get_block_for_node(mb->pred(1)) == block, \"Unexpected predecessor block\");\n+       uint k;\n+       uint num_nodes = mb->number_of_nodes();\n+       for (k = 1; k < num_nodes; k++) {\n+         Node *n = mb->get_node(k);\n+         if (n->needs_anti_dependence_check() &&\n+             n->in(LoadNode::Memory) == mach->in(StoreNode::Memory)) {\n+           break;              \/\/ Found anti-dependent load\n+         }\n+       }\n+       if (k < num_nodes) {\n+         continue;             \/\/ Found anti-dependent load\n+       }\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":21,"deletions":19,"binary":false,"changes":40,"status":"modified"}]}