{"files":[{"patch":"@@ -79,9 +79,0 @@\n-DefNewGeneration::KeepAliveClosure::\n-KeepAliveClosure(ScanWeakRefClosure* cl) : _cl(cl) {\n-  _rs = GenCollectedHeap::heap()->rem_set();\n-}\n-\n-void DefNewGeneration::KeepAliveClosure::do_oop(oop* p)       { DefNewGeneration::KeepAliveClosure::do_oop_work(p); }\n-void DefNewGeneration::KeepAliveClosure::do_oop(narrowOop* p) { DefNewGeneration::KeepAliveClosure::do_oop_work(p); }\n-\n-\n@@ -90,1 +81,2 @@\n-  DefNewGeneration::KeepAliveClosure(cl) {\n+  _cl(cl) {\n+  _rs = GenCollectedHeap::heap()->rem_set();\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -170,2 +170,1 @@\n-  class KeepAliveClosure: public OopClosure {\n-  protected:\n+  class FastKeepAliveClosure: public OopClosure {\n@@ -174,9 +173,0 @@\n-    template <class T> void do_oop_work(T* p);\n-  public:\n-    KeepAliveClosure(ScanWeakRefClosure* cl);\n-    virtual void do_oop(oop* p);\n-    virtual void do_oop(narrowOop* p);\n-  };\n-\n-  class FastKeepAliveClosure: public KeepAliveClosure {\n-  protected:\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -39,31 +39,0 @@\n-template <class T>\n-inline void DefNewGeneration::KeepAliveClosure::do_oop_work(T* p) {\n-#ifdef ASSERT\n-  {\n-    \/\/ We never expect to see a null reference being processed\n-    \/\/ as a weak reference.\n-    oop obj = RawAccess<IS_NOT_NULL>::oop_load(p);\n-    assert (oopDesc::is_oop(obj), \"expected an oop while scanning weak refs\");\n-  }\n-#endif \/\/ ASSERT\n-\n-  Devirtualizer::do_oop(_cl, p);\n-\n-  \/\/ Card marking is trickier for weak refs.\n-  \/\/ This oop is a 'next' field which was filled in while we\n-  \/\/ were discovering weak references. While we might not need\n-  \/\/ to take a special action to keep this reference alive, we\n-  \/\/ will need to dirty a card as the field was modified.\n-  \/\/\n-  \/\/ Alternatively, we could create a method which iterates through\n-  \/\/ each generation, allowing them in turn to examine the modified\n-  \/\/ field.\n-  \/\/\n-  \/\/ We could check that p is also in the old generation, but\n-  \/\/ dirty cards in the young gen are never scanned, so the\n-  \/\/ extra check probably isn't worthwhile.\n-  if (GenCollectedHeap::heap()->is_in_reserved(p)) {\n-    _rs->inline_write_ref_field_gc(p);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.inline.hpp","additions":0,"deletions":31,"binary":false,"changes":31,"status":"modified"}]}