{"files":[{"patch":"@@ -82,0 +82,1 @@\n+  BUILD_JDK_JTREG_LIBRARIES_LIBS_libGetXSpace := $(WIN_LIB_JAVA)\n@@ -86,0 +87,1 @@\n+  BUILD_JDK_JTREG_LIBRARIES_LIBS_libGetXSpace := -ljava\n","filename":"make\/test\/JtregNativeJdk.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @run main\/othervm -Djava.security.manager=allow GetXSpace\n+ * @run main\/othervm\/native -Djava.security.manager=allow GetXSpace\n@@ -55,0 +55,3 @@\n+    static {\n+        System.loadLibrary(\"GetXSpace\");\n+    }\n@@ -59,3 +62,0 @@\n-    \/\/ FileSystem Total Used Available Use% MountedOn\n-    private static final Pattern DF_PATTERN = Pattern.compile(\"([^\\\\s]+)\\\\s+(\\\\d+)\\\\s+(\\\\d+)\\\\s+(\\\\d+)\\\\s+\\\\d+%\\\\s+([^\\\\s].*)\\n\");\n-\n@@ -103,1 +103,0 @@\n-        private static final long KSIZE = 1024;\n@@ -105,0 +104,1 @@\n+        private final long size;\n@@ -106,1 +106,1 @@\n-        private final long used;\n+        private final long free;\n@@ -109,1 +109,1 @@\n-        Space(String name, String total, String used, String available) {\n+        Space(String name) {\n@@ -111,7 +111,6 @@\n-            try {\n-                this.total = Long.parseLong(total) * KSIZE;\n-                this.used = Long.parseLong(used) * KSIZE;\n-                this.available = Long.parseLong(available) * KSIZE;\n-            } catch (NumberFormatException x) {\n-                throw new RuntimeException(\"the regex should have caught this\", x);\n-            }\n+            long[] sizes = new long[4];\n+            getSpace0(name, sizes);\n+            this.size = sizes[0];\n+            this.total = sizes[1];\n+            this.free = sizes[2];\n+            this.available = sizes[3];\n@@ -121,0 +120,1 @@\n+        long size() { return size; }\n@@ -122,1 +122,0 @@\n-        long used() { return used; }\n@@ -124,1 +123,2 @@\n-        long free() { return total - used; }\n+        long free() { return free; }\n+\n@@ -129,0 +129,1 @@\n+\n@@ -130,1 +131,1 @@\n-            return String.format(\"%s (%d\/%d\/%d)\", name, total, used, available);\n+            return String.format(\"%s (%d\/%d\/%d)\", name, total, free, available);\n@@ -152,47 +153,2 @@\n-    private static String getCallerTotalSpace(String name) throws IOException {\n-        String root = name.substring(0, name.indexOf(':') + 1) + \"\\\\\";\n-        String cmd = \"fsutil volume diskFree \" + root;\n-        Process p = Runtime.getRuntime().exec(cmd);\n-        try (BufferedReader in = p.inputReader()) {\n-            String line;\n-            while ((line = in.readLine()) != null) {\n-                \/\/\n-                \/\/ The line of the diskFree output which contains the total\n-                \/\/ number of bytes may be formatted as one of the following:\n-                \/\/\n-                \/\/ Total # of bytes             : 161051996160\n-                \/\/ Total # of bytes             : 161051996160 (149.99GB)\n-                \/\/ Total bytes                     : 322,122,547,200 (300.0 GB)\n-                \/\/\n-                if (line.startsWith(\"Total # of bytes\") ||\n-                    line.startsWith(\"Total bytes\")) {\n-                    int colon = line.indexOf(':');\n-                    int paren = line.indexOf('(', colon);\n-                    String s = paren == -1\n-                        ? line.substring(colon + 1)\n-                        : line.substring(colon + 1, paren);\n-                    s = s.trim();\n-                    s = s.replace(\",\", \"\");\n-                    return s;\n-                }\n-            }\n-            throw new RuntimeException(\"Total number of bytes not found\");\n-        }\n-    }\n-\n-    private static ArrayList<Space> space(String f) throws IOException {\n-        ArrayList<Space> al = new ArrayList<>();\n-\n-        String cmd = \"df -k -P\" + (f == null ? \"\" : \" \" + f);\n-        StringBuilder sb = new StringBuilder();\n-        Process p = Runtime.getRuntime().exec(cmd);\n-        try (BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream()))) {\n-            String s;\n-            int i = 0;\n-            while ((s = in.readLine()) != null) {\n-                \/\/ skip header\n-                if (i++ == 0) continue;\n-                sb.append(s).append(\"\\n\");\n-            }\n-        }\n-        out.println(sb);\n+    private static ArrayList<String> paths() throws IOException {\n+        ArrayList<String> al = new ArrayList<>();\n@@ -200,25 +156,5 @@\n-        Matcher m = DF_PATTERN.matcher(sb);\n-        int j = 0;\n-        while (j < sb.length()) {\n-            if (m.find(j)) {\n-                \/\/ swap can change while this test is running\n-                if (!m.group(1).equals(\"swap\")) {\n-                    String name = f;\n-                    if (name == null) {\n-                        \/\/ cygwin's df lists windows path as FileSystem (1st group)\n-                        name = Platform.isWindows() ? m.group(1) : m.group(5);\n-                    }\n-                    \/\/ cygwin's df provides the actual total disk space not\n-                    \/\/ accounting for quotas, so use the total size from\n-                    \/\/ diskFree which does account for quotas\n-                    String callerTotalSpace = Platform.isWindows()\n-                        ? getCallerTotalSpace(name)\n-                        : m.group(2);\n-                    al.add(new Space(name, callerTotalSpace, m.group(3), m.group(4)));\n-                }\n-                j = m.end();\n-            } else {\n-                throw new RuntimeException(\"unrecognized df output format: \"\n-                                           + \"charAt(\" + j + \") = '\"\n-                                           + sb.charAt(j) + \"'\");\n-            }\n+        File[] roots = File.listRoots();\n+        long[] space = new long[4];\n+        for (File root : roots) {\n+            String path = root.toString();\n+            al.add(path);\n@@ -227,5 +163,0 @@\n-        if (al.size() == 0) {\n-            \/\/ df did not produce output\n-            String name = (f == null ? \"\" : f);\n-            al.add(new Space(name, \"0\", \"0\", \"0\"));\n-        }\n@@ -271,1 +202,1 @@\n-        out.format(\"%s:%n\", s.name());\n+        out.format(\"%s (%d):%n\", s.name(), s.size());\n@@ -273,2 +204,2 @@\n-        out.format(fmt, \"df\", s.total(), s.free(), s.available());\n-        out.format(fmt, \"getX\", ts, fs, us);\n+        out.format(fmt, \"getSpace0\", s.total(), s.free(), s.available());\n+        out.format(fmt, \"getXSpace\", ts, fs, us);\n@@ -278,1 +209,2 @@\n-        if (ts != s.total() && (!Platform.isOSX() || !s.name().equals(\"\/dev\"))) {\n+        if (ts != s.total()\n+            && (!Platform.isOSX() || !s.name().equals(\"\/dev\"))) {\n@@ -295,18 +227,3 @@\n-            \/\/ On macOS, the number of 1024 byte blocks might be incorrectly\n-            \/\/ calculated by 'df' using integer division by 2 of the number of\n-            \/\/ 512 byte blocks, resulting in a size smaller than the actual\n-            \/\/ value when the number of blocks is odd.\n-            if (!Platform.isOSX() || blockSize != 512 || numBlocks % 2 == 0 ||\n-                ts - s.total() != 512) {\n-                if (Platform.isWindows()) {\n-                    \/\/\n-                    \/\/ In Cygwin, 'df' reports the actual total disk size, but\n-                    \/\/ the total size reported by GetDiskFreeSpaceExW accounts\n-                    \/\/ for user quotas, thus the latter value should not exceed\n-                    \/\/ the former.\n-                    \/\/\n-                    if (ts > s.total()) {\n-                        fail(s.name() + \" total space\", ts, \">\", s.total());\n-                    }\n-                } else {\n-                    fail(s.name() + \" total space\", ts, \"!=\", s.total());\n+            if (Platform.isWindows()) {\n+                if (ts > s.total()) {\n+                    fail(s.name() + \" total space\", ts, \">\", s.total());\n@@ -314,0 +231,2 @@\n+            } else if (ts != s.total()) {\n+                fail(s.name() + \" total space\", ts, \"!=\", s.total());\n@@ -319,1 +238,1 @@\n-        \/\/ unix df returns statvfs.f_bavail\n+        \/\/ unix usable space is from statvfs.f_bavail\n@@ -327,2 +246,13 @@\n-        if (fs > s.total()) {\n-            fail(s.name() + \" free space\", fs, \">\", s.total());\n+        \/\/\n+        \/\/ Invariants are:\n+        \/\/ total space <= size\n+        \/\/ total space == size (Unix)\n+        \/\/ free space <= total space (if no quotas in effect) (Windows)\n+        \/\/ free space < size (if quotas in effect) (Windows)\n+        \/\/ usable space <= total space\n+        \/\/ usable space <= free space\n+        \/\/\n+\n+        \/\/ total space <= size\n+        if (ts > s.size()) {\n+            fail(s.name() + \" size\", ts, \">\", s.size());\n@@ -333,0 +263,19 @@\n+        \/\/ On Unix the total space should always be the volume size\n+        if (!Platform.isWindows()) {\n+            if (ts != s.size()) {\n+                fail(s.name() + \" total space\", ts, \"!=\", s.size());\n+            } else {\n+                pass();\n+            }\n+        } else { \/\/ Windows\n+            \/\/ ts != s.size() indicates that quotas are in effect\n+            if (ts == s.size() && fs > s.total()) {\n+                fail(s.name() + \" free space\", fs, \">\", s.total());\n+            } else if (ts < s.size() && fs > s.size()) {\n+                fail(s.name() + \" free space (quota)\", fs, \">\", s.size());\n+            } else {\n+                pass();\n+            }\n+        }\n+\n+        \/\/ usable space <= total space\n@@ -338,0 +287,13 @@\n+\n+        \/\/ usable space <= free space\n+        if (us > s.free()) {\n+            \/\/ free and usable change dynamically\n+            System.err.println(\"Warning: us > s.free()\");\n+            if (1.0 - Math.abs((double)s.free()\/(double)us) > 0.01) {\n+                fail(s.name() + \" usable vs. free space\", us, \">\", s.free());\n+            } else {\n+                pass();\n+            }\n+        } else {\n+            pass();\n+        }\n@@ -430,7 +392,1 @@\n-        ArrayList<Space> l;\n-        try {\n-            l = space(dirName);\n-        } catch (IOException x) {\n-            throw new RuntimeException(dirName + \" can't get file system information\", x);\n-        }\n-        compare(l.get(0));\n+        compare(new Space(dir.getRoot().toString()));\n@@ -448,5 +404,5 @@\n-    private static int testDF() {\n-        out.println(\"--- Testing df\");\n-        \/\/ Find all of the partitions on the machine and verify that the size\n-        \/\/ returned by \"df\" is equivalent to File.getXSpace() values.\n-        ArrayList<Space> l;\n+    private static int testVolumes() {\n+        out.println(\"--- Testing volumes\");\n+        \/\/ Find all of the partitions on the machine and verify that the sizes\n+        \/\/ returned by File::getXSpace are equivalent to those from getSpace0\n+        ArrayList<String> l;\n@@ -454,1 +410,1 @@\n-            l = space(null);\n+            l = paths();\n@@ -473,1 +429,2 @@\n-            for (var s : l) {\n+            for (var p : l) {\n+                Space s = new Space(p);\n@@ -511,1 +468,1 @@\n-        int failedTests = testDF();\n+        int failedTests = testVolumes();\n@@ -530,0 +487,9 @@\n+\n+    \/\/\n+    \/\/ root     the root of the volume\n+    \/\/ size[0]  total size:   number of bytes in the volume\n+    \/\/ size[1]  total space:  number of bytes visible to the caller\n+    \/\/ size[2]  free space:   number of free bytes in the volume\n+    \/\/ size[3]  usable space: number of bytes available to the caller\n+    \/\/\n+    private static native void getSpace0(String root, long[] space);\n","filename":"test\/jdk\/java\/io\/File\/GetXSpace.java","additions":100,"deletions":134,"binary":false,"changes":234,"status":"modified"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <stdlib.h>\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#ifdef _WIN64\n+#include <windows.h>\n+#include <fileapi.h>\n+#include <winerror.h>\n+#else\n+#include <sys\/errno.h>\n+#include <string.h>\n+#if __APPLE__\n+#include <sys\/param.h>\n+#include <sys\/mount.h>\n+#else\n+#include <sys\/statfs.h>\n+#endif\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#ifdef _WIN64\n+jboolean initialized = JNI_FALSE;\n+BOOL(WINAPI * pfnGetDiskSpaceInformation)(LPCWSTR, LPVOID) = NULL;\n+#endif\n+\n+\/\/\n+\/\/ root      the root of the volume\n+\/\/ sizes[0]  total size:   number of bytes in the volume\n+\/\/ sizes[1]  total space:  number of bytes visible to the caller\n+\/\/ sizes[2]  free space:   number of free bytes in the volume\n+\/\/ sizes[3]  usable space: number of bytes available to the caller\n+\/\/\n+JNIEXPORT void JNICALL\n+Java_GetXSpace_getSpace0\n+    (JNIEnv *env, jclass cls, jstring root, jlongArray sizes)\n+{\n+    jlong array[4];\n+    const jchar* chars = (*env)->GetStringChars(env, root, NULL);\n+    if (chars == NULL) {\n+        JNU_ThrowByNameWithLastError(env, \"java\/lang\/RuntimeException\",\n+                                     \"GetStringChars\");\n+    }\n+\n+#ifdef _WIN64\n+    if (initialized == JNI_FALSE) {\n+        initialized = JNI_TRUE;\n+        HMODULE hmod = GetModuleHandleW(L\"kernel32\");\n+        if (hmod != NULL) {\n+            *(FARPROC*)&pfnGetDiskSpaceInformation =\n+                GetProcAddress(hmod, \"GetDiskSpaceInformationW\");\n+        }\n+    }\n+\n+    LPCWSTR path = (LPCWSTR)chars;\n+\n+    if (pfnGetDiskSpaceInformation != NULL) {\n+        \/\/ use GetDiskSpaceInformationW\n+        DISK_SPACE_INFORMATION diskSpaceInfo;\n+        BOOL hres = pfnGetDiskSpaceInformation(path, &diskSpaceInfo);\n+        if (FAILED(hres)) {\n+            JNU_ThrowByNameWithLastError(env, \"java\/lang\/RuntimeException\",\n+                                         \"GetDiskSpaceInformationW\");\n+            return;\n+        }\n+\n+        ULONGLONG bytesPerAllocationUnit =\n+            diskSpaceInfo.SectorsPerAllocationUnit*diskSpaceInfo.BytesPerSector;\n+        array[0] = (jlong)(diskSpaceInfo.ActualTotalAllocationUnits*\n+                           bytesPerAllocationUnit);\n+        array[1] = (jlong)(diskSpaceInfo.CallerTotalAllocationUnits*\n+                           bytesPerAllocationUnit);\n+        array[2] = (jlong)(diskSpaceInfo.ActualAvailableAllocationUnits*\n+                           bytesPerAllocationUnit);\n+        array[3] = (jlong)(diskSpaceInfo.CallerAvailableAllocationUnits*\n+                           bytesPerAllocationUnit);\n+    } else {\n+        \/\/ if GetDiskSpaceInformationW is unavailable (\"The specified\n+        \/\/ procedure could not be found\"), fall back to GetDiskFreeSpaceExW\n+        ULARGE_INTEGER freeBytesAvailable;\n+        ULARGE_INTEGER totalNumberOfBytes;\n+        ULARGE_INTEGER totalNumberOfFreeBytes;\n+\n+        if (GetDiskFreeSpaceExW(path, &freeBytesAvailable, &totalNumberOfBytes,\n+            &totalNumberOfFreeBytes) == 0) {\n+            JNU_ThrowByNameWithLastError(env, \"java\/lang\/RuntimeException\",\n+                                         \"GetDiskFreeSpaceExW\");\n+            return;\n+        }\n+\n+        \/\/ If quotas are in effect, it is impossible to obtain the volume size,\n+        \/\/ so estimate it as free + used = free + (visible - available)\n+        ULONGLONG used = totalNumberOfBytes.QuadPart - freeBytesAvailable.QuadPart;\n+        array[0] = (jlong)(totalNumberOfFreeBytes.QuadPart + used);\n+        array[1] = (jlong)totalNumberOfBytes.QuadPart;\n+        array[2] = (jlong)totalNumberOfFreeBytes.QuadPart;\n+        array[3] = (jlong)freeBytesAvailable.QuadPart;\n+    }\n+#else\n+    struct statfs buf;\n+    int result = statfs((const char*)chars, &buf);\n+    (*env)->ReleaseStringChars(env, root, chars);\n+    if (result < 0) {\n+        JNU_ThrowByNameWithLastError(env, \"java\/lang\/RuntimeException\",\n+                                     strerror(errno));\n+        return;\n+    }\n+\n+    array[0] = (jlong)(buf.f_blocks*buf.f_bsize);\n+    array[1] = array[0]; \/\/ number visible is the same as the total size\n+    array[2] = (jlong)(buf.f_bfree*buf.f_bsize);\n+    array[3] = (jlong)(buf.f_bavail*buf.f_bsize);\n+#endif\n+    (*env)->SetLongArrayRegion(env, sizes, 0, 4, array);\n+}\n+#ifdef __cplusplus\n+}\n+#endif\n","filename":"test\/jdk\/java\/io\/File\/libGetXSpace.c","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"}]}