{"files":[{"patch":"@@ -1653,1 +1653,1 @@\n-    Deoptimization::mark_and_deoptimize_dependents_on(k);\n+    Deoptimization::deoptimize_dependents(k);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -760,1 +760,1 @@\n-void CodeCache::do_unloading(BoolObjectClosure* is_alive, bool unloading_occurred) {\n+void CodeCache::do_unloading(bool unloading_occurred) {\n@@ -762,1 +762,0 @@\n-  UnloadingScope scope(is_alive);\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -200,1 +200,1 @@\n-  static void do_unloading(BoolObjectClosure* is_alive, bool unloading_occurred);\n+  static void do_unloading(bool unloading_occurred);\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,2 +53,0 @@\n-CompiledMethod* CompiledMethod::_root_mark_link = nullptr;\n-\n@@ -59,1 +57,0 @@\n-    _mark_link(nullptr),\n@@ -71,1 +68,0 @@\n-    _mark_link(nullptr),\n@@ -122,1 +118,1 @@\n-bool CompiledMethod::mark_for_deoptimization(bool inc_recompile_counts) {\n+bool CompiledMethod::enqueue_deoptimization(bool inc_recompile_counts) {\n@@ -124,11 +120,3 @@\n-  MarkForDeoptimizationStatus old_mark = extract_mark(_mark_link);\n-  if (old_mark != deoptimize_done) { \/\/ can't go backwards\n-    MarkForDeoptimizationStatus new_mark = (inc_recompile_counts ? deoptimize : deoptimize_noupdate);\n-    if (old_mark == not_marked) {\n-      assert(extract_compiled_method(_mark_link) == nullptr, \"Compiled Method should not already be linked\");\n-      _mark_link = mark_link(_root_mark_link, new_mark);\n-      _root_mark_link = this;\n-      return true;\n-    } else {\n-      _mark_link = mark_link(extract_compiled_method(_mark_link), new_mark);\n-    }\n+  DeoptimizationStatus old_status = _deoptimization_status;\n+  if (_deoptimization_status != deoptimize_done) { \/\/ can't go backwards\n+    _deoptimization_status = (inc_recompile_counts ? enqueued : enqueued_noupdate);\n@@ -136,13 +124,1 @@\n-  return false;\n-}\n-\n-CompiledMethod* CompiledMethod::next_marked() const {\n-  assert_locked_or_safepoint(Compile_lock);\n-  return extract_compiled_method(_mark_link);\n-}\n-\n-CompiledMethod* CompiledMethod::take_root() {\n-  assert_locked_or_safepoint(Compile_lock);\n-  CompiledMethod* root = _root_mark_link;\n-  _root_mark_link = nullptr;\n-  return root;\n+  return old_status == not_enqueued;\n@@ -151,1 +127,1 @@\n-void  CompiledMethod::mark_deoptimized() {\n+void  CompiledMethod::make_deoptimized_done() {\n@@ -153,1 +129,1 @@\n-  _mark_link = mark_link(extract_compiled_method(_mark_link), deoptimize_done);\n+  _deoptimization_status = deoptimize_done;\n","filename":"src\/hotspot\/share\/code\/compiledMethod.cpp","additions":7,"deletions":31,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -148,4 +148,6 @@\n-  enum MarkForDeoptimizationStatus : u1 {\n-    not_marked,\n-    deoptimize,\n-    deoptimize_noupdate,\n+  enum DeoptimizationStatus : u1 {\n+    not_enqueued,\n+    enqueued,\n+    enqueued_noupdate,\n+    \/\/ TODO: look at deoptimize_done, it is only used for continuations, misleading\n+    \/\/ see TODO comment in update_recompile_counts().\n@@ -155,1 +157,1 @@\n-  struct MarkedCompiledMethodLink;\n+  DeoptimizationStatus _deoptimization_status; \/\/ Used for stack deoptimization\n@@ -157,14 +159,0 @@\n-  static CompiledMethod* _root_mark_link;\n-  MarkedCompiledMethodLink* _mark_link;\n-\n-  static MarkedCompiledMethodLink* mark_link(CompiledMethod* cm, MarkForDeoptimizationStatus mark) {\n-    assert(((uintptr_t)cm & 0x3) == 0, \"cm pointer must have zero lower two LSB\");\n-    return (MarkedCompiledMethodLink*)(((uintptr_t)cm & ~0x3) | static_cast<u1>(mark));\n-  }\n-\n-  static MarkForDeoptimizationStatus extract_mark(MarkedCompiledMethodLink* link) {\n-    return static_cast<MarkForDeoptimizationStatus>((uintptr_t)link & 0x3);\n-  }\n-  static CompiledMethod* extract_compiled_method(MarkedCompiledMethodLink* link) {\n-    return (CompiledMethod*)((uintptr_t)link & ~0x3);\n-  }\n@@ -260,1 +248,1 @@\n-  bool  is_marked_for_deoptimization() const { return extract_mark(_mark_link) != not_marked; }\n+  bool  has_been_enqueued_for_deoptimization() const { return _deoptimization_status != not_enqueued; }\n@@ -262,1 +250,3 @@\n-  bool  has_been_deoptimized() const { return extract_mark(_mark_link) == deoptimize_done; }\n+  \/\/ TODO: deoptimize_done is very weird in this new thing\n+  \/\/ see TODO comment in update_recompile_counts().\n+  bool  has_been_deoptimized() const { return _deoptimization_status == deoptimize_done; }\n@@ -265,3 +255,1 @@\n-  bool  mark_for_deoptimization(bool inc_recompile_counts = true);\n-  CompiledMethod* next_marked() const;\n-  static CompiledMethod* take_root();\n+  bool  enqueue_deoptimization(bool inc_recompile_counts = true);\n@@ -269,1 +257,3 @@\n-  void  mark_deoptimized();\n+  \/\/ TODO: bad name for what it does.\n+  \/\/ see TODO comment in update_recompile_counts().\n+  void  make_deoptimized_done();\n@@ -275,5 +265,30 @@\n-    \/\/ Update recompile counts when either the update is explicitly requested (deoptimize)\n-    \/\/ or the nmethod is not marked for deoptimization at all (not_marked).\n-    \/\/ The latter happens during uncommon traps when deoptimized nmethod is made not entrant.\n-    MarkForDeoptimizationStatus mark_status = extract_mark(_mark_link);\n-    return mark_status != deoptimize_noupdate && mark_status != deoptimize_done;\n+    \/\/ TODO: fix this logic!\n+    \/\/ Original Text with new enum terminology:\n+      \/\/ Update recompile counts when either the update is explicitly requested (enqueued)\n+      \/\/ or the nmethod has not enqueued deoptimization at all (not_enqueued).\n+      \/\/ The latter happens during uncommon traps when deoptimized nmethod is made not entrant.\n+    \/\/ Actually behaviour:\n+      \/\/ The function is only used in when an nmethod is made not entrant (or zombie) and\n+      \/\/ _deoptimization_status != deoptimize_done is always true, as it is only called in\n+      \/\/ make_deoptimized which is called right after a call to make_not_entrant. Even if\n+      \/\/ some other thread comes before that call and makes this nmethod not entrant (or zombie)\n+      \/\/ that thread will not see _deoptimization_status == deoptimize_done and if some thread\n+      \/\/ calls make_not_entrant after it will not succeed as it was already made non_entrant.\n+      \/\/ the unloaded transition will not affect this either. (the try_transition race). And it\n+      \/\/ is gone when the sweeper is removed. So now it is pretty much just update the recompile\n+      \/\/ count if not explicitly told not too (enqueued_noupdate).\n+    \/\/ _deoptimization_status != deoptimize_done sort of makes sense if it meant what it actually says,\n+    \/\/ but the semantics of deoptimize_done is unclear and need to be defined.\n+      \/\/ Right now it means nothing if continuations is turned off. And with it on it means that the\n+      \/\/ nmethod's NativePostCallNop have been patched. Neither truly means that the nmethod has been\n+      \/\/ deoptimized. As we still need to walk the frame stacks and install deopt return pc's.\n+        \/\/ frame::deoptimize also have some dead code, NativePostCallNop* inst = nativePostCallNop_at(pc()),\n+        \/\/ which has no side effects. (inst never used).\n+        \/\/ frame::patch_pc takes a Thread* and never uses it.\n+      \/\/ So maybe there should be another status, deoptimize_post_call_installed and deoptimize_done. And\n+      \/\/ deoptimize_done is only set after the frames has been walked. This does however require finding all\n+      \/\/ the nmethods again, it seems overly complicated to just have a flag which is never used. Maybe rename\n+      \/\/ deoptimize_done to deoptimize_post_call_installed is the best and not track if all the steps of the\n+      \/\/ deoptimization has been completed.\n+    return _deoptimization_status != enqueued_noupdate &&\n+        _deoptimization_status != deoptimize_done;\n","filename":"src\/hotspot\/share\/code\/compiledMethod.hpp","additions":45,"deletions":30,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -687,1 +687,1 @@\n-  virtual void mark_for_deoptimization(nmethod* nm, DeoptimizationContext* deopt) = 0;\n+  virtual void enqueue_deoptimization(nmethod* nm, DeoptimizationContext* deopt) = 0;\n@@ -785,2 +785,2 @@\n-  virtual void mark_for_deoptimization(nmethod* nm, DeoptimizationContext* deopt) {\n-    deopt->mark(nm, true \/* inc_recompile_counts *\/);\n+  virtual void enqueue_deoptimization(nmethod* nm, DeoptimizationContext* deopt) {\n+    deopt->enqueue(nm);\n@@ -827,2 +827,2 @@\n-  virtual void mark_for_deoptimization(nmethod* nm, DeoptimizationContext* deopt) {\n-    deopt->mark(nm, false \/* inc_recompile_counts *\/);\n+  virtual void enqueue_deoptimization(nmethod* nm, DeoptimizationContext* deopt) {\n+    deopt->enqueue_no_recompile_count_update(nm);\n","filename":"src\/hotspot\/share\/code\/dependencies.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -65,2 +65,2 @@\n-\/\/ are dependent on the changes that were passed in and mark them for\n-\/\/ deoptimization.  Returns the number of nmethods found.\n+\/\/ are dependent on the changes that were passed in and enqueue\n+\/\/ deoptimization for them.  Returns the number of nmethods found.\n@@ -68,1 +68,1 @@\n-void DependencyContext::mark_dependent_nmethods(DepChange& changes, DeoptimizationContext* deopt) {\n+void DependencyContext::enqueue_deoptimization_dependent_nmethods(DepChange& changes, DeoptimizationContext* deopt) {\n@@ -73,1 +73,1 @@\n-    if (b->count() > 0 && nm->is_alive() && !nm->is_marked_for_deoptimization() && nm->check_dependency_on(changes)) {\n+    if (b->count() > 0 && nm->is_alive() && !nm->has_been_enqueued_for_deoptimization() && nm->check_dependency_on(changes)) {\n@@ -76,1 +76,1 @@\n-        tty->print_cr(\"Marked for deoptimization\");\n+        tty->print_cr(\"Enqueued deoptimization\");\n@@ -81,1 +81,1 @@\n-      changes.mark_for_deoptimization(nm, deopt);\n+      changes.enqueue_deoptimization(nm, deopt);\n@@ -207,4 +207,4 @@\n-    nmethodBucket* next = b->next_not_unloading();\n-    release(b);\n-    return next;\n-}\n+  nmethodBucket* next = b->next_not_unloading();\n+  release(b);\n+  return next;\n+ }\n@@ -217,8 +217,1 @@\n-  int removed = 0;\n-  while (b != NULL) {\n-    b = release_and_get_next_not_unloading(b);\n-    ++removed;\n-  }\n-  if (UsePerfData && removed > 0) {\n-    _perf_total_buckets_deallocated_count->inc(removed);\n-  }\n+  assert(b == nullptr, \"All dependents should be unloading\");\n@@ -227,1 +220,1 @@\n-void DependencyContext::remove_and_mark_all_dependents(DeoptimizationContext* deopt) {\n+void DependencyContext::remove_and_enqueue_deoptimization_all_dependents(DeoptimizationContext* deopt) {\n@@ -230,1 +223,0 @@\n-  int removed = 0;\n@@ -233,2 +225,2 @@\n-    if (b->count() > 0 && nm->is_alive() && !nm->is_marked_for_deoptimization()) {\n-      deopt->mark(nm, true \/* inc_recompile_counts *\/);\n+    if (b->count() > 0 && nm->is_alive() && !nm->has_been_enqueued_for_deoptimization()) {\n+      deopt->enqueue(nm);\n@@ -237,4 +229,0 @@\n-    ++removed;\n-  }\n-  if (UsePerfData && removed > 0) {\n-    _perf_total_buckets_deallocated_count->inc(removed);\n","filename":"src\/hotspot\/share\/code\/dependencyContext.cpp","additions":14,"deletions":26,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-  void mark_dependent_nmethods(DepChange& changes, DeoptimizationContext* deopt);\n+  void enqueue_deoptimization_dependent_nmethods(DepChange& changes, DeoptimizationContext* deopt);\n@@ -125,1 +125,0 @@\n-  void remove_and_mark_all_dependents(DeoptimizationContext* deopt);\n@@ -127,0 +126,1 @@\n+  void remove_and_enqueue_deoptimization_all_dependents(DeoptimizationContext* deopt);\n","filename":"src\/hotspot\/share\/code\/dependencyContext.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1165,1 +1165,1 @@\n-  mark_deoptimized();\n+  make_deoptimized_done();\n@@ -1472,0 +1472,1 @@\n+      \/\/ TODO: Fix terminology\n@@ -2358,2 +2359,2 @@\n-  \/\/ Iterate over live nmethods and check dependencies of all nmethods that are not\n-  \/\/ marked for deoptimization. A particular dependency is only checked once.\n+  \/\/ Iterate over live nmethods and check dependencies of all nmethods that has not\n+  \/\/ been enqueue for deoptimization. A particular dependency is only checked once.\n@@ -2364,1 +2365,1 @@\n-    if (!nm->is_marked_for_deoptimization()) {\n+    if (!nm->has_been_enqueued_for_deoptimization()) {\n@@ -2380,1 +2381,1 @@\n-            assert(false, \"Should have been marked for deoptimization\");\n+            assert(false, \"Should have enqueued deoptimization\");\n@@ -2403,1 +2404,0 @@\n-\/\/ Called from mark_for_deoptimization, when dependee is invalidated.\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2893,2 +2893,1 @@\n-void G1CollectedHeap::complete_cleaning(BoolObjectClosure* is_alive,\n-                                        bool class_unloading_occurred) {\n+void G1CollectedHeap::complete_cleaning(bool class_unloading_occurred) {\n@@ -2896,1 +2895,1 @@\n-  G1ParallelCleaningTask unlink_task(is_alive, num_workers, class_unloading_occurred);\n+  G1ParallelCleaningTask unlink_task(num_workers, class_unloading_occurred);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1264,1 +1264,1 @@\n-  void complete_cleaning(BoolObjectClosure* is_alive, bool class_unloading_occurred);\n+  void complete_cleaning(bool class_unloading_occurred);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1684,0 +1684,1 @@\n+    CodeCache::UnloadingScope scope(&g1_is_alive);\n@@ -1685,1 +1686,1 @@\n-    _g1h->complete_cleaning(&g1_is_alive, purged_classes);\n+    _g1h->complete_cleaning(purged_classes);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -304,0 +304,1 @@\n+    CodeCache::UnloadingScope unloading_scope(&_is_alive);\n@@ -306,1 +307,1 @@\n-    _heap->complete_cleaning(&_is_alive, purged_class);\n+    _heap->complete_cleaning(purged_class);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -54,2 +54,1 @@\n-G1ParallelCleaningTask::G1ParallelCleaningTask(BoolObjectClosure* is_alive,\n-                                               uint num_workers,\n+G1ParallelCleaningTask::G1ParallelCleaningTask(uint num_workers,\n@@ -59,1 +58,1 @@\n-  _code_cache_task(num_workers, is_alive, unloading_occurred),\n+  _code_cache_task(num_workers, unloading_occurred),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParallelCleaning.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -57,2 +57,1 @@\n-  G1ParallelCleaningTask(BoolObjectClosure* is_alive,\n-                         uint num_workers,\n+  G1ParallelCleaningTask(uint num_workers,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParallelCleaning.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2059,0 +2059,1 @@\n+    CodeCache::UnloadingScope scope(is_alive_closure());\n@@ -2064,1 +2065,1 @@\n-    CodeCache::do_unloading(is_alive_closure(), purged_class);\n+    CodeCache::do_unloading(purged_class);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -218,0 +218,1 @@\n+    CodeCache::UnloadingScope scope(&is_alive);\n@@ -223,1 +224,1 @@\n-    CodeCache::do_unloading(&is_alive, purged_class);\n+    CodeCache::do_unloading(purged_class);\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,2 +35,1 @@\n-CodeCacheUnloadingTask::CodeCacheUnloadingTask(uint num_workers, BoolObjectClosure* is_alive, bool unloading_occurred) :\n-  _unloading_scope(is_alive),\n+CodeCacheUnloadingTask::CodeCacheUnloadingTask(uint num_workers, bool unloading_occurred) :\n","filename":"src\/hotspot\/share\/gc\/shared\/parallelCleaning.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-  CodeCache::UnloadingScope _unloading_scope;\n@@ -44,1 +43,1 @@\n-  CodeCacheUnloadingTask(uint num_workers, BoolObjectClosure* is_alive, bool unloading_occurred);\n+  CodeCacheUnloadingTask(uint num_workers, bool unloading_occurred);\n","filename":"src\/hotspot\/share\/gc\/shared\/parallelCleaning.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+#include \"code\/codeCache.hpp\"\n@@ -1793,0 +1794,2 @@\n+    ShenandoahIsAliveSelector is_alive;\n+    CodeCache::UnloadingScope scope(is_alive.is_alive_closure());\n@@ -1797,1 +1800,0 @@\n-    ShenandoahIsAliveSelector is_alive;\n@@ -1799,1 +1801,1 @@\n-    ShenandoahClassUnloadingTask unlink_task(phase, is_alive.is_alive_closure(), num_workers, purged_class);\n+    ShenandoahClassUnloadingTask unlink_task(phase, num_workers, purged_class);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-                                                           BoolObjectClosure* is_alive,\n@@ -41,1 +40,1 @@\n-  _code_cache_task(num_workers, is_alive, unloading_occurred),\n+  _code_cache_task(num_workers, unloading_occurred),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahParallelCleaning.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-                               BoolObjectClosure* is_alive,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahParallelCleaning.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1539,1 +1539,1 @@\n-    Deoptimization::mark_and_deoptimize_nmethod(nm);\n+    Deoptimization::deoptimize_nmethod(nm);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1184,1 +1184,1 @@\n-     Deoptimization::mark_and_deoptimize_dependents_on(this);\n+     Deoptimization::deoptimize_dependents(this);\n@@ -2337,2 +2337,2 @@\n-void InstanceKlass::mark_dependent_nmethods(KlassDepChange& changes, DeoptimizationContext* deopt) {\n-  dependencies().mark_dependent_nmethods(changes, deopt);\n+void InstanceKlass::enqueue_deoptimization_dependent_nmethods(KlassDepChange& changes, DeoptimizationContext* deopt) {\n+  dependencies().enqueue_deoptimization_dependent_nmethods(changes, deopt);\n@@ -3322,1 +3322,1 @@\n-void InstanceKlass::mark_osr_nmethods(const Method* m, DeoptimizationContext* deopt) {\n+void InstanceKlass::enqueue_deoptimization_osr_nmethods(const Method* m, DeoptimizationContext* deopt) {\n@@ -3329,1 +3329,1 @@\n-      deopt->mark(osr, true \/* inc_recompile_count *\/);\n+      deopt->enqueue(osr);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -941,1 +941,1 @@\n-  void mark_dependent_nmethods(KlassDepChange& changes, DeoptimizationContext* deopt);\n+  void enqueue_deoptimization_dependent_nmethods(KlassDepChange& changes, DeoptimizationContext* deopt);\n@@ -951,1 +951,1 @@\n-  void mark_osr_nmethods(const Method* m, DeoptimizationContext* deopt);\n+  void enqueue_deoptimization_osr_nmethods(const Method* m, DeoptimizationContext* deopt);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2037,1 +2037,1 @@\n-    Deoptimization::mark_and_deoptimize_dependents(mh);\n+    Deoptimization::deoptimize_dependents(mh);\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -918,2 +918,2 @@\n-  void mark_osr_nmethods(DeoptimizationContext* deopt) {\n-    method_holder()->mark_osr_nmethods(this, deopt);\n+  void enqueue_deoptimization_osr_nmethods(DeoptimizationContext* deopt) {\n+    method_holder()->enqueue_deoptimization_osr_nmethods(this, deopt);\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4150,1 +4150,1 @@\n-          deopt.mark(nm, true \/* inc_recompile_count *\/);\n+          deopt.enqueue(nm);\n@@ -4157,1 +4157,1 @@\n-    log_debug(redefine, class, nmethod)(\"Marked all nmethods for deopt\");\n+    log_debug(redefine, class, nmethod)(\"Enqueued all nmethods for deopt\");\n@@ -4168,1 +4168,1 @@\n-        deopt.mark(nm, true \/* inc_recompile_count *\/);\n+        deopt.enqueue(nm);\n@@ -4172,1 +4172,1 @@\n-    log_debug(redefine, class, nmethod)(\"Marked %d dependent nmethods for deopt\", deopt.marked());\n+    log_debug(redefine, class, nmethod)(\"Enqueued %d dependent nmethods for deopt\", deopt.enqueued());\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1080,1 +1080,1 @@\n-    deps.mark_dependent_nmethods(changes, &deopt);\n+    deps.enqueue_deoptimization_dependent_nmethods(changes, &deopt);\n@@ -1489,1 +1489,1 @@\n-    deps.remove_and_mark_all_dependents(&deopt);\n+    deps.remove_and_enqueue_deoptimization_all_dependents(&deopt);\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -781,1 +781,1 @@\n-  Deoptimization::mark_and_deoptimize_all();\n+  Deoptimization::deoptimize_all_whitebox();\n@@ -791,1 +791,1 @@\n-    mh->mark_osr_nmethods(&deopt);\n+    mh->enqueue_deoptimization_osr_nmethods(&deopt);\n@@ -793,1 +793,1 @@\n-    deopt.mark(mh->code(), true \/* inc_recompile_count *\/);\n+    deopt.enqueue(mh->code());\n@@ -795,1 +795,1 @@\n-  Deoptimization::mark_dependents(mh(), &deopt);\n+  Deoptimization::enqueue_dependents(mh(), &deopt);\n@@ -797,1 +797,1 @@\n-  return (jint)deopt.marked();\n+  return (jint)deopt.enqueued();\n@@ -809,1 +809,1 @@\n-  return (code->is_alive() && !code->is_marked_for_deoptimization());\n+  return (code->is_alive() && !code->has_been_enqueued_for_deoptimization());\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2112,1 +2112,1 @@\n-              || (_cont.is_preempted() && f.cb()->as_compiled_method()->is_marked_for_deoptimization())) {\n+              || (_cont.is_preempted() && f.cb()->as_compiled_method()->has_been_enqueued_for_deoptimization())) {\n@@ -2360,1 +2360,1 @@\n-    if (fst.current()->cb()->is_compiled() && fst.current()->cb()->as_compiled_method()->is_marked_for_deoptimization()) {\n+    if (fst.current()->cb()->is_compiled() && fst.current()->cb()->as_compiled_method()->has_been_enqueued_for_deoptimization()) {\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -922,1 +922,1 @@\n-class DeoptimizeMarkedClosure : public HandshakeClosure {\n+class DeoptimizeEnqueueMethodFramesClosure : public HandshakeClosure {\n@@ -924,1 +924,1 @@\n-  DeoptimizeMarkedClosure() : HandshakeClosure(\"Deoptimize\") {}\n+  DeoptimizeEnqueueMethodFramesClosure() : HandshakeClosure(\"Deoptimize\") {}\n@@ -927,1 +927,1 @@\n-    jt->deoptimize_marked_methods();\n+    jt->deoptimize_enqueued_method_frames();\n@@ -931,1 +931,1 @@\n-void Deoptimization::mark_and_deoptimize_all() {\n+void Deoptimization::deoptimize_all_whitebox() {\n@@ -940,1 +940,1 @@\n-        deopt.mark(nm, true \/* inc_recompile_count *\/);\n+        deopt.enqueue(nm);\n@@ -955,1 +955,1 @@\n-void Deoptimization::mark_and_deoptimize(KlassDepChange& changes) {\n+void Deoptimization::deoptimize(KlassDepChange& changes) {\n@@ -964,1 +964,1 @@\n-      InstanceKlass::cast(d)->mark_dependent_nmethods(changes, &deopt);\n+      InstanceKlass::cast(d)->enqueue_deoptimization_dependent_nmethods(changes, &deopt);\n@@ -982,1 +982,1 @@\n-void Deoptimization::mark_and_deoptimize_dependents_on(InstanceKlass* dependee) {\n+void Deoptimization::deoptimize_dependents(InstanceKlass* dependee) {\n@@ -990,1 +990,1 @@\n-    mark_and_deoptimize(changes);\n+    deoptimize(changes);\n@@ -994,1 +994,1 @@\n-    mark_and_deoptimize(changes);\n+    deoptimize(changes);\n@@ -998,1 +998,1 @@\n-bool DeoptimizationContext::_context_active = false;\n+volatile bool DeoptimizationContext::_context_active = false;\n@@ -1002,1 +1002,1 @@\n-    _marked(0),\n+    _enqueued(0),\n@@ -1005,2 +1005,2 @@\n-  assert(!_context_active, \"Cannot create a DeoptimizationContext while another one is active\");\n-  _context_active = true;\n+  assert(!Atomic::load(&_context_active), \"Cannot create a DeoptimizationContext while another one is active\");\n+  Atomic::store(&_context_active, true);\n@@ -1010,1 +1010,1 @@\n-  assert(_marked == 0 || _deoptimized, \"If something got marked, you have to call deoptimize\");\n+  assert(_enqueued == 0 || _deoptimized, \"If something got enqueued, you have to call deoptimize\");\n@@ -1013,4 +1013,11 @@\n-void DeoptimizationContext::mark(CompiledMethod* cm, bool inc_recompile_count) {\n-  assert(!_deoptimized, \"Calling mark after deoptimize is invalid\");\n-  if (cm->mark_for_deoptimization(inc_recompile_count)) {\n-    ++_marked;\n+void DeoptimizationContext::enqueue(CompiledMethod* cm) {\n+  assert(!_deoptimized, \"Calling enqueue after deoptimize is invalid\");\n+  if (cm->enqueue_deoptimization(true \/* inc_recompile_counts *\/)) {\n+    ++_enqueued;\n+  }\n+}\n+\n+void DeoptimizationContext::enqueue_no_recompile_count_update(CompiledMethod* cm) {\n+  assert(!_deoptimized, \"Calling enqueue_no_recompile_count_update after deoptimize is invalid\");\n+  if (cm->enqueue_deoptimization(false \/* inc_recompile_counts *\/)) {\n+    ++_enqueued;\n@@ -1021,8 +1028,4 @@\n-  SweeperBlocker sw;\n-  CompiledMethod* nm = CompiledMethod::take_root();\n-  uint links_found = 0;\n-  while (nm != nullptr) {\n-    _deoptimized = true;\n-    ++links_found;\n-    assert(nm->is_marked_for_deoptimization(), \"All nmethods in list must be marked\");\n-    if (!nm->has_been_deoptimized() && nm->can_be_deoptimized()) {\n+  SweeperBlockingCompiledMethodIterator iter(SweeperBlockingCompiledMethodIterator::only_alive_and_not_unloading);\n+  while(iter.next()) {\n+    CompiledMethod* nm = iter.method();\n+    if (nm->has_been_enqueued_for_deoptimization() && !nm->has_been_deoptimized() && nm->can_be_deoptimized()) {\n@@ -1032,1 +1035,0 @@\n-    nm = nm->next_marked();\n@@ -1034,1 +1036,0 @@\n-  assert(links_found ==_marked, \"All marked nmethods must have been linked\");\n@@ -1038,0 +1039,1 @@\n+  assert_locked_or_safepoint(Compile_lock);\n@@ -1039,1 +1041,1 @@\n-  \/\/ deopt_compiled_methods() finishes processing marked nmethods.\n+  \/\/ deopt_compiled_methods() finishes processing enqueued nmethods.\n@@ -1041,2 +1043,2 @@\n-  assert(_context_active, \"deoptimize() must be called on an active context\");\n-  _context_active = false;\n+  assert(Atomic::load(&_context_active), \"deoptimize() must be called on an active context\");\n+  Atomic::store(&_context_active, false);\n@@ -1044,1 +1046,1 @@\n-  if (!_marked) {\n+  if (_enqueued == 0) {\n@@ -1051,1 +1053,1 @@\n-  DeoptimizeMarkedClosure deopt;\n+  DeoptimizeEnqueueMethodFramesClosure deopt;\n@@ -1064,1 +1066,1 @@\n-void Deoptimization::mark_and_deoptimize_dependents(const methodHandle& m_h) {\n+void Deoptimization::deoptimize_dependents(const methodHandle& m_h) {\n@@ -1066,1 +1068,1 @@\n-  Deoptimization::mark_and_deoptimize_dependents(m_h());\n+  Deoptimization::deoptimize_dependents(m_h());\n@@ -1069,1 +1071,1 @@\n-void Deoptimization::mark_dependents(Method* dependee, DeoptimizationContext* deopt) {\n+void Deoptimization::enqueue_dependents(Method* dependee, DeoptimizationContext* deopt) {\n@@ -1075,1 +1077,1 @@\n-      deopt->mark(nm, true \/* inc_recompile_count *\/);\n+      deopt->enqueue(nm);\n@@ -1080,1 +1082,1 @@\n-void Deoptimization::mark_and_deoptimize_dependents(Method* dependee) {\n+void Deoptimization::deoptimize_dependents(Method* dependee) {\n@@ -1083,1 +1085,1 @@\n-  mark_dependents(dependee, &deopt);\n+  enqueue_dependents(dependee, &deopt);\n@@ -1087,1 +1089,1 @@\n-void Deoptimization::mark_and_deoptimize_nmethod(nmethod* nmethod) {\n+void Deoptimization::deoptimize_nmethod(nmethod* nmethod) {\n@@ -1089,1 +1091,1 @@\n-  deopt.mark(nmethod, true \/* inc_recompile_count *\/);\n+  deopt.enqueue(nmethod);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":44,"deletions":42,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-  static void mark_and_deoptimize(KlassDepChange& changes);\n+  static void deoptimize(KlassDepChange& changes);\n@@ -158,6 +158,7 @@\n-  static void mark_and_deoptimize_nmethod(nmethod* nmethod);\n-  static void mark_and_deoptimize_all();\n-  static void mark_and_deoptimize_dependents(const methodHandle& dependee);\n-  static void mark_and_deoptimize_dependents(Method* dependee);\n-  static void mark_and_deoptimize_dependents_on(InstanceKlass* dependee);\n-  static void mark_dependents(Method* dependee, DeoptimizationContext* deopt);\n+  static void deoptimize_nmethod(nmethod* nmethod);\n+  static void deoptimize_dependents(const methodHandle& dependee);\n+  static void deoptimize_dependents(Method* dependee);\n+  static void deoptimize_dependents(InstanceKlass* dependee);\n+  static void enqueue_dependents(Method* dependee, DeoptimizationContext* deopt);\n+  \/\/ Only called from whitebox API.\n+  static void deoptimize_all_whitebox();\n@@ -490,1 +491,1 @@\n-  uint _marked;\n+  uint _enqueued;\n@@ -492,1 +493,1 @@\n-  static bool _context_active;\n+  static volatile bool _context_active;\n@@ -501,1 +502,2 @@\n-  void mark(CompiledMethod* cm, bool inc_recompile_count);\n+  void enqueue(CompiledMethod* cm);\n+  void enqueue_no_recompile_count_update(CompiledMethod* cm);\n@@ -504,1 +506,1 @@\n-  uint marked() { return _marked; }\n+  uint enqueued() { return _enqueued; }\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -325,1 +325,1 @@\n-    tty->print(\"checking (%s) \", nm->is_marked_for_deoptimization() ? \"true\" : \"false\");\n+    tty->print(\"checking (%s) \", nm->has_been_enqueued_for_deoptimization() ? \"true\" : \"false\");\n@@ -330,1 +330,1 @@\n-  if( !nm->is_marked_for_deoptimization() )\n+  if( !nm->has_been_enqueued_for_deoptimization() )\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1321,1 +1321,1 @@\n-void JavaThread::deoptimize_marked_methods() {\n+void JavaThread::deoptimize_enqueued_method_frames() {\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -962,1 +962,1 @@\n-  void deoptimize_marked_methods();\n+  void deoptimize_enqueued_method_frames();\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,3 +144,0 @@\n-  \/\/ Deoptimizes all frames tied to marked nmethods\n-  static void deoptimized_wrt_marked_nmethods();\n-\n","filename":"src\/hotspot\/share\/runtime\/threads.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}