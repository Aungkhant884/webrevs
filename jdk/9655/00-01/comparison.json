{"files":[{"patch":"@@ -122,1 +122,1 @@\n-void CompiledMethod::mark_for_deoptimization(bool inc_recompile_counts) {\n+bool CompiledMethod::mark_for_deoptimization(bool inc_recompile_counts) {\n@@ -131,0 +131,1 @@\n+      return true;\n@@ -132,1 +133,1 @@\n-      _mark_link = mark_link(nullptr, new_mark);\n+      _mark_link = mark_link(extract_compiled_method(_mark_link), new_mark);\n@@ -135,0 +136,1 @@\n+  return false;\n","filename":"src\/hotspot\/share\/code\/compiledMethod.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-  friend class Deoptimization;\n+  friend class DeoptimizationContext;\n@@ -265,1 +265,1 @@\n-  void  mark_for_deoptimization(bool inc_recompile_counts = true);\n+  bool  mark_for_deoptimization(bool inc_recompile_counts = true);\n","filename":"src\/hotspot\/share\/code\/compiledMethod.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -687,1 +687,1 @@\n-  virtual void mark_for_deoptimization(nmethod* nm, Deoptimization::MarkFn mark_fn) = 0;\n+  virtual void mark_for_deoptimization(nmethod* nm, DeoptimizationContext* deopt) = 0;\n@@ -785,2 +785,2 @@\n-  virtual void mark_for_deoptimization(nmethod* nm, Deoptimization::MarkFn mark_fn) {\n-    mark_fn(nm, true \/* inc_recompile_counts *\/);\n+  virtual void mark_for_deoptimization(nmethod* nm, DeoptimizationContext* deopt) {\n+    deopt->mark(nm, true \/* inc_recompile_counts *\/);\n@@ -827,2 +827,2 @@\n-  virtual void mark_for_deoptimization(nmethod* nm, Deoptimization::MarkFn mark_fn) {\n-    mark_fn(nm, false \/* inc_recompile_counts *\/);\n+  virtual void mark_for_deoptimization(nmethod* nm, DeoptimizationContext* deopt) {\n+    deopt->mark(nm, false \/* inc_recompile_counts *\/);\n","filename":"src\/hotspot\/share\/code\/dependencies.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -68,2 +68,1 @@\n-int DependencyContext::mark_dependent_nmethods(DepChange& changes, Deoptimization::MarkFn mark_fn) {\n-  int found = 0;\n+void DependencyContext::mark_dependent_nmethods(DepChange& changes, DeoptimizationContext* deopt) {\n@@ -82,2 +81,1 @@\n-      changes.mark_for_deoptimization(nm, mark_fn);\n-      found++;\n+      changes.mark_for_deoptimization(nm, deopt);\n@@ -86,1 +84,0 @@\n-  return found;\n@@ -230,1 +227,1 @@\n-int DependencyContext::remove_and_mark_all_dependents(Deoptimization::MarkFn mark_fn) {\n+void DependencyContext::remove_and_mark_all_dependents(DeoptimizationContext* deopt) {\n@@ -233,1 +230,0 @@\n-  int marked = 0;\n@@ -238,2 +234,1 @@\n-      mark_fn(nm, true \/* inc_recompile_counts *\/);\n-      ++marked;\n+      deopt->mark(nm, true \/* inc_recompile_counts *\/);\n@@ -247,1 +242,0 @@\n-  return marked;\n","filename":"src\/hotspot\/share\/code\/dependencyContext.cpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-  int  mark_dependent_nmethods(DepChange& changes, Deoptimization::MarkFn mark_fn);\n+  void mark_dependent_nmethods(DepChange& changes, DeoptimizationContext* deopt);\n@@ -125,1 +125,1 @@\n-  int  remove_and_mark_all_dependents(Deoptimization::MarkFn mark_fn);\n+  void remove_and_mark_all_dependents(DeoptimizationContext* deopt);\n","filename":"src\/hotspot\/share\/code\/dependencyContext.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2337,2 +2337,2 @@\n-int InstanceKlass::mark_dependent_nmethods(KlassDepChange& changes, Deoptimization::MarkFn mark_fn) {\n-  return dependencies().mark_dependent_nmethods(changes, mark_fn);\n+void InstanceKlass::mark_dependent_nmethods(KlassDepChange& changes, DeoptimizationContext* deopt) {\n+  dependencies().mark_dependent_nmethods(changes, deopt);\n@@ -3322,1 +3322,1 @@\n-int InstanceKlass::mark_osr_nmethods(const Method* m, Deoptimization::MarkFn mark_fn) {\n+void InstanceKlass::mark_osr_nmethods(const Method* m, DeoptimizationContext* deopt) {\n@@ -3326,1 +3326,0 @@\n-  int found = 0;\n@@ -3330,2 +3329,1 @@\n-      mark_fn((CompiledMethod*)osr);\n-      found++;\n+      deopt->mark(osr, true \/* inc_recompile_count *\/);\n@@ -3335,1 +3333,0 @@\n-  return found;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -941,1 +941,1 @@\n-  int  mark_dependent_nmethods(KlassDepChange& changes, Deoptimization::MarkFn mark_fn);\n+  void mark_dependent_nmethods(KlassDepChange& changes, DeoptimizationContext* deopt);\n@@ -951,1 +951,1 @@\n-  int mark_osr_nmethods(const Method* m, Deoptimization::MarkFn mark_fn);\n+  void mark_osr_nmethods(const Method* m, DeoptimizationContext* deopt);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -918,2 +918,2 @@\n-  int mark_osr_nmethods(Deoptimization::MarkFn mark_fn) {\n-    return method_holder()->mark_osr_nmethods(this, mark_fn);\n+  void mark_osr_nmethods(DeoptimizationContext* deopt) {\n+    method_holder()->mark_osr_nmethods(this, deopt);\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4141,16 +4141,10 @@\n-  struct FlushDependentCodeClosure : DeoptimizationMarkerClosure {\n-    void marker_do(Deoptimization::MarkFn mark_fn) override {\n-      const bool first_call = !JvmtiExport::all_dependencies_are_recorded();\n-      assert(SafepointSynchronize::is_at_safepoint(), \"Can only do this at a safepoint!\");\n-      CompiledMethodIterator iter(CompiledMethodIterator::only_alive);\n-      if (first_call) {\n-        while(iter.next()) {\n-          CompiledMethod* nm = iter.method();\n-          if (!nm->method()->is_method_handle_intrinsic()) {\n-            if (nm->can_be_deoptimized()) {\n-              mark_fn(nm);\n-            }\n-            if (nm->has_evol_metadata()) {\n-              add_to_old_table(nm);\n-            }\n-          }\n+  DeoptimizationContext deopt;\n+  const bool first_call = !JvmtiExport::all_dependencies_are_recorded();\n+  assert(SafepointSynchronize::is_at_safepoint(), \"Can only do this at a safepoint!\");\n+  CompiledMethodIterator iter(CompiledMethodIterator::only_alive);\n+  if (first_call) {\n+    while(iter.next()) {\n+      CompiledMethod* nm = iter.method();\n+      if (!nm->method()->is_method_handle_intrinsic()) {\n+        if (nm->can_be_deoptimized()) {\n+          deopt.mark(nm, true \/* inc_recompile_count *\/);\n@@ -4158,16 +4152,2 @@\n-        log_debug(redefine, class, nmethod)(\"Marked all nmethods for deopt\");\n-      } else {\n-        \/\/ Each redefinition creates a new set of nmethods that have references to \"old\" Methods\n-        \/\/ So delete old method table and create a new one.\n-        reset_old_method_table();\n-        int number_marked = 0;\n-        while(iter.next()) {\n-          CompiledMethod* nm = iter.method();\n-          \/\/ Walk all alive nmethods to check for old Methods.\n-          \/\/ This includes methods whose inline caches point to old methods, so\n-          \/\/ inline cache clearing is unnecessary.\n-          if (nm->has_evol_metadata()) {\n-            mark_fn(nm);\n-            add_to_old_table(nm);\n-            number_marked++;\n-          }\n+        if (nm->has_evol_metadata()) {\n+          add_to_old_table(nm);\n@@ -4175,1 +4155,0 @@\n-        log_debug(redefine, class, nmethod)(\"Marked %d dependent nmethods for deopt\", number_marked);\n@@ -4178,3 +4157,18 @@\n-  };\n-  FlushDependentCodeClosure closure;\n-  Deoptimization::mark_and_deoptimize(closure);\n+    log_debug(redefine, class, nmethod)(\"Marked all nmethods for deopt\");\n+  } else {\n+    \/\/ Each redefinition creates a new set of nmethods that have references to \"old\" Methods\n+    \/\/ So delete old method table and create a new one.\n+    reset_old_method_table();\n+    while(iter.next()) {\n+      CompiledMethod* nm = iter.method();\n+      \/\/ Walk all alive nmethods to check for old Methods.\n+      \/\/ This includes methods whose inline caches point to old methods, so\n+      \/\/ inline cache clearing is unnecessary.\n+      if (nm->has_evol_metadata()) {\n+        deopt.mark(nm, true \/* inc_recompile_count *\/);\n+        add_to_old_table(nm);\n+      }\n+    }\n+    log_debug(redefine, class, nmethod)(\"Marked %d dependent nmethods for deopt\", deopt.marked());\n+  }\n+  deopt.deoptimize();\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":30,"deletions":36,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -1074,0 +1074,1 @@\n+  DeoptimizationContext deopt;\n@@ -1075,16 +1076,7 @@\n-  struct FlushDependentNmethodsClosure : DeoptimizationMarkerClosure {\n-    Handle& _call_site;\n-    CallSiteDepChange& _changes;\n-    FlushDependentNmethodsClosure(Handle& call_site, CallSiteDepChange& changes)\n-      : _call_site(call_site), _changes(changes) {}\n-    void marker_do(Deoptimization::MarkFn mark_fn) override {\n-      NoSafepointVerifier nsv;\n-      MutexLocker mu2(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-\n-      oop context = java_lang_invoke_CallSite::context_no_keepalive(_call_site());\n-      DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context);\n-      deps.mark_dependent_nmethods(_changes, mark_fn);\n-    }\n-  };\n-  FlushDependentNmethodsClosure closure(call_site, changes);\n-  Deoptimization::mark_and_deoptimize(closure);\n+  {\n+    MutexLocker mu2(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    oop context = java_lang_invoke_CallSite::context_no_keepalive(call_site());\n+    DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context);\n+    deps.mark_dependent_nmethods(changes, &deopt);\n+  }\n+  deopt.deoptimize();\n@@ -1491,0 +1483,3 @@\n+  \/\/ Walk all nmethods depending on this call site.\n+  MutexLocker mu1(thread, Compile_lock);\n+  DeoptimizationContext deopt;\n@@ -1492,16 +1487,3 @@\n-    \/\/ Walk all nmethods depending on this call site.\n-    MutexLocker mu1(thread, Compile_lock);\n-    struct ClearCallSiteContextDependenciesClosure : DeoptimizationMarkerClosure {\n-      Thread* _thread;\n-      Handle& _context;\n-      ClearCallSiteContextDependenciesClosure(Thread* thread, Handle& context)\n-        : _thread(thread), _context(context) {}\n-      void marker_do(Deoptimization::MarkFn mark_fn) override {\n-        NoSafepointVerifier nsv;\n-        MutexLocker mu2(_thread, CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-        DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(_context());\n-        deps.remove_and_mark_all_dependents(mark_fn);\n-      }\n-    };\n-    ClearCallSiteContextDependenciesClosure closure(THREAD,context);\n-    Deoptimization::mark_and_deoptimize(closure);\n+    MutexLocker mu2(thread, CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context());\n+    deps.remove_and_mark_all_dependents(&deopt);\n@@ -1509,0 +1491,2 @@\n+\n+  deopt.deoptimize();\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":16,"deletions":32,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -787,2 +787,1 @@\n-  int result = 0;\n-  CHECK_JNI_EXCEPTION_(env, result);\n+  CHECK_JNI_EXCEPTION_(env, 0);\n@@ -790,0 +789,1 @@\n+  DeoptimizationContext deopt;\n@@ -791,19 +791,8 @@\n-  struct DeoptimizeMethodClosure : DeoptimizationMarkerClosure {\n-    jboolean _is_osr;\n-    methodHandle& _mh;\n-    int& _result;\n-    DeoptimizeMethodClosure(jboolean is_osr, methodHandle& mh, int& result)\n-      : _is_osr(is_osr), _mh(mh), _result(result) {}\n-    void marker_do(Deoptimization::MarkFn mark_fn) override {\n-      if (_is_osr) {\n-        _result = _mh->mark_osr_nmethods(mark_fn);\n-      } else if (_mh->code() != NULL) {\n-        mark_fn(_mh->code());\n-        ++_result;\n-      }\n-      _result += Deoptimization::mark_dependents(_mh(), mark_fn);\n-    }\n-  };\n-  DeoptimizeMethodClosure closure(is_osr, mh, result);\n-  Deoptimization::mark_and_deoptimize(closure);\n-  return result;\n+  if (is_osr) {\n+    mh->mark_osr_nmethods(&deopt);\n+  } else if (mh->code() != NULL) {\n+    deopt.mark(mh->code(), true \/* inc_recompile_count *\/);\n+  }\n+  Deoptimization::mark_dependents(mh(), &deopt);\n+  deopt.deoptimize();\n+  return (jint)deopt.marked();\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":10,"deletions":21,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -101,2 +101,0 @@\n-bool DeoptimizationMarker::_is_active = false;\n-\n@@ -924,26 +922,0 @@\n-bool Deoptimization::deoptimize_all_marked() {\n-  assert_locked_or_safepoint(Compile_lock);\n-  CompiledMethod* nm = CompiledMethod::take_root();\n-  bool anything_deoptimized = false;\n-  if (nm != nullptr) {\n-    SweeperBlocker sw;\n-    anything_deoptimized = true;\n-    do {\n-      assert(nm->is_marked_for_deoptimization(), \"All methods in list must be marked\");\n-      if (!nm->has_been_deoptimized() && nm->can_be_deoptimized()) {\n-        nm->make_not_entrant();\n-        make_nmethod_deoptimized(nm);\n-      }\n-      nm = nm->next_marked();\n-    } while(nm != nullptr);\n-  }\n-  return anything_deoptimized;\n-}\n-\n-void Deoptimization::make_nmethod_deoptimized(CompiledMethod* nm) {\n-  assert_locked_or_safepoint(Compile_lock);\n-  if (nm->is_marked_for_deoptimization() && nm->can_be_deoptimized()) {\n-    nm->make_deoptimized();\n-  }\n-}\n-\n@@ -952,9 +924,8 @@\n-  struct MarkAndDeoptimizeAllClosure : DeoptimizationMarkerClosure {\n-    void marker_do(Deoptimization::MarkFn mark_fn) override {\n-      MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-      CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);\n-      while(iter.next()) {\n-        CompiledMethod* nm = iter.method();\n-        if (!nm->is_native_method()) {\n-          mark_fn(nm);\n-        }\n+  DeoptimizationContext deopt;\n+  {\n+    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);\n+    while(iter.next()) {\n+      CompiledMethod* nm = iter.method();\n+      if (!nm->is_native_method()) {\n+        deopt.mark(nm, true \/* inc_recompile_count *\/);\n@@ -963,3 +934,2 @@\n-  };\n-  MarkAndDeoptimizeAllClosure closure;\n-  mark_and_deoptimize(closure);\n+  }\n+  deopt.deoptimize();\n@@ -977,12 +947,10 @@\n-  struct MarkAndDeoptimizeClosure: DeoptimizationMarkerClosure {\n-    KlassDepChange& _changes;\n-    MarkAndDeoptimizeClosure(KlassDepChange& changes) : _changes(changes) {}\n-    void marker_do(Deoptimization::MarkFn mark_fn) override {\n-      MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-      \/\/ nmethod::check_all_dependencies works only correctly, if no safepoint\n-      \/\/ can happen\n-      NoSafepointVerifier nsv;\n-      for (DepChange::ContextStream str(_changes, nsv); str.next(); ) {\n-        Klass* d = str.klass();\n-        InstanceKlass::cast(d)->mark_dependent_nmethods(_changes, mark_fn);\n-      }\n+  DeoptimizationContext deopt;\n+  {\n+    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    \/\/ nmethod::check_all_dependencies works only correctly, if no safepoint\n+    \/\/ can happen\n+    NoSafepointVerifier nsv;\n+    for (DepChange::ContextStream str(changes, nsv); str.next(); ) {\n+      Klass* d = str.klass();\n+      InstanceKlass::cast(d)->mark_dependent_nmethods(changes, &deopt);\n+    }\n@@ -991,8 +959,6 @@\n-      if (VerifyDependencies) {\n-        \/\/ Object pointers are used as unique identifiers for dependency arguments. This\n-        \/\/ is only possible if no safepoint, i.e., GC occurs during the verification code.\n-        dependentCheckTime.start();\n-        nmethod::check_all_dependencies(_changes);\n-        dependentCheckTime.stop();\n-      }\n-#endif\n+    if (VerifyDependencies) {\n+      \/\/ Object pointers are used as unique identifiers for dependency arguments. This\n+      \/\/ is only possible if no safepoint, i.e., GC occurs during the verification code.\n+      dependentCheckTime.start();\n+      nmethod::check_all_dependencies(changes);\n+      dependentCheckTime.stop();\n@@ -1000,3 +966,3 @@\n-  };\n-  MarkAndDeoptimizeClosure closure(changes);\n-  Deoptimization::mark_and_deoptimize(closure);\n+#endif\n+  }\n+  deopt.deoptimize();\n@@ -1023,2 +989,9 @@\n-void Deoptimization::MarkFn::operator()(CompiledMethod* cm, bool inc_recompile_counts) {\n-  cm->mark_for_deoptimization(inc_recompile_counts);\n+bool DeoptimizationContext::_context_active = false;\n+\n+DeoptimizationContext::DeoptimizationContext()\n+  : _nsv(),\n+    _marked(0),\n+    _deoptimized(false) {\n+  assert_locked_or_safepoint(Compile_lock);\n+  assert(!_context_active, \"Cannot create a DeoptimizationContext while another one is active\");\n+  _context_active = true;\n@@ -1027,8 +1000,8 @@\n-void Deoptimization::mark_and_deoptimize(DeoptimizationMarkerClosure& marker_closure) {\n-  DeoptimizationMarker dm;\n-  bool anything_deoptimized = false;\n-  {\n-    NoSafepointVerifier nsv;\n-    assert_locked_or_safepoint(Compile_lock);\n-    marker_closure.marker_do(MarkFn());\n-    anything_deoptimized = deoptimize_all_marked();\n+DeoptimizationContext::~DeoptimizationContext() {\n+  assert(_marked == 0 || _deoptimized, \"If something got marked, you have to call deoptimize\");\n+}\n+\n+void DeoptimizationContext::mark(CompiledMethod* cm, bool inc_recompile_count) {\n+  assert(!_deoptimized, \"Calling mark after deoptimize is invalid\");\n+  if (cm->mark_for_deoptimization(inc_recompile_count)) {\n+    ++_marked;\n@@ -1036,2 +1009,28 @@\n-  if (anything_deoptimized) {\n-    run_deoptimize_closure();\n+}\n+\n+void DeoptimizationContext::deopt_compiled_methods() {\n+  SweeperBlocker sw;\n+  CompiledMethod* nm = CompiledMethod::take_root();\n+  uint links_found = 0;\n+  while (nm != nullptr) {\n+    _deoptimized = true;\n+    ++links_found;\n+    assert(nm->is_marked_for_deoptimization(), \"All nmethods in list must be marked\");\n+    if (!nm->has_been_deoptimized() && nm->can_be_deoptimized()) {\n+      nm->make_not_entrant();\n+      nm->make_deoptimized();\n+    }\n+    nm = nm->next_marked();\n+  }\n+  assert(links_found ==_marked, \"All marked nmethods must have been linked\");\n+}\n+\n+void DeoptimizationContext::deopt_frames() {\n+  \/\/ DeoptimizationContext is considered active from its creation until\n+  \/\/ deopt_compiled_methods() finishes processing marked nmethods.\n+  \/\/ deopt_compiled_methods() occurs as the first step of deoptimize()\n+  assert(_context_active, \"deoptimize() must be called on an active context\");\n+  _context_active = false;\n+\n+  if (!_marked) {\n+    return; \/\/ Nothing to do\n@@ -1039,0 +1038,15 @@\n+\n+  \/\/ DeoptimizationContext sets up a NSV to detect bugs in the client of this API.\n+  \/\/ But we must allow safepoints when performing thread-local handshakes\n+  PauseNoSafepointVerifier pnsv(&_nsv);\n+  DeoptimizeMarkedClosure deopt;\n+  if (SafepointSynchronize::is_at_safepoint()) {\n+    Threads::java_threads_do(&deopt);\n+  } else {\n+    Handshake::execute(&deopt);\n+  }\n+}\n+\n+void DeoptimizationContext::deoptimize() {\n+  deopt_compiled_methods();\n+  deopt_frames();\n@@ -1046,1 +1060,1 @@\n-int Deoptimization::mark_dependents(Method* dependee, Deoptimization::MarkFn mark_fn) {\n+void Deoptimization::mark_dependents(Method* dependee, DeoptimizationContext* deopt) {\n@@ -1048,1 +1062,0 @@\n-  int number_marked = 0;\n@@ -1053,2 +1066,1 @@\n-      mark_fn(nm);\n-      ++number_marked;\n+      deopt->mark(nm, true \/* inc_recompile_count *\/);\n@@ -1057,1 +1069,0 @@\n-  return number_marked;\n@@ -1062,9 +1073,3 @@\n-  struct MarkAandDeoptimizeDependentsClosure : DeoptimizationMarkerClosure {\n-    Method* _dependee;\n-    MarkAandDeoptimizeDependentsClosure(Method* dependee) : _dependee(dependee) {}\n-    void marker_do(Deoptimization::MarkFn mark_fn) override {\n-      mark_dependents(_dependee, mark_fn);\n-    }\n-  };\n-  MarkAandDeoptimizeDependentsClosure closure(dependee);\n-  mark_and_deoptimize(closure);\n+  DeoptimizationContext deopt;\n+  mark_dependents(dependee, &deopt);\n+  deopt.deoptimize();\n@@ -1074,21 +1079,3 @@\n-  ResourceMark rm;\n-  DeoptimizationMarker dm;\n-  {\n-    assert_locked_or_safepoint(Compile_lock);\n-    assert(nmethod != nullptr, \"nmethod connot be null\");\n-\n-    nmethod->mark_for_deoptimization();\n-    nmethod->make_not_entrant();\n-    Deoptimization::make_nmethod_deoptimized(nmethod);\n-  }\n-\n-  run_deoptimize_closure();\n-}\n-\n-void Deoptimization::run_deoptimize_closure() {\n-  DeoptimizeMarkedClosure deopt;\n-  if (SafepointSynchronize::is_at_safepoint()) {\n-    Threads::java_threads_do(&deopt);\n-  } else {\n-    Handshake::execute(&deopt);\n-  }\n+  DeoptimizationContext deopt;\n+  deopt.mark(nmethod, true \/* inc_recompile_count *\/);\n+  deopt.deoptimize();\n@@ -1800,1 +1787,0 @@\n-  DeoptimizationMarker dm;\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":97,"deletions":111,"binary":false,"changes":208,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/safepointVerifiers.hpp\"\n@@ -32,0 +33,1 @@\n+class DeoptimizationContext;\n@@ -40,1 +42,0 @@\n-class DeoptimizationMarkerClosure;\n@@ -155,3 +156,0 @@\n-  static bool deoptimize_all_marked();\n-  static void make_nmethod_deoptimized(CompiledMethod* nm);\n-  static void run_deoptimize_closure();\n@@ -160,1 +158,0 @@\n-  static void mark_and_deoptimize(DeoptimizationMarkerClosure& marker_closure);\n@@ -166,7 +163,1 @@\n-  class MarkFn : StackObj {\n-    friend void Deoptimization::mark_and_deoptimize(DeoptimizationMarkerClosure&);\n-    MarkFn() {};\n-  public:\n-    void operator()(CompiledMethod* cm, bool inc_recompile_counts = true);\n-  };\n-  static int mark_dependents(Method* dependee, Deoptimization::MarkFn mark_fn);\n+  static void mark_dependents(Method* dependee, DeoptimizationContext* deopt);\n@@ -497,0 +488,5 @@\n+class DeoptimizationContext : StackObj {\n+  NoSafepointVerifier _nsv;\n+  uint _marked;\n+  bool _deoptimized;\n+  static bool _context_active;\n@@ -498,7 +494,2 @@\n-class DeoptimizationMarker : StackObj {  \/\/ for profiling\n-  static bool _is_active;\n-public:\n-  DeoptimizationMarker()  { _is_active = true; }\n-  ~DeoptimizationMarker() { _is_active = false; }\n-  static bool is_active() { return _is_active; }\n-};\n+  void deopt_compiled_methods();\n+  void deopt_frames();\n@@ -506,1 +497,0 @@\n-class DeoptimizationMarkerClosure : StackObj {\n@@ -508,1 +498,7 @@\n-  virtual void marker_do(Deoptimization::MarkFn mark_fn) = 0;\n+  DeoptimizationContext();\n+  ~DeoptimizationContext();\n+\n+  void mark(CompiledMethod* cm, bool inc_recompile_count);\n+  void deoptimize();\n+\n+  uint marked() { return _marked; }\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":17,"deletions":21,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -120,1 +120,0 @@\n-  DeoptimizationMarker dm;\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}