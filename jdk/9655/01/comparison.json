{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,3 @@\n+#if INCLUDE_JVMTI\n+#include \"prims\/jvmtiRedefineClasses.hpp\"\n+#endif\n@@ -70,1 +73,3 @@\n-      CodeCache::old_nmethods_do(&md_on_stack);\n+#if INCLUDE_JVMTI\n+      VM_RedefineClasses::old_nmethods_do(&md_on_stack);\n+#endif\n","filename":"src\/hotspot\/share\/classfile\/metadataOnStackMark.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -1583,1 +1584,1 @@\n-    CodeCache::flush_dependents_on(k);\n+    Deoptimization::mark_and_deoptimize_dependents_on(k);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"code\/dependencies.hpp\"\n@@ -1070,32 +1069,0 @@\n-\/\/ Keeps track of time spent for checking dependencies\n-NOT_PRODUCT(static elapsedTimer dependentCheckTime;)\n-\n-int CodeCache::mark_for_deoptimization(KlassDepChange& changes) {\n-  MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-  int number_of_marked_CodeBlobs = 0;\n-\n-  \/\/ search the hierarchy looking for nmethods which are affected by the loading of this class\n-\n-  \/\/ then search the interfaces this class implements looking for nmethods\n-  \/\/ which might be dependent of the fact that an interface only had one\n-  \/\/ implementor.\n-  \/\/ nmethod::check_all_dependencies works only correctly, if no safepoint\n-  \/\/ can happen\n-  NoSafepointVerifier nsv;\n-  for (DepChange::ContextStream str(changes, nsv); str.next(); ) {\n-    Klass* d = str.klass();\n-    number_of_marked_CodeBlobs += InstanceKlass::cast(d)->mark_dependent_nmethods(changes);\n-  }\n-\n-#ifndef PRODUCT\n-  if (VerifyDependencies) {\n-    \/\/ Object pointers are used as unique identifiers for dependency arguments. This\n-    \/\/ is only possible if no safepoint, i.e., GC occurs during the verification code.\n-    dependentCheckTime.start();\n-    nmethod::check_all_dependencies(changes);\n-    dependentCheckTime.stop();\n-  }\n-#endif\n-\n-  return number_of_marked_CodeBlobs;\n-}\n@@ -1109,183 +1076,0 @@\n-#if INCLUDE_JVMTI\n-\/\/ RedefineClasses support for saving nmethods that are dependent on \"old\" methods.\n-\/\/ We don't really expect this table to grow very large.  If it does, it can become a hashtable.\n-static GrowableArray<CompiledMethod*>* old_compiled_method_table = NULL;\n-\n-static void add_to_old_table(CompiledMethod* c) {\n-  if (old_compiled_method_table == NULL) {\n-    old_compiled_method_table = new (ResourceObj::C_HEAP, mtCode) GrowableArray<CompiledMethod*>(100, mtCode);\n-  }\n-  old_compiled_method_table->push(c);\n-}\n-\n-static void reset_old_method_table() {\n-  if (old_compiled_method_table != NULL) {\n-    delete old_compiled_method_table;\n-    old_compiled_method_table = NULL;\n-  }\n-}\n-\n-\/\/ Remove this method when zombied or unloaded.\n-void CodeCache::unregister_old_nmethod(CompiledMethod* c) {\n-  assert_lock_strong(CodeCache_lock);\n-  if (old_compiled_method_table != NULL) {\n-    int index = old_compiled_method_table->find(c);\n-    if (index != -1) {\n-      old_compiled_method_table->delete_at(index);\n-    }\n-  }\n-}\n-\n-void CodeCache::old_nmethods_do(MetadataClosure* f) {\n-  \/\/ Walk old method table and mark those on stack.\n-  int length = 0;\n-  if (old_compiled_method_table != NULL) {\n-    length = old_compiled_method_table->length();\n-    for (int i = 0; i < length; i++) {\n-      CompiledMethod* cm = old_compiled_method_table->at(i);\n-      \/\/ Only walk alive nmethods, the dead ones will get removed by the sweeper or GC.\n-      if (cm->is_alive() && !cm->is_unloading()) {\n-        old_compiled_method_table->at(i)->metadata_do(f);\n-      }\n-    }\n-  }\n-  log_debug(redefine, class, nmethod)(\"Walked %d nmethods for mark_on_stack\", length);\n-}\n-\n-\/\/ Walk compiled methods and mark dependent methods for deoptimization.\n-int CodeCache::mark_dependents_for_evol_deoptimization() {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"Can only do this at a safepoint!\");\n-  \/\/ Each redefinition creates a new set of nmethods that have references to \"old\" Methods\n-  \/\/ So delete old method table and create a new one.\n-  reset_old_method_table();\n-\n-  int number_of_marked_CodeBlobs = 0;\n-  CompiledMethodIterator iter(CompiledMethodIterator::only_alive);\n-  while(iter.next()) {\n-    CompiledMethod* nm = iter.method();\n-    \/\/ Walk all alive nmethods to check for old Methods.\n-    \/\/ This includes methods whose inline caches point to old methods, so\n-    \/\/ inline cache clearing is unnecessary.\n-    if (nm->has_evol_metadata()) {\n-      nm->mark_for_deoptimization();\n-      add_to_old_table(nm);\n-      number_of_marked_CodeBlobs++;\n-    }\n-  }\n-\n-  \/\/ return total count of nmethods marked for deoptimization, if zero the caller\n-  \/\/ can skip deoptimization\n-  return number_of_marked_CodeBlobs;\n-}\n-\n-void CodeCache::mark_all_nmethods_for_evol_deoptimization() {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"Can only do this at a safepoint!\");\n-  CompiledMethodIterator iter(CompiledMethodIterator::only_alive);\n-  while(iter.next()) {\n-    CompiledMethod* nm = iter.method();\n-    if (!nm->method()->is_method_handle_intrinsic()) {\n-      if (nm->can_be_deoptimized()) {\n-        nm->mark_for_deoptimization();\n-      }\n-      if (nm->has_evol_metadata()) {\n-        add_to_old_table(nm);\n-      }\n-    }\n-  }\n-}\n-\n-\/\/ Flushes compiled methods dependent on redefined classes, that have already been\n-\/\/ marked for deoptimization.\n-void CodeCache::flush_evol_dependents() {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"Can only do this at a safepoint!\");\n-\n-  \/\/ CodeCache can only be updated by a thread_in_VM and they will all be\n-  \/\/ stopped during the safepoint so CodeCache will be safe to update without\n-  \/\/ holding the CodeCache_lock.\n-\n-  \/\/ At least one nmethod has been marked for deoptimization\n-\n-  Deoptimization::deoptimize_all_marked();\n-}\n-#endif \/\/ INCLUDE_JVMTI\n-\n-\/\/ Mark methods for deopt (if safe or possible).\n-void CodeCache::mark_all_nmethods_for_deoptimization() {\n-  MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-  CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);\n-  while(iter.next()) {\n-    CompiledMethod* nm = iter.method();\n-    if (!nm->is_native_method()) {\n-      nm->mark_for_deoptimization();\n-    }\n-  }\n-}\n-\n-int CodeCache::mark_for_deoptimization(Method* dependee) {\n-  MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-  int number_of_marked_CodeBlobs = 0;\n-\n-  CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);\n-  while(iter.next()) {\n-    CompiledMethod* nm = iter.method();\n-    if (nm->is_dependent_on_method(dependee)) {\n-      ResourceMark rm;\n-      nm->mark_for_deoptimization();\n-      number_of_marked_CodeBlobs++;\n-    }\n-  }\n-\n-  return number_of_marked_CodeBlobs;\n-}\n-\n-void CodeCache::make_marked_nmethods_deoptimized() {\n-  SweeperBlockingCompiledMethodIterator iter(SweeperBlockingCompiledMethodIterator::only_alive_and_not_unloading);\n-  while(iter.next()) {\n-    CompiledMethod* nm = iter.method();\n-    if (nm->is_marked_for_deoptimization() && !nm->has_been_deoptimized() && nm->can_be_deoptimized()) {\n-      nm->make_not_entrant();\n-      make_nmethod_deoptimized(nm);\n-    }\n-  }\n-}\n-\n-void CodeCache::make_nmethod_deoptimized(CompiledMethod* nm) {\n-  if (nm->is_marked_for_deoptimization() && nm->can_be_deoptimized()) {\n-    nm->make_deoptimized();\n-  }\n-}\n-\n-\/\/ Flushes compiled methods dependent on dependee.\n-void CodeCache::flush_dependents_on(InstanceKlass* dependee) {\n-  assert_lock_strong(Compile_lock);\n-\n-  if (number_of_nmethods_with_dependencies() == 0) return;\n-\n-  int marked = 0;\n-  if (dependee->is_linked()) {\n-    \/\/ Class initialization state change.\n-    KlassInitDepChange changes(dependee);\n-    marked = mark_for_deoptimization(changes);\n-  } else {\n-    \/\/ New class is loaded.\n-    NewKlassDepChange changes(dependee);\n-    marked = mark_for_deoptimization(changes);\n-  }\n-\n-  if (marked > 0) {\n-    \/\/ At least one nmethod has been marked for deoptimization\n-    Deoptimization::deoptimize_all_marked();\n-  }\n-}\n-\n-\/\/ Flushes compiled methods dependent on dependee\n-void CodeCache::flush_dependents_on_method(const methodHandle& m_h) {\n-  \/\/ --- Compile_lock is not held. However we are at a safepoint.\n-  assert_locked_or_safepoint(Compile_lock);\n-\n-  \/\/ Compute the dependent nmethods\n-  if (mark_for_deoptimization(m_h()) > 0) {\n-    Deoptimization::deoptimize_all_marked();\n-  }\n-}\n-\n@@ -1552,1 +1336,1 @@\n-  tty->print_cr(\"nmethod dependency checking time %fs\", dependentCheckTime.seconds());\n+  Deoptimization::print_dependency_checking_time(tty);\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":1,"deletions":217,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -76,1 +76,0 @@\n-class KlassDepChange;\n@@ -124,0 +123,1 @@\n+    friend class SweeperBlocker;\n@@ -285,4 +285,0 @@\n-  \/\/ Deoptimization\n- private:\n-  static int  mark_for_deoptimization(KlassDepChange& changes);\n-\n@@ -290,19 +286,0 @@\n-  static void mark_all_nmethods_for_deoptimization();\n-  static int  mark_for_deoptimization(Method* dependee);\n-  static void make_marked_nmethods_deoptimized();\n-  static void make_nmethod_deoptimized(CompiledMethod* nm);\n-\n-  \/\/ Flushing and deoptimization\n-  static void flush_dependents_on(InstanceKlass* dependee);\n-\n-  \/\/ RedefineClasses support\n-  \/\/ Flushing and deoptimization in case of evolution\n-  static int  mark_dependents_for_evol_deoptimization();\n-  static void mark_all_nmethods_for_evol_deoptimization();\n-  static void flush_evol_dependents();\n-  static void old_nmethods_do(MetadataClosure* f) NOT_JVMTI_RETURN;\n-  static void unregister_old_nmethod(CompiledMethod* c) NOT_JVMTI_RETURN;\n-\n-  \/\/ Support for fullspeed debugging\n-  static void flush_dependents_on_method(const methodHandle& dependee);\n-\n@@ -329,0 +306,9 @@\n+class SweeperBlocker : public StackObj {\n+  public:\n+    SweeperBlocker() {\n+      CodeCache::Sweep::begin_compiled_method_iteration();\n+    }\n+    ~SweeperBlocker() {\n+      CodeCache::Sweep::end_compiled_method_iteration();\n+    }\n+};\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":10,"deletions":24,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -53,0 +53,2 @@\n+CompiledMethod* CompiledMethod::_root_mark_link = nullptr;\n+\n@@ -57,1 +59,1 @@\n-    _mark_for_deoptimization_status(not_marked),\n+    _mark_link(nullptr),\n@@ -69,1 +71,1 @@\n-    _mark_for_deoptimization_status(not_marked),\n+    _mark_link(nullptr),\n@@ -120,6 +122,13 @@\n-void CompiledMethod::mark_for_deoptimization(bool inc_recompile_counts) {\n-  \/\/ assert(can_be_deoptimized(), \"\"); \/\/ in some places we check before marking, in others not.\n-  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? NULL : CompiledMethod_lock,\n-                 Mutex::_no_safepoint_check_flag);\n-  if (_mark_for_deoptimization_status != deoptimize_done) { \/\/ can't go backwards\n-     _mark_for_deoptimization_status = (inc_recompile_counts ? deoptimize : deoptimize_noupdate);\n+bool CompiledMethod::mark_for_deoptimization(bool inc_recompile_counts) {\n+  assert_locked_or_safepoint(Compile_lock);\n+  MarkForDeoptimizationStatus old_mark = extract_mark(_mark_link);\n+  if (old_mark != deoptimize_done) { \/\/ can't go backwards\n+    MarkForDeoptimizationStatus new_mark = (inc_recompile_counts ? deoptimize : deoptimize_noupdate);\n+    if (old_mark == not_marked) {\n+      assert(extract_compiled_method(_mark_link) == nullptr, \"Compiled Method should not already be linked\");\n+      _mark_link = mark_link(_root_mark_link, new_mark);\n+      _root_mark_link = this;\n+      return true;\n+    } else {\n+      _mark_link = mark_link(extract_compiled_method(_mark_link), new_mark);\n+    }\n@@ -127,0 +136,18 @@\n+  return false;\n+}\n+\n+CompiledMethod* CompiledMethod::next_marked() const {\n+  assert_locked_or_safepoint(Compile_lock);\n+  return extract_compiled_method(_mark_link);\n+}\n+\n+CompiledMethod* CompiledMethod::take_root() {\n+  assert_locked_or_safepoint(Compile_lock);\n+  CompiledMethod* root = _root_mark_link;\n+  _root_mark_link = nullptr;\n+  return root;\n+}\n+\n+void  CompiledMethod::mark_deoptimized() {\n+  assert_locked_or_safepoint(Compile_lock);\n+  _mark_link = mark_link(extract_compiled_method(_mark_link), deoptimize_done);\n","filename":"src\/hotspot\/share\/code\/compiledMethod.cpp","additions":35,"deletions":8,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+  friend class DeoptimizationContext;\n@@ -154,1 +155,1 @@\n-  MarkForDeoptimizationStatus _mark_for_deoptimization_status; \/\/ Used for stack deoptimization\n+  struct MarkedCompiledMethodLink;\n@@ -156,0 +157,14 @@\n+  static CompiledMethod* _root_mark_link;\n+  MarkedCompiledMethodLink* _mark_link;\n+\n+  static MarkedCompiledMethodLink* mark_link(CompiledMethod* cm, MarkForDeoptimizationStatus mark) {\n+    assert(((uintptr_t)cm & 0x3) == 0, \"cm pointer must have zero lower two LSB\");\n+    return (MarkedCompiledMethodLink*)(((uintptr_t)cm & ~0x3) | static_cast<u1>(mark));\n+  }\n+\n+  static MarkForDeoptimizationStatus extract_mark(MarkedCompiledMethodLink* link) {\n+    return static_cast<MarkForDeoptimizationStatus>((uintptr_t)link & 0x3);\n+  }\n+  static CompiledMethod* extract_compiled_method(MarkedCompiledMethodLink* link) {\n+    return (CompiledMethod*)((uintptr_t)link & ~0x3);\n+  }\n@@ -245,2 +260,1 @@\n-  bool  is_marked_for_deoptimization() const { return _mark_for_deoptimization_status != not_marked; }\n-  void  mark_for_deoptimization(bool inc_recompile_counts = true);\n+  bool  is_marked_for_deoptimization() const { return extract_mark(_mark_link) != not_marked; }\n@@ -248,2 +262,9 @@\n-  bool  has_been_deoptimized() const { return _mark_for_deoptimization_status == deoptimize_done; }\n-  void  mark_deoptimized() { _mark_for_deoptimization_status = deoptimize_done; }\n+  bool  has_been_deoptimized() const { return extract_mark(_mark_link) == deoptimize_done; }\n+\n+private:\n+  bool  mark_for_deoptimization(bool inc_recompile_counts = true);\n+  CompiledMethod* next_marked() const;\n+  static CompiledMethod* take_root();\n+protected:\n+  void  mark_deoptimized();\n+public:\n@@ -257,2 +278,2 @@\n-    return _mark_for_deoptimization_status != deoptimize_noupdate &&\n-           _mark_for_deoptimization_status != deoptimize_done;\n+    MarkForDeoptimizationStatus mark_status = extract_mark(_mark_link);\n+    return mark_status != deoptimize_noupdate && mark_status != deoptimize_done;\n","filename":"src\/hotspot\/share\/code\/compiledMethod.hpp","additions":28,"deletions":7,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -686,1 +687,1 @@\n-  virtual void mark_for_deoptimization(nmethod* nm) = 0;\n+  virtual void mark_for_deoptimization(nmethod* nm, DeoptimizationContext* deopt) = 0;\n@@ -784,2 +785,2 @@\n-  virtual void mark_for_deoptimization(nmethod* nm) {\n-    nm->mark_for_deoptimization(\/*inc_recompile_counts=*\/true);\n+  virtual void mark_for_deoptimization(nmethod* nm, DeoptimizationContext* deopt) {\n+    deopt->mark(nm, true \/* inc_recompile_counts *\/);\n@@ -826,2 +827,2 @@\n-  virtual void mark_for_deoptimization(nmethod* nm) {\n-    nm->mark_for_deoptimization(\/*inc_recompile_counts=*\/false);\n+  virtual void mark_for_deoptimization(nmethod* nm, DeoptimizationContext* deopt) {\n+    deopt->mark(nm, false \/* inc_recompile_counts *\/);\n","filename":"src\/hotspot\/share\/code\/dependencies.hpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -67,2 +68,1 @@\n-int DependencyContext::mark_dependent_nmethods(DepChange& changes) {\n-  int found = 0;\n+void DependencyContext::mark_dependent_nmethods(DepChange& changes, DeoptimizationContext* deopt) {\n@@ -81,2 +81,1 @@\n-      changes.mark_for_deoptimization(nm);\n-      found++;\n+      changes.mark_for_deoptimization(nm, deopt);\n@@ -85,1 +84,0 @@\n-  return found;\n@@ -208,0 +206,6 @@\n+nmethodBucket* DependencyContext::release_and_get_next_not_unloading(nmethodBucket* b) {\n+    nmethodBucket* next = b->next_not_unloading();\n+    release(b);\n+    return next;\n+}\n+\n@@ -210,1 +214,14 @@\n-int DependencyContext::remove_all_dependents() {\n+void DependencyContext::remove_all_dependents() {\n+  nmethodBucket* b = dependencies_not_unloading();\n+  set_dependencies(NULL);\n+  int removed = 0;\n+  while (b != NULL) {\n+    b = release_and_get_next_not_unloading(b);\n+    ++removed;\n+  }\n+  if (UsePerfData && removed > 0) {\n+    _perf_total_buckets_deallocated_count->inc(removed);\n+  }\n+}\n+\n+void DependencyContext::remove_and_mark_all_dependents(DeoptimizationContext* deopt) {\n@@ -213,1 +230,0 @@\n-  int marked = 0;\n@@ -218,2 +234,1 @@\n-      nm->mark_for_deoptimization();\n-      marked++;\n+      deopt->mark(nm, true \/* inc_recompile_counts *\/);\n@@ -221,4 +236,2 @@\n-    nmethodBucket* next = b->next_not_unloading();\n-    removed++;\n-    release(b);\n-    b = next;\n+    b = release_and_get_next_not_unloading(b);\n+    ++removed;\n@@ -229,1 +242,0 @@\n-  return marked;\n","filename":"src\/hotspot\/share\/code\/dependencyContext.cpp","additions":26,"deletions":14,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -88,0 +89,1 @@\n+  nmethodBucket* release_and_get_next_not_unloading(nmethodBucket* b);\n@@ -120,1 +122,1 @@\n-  int  mark_dependent_nmethods(DepChange& changes);\n+  void mark_dependent_nmethods(DepChange& changes, DeoptimizationContext* deopt);\n@@ -123,1 +125,2 @@\n-  int  remove_all_dependents();\n+  void remove_and_mark_all_dependents(DeoptimizationContext* deopt);\n+  void remove_all_dependents();\n","filename":"src\/hotspot\/share\/code\/dependencyContext.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -86,0 +86,3 @@\n+#if INCLUDE_JVMTI\n+#include \"prims\/jvmtiRedefineClasses.hpp\"\n+#endif\n@@ -1618,1 +1621,3 @@\n-  CodeCache::unregister_old_nmethod(this);\n+#if INCLUDE_JVMTI\n+  VM_RedefineClasses::unregister_old_nmethod(this);\n+#endif\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1539,1 +1539,1 @@\n-    Deoptimization::deoptimize_all_marked(nm);\n+    Deoptimization::mark_and_deoptimize_nmethod(nm);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1184,1 +1184,1 @@\n-    CodeCache::flush_dependents_on(this);\n+     Deoptimization::mark_and_deoptimize_dependents_on(this);\n@@ -2337,2 +2337,2 @@\n-int InstanceKlass::mark_dependent_nmethods(KlassDepChange& changes) {\n-  return dependencies().mark_dependent_nmethods(changes);\n+void InstanceKlass::mark_dependent_nmethods(KlassDepChange& changes, DeoptimizationContext* deopt) {\n+  dependencies().mark_dependent_nmethods(changes, deopt);\n@@ -3322,1 +3322,1 @@\n-int InstanceKlass::mark_osr_nmethods(const Method* m) {\n+void InstanceKlass::mark_osr_nmethods(const Method* m, DeoptimizationContext* deopt) {\n@@ -3326,1 +3326,0 @@\n-  int found = 0;\n@@ -3330,2 +3329,1 @@\n-      osr->mark_for_deoptimization();\n-      found++;\n+      deopt->mark(osr, true \/* inc_recompile_count *\/);\n@@ -3335,1 +3333,0 @@\n-  return found;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -940,1 +941,1 @@\n-  int  mark_dependent_nmethods(KlassDepChange& changes);\n+  void mark_dependent_nmethods(KlassDepChange& changes, DeoptimizationContext* deopt);\n@@ -950,1 +951,1 @@\n-  int mark_osr_nmethods(const Method* m);\n+  void mark_osr_nmethods(const Method* m, DeoptimizationContext* deopt);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2037,1 +2037,1 @@\n-    CodeCache::flush_dependents_on_method(mh);\n+    Deoptimization::mark_and_deoptimize_dependents(mh);\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -917,2 +918,2 @@\n-  int mark_osr_nmethods() {\n-    return method_holder()->mark_osr_nmethods(this);\n+  void mark_osr_nmethods(DeoptimizationContext* deopt) {\n+    method_holder()->mark_osr_nmethods(this, deopt);\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4078,0 +4078,45 @@\n+\/\/ RedefineClasses support for saving nmethods that are dependent on \"old\" methods.\n+\/\/ We don't really expect this table to grow very large.  If it does, it can become a hashtable.\n+static GrowableArray<CompiledMethod*>* old_compiled_method_table = NULL;\n+\n+static void add_to_old_table(CompiledMethod* c) {\n+  if (old_compiled_method_table == NULL) {\n+    old_compiled_method_table = new (ResourceObj::C_HEAP, mtCode) GrowableArray<CompiledMethod*>(100, mtCode);\n+  }\n+  old_compiled_method_table->push(c);\n+}\n+\n+static void reset_old_method_table() {\n+  if (old_compiled_method_table != NULL) {\n+    delete old_compiled_method_table;\n+    old_compiled_method_table = NULL;\n+  }\n+}\n+\n+\/\/ Remove this method when zombied or unloaded.\n+void VM_RedefineClasses::unregister_old_nmethod(CompiledMethod* c) {\n+  assert_lock_strong(CodeCache_lock);\n+  if (old_compiled_method_table != NULL) {\n+    int index = old_compiled_method_table->find(c);\n+    if (index != -1) {\n+      old_compiled_method_table->delete_at(index);\n+    }\n+  }\n+}\n+\n+void VM_RedefineClasses::old_nmethods_do(MetadataClosure* f) {\n+  \/\/ Walk old method table and mark those on stack.\n+  int length = 0;\n+  if (old_compiled_method_table != NULL) {\n+    length = old_compiled_method_table->length();\n+    for (int i = 0; i < length; i++) {\n+      CompiledMethod* cm = old_compiled_method_table->at(i);\n+      \/\/ Only walk alive nmethods, the dead ones will get removed by the sweeper or GC.\n+      if (cm->is_alive() && !cm->is_unloading()) {\n+        old_compiled_method_table->at(i)->metadata_do(f);\n+      }\n+    }\n+  }\n+  log_debug(redefine, class, nmethod)(\"Walked %d nmethods for mark_on_stack\", length);\n+}\n+\n@@ -4096,5 +4141,16 @@\n-\n-  bool deopt_needed;\n-\n-  \/\/ This is the first redefinition, mark all the nmethods for deoptimization\n-  if (!JvmtiExport::all_dependencies_are_recorded()) {\n+  DeoptimizationContext deopt;\n+  const bool first_call = !JvmtiExport::all_dependencies_are_recorded();\n+  assert(SafepointSynchronize::is_at_safepoint(), \"Can only do this at a safepoint!\");\n+  CompiledMethodIterator iter(CompiledMethodIterator::only_alive);\n+  if (first_call) {\n+    while(iter.next()) {\n+      CompiledMethod* nm = iter.method();\n+      if (!nm->method()->is_method_handle_intrinsic()) {\n+        if (nm->can_be_deoptimized()) {\n+          deopt.mark(nm, true \/* inc_recompile_count *\/);\n+        }\n+        if (nm->has_evol_metadata()) {\n+          add_to_old_table(nm);\n+        }\n+      }\n+    }\n@@ -4102,2 +4158,0 @@\n-    CodeCache::mark_all_nmethods_for_evol_deoptimization();\n-    deopt_needed = true;\n@@ -4105,7 +4159,14 @@\n-    int deopt = CodeCache::mark_dependents_for_evol_deoptimization();\n-    log_debug(redefine, class, nmethod)(\"Marked %d dependent nmethods for deopt\", deopt);\n-    deopt_needed = (deopt != 0);\n-  }\n-\n-  if (deopt_needed) {\n-    CodeCache::flush_evol_dependents();\n+    \/\/ Each redefinition creates a new set of nmethods that have references to \"old\" Methods\n+    \/\/ So delete old method table and create a new one.\n+    reset_old_method_table();\n+    while(iter.next()) {\n+      CompiledMethod* nm = iter.method();\n+      \/\/ Walk all alive nmethods to check for old Methods.\n+      \/\/ This includes methods whose inline caches point to old methods, so\n+      \/\/ inline cache clearing is unnecessary.\n+      if (nm->has_evol_metadata()) {\n+        deopt.mark(nm, true \/* inc_recompile_count *\/);\n+        add_to_old_table(nm);\n+      }\n+    }\n+    log_debug(redefine, class, nmethod)(\"Marked %d dependent nmethods for deopt\", deopt.marked());\n@@ -4113,1 +4174,1 @@\n-\n+  deopt.deoptimize();\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":76,"deletions":15,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -538,0 +538,3 @@\n+  static void old_nmethods_do(MetadataClosure* f);\n+  static void unregister_old_nmethod(CompiledMethod* c);\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1074,2 +1074,1 @@\n-\n-  int marked = 0;\n+  DeoptimizationContext deopt;\n@@ -1078,1 +1077,0 @@\n-    NoSafepointVerifier nsv;\n@@ -1080,1 +1078,0 @@\n-\n@@ -1083,5 +1080,1 @@\n-    marked = deps.mark_dependent_nmethods(changes);\n-  }\n-  if (marked > 0) {\n-    \/\/ At least one nmethod has been marked for deoptimization.\n-    Deoptimization::deoptimize_all_marked();\n+    deps.mark_dependent_nmethods(changes, &deopt);\n@@ -1089,0 +1082,1 @@\n+  deopt.deoptimize();\n@@ -1489,0 +1483,3 @@\n+  \/\/ Walk all nmethods depending on this call site.\n+  MutexLocker mu1(thread, Compile_lock);\n+  DeoptimizationContext deopt;\n@@ -1490,14 +1487,3 @@\n-    \/\/ Walk all nmethods depending on this call site.\n-    MutexLocker mu1(thread, Compile_lock);\n-\n-    int marked = 0;\n-    {\n-      NoSafepointVerifier nsv;\n-      MutexLocker mu2(THREAD, CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-      DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context());\n-      marked = deps.remove_all_dependents();\n-    }\n-    if (marked > 0) {\n-      \/\/ At least one nmethod has been marked for deoptimization\n-      Deoptimization::deoptimize_all_marked();\n-    }\n+    MutexLocker mu2(thread, CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context());\n+    deps.remove_and_mark_all_dependents(&deopt);\n@@ -1505,0 +1491,2 @@\n+\n+  deopt.deoptimize();\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":11,"deletions":23,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -781,2 +781,2 @@\n-  CodeCache::mark_all_nmethods_for_deoptimization();\n-  Deoptimization::deoptimize_all_marked();\n+  MutexLocker ml(Compile_lock);\n+  Deoptimization::mark_and_deoptimize_all();\n@@ -787,2 +787,1 @@\n-  int result = 0;\n-  CHECK_JNI_EXCEPTION_(env, result);\n+  CHECK_JNI_EXCEPTION_(env, 0);\n@@ -790,0 +789,1 @@\n+  DeoptimizationContext deopt;\n@@ -792,1 +792,1 @@\n-    result += mh->mark_osr_nmethods();\n+    mh->mark_osr_nmethods(&deopt);\n@@ -794,2 +794,1 @@\n-    mh->code()->mark_for_deoptimization();\n-    ++result;\n+    deopt.mark(mh->code(), true \/* inc_recompile_count *\/);\n@@ -797,5 +796,3 @@\n-  result += CodeCache::mark_for_deoptimization(mh());\n-  if (result > 0) {\n-    Deoptimization::deoptimize_all_marked();\n-  }\n-  return result;\n+  Deoptimization::mark_dependents(mh(), &deopt);\n+  deopt.deoptimize();\n+  return (jint)deopt.marked();\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"code\/dependencies.hpp\"\n@@ -100,2 +101,0 @@\n-bool DeoptimizationMarker::_is_active = false;\n-\n@@ -923,3 +922,48 @@\n-void Deoptimization::deoptimize_all_marked(nmethod* nmethod_only) {\n-  ResourceMark rm;\n-  DeoptimizationMarker dm;\n+void Deoptimization::mark_and_deoptimize_all() {\n+  assert_locked_or_safepoint(Compile_lock);\n+  DeoptimizationContext deopt;\n+  {\n+    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);\n+    while(iter.next()) {\n+      CompiledMethod* nm = iter.method();\n+      if (!nm->is_native_method()) {\n+        deopt.mark(nm, true \/* inc_recompile_count *\/);\n+      }\n+    }\n+  }\n+  deopt.deoptimize();\n+}\n+\n+\/\/ Keeps track of time spent for checking dependencies\n+NOT_PRODUCT(static elapsedTimer dependentCheckTime;)\n+#ifndef PRODUCT\n+  void Deoptimization::print_dependency_checking_time(outputStream* stream) {\n+    stream->print_cr(\"nmethod dependency checking time %fs\", dependentCheckTime.seconds());\n+  }\n+#endif\n+\n+void Deoptimization::mark_and_deoptimize(KlassDepChange& changes) {\n+  DeoptimizationContext deopt;\n+  {\n+    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    \/\/ nmethod::check_all_dependencies works only correctly, if no safepoint\n+    \/\/ can happen\n+    NoSafepointVerifier nsv;\n+    for (DepChange::ContextStream str(changes, nsv); str.next(); ) {\n+      Klass* d = str.klass();\n+      InstanceKlass::cast(d)->mark_dependent_nmethods(changes, &deopt);\n+    }\n+\n+#ifndef PRODUCT\n+    if (VerifyDependencies) {\n+      \/\/ Object pointers are used as unique identifiers for dependency arguments. This\n+      \/\/ is only possible if no safepoint, i.e., GC occurs during the verification code.\n+      dependentCheckTime.start();\n+      nmethod::check_all_dependencies(changes);\n+      dependentCheckTime.stop();\n+    }\n+#endif\n+  }\n+  deopt.deoptimize();\n+}\n@@ -927,5 +971,11 @@\n-  \/\/ Make the dependent methods not entrant\n-  if (nmethod_only != NULL) {\n-    nmethod_only->mark_for_deoptimization();\n-    nmethod_only->make_not_entrant();\n-    CodeCache::make_nmethod_deoptimized(nmethod_only);\n+\n+\/\/ Flushes compiled methods dependent on dependee.\n+void Deoptimization::mark_and_deoptimize_dependents_on(InstanceKlass* dependee) {\n+  assert_lock_strong(Compile_lock);\n+\n+  if (CodeCache::number_of_nmethods_with_dependencies() == 0) return;\n+\n+  if (dependee->is_linked()) {\n+    \/\/ Class initialization state change.\n+    KlassInitDepChange changes(dependee);\n+    mark_and_deoptimize(changes);\n@@ -933,1 +983,3 @@\n-    CodeCache::make_marked_nmethods_deoptimized();\n+    \/\/ New class is loaded.\n+    NewKlassDepChange changes(dependee);\n+    mark_and_deoptimize(changes);\n@@ -935,0 +987,3 @@\n+}\n+\n+bool DeoptimizationContext::_context_active = false;\n@@ -936,0 +991,51 @@\n+DeoptimizationContext::DeoptimizationContext()\n+  : _nsv(),\n+    _marked(0),\n+    _deoptimized(false) {\n+  assert_locked_or_safepoint(Compile_lock);\n+  assert(!_context_active, \"Cannot create a DeoptimizationContext while another one is active\");\n+  _context_active = true;\n+}\n+\n+DeoptimizationContext::~DeoptimizationContext() {\n+  assert(_marked == 0 || _deoptimized, \"If something got marked, you have to call deoptimize\");\n+}\n+\n+void DeoptimizationContext::mark(CompiledMethod* cm, bool inc_recompile_count) {\n+  assert(!_deoptimized, \"Calling mark after deoptimize is invalid\");\n+  if (cm->mark_for_deoptimization(inc_recompile_count)) {\n+    ++_marked;\n+  }\n+}\n+\n+void DeoptimizationContext::deopt_compiled_methods() {\n+  SweeperBlocker sw;\n+  CompiledMethod* nm = CompiledMethod::take_root();\n+  uint links_found = 0;\n+  while (nm != nullptr) {\n+    _deoptimized = true;\n+    ++links_found;\n+    assert(nm->is_marked_for_deoptimization(), \"All nmethods in list must be marked\");\n+    if (!nm->has_been_deoptimized() && nm->can_be_deoptimized()) {\n+      nm->make_not_entrant();\n+      nm->make_deoptimized();\n+    }\n+    nm = nm->next_marked();\n+  }\n+  assert(links_found ==_marked, \"All marked nmethods must have been linked\");\n+}\n+\n+void DeoptimizationContext::deopt_frames() {\n+  \/\/ DeoptimizationContext is considered active from its creation until\n+  \/\/ deopt_compiled_methods() finishes processing marked nmethods.\n+  \/\/ deopt_compiled_methods() occurs as the first step of deoptimize()\n+  assert(_context_active, \"deoptimize() must be called on an active context\");\n+  _context_active = false;\n+\n+  if (!_marked) {\n+    return; \/\/ Nothing to do\n+  }\n+\n+  \/\/ DeoptimizationContext sets up a NSV to detect bugs in the client of this API.\n+  \/\/ But we must allow safepoints when performing thread-local handshakes\n+  PauseNoSafepointVerifier pnsv(&_nsv);\n@@ -944,0 +1050,34 @@\n+void DeoptimizationContext::deoptimize() {\n+  deopt_compiled_methods();\n+  deopt_frames();\n+}\n+\n+void Deoptimization::mark_and_deoptimize_dependents(const methodHandle& m_h) {\n+  assert_locked_or_safepoint(Compile_lock);\n+  Deoptimization::mark_and_deoptimize_dependents(m_h());\n+}\n+\n+void Deoptimization::mark_dependents(Method* dependee, DeoptimizationContext* deopt) {\n+  MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+  CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);\n+  while(iter.next()) {\n+    CompiledMethod* nm = iter.method();\n+    if (nm->is_dependent_on_method(dependee)) {\n+      deopt->mark(nm, true \/* inc_recompile_count *\/);\n+    }\n+  }\n+}\n+\n+void Deoptimization::mark_and_deoptimize_dependents(Method* dependee) {\n+  assert_locked_or_safepoint(Compile_lock);\n+  DeoptimizationContext deopt;\n+  mark_dependents(dependee, &deopt);\n+  deopt.deoptimize();\n+}\n+\n+void Deoptimization::mark_and_deoptimize_nmethod(nmethod* nmethod) {\n+  DeoptimizationContext deopt;\n+  deopt.mark(nmethod, true \/* inc_recompile_count *\/);\n+  deopt.deoptimize();\n+}\n+\n@@ -1647,1 +1787,0 @@\n-  DeoptimizationMarker dm;\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":151,"deletions":12,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/safepointVerifiers.hpp\"\n@@ -32,0 +33,1 @@\n+class DeoptimizationContext;\n@@ -40,0 +42,1 @@\n+class KlassDepChange;\n@@ -151,5 +154,14 @@\n-  \/\/ Make all nmethods that are marked_for_deoptimization not_entrant and deoptimize any live\n-  \/\/ activations using those nmethods.  If an nmethod is passed as an argument then it is\n-  \/\/ marked_for_deoptimization and made not_entrant.  Otherwise a scan of the code cache is done to\n-  \/\/ find all marked nmethods and they are made not_entrant.\n-  static void deoptimize_all_marked(nmethod* nmethod_only = NULL);\n+private:\n+  static void mark_and_deoptimize(KlassDepChange& changes);\n+\n+public:\n+  static void mark_and_deoptimize_nmethod(nmethod* nmethod);\n+  static void mark_and_deoptimize_all();\n+  static void mark_and_deoptimize_dependents(const methodHandle& dependee);\n+  static void mark_and_deoptimize_dependents(Method* dependee);\n+  static void mark_and_deoptimize_dependents_on(InstanceKlass* dependee);\n+  static void mark_dependents(Method* dependee, DeoptimizationContext* deopt);\n+\n+#ifndef PRODUCT\n+  static void print_dependency_checking_time(outputStream* stream);\n+#endif\n@@ -476,0 +488,8 @@\n+class DeoptimizationContext : StackObj {\n+  NoSafepointVerifier _nsv;\n+  uint _marked;\n+  bool _deoptimized;\n+  static bool _context_active;\n+\n+  void deopt_compiled_methods();\n+  void deopt_frames();\n@@ -477,2 +497,0 @@\n-class DeoptimizationMarker : StackObj {  \/\/ for profiling\n-  static bool _is_active;\n@@ -480,3 +498,7 @@\n-  DeoptimizationMarker()  { _is_active = true; }\n-  ~DeoptimizationMarker() { _is_active = false; }\n-  static bool is_active() { return _is_active; }\n+  DeoptimizationContext();\n+  ~DeoptimizationContext();\n+\n+  void mark(CompiledMethod* cm, bool inc_recompile_count);\n+  void deoptimize();\n+\n+  uint marked() { return _marked; }\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":32,"deletions":10,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -120,1 +120,0 @@\n-  DeoptimizationMarker dm;\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}