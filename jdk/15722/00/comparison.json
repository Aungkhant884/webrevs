{"files":[{"patch":"@@ -38,0 +38,2 @@\n+import jdk.internal.util.ByteArrayLittleEndian;\n+import jdk.internal.util.DecimalDigits;\n@@ -818,0 +820,29 @@\n+    void appendDigit2(int i) {\n+        ensureCapacityInternal(count + 2);\n+        if (isLatin1()) {\n+            ByteArrayLittleEndian.setShort(value, count, DecimalDigits.digitPair(i));\n+        } else {\n+            StringUTF16.putPair(value, count, i);\n+        }\n+        count += 2;\n+    }\n+\n+    void appendDigit3(int i) {\n+        ensureCapacityInternal(count + 3);\n+\n+        int div = i \/ 100;\n+        int rem = i - div * 100;\n+        byte c0 = (byte) ('0' + div);\n+        short c12 = DecimalDigits.digitPair(i - div * 100);\n+\n+        if (isLatin1()) {\n+            value[count] = c0;\n+            ByteArrayLittleEndian.setShort(value, count + 1, c12);\n+        } else {\n+            StringUTF16.putChar(value, count, c0);\n+            StringUTF16.putPair(value, count + 1, c12);\n+        }\n+\n+        count += 3;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/AbstractStringBuilder.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1615,1 +1615,1 @@\n-    private static void putPair(byte[] buf, int charPos, int v) {\n+    static void putPair(byte[] buf, int charPos, int v) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringUTF16.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2547,0 +2547,8 @@\n+            public void appendDigit2(StringBuilder sb, int i) {\n+                sb.appendDigit2(i);\n+            }\n+\n+            public void appendDigit3(StringBuilder sb, int i) {\n+                sb.appendDigit3(i);\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -800,5 +800,1 @@\n-                .appendValue(YEAR, 4, 10, SignStyle.EXCEEDS_PAD)\n-                .appendLiteral('-')\n-                .appendValue(MONTH_OF_YEAR, 2)\n-                .appendLiteral('-')\n-                .appendValue(DAY_OF_MONTH, 2)\n+                .appendLocalDate()\n@@ -899,8 +895,1 @@\n-                .appendValue(HOUR_OF_DAY, 2)\n-                .appendLiteral(':')\n-                .appendValue(MINUTE_OF_HOUR, 2)\n-                .optionalStart()\n-                .appendLiteral(':')\n-                .appendValue(SECOND_OF_MINUTE, 2)\n-                .optionalStart()\n-                .appendFraction(NANO_OF_SECOND, 0, 9, true)\n+                .appendLocalTime()\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatter.java","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -85,0 +85,3 @@\n+import java.time.OffsetDateTime;\n+import java.time.OffsetTime;\n+import java.time.ZonedDateTime;\n@@ -124,0 +127,3 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -162,0 +168,20 @@\n+    \/**\n+     * Hours per day.\n+     *\/\n+    static final int HOURS_PER_DAY = 24;\n+    \/**\n+     * Minutes per hour.\n+     *\/\n+    static final int MINUTES_PER_HOUR = 60;\n+    \/**\n+     * Seconds per minute.\n+     *\/\n+    static final int SECONDS_PER_MINUTE = 60;\n+    \/**\n+     * Seconds per hour.\n+     *\/\n+    static final int SECONDS_PER_HOUR = SECONDS_PER_MINUTE * MINUTES_PER_HOUR;\n+    \/**\n+     * Seconds per day.\n+     *\/\n+    static final int SECONDS_PER_DAY = SECONDS_PER_HOUR * HOURS_PER_DAY;\n@@ -163,0 +189,1 @@\n+    private static final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n@@ -866,0 +893,19 @@\n+    DateTimeFormatterBuilder appendLocalDate() {\n+        appendInternal(new LocalDatePrinterParser());\n+        return this;\n+    }\n+\n+    DateTimeFormatterBuilder appendLocalTime() {\n+        appendInternal(new LocalTimePrinterParser(true, 0, 9));\n+        return this;\n+    }\n+\n+    DateTimeFormatterBuilder appendLocalTime(\n+            boolean optional,\n+            int nanoMinWidth,\n+            int nanoMaxWidth\n+    ) {\n+        appendInternal(new LocalTimePrinterParser(optional, nanoMinWidth, nanoMaxWidth));\n+        return this;\n+    }\n+\n@@ -1899,2 +1945,27 @@\n-        parsePattern(pattern);\n-        return this;\n+        switch (pattern) {\n+            case \"HH:mm:ss\":\n+                return appendLocalTime(true, 0, 0);\n+            case \"HH:mm:ss.SSS\":\n+                return appendLocalTime(true, 3, 3);\n+            case \"yyyy-MM-dd\":\n+                return appendLocalDate();\n+            case \"yyyy-MM-dd HH:mm:ss\":\n+                return appendLocalDate()\n+                        .appendLiteral(' ')\n+                        .appendLocalTime(false, 0, 0);\n+            case \"yyyy-MM-dd'T'HH:mm:ss\":\n+                return appendLocalDate()\n+                        .appendLiteral('T')\n+                        .appendLocalTime(false, 0, 0);\n+            case \"yyyy-MM-dd HH:mm:ss.SSS\":\n+                return appendLocalDate()\n+                        .appendLiteral(' ')\n+                        .appendLocalTime(false, 3, 3);\n+            case \"yyyy-MM-dd'T'HH:mm:ss.SSS\":\n+                return appendLocalDate()\n+                        .appendLiteral('T')\n+                        .appendLocalTime(false, 3, 3);\n+            default:\n+                parsePattern(pattern);\n+                return this;\n+        }\n@@ -2425,0 +2496,1 @@\n+\n@@ -2426,0 +2498,1 @@\n+\n@@ -2491,0 +2564,109 @@\n+    static final class LocalDatePrinterParser extends CompositePrinterParser {\n+        LocalDatePrinterParser() {\n+            super(buildPrinterParsers(), false);\n+        }\n+\n+        private static List<DateTimePrinterParser> buildPrinterParsers() {\n+            List<DateTimePrinterParser> printerParsers = new ArrayList<>();\n+            printerParsers.add(new NumberPrinterParser(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD));\n+            printerParsers.add(new CharLiteralPrinterParser('-'));\n+            printerParsers.add(new NumberPrinterParser(ChronoField.MONTH_OF_YEAR, 2, 2, SignStyle.NOT_NEGATIVE));\n+            printerParsers.add(new CharLiteralPrinterParser('-'));\n+            printerParsers.add(new NumberPrinterParser(ChronoField.DAY_OF_MONTH, 2, 2, SignStyle.NOT_NEGATIVE));\n+            return printerParsers;\n+        }\n+\n+        @Override\n+        public boolean format(DateTimePrintContext context, StringBuilder buf) {\n+            TemporalAccessor temporal = context.getTemporal();\n+\n+            LocalDate date;\n+            switch (temporal) {\n+                case LocalDate localDate -> date = localDate;\n+                case LocalDateTime ldt -> date = ldt.toLocalDate();\n+                case ZonedDateTime zdt -> date = zdt.toLocalDate();\n+                case OffsetDateTime odt -> date = odt.toLocalDate();\n+                default -> {\n+                    return super.format(context, buf);\n+                }\n+            }\n+\n+            formatDate(buf, date);\n+            return true;\n+        }\n+    }\n+\n+    static final class LocalTimePrinterParser extends CompositePrinterParser {\n+        private final boolean nanoOptional;\n+        private final int nanoMinWidth;\n+        private final int nanoMaxWidth;\n+        private final int fractionalDigits;\n+\n+        LocalTimePrinterParser(boolean nanoOptional, int nanoMinWidth, int nanoMaxWidth) {\n+            super(buildPrinterParsers(nanoOptional, nanoMinWidth, nanoMaxWidth), false);\n+            this.nanoOptional = nanoOptional;\n+            this.nanoMinWidth = nanoMinWidth;\n+            this.nanoMaxWidth = nanoMaxWidth;\n+            if (nanoMaxWidth == 0 && nanoMaxWidth == 9) {\n+                fractionalDigits = -2;\n+            } else {\n+                fractionalDigits = nanoMaxWidth;\n+            }\n+        }\n+\n+        private static List<DateTimePrinterParser> buildPrinterParsers(\n+                boolean optional,\n+                int nanoMinWidth,\n+                int nanoMaxWidth\n+        ) {\n+            List<DateTimePrinterParser> printerParsers = new ArrayList<>();\n+            printerParsers.add(new NumberPrinterParser(ChronoField.HOUR_OF_DAY, 2, 2, SignStyle.NOT_NEGATIVE));\n+            printerParsers.add(new CharLiteralPrinterParser(':'));\n+            printerParsers.add(new NumberPrinterParser(ChronoField.MINUTE_OF_HOUR, 2, 2, SignStyle.NOT_NEGATIVE));\n+            printerParsers.add(new CharLiteralPrinterParser(':'));\n+            printerParsers.add(new NumberPrinterParser(ChronoField.SECOND_OF_MINUTE, 2, 2, SignStyle.NOT_NEGATIVE));\n+\n+            if (nanoMinWidth >= 0) {\n+                DateTimePrinterParser nanosPrinterParser\n+                        = new NanosPrinterParser(nanoMinWidth, nanoMaxWidth, optional, 0);\n+                if (optional) {\n+                    nanosPrinterParser\n+                            = new CompositePrinterParser(new DateTimePrinterParser[]{nanosPrinterParser}, true);\n+                }\n+                printerParsers.add(nanosPrinterParser);\n+            }\n+\n+            return printerParsers;\n+        }\n+\n+        @Override\n+        public boolean format(DateTimePrintContext context, StringBuilder buf) {\n+            TemporalAccessor temporal = context.getTemporal();\n+\n+            LocalTime time;\n+            switch (temporal) {\n+                case LocalTime lt -> time = lt;\n+                case LocalDateTime ldt -> time = ldt.toLocalTime();\n+                case ZonedDateTime zdt -> time = zdt.toLocalTime();\n+                case OffsetDateTime odt -> time = odt.toLocalTime();\n+                case OffsetTime ot -> time = ot.toLocalTime();\n+                default -> {\n+                    return super.format(context, buf);\n+                }\n+            }\n+\n+            formatTime(buf, time);\n+\n+            int nano = time.getNano();\n+            if (nano != 0 || !nanoOptional) {\n+                if (fractionalDigits < 0) {\n+                    formatNano(buf, nano);\n+                } else {\n+                    formatNano(buf, fractionalDigits, nano);\n+                }\n+            }\n+\n+            return true;\n+        }\n+    }\n+\n@@ -2495,1 +2677,1 @@\n-    static final class CompositePrinterParser implements DateTimePrinterParser {\n+    static sealed class CompositePrinterParser implements DateTimePrinterParser {\n@@ -2499,1 +2681,1 @@\n-        private CompositePrinterParser(List<DateTimePrinterParser> printerParsers, boolean optional) {\n+        CompositePrinterParser(List<DateTimePrinterParser> printerParsers, boolean optional) {\n@@ -2833,1 +3015,1 @@\n-        private final SignStyle signStyle;\n+        final SignStyle signStyle;\n@@ -3279,1 +3461,1 @@\n-        private final boolean decimalPoint;\n+        final boolean decimalPoint;\n@@ -3796,0 +3978,116 @@\n+    static void formatDate(StringBuilder buf, LocalDate date) {\n+        int year = date.getYear();\n+        int yearAbs = Math.abs(year);\n+        if (yearAbs < 1000) {\n+            if (year < 0) {\n+                buf.append('-');\n+            }\n+            int y01 = yearAbs \/ 100;\n+            int y23 = yearAbs - y01 * 100;\n+\n+            jla.appendDigit2(buf, y01);\n+            jla.appendDigit2(buf, y23);\n+        } else {\n+            if (year > 9999) {\n+                buf.append('+');\n+            }\n+\n+            buf.append(year);\n+        }\n+        buf.append('-');\n+        jla.appendDigit2(buf, date.getMonthValue());\n+        buf.append('-');\n+        jla.appendDigit2(buf, date.getDayOfMonth());\n+    }\n+\n+    static void formatTime(StringBuilder buf, LocalTime time) {\n+        jla.appendDigit2(buf, time.getHour());\n+        buf.append(':');\n+        jla.appendDigit2(buf, time.getMinute());\n+        buf.append(':');\n+        jla.appendDigit2(buf, time.getSecond());\n+    }\n+\n+    static void formatNano(StringBuilder buf, int nano) {\n+        if (nano == 0) {\n+            return;\n+        }\n+\n+        int div = nano \/ 1000;\n+        int div2 = div \/ 1000;\n+\n+        buf.append('.');\n+        jla.appendDigit3(buf, div2);\n+\n+        int rem1 = nano - div * 1000;\n+        int rem2 = div - div2 * 1000;\n+\n+        if (rem1 == 0 && rem2 == 0) {\n+            return;\n+        }\n+\n+        jla.appendDigit3(buf, rem2);\n+        if (rem1 == 0) {\n+            return;\n+        }\n+        jla.appendDigit3(buf, rem1);\n+    }\n+\n+    static void formatNano(StringBuilder buf, int fractionalDigits, int nano) {\n+        if (fractionalDigits == 0) {\n+            return;\n+        }\n+\n+        buf.append('.');\n+\n+        int div = nano \/ 1000;\n+        int div2 = div \/ 1000;\n+\n+        if (fractionalDigits == 1) {\n+            buf.append((char) ('0' + (div2 \/ 100)));\n+            return;\n+        }\n+\n+        if (fractionalDigits == 2) {\n+            jla.appendDigit2(buf, div2 \/ 10);\n+            return;\n+        }\n+\n+        jla.appendDigit3(buf, div2);\n+\n+        if (fractionalDigits == 3) {\n+            return;\n+        }\n+\n+        int rem1 = nano - div * 1000;\n+        int rem2 = div - div2 * 1000;\n+\n+        if (fractionalDigits == 4) {\n+            buf.append((char) ('0' + (rem2 \/ 100)));\n+            return;\n+        }\n+\n+        if (fractionalDigits == 5) {\n+            jla.appendDigit2(buf, rem2 \/ 10);\n+            return;\n+        }\n+\n+        jla.appendDigit3(buf, rem2);\n+\n+        if (fractionalDigits == 6) {\n+            return;\n+        }\n+\n+        if (fractionalDigits == 7) {\n+            buf.append((char) ('0' + (rem1 \/ 100)));\n+            return;\n+        }\n+\n+        if (fractionalDigits == 8) {\n+            jla.appendDigit2(buf, rem1 \/ 10);\n+            return;\n+        }\n+\n+        jla.appendDigit3(buf, rem1);\n+    }\n+\n@@ -3814,25 +4112,16 @@\n-            \/\/ use INSTANT_SECONDS, thus this code is not bound by Instant.MAX\n-            Long inSecs = context.getValue(INSTANT_SECONDS);\n-            Long inNanos = null;\n-            if (context.getTemporal().isSupported(NANO_OF_SECOND)) {\n-                inNanos = context.getTemporal().getLong(NANO_OF_SECOND);\n-            }\n-            if (inSecs == null) {\n-                return false;\n-            }\n-            long inSec = inSecs;\n-            int inNano = NANO_OF_SECOND.checkValidIntValue(inNanos != null ? inNanos : 0);\n-            \/\/ format mostly using LocalDateTime.toString\n-            if (inSec >= -SECONDS_0000_TO_1970) {\n-                \/\/ current era\n-                long zeroSecs = inSec - SECONDS_PER_10000_YEARS + SECONDS_0000_TO_1970;\n-                long hi = Math.floorDiv(zeroSecs, SECONDS_PER_10000_YEARS) + 1;\n-                long lo = Math.floorMod(zeroSecs, SECONDS_PER_10000_YEARS);\n-                LocalDateTime ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);\n-                if (hi > 0) {\n-                    buf.append('+').append(hi);\n-                }\n-                buf.append(ldt);\n-                if (ldt.getSecond() == 0) {\n-                    buf.append(\":00\");\n-                }\n+            Instant instant = (Instant) context.getTemporal();\n+            long seconds = instant.getEpochSecond();\n+            int nano = instant.getNano();\n+\n+            LocalDate date = LocalDate.ofEpochDay(\n+                    Math.floorDiv(seconds, SECONDS_PER_DAY));\n+\n+            formatDate(buf, date);\n+            buf.append('T');\n+\n+            LocalTime time = LocalTime.ofSecondOfDay(\n+                    Math.floorMod(seconds, SECONDS_PER_DAY));\n+\n+            formatTime(buf, time);\n+            if (fractionalDigits < 0) {\n+                formatNano(buf, nano);\n@@ -3840,32 +4129,1 @@\n-                \/\/ before current era\n-                long zeroSecs = inSec + SECONDS_0000_TO_1970;\n-                long hi = zeroSecs \/ SECONDS_PER_10000_YEARS;\n-                long lo = zeroSecs % SECONDS_PER_10000_YEARS;\n-                LocalDateTime ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);\n-                int pos = buf.length();\n-                buf.append(ldt);\n-                if (ldt.getSecond() == 0) {\n-                    buf.append(\":00\");\n-                }\n-                if (hi < 0) {\n-                    if (ldt.getYear() == -10_000) {\n-                        buf.replace(pos, pos + 2, Long.toString(hi - 1));\n-                    } else if (lo == 0) {\n-                        buf.insert(pos, hi);\n-                    } else {\n-                        buf.insert(pos + 1, Math.abs(hi));\n-                    }\n-                }\n-            }\n-            \/\/ add fraction\n-            if ((fractionalDigits < 0 && inNano > 0) || fractionalDigits > 0) {\n-                buf.append('.');\n-                int div = 100_000_000;\n-                for (int i = 0; ((fractionalDigits == -1 && inNano > 0) ||\n-                                    (fractionalDigits == -2 && (inNano > 0 || (i % 3) != 0)) ||\n-                                    i < fractionalDigits); i++) {\n-                    int digit = inNano \/ div;\n-                    buf.append((char) (digit + '0'));\n-                    inNano = inNano - (digit * div);\n-                    div = div \/ 10;\n-                }\n+                formatNano(buf, fractionalDigits, nano);\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":321,"deletions":63,"binary":false,"changes":384,"status":"modified"},{"patch":"@@ -437,0 +437,4 @@\n+   void appendDigit2(StringBuilder sb, int i);\n+\n+   void appendDigit3(StringBuilder sb, int i);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}