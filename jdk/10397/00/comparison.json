{"files":[{"patch":"@@ -86,1 +86,5 @@\n-          \"Use fast method entry code for accessor methods\")\n+          \"Use fast method entry code for accessor methods\")                \\\n+                                                                            \\\n+  product(bool, DecodeErrorContext, false, DIAGNOSTIC,                      \\\n+          \"Try to decode the architecture-specific context for better \"     \\\n+          \"diagnostics\")\n","filename":"src\/hotspot\/cpu\/zero\/globals_zero.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -605,6 +605,0 @@\n-    } else if (ZERO_ONLY(true) NOT_ZERO(false)) {\n-      \/\/ Non-arch-specific Zero code does not really know the pc.\n-      \/\/ This can be alleviated by making arch-specific os::Posix::ucontext_get_pc\n-      \/\/ available for Zero for known architectures. But for generic Zero\n-      \/\/ code, it would still remain unknown.\n-      pc = NULL;\n@@ -669,6 +663,1 @@\n-    \/\/ For Zero, we ignore the crash context, because:\n-    \/\/  a) The crash would be in C++ interpreter code, so context is not really relevant;\n-    \/\/  b) Generic Zero code would not be able to parse it, so when generic error\n-    \/\/     reporting code asks e.g. about frames on stack, Zero would experience\n-    \/\/     a secondary ShouldNotCallThis() crash.\n-    VMError::report_and_die(t, sig, pc, info, NOT_ZERO(ucVoid) ZERO_ONLY(NULL));\n+    VMError::report_and_die(t, sig, pc, info, ucVoid);\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -90,2 +90,24 @@\n-  ShouldNotCallThis();\n-  return NULL; \/\/ silence compile warnings\n+  if (DecodeErrorContext) {\n+#if defined(IA32)\n+    return (address)uc->uc_mcontext.gregs[REG_EIP];\n+#elif defined(AMD64)\n+    return (address)uc->uc_mcontext.gregs[REG_RIP];\n+#elif defined(ARM)\n+    return (address)uc->uc_mcontext.arm_pc;\n+#elif defined(AARCH64)\n+    return (address)uc->uc_mcontext.pc;\n+#elif defined(PPC)\n+    return (address)uc->uc_mcontext.regs->nip;\n+#elif defined(RISCV)\n+    return (address)uc->uc_mcontext.__gregs[REG_PC];\n+#elif defined(S390)\n+    return (address)uc->uc_mcontext.psw.addr;\n+#else\n+    \/\/ Non-arch-specific Zero code does not really know the PC.\n+    \/\/ If possible, add the arch-specific definition in this method.\n+    fatal(\"Cannot handle ucontext_get_pc\");\n+#endif\n+  }\n+\n+  \/\/ Answer the default and hope for the best\n+  return nullptr;\n@@ -94,1 +116,1 @@\n-void os::Posix::ucontext_set_pc(ucontext_t * uc, address pc) {\n+void os::Posix::ucontext_set_pc(ucontext_t* uc, address pc) {\n@@ -98,0 +120,54 @@\n+intptr_t* os::Linux::ucontext_get_sp(const ucontext_t* uc) {\n+  if (DecodeErrorContext) {\n+#if defined(IA32)\n+    return (intptr_t*)uc->uc_mcontext.gregs[REG_UESP];\n+#elif defined(AMD64)\n+    return (intptr_t*)uc->uc_mcontext.gregs[REG_RSP];\n+#elif defined(ARM)\n+    return (intptr_t*)uc->uc_mcontext.arm_sp;\n+#elif defined(AARCH64)\n+    return (intptr_t*)uc->uc_mcontext.sp;\n+#elif defined(PPC)\n+    return (intptr_t*)uc->uc_mcontext.regs->gpr[1\/*REG_SP*\/];\n+#elif defined(RISCV)\n+    return (intptr_t*)uc->uc_mcontext.__gregs[REG_SP];\n+#elif defined(S390)\n+    return (intptr_t*)uc->uc_mcontext.gregs[15\/*REG_SP*\/];\n+#else\n+    \/\/ Non-arch-specific Zero code does not really know the SP.\n+    \/\/ If possible, add the arch-specific definition in this method.\n+    fatal(\"Cannot handle ucontext_get_sp\");\n+#endif\n+  }\n+\n+  \/\/ Answer the default and hope for the best\n+  return nullptr;\n+}\n+\n+intptr_t* os::Linux::ucontext_get_fp(const ucontext_t* uc) {\n+  if (DecodeErrorContext) {\n+#if defined(IA32)\n+    return (intptr_t*)uc->uc_mcontext.gregs[REG_EBP];\n+#elif defined(AMD64)\n+    return (intptr_t*)uc->uc_mcontext.gregs[REG_RBP];\n+#elif defined(ARM)\n+    return (intptr_t*)uc->uc_mcontext.arm_fp;\n+#elif defined(AARCH64)\n+    return (intptr_t*)uc->uc_mcontext.regs[29 \/* REG_FP *\/];\n+#elif defined(PPC)\n+    return nullptr;\n+#elif defined(RISCV)\n+    return (intptr_t*)uc->uc_mcontext.__gregs[8 \/* REG_FP *\/];\n+#elif defined(S390)\n+    return nullptr;\n+#else\n+    \/\/ Non-arch-specific Zero code does not really know the FP.\n+    \/\/ If possible, add the arch-specific definition in this method.\n+    fatal(\"Cannot handle ucontext_get_fp\");\n+#endif\n+  }\n+\n+  \/\/ Answer the default and hope for the best\n+  return nullptr;\n+}\n+\n@@ -101,2 +177,14 @@\n-  ShouldNotCallThis();\n-  return NULL; \/\/ silence compile warnings\n+  address epc;\n+  const ucontext_t* uc = (const ucontext_t*)ucVoid;\n+\n+  if (uc != NULL) {\n+    epc = os::Posix::ucontext_get_pc(uc);\n+    if (ret_sp) *ret_sp = (intptr_t *)os::Linux::ucontext_get_sp(uc);\n+    if (ret_fp) *ret_fp = (intptr_t *)os::Linux::ucontext_get_fp(uc);\n+  } else {\n+    epc = NULL;\n+    if (ret_sp) *ret_sp = nullptr;\n+    if (ret_fp) *ret_fp = nullptr;\n+  }\n+\n+  return epc;\n@@ -106,2 +194,12 @@\n-  ShouldNotCallThis();\n-  return frame(NULL, NULL); \/\/ silence compile warnings\n+  \/\/ This code is only called from error handler to get PC and SP.\n+  \/\/ We don't have the ready ZeroFrame* at this point, so fake the\n+  \/\/ frame with bare minimum.\n+  if (ucVoid != NULL) {\n+    const ucontext_t* uc = (const ucontext_t*)ucVoid;\n+    frame dummy = frame();\n+    dummy.set_pc(os::Posix::ucontext_get_pc(uc));\n+    dummy.set_sp((intptr_t*)os::Linux::ucontext_get_sp(uc));\n+    return dummy;\n+  } else {\n+    return frame(nullptr, nullptr);\n+  }\n@@ -291,2 +389,2 @@\n-void os::print_context(outputStream* st, const void* context) {\n-  ShouldNotCallThis();\n+void os::print_context(outputStream* st, const void* ucVoid) {\n+  st->print_cr(\"No context information.\");\n@@ -295,2 +393,13 @@\n-void os::print_tos_pc(outputStream *st, const void *context) {\n-  ShouldNotCallThis();\n+void os::print_tos_pc(outputStream *st, const void* ucVoid) {\n+  const ucontext_t* uc = (const ucontext_t*)ucVoid;\n+\n+  address sp = (address)os::Linux::ucontext_get_sp(uc);\n+  print_tos(st, sp);\n+  st->cr();\n+\n+  \/\/ Note: it may be unsafe to inspect memory near pc. For example, pc may\n+  \/\/ point to garbage if entry point in an nmethod is corrupted. Leave\n+  \/\/ this at the end, and hope for the best.\n+  address pc = os::Posix::ucontext_get_pc(uc);\n+  print_instructions(st, pc, sizeof(char));\n+  st->cr();\n@@ -299,2 +408,2 @@\n-void os::print_register_info(outputStream *st, const void *context) {\n-  ShouldNotCallThis();\n+void os::print_register_info(outputStream *st, const void* ucVoid) {\n+  st->print_cr(\"No register info.\");\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/os_linux_zero.cpp","additions":122,"deletions":13,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -3155,0 +3155,11 @@\n+\n+  \/\/ Enable error context decoding on known platforms\n+#if defined(IA32) || defined(AMD64) || defined(ARM) || \\\n+    defined(AARCH64) || defined(PPC) || defined(RISCV) || \\\n+    defined(S390)\n+  if (FLAG_IS_DEFAULT(DecodeErrorContext)) {\n+    FLAG_SET_DEFAULT(DecodeErrorContext, true);\n+  }\n+#else\n+  UNSUPPORTED_OPTION(DecodeErrorContext);\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"}]}