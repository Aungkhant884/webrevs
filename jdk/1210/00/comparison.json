{"files":[{"patch":"@@ -778,1 +778,7 @@\n-    \/\/ Test if the oopMark is an obvious stack pointer, i.e.,\n+    \/\/ Fast check for recursive lock.\n+    \/\/\n+    \/\/ Can apply the optimization only if this is a stack lock\n+    \/\/ allocated in this thread. For efficiency, we can focus on\n+    \/\/ recently allocated stack locks (instead of reading the stack\n+    \/\/ base and checking whether 'mark' points inside the current\n+    \/\/ thread stack):\n@@ -780,1 +786,13 @@\n-    \/\/  2) rsp <= mark < mark + os::pagesize()\n+    \/\/  2) sp <= mark < mark + os::pagesize()\n+    \/\/\n+    \/\/ Warning: sp + os::pagesize can overflow the stack base. We must\n+    \/\/ neither apply the optimization for an inflated lock allocated\n+    \/\/ just above the thread stack (this is why condition 1 matters)\n+    \/\/ nor apply the optimization if the stack lock is inside the stack\n+    \/\/ of another thread. The latter is avoided even in case of overflow\n+    \/\/ because we have guard pages at the end of all stacks. Hence, if\n+    \/\/ we go over the stack base and hit the stack of another thread,\n+    \/\/ this should not be in a writeable area that could contain a\n+    \/\/ stack lock allocated by that thread. As a consequence, a stack\n+    \/\/ lock less than page size away from sp is guaranteed to be\n+    \/\/ owned by the current thread.\n@@ -783,1 +801,1 @@\n-    \/\/ expression: ((mark - rsp) & (7 - os::vm_page_size())),\n+    \/\/ expression: ((mark - sp) & (7 - os::vm_page_size())),\n@@ -786,1 +804,1 @@\n-    \/\/ NOTE: the oopMark is in swap_reg %r0 as the result of cmpxchg\n+    \/\/ NOTE: the mark is in swap_reg %r0 as the result of cmpxchg\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1255,1 +1255,7 @@\n-    \/\/ Test if the oopMark is an obvious stack pointer, i.e.,\n+    \/\/ Fast check for recursive lock.\n+    \/\/\n+    \/\/ Can apply the optimization only if this is a stack lock\n+    \/\/ allocated in this thread. For efficiency, we can focus on\n+    \/\/ recently allocated stack locks (instead of reading the stack\n+    \/\/ base and checking whether 'mark' points inside the current\n+    \/\/ thread stack):\n@@ -1259,0 +1265,12 @@\n+    \/\/ Warning: rsp + os::pagesize can overflow the stack base. We must\n+    \/\/ neither apply the optimization for an inflated lock allocated\n+    \/\/ just above the thread stack (this is why condition 1 matters)\n+    \/\/ nor apply the optimization if the stack lock is inside the stack\n+    \/\/ of another thread. The latter is avoided even in case of overflow\n+    \/\/ because we have guard pages at the end of all stacks. Hence, if\n+    \/\/ we go over the stack base and hit the stack of another thread,\n+    \/\/ this should not be in a writeable area that could contain a\n+    \/\/ stack lock allocated by that thread. As a consequence, a stack\n+    \/\/ lock less than page size away from rsp is guaranteed to be\n+    \/\/ owned by the current thread.\n+    \/\/\n@@ -1263,1 +1281,1 @@\n-    \/\/ NOTE: the oopMark is in swap_reg %rax as the result of cmpxchg\n+    \/\/ NOTE: the mark is in swap_reg %rax as the result of cmpxchg\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"}]}