{"files":[{"patch":"@@ -58,1 +58,1 @@\n-    runs-on: macos-13\n+    runs-on: macos-11\n","filename":".github\/workflows\/build-macos.yml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-      xcode-toolset-version: '14.3.1'\n+      xcode-toolset-version: '12.5.1'\n@@ -241,1 +241,1 @@\n-      xcode-toolset-version: '14.3.1'\n+      xcode-toolset-version: '12.5.1'\n@@ -321,1 +321,1 @@\n-      runs-on: macos-13\n+      runs-on: macos-11\n","filename":".github\/workflows\/main.yml","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,1 +135,1 @@\n-          sudo xcode-select --switch \/Applications\/Xcode_14.3.1.app\/Contents\/Developer\n+          sudo xcode-select --switch \/Applications\/Xcode_11.7.app\/Contents\/Developer\n","filename":".github\/workflows\/test.yml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -131,1 +131,1 @@\n-    # MACOSX_VERSION_MIN specifies the lowest version of macOS that the built\n+    # MACOSX_VERSION_MIN specifies the lowest version of Macosx that the built\n@@ -136,1 +136,5 @@\n-    MACOSX_VERSION_MIN=11.00.00\n+    if test \"x$OPENJDK_TARGET_CPU_ARCH\" = xaarch64; then\n+      MACOSX_VERSION_MIN=11.00.00\n+    else\n+      MACOSX_VERSION_MIN=10.12.0\n+    fi\n","filename":"make\/autoconf\/flags.m4","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -444,1 +444,1 @@\n-                \"--with-macosx-version-max=11.00.00\",\n+                \"--with-macosx-version-max=10.12.00\",\n","filename":"make\/conf\/jib-profiles.js","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -136,15 +136,0 @@\n-  # Set ASSERT, NDEBUG and PRODUCT flags just like in JvmFlags.gmk\n-  ifeq ($(DEBUG_LEVEL), release)\n-    # release builds disable uses of assert macro from <assert.h>.\n-    ADLCFLAGS += -DNDEBUG\n-    # For hotspot, release builds differ internally between \"optimized\" and \"product\"\n-    # in that \"optimize\" does not define PRODUCT.\n-    ifneq ($(HOTSPOT_DEBUG_LEVEL), optimized)\n-      ADLCFLAGS += -DPRODUCT\n-    endif\n-  else ifeq ($(DEBUG_LEVEL), fastdebug)\n-    ADLCFLAGS += -DASSERT\n-  else ifeq ($(DEBUG_LEVEL), slowdebug)\n-    ADLCFLAGS += -DASSERT\n-  endif\n-\n","filename":"make\/hotspot\/gensrc\/GensrcAdlc.gmk","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -922,0 +922,13 @@\n+# MACOSX_METAL_VERSION_MIN specifies the lowest version of Macosx\n+# that should be used to compile Metal shaders. We support Metal\n+# pipeline only on Macosx >=10.14. For Macosx versions <10.14 even if\n+# we enable Metal pipeline using -Dsun.java2d.metal=true, at\n+# runtime we force it to use OpenGL pipeline. And MACOSX_VERSION_MIN\n+# for aarch64 has always been >10.14 so we use continue to use\n+# MACOSX_VERSION_MIN for aarch64.\n+ifeq ($(OPENJDK_TARGET_CPU_ARCH), xaarch64)\n+    MACOSX_METAL_VERSION_MIN=$(MACOSX_VERSION_MIN)\n+else\n+    MACOSX_METAL_VERSION_MIN=10.14.0\n+endif\n+\n@@ -934,1 +947,1 @@\n-          -mmacosx-version-min=$(MACOSX_VERSION_MIN) \\\n+          -mmacosx-version-min=$(MACOSX_METAL_VERSION_MIN) \\\n","filename":"make\/modules\/java.desktop\/lib\/Awt2dLibraries.gmk","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -111,1 +111,0 @@\n-        --add-exports java.base\/jdk.internal.foreign=ALL-UNNAMED \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-  frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, bool allow_cb_null = false);\n+  frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb);\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-inline frame::frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, bool allow_cb_null) {\n+inline frame::frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb) {\n@@ -105,1 +105,1 @@\n-  assert(_cb != nullptr || allow_cb_null, \"pc: \" INTPTR_FORMAT, p2i(pc));\n+  assert(_cb != nullptr, \"pc: \" INTPTR_FORMAT, p2i(pc));\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-  return frame(fr->sender_sp(), fr->link(), fr->sender_pc());\n+  return frame(fr->link(), fr->link(), fr->sender_pc());\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/os_bsd_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -155,10 +155,0 @@\n-\/\/ The \"Procedure Call Standard for the Arm 64-bit Architecture\" doesn't\n-\/\/ specify a location for the frame record within a stack frame (6.4.6).\n-\/\/ GCC currently chooses to save it at the top of the frame (lowest address).\n-\/\/ This means that using fr->sender_sp() to set the caller's frame _unextended_sp,\n-\/\/ as we do in x86, is wrong. Using fr->link() instead only makes sense for\n-\/\/ native frames. Setting a correct value for _unextended_sp is important\n-\/\/ if this value is later used to get that frame's caller. This will happen\n-\/\/ if we end up calling frame::sender_for_compiled_frame(), which will be the\n-\/\/ case if the _pc is associated with a CodeBlob that has a _frame_size > 0\n-\/\/ (nmethod, runtime stub, safepoint stub, etc).\n@@ -166,6 +156,1 @@\n-  address pc = fr->sender_pc();\n-  CodeBlob* cb = CodeCache::find_blob(pc);\n-  bool use_codeblob = cb != nullptr && cb->frame_size() > 0;\n-  assert(!use_codeblob || !Interpreter::contains(pc), \"should not be an interpreter frame\");\n-  intptr_t* sender_sp = use_codeblob ? (fr->link() + frame::metadata_words - cb->frame_size()) : fr->link();\n-  return frame(sender_sp, sender_sp, fr->link(), pc, cb, true \/* allow_cb_null *\/);\n+  return frame(fr->link(), fr->link(), fr->sender_pc());\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/os_linux_aarch64.cpp","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-#include \"compiler\/compilationMemoryStatistic.hpp\"\n-#include \"compiler\/compilerDirectives.hpp\"\n@@ -39,1 +37,0 @@\n-#include \"compiler\/compileTask.hpp\"\n@@ -448,3 +445,0 @@\n-\n-  CompilationMemoryStatisticMark cmsm(env()->task()->directive());\n-\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -49,3 +49,5 @@\n-  PerfClassTraceTime vmtimer(ClassLoader::perf_app_classload_time(),\n-                             THREAD->get_thread_stat()->perf_timers_addr(),\n-                             PerfClassTraceTime::CLASS_LOAD);\n+  {\n+    PerfClassTraceTime vmtimer(ClassLoader::perf_sys_class_lookup_time(),\n+                               THREAD->get_thread_stat()->perf_timers_addr(),\n+                               PerfClassTraceTime::CLASS_LOAD);\n+  }\n","filename":"src\/hotspot\/share\/cds\/unregisteredClasses.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -126,0 +126,1 @@\n+PerfCounter*    ClassLoader::_perf_sys_class_lookup_time = nullptr;\n@@ -1379,0 +1380,1 @@\n+    NEWPERFTICKCOUNTER(_perf_sys_class_lookup_time, SUN_CLS, \"lookupSysClassTime\");\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -171,0 +171,1 @@\n+  static PerfCounter* _perf_sys_class_lookup_time;\n@@ -291,0 +292,1 @@\n+  static PerfCounter* perf_sys_class_lookup_time()    { return _perf_sys_class_lookup_time; }\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -222,1 +222,1 @@\n-    _arena = new (mtSymbol) Arena(mtSymbol, Arena::Tag::tag_other, symbol_alloc_arena_size);\n+    _arena = new (mtSymbol) Arena(mtSymbol, symbol_alloc_arena_size);\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-#include \"runtime\/atomic.hpp\"\n@@ -48,2 +47,2 @@\n-CompiledICHolder* volatile InlineCacheBuffer::_pending_released = nullptr;\n-volatile int InlineCacheBuffer::_pending_count = 0;\n+CompiledICHolder* InlineCacheBuffer::_pending_released = nullptr;\n+int InlineCacheBuffer::_pending_count = 0;\n@@ -251,1 +250,1 @@\n-  CompiledICHolder* holder = Atomic::load(&_pending_released);\n+  CompiledICHolder* holder = _pending_released;\n@@ -253,1 +252,0 @@\n-  int count = 0;\n@@ -258,1 +256,1 @@\n-    count++;\n+    _pending_count--;\n@@ -260,2 +258,1 @@\n-  assert(pending_icholder_count() == count, \"wrong count\");\n-  Atomic::store(&_pending_count, 0);\n+  assert(_pending_count == 0, \"wrong count\");\n@@ -265,1 +262,1 @@\n-\/\/ not safe to free them until then since they might be visible to\n+\/\/ not safe to free them until them since they might be visible to\n@@ -268,14 +265,4 @@\n-  assert(icholder->next() == nullptr, \"multiple enqueue?\");\n-\n-  CompiledICHolder* old = Atomic::load(&_pending_released);\n-  for (;;) {\n-    icholder->set_next(old);\n-    \/\/ The only reader runs at a safepoint serially so there is no need for a more strict atomic.\n-    CompiledICHolder* cur = Atomic::cmpxchg(&_pending_released, old, icholder, memory_order_relaxed);\n-    if (cur == old) {\n-      break;\n-    }\n-    old = cur;\n-  }\n-  Atomic::inc(&_pending_count, memory_order_relaxed);\n-\n+  MutexLocker mex(InlineCacheBuffer_lock, Mutex::_no_safepoint_check_flag);\n+  icholder->set_next(_pending_released);\n+  _pending_released = icholder;\n+  _pending_count++;\n@@ -286,4 +273,0 @@\n-\n-int InlineCacheBuffer::pending_icholder_count() {\n-  return Atomic::load(&_pending_count);\n-}\n","filename":"src\/hotspot\/share\/code\/icBuffer.cpp","additions":10,"deletions":27,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -149,2 +149,2 @@\n-  static CompiledICHolder* volatile _pending_released;\n-  static volatile int _pending_count;\n+  static CompiledICHolder* _pending_released;\n+  static int _pending_count;\n@@ -179,1 +179,1 @@\n-  static int pending_icholder_count();\n+  static int pending_icholder_count() { return _pending_count; }\n","filename":"src\/hotspot\/share\/code\/icBuffer.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -98,1 +98,2 @@\n-VtableStub* volatile VtableStubs::_table[VtableStubs::N];\n+VtableStub* VtableStubs::_table[VtableStubs::N];\n+int VtableStubs::_number_of_vtable_stubs = 0;\n@@ -128,2 +129,0 @@\n-  assert(VtableStub::_receiver_location == VMRegImpl::Bad(), \"initialized multiple times?\");\n-\n@@ -133,0 +132,2 @@\n+    assert(_number_of_vtable_stubs == 0, \"potential performance bug: VtableStubs initialized more than once\");\n+    assert(is_power_of_2(int(N)), \"N must be a power of 2\");\n@@ -134,1 +135,1 @@\n-      Atomic::store(&_table[i], (VtableStub*)nullptr);\n+      _table[i] = nullptr;\n@@ -261,1 +262,1 @@\n-  VtableStub* s = Atomic::load(&_table[hash]);\n+  VtableStub* s = _table[hash];\n@@ -271,4 +272,4 @@\n-  \/\/ Insert s at the beginning of the corresponding list.\n-  s->set_next(Atomic::load(&_table[h]));\n-  \/\/ Make sure that concurrent readers not taking the mutex observe the writing of \"next\".\n-  Atomic::release_store(&_table[h], s);\n+  \/\/ enter s at the beginning of the corresponding list\n+  s->set_next(_table[h]);\n+  _table[h] = s;\n+  _number_of_vtable_stubs++;\n@@ -282,1 +283,1 @@\n-  for (s = Atomic::load(&_table[hash]); s != nullptr && s != stub; s = s->next()) {}\n+  for (s = _table[hash]; s != nullptr && s != stub; s = s->next()) {}\n@@ -301,0 +302,3 @@\n+  \/\/ Note: No locking needed since any change to the data structure\n+  \/\/       happens with an atomic store into it (we don't care about\n+  \/\/       consistency with the _number_of_vtable_stubs counter).\n@@ -302,1 +306,1 @@\n-    for (VtableStub* s = Atomic::load_acquire(&_table[i]); s != nullptr; s = s->next()) {\n+    for (VtableStub* s = _table[i]; s != nullptr; s = s->next()) {\n@@ -314,3 +318,4 @@\n-  for (int i = 0; i < N; i++) {\n-    for (VtableStub* s = Atomic::load_acquire(&_table[i]); s != nullptr; s = s->next()) {\n-      f(s);\n+    for (int i = 0; i < N; i++) {\n+        for (VtableStub* s = _table[i]; s != nullptr; s = s->next()) {\n+            f(s);\n+        }\n@@ -318,1 +323,0 @@\n-  }\n","filename":"src\/hotspot\/share\/code\/vtableStubs.cpp","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -83,2 +83,0 @@\n-  static_assert(is_power_of_2((int)N), \"N must be a power of 2\");\n-\n@@ -87,1 +85,2 @@\n-  static VtableStub* volatile _table[N];                  \/\/ table of existing stubs\n+  static VtableStub* _table[N];                  \/\/ table of existing stubs\n+  static int         _number_of_vtable_stubs;    \/\/ number of stubs created so far (for statistics)\n@@ -113,0 +112,1 @@\n+  static int         number_of_vtable_stubs() { return _number_of_vtable_stubs; }\n","filename":"src\/hotspot\/share\/code\/vtableStubs.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,451 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"logging\/logStream.hpp\"\n-#include \"compiler\/abstractCompiler.hpp\"\n-#include \"compiler\/compilationMemoryStatistic.hpp\"\n-#include \"compiler\/compilerDirectives.hpp\"\n-#include \"compiler\/compileTask.hpp\"\n-#include \"compiler\/compilerDefinitions.hpp\"\n-#include \"compiler\/compilerThread.hpp\"\n-#include \"memory\/arena.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"oops\/symbol.hpp\"\n-#ifdef COMPILER2\n-#include \"opto\/node.hpp\" \/\/ compile.hpp is not self-contained\n-#include \"opto\/compile.hpp\"\n-#endif\n-#include \"services\/nmtCommon.hpp\"\n-#include \"runtime\/mutexLocker.hpp\"\n-#include \"runtime\/os.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/ostream.hpp\"\n-#include \"utilities\/quickSort.hpp\"\n-#include \"utilities\/resourceHash.hpp\"\n-\n-\n-ArenaStatCounter::ArenaStatCounter() :\n-  _current(0), _start(0), _peak(0),\n-  _na(0), _ra(0),\n-  _na_at_peak(0), _ra_at_peak(0), _live_nodes_at_peak(0)\n-{}\n-\n-size_t ArenaStatCounter::peak_since_start() const {\n-  return _peak > _start ? _peak - _start : 0;\n-}\n-\n-void ArenaStatCounter::start() {\n-  _peak = _start = _current;\n-}\n-\n-void ArenaStatCounter::update_c2_node_count() {\n-#ifdef COMPILER2\n-  CompilerThread* const th = Thread::current()->as_Compiler_thread();\n-  const CompileTask* const task = th->task();\n-  if (task != nullptr &&\n-      th->task()->compiler() != nullptr &&\n-      th->task()->compiler()->type() == compiler_c2) {\n-    const Compile* const comp = Compile::current();\n-    if (comp != nullptr) {\n-      _live_nodes_at_peak = comp->live_nodes();\n-    }\n-  }\n-#endif\n-}\n-\n-\/\/ Account an arena allocation or de-allocation.\n-bool ArenaStatCounter::account(ssize_t delta, int tag) {\n-  bool rc = false;\n-#ifdef ASSERT\n-  \/\/ Note: if this fires, we free more arena memory under the scope of the\n-  \/\/ CompilationMemoryHistoryMark than we allocate. This cannot be since we\n-  \/\/ assume arena allocations in CompilerThread to be stack bound and symmetric.\n-  assert(delta >= 0 || ((ssize_t)_current + delta) >= 0,\n-         \"Negative overflow (d=%zd %zu %zu %zu)\", delta, _current, _start, _peak);\n-#endif\n-  \/\/ Update totals\n-  _current += delta;\n-  \/\/ Update detail counter\n-  switch ((Arena::Tag)tag) {\n-    case Arena::Tag::tag_ra: _ra += delta; break;\n-    case Arena::Tag::tag_node: _na += delta; break;\n-    default: \/\/ ignore\n-      break;\n-  };\n-  \/\/ Did we reach a peak?\n-  if (_current > _peak) {\n-    _peak = _current;\n-    assert(delta > 0, \"Sanity (%zu %zu %zu)\", _current, _start, _peak);\n-    _na_at_peak = _na;\n-    _ra_at_peak = _ra;\n-    update_c2_node_count();\n-    rc = true;\n-  }\n-  return rc;\n-}\n-\n-void ArenaStatCounter::print_on(outputStream* st) const {\n-  st->print(\"%zu [na %zu ra %zu]\", peak_since_start(), _na_at_peak, _ra_at_peak);\n-#ifdef ASSERT\n-  st->print(\" (%zu->%zu->%zu)\", _start, _peak, _current);\n-#endif\n-}\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ Backend\n-\n-class FullMethodName {\n-  Symbol* const _k;\n-  Symbol* const _m;\n-  Symbol* const _s;\n-\n-public:\n-\n-  FullMethodName(Symbol* k, Symbol* m, Symbol* s) : _k(k), _m(m), _s(s) {}\n-  FullMethodName(const FullMethodName& o) : _k(o._k), _m(o._m), _s(o._s) {}\n-\n-  void make_permanent() {\n-    _k->make_permanent();\n-    _m->make_permanent();\n-    _s->make_permanent();\n-  }\n-\n-  static unsigned compute_hash(const FullMethodName& n) {\n-    return Symbol::compute_hash(n._k) ^\n-        Symbol::compute_hash(n._m) ^\n-        Symbol::compute_hash(n._s);\n-  }\n-\n-  char* as_C_string(char* buf, size_t len) const {\n-    stringStream ss(buf, len);\n-    ResourceMark rm;\n-    ss.print_raw(_k->as_C_string());\n-    ss.print_raw(\"::\");\n-    ss.print_raw(_m->as_C_string());\n-    ss.put('(');\n-    ss.print_raw(_s->as_C_string());\n-    ss.put(')');\n-    return buf;\n-  }\n-\n-  bool equals(const FullMethodName& b) const {\n-    return _k == b._k && _m == b._m && _s == b._s;\n-  }\n-\n-  bool operator== (const FullMethodName& other) const { return equals(other); }\n-};\n-\n-\/\/ Note: not mtCompiler since we don't want to change what we measure\n-class MemStatEntry : public CHeapObj<mtInternal> {\n-  const FullMethodName _method;\n-  CompilerType _comptype;\n-  double _time;\n-  \/\/ How often this has been recompiled.\n-  int _num_recomp;\n-  \/\/ Compiling thread. Only for diagnostic purposes. Thread may not be alive anymore.\n-  const Thread* _thread;\n-\n-  size_t _total;\n-  size_t _na_at_peak;\n-  size_t _ra_at_peak;\n-  unsigned _live_nodes_at_peak;\n-\n-public:\n-\n-  MemStatEntry(FullMethodName method)\n-    : _method(method), _comptype(compiler_c1),\n-      _time(0), _num_recomp(0), _thread(nullptr),\n-      _total(0), _na_at_peak(0), _ra_at_peak(0), _live_nodes_at_peak(0) {\n-  }\n-\n-  void set_comptype(CompilerType comptype) { _comptype = comptype; }\n-  void set_current_time() { _time = os::elapsedTime(); }\n-  void set_current_thread() { _thread = Thread::current(); }\n-  void inc_recompilation() { _num_recomp++; }\n-\n-  void set_total(size_t n) { _total = n; }\n-  void set_na_at_peak(size_t n) { _na_at_peak = n; }\n-  void set_ra_at_peak(size_t n) { _ra_at_peak = n; }\n-  void set_live_nodes_at_peak(unsigned n) { _live_nodes_at_peak = n; }\n-\n-  size_t total() const { return _total; }\n-\n-  static void print_legend(outputStream* st) {\n-    st->print_cr(\"Legend:\");\n-    st->print_cr(\"  total  : memory allocated via arenas while compiling\");\n-    st->print_cr(\"  NA     : ...how much in node arenas (if c2)\");\n-    st->print_cr(\"  RA     : ...how much in resource areas\");\n-    st->print_cr(\"  #nodes : ...how many nodes (if c2)\");\n-    st->print_cr(\"  time   : time of last compilation (sec)\");\n-    st->print_cr(\"  type   : compiler type\");\n-    st->print_cr(\"  #rc    : how often recompiled\");\n-    st->print_cr(\"  thread : compiler thread\");\n-  }\n-\n-  static void print_header(outputStream* st) {\n-    st->print_cr(\"total     NA        RA        #nodes  time    type  #rc thread              method\");\n-  }\n-\n-  void print_on(outputStream* st, bool human_readable) const {\n-    int col = 0;\n-\n-    \/\/ Total\n-    if (human_readable) {\n-      st->print(PROPERFMT \" \", PROPERFMTARGS(_total));\n-    } else {\n-      st->print(\"%zu \", _total);\n-    }\n-    col += 10; st->fill_to(col);\n-\n-    \/\/ NA\n-    if (human_readable) {\n-      st->print(PROPERFMT \" \", PROPERFMTARGS(_na_at_peak));\n-    } else {\n-      st->print(\"%zu \", _na_at_peak);\n-    }\n-    col += 10; st->fill_to(col);\n-\n-    \/\/ RA\n-    if (human_readable) {\n-      st->print(PROPERFMT \" \", PROPERFMTARGS(_ra_at_peak));\n-    } else {\n-      st->print(\"%zu \", _ra_at_peak);\n-    }\n-    col += 10; st->fill_to(col);\n-\n-    \/\/ Number of Nodes when memory peaked\n-    st->print(\"%u \", _live_nodes_at_peak);\n-    col += 8; st->fill_to(col);\n-\n-    \/\/ TimeStamp\n-    st->print(\"%.3f \", _time);\n-    col += 8; st->fill_to(col);\n-\n-    \/\/ Type\n-    st->print(\"%s \", compilertype2name(_comptype));\n-    col += 6; st->fill_to(col);\n-\n-    \/\/ Recomp\n-    st->print(\"%u \", _num_recomp);\n-    col += 4; st->fill_to(col);\n-\n-    \/\/ Thread\n-    st->print(PTR_FORMAT \"  \", p2i(_thread));\n-\n-    \/\/ MethodName\n-    char buf[1024];\n-    st->print(\"%s \", _method.as_C_string(buf, sizeof(buf)));\n-    st->cr();\n-  }\n-\n-  int compare_by_size(const MemStatEntry* b) const {\n-    const size_t x1 = b->_total;\n-    const size_t x2 = _total;\n-    return x1 < x2 ? -1 : x1 == x2 ? 0 : 1;\n-  }\n-\n-  bool equals(const FullMethodName& b) const {\n-    return _method.equals(b);\n-  }\n-};\n-\n-class MemStatTable :\n-    public ResourceHashtable<FullMethodName, MemStatEntry*, 7919, AnyObj::C_HEAP,\n-                             mtInternal, FullMethodName::compute_hash>\n-{\n-public:\n-\n-  void add(const FullMethodName& fmn, CompilerType comptype,\n-           size_t total, size_t na_at_peak, size_t ra_at_peak,\n-           unsigned live_nodes_at_peak) {\n-    assert_lock_strong(NMTCompilationCostHistory_lock);\n-\n-    MemStatEntry** pe = get(fmn);\n-    MemStatEntry* e = nullptr;\n-    if (pe == nullptr) {\n-      e = new MemStatEntry(fmn);\n-      put(fmn, e);\n-    } else {\n-      \/\/ Update existing entry\n-      e = *pe;\n-      assert(e != nullptr, \"Sanity\");\n-    }\n-    e->set_current_time();\n-    e->set_current_thread();\n-    e->set_comptype(comptype);\n-    e->inc_recompilation();\n-    e->set_total(total);\n-    e->set_na_at_peak(na_at_peak);\n-    e->set_ra_at_peak(ra_at_peak);\n-    e->set_live_nodes_at_peak(live_nodes_at_peak);\n-  }\n-\n-  \/\/ Returns a C-heap-allocated SortMe array containing all entries from the table,\n-  \/\/ optionally filtered by entry size\n-  MemStatEntry** calc_flat_array(int& num, size_t min_size) {\n-    assert_lock_strong(NMTCompilationCostHistory_lock);\n-\n-    const int num_all = number_of_entries();\n-    MemStatEntry** flat = NEW_C_HEAP_ARRAY(MemStatEntry*, num_all, mtInternal);\n-    int i = 0;\n-    auto do_f = [&] (const FullMethodName& ignored, MemStatEntry* e) {\n-      if (e->total() >= min_size) {\n-        flat[i] = e;\n-        assert(i < num_all, \"Sanity\");\n-        i ++;\n-      }\n-    };\n-    iterate_all(do_f);\n-    if (min_size == 0) {\n-      assert(i == num_all, \"Sanity\");\n-    } else {\n-      assert(i <= num_all, \"Sanity\");\n-    }\n-    num = i;\n-    return flat;\n-  }\n-};\n-\n-bool CompilationMemoryStatistic::_enabled = false;\n-\n-static MemStatTable* _the_table = nullptr;\n-\n-void CompilationMemoryStatistic::initialize() {\n-  assert(_enabled == false && _the_table == nullptr, \"Only once\");\n-  _the_table = new (mtCompiler) MemStatTable;\n-  _enabled = true;\n-  log_info(compilation, alloc)(\"Compilation memory statistic enabled\");\n-}\n-\n-void CompilationMemoryStatistic::on_start_compilation() {\n-  assert(enabled(), \"Not enabled?\");\n-  Thread::current()->as_Compiler_thread()->arena_stat()->start();\n-}\n-\n-void CompilationMemoryStatistic::on_end_compilation() {\n-  assert(enabled(), \"Not enabled?\");\n-  ResourceMark rm;\n-  CompilerThread* const th = Thread::current()->as_Compiler_thread();\n-  const ArenaStatCounter* const arena_stat = th->arena_stat();\n-  const CompilerType ct = th->task()->compiler()->type();\n-\n-  const Method* const m = th->task()->method();\n-  FullMethodName fmn(m->klass_name(), m->name(), m->signature());\n-  fmn.make_permanent();\n-\n-  const DirectiveSet* directive = th->task()->directive();\n-  assert(directive->should_collect_memstat(), \"Only call if memstat is enabled\");\n-  const bool print = directive->should_print_memstat();\n-\n-  if (print) {\n-    char buf[1024];\n-    fmn.as_C_string(buf, sizeof(buf));\n-    tty->print(\"%s Arena usage %s: \", compilertype2name(ct), buf);\n-    arena_stat->print_on(tty);\n-    tty->cr();\n-  }\n-  {\n-    MutexLocker ml(NMTCompilationCostHistory_lock, Mutex::_no_safepoint_check_flag);\n-    assert(_the_table != nullptr, \"not initialized\");\n-\n-    _the_table->add(fmn, ct,\n-                    arena_stat->peak_since_start(), \/\/ total\n-                    arena_stat->na_at_peak(),\n-                    arena_stat->ra_at_peak(),\n-                    arena_stat->live_nodes_at_peak());\n-  }\n-}\n-\n-void CompilationMemoryStatistic::on_arena_change(ssize_t diff, const Arena* arena) {\n-  assert(enabled(), \"Not enabled?\");\n-  CompilerThread* const th = Thread::current()->as_Compiler_thread();\n-  th->arena_stat()->account(diff, (int)arena->get_tag());\n-}\n-\n-static inline ssize_t diff_entries_by_size(const MemStatEntry* e1, const MemStatEntry* e2) {\n-  return e1->compare_by_size(e2);\n-}\n-\n-void CompilationMemoryStatistic::print_all_by_size(outputStream* st, bool human_readable, size_t min_size) {\n-  st->print_cr(\"Compilation memory statistics\");\n-\n-  if (!enabled()) {\n-    st->print_cr(\"(unavailable)\");\n-    return;\n-  }\n-\n-  st->cr();\n-\n-  MemStatEntry::print_legend(st);\n-  st->cr();\n-\n-  if (min_size > 0) {\n-    st->print_cr(\" (cutoff: %zu bytes)\", min_size);\n-  }\n-  st->cr();\n-\n-  MemStatEntry::print_header(st);\n-\n-  MemStatEntry** filtered = nullptr;\n-  {\n-    MutexLocker ml(NMTCompilationCostHistory_lock, Mutex::_no_safepoint_check_flag);\n-\n-    if (_the_table != nullptr) {\n-      \/\/ We sort with quicksort\n-      int num = 0;\n-      filtered = _the_table->calc_flat_array(num, min_size);\n-      if (min_size > 0) {\n-        st->print_cr(\"(%d\/%d)\", num, _the_table->number_of_entries());\n-      }\n-      if (num > 0) {\n-        QuickSort::sort(filtered, num, diff_entries_by_size, false);\n-        \/\/ Now print. Has to happen under lock protection too, since entries may be changed.\n-        for (int i = 0; i < num; i ++) {\n-          filtered[i]->print_on(st, human_readable);\n-        }\n-      } else {\n-        st->print_cr(\"No entries.\");\n-      }\n-    } else {\n-      st->print_cr(\"Not initialized.\");\n-    }\n-  } \/\/ locked\n-\n-  FREE_C_HEAP_ARRAY(Entry, filtered);\n-}\n-\n-CompilationMemoryStatisticMark::CompilationMemoryStatisticMark(const DirectiveSet* directive)\n-  : _active(directive->should_collect_memstat()) {\n-  if (_active) {\n-    CompilationMemoryStatistic::on_start_compilation();\n-  }\n-}\n-CompilationMemoryStatisticMark::~CompilationMemoryStatisticMark() {\n-  if (_active) {\n-    CompilationMemoryStatistic::on_end_compilation();\n-  }\n-}\n","filename":"src\/hotspot\/share\/compiler\/compilationMemoryStatistic.cpp","additions":0,"deletions":451,"binary":false,"changes":451,"status":"deleted"},{"patch":"@@ -1,103 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_COMPILER_COMPILATIONMEMORYSTATISTIC_HPP\n-#define SHARE_COMPILER_COMPILATIONMEMORYSTATISTIC_HPP\n-\n-#include \"compiler\/compilerDefinitions.hpp\"\n-#include \"memory\/allocation.hpp\"\n-#include \"memory\/allStatic.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-class outputStream;\n-class Symbol;\n-class DirectiveSet;\n-\n-\/\/ Counters for allocations from one arena\n-class ArenaStatCounter : public CHeapObj<mtCompiler> {\n-  \/\/ Current bytes, total\n-  size_t _current;\n-  \/\/ bytes when compilation started\n-  size_t _start;\n-  \/\/ bytes at last peak, total\n-  size_t _peak;\n-  \/\/ Current bytes used for node arenas, total\n-  size_t _na;\n-  \/\/ Current bytes used for resource areas\n-  size_t _ra;\n-\n-  \/\/ Peak composition:\n-  \/\/ Size of node arena when total peaked (c2 only)\n-  size_t _na_at_peak;\n-  \/\/ Size of resource area when total peaked\n-  size_t _ra_at_peak;\n-  \/\/ Number of live nodes when total peaked (c2 only)\n-  unsigned _live_nodes_at_peak;\n-\n-  void update_c2_node_count();\n-\n-public:\n-  ArenaStatCounter();\n-\n-  \/\/ Size of peak since last compilation\n-  size_t peak_since_start() const;\n-\n-  \/\/ Peak details\n-  size_t na_at_peak() const { return _na_at_peak; }\n-  size_t ra_at_peak() const { return _ra_at_peak; }\n-  unsigned live_nodes_at_peak() const { return _live_nodes_at_peak; }\n-\n-  \/\/ Mark the start of a compilation.\n-  void start();\n-\n-  \/\/ Account an arena allocation or de-allocation.\n-  \/\/ Returns true if new peak reached\n-  bool account(ssize_t delta, int tag);\n-\n-  void set_live_nodes_at_peak(unsigned i) { _live_nodes_at_peak = i; }\n-  void print_on(outputStream* st) const;\n-};\n-\n-class CompilationMemoryStatistic : public AllStatic {\n-  static bool _enabled;\n-public:\n-  static void initialize();\n-  \/\/ true if CollectMemStat or PrintMemStat has been enabled for any method\n-  static bool enabled() { return _enabled; }\n-  static void on_start_compilation();\n-  static void on_end_compilation();\n-  static void on_arena_change(ssize_t diff, const Arena* arena);\n-  static void print_all_by_size(outputStream* st, bool human_readable, size_t minsize);\n-};\n-\n-\/\/ RAII object to wrap one compilation\n-class CompilationMemoryStatisticMark {\n-  const bool _active;\n-public:\n-  CompilationMemoryStatisticMark(const DirectiveSet* directive);\n-  ~CompilationMemoryStatisticMark();\n-};\n-\n-#endif \/\/ SHARE_COMPILER_COMPILATIONMEMORYSTATISTIC_HPP\n","filename":"src\/hotspot\/share\/compiler\/compilationMemoryStatistic.hpp","additions":0,"deletions":103,"binary":false,"changes":103,"status":"deleted"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"compiler\/compilationMemoryStatistic.hpp\"\n@@ -654,4 +653,0 @@\n-  if (CompilerOracle::should_collect_memstat()) {\n-    CompilationMemoryStatistic::initialize();\n-  }\n-\n@@ -1703,1 +1698,1 @@\n-  if (!UseJVMCINativeLibrary && comp->is_jvmci() && !task->should_wait_for_compilation()) {\n+  if (comp->is_jvmci() && !task->should_wait_for_compilation()) {\n@@ -1705,3 +1700,0 @@\n-    \/\/ Note that libjvmci should not pre-emptively unblock\n-    \/\/ a thread waiting for a compilation as it does not call\n-    \/\/ Java code and so is not deadlock prone like jarjvmci.\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-inline const char* compilertype2name(CompilerType t) { return (uint)t < compiler_number_of_types ? compilertype2name_tab[t] : \"invalid\"; }\n+inline const char* compilertype2name(CompilerType t) { return (uint)t < compiler_number_of_types ? compilertype2name_tab[t] : nullptr; }\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -205,8 +205,0 @@\n-bool DirectiveSet::should_collect_memstat() const {\n-  return MemStatOption > 0;\n-}\n-\n-bool DirectiveSet::should_print_memstat() const {\n-  return MemStatOption == (uintx)MemStatAction::print;\n-}\n-\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-    cflags(MemStat,                 uintx, 0, MemStat) \\\n@@ -135,2 +134,0 @@\n-  bool should_collect_memstat() const;\n-  bool should_print_memstat() const;\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -104,1 +104,0 @@\n-static bool print_final_memstat_report = false;\n@@ -329,1 +328,0 @@\n-\n@@ -460,9 +458,0 @@\n-\/\/ Tells whether there are any methods to collect memory statistics for\n-bool CompilerOracle::should_collect_memstat() {\n-  return has_command(CompileCommand::MemStat);\n-}\n-\n-bool CompilerOracle::should_print_final_memstat_report() {\n-  return print_final_memstat_report;\n-}\n-\n@@ -637,16 +626,0 @@\n-static bool parseEnumValueAsUintx(enum CompileCommand option, const char* line, uintx& value, int& bytes_read, char* errorbuf, const int buf_size) {\n-  if (option == CompileCommand::MemStat) {\n-    if (strncasecmp(line, \"collect\", 7) == 0) {\n-      value = (uintx)MemStatAction::collect;\n-    } else if (strncasecmp(line, \"print\", 5) == 0) {\n-      value = (uintx)MemStatAction::print;\n-      print_final_memstat_report = true;\n-    } else {\n-      jio_snprintf(errorbuf, buf_size, \"MemStat: invalid value expected 'collect' or 'print' (omitting value means 'collect')\");\n-    }\n-    return true; \/\/ handled\n-  }\n-  return false;\n-#undef HANDLE_VALUE\n-}\n-\n@@ -672,7 +645,1 @@\n-    \/\/ Is it a named enum?\n-    bool success = parseEnumValueAsUintx(option, line, value, bytes_read, errorbuf, buf_size);\n-    if (!success) {\n-      \/\/ Is it a raw number?\n-      success = (sscanf(line, \"\" UINTX_FORMAT \"%n\", &value, &bytes_read) == 1);\n-    }\n-    if (success) {\n+    if (sscanf(line, \"\" UINTX_FORMAT \"%n\", &value, &bytes_read) == 1) {\n@@ -950,0 +917,1 @@\n+      \/\/ if this is a bool option this implies true\n@@ -951,1 +919,0 @@\n-        \/\/ if this is a bool option this implies true\n@@ -954,4 +921,0 @@\n-      } else if (option == CompileCommand::MemStat) {\n-        \/\/ MemStat default action is to collect data but to not print\n-        register_command(matcher, option, (uintx)MemStatAction::collect);\n-        return true;\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":2,"deletions":39,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-  option(MemStat, \"MemStat\", Uintx) \\\n@@ -117,4 +116,0 @@\n-enum class MemStatAction {\n-  collect = 1, print = 2\n-};\n-\n@@ -159,4 +154,0 @@\n-  \/\/ Tells whether there are any methods to (collect|collect+print) memory statistics for\n-  static bool should_collect_memstat();\n-  static bool should_print_final_memstat_report();\n-\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"compiler\/compilationMemoryStatistic.hpp\"\n@@ -43,1 +42,0 @@\n-  _arena_stat = CompilationMemoryStatistic::enabled() ? new ArenaStatCounter : nullptr;\n@@ -56,1 +54,0 @@\n-  delete _arena_stat;\n","filename":"src\/hotspot\/share\/compiler\/compilerThread.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-class AbstractCompiler;\n-class ArenaStatCounter;\n@@ -33,0 +31,1 @@\n+class AbstractCompiler;\n@@ -58,2 +57,0 @@\n-  ArenaStatCounter*     _arena_stat;\n-\n@@ -87,1 +84,0 @@\n-  ArenaStatCounter* arena_stat() const           { return _arena_stat; }\n","filename":"src\/hotspot\/share\/compiler\/compilerThread.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"gc\/serial\/serialHeap.hpp\"\n@@ -34,0 +33,1 @@\n+#include \"gc\/shared\/genCollectedHeap.hpp\"\n@@ -61,3 +61,3 @@\n-  SerialHeap* serial_heap = SerialHeap::heap();\n-  if (serial_heap->is_young_gen(this)) {\n-    return serial_heap->young_gen_spec()->init_size();\n+  GenCollectedHeap* gch = GenCollectedHeap::heap();\n+  if (gch->is_young_gen(this)) {\n+    return gch->young_gen_spec()->init_size();\n@@ -65,1 +65,1 @@\n-  return serial_heap->old_gen_spec()->init_size();\n+  return gch->old_gen_spec()->init_size();\n@@ -89,1 +89,1 @@\n-               SerialHeap::heap()->is_young_gen(this) ? \"young\" : \"old\" ,\n+               GenCollectedHeap::heap()->is_young_gen(this) ? \"young\" : \"old\" ,\n@@ -119,2 +119,2 @@\n-  if (SerialHeap::heap()->is_young_gen(this)) {\n-    old_avail = SerialHeap::heap()->old_gen()->contiguous_available();\n+  if (GenCollectedHeap::heap()->is_young_gen(this)) {\n+    old_avail = GenCollectedHeap::heap()->old_gen()->contiguous_available();\n@@ -138,1 +138,1 @@\n-  if (SerialHeap::heap()->promotion_should_fail()) {\n+  if (GenCollectedHeap::heap()->promotion_should_fail()) {\n@@ -239,0 +239,2 @@\n+#if INCLUDE_SERIALGC\n+\n@@ -269,0 +271,2 @@\n+\n+#endif \/\/ INCLUDE_SERIALGC\n","filename":"src\/hotspot\/share\/gc\/serial\/generation.cpp","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+class GenCollectedHeap;\n@@ -292,0 +293,1 @@\n+#if INCLUDE_SERIALGC\n@@ -298,0 +300,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/gc\/serial\/generation.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-  HeapWord* saved_mark_word() const  { return _saved_mark_word; }\n+  virtual HeapWord* saved_mark_word() const  { return _saved_mark_word; }\n@@ -95,1 +95,1 @@\n-  bool obj_allocated_since_save_marks(const oop obj) const {\n+  virtual bool obj_allocated_since_save_marks(const oop obj) const {\n@@ -181,1 +181,1 @@\n-  HeapWord* block_start(const void* p);\n+  virtual HeapWord* block_start(const void* p);\n@@ -194,1 +194,1 @@\n-  bool obj_is_alive(const HeapWord* addr) const;\n+  virtual bool obj_is_alive(const HeapWord* addr) const;\n@@ -209,1 +209,1 @@\n-  void print() const;\n+  virtual void print() const;\n@@ -211,2 +211,2 @@\n-  void print_short() const;\n-  void print_short_on(outputStream* st) const;\n+  virtual void print_short() const;\n+  virtual void print_short_on(outputStream* st) const;\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -533,1 +533,1 @@\n-    return BarrierSetC2::load_at_resolved(access, val_type);\n+    return BarrierSetC2::load_at_resolved(access, val_type);;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-      if (C->failing()) return false;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -356,0 +356,4 @@\n+double ShenandoahAllocationRate::instantaneous_rate(size_t allocated) const {\n+  return instantaneous_rate(os::elapsedTime(), allocated);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+  double instantaneous_rate(size_t allocated) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -223,1 +223,1 @@\n-#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHCLOSURES_INLINE_HPP\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHCLOSURES_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahClosures.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,64 @@\n+ShenandoahParallelCodeCacheIterator::ShenandoahParallelCodeCacheIterator(const GrowableArray<CodeHeap*>* heaps) {\n+  _length = heaps->length();\n+  _iters = NEW_C_HEAP_ARRAY(ShenandoahParallelCodeHeapIterator, _length, mtGC);\n+  for (int h = 0; h < _length; h++) {\n+    _iters[h] = ShenandoahParallelCodeHeapIterator(heaps->at(h));\n+  }\n+}\n+\n+ShenandoahParallelCodeCacheIterator::~ShenandoahParallelCodeCacheIterator() {\n+  FREE_C_HEAP_ARRAY(ParallelCodeHeapIterator, _iters);\n+}\n+\n+void ShenandoahParallelCodeCacheIterator::parallel_blobs_do(CodeBlobClosure* f) {\n+  for (int c = 0; c < _length; c++) {\n+    _iters[c].parallel_blobs_do(f);\n+  }\n+}\n+\n+ShenandoahParallelCodeHeapIterator::ShenandoahParallelCodeHeapIterator(CodeHeap* heap) :\n+        _heap(heap), _claimed_idx(0), _finished(false) {\n+}\n+\n+void ShenandoahParallelCodeHeapIterator::parallel_blobs_do(CodeBlobClosure* f) {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"Must be at safepoint\");\n+\n+  \/*\n+   * Parallel code heap walk.\n+   *\n+   * This code makes all threads scan all code heaps, but only one thread would execute the\n+   * closure on given blob. This is achieved by recording the \"claimed\" blocks: if a thread\n+   * had claimed the block, it can process all blobs in it. Others have to fast-forward to\n+   * next attempt without processing.\n+   *\n+   * Late threads would return immediately if iterator is finished.\n+   *\/\n+\n+  if (_finished) {\n+    return;\n+  }\n+\n+  int stride = 256; \/\/ educated guess\n+  int stride_mask = stride - 1;\n+  assert (is_power_of_2(stride), \"sanity\");\n+\n+  int count = 0;\n+  bool process_block = true;\n+\n+  for (CodeBlob *cb = CodeCache::first_blob(_heap); cb != nullptr; cb = CodeCache::next_blob(_heap, cb)) {\n+    int current = count++;\n+    if ((current & stride_mask) == 0) {\n+      process_block = (current >= _claimed_idx) &&\n+                      (Atomic::cmpxchg(&_claimed_idx, current, current + stride, memory_order_relaxed) == current);\n+    }\n+    if (process_block) {\n+      f->do_code_blob(cb);\n+#ifdef ASSERT\n+      if (cb->is_nmethod())\n+        Universe::heap()->verify_nmethod((nmethod*)cb);\n+#endif\n+    }\n+  }\n+\n+  _finished = true;\n+}\n@@ -242,0 +306,1 @@\n+        _par_iterator(CodeCache::heaps()),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCodeRoots.cpp","additions":65,"deletions":0,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -42,0 +42,27 @@\n+class ShenandoahParallelCodeHeapIterator {\n+  friend class CodeCache;\n+private:\n+  CodeHeap*     _heap;\n+  shenandoah_padding(0);\n+  volatile int  _claimed_idx;\n+  volatile bool _finished;\n+  shenandoah_padding(1);\n+public:\n+  ShenandoahParallelCodeHeapIterator(CodeHeap* heap);\n+  void parallel_blobs_do(CodeBlobClosure* f);\n+};\n+\n+class ShenandoahParallelCodeCacheIterator {\n+  friend class CodeCache;\n+private:\n+  ShenandoahParallelCodeHeapIterator* _iters;\n+  int                       _length;\n+\n+  NONCOPYABLE(ShenandoahParallelCodeCacheIterator);\n+\n+public:\n+  ShenandoahParallelCodeCacheIterator(const GrowableArray<CodeHeap*>* heaps);\n+  ~ShenandoahParallelCodeCacheIterator();\n+  void parallel_blobs_do(CodeBlobClosure* f);\n+};\n+\n@@ -45,0 +72,2 @@\n+  ShenandoahParallelCodeCacheIterator _par_iterator;\n+  ShenandoahSharedFlag _seq_claimed;\n@@ -62,0 +91,1 @@\n+  static void flush_nmethod(nmethod* nm);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCodeRoots.hpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+    ShenandoahObjToScanQueue* q = _cm->get_queue(worker_id);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -282,1 +282,1 @@\n-  }\n+  };\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+    ShenandoahHeap* heap = ShenandoahHeap::heap();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGC.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1896,0 +1896,8 @@\n+address ShenandoahHeap::cancelled_gc_addr() {\n+  return (address) ShenandoahHeap::heap()->_cancelled_gc.addr_of();\n+}\n+\n+address ShenandoahHeap::gc_state_addr() {\n+  return (address) ShenandoahHeap::heap()->_gc_state.addr_of();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -298,0 +298,1 @@\n+  static address gc_state_addr();\n@@ -318,1 +319,1 @@\n-\n+  inline bool is_gc_in_progress_mask(uint mask) const;\n@@ -338,0 +339,1 @@\n+  static address cancelled_gc_addr();\n@@ -357,0 +359,1 @@\n+  void prepare_evacuation(bool concurrent);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -386,0 +386,4 @@\n+inline bool ShenandoahHeap::is_gc_in_progress_mask(uint mask) const {\n+  return _gc_state.is_set(mask);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHJFRSUPPORT_HPP\n+#endif \/\/ SHARE_VM_GC_SHENANDOAH_SHENANDOAHJFRSUPPORT_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahJfrSupport.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+class ShenandoahCMDrainMarkingStackClosure;\n+\n@@ -37,0 +39,2 @@\n+  friend class ShenandoahCMDrainMarkingStackClosure;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,0 +55,33 @@\n+class ShenandoahHasCSetOopClosure : public OopClosure {\n+private:\n+  ShenandoahHeap* const _heap;\n+  bool                  _has_cset_oops;\n+\n+public:\n+  ShenandoahHasCSetOopClosure(ShenandoahHeap *heap) :\n+    _heap(heap),\n+    _has_cset_oops(false) {\n+  }\n+\n+  bool has_cset_oops() const {\n+    return _has_cset_oops;\n+  }\n+\n+  void do_oop(oop* p) {\n+    oop value = RawAccess<>::oop_load(p);\n+    if (!_has_cset_oops && _heap->in_collection_set(value)) {\n+      _has_cset_oops = true;\n+    }\n+  }\n+\n+  void do_oop(narrowOop* p) {\n+    ShouldNotReachHere();\n+  }\n+};\n+\n+bool ShenandoahNMethod::has_cset_oops(ShenandoahHeap *heap) {\n+  ShenandoahHasCSetOopClosure cl(heap);\n+  oops_do(&cl);\n+  return cl.has_cset_oops();\n+}\n+\n@@ -179,0 +212,4 @@\n+\n+  bool has_oops() {\n+    return !_oops.is_empty();\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.cpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -58,0 +58,6 @@\n+  bool has_cset_oops(ShenandoahHeap* heap);\n+\n+  inline int oop_count() const;\n+  inline bool has_oops() const;\n+\n+  inline void mark_unregistered();\n@@ -74,0 +80,1 @@\n+  bool has_non_immed_oops() const { return _has_non_immed_oops; }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -42,0 +42,12 @@\n+int ShenandoahNMethod::oop_count() const {\n+  return _oops_count + static_cast<int>(nm()->oops_end() - nm()->oops_begin());\n+}\n+\n+bool ShenandoahNMethod::has_oops() const {\n+  return oop_count() > 0;\n+}\n+\n+void ShenandoahNMethod::mark_unregistered() {\n+  _unregistered = true;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.inline.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -405,1 +405,1 @@\n-void ShenandoahReferenceProcessor::process_references(ShenandoahRefProcThreadLocal& refproc_data, uint worker_id) {\n+void ShenandoahReferenceProcessor::process_references(ShenandoahRefProcThreadLocal& refproc_data, uint worker_id) {;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+  _phase(phase),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -137,0 +137,1 @@\n+  const ShenandoahPhaseTimings::Phase _phase;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2439,10 +2439,0 @@\n-C2V_VMENTRY(void, clearOopHandle, (JNIEnv* env, jobject, jlong oop_handle))\n-  if (oop_handle == 0L) {\n-    JVMCI_THROW(NullPointerException);\n-  }\n-  \/\/ Assert before nulling out, for better debugging.\n-  assert(JVMCIRuntime::is_oop_handle(oop_handle), \"precondition\");\n-  oop* oop_ptr = (oop*) oop_handle;\n-  NativeAccess<>::oop_store(oop_ptr, (oop) nullptr);\n-C2V_END\n-\n@@ -3273,1 +3263,0 @@\n-  {CC \"clearOopHandle\",                               CC \"(J)V\",                                                                            FN_PTR(clearOopHandle)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -890,7 +890,0 @@\n-#ifdef ASSERT\n-bool JVMCIRuntime::is_oop_handle(jlong handle) {\n-  const oop* ptr = (oop*) handle;\n-  return object_handles()->allocation_status(ptr) == OopStorage::ALLOCATED_ENTRY;\n-}\n-#endif\n-\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -320,3 +320,0 @@\n-#ifdef ASSERT\n-  static bool is_oop_handle(jlong handle);\n-#endif\n@@ -326,0 +323,2 @@\n+  \/\/ The method also resets _last_found_oop_handle_index to -1\n+  \/\/ and _null_oop_handles to 0.\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"compiler\/compilationMemoryStatistic.hpp\"\n@@ -213,1 +212,1 @@\n-Arena::Arena(MEMFLAGS flag, Tag tag, size_t init_size) : _flags(flag), _tag(tag), _size_in_bytes(0)  {\n+Arena::Arena(MEMFLAGS flag, size_t init_size) : _flags(flag), _size_in_bytes(0)  {\n@@ -223,1 +222,1 @@\n-Arena::Arena(MEMFLAGS flag, Tag tag) : _flags(flag), _tag(tag), _size_in_bytes(0) {\n+Arena::Arena(MEMFLAGS flag) : _flags(flag), _size_in_bytes(0) {\n@@ -255,6 +254,0 @@\n-    if (CompilationMemoryStatistic::enabled() && _flags == mtCompiler) {\n-      Thread* const t = Thread::current();\n-      if (t != nullptr && t->is_Compiler_thread()) {\n-        CompilationMemoryStatistic::on_arena_change(delta, this);\n-      }\n-    }\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -89,9 +89,0 @@\n-public:\n-\n-  enum class Tag {\n-    tag_other = 0,\n-    tag_ra,   \/\/ resource area\n-    tag_ha,   \/\/ handle area\n-    tag_node  \/\/ C2 Node arena\n-  };\n-\n@@ -104,1 +95,1 @@\n-  const Tag _tag;\n+\n@@ -127,2 +118,3 @@\n-  Arena(MEMFLAGS memflag, Tag tag = Tag::tag_other);\n-  Arena(MEMFLAGS memflag, Tag tag, size_t init_size);\n+\n+  Arena(MEMFLAGS memflag);\n+  Arena(MEMFLAGS memflag, size_t init_size);\n@@ -182,2 +174,0 @@\n-  Tag get_tag() const { return _tag; }\n-\n","filename":"src\/hotspot\/share\/memory\/arena.hpp","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"memory\/arena.hpp\"\n@@ -55,1 +54,1 @@\n-    Arena(flags, Arena::Tag::tag_ra) DEBUG_ONLY(COMMA _nesting(0)) {}\n+    Arena(flags) DEBUG_ONLY(COMMA _nesting(0)) {}\n@@ -58,2 +57,1 @@\n-    Arena(flags, Arena::Tag::tag_ra, init_size) DEBUG_ONLY(COMMA _nesting(0)) {\n-  }\n+    Arena(flags, init_size) DEBUG_ONLY(COMMA _nesting(0)) {}\n","filename":"src\/hotspot\/share\/memory\/resourceArea.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-  : _holder_metadata(metadata), _holder_klass(klass), _next(nullptr), _is_metadata_method(is_method) {\n+  : _holder_metadata(metadata), _holder_klass(klass), _is_metadata_method(is_method) {\n","filename":"src\/hotspot\/share\/oops\/compiledICHolder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"compiler\/compilationMemoryStatistic.hpp\"\n@@ -113,2 +112,0 @@\n-  CompilationMemoryStatisticMark cmsm(directive);\n-\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -100,2 +100,0 @@\n-  if (C->failing()) return nullptr;\n-\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1886,11 +1886,0 @@\n-\/\/ Returns the BasicType of a given convert node and a type, with special handling to ensure that conversions to\n-\/\/ and from half float will return the SHORT basic type, as that wouldn't be returned typically from TypeInt.\n-static BasicType get_convert_type(Node* convert, const Type* type) {\n-  int convert_op = convert->Opcode();\n-  if (type->isa_int() && (convert_op == Op_ConvHF2F || convert_op == Op_ConvF2HF)) {\n-    return T_SHORT;\n-  }\n-\n-  return type->basic_type();\n-}\n-\n@@ -2571,35 +2560,0 @@\n-  \/\/ Try to convert a Phi with two duplicated convert nodes into a phi of the pre-conversion type and the convert node\n-  \/\/ proceeding the phi, to de-duplicate the convert node and compact the IR.\n-  if (can_reshape && progress == nullptr) {\n-    ConvertNode* convert = in(1)->isa_Convert();\n-    if (convert != nullptr) {\n-      int conv_op = convert->Opcode();\n-      bool ok = true;\n-\n-      \/\/ Check the rest of the inputs\n-      for (uint i = 2; i < req(); i++) {\n-        \/\/ Make sure that all inputs are of the same type of convert node\n-        if (in(i)->Opcode() != conv_op) {\n-          ok = false;\n-          break;\n-        }\n-      }\n-\n-      if (ok) {\n-        \/\/ Find the local bottom type to set as the type of the phi\n-        const Type* source_type = Type::get_const_basic_type(convert->in_type()->basic_type());\n-        const Type* dest_type = convert->bottom_type();\n-\n-        PhiNode* newphi = new PhiNode(in(0), source_type, nullptr);\n-        \/\/ Set inputs to the new phi be the inputs of the convert\n-        for (uint i = 1; i < req(); i++) {\n-          newphi->init_req(i, in(i)->in(1));\n-        }\n-\n-        phase->is_IterGVN()->register_new_node_with_optimizer(newphi, this);\n-\n-        return ConvertNode::create_convert(get_convert_type(convert, source_type), get_convert_type(convert, dest_type), newphi);\n-      }\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":0,"deletions":46,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -649,2 +649,2 @@\n-                  _node_arena_one(mtCompiler, Arena::Tag::tag_node),\n-                  _node_arena_two(mtCompiler, Arena::Tag::tag_node),\n+                  _node_arena_one(mtCompiler),\n+                  _node_arena_two(mtCompiler),\n@@ -2248,2 +2248,0 @@\n-  if (failing())  return;\n-\n@@ -2260,2 +2258,0 @@\n-    if (failing())  return;\n-\n@@ -2277,2 +2273,0 @@\n-  if (failing())  return;\n-\n@@ -2283,2 +2277,0 @@\n-  if (failing())  return;\n-\n@@ -2290,1 +2282,1 @@\n-    if (failing())  return;\n+\n@@ -2310,2 +2302,0 @@\n-  if (failing())  return;\n-\n@@ -2424,2 +2414,0 @@\n-  if (failing())  return;\n-\n@@ -2464,1 +2452,0 @@\n-    if (failing())  return;\n@@ -4941,1 +4928,0 @@\n-      if (failing())  return;\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":3,"deletions":17,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -91,48 +91,0 @@\n-uint ConvertNode::ideal_reg() const {\n-  return _type->ideal_reg();\n-}\n-\n-Node* ConvertNode::create_convert(BasicType source, BasicType target, Node* input) {\n-  if (source == T_INT) {\n-    if (target == T_LONG) {\n-      return new ConvI2LNode(input);\n-    } else if (target == T_FLOAT) {\n-      return new ConvI2FNode(input);\n-    } else if (target == T_DOUBLE) {\n-      return new ConvI2DNode(input);\n-    }\n-  } else if (source == T_LONG) {\n-    if (target == T_INT) {\n-      return new ConvL2INode(input);\n-    } else if (target == T_FLOAT) {\n-      return new ConvL2FNode(input);\n-    } else if (target == T_DOUBLE) {\n-      return new ConvL2DNode(input);\n-    }\n-  } else if (source == T_FLOAT) {\n-    if (target == T_INT) {\n-      return new ConvF2INode(input);\n-    } else if (target == T_LONG) {\n-      return new ConvF2LNode(input);\n-    } else if (target == T_DOUBLE) {\n-      return new ConvF2DNode(input);\n-    } else if (target == T_SHORT) {\n-      return new ConvF2HFNode(input);\n-    }\n-  } else if (source == T_DOUBLE) {\n-    if (target == T_INT) {\n-      return new ConvD2INode(input);\n-    } else if (target == T_LONG) {\n-      return new ConvD2LNode(input);\n-    } else if (target == T_FLOAT) {\n-      return new ConvD2FNode(input);\n-    }\n-  } else if (source == T_SHORT) {\n-    if (target == T_FLOAT) {\n-      return new ConvHF2FNode(input);\n-    }\n-  }\n-\n-  assert(false, \"Couldn't create conversion for type %s to %s\", type2name(source), type2name(target));\n-  return nullptr;\n-}\n@@ -244,3 +196,2 @@\n-  if (t == Type::FLOAT || StubRoutines::f2hf_adr() == nullptr) {\n-    return TypeInt::SHORT;\n-  }\n+  if (t == Type::FLOAT) return TypeInt::SHORT;\n+  if (StubRoutines::f2hf_adr() == nullptr) return bottom_type();\n@@ -315,3 +266,2 @@\n-  if (t == TypeInt::SHORT || StubRoutines::hf2f_adr() == nullptr) {\n-    return Type::FLOAT;\n-  }\n+  if (t == TypeInt::SHORT) return Type::FLOAT;\n+  if (StubRoutines::hf2f_adr() == nullptr) return bottom_type();\n@@ -323,1 +273,1 @@\n-  return Type::FLOAT;\n+  return bottom_type();\n@@ -333,1 +283,1 @@\n-  return Type::DOUBLE;\n+  return bottom_type();\n@@ -343,1 +293,1 @@\n-  return Type::FLOAT;\n+  return bottom_type();\n@@ -763,1 +713,1 @@\n-  return Type::DOUBLE;\n+  return bottom_type();\n@@ -773,1 +723,1 @@\n-  return Type::FLOAT;\n+  return bottom_type();\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":9,"deletions":59,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -45,15 +45,0 @@\n-class ConvertNode : public TypeNode {\n-protected:\n-  ConvertNode(const Type* t, Node* input) : TypeNode(t, 2) {\n-    init_class_id(Class_Convert);\n-    init_req(1, input);\n-  }\n-public:\n-  virtual const Type* in_type() const = 0;\n-  virtual uint ideal_reg() const;\n-\n-  \/\/ Create a convert node for a given input and output type.\n-  \/\/ Conversions to and from half float are specified via T_SHORT.\n-  static Node* create_convert(BasicType source, BasicType target, Node* input);\n-};\n-\n@@ -63,1 +48,1 @@\n-class ConvD2FNode : public ConvertNode {\n+class ConvD2FNode : public Node {\n@@ -65,1 +50,1 @@\n-  ConvD2FNode(Node* in1) : ConvertNode(Type::FLOAT,in1) {}\n+  ConvD2FNode( Node *in1 ) : Node(0,in1) {}\n@@ -67,1 +52,1 @@\n-  virtual const Type* in_type() const { return Type::DOUBLE; }\n+  virtual const Type *bottom_type() const { return Type::FLOAT; }\n@@ -70,1 +55,2 @@\n-  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n+  virtual uint  ideal_reg() const { return Op_RegF; }\n@@ -75,1 +61,1 @@\n-class ConvD2INode : public ConvertNode {\n+class ConvD2INode : public Node {\n@@ -77,1 +63,1 @@\n-  ConvD2INode(Node* in1) : ConvertNode(TypeInt::INT,in1) {}\n+  ConvD2INode( Node *in1 ) : Node(0,in1) {}\n@@ -79,1 +65,1 @@\n-  virtual const Type* in_type() const { return Type::DOUBLE; }\n+  virtual const Type *bottom_type() const { return TypeInt::INT; }\n@@ -82,1 +68,2 @@\n-  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n+  virtual uint  ideal_reg() const { return Op_RegI; }\n@@ -87,1 +74,1 @@\n-class ConvD2LNode : public ConvertNode {\n+class ConvD2LNode : public Node {\n@@ -89,1 +76,1 @@\n-  ConvD2LNode(Node* in1) : ConvertNode(TypeLong::LONG, in1) {}\n+  ConvD2LNode( Node *dbl ) : Node(0,dbl) {}\n@@ -91,1 +78,1 @@\n-  virtual const Type* in_type() const { return Type::DOUBLE; }\n+  virtual const Type *bottom_type() const { return TypeLong::LONG; }\n@@ -94,1 +81,10 @@\n-  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n+  virtual uint ideal_reg() const { return Op_RegL; }\n+};\n+\n+class RoundDNode : public Node {\n+  public:\n+  RoundDNode( Node *dbl ) : Node(0,dbl) {}\n+  virtual int Opcode() const;\n+  virtual const Type *bottom_type() const { return TypeLong::LONG; }\n+  virtual uint ideal_reg() const { return Op_RegL; }\n@@ -99,1 +95,1 @@\n-class ConvF2DNode : public ConvertNode {\n+class ConvF2DNode : public Node {\n@@ -101,1 +97,1 @@\n-  ConvF2DNode(Node* in1) : ConvertNode(Type::DOUBLE,in1) {}\n+  ConvF2DNode( Node *in1 ) : Node(0,in1) {}\n@@ -103,1 +99,1 @@\n-  virtual const Type* in_type() const { return Type::FLOAT; }\n+  virtual const Type *bottom_type() const { return Type::DOUBLE; }\n@@ -105,0 +101,1 @@\n+  virtual uint  ideal_reg() const { return Op_RegD; }\n@@ -109,1 +106,1 @@\n-class ConvF2HFNode : public ConvertNode {\n+class ConvF2HFNode : public Node {\n@@ -111,1 +108,1 @@\n-  ConvF2HFNode(Node* in1) : ConvertNode(TypeInt::SHORT, in1) {}\n+  ConvF2HFNode( Node *in1 ) : Node(0,in1) {}\n@@ -113,1 +110,1 @@\n-  virtual const Type* in_type() const { return TypeInt::FLOAT; }\n+  virtual const Type *bottom_type() const { return TypeInt::SHORT; }\n@@ -115,0 +112,1 @@\n+  virtual uint  ideal_reg() const { return Op_RegI; }\n@@ -119,3 +117,3 @@\n-class ConvF2INode : public ConvertNode {\n-public:\n-  ConvF2INode(Node* in1) : ConvertNode(TypeInt::INT, in1) {}\n+class ConvF2INode : public Node {\n+  public:\n+  ConvF2INode( Node *in1 ) : Node(0,in1) {}\n@@ -123,1 +121,1 @@\n-  virtual const Type* in_type() const { return TypeInt::FLOAT; }\n+  virtual const Type *bottom_type() const { return TypeInt::INT; }\n@@ -126,1 +124,2 @@\n-  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n+  virtual uint  ideal_reg() const { return Op_RegI; }\n@@ -129,0 +128,1 @@\n+\n@@ -131,3 +131,3 @@\n-class ConvF2LNode : public ConvertNode {\n-public:\n-  ConvF2LNode(Node* in1) : ConvertNode(TypeLong::LONG, in1) {}\n+class ConvF2LNode : public Node {\n+  public:\n+  ConvF2LNode( Node *in1 ) : Node(0,in1) {}\n@@ -135,1 +135,1 @@\n-  virtual const Type* in_type() const { return TypeInt::FLOAT; }\n+  virtual const Type *bottom_type() const { return TypeLong::LONG; }\n@@ -138,1 +138,2 @@\n-  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n+  virtual uint  ideal_reg() const { return Op_RegL; }\n@@ -143,3 +144,3 @@\n-class ConvHF2FNode : public ConvertNode {\n-public:\n-  ConvHF2FNode(Node* in1) : ConvertNode(Type::FLOAT, in1) {}\n+class ConvHF2FNode : public Node {\n+  public:\n+  ConvHF2FNode( Node *in1 ) : Node(0,in1) {}\n@@ -147,1 +148,1 @@\n-  virtual const Type* in_type() const { return TypeInt::SHORT; }\n+  virtual const Type *bottom_type() const { return Type::FLOAT; }\n@@ -149,0 +150,1 @@\n+  virtual uint  ideal_reg() const { return Op_RegF; }\n@@ -153,3 +155,3 @@\n-class ConvI2DNode : public ConvertNode {\n-public:\n-  ConvI2DNode(Node* in1) : ConvertNode(Type::DOUBLE, in1) {}\n+class ConvI2DNode : public Node {\n+  public:\n+  ConvI2DNode( Node *in1 ) : Node(0,in1) {}\n@@ -157,1 +159,1 @@\n-  virtual const Type* in_type() const { return TypeInt::INT; }\n+  virtual const Type *bottom_type() const { return Type::DOUBLE; }\n@@ -159,0 +161,1 @@\n+  virtual uint  ideal_reg() const { return Op_RegD; }\n@@ -163,3 +166,3 @@\n-class ConvI2FNode : public ConvertNode {\n-public:\n-  ConvI2FNode(Node* in1) : ConvertNode(Type::FLOAT, in1) {}\n+class ConvI2FNode : public Node {\n+  public:\n+  ConvI2FNode( Node *in1 ) : Node(0,in1) {}\n@@ -167,1 +170,1 @@\n-  virtual const Type* in_type() const { return TypeInt::INT; }\n+  virtual const Type *bottom_type() const { return Type::FLOAT; }\n@@ -170,0 +173,9 @@\n+  virtual uint  ideal_reg() const { return Op_RegF; }\n+};\n+\n+class RoundFNode : public Node {\n+  public:\n+  RoundFNode( Node *in1 ) : Node(0,in1) {}\n+  virtual int Opcode() const;\n+  virtual const Type *bottom_type() const { return TypeInt::INT; }\n+  virtual uint  ideal_reg() const { return Op_RegI; }\n@@ -174,1 +186,1 @@\n-class ConvI2LNode : public ConvertNode {\n+class ConvI2LNode : public TypeNode {\n@@ -176,1 +188,3 @@\n-  ConvI2LNode(Node* in1, const TypeLong* t = TypeLong::INT) : ConvertNode(t, in1) {}\n+  ConvI2LNode(Node *in1, const TypeLong* t = TypeLong::INT)\n+  : TypeNode(t, 2)\n+  { init_req(1, in1); }\n@@ -178,1 +192,0 @@\n-  virtual const Type* in_type() const { return TypeInt::INT; }\n@@ -180,1 +193,1 @@\n-  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n@@ -182,0 +195,1 @@\n+  virtual uint  ideal_reg() const { return Op_RegL; }\n@@ -186,3 +200,3 @@\n-class ConvL2DNode : public ConvertNode {\n-public:\n-  ConvL2DNode(Node* in1) : ConvertNode(Type::DOUBLE, in1) {}\n+class ConvL2DNode : public Node {\n+  public:\n+  ConvL2DNode( Node *in1 ) : Node(0,in1) {}\n@@ -190,1 +204,1 @@\n-  virtual const Type* in_type() const { return TypeLong::LONG; }\n+  virtual const Type *bottom_type() const { return Type::DOUBLE; }\n@@ -192,0 +206,1 @@\n+  virtual uint ideal_reg() const { return Op_RegD; }\n@@ -196,3 +211,3 @@\n-class ConvL2FNode : public ConvertNode {\n-public:\n-  ConvL2FNode(Node* in1) : ConvertNode(Type::FLOAT, in1) {}\n+class ConvL2FNode : public Node {\n+  public:\n+  ConvL2FNode( Node *in1 ) : Node(0,in1) {}\n@@ -200,1 +215,1 @@\n-  virtual const Type* in_type() const { return TypeLong::LONG; }\n+  virtual const Type *bottom_type() const { return Type::FLOAT; }\n@@ -202,0 +217,1 @@\n+  virtual uint  ideal_reg() const { return Op_RegF; }\n@@ -206,1 +222,1 @@\n-class ConvL2INode : public ConvertNode {\n+class ConvL2INode : public TypeNode {\n@@ -208,1 +224,4 @@\n-  ConvL2INode(Node* in1, const TypeInt* t = TypeInt::INT) : ConvertNode(t, in1) {}\n+  ConvL2INode(Node *in1, const TypeInt* t = TypeInt::INT)\n+  : TypeNode(t, 2) {\n+    init_req(1, in1);\n+  }\n@@ -210,1 +229,0 @@\n-  virtual const Type* in_type() const { return TypeLong::LONG; }\n@@ -213,16 +231,1 @@\n-  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n-};\n-\n-class RoundDNode : public Node {\n-public:\n-  RoundDNode(Node* in1) : Node(nullptr, in1) {}\n-  virtual int Opcode() const;\n-  virtual const Type* bottom_type() const { return TypeLong::LONG; }\n-  virtual uint ideal_reg() const { return Op_RegL; }\n-};\n-\n-class RoundFNode : public Node {\n-public:\n-  RoundFNode(Node* in1) : Node(nullptr, in1) {}\n-  virtual int Opcode() const;\n-  virtual const Type* bottom_type() const { return TypeInt::INT; }\n+  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n","filename":"src\/hotspot\/share\/opto\/convertnode.hpp","additions":89,"deletions":86,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -85,2 +85,1 @@\n-    assert(failing() || !has_exceptions(),\n-           \"unless compilation failed, user must call transfer_exceptions_into_jvms\");\n+    assert(!has_exceptions(), \"user must call transfer_exceptions_into_jvms\");\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4695,1 +4695,0 @@\n-  if (C->failing()) return;\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1197,1 +1197,1 @@\n-      if (C->failing()) { return; }\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -359,3 +359,1 @@\n-  Node* const n = xform(C->top(), live_nodes);\n-  if (C->failing()) return;\n-  C->set_cached_top_node(n);\n+  C->set_cached_top_node(xform( C->top(), live_nodes ));\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-class ConvertNode;\n@@ -735,1 +734,0 @@\n-      DEFINE_CLASS_ID(Convert, Type, 10)\n@@ -894,1 +892,0 @@\n-  DEFINE_CLASS_QUERY(Convert)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1578,1 +1578,0 @@\n-    if (failing()) return;\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -731,1 +731,1 @@\n-  Arena* arena =  new (mtTest) Arena(mtTest, Arena::Tag::tag_other, size_t(init_size));\n+  Arena* arena =  new (mtTest) Arena(mtTest, size_t(init_size));\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,16 +69,13 @@\n-  if (LockingMode == LM_LEGACY) {\n-    if (displaced_header().is_neutral()) {\n-      \/\/ The object is locked and the resulting ObjectMonitor* will also be\n-      \/\/ locked so it can't be async deflated until ownership is dropped.\n-      ObjectSynchronizer::inflate_helper(obj);\n-      \/\/ WARNING: We cannot put a check here, because the inflation\n-      \/\/ will not update the displaced header. Once BasicLock is inflated,\n-      \/\/ no one should ever look at its content.\n-    } else {\n-      \/\/ Typically the displaced header will be 0 (recursive stack lock) or\n-      \/\/ unused_mark.  Naively we'd like to assert that the displaced mark\n-      \/\/ value is either 0, neutral, or 3.  But with the advent of the\n-      \/\/ store-before-CAS avoidance in fast_lock\/compiler_lock_object\n-      \/\/ we can find any flavor mark in the displaced mark.\n-    }\n-    dest->set_displaced_header(displaced_header());\n+  if (displaced_header().is_neutral()) {\n+    \/\/ The object is locked and the resulting ObjectMonitor* will also be\n+    \/\/ locked so it can't be async deflated until ownership is dropped.\n+    ObjectSynchronizer::inflate_helper(obj);\n+    \/\/ WARNING: We cannot put a check here, because the inflation\n+    \/\/ will not update the displaced header. Once BasicLock is inflated,\n+    \/\/ no one should ever look at its content.\n+  } else {\n+    \/\/ Typically the displaced header will be 0 (recursive stack lock) or\n+    \/\/ unused_mark.  Naively we'd like to assert that the displaced mark\n+    \/\/ value is either 0, neutral, or 3.  But with the advent of the\n+    \/\/ store-before-CAS avoidance in fast_lock\/compiler_lock_object\n+    \/\/ we can find any flavor mark in the displaced mark.\n@@ -86,5 +83,1 @@\n-#ifdef ASSERT\n-  else {\n-    dest->set_displaced_header(markWord(badDispHeaderDeopt));\n-  }\n-#endif\n+  dest->set_displaced_header(displaced_header());\n","filename":"src\/hotspot\/share\/runtime\/basicLock.cpp","additions":14,"deletions":21,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-  HandleArea(HandleArea* prev) : Arena(mtThread, Tag::tag_ha, Chunk::tiny_size) {\n+  HandleArea(HandleArea* prev) : Arena(mtThread, Chunk::tiny_size) {\n","filename":"src\/hotspot\/share\/runtime\/handles.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"compiler\/compilationMemoryStatistic.hpp\"\n@@ -345,4 +344,0 @@\n-  if (CompilerOracle::should_print_final_memstat_report()) {\n-    CompilationMemoryStatistic::print_all_by_size(tty, false, 0);\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -50,8 +50,4 @@\n-  Thread* current = Thread::current();\n-  if (current->is_Java_thread()) {\n-    JavaThread* thread = JavaThread::cast(current);\n-    bool is_owning = &thread->lock_stack() == this;\n-    assert(is_owning == (get_thread() == thread), \"is_owning sanity\");\n-    return is_owning;\n-  }\n-  return false;\n+  JavaThread* thread = JavaThread::current();\n+  bool is_owning = &thread->lock_stack() == this;\n+  assert(is_owning == (get_thread() == thread), \"is_owning sanity\");\n+  return is_owning;\n","filename":"src\/hotspot\/share\/runtime\/lockStack.inline.hpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -142,1 +142,0 @@\n-Mutex*   NMTCompilationCostHistory_lock = nullptr;\n@@ -313,1 +312,0 @@\n-  MUTEX_DEFN(NMTCompilationCostHistory_lock  , PaddedMutex  , nosafepoint);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -120,1 +120,0 @@\n-extern Mutex*   NMTCompilationCostHistory_lock;  \/\/ guards NMT compilation cost history\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3260,11 +3260,6 @@\n-      if (LockingMode == LM_LEGACY) {\n-        \/\/ Inflate so the object's header no longer refers to the BasicLock.\n-        if (lock->displaced_header().is_unlocked()) {\n-          \/\/ The object is locked and the resulting ObjectMonitor* will also be\n-          \/\/ locked so it can't be async deflated until ownership is dropped.\n-          \/\/ See the big comment in basicLock.cpp: BasicLock::move_to().\n-          ObjectSynchronizer::inflate_helper(kptr2->obj());\n-        }\n-        \/\/ Now the displaced header is free to move because the\n-        \/\/ object's header no longer refers to it.\n-        buf[i] = (intptr_t)lock->displaced_header().value();\n+      \/\/ Inflate so the object's header no longer refers to the BasicLock.\n+      if (lock->displaced_header().is_unlocked()) {\n+        \/\/ The object is locked and the resulting ObjectMonitor* will also be\n+        \/\/ locked so it can't be async deflated until ownership is dropped.\n+        \/\/ See the big comment in basicLock.cpp: BasicLock::move_to().\n+        ObjectSynchronizer::inflate_helper(kptr2->obj());\n@@ -3272,6 +3267,3 @@\n-#ifdef ASSERT\n-      else {\n-        buf[i] = badDispHeaderOSR;\n-      }\n-#endif\n-      i++;\n+      \/\/ Now the displaced header is free to move because the\n+      \/\/ object's header no longer refers to it.\n+      buf[i++] = (intptr_t)lock->displaced_header().value();\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":9,"deletions":17,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-class CompilerThread;\n@@ -328,6 +327,0 @@\n-  \/\/ Convenience cast functions\n-  CompilerThread* as_Compiler_thread() const {\n-    assert(is_Compiler_thread(), \"Must be compiler thread\");\n-    return (CompilerThread*)this;\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1496,1 +1496,0 @@\n-  declare_c2_type(ConvertNode, TypeNode)                                  \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,2 +34,0 @@\n-#include \"compiler\/compilationMemoryStatistic.hpp\"\n-#include \"compiler\/compiler_globals.hpp\"\n@@ -143,1 +141,0 @@\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CompilationMemoryStatisticDCmd>(full_export, true, false));\n@@ -1140,14 +1137,0 @@\n-\n-CompilationMemoryStatisticDCmd::CompilationMemoryStatisticDCmd(outputStream* output, bool heap) :\n-    DCmdWithParser(output, heap),\n-  _human_readable(\"-H\", \"Human readable format\", \"BOOLEAN\", false, \"false\"),\n-  _minsize(\"-s\", \"Minimum memory size\", \"MEMORY SIZE\", false, \"0\") {\n-  _dcmdparser.add_dcmd_option(&_human_readable);\n-  _dcmdparser.add_dcmd_option(&_minsize);\n-}\n-\n-void CompilationMemoryStatisticDCmd::execute(DCmdSource source, TRAPS) {\n-  const bool human_readable = _human_readable.value();\n-  const size_t minsize = _minsize.has_value() ? _minsize.value()._size : 0;\n-  CompilationMemoryStatistic::print_all_by_size(output(), human_readable, minsize);\n-}\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -957,24 +957,0 @@\n-class CompilationMemoryStatisticDCmd: public DCmdWithParser {\n-protected:\n-  DCmdArgument<bool> _human_readable;\n-  DCmdArgument<MemorySizeArgument> _minsize;\n-public:\n-  static int num_arguments() { return 2; }\n-  CompilationMemoryStatisticDCmd(outputStream* output, bool heap);\n-  static const char* name() {\n-    return \"Compiler.memory\";\n-  }\n-  static const char* description() {\n-    return \"Print compilation footprint\";\n-  }\n-  static const char* impact() {\n-    return \"Medium: Pause time depends on number of compiled methods\";\n-  }\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n-  virtual void execute(DCmdSource source, TRAPS);\n-};\n-\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -62,0 +62,17 @@\n+void MallocMemorySnapshot::copy_to(MallocMemorySnapshot* s) {\n+  \/\/ Need to make sure that mtChunks don't get deallocated while the\n+  \/\/ copy is going on, because their size is adjusted using this\n+  \/\/ buffer in make_adjustment().\n+  ThreadCritical tc;\n+  s->_all_mallocs = _all_mallocs;\n+  size_t total_size = 0;\n+  size_t total_count = 0;\n+  for (int index = 0; index < mt_number_of_types; index ++) {\n+    s->_malloc[index] = _malloc[index];\n+    total_size += s->_malloc[index].malloc_size();\n+    total_count += s->_malloc[index].malloc_count();\n+  }\n+  \/\/ malloc counters may be updated concurrently\n+  s->_all_mallocs.set_size_and_count(total_size, total_count);\n+}\n+\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -58,0 +58,2 @@\n+  inline void set_size_and_count(size_t size, size_t count) { _size = size; _count = count; }\n+\n@@ -179,10 +181,6 @@\n-  void copy_to(MallocMemorySnapshot* s) {\n-     \/\/ Need to make sure that mtChunks don't get deallocated while the\n-     \/\/ copy is going on, because their size is adjusted using this\n-     \/\/ buffer in make_adjustment().\n-     ThreadCritical tc;\n-     s->_all_mallocs = _all_mallocs;\n-     for (int index = 0; index < mt_number_of_types; index ++) {\n-       s->_malloc[index] = _malloc[index];\n-     }\n-   }\n+  inline size_t thread_count() const {\n+    MallocMemorySnapshot* s = const_cast<MallocMemorySnapshot*>(this);\n+    return s->by_type(mtThreadStack)->malloc_count();\n+  }\n+\n+  void copy_to(MallocMemorySnapshot* s);\n","filename":"src\/hotspot\/share\/services\/mallocTracker.hpp","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -193,1 +193,0 @@\n-  _thread_count = ThreadStackTracker::thread_count();\n","filename":"src\/hotspot\/share\/services\/memBaseline.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -67,1 +67,0 @@\n-  size_t                 _thread_count;\n@@ -88,1 +87,1 @@\n-    _instance_class_count(0), _array_class_count(0), _thread_count(0),\n+    _instance_class_count(0), _array_class_count(0),\n@@ -175,1 +174,1 @@\n-    return _thread_count;\n+    return _malloc_memory_snapshot.thread_count();\n@@ -184,1 +183,0 @@\n-    _thread_count = 0;\n","filename":"src\/hotspot\/share\/services\/memBaseline.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-  ThreadCritical tc;\n@@ -54,0 +53,1 @@\n+    ThreadCritical tc;\n@@ -55,0 +55,1 @@\n+    _thread_count ++;\n@@ -59,0 +60,1 @@\n+      ThreadCritical tc;\n@@ -64,1 +66,0 @@\n-  _thread_count++;\n@@ -70,1 +71,0 @@\n-  ThreadCritical tc;\n@@ -72,0 +72,1 @@\n+    ThreadCritical tc;\n@@ -73,0 +74,1 @@\n+    _thread_count--;\n@@ -77,0 +79,1 @@\n+      ThreadCritical tc;\n@@ -83,1 +86,0 @@\n-  _thread_count--;\n","filename":"src\/hotspot\/share\/services\/threadStackTracker.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1039,2 +1039,1 @@\n-const intptr_t badDispHeaderDeopt = 0xDE0BD000;             \/\/ value to fill unused displaced header during deoptimization\n-const intptr_t badDispHeaderOSR   = 0xDEAD05A0;             \/\/ value to fill unused displaced header during OSR\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -434,1 +434,1 @@\n-    if (fr.is_interpreted_frame() || (fr.cb() != nullptr && fr.cb()->frame_size() > 0)) {\n+    if (fr.is_java_frame() || fr.is_native_frame() || fr.is_runtime_frame()) {\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-        \/\/ POSIX attributes not supported on FAT32\n+        \/\/ POSIX attributes not supported on FAT\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxFileStore.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.io.IOException;\n@@ -30,1 +29,0 @@\n-import java.nio.file.attribute.PosixFileAttributeView;\n@@ -32,0 +30,1 @@\n+import java.io.IOException;\n@@ -104,4 +103,0 @@\n-        \/\/ POSIX attributes not supported on FAT32\n-        if (type == PosixFileAttributeView.class &&\n-            entry().fstype().equals(\"msdos\"))\n-            return false;\n@@ -115,3 +110,0 @@\n-        \/\/ UNIX attributes not supported on FAT32\n-        if (name.equals(\"unix\") && entry().fstype().equals(\"msdos\"))\n-            return false;\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdFileStore.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-    private final BlockCipherParamsCore core;\n+    private BlockCipherParamsCore core;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESParameters.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-    private final int block_size;\n+    private int block_size = 0;\n@@ -52,1 +52,1 @@\n-    private final int[] moreSizes;\n+    private int[] moreSizes = null;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/BlockCipherParamsCore.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import sun.security.util.*;\n@@ -33,0 +34,1 @@\n+import javax.crypto.spec.*;\n@@ -58,1 +60,1 @@\n-    private final CipherCore core;\n+    private CipherCore core = null;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/BlowfishCipher.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2011, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-    private final BlockCipherParamsCore core;\n+    private BlockCipherParamsCore core;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/BlowfishParameters.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.Objects;\n@@ -57,1 +58,1 @@\n-    private final byte[] k;\n+    private byte[] k;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/CipherBlockChaining.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-    private final byte[] buffer;\n+    private byte[] buffer = null;\n@@ -65,1 +65,1 @@\n-    private final int blockSize;\n+    private int blockSize = 0;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/CipherCore.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-    private final int numBytes;\n+    private int numBytes;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/CipherFeedback.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import javax.crypto.spec.*;\n@@ -54,1 +55,1 @@\n-    private final CipherCore core;\n+    private CipherCore core = null;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESCipher.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.io.IOException;\n-import java.io.InvalidObjectException;\n@@ -50,1 +48,1 @@\n-    private static final long serialVersionUID = 7724971015953279128L;\n+    static final long serialVersionUID = 7724971015953279128L;\n@@ -148,5 +146,2 @@\n-     * Restores the state of this object from the stream.\n-     *\n-     * @param  s the {@code ObjectInputStream} from which data is read\n-     * @throws IOException if an I\/O error occurs\n-     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     * readObject is called to restore the state of this key from\n+     * a stream.\n@@ -156,1 +151,1 @@\n-         throws IOException, ClassNotFoundException\n+         throws java.io.IOException, ClassNotFoundException\n@@ -159,3 +154,0 @@\n-        if ((key == null) || (key.length != DESKeySpec.DES_KEY_LEN)) {\n-            throw new InvalidObjectException(\"Wrong key size\");\n-        }\n@@ -165,3 +157,0 @@\n-\n-        DESKeyGenerator.setParityBit(key, 0);\n-\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESKey.java","additions":4,"deletions":15,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2011, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-    private final BlockCipherParamsCore core;\n+    private BlockCipherParamsCore core;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESParameters.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import javax.crypto.spec.*;\n@@ -52,1 +53,1 @@\n-    private final CipherCore core;\n+    private CipherCore core = null;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESedeCipher.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2007, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,2 +51,1 @@\n-    private final byte[] buf1;\n-    private final byte[] buf2;\n+    private byte[] buf1, buf2;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESedeCrypt.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.io.IOException;\n-import java.io.InvalidObjectException;\n@@ -50,1 +48,1 @@\n-    private static final long serialVersionUID = 2463986565756745178L;\n+    static final long serialVersionUID = 2463986565756745178L;\n@@ -149,5 +147,2 @@\n-     * Restores the state of this object from the stream.\n-     *\n-     * @param  s the {@code ObjectInputStream} from which data is read\n-     * @throws IOException if an I\/O error occurs\n-     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     * readObject is called to restore the state of this key from\n+     * a stream.\n@@ -157,1 +152,1 @@\n-         throws IOException, ClassNotFoundException\n+         throws java.io.IOException, ClassNotFoundException\n@@ -160,3 +155,0 @@\n-        if ((key == null) || (key.length != DESedeKeySpec.DES_EDE_KEY_LEN)) {\n-            throw new InvalidObjectException(\"Wrong key size\");\n-        }\n@@ -166,5 +158,0 @@\n-\n-        DESKeyGenerator.setParityBit(key, 0);\n-        DESKeyGenerator.setParityBit(key, 8);\n-        DESKeyGenerator.setParityBit(key, 16);\n-\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESedeKey.java","additions":4,"deletions":17,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2011, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-    private final BlockCipherParamsCore core;\n+    private BlockCipherParamsCore core;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESedeParameters.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-    private final FeedbackCipher cipher;\n+    private FeedbackCipher cipher;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESedeWrapCipher.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -356,1 +356,1 @@\n-            if (ns.getName().equalsIgnoreCase(\"X25519\")) {\n+            if (ns.getName().equals(\"X25519\")) {\n@@ -358,1 +358,1 @@\n-            } else if (ns.getName().equalsIgnoreCase(\"X448\")) {\n+            } else if (ns.getName().equals(\"X448\")) {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHKEM.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+ *\n+ *\n@@ -50,1 +52,1 @@\n-    private static final long serialVersionUID = 7565477590005668886L;\n+    static final long serialVersionUID = 7565477590005668886L;\n@@ -56,1 +58,1 @@\n-    private final BigInteger x;\n+    private BigInteger x;\n@@ -65,1 +67,1 @@\n-    private final BigInteger p;\n+    private BigInteger p;\n@@ -68,1 +70,1 @@\n-    private final BigInteger g;\n+    private BigInteger g;\n@@ -71,1 +73,1 @@\n-    private final int l;\n+    private int l;\n@@ -164,2 +166,0 @@\n-            } else {\n-                this.l = 0;\n@@ -175,3 +175,1 @@\n-\n-            DerInputStream in = new DerInputStream(this.key);\n-            this.x = in.getBigInteger();\n+            parseKeyBits();\n@@ -278,0 +276,10 @@\n+    private void parseKeyBits() throws InvalidKeyException {\n+        try {\n+            DerInputStream in = new DerInputStream(this.key);\n+            this.x = in.getBigInteger();\n+        } catch (IOException e) {\n+            throw new InvalidKeyException(\n+                \"Error parsing key encoding: \" + e.getMessage(), e);\n+        }\n+    }\n+\n@@ -316,24 +324,0 @@\n-\n-    \/**\n-     * Restores the state of this object from the stream.\n-     * <p>\n-     * JDK 1.5+ objects use <code>KeyRep<\/code>s instead.\n-     *\n-     * @param  stream the {@code ObjectInputStream} from which data is read\n-     * @throws IOException if an I\/O error occurs\n-     * @throws ClassNotFoundException if a serialized class cannot be loaded\n-     *\/\n-    @java.io.Serial\n-    private void readObject(ObjectInputStream stream)\n-            throws IOException, ClassNotFoundException {\n-        stream.defaultReadObject();\n-        if ((key == null) || (key.length == 0)) {\n-            throw new InvalidObjectException(\"key not deserializable\");\n-        }\n-        this.key = key.clone();\n-        if ((encodedKey == null) || (encodedKey.length == 0)) {\n-            throw new InvalidObjectException(\n-                    \"encoded key not deserializable\");\n-        }\n-        this.encodedKey = encodedKey.clone();\n-    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHPrivateKey.java","additions":18,"deletions":34,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+ *\n+ *\n@@ -49,1 +51,1 @@\n-    private static final long serialVersionUID = 7647557958927458271L;\n+    static final long serialVersionUID = 7647557958927458271L;\n@@ -52,1 +54,1 @@\n-    private final BigInteger y;\n+    private BigInteger y;\n@@ -61,1 +63,1 @@\n-    private final BigInteger p;\n+    private BigInteger p;\n@@ -64,1 +66,1 @@\n-    private final BigInteger g;\n+    private BigInteger g;\n@@ -67,1 +69,1 @@\n-    private final int l;\n+    private int l;\n@@ -70,1 +72,1 @@\n-    static final ObjectIdentifier DH_OID =\n+    static ObjectIdentifier DH_OID =\n@@ -156,2 +158,0 @@\n-            } else {\n-                this.l = 0;\n@@ -167,4 +167,1 @@\n-\n-            DerInputStream in = new DerInputStream(this.key);\n-            this.y = in.getBigInteger();\n-\n+            parseKeyBits();\n@@ -271,0 +268,10 @@\n+    private void parseKeyBits() throws InvalidKeyException {\n+        try {\n+            DerInputStream in = new DerInputStream(this.key);\n+            this.y = in.getBigInteger();\n+        } catch (IOException e) {\n+            throw new InvalidKeyException(\n+                \"Error parsing key encoding: \" + e.toString());\n+        }\n+    }\n+\n@@ -309,24 +316,0 @@\n-\n-    \/**\n-     * Restores the state of this object from the stream.\n-     * <p>\n-     * JDK 1.5+ objects use <code>KeyRep<\/code>s instead.\n-     *\n-     * @param  stream the {@code ObjectInputStream} from which data is read\n-     * @throws IOException if an I\/O error occurs\n-     * @throws ClassNotFoundException if a serialized class cannot be loaded\n-     *\/\n-    @java.io.Serial\n-    private void readObject(ObjectInputStream stream)\n-            throws IOException, ClassNotFoundException {\n-        stream.defaultReadObject();\n-        if ((key == null) || (key.length == 0)) {\n-            throw new InvalidObjectException(\"key not deserializable\");\n-        }\n-        this.key = key.clone();\n-        if ((encodedKey == null) || (encodedKey.length == 0)) {\n-            throw new InvalidObjectException(\n-                    \"encoded key not deserializable\");\n-        }\n-        this.encodedKey = encodedKey.clone();\n-    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHPublicKey.java","additions":19,"deletions":36,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2011, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-    private final AlgorithmId algid;\n+    private AlgorithmId algid;\n@@ -50,1 +50,1 @@\n-    private final byte[] encryptedData;\n+    private byte[] encryptedData;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/EncryptedPrivateKeyInfo.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,1 +127,1 @@\n-    private final long[] subkeyHtbl;\n+    private long[] subkeyHtbl;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GHASH.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,2 +77,2 @@\n-    private static final int DEFAULT_IV_LEN = 12; \/\/ in bytes\n-    private static final int DEFAULT_TAG_LEN = 16; \/\/ in bytes\n+    static int DEFAULT_IV_LEN = 12; \/\/ in bytes\n+    static int DEFAULT_TAG_LEN = 16; \/\/ in bytes\n@@ -101,1 +101,1 @@\n-    final SymmetricCipher blockCipher;\n+    SymmetricCipher blockCipher;\n@@ -109,1 +109,1 @@\n-    private final int keySize;\n+    int keySize;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-    private final int blockSize;\n+    private int blockSize;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ISO10126Padding.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,1 +102,1 @@\n-    private final Hashtable<String, Object> entries = new Hashtable<>();\n+    private Hashtable<String, Object> entries = new Hashtable<String, Object>();\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/JceKeyStore.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-    private final char[] password;\n+    private char[] password;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/KeyProtector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-    private static final ObjectIdentifier OID_MGF1 =\n+    private static ObjectIdentifier OID_MGF1 =\n@@ -61,1 +61,1 @@\n-    private static final ObjectIdentifier OID_PSpecified =\n+    private static ObjectIdentifier OID_PSpecified =\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/OAEPParameters.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-    private final byte[] k;\n+    private byte[] k = null;\n@@ -53,1 +53,1 @@\n-    private final byte[] register;\n+    private byte[] register = null;\n@@ -59,1 +59,1 @@\n-    private final int numBytes;\n+    private int numBytes;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/OutputFeedback.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.io.IOException;\n-import java.io.InvalidObjectException;\n@@ -51,1 +49,1 @@\n-    private static final long serialVersionUID = -2234768909660948176L;\n+    static final long serialVersionUID = -2234768909660948176L;\n@@ -55,1 +53,1 @@\n-    private final String type;\n+    private String type;\n@@ -167,5 +165,2 @@\n-     * Restores the state of this object from the stream.\n-     *\n-     * @param  s the {@code ObjectInputStream} from which data is read\n-     * @throws IOException if an I\/O error occurs\n-     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     * readObject is called to restore the state of this key from\n+     * a stream.\n@@ -175,1 +170,1 @@\n-         throws IOException, ClassNotFoundException\n+         throws java.io.IOException, ClassNotFoundException\n@@ -178,4 +173,0 @@\n-        if (key == null) {\n-            throw new InvalidObjectException(\n-                    \"PBEKey couldn't be deserialized\");\n-        }\n@@ -185,11 +176,0 @@\n-\n-        \/\/ Accept \"\\0\" to signify \"zero-length password with no terminator\".\n-        if (!(key.length == 1 && key[0] == 0)) {\n-            for (int i = 0; i < key.length; i++) {\n-                if ((key[i] < '\\u0020') || (key[i] > '\\u007E')) {\n-                    throw new InvalidObjectException(\n-                            \"PBEKey had non-ASCII chars\");\n-                }\n-            }\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBEKey.java","additions":5,"deletions":25,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    private final String type;\n+    private String type;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBEKeyFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,3 +46,4 @@\n-    private final CipherCore cipher;\n-    private final MessageDigest md;\n-    private final String algo;\n+    private CipherCore cipher;\n+    private MessageDigest md;\n+    private int blkSize;\n+    private String algo = null;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBES1Core.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,1 +95,1 @@\n-    private static final ObjectIdentifier pkcs5PBKDF2_OID =\n+    private static ObjectIdentifier pkcs5PBKDF2_OID =\n@@ -97,1 +97,1 @@\n-    private static final ObjectIdentifier pkcs5PBES2_OID =\n+    private static ObjectIdentifier pkcs5PBES2_OID =\n@@ -99,1 +99,1 @@\n-    private static final ObjectIdentifier aes128CBC_OID =\n+    private static ObjectIdentifier aes128CBC_OID =\n@@ -101,1 +101,1 @@\n-    private static final ObjectIdentifier aes192CBC_OID =\n+    private static ObjectIdentifier aes192CBC_OID =\n@@ -103,1 +103,1 @@\n-    private static final ObjectIdentifier aes256CBC_OID =\n+    private static ObjectIdentifier aes256CBC_OID =\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBES2Parameters.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-    private final PBES1Core core;\n+    private PBES1Core core;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBEWithMD5AndDESCipher.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-    private final PBES1Core core;\n+    private PBES1Core core;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBEWithMD5AndTripleDESCipher.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.io.*;\n+import java.io.ObjectStreamException;\n@@ -61,1 +61,1 @@\n-    private static final long serialVersionUID = -2234868909660948157L;\n+    static final long serialVersionUID = -2234868909660948157L;\n@@ -63,4 +63,4 @@\n-    private final char[] passwd;\n-    private final byte[] salt;\n-    private final int iterCount;\n-    private final byte[] key;\n+    private char[] passwd;\n+    private byte[] salt;\n+    private int iterCount;\n+    private byte[] key;\n@@ -69,2 +69,2 @@\n-    private final transient Mac prf;\n-    private final transient Cleaner.Cleanable cleaner;\n+    private transient Mac prf;\n+    private transient Cleaner.Cleanable cleaner;\n@@ -96,1 +96,0 @@\n-        byte[] key = null;\n@@ -115,1 +114,1 @@\n-            key = deriveKey(prf, passwdBytes, salt, iterCount, keyLength);\n+            this.key = deriveKey(prf, passwdBytes, salt, iterCount, keyLength);\n@@ -126,1 +125,1 @@\n-        final byte[] k = this.key = key;\n+        final byte[] k = this.key;\n@@ -145,1 +144,0 @@\n-            String algName = prf.getAlgorithm();\n@@ -152,1 +150,1 @@\n-                    return algName;\n+                    return prf.getAlgorithm();\n@@ -165,1 +163,1 @@\n-                      algName.toLowerCase(Locale.ENGLISH).hashCode();\n+                      prf.getAlgorithm().toLowerCase(Locale.ENGLISH).hashCode();\n@@ -172,1 +170,1 @@\n-                    return algName.equalsIgnoreCase(\n+                    return prf.getAlgorithm().equalsIgnoreCase(\n@@ -176,8 +174,0 @@\n-                \/\/ This derived key can't be deserialized.\n-                @java.io.Serial\n-                private void readObject(ObjectInputStream stream)\n-                        throws IOException, ClassNotFoundException {\n-                    throw new InvalidObjectException(\n-                            \"PBKDF2KeyImpl SecretKeys are not \" +\n-                            \"directly deserializable\");\n-                }\n@@ -185,1 +175,0 @@\n-\n@@ -317,16 +306,0 @@\n-\n-    \/**\n-     * Restores the state of this object from the stream.\n-     * <p>\n-     * Deserialization of this class is not supported.\n-     *\n-     * @param  stream the {@code ObjectInputStream} from which data is read\n-     * @throws IOException if an I\/O error occurs\n-     * @throws ClassNotFoundException if a serialized class cannot be loaded\n-     *\/\n-    @java.io.Serial\n-    private void readObject(ObjectInputStream stream)\n-            throws IOException, ClassNotFoundException {\n-        throw new InvalidObjectException(\n-                \"PBKDF2KeyImpl keys are not directly deserializable\");\n-    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBKDF2KeyImpl.java","additions":13,"deletions":40,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-    private final int blockSize;\n+    private int blockSize;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PKCS5Padding.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-    private final AlgorithmId algid;\n+    private AlgorithmId algid;\n@@ -59,1 +59,1 @@\n-    private final byte[] privkey;\n+    private byte[] privkey;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PrivateKeyInfo.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import java.io.IOException;\n-import java.io.InvalidObjectException;\n-import java.io.ObjectInputStream;\n@@ -68,1 +65,1 @@\n-        if (!(params instanceof TlsMasterSecretParameterSpec)) {\n+        if (params instanceof TlsMasterSecretParameterSpec == false) {\n@@ -72,1 +69,1 @@\n-        if (!\"RAW\".equals(spec.getPremasterSecret().getFormat())) {\n+        if (\"RAW\".equals(spec.getPremasterSecret().getFormat()) == false) {\n@@ -197,17 +194,1 @@\n-       \/**\n-        * Restores the state of this object from the stream.\n-        *\n-        * @param  stream the {@code ObjectInputStream} from which data is read\n-        * @throws IOException if an I\/O error occurs\n-        * @throws ClassNotFoundException if a serialized class cannot be loaded\n-        *\/\n-       @java.io.Serial\n-       private void readObject(ObjectInputStream stream)\n-               throws IOException, ClassNotFoundException {\n-           stream.defaultReadObject();\n-           if ((key == null) || (key.length == 0)) {\n-               throw new InvalidObjectException(\"TlsMasterSecretKey is null\");\n-           }\n-           key = key.clone();\n-       }\n-   }\n+    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/TlsMasterSecretGenerator.java","additions":4,"deletions":23,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.ValueLayout;\n@@ -1841,15 +1839,0 @@\n-    boolean bytesCompatible(Charset charset) {\n-        if (isLatin1()) {\n-            if (charset == ISO_8859_1.INSTANCE) {\n-                return true; \/\/ ok, same encoding\n-            } else if (charset == UTF_8.INSTANCE || charset == US_ASCII.INSTANCE) {\n-                return !StringCoding.hasNegatives(value, 0, value.length); \/\/ ok, if ASCII-compatible\n-            }\n-        }\n-        return false;\n-    }\n-\n-    void copyToSegmentRaw(MemorySegment segment, long offset) {\n-        MemorySegment.copy(value, 0, segment, ValueLayout.JAVA_BYTE, offset, value.length);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import java.lang.foreign.MemorySegment;\n@@ -92,0 +91,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -2672,10 +2672,0 @@\n-\n-            @Override\n-            public void copyToSegmentRaw(String string, MemorySegment segment, long offset) {\n-                string.copyToSegmentRaw(segment, offset);\n-            }\n-\n-            @Override\n-            public boolean bytesCompatible(String string, Charset charset) {\n-                return string.bytesCompatible(charset);\n-            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n- * SequenceLayout TAGGED_VALUES = MemoryLayout.sequenceLayout(5,\n+ * SequenceLayout taggedValues = MemoryLayout.sequenceLayout(5,\n@@ -135,1 +135,1 @@\n- * long valueOffset = TAGGED_VALUES.byteOffset(PathElement.sequenceElement(0),\n+ * long valueOffset = taggedValues.byteOffset(PathElement.sequenceElement(0),\n@@ -141,1 +141,1 @@\n- * MemoryLayout value = TAGGED_VALUES.select(PathElement.sequenceElement(),\n+ * MemoryLayout value = taggedValues.select(PathElement.sequenceElement(),\n@@ -154,1 +154,1 @@\n- * VarHandle valueHandle = TAGGED_VALUES.varHandle(PathElement.sequenceElement(),\n+ * VarHandle valueHandle = taggedValues.varHandle(PathElement.sequenceElement(),\n@@ -156,5 +156,2 @@\n- * MemorySegment taggedValues = ...\n- * \/\/ reads the \"value\" field of the third struct in the array (taggedValues[2].value)\n- * int val = (int) valueHandle.get(taggedValues,\n- *         0L,  \/\/ base offset\n- *         2L); \/\/ sequence index\n+ * MemorySegment valuesSegment = ...\n+ * int val = (int) valueHandle.get(valuesSegment, 2); \/\/ reads the \"value\" field of the third struct in the array\n@@ -170,1 +167,1 @@\n- * MethodHandle offsetHandle = TAGGED_VALUES.byteOffsetHandle(PathElement.sequenceElement(),\n+ * MethodHandle offsetHandle = taggedValues.byteOffsetHandle(PathElement.sequenceElement(),\n@@ -172,2 +169,2 @@\n- * long offset1 = (long) offsetHandle.invokeExact(0L, 1L); \/\/ 0 + (1 * 8) = 8\n- * long offset2 = (long) offsetHandle.invokeExact(0L, 2L); \/\/ 0 + (2 * 8) = 16\n+ * long offset1 = (long) offsetHandle.invokeExact(1L); \/\/ 8\n+ * long offset2 = (long) offsetHandle.invokeExact(2L); \/\/ 16\n@@ -211,4 +208,1 @@\n- * \/\/ dereferences the third point struct in the \"points\" array, and reads its \"y\" coordinate (rect.points[2]->y)\n- * int rect_y_2 = (int) rectPointYs.get(rect,\n- *     0L,  \/\/ base offset\n- *     2L); \/\/ sequence index\n+ * int rect_y_4 = (int) rectPointYs.get(rect, 2); \/\/ rect.points[2]->y\n@@ -278,61 +272,0 @@\n- * <h2 id=\"variable-length\">Working with variable-length structs<\/h2>\n- *\n- * Memory layouts allow clients to describe the contents of a region of memory whose size is known <em>statically<\/em>.\n- * There are, however, cases, where the size of a region of memory is only known <em>dynamically<\/em>, as it depends\n- * on the value of one or more struct fields. Consider the following struct declaration in C:\n- *\n- * {@snippet lang=c :\n- * typedef struct {\n- *     int size;\n- *     struct {\n- *         int x;\n- *         int y;\n- *     } points[];\n- * } Polygon;\n- * }\n- *\n- * In the above code, a polygon is modelled as a size (the number of edges in the polygon) and an array of points\n- * (one for each vertex in the polygon). The number of vertices depends on the number of edges in the polygon. As such,\n- * the size of the {@code points} array is left <em>unspecified<\/em> in the C declaration, using a <em>Flexible Array Member<\/em>\n- * (a feature standardized in C99).\n- * <p>\n- * Memory layouts do not support sequence layouts whose size is unknown. As such, it is not possible to model\n- * the above struct directly. That said, clients can still enjoy structured access provided by memory layouts, as\n- * demonstrated below:\n- *\n- * {@snippet lang=java :\n- * StructLayout POINT = MemoryLayout.structLayout(\n- *             ValueLayout.JAVA_INT.withName(\"x\"),\n- *             ValueLayout.JAVA_INT.withName(\"y\")\n- * );\n- *\n- * StructLayout POLYGON = MemoryLayout.structLayout(\n- *             ValueLayout.JAVA_INT.withName(\"size\"),\n- *             MemoryLayout.sequenceLayout(0, POINT).withName(\"points\")\n- * );\n- *\n- * VarHandle POLYGON_SIZE = POLYGON.varHandle(0, PathElement.groupElement(\"size\"));\n- * VarHandle POINT_X = POINT.varHandle(PathElement.groupElement(\"x\"));\n- * long POINTS_OFFSET = POLYGON.byteOffset(PathElement.groupElement(\"points\"));\n- * }\n- *\n- * Note how we have split the polygon struct in two. The {@code POLYGON} layout contains a sequence layout\n- * of size <em>zero<\/em>. The element layout of the sequence layout is the {@code POINT} layout, which defines\n- * the {@code x} and {@code y} coordinates, accordingly. The first layout is used to obtain a var handle\n- * that provides access to the polygon size; the second layout is used to obtain a var handle that provides\n- * access to the {@code x} coordinate of a point struct. Finally, an offset to the start of the variable-length\n- * {@code points} array is also obtained.\n- * <p>\n- * The {@code x} coordinates of all the points in a polygon can then be accessed as follows:\n- * {@snippet lang=java :\n- * MemorySegment polygon = ...\n- * int size = POLYGON_SIZE.get(polygon, 0L);\n- * for (int i = 0 ; i < size ; i++) {\n- *     int x = POINT_X.get(polygon, POINT.scaleOffset(POINTS_OFFSET, i));\n- * }\n- *  }\n- * Here, we first obtain the polygon size, using the {@code POLYGON_SIZE} var handle. Then, in a loop, we read\n- * the {@code x} coordinates of all the points in the polygon. This is done by providing a custom base offset to\n- * the {@code POINT_X} var handle. The custom offset is computed as {@code POINTS_OFFSET + (i * POINT.byteSize())}, where\n- * {@code i} is the loop induction variable.\n- *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":10,"deletions":77,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -29,3 +29,0 @@\n-import java.lang.foreign.ValueLayout.OfInt;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n@@ -47,0 +44,1 @@\n+import jdk.internal.foreign.HeapMemorySegmentImpl;\n@@ -48,1 +46,1 @@\n-import jdk.internal.foreign.SegmentFactories;\n+import jdk.internal.foreign.NativeMemorySegmentImpl;\n@@ -125,0 +123,1 @@\n+ * MemorySegment segment = ...\n@@ -128,12 +127,5 @@\n- * Access operations on memory segments are implemented using var handles. The {@link ValueLayout#varHandle()}\n- * method can be used to obtain a var handle that can be used to get\/set values represented by the given value layout\n- * on a memory segment at the given offset:\n- *\n- * {@snippet lang=java:\n- * VarHandle intAtOffsetHandle = ValueLayout.JAVA_INT.varHandle(); \/\/ (MemorySegment, long)\n- * int value = (int) intAtOffsetHandle.get(segment, 10L);          \/\/ segment.get(ValueLayout.JAVA_INT, 10L)\n- * }\n- *\n- * The var handle returned by {@link ValueLayout#varHandle()} features a <em>base offset<\/em> parameter. This parameter\n- * allows clients to express complex access operations, by injecting additional offset computation into the var handle.\n- * For instance, a var handle that can be used to access an element of an {@code int} array at a given logical\n+ * More complex access operations can be implemented using var handles. The {@link ValueLayout#varHandle()}\n+ * method can be used to obtain a var handle that can be used to get\/set values represented by the given value layout on a memory segment.\n+ * A var handle obtained from a layout supports several additional <a href=MemoryLayout.html#access-mode-restrictions>\n+ * access modes<\/a>. More importantly, var handles can be <em>combined<\/em> with method handles to express complex access\n+ * operations. For instance, a var handle that can be used to access an element of an {@code int} array at a given logical\n@@ -143,4 +135,6 @@\n- * MethodHandle scale = ValueLayout.JAVA_INT.scaleHandle();              \/\/ (long, long)long\n- * VarHandle intAtOffsetAndIndexHandle =\n- *         MethodHandles.collectCoordinates(intAtOffsetHandle, 1, scale); \/\/ (MemorySegment, long, long)\n- * int value = (int) intAtOffsetAndIndexHandle.get(segment, 2L, 3L);     \/\/ segment.get(ValueLayout.JAVA_INT, 2L + (3L * 4L))\n+ * MemorySegment segment = ...\n+ * VarHandle intHandle = ValueLayout.JAVA_INT.varHandle(); \/\/ (MemorySegment, long)\n+ * MethodHandle scale = ValueLayout.JAVA_INT.scaleHandle(); \/\/ <base offset> + <index> * JAVA_INT.byteSize()\n+ *\n+ * intHandle = MethodHandles.filterCoordinates(intHandle, 1, scale);\n+ * int value = (int) intHandle.get(segment, 0L, 3L); \/\/ get int element at offset 0 + 3 * 4 = 12\n@@ -149,3 +143,5 @@\n- * <p>\n- * Clients can also drop the base offset parameter, in order to make the access expression simpler. This can be used to\n- * implement access operation such as {@link #getAtIndex(OfInt, long)}:\n+ * To make the process of creating these var handles easier, the method\n+ * {@link MemoryLayout#varHandle(MemoryLayout.PathElement...)} can be used, by providing it a so called\n+ * <a href=\"MemoryLayout.html#layout-paths\"><em>layout path<\/em><\/a>. A layout path, consisting of several <em>layout\n+ * path elements<\/em>, selects a value layout to be accessed, which can be nested inside another memory layout. For example,\n+ * we can express the access to an element of an {@code int} array using layout paths like so:\n@@ -153,4 +149,9 @@\n- * {@snippet lang=java:\n- * VarHandle intAtIndexHandle =\n- *         MethodHandles.insertCoordinates(intAtOffsetAndIndexHandle, 1, 0L); \/\/ (MemorySegment, long)\n- * int value = (int) intAtIndexHandle.get(segment, 3L);                       \/\/ segment.getAtIndex(ValueLayout.JAVA_INT, 3L);\n+ * {@snippet lang=java :\n+ * MemorySegment segment = ...\n+ * MemoryLayout segmentLayout = MemoryLayout.structLayout(\n+ *     ValueLayout.JAVA_INT.withName(\"size\"),\n+ *     MemoryLayout.sequenceLayout(4, ValueLayout.JAVA_INT).withName(\"data\") \/\/ array of 4 elements\n+ * );\n+ * VarHandle intHandle = segmentLayout.varHandle(MemoryLayout.PathElement.groupElement(\"data\"),\n+ *                                               MemoryLayout.PathElement.sequenceElement());\n+ * int value = (int) intHandle.get(segment, 0L, 3L); \/\/ get int element at offset 0 + offsetof(data) + 3 * 4 = 12\n@@ -158,0 +159,1 @@\n+ * Where {@code offsetof(data)} is the offset of the {@code data} element layout of the {@code segmentLayout} layout\n@@ -159,2 +161,7 @@\n- * Var handles for more complex access expressions (e.g. struct field access, pointer dereference) can be created directly\n- * from memory layouts, using <a href=\"MemoryLayout.html#layout-paths\"><em>layout paths<\/em><\/a>.\n+ * Both the var handle returned by {@link ValueLayout#varHandle()} and\n+ * {@link MemoryLayout#varHandle(MemoryLayout.PathElement...)}, as well as the method handle returned by\n+ * {@link MemoryLayout#byteOffsetHandle(MemoryLayout.PathElement...)} and {@link MemoryLayout#sliceHandle(MemoryLayout.PathElement...)}\n+ * feature a <em>base offset<\/em> parameter. This parameter represents a base offset for the offset computation. This\n+ * parameter allows a client to combine these handles further with additional offset computations. This is demonstrated\n+ * in the first of the two examples above, where {@code intHandle} is combined with a\n+ * {@linkplain MemoryLayout#scaleHandle() scale handle} obtained from {@code ValueLayout.JAVA_INT}.\n@@ -1072,1 +1079,1 @@\n-        return getString(offset, sun.nio.cs.UTF_8.INSTANCE);\n+        return getString(offset, StandardCharsets.UTF_8);\n@@ -1128,1 +1135,1 @@\n-        setString(offset, str, sun.nio.cs.UTF_8.INSTANCE);\n+        setString(offset, str, StandardCharsets.UTF_8);\n@@ -1205,1 +1212,1 @@\n-        return SegmentFactories.fromArray(byteArray);\n+        return HeapMemorySegmentImpl.OfByte.fromArray(byteArray);\n@@ -1217,1 +1224,1 @@\n-        return SegmentFactories.fromArray(charArray);\n+        return HeapMemorySegmentImpl.OfChar.fromArray(charArray);\n@@ -1229,1 +1236,1 @@\n-        return SegmentFactories.fromArray(shortArray);\n+        return HeapMemorySegmentImpl.OfShort.fromArray(shortArray);\n@@ -1241,1 +1248,1 @@\n-        return SegmentFactories.fromArray(intArray);\n+        return HeapMemorySegmentImpl.OfInt.fromArray(intArray);\n@@ -1253,1 +1260,1 @@\n-        return SegmentFactories.fromArray(floatArray);\n+        return HeapMemorySegmentImpl.OfFloat.fromArray(floatArray);\n@@ -1265,1 +1272,1 @@\n-        return SegmentFactories.fromArray(longArray);\n+        return HeapMemorySegmentImpl.OfLong.fromArray(longArray);\n@@ -1277,1 +1284,1 @@\n-        return SegmentFactories.fromArray(doubleArray);\n+        return HeapMemorySegmentImpl.OfDouble.fromArray(doubleArray);\n@@ -1281,1 +1288,1 @@\n-     * A zero-length native segment modelling the {@code NULL} address. Equivalent to {@code MemorySegment.ofAddress(0L)}.\n+     * A zero-length native segment modelling the {@code NULL} address.\n@@ -1283,1 +1290,1 @@\n-    MemorySegment NULL = MemorySegment.ofAddress(0L);\n+    MemorySegment NULL = new NativeMemorySegmentImpl();\n@@ -1297,1 +1304,1 @@\n-        return SegmentFactories.makeNativeSegmentUnchecked(address, 0);\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, 0);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":48,"deletions":41,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-        return allocateFrom(str, sun.nio.cs.UTF_8.INSTANCE);\n+        return allocateFrom(str, StandardCharsets.UTF_8);\n@@ -127,12 +127,3 @@\n-        MemorySegment segment;\n-        int length;\n-        if (StringSupport.bytesCompatible(str, charset)) {\n-            length = str.length();\n-            segment = allocateNoInit((long) length + termCharSize);\n-            StringSupport.copyToSegmentRaw(str, segment, 0);\n-        } else {\n-            byte[] bytes = str.getBytes(charset);\n-            length = bytes.length;\n-            segment = allocateNoInit((long) bytes.length + termCharSize);\n-            MemorySegment.copy(bytes, 0, segment, ValueLayout.JAVA_BYTE, 0, bytes.length);\n-        }\n+        byte[] bytes = str.getBytes(charset);\n+        MemorySegment segment = allocateNoInit(bytes.length + termCharSize);\n+        MemorySegment.copy(bytes, 0, segment, ValueLayout.JAVA_BYTE, 0, bytes.length);\n@@ -140,1 +131,1 @@\n-            segment.set(ValueLayout.JAVA_BYTE, length + i, (byte)0);\n+            segment.set(ValueLayout.JAVA_BYTE, bytes.length + i, (byte)0);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":5,"deletions":14,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -138,2 +138,2 @@\n- * @apiNote Usual memory model guarantees (see {@jls 17.4}) do not apply when accessing native memory segments as\n- * these segments are backed by off-heap regions of memory.\n+ * @apiNote Usual memory model guarantees, for example stated in {@jls 6.6} and {@jls 10.4}, do not apply\n+ * when accessing native memory segments as these segments are backed by off-heap regions of memory.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.foreign.Utils;\n-\n@@ -59,1 +57,1 @@\n-        return new IllegalArgumentException(\"Misaligned access at address: \" + Utils.toHexString(address));\n+        return new IllegalArgumentException(\"Misaligned access at address: \" + address);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandleSegmentViewBase.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1099,4 +1099,1 @@\n-            long duration = SocketReadEvent.timestamp() - start;\n-            if (SocketReadEvent.shouldCommit(duration)) {\n-                SocketReadEvent.emit(start, duration, nbytes, parent.getRemoteSocketAddress(), getSoTimeout());\n-            }\n+            SocketReadEvent.offer(start, nbytes, parent.getRemoteSocketAddress(), getSoTimeout());\n@@ -1215,4 +1212,1 @@\n-            long duration = SocketWriteEvent.timestamp() - start;\n-            if (SocketWriteEvent.shouldCommit(duration)) {\n-                SocketWriteEvent.emit(start, duration, len, parent.getRemoteSocketAddress());\n-            }\n+            SocketWriteEvent.offer(start, len, parent.getRemoteSocketAddress());\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -282,3 +282,0 @@\n-#if[byte]\n- * @sealedGraph\n-#end[byte]\n","filename":"src\/java.base\/share\/classes\/java\/nio\/X-Buffer.java.template","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-        sb.append(\"Signer: \").append(signerCertPath.getCertificates().get(0));\n+        sb.append(\"Signer: \" + signerCertPath.getCertificates().get(0));\n@@ -147,1 +147,1 @@\n-            sb.append(\"timestamp: \").append(timestamp);\n+            sb.append(\"timestamp: \" + timestamp);\n@@ -163,6 +163,3 @@\n-            throws IOException, ClassNotFoundException {\n-        ois.defaultReadObject();\n-        if (signerCertPath == null) {\n-            throw new InvalidObjectException(\"signerCertPath is null\");\n-        }\n-        myhash = -1;\n+        throws IOException, ClassNotFoundException {\n+     ois.defaultReadObject();\n+     myhash = -1;\n","filename":"src\/java.base\/share\/classes\/java\/security\/CodeSigner.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import java.util.Date;\n+import java.util.*;\n@@ -32,0 +32,2 @@\n+import sun.security.x509.GeneralNameInterface;\n+\n@@ -56,0 +58,5 @@\n+    protected void implSetPathToNames(X509CertSelector sel,\n+            Set<GeneralNameInterface> names) {\n+        sel.setPathToNamesInternal(names);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/security\/cert\/CertPathHelperImpl.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,0 +90,4 @@\n+    static {\n+        CertPathHelperImpl.initialize();\n+    }\n+\n@@ -1126,0 +1130,8 @@\n+    \/\/ called from CertPathHelper\n+    void setPathToNamesInternal(Set<GeneralNameInterface> names) {\n+        \/\/ set names to non-null dummy value\n+        \/\/ this breaks getPathToNames()\n+        pathToNames = Collections.<List<?>>emptySet();\n+        pathToGeneralNames = names;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/security\/cert\/X509CertSelector.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,3 +31,0 @@\n-import java.io.IOException;\n-import java.io.InvalidObjectException;\n-import java.io.ObjectInputStream;\n@@ -66,1 +63,1 @@\n-    private byte[] key;\n+    private final byte[] key;\n@@ -257,22 +254,0 @@\n-\n-    \/**\n-     * Restores the state of this object from the stream.\n-     *\n-     * @param  stream the {@code ObjectInputStream} from which data is read\n-     * @throws IOException if an I\/O error occurs\n-     * @throws ClassNotFoundException if a serialized class cannot be loaded\n-     *\/\n-    @java.io.Serial\n-    private void readObject(ObjectInputStream stream)\n-            throws IOException, ClassNotFoundException {\n-        stream.defaultReadObject();\n-\n-        if (key == null || algorithm == null) {\n-            throw new InvalidObjectException(\"Missing argument\");\n-        }\n-\n-        this.key = key.clone();\n-        if (key.length == 0) {\n-            throw new InvalidObjectException(\"Invalid key length\");\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/spec\/SecretKeySpec.java","additions":1,"deletions":26,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,0 @@\n-import java.io.IOException;\n-import java.io.InvalidObjectException;\n-import java.io.ObjectInputStream;\n-\n@@ -55,1 +51,1 @@\n-    private String[] choices;\n+    private final String[] choices;\n@@ -79,0 +75,1 @@\n+     *\n@@ -110,5 +107,0 @@\n-        this.prompt = prompt;\n-        this.defaultChoice = defaultChoice;\n-        this.multipleSelectionsAllowed = multipleSelectionsAllowed;\n-\n-        this.choices = choices.clone();\n@@ -119,0 +111,5 @@\n+\n+        this.prompt = prompt;\n+        this.choices = choices.clone();\n+        this.defaultChoice = defaultChoice;\n+        this.multipleSelectionsAllowed = multipleSelectionsAllowed;\n@@ -202,34 +199,0 @@\n-\n-    \/**\n-     * Restores the state of this object from the stream.\n-     *\n-     * @param  stream the {@code ObjectInputStream} from which data is read\n-     * @throws IOException if an I\/O error occurs\n-     * @throws ClassNotFoundException if a serialized class cannot be loaded\n-     *\/\n-    @java.io.Serial\n-    private void readObject(ObjectInputStream stream)\n-            throws IOException, ClassNotFoundException {\n-        stream.defaultReadObject();\n-\n-        if ((prompt == null) || prompt.isEmpty() ||\n-                (choices == null) || (choices.length == 0) ||\n-                (defaultChoice < 0) || (defaultChoice >= choices.length)) {\n-            throw new InvalidObjectException(\n-                    \"Missing\/invalid prompt\/choices\");\n-        }\n-\n-        choices = choices.clone();\n-        for (int i = 0; i < choices.length; i++) {\n-            if ((choices[i] == null) || choices[i].isEmpty())\n-                throw new InvalidObjectException(\"Null\/empty choices\");\n-        }\n-\n-        if (selections != null) {\n-            selections = selections.clone();\n-            if (!multipleSelectionsAllowed && (selections.length != 1)) {\n-                throw new InvalidObjectException(\n-                        \"Multiple selections not allowed\");\n-            }\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/callback\/ChoiceCallback.java","additions":8,"deletions":45,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import java.io.IOException;\n-import java.io.ObjectInputStream;\n-\n@@ -153,1 +150,1 @@\n-    private String[] options;\n+    private final String[] options;\n@@ -258,6 +255,0 @@\n-        this.prompt = null;\n-        this.messageType = messageType;\n-        this.optionType = UNSPECIFIED_OPTION;\n-        this.defaultOption = defaultOption;\n-\n-        this.options = options.clone();\n@@ -268,0 +259,6 @@\n+\n+        this.prompt = null;\n+        this.messageType = messageType;\n+        this.optionType = UNSPECIFIED_OPTION;\n+        this.options = options.clone();\n+        this.defaultOption = defaultOption;\n@@ -378,6 +375,0 @@\n-        this.prompt = prompt;\n-        this.messageType = messageType;\n-        this.optionType = UNSPECIFIED_OPTION;\n-        this.defaultOption = defaultOption;\n-\n-        this.options = options.clone();\n@@ -388,0 +379,6 @@\n+\n+        this.prompt = prompt;\n+        this.messageType = messageType;\n+        this.optionType = UNSPECIFIED_OPTION;\n+        this.options = options.clone();\n+        this.defaultOption = defaultOption;\n@@ -493,16 +490,0 @@\n-\n-    \/**\n-     * Restores the state of this object from the stream.\n-     *\n-     * @param  stream the {@code ObjectInputStream} from which data is read\n-     * @throws IOException if an I\/O error occurs\n-     * @throws ClassNotFoundException if a serialized class cannot be loaded\n-     *\/\n-    @java.io.Serial\n-    private void readObject(ObjectInputStream stream)\n-            throws IOException, ClassNotFoundException {\n-        stream.defaultReadObject();\n-        if (options != null) {\n-            options = options.clone();\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/callback\/ConfirmationCallback.java","additions":14,"deletions":33,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import java.io.IOException;\n-import java.io.InvalidObjectException;\n-import java.io.ObjectInputStream;\n@@ -163,23 +160,0 @@\n-\n-    \/**\n-     * Restores the state of this object from the stream.\n-     *\n-     * @param  stream the {@code ObjectInputStream} from which data is read\n-     * @throws IOException if an I\/O error occurs\n-     * @throws ClassNotFoundException if a serialized class cannot be loaded\n-     *\/\n-    @java.io.Serial\n-    private void readObject(ObjectInputStream stream)\n-            throws IOException, ClassNotFoundException {\n-        stream.defaultReadObject();\n-\n-        if (prompt == null || prompt.isEmpty()) {\n-            throw new InvalidObjectException(\"Missing prompt\");\n-        }\n-\n-        if (inputPassword != null) {\n-            inputPassword = inputPassword.clone();\n-            cleanable = CleanerFactory.cleaner().register(\n-                    this, cleanerFor(inputPassword));\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/callback\/PasswordCallback.java","additions":1,"deletions":27,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.foreign.MemorySegment;\n@@ -578,10 +577,0 @@\n-\n-    \/**\n-     * Copy the string bytes to an existing segment, avoiding intermediate copies.\n-     *\/\n-    void copyToSegmentRaw(String string, MemorySegment segment, long offset);\n-\n-    \/**\n-     * Are the string bytes compatible with the given charset?\n-     *\/\n-    boolean bytesCompatible(String string, Charset charset);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -116,1 +116,0 @@\n-     * @param duration the duration\n@@ -121,8 +120,11 @@\n-    public static void emit(long start, long duration, long nbytes, SocketAddress remote, long timeout) {\n-        boolean eof = nbytes < 0 ? true : false;\n-        nbytes = nbytes < 0 ? 0 : nbytes;\n-        if (remote instanceof InetSocketAddress isa) {\n-            commit(start, duration, isa.getHostString(), isa.getAddress().getHostAddress(), isa.getPort(), timeout, nbytes, eof);\n-        } else if (remote instanceof UnixDomainSocketAddress udsa) {\n-            String path = \"[\" + udsa.getPath().toString() + \"]\";\n-            commit(start, duration, \"Unix domain socket\", path, 0, timeout, nbytes, eof);\n+    public static void offer(long start, long nbytes, SocketAddress remote, long timeout) {\n+        long duration = timestamp() - start;\n+        if (shouldCommit(duration)) {\n+            boolean eof = nbytes < 0 ? true : false;\n+            nbytes = nbytes < 0 ? 0 : nbytes;\n+            if (remote instanceof InetSocketAddress isa) {\n+                commit(start, duration, isa.getHostString(), isa.getAddress().getHostAddress(), isa.getPort(), timeout, nbytes, eof);\n+            } else if (remote instanceof UnixDomainSocketAddress udsa) {\n+                String path = \"[\" + udsa.getPath().toString() + \"]\";\n+                commit(start, duration, \"Unix domain socket\", path, 0, timeout, nbytes, eof);\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/SocketReadEvent.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -111,1 +111,0 @@\n-     * @param duration the duration\n@@ -115,7 +114,10 @@\n-    public static void emit(long start, long duration, long bytesWritten, SocketAddress remote) {\n-        long bytes = bytesWritten < 0 ? 0 : bytesWritten;\n-        if (remote instanceof InetSocketAddress isa) {\n-            commit(start, duration, isa.getHostString(), isa.getAddress().getHostAddress(), isa.getPort(), bytes);\n-        } else if (remote instanceof UnixDomainSocketAddress udsa) {\n-            String path = \"[\" + udsa.getPath().toString() + \"]\";\n-            commit(start, duration, \"Unix domain socket\", path, 0, bytes);\n+    public static void offer(long start, long bytesWritten, SocketAddress remote) {\n+        long duration = timestamp() - start;\n+        if (shouldCommit(duration)) {\n+            long bytes = bytesWritten < 0 ? 0 : bytesWritten;\n+            if (remote instanceof InetSocketAddress isa) {\n+                commit(start, duration, isa.getHostString(), isa.getAddress().getHostAddress(), isa.getPort(), bytes);\n+            } else if (remote instanceof UnixDomainSocketAddress udsa) {\n+                String path = \"[\" + udsa.getPath().toString() + \"]\";\n+                commit(start, duration, \"Unix domain socket\", path, 0, bytes);\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/SocketWriteEvent.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n-                () -> cleanup.accept(SegmentFactories.makeNativeSegmentUnchecked(address(), newSize)) :\n+                () -> cleanup.accept(NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address(), newSize)) :\n@@ -156,1 +156,1 @@\n-        return SegmentFactories.makeNativeSegmentUnchecked(address(), newSize,\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address(), newSize,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-        return SegmentFactories.allocateSegment(byteSize, byteAlignment, session, shouldReserveMemory);\n+        return NativeMemorySegmentImpl.makeNativeSegmentNoZeroing(byteSize, byteAlignment, session, shouldReserveMemory);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ArenaImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -50,1 +51,1 @@\n-abstract sealed class HeapMemorySegmentImpl extends AbstractMemorySegmentImpl {\n+public abstract sealed class HeapMemorySegmentImpl extends AbstractMemorySegmentImpl {\n@@ -112,0 +113,7 @@\n+        public static MemorySegment fromArray(byte[] arr) {\n+            Objects.requireNonNull(arr);\n+            long byteSize = (long)arr.length * Unsafe.ARRAY_BYTE_INDEX_SCALE;\n+            return new OfByte(Unsafe.ARRAY_BYTE_BASE_OFFSET, arr, byteSize, false,\n+                    MemorySessionImpl.heapSession(arr));\n+        }\n+\n@@ -139,0 +147,7 @@\n+        public static MemorySegment fromArray(char[] arr) {\n+            Objects.requireNonNull(arr);\n+            long byteSize = (long)arr.length * Unsafe.ARRAY_CHAR_INDEX_SCALE;\n+            return new OfChar(Unsafe.ARRAY_CHAR_BASE_OFFSET, arr, byteSize, false,\n+                    MemorySessionImpl.heapSession(arr));\n+        }\n+\n@@ -166,0 +181,7 @@\n+        public static MemorySegment fromArray(short[] arr) {\n+            Objects.requireNonNull(arr);\n+            long byteSize = (long)arr.length * Unsafe.ARRAY_SHORT_INDEX_SCALE;\n+            return new OfShort(Unsafe.ARRAY_SHORT_BASE_OFFSET, arr, byteSize, false,\n+                    MemorySessionImpl.heapSession(arr));\n+        }\n+\n@@ -193,0 +215,7 @@\n+        public static MemorySegment fromArray(int[] arr) {\n+            Objects.requireNonNull(arr);\n+            long byteSize = (long)arr.length * Unsafe.ARRAY_INT_INDEX_SCALE;\n+            return new OfInt(Unsafe.ARRAY_INT_BASE_OFFSET, arr, byteSize, false,\n+                    MemorySessionImpl.heapSession(arr));\n+        }\n+\n@@ -220,0 +249,7 @@\n+        public static MemorySegment fromArray(long[] arr) {\n+            Objects.requireNonNull(arr);\n+            long byteSize = (long)arr.length * Unsafe.ARRAY_LONG_INDEX_SCALE;\n+            return new OfLong(Unsafe.ARRAY_LONG_BASE_OFFSET, arr, byteSize, false,\n+                    MemorySessionImpl.heapSession(arr));\n+        }\n+\n@@ -247,0 +283,7 @@\n+        public static MemorySegment fromArray(float[] arr) {\n+            Objects.requireNonNull(arr);\n+            long byteSize = (long)arr.length * Unsafe.ARRAY_FLOAT_INDEX_SCALE;\n+            return new OfFloat(Unsafe.ARRAY_FLOAT_BASE_OFFSET, arr, byteSize, false,\n+                    MemorySessionImpl.heapSession(arr));\n+        }\n+\n@@ -274,0 +317,7 @@\n+        public static MemorySegment fromArray(double[] arr) {\n+            Objects.requireNonNull(arr);\n+            long byteSize = (long)arr.length * Unsafe.ARRAY_DOUBLE_INDEX_SCALE;\n+            return new OfDouble(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, arr, byteSize, false,\n+                    MemorySessionImpl.heapSession(arr));\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":51,"deletions":1,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.vm.annotation.Stable;\n@@ -44,1 +43,0 @@\n-import java.util.Locale;\n@@ -48,3 +46,0 @@\n-import java.util.stream.Stream;\n-\n-import static java.util.stream.Collectors.joining;\n@@ -97,0 +92,1 @@\n+\n@@ -112,1 +108,2 @@\n-        SequenceLayout seq = requireSequenceLayout();\n+        check(SequenceLayout.class, \"attempting to select a sequence element from a non-sequence layout\");\n+        SequenceLayout seq = (SequenceLayout)layout;\n@@ -118,1 +115,2 @@\n-        SequenceLayout seq = requireSequenceLayout();\n+        check(SequenceLayout.class, \"attempting to select a sequence element from a non-sequence layout\");\n+        SequenceLayout seq = (SequenceLayout)layout;\n@@ -127,1 +125,1 @@\n-                addStride(elemSize * step), addBound(maxIndex), derefAdapters, this);\n+                                     addStride(elemSize * step), addBound(maxIndex), derefAdapters, this);\n@@ -131,1 +129,2 @@\n-        SequenceLayout seq = requireSequenceLayout();\n+        check(SequenceLayout.class, \"attempting to select a sequence element from a non-sequence layout\");\n+        SequenceLayout seq = (SequenceLayout)layout;\n@@ -135,1 +134,1 @@\n-        return LayoutPath.nestedPath(seq.elementLayout(), offset + elemOffset, strides, bounds, derefAdapters, this);\n+        return LayoutPath.nestedPath(seq.elementLayout(), offset + elemOffset, strides, bounds, derefAdapters,this);\n@@ -139,1 +138,2 @@\n-        GroupLayout g = requireGroupLayout();\n+        check(GroupLayout.class, \"attempting to select a group element from a non-group layout\");\n+        GroupLayout g = (GroupLayout)layout;\n@@ -153,2 +153,1 @@\n-            throw badLayoutPath(\n-                    String.format(\"cannot resolve '%s' in layout %s\", name, breadcrumbs()));\n+            throw badLayoutPath(\"cannot resolve '\" + name + \"' in layout \" + layout);\n@@ -160,1 +159,2 @@\n-        GroupLayout g = requireGroupLayout();\n+        check(GroupLayout.class, \"attempting to select a group element from a non-group layout\");\n+        GroupLayout g = (GroupLayout)layout;\n@@ -166,2 +166,1 @@\n-                throw badLayoutPath(\n-                        String.format(\"cannot resolve element %d in layout: %s\", index, breadcrumbs()));\n+                throw badLayoutPath(\"cannot resolve element \" + index + \" in layout \" + layout);\n@@ -180,2 +179,1 @@\n-            throw badLayoutPath(\n-                    String.format(\"Cannot dereference layout: %s\", breadcrumbs()));\n+            throw badLayoutPath(\"Cannot dereference layout: \" + layout);\n@@ -206,2 +204,1 @@\n-            throw new IllegalArgumentException(\n-                    String.format(\"Path does not select a value layout: %s\", breadcrumbs()));\n+            throw new IllegalArgumentException(\"Path does not select a value layout\");\n@@ -294,3 +291,1 @@\n-            throw new IllegalArgumentException(String.format(\n-                    \"Target offset %d is incompatible with alignment constraint %d (of %s) for segment %s\"\n-                    , offset, constraint.byteAlignment(), constraint, segment));\n+            throw new IllegalArgumentException(\"Target offset incompatible with alignment constraints: \" + constraint.byteAlignment());\n@@ -322,9 +317,1 @@\n-    private SequenceLayout requireSequenceLayout() {\n-        return requireLayoutType(SequenceLayout.class, \"sequence\");\n-    }\n-\n-    private GroupLayout requireGroupLayout() {\n-        return requireLayoutType(GroupLayout.class, \"group\");\n-    }\n-\n-    private <T extends MemoryLayout> T requireLayoutType(Class<T> layoutClass, String name) {\n+    private void check(Class<?> layoutClass, String msg) {\n@@ -332,3 +319,1 @@\n-            throw badLayoutPath(\n-                    String.format(\"attempting to select a %s element from a non-%s layout: %s\",\n-                            name, name, breadcrumbs()));\n+            throw badLayoutPath(msg);\n@@ -336,1 +321,0 @@\n-        return layoutClass.cast(layout);\n@@ -341,2 +325,1 @@\n-            throw badLayoutPath(String.format(\"sequence index out of bounds; index: %d, elementCount is %d for layout %s\",\n-                    index, seq.elementCount(), breadcrumbs()));\n+            throw badLayoutPath(String.format(\"Sequence index out of bound; found: %d, size: %d\", index, seq.elementCount()));\n@@ -362,7 +345,0 @@\n-    private String breadcrumbs() {\n-        return Stream.iterate(this, Objects::nonNull, lp -> lp.enclosing)\n-                .map(LayoutPath::layout)\n-                .map(Object::toString)\n-                .collect(joining(\", selected from: \"));\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":21,"deletions":45,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-final class MappedMemorySegmentImpl extends NativeMemorySegmentImpl {\n+public final class MappedMemorySegmentImpl extends NativeMemorySegmentImpl {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.misc.VM;\n@@ -40,1 +41,7 @@\n-sealed class NativeMemorySegmentImpl extends AbstractMemorySegmentImpl permits MappedMemorySegmentImpl {\n+public sealed class NativeMemorySegmentImpl extends AbstractMemorySegmentImpl permits MappedMemorySegmentImpl {\n+\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    \/\/ The maximum alignment supported by malloc - typically 16 bytes on\n+    \/\/ 64-bit platforms and 8 bytes on 32-bit platforms.\n+    private static final long MAX_MALLOC_ALIGN = Unsafe.ADDRESS_SIZE == 4 ? 8 : 16;\n@@ -54,0 +61,11 @@\n+    \/**\n+     * This constructor should only be used when initializing {@link MemorySegment#NULL}. Note: because of the memory\n+     * segment class hierarchy, it is possible to end up in a situation where this constructor is called\n+     * when the static fields in this class are not yet initialized.\n+     *\/\n+    @ForceInline\n+    public NativeMemorySegmentImpl() {\n+        super(0L, false, new GlobalSession(null));\n+        this.min = 0L;\n+    }\n+\n@@ -95,0 +113,68 @@\n+\n+    \/\/ factories\n+\n+    public static MemorySegment makeNativeSegmentNoZeroing(long byteSize, long byteAlignment, MemorySessionImpl sessionImpl,\n+                                                  boolean shouldReserve) {\n+        sessionImpl.checkValidState();\n+        if (VM.isDirectMemoryPageAligned()) {\n+            byteAlignment = Math.max(byteAlignment, NIO_ACCESS.pageSize());\n+        }\n+        long alignedSize = Math.max(1L, byteAlignment > MAX_MALLOC_ALIGN ?\n+                byteSize + (byteAlignment - 1) :\n+                byteSize);\n+\n+        if (shouldReserve) {\n+            NIO_ACCESS.reserveMemory(alignedSize, byteSize);\n+        }\n+\n+        long buf = allocateMemoryWrapper(alignedSize);\n+        long alignedBuf = Utils.alignUp(buf, byteAlignment);\n+        AbstractMemorySegmentImpl segment = new NativeMemorySegmentImpl(buf, alignedSize,\n+                false, sessionImpl);\n+        sessionImpl.addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n+            @Override\n+            public void cleanup() {\n+                UNSAFE.freeMemory(buf);\n+                if (shouldReserve) {\n+                    NIO_ACCESS.unreserveMemory(alignedSize, byteSize);\n+                }\n+            }\n+        });\n+        if (alignedSize != byteSize) {\n+            long delta = alignedBuf - buf;\n+            segment = segment.asSlice(delta, byteSize);\n+        }\n+        return segment;\n+    }\n+\n+    private static long allocateMemoryWrapper(long size) {\n+        try {\n+            return UNSAFE.allocateMemory(size);\n+        } catch (IllegalArgumentException ex) {\n+            throw new OutOfMemoryError();\n+        }\n+    }\n+\n+    \/\/ Unsafe native segment factories. These are used by the implementation code, to skip the sanity checks\n+    \/\/ associated with MemorySegment::ofAddress.\n+\n+    @ForceInline\n+    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, MemorySessionImpl sessionImpl, Runnable action) {\n+        if (action == null) {\n+            sessionImpl.checkValidState();\n+        } else {\n+            sessionImpl.addCloseAction(action);\n+        }\n+        return new NativeMemorySegmentImpl(min, byteSize, false, sessionImpl);\n+    }\n+\n+    @ForceInline\n+    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, MemorySessionImpl sessionImpl) {\n+        sessionImpl.checkValidState();\n+        return new NativeMemorySegmentImpl(min, byteSize, false, sessionImpl);\n+    }\n+\n+    @ForceInline\n+    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize) {\n+        return new NativeMemorySegmentImpl(min, byteSize, false, new GlobalSession(null));\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":87,"deletions":1,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -1,211 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.foreign;\n-\n-import jdk.internal.access.foreign.UnmapperProxy;\n-import jdk.internal.foreign.HeapMemorySegmentImpl.OfByte;\n-import jdk.internal.foreign.HeapMemorySegmentImpl.OfChar;\n-import jdk.internal.foreign.HeapMemorySegmentImpl.OfDouble;\n-import jdk.internal.foreign.HeapMemorySegmentImpl.OfFloat;\n-import jdk.internal.foreign.HeapMemorySegmentImpl.OfInt;\n-import jdk.internal.foreign.HeapMemorySegmentImpl.OfLong;\n-import jdk.internal.foreign.HeapMemorySegmentImpl.OfShort;\n-import jdk.internal.misc.Unsafe;\n-import jdk.internal.misc.VM;\n-import jdk.internal.vm.annotation.ForceInline;\n-\n-import java.lang.foreign.MemorySegment;\n-import java.util.Objects;\n-\n-\/**\n- * This class is used to retrieve concrete memory segment implementations, while making sure that classes\n- * are initialized in the right order (that is, that {@code MemorySegment} is always initialized first).\n- * See {@link SegmentFactories#ensureInitialized()}.\n- *\/\n-public class SegmentFactories {\n-\n-    \/\/ The maximum alignment supported by malloc - typically 16 bytes on\n-    \/\/ 64-bit platforms and 8 bytes on 32-bit platforms.\n-    private static final long MAX_MALLOC_ALIGN = Unsafe.ADDRESS_SIZE == 4 ? 8 : 16;\n-\n-    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n-\n-    \/\/ Unsafe native segment factories. These are used by the implementation code, to skip the sanity checks\n-    \/\/ associated with MemorySegment::ofAddress.\n-\n-    @ForceInline\n-    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, MemorySessionImpl sessionImpl, Runnable action) {\n-        ensureInitialized();\n-        if (action == null) {\n-            sessionImpl.checkValidState();\n-        } else {\n-            sessionImpl.addCloseAction(action);\n-        }\n-        return new NativeMemorySegmentImpl(min, byteSize, false, sessionImpl);\n-    }\n-\n-    @ForceInline\n-    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, MemorySessionImpl sessionImpl) {\n-        ensureInitialized();\n-        sessionImpl.checkValidState();\n-        return new NativeMemorySegmentImpl(min, byteSize, false, sessionImpl);\n-    }\n-\n-    @ForceInline\n-    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize) {\n-        ensureInitialized();\n-        return new NativeMemorySegmentImpl(min, byteSize, false, new GlobalSession(null));\n-    }\n-\n-    public static MemorySegment fromArray(byte[] arr) {\n-        ensureInitialized();\n-        Objects.requireNonNull(arr);\n-        long byteSize = (long)arr.length * Unsafe.ARRAY_BYTE_INDEX_SCALE;\n-        return new OfByte(Unsafe.ARRAY_BYTE_BASE_OFFSET, arr, byteSize, false,\n-                MemorySessionImpl.heapSession(arr));\n-    }\n-\n-    public static MemorySegment fromArray(short[] arr) {\n-        ensureInitialized();\n-        Objects.requireNonNull(arr);\n-        long byteSize = (long)arr.length * Unsafe.ARRAY_SHORT_INDEX_SCALE;\n-        return new OfShort(Unsafe.ARRAY_SHORT_BASE_OFFSET, arr, byteSize, false,\n-                MemorySessionImpl.heapSession(arr));\n-    }\n-\n-    public static MemorySegment fromArray(int[] arr) {\n-        ensureInitialized();\n-        Objects.requireNonNull(arr);\n-        long byteSize = (long)arr.length * Unsafe.ARRAY_INT_INDEX_SCALE;\n-        return new OfInt(Unsafe.ARRAY_INT_BASE_OFFSET, arr, byteSize, false,\n-                MemorySessionImpl.heapSession(arr));\n-    }\n-\n-    public static MemorySegment fromArray(char[] arr) {\n-        ensureInitialized();\n-        Objects.requireNonNull(arr);\n-        long byteSize = (long)arr.length * Unsafe.ARRAY_CHAR_INDEX_SCALE;\n-        return new OfChar(Unsafe.ARRAY_CHAR_BASE_OFFSET, arr, byteSize, false,\n-                MemorySessionImpl.heapSession(arr));\n-    }\n-\n-    public static MemorySegment fromArray(float[] arr) {\n-        ensureInitialized();\n-        Objects.requireNonNull(arr);\n-        long byteSize = (long)arr.length * Unsafe.ARRAY_FLOAT_INDEX_SCALE;\n-        return new OfFloat(Unsafe.ARRAY_FLOAT_BASE_OFFSET, arr, byteSize, false,\n-                MemorySessionImpl.heapSession(arr));\n-    }\n-\n-    public static MemorySegment fromArray(double[] arr) {\n-        ensureInitialized();\n-        Objects.requireNonNull(arr);\n-        long byteSize = (long)arr.length * Unsafe.ARRAY_DOUBLE_INDEX_SCALE;\n-        return new OfDouble(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, arr, byteSize, false,\n-                MemorySessionImpl.heapSession(arr));\n-    }\n-\n-    public static MemorySegment fromArray(long[] arr) {\n-        ensureInitialized();\n-        Objects.requireNonNull(arr);\n-        long byteSize = (long)arr.length * Unsafe.ARRAY_LONG_INDEX_SCALE;\n-        return new OfLong(Unsafe.ARRAY_LONG_BASE_OFFSET, arr, byteSize, false,\n-                MemorySessionImpl.heapSession(arr));\n-    }\n-\n-    public static MemorySegment allocateSegment(long byteSize, long byteAlignment, MemorySessionImpl sessionImpl,\n-                                                  boolean shouldReserve) {\n-        ensureInitialized();\n-        sessionImpl.checkValidState();\n-        if (VM.isDirectMemoryPageAligned()) {\n-            byteAlignment = Math.max(byteAlignment, AbstractMemorySegmentImpl.NIO_ACCESS.pageSize());\n-        }\n-        long alignedSize = Math.max(1L, byteAlignment > MAX_MALLOC_ALIGN ?\n-                byteSize + (byteAlignment - 1) :\n-                byteSize);\n-\n-        if (shouldReserve) {\n-            AbstractMemorySegmentImpl.NIO_ACCESS.reserveMemory(alignedSize, byteSize);\n-        }\n-\n-        long buf = allocateMemoryWrapper(alignedSize);\n-        long alignedBuf = Utils.alignUp(buf, byteAlignment);\n-        AbstractMemorySegmentImpl segment = new NativeMemorySegmentImpl(buf, alignedSize,\n-                false, sessionImpl);\n-        sessionImpl.addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n-            @Override\n-            public void cleanup() {\n-                UNSAFE.freeMemory(buf);\n-                if (shouldReserve) {\n-                    AbstractMemorySegmentImpl.NIO_ACCESS.unreserveMemory(alignedSize, byteSize);\n-                }\n-            }\n-        });\n-        if (alignedSize != byteSize) {\n-            long delta = alignedBuf - buf;\n-            segment = segment.asSlice(delta, byteSize);\n-        }\n-        return segment;\n-    }\n-\n-    private static long allocateMemoryWrapper(long size) {\n-        try {\n-            return UNSAFE.allocateMemory(size);\n-        } catch (IllegalArgumentException ex) {\n-            throw new OutOfMemoryError();\n-        }\n-    }\n-\n-    public static MemorySegment mapSegment(long size, UnmapperProxy unmapper, boolean readOnly, MemorySessionImpl sessionImpl) {\n-        ensureInitialized();\n-        if (unmapper != null) {\n-            AbstractMemorySegmentImpl segment =\n-                    new MappedMemorySegmentImpl(unmapper.address(), unmapper, size,\n-                            readOnly, sessionImpl);\n-            MemorySessionImpl.ResourceList.ResourceCleanup resource =\n-                    new MemorySessionImpl.ResourceList.ResourceCleanup() {\n-                        @Override\n-                        public void cleanup() {\n-                            unmapper.unmap();\n-                        }\n-                    };\n-            sessionImpl.addOrCleanupIfFail(resource);\n-            return segment;\n-        } else {\n-            return new MappedMemorySegmentImpl(0, null, 0, readOnly, sessionImpl);\n-        }\n-    }\n-\n-    \/\/ The method below needs to be called before any concrete subclass of MemorySegment\n-    \/\/ is instantiated. This is to make sure that we cannot have an initialization deadlock\n-    \/\/ where one thread attempts to initialize e.g. MemorySegment (and then NativeMemorySegmentImpl, via\n-    \/\/ the MemorySegment.NULL field) while another thread is attempting to initialize\n-    \/\/ NativeMemorySegmentImpl (and then MemorySegment, the super-interface).\n-    @ForceInline\n-    private static void ensureInitialized() {\n-        MemorySegment segment = MemorySegment.NULL;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentFactories.java","additions":0,"deletions":211,"binary":false,"changes":211,"status":"deleted"},{"patch":"@@ -28,6 +28,0 @@\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.foreign.abi.SharedUtils;\n-import jdk.internal.util.ArraysSupport;\n-import sun.security.action.GetPropertyAction;\n-\n@@ -36,0 +30,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -37,1 +32,3 @@\n-import static java.lang.foreign.ValueLayout.*;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n@@ -43,5 +40,0 @@\n-\n-    static final JavaLangAccess JAVA_LANG_ACCESS = SharedSecrets.getJavaLangAccess();\n-\n-    private StringSupport() {}\n-\n@@ -50,3 +42,3 @@\n-            case SINGLE_BYTE -> readByte(segment, offset, charset);\n-            case DOUBLE_BYTE -> readShort(segment, offset, charset);\n-            case QUAD_BYTE -> readInt(segment, offset, charset);\n+            case SINGLE_BYTE -> readFast_byte(segment, offset, charset);\n+            case DOUBLE_BYTE -> readFast_short(segment, offset, charset);\n+            case QUAD_BYTE -> readFast_int(segment, offset, charset);\n@@ -58,3 +50,3 @@\n-            case SINGLE_BYTE -> writeByte(segment, offset, charset, string);\n-            case DOUBLE_BYTE -> writeShort(segment, offset, charset, string);\n-            case QUAD_BYTE -> writeInt(segment, offset, charset, string);\n+            case SINGLE_BYTE -> writeFast_byte(segment, offset, charset, string);\n+            case DOUBLE_BYTE -> writeFast_short(segment, offset, charset, string);\n+            case QUAD_BYTE -> writeFast_int(segment, offset, charset, string);\n@@ -63,3 +55,2 @@\n-\n-    private static String readByte(MemorySegment segment, long offset, Charset charset) {\n-        long len = chunkedStrlenByte(segment, offset);\n+    private static String readFast_byte(MemorySegment segment, long offset, Charset charset) {\n+        long len = strlen_byte(segment, offset);\n@@ -71,3 +62,4 @@\n-    private static void writeByte(MemorySegment segment, long offset, Charset charset, String string) {\n-        int bytes = copyBytes(string, segment, charset, offset);\n-        segment.set(JAVA_BYTE, offset + bytes, (byte)0);\n+    private static void writeFast_byte(MemorySegment segment, long offset, Charset charset, String string) {\n+        byte[] bytes = string.getBytes(charset);\n+        MemorySegment.copy(bytes, 0, segment, JAVA_BYTE, offset, bytes.length);\n+        segment.set(JAVA_BYTE, offset + bytes.length, (byte)0);\n@@ -76,2 +68,2 @@\n-    private static String readShort(MemorySegment segment, long offset, Charset charset) {\n-        long len = chunkedStrlenShort(segment, offset);\n+    private static String readFast_short(MemorySegment segment, long offset, Charset charset) {\n+        long len = strlen_short(segment, offset);\n@@ -83,3 +75,4 @@\n-    private static void writeShort(MemorySegment segment, long offset, Charset charset, String string) {\n-        int bytes = copyBytes(string, segment, charset, offset);\n-        segment.set(JAVA_SHORT, offset + bytes, (short)0);\n+    private static void writeFast_short(MemorySegment segment, long offset, Charset charset, String string) {\n+        byte[] bytes = string.getBytes(charset);\n+        MemorySegment.copy(bytes, 0, segment, JAVA_BYTE, offset, bytes.length);\n+        segment.set(JAVA_SHORT, offset + bytes.length, (short)0);\n@@ -88,2 +81,2 @@\n-    private static String readInt(MemorySegment segment, long offset, Charset charset) {\n-        long len = strlenInt(segment, offset);\n+    private static String readFast_int(MemorySegment segment, long offset, Charset charset) {\n+        long len = strlen_int(segment, offset);\n@@ -95,89 +88,4 @@\n-    private static void writeInt(MemorySegment segment, long offset, Charset charset, String string) {\n-        int bytes = copyBytes(string, segment, charset, offset);\n-        segment.set(JAVA_INT, offset + bytes, 0);\n-    }\n-\n-    \/**\n-     * {@return the shortest distance beginning at the provided {@code start}\n-     *  to the encountering of a zero byte in the provided {@code segment}}\n-     * <p>\n-     * The method divides the region of interest into three distinct regions:\n-     * <ul>\n-     *     <li>head (access made on a byte-by-byte basis) (if any)<\/li>\n-     *     <li>body (access made with eight bytes at a time at physically 64-bit-aligned memory) (if any)<\/li>\n-     *     <li>tail (access made on a byte-by-byte basis) (if any)<\/li>\n-     * <\/ul>\n-     * <p>\n-     * The body is using a heuristic method to determine if a long word\n-     * contains a zero byte. The method might have false positives but\n-     * never false negatives.\n-     * <p>\n-     * This method is inspired by the `glibc\/string\/strlen.c` implementation\n-     *\n-     * @param segment to examine\n-     * @param start   from where examination shall begin\n-     * @throws IllegalArgumentException if the examined region contains no zero bytes\n-     *                                  within a length that can be accepted by a String\n-     *\/\n-    public static int chunkedStrlenByte(MemorySegment segment, long start) {\n-\n-        \/\/ Handle the first unaligned \"head\" bytes separately\n-        int headCount = (int)SharedUtils.remainsToAlignment(segment.address() + start, Long.BYTES);\n-\n-        int offset = 0;\n-        for (; offset < headCount; offset++) {\n-            byte curr = segment.get(JAVA_BYTE, start + offset);\n-            if (curr == 0) {\n-                return offset;\n-            }\n-        }\n-\n-        \/\/ We are now on a long-aligned boundary so this is the \"body\"\n-        int bodyCount = bodyCount(segment.byteSize() - start - headCount);\n-\n-        for (; offset < bodyCount; offset += Long.BYTES) {\n-            \/\/ We know we are `long` aligned so, we can save on alignment checking here\n-            long curr = segment.get(JAVA_LONG_UNALIGNED, start + offset);\n-            \/\/ Is this a candidate?\n-            if (mightContainZeroByte(curr)) {\n-                for (int j = 0; j < 8; j++) {\n-                    if (segment.get(JAVA_BYTE, start + offset + j) == 0) {\n-                        return offset + j;\n-                    }\n-                }\n-            }\n-        }\n-\n-        \/\/ Handle the \"tail\"\n-        return requireWithinArraySize((long) offset + strlenByte(segment, start + offset));\n-    }\n-\n-    \/* Bits 63 and N * 8 (N = 1..7) of this number are zero.  Call these bits\n-       the \"holes\".  Note that there is a hole just to the left of\n-       each byte, with an extra at the end:\n-\n-       bits:  01111110 11111110 11111110 11111110 11111110 11111110 11111110 11111111\n-       bytes: AAAAAAAA BBBBBBBB CCCCCCCC DDDDDDDD EEEEEEEE FFFFFFFF GGGGGGGG HHHHHHHH\n-\n-       The 1-bits make sure that carries propagate to the next 0-bit.\n-       The 0-bits provide holes for carries to fall into.\n-    *\/\n-    private static final long HIMAGIC_FOR_BYTES = 0x8080_8080_8080_8080L;\n-    private static final long LOMAGIC_FOR_BYTES = 0x0101_0101_0101_0101L;\n-\n-    static boolean mightContainZeroByte(long l) {\n-        return ((l - LOMAGIC_FOR_BYTES) & (~l) & HIMAGIC_FOR_BYTES) != 0;\n-    }\n-\n-    private static final long HIMAGIC_FOR_SHORTS = 0x8000_8000_8000_8000L;\n-    private static final long LOMAGIC_FOR_SHORTS = 0x0001_0001_0001_0001L;\n-\n-    static boolean mightContainZeroShort(long l) {\n-        return ((l - LOMAGIC_FOR_SHORTS) & (~l) & HIMAGIC_FOR_SHORTS) != 0;\n-    }\n-\n-    static int requireWithinArraySize(long size) {\n-        if (size > ArraysSupport.SOFT_MAX_ARRAY_LENGTH) {\n-            throw newIaeStringTooLarge();\n-        }\n-        return (int) size;\n+    private static void writeFast_int(MemorySegment segment, long offset, Charset charset, String string) {\n+        byte[] bytes = string.getBytes(charset);\n+        MemorySegment.copy(bytes, 0, segment, JAVA_BYTE, offset, bytes.length);\n+        segment.set(JAVA_INT, offset + bytes.length, 0);\n@@ -186,11 +94,3 @@\n-    static int bodyCount(long remaining) {\n-        return (int) Math.min(\n-                \/\/ Make sure we do not wrap around\n-                Integer.MAX_VALUE - Long.BYTES,\n-                \/\/ Remaining bytes to consider\n-                remaining)\n-                & -Long.BYTES; \/\/ Mask 0xFFFFFFF8\n-    }\n-\n-    private static int strlenByte(MemorySegment segment, long start) {\n-        for (int offset = 0; offset < ArraysSupport.SOFT_MAX_ARRAY_LENGTH; offset += 1) {\n+    private static int strlen_byte(MemorySegment segment, long start) {\n+        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n+        for (int offset = 0; offset >= 0; offset++) {\n@@ -202,1 +102,1 @@\n-        throw newIaeStringTooLarge();\n+        throw new IllegalArgumentException(\"String too large\");\n@@ -205,20 +105,3 @@\n-    \/**\n-     * {@return the shortest distance beginning at the provided {@code start}\n-     *  to the encountering of a zero short in the provided {@code segment}}\n-     * <p>\n-     * Note: The inspected region must be short aligned.\n-     *\n-     * @see #chunkedStrlenByte(MemorySegment, long) for more information\n-     *\n-     * @param segment to examine\n-     * @param start   from where examination shall begin\n-     * @throws IllegalArgumentException if the examined region contains no zero shorts\n-     *                                  within a length that can be accepted by a String\n-     *\/\n-    public static int chunkedStrlenShort(MemorySegment segment, long start) {\n-\n-        \/\/ Handle the first unaligned \"head\" bytes separately\n-        int headCount = (int)SharedUtils.remainsToAlignment(segment.address() + start, Long.BYTES);\n-\n-        int offset = 0;\n-        for (; offset < headCount; offset += Short.BYTES) {\n+    private static int strlen_short(MemorySegment segment, long start) {\n+        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n+        for (int offset = 0; offset >= 0; offset += 2) {\n@@ -230,19 +113,1 @@\n-\n-        \/\/ We are now on a long-aligned boundary so this is the \"body\"\n-        int bodyCount = bodyCount(segment.byteSize() - start - headCount);\n-\n-        for (; offset < bodyCount; offset += Long.BYTES) {\n-            \/\/ We know we are `long` aligned so, we can save on alignment checking here\n-            long curr = segment.get(JAVA_LONG_UNALIGNED, start + offset);\n-            \/\/ Is this a candidate?\n-            if (mightContainZeroShort(curr)) {\n-                for (int j = 0; j < Long.BYTES; j += Short.BYTES) {\n-                    if (segment.get(JAVA_SHORT_UNALIGNED, start + offset + j) == 0) {\n-                        return offset + j;\n-                    }\n-                }\n-            }\n-        }\n-\n-        \/\/ Handle the \"tail\"\n-        return requireWithinArraySize((long) offset + strlenShort(segment, start + offset));\n+        throw new IllegalArgumentException(\"String too large\");\n@@ -251,16 +116,4 @@\n-    private static int strlenShort(MemorySegment segment, long start) {\n-        for (int offset = 0; offset < ArraysSupport.SOFT_MAX_ARRAY_LENGTH; offset += Short.BYTES) {\n-            short curr = segment.get(JAVA_SHORT_UNALIGNED, start + offset);\n-            if (curr == (short)0) {\n-                return offset;\n-            }\n-        }\n-        throw newIaeStringTooLarge();\n-    }\n-\n-    \/\/ The gain of using `long` wide operations for `int` is lower than for the two other `byte` and `short` variants\n-    \/\/ so, there is only one method for ints.\n-    public static int strlenInt(MemorySegment segment, long start) {\n-        for (int offset = 0; offset < ArraysSupport.SOFT_MAX_ARRAY_LENGTH; offset += Integer.BYTES) {\n-            \/\/ We are guaranteed to be aligned here so, we can use unaligned access.\n-            int curr = segment.get(JAVA_INT_UNALIGNED, start + offset);\n+    private static int strlen_int(MemorySegment segment, long start) {\n+        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n+        for (int offset = 0; offset >= 0; offset += 4) {\n+            int curr = segment.get(JAVA_INT, start + offset);\n@@ -271,1 +124,1 @@\n-        throw newIaeStringTooLarge();\n+        throw new IllegalArgumentException(\"String too large\");\n@@ -290,13 +143,6 @@\n-            \/\/ Comparing the charset to specific internal implementations avoids loading the class `StandardCharsets`\n-            if        (charset == sun.nio.cs.UTF_8.INSTANCE ||\n-                       charset == sun.nio.cs.ISO_8859_1.INSTANCE ||\n-                       charset == sun.nio.cs.US_ASCII.INSTANCE) {\n-                return SINGLE_BYTE;\n-            } else if (charset instanceof sun.nio.cs.UTF_16LE ||\n-                       charset instanceof sun.nio.cs.UTF_16BE ||\n-                       charset instanceof sun.nio.cs.UTF_16) {\n-                return DOUBLE_BYTE;\n-            } else if (charset instanceof sun.nio.cs.UTF_32LE ||\n-                       charset instanceof sun.nio.cs.UTF_32BE ||\n-                       charset instanceof sun.nio.cs.UTF_32) {\n-                return QUAD_BYTE;\n+            if (charset == StandardCharsets.UTF_8 || charset == StandardCharsets.ISO_8859_1 || charset == StandardCharsets.US_ASCII) {\n+                return CharsetKind.SINGLE_BYTE;\n+            } else if (charset == StandardCharsets.UTF_16LE || charset == StandardCharsets.UTF_16BE || charset == StandardCharsets.UTF_16) {\n+                return CharsetKind.DOUBLE_BYTE;\n+            } else if (charset == StandardCharsets.UTF_32LE || charset == StandardCharsets.UTF_32BE || charset == StandardCharsets.UTF_32) {\n+                return CharsetKind.QUAD_BYTE;\n@@ -308,24 +154,0 @@\n-\n-    public static boolean bytesCompatible(String string, Charset charset) {\n-        return JAVA_LANG_ACCESS.bytesCompatible(string, charset);\n-    }\n-\n-    public static int copyBytes(String string, MemorySegment segment, Charset charset, long offset) {\n-        if (bytesCompatible(string, charset)) {\n-            copyToSegmentRaw(string, segment, offset);\n-            return string.length();\n-        } else {\n-            byte[] bytes = string.getBytes(charset);\n-            MemorySegment.copy(bytes, 0, segment, JAVA_BYTE, offset, bytes.length);\n-            return bytes.length;\n-        }\n-    }\n-\n-    public static void copyToSegmentRaw(String string, MemorySegment segment, long offset) {\n-        JAVA_LANG_ACCESS.copyToSegmentRaw(string, segment, offset);\n-    }\n-\n-    private static IllegalArgumentException newIaeStringTooLarge() {\n-        return new IllegalArgumentException(\"String too large\");\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/StringSupport.java","additions":47,"deletions":225,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-            throw new IllegalArgumentException(\"Invalid alignment constraint for address: \" + toHexString(addr));\n+            throw new IllegalArgumentException(\"Invalid alignment constraint for address: \" + addr);\n@@ -151,1 +151,1 @@\n-        return SegmentFactories.makeNativeSegmentUnchecked(addr, size);\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(addr, size);\n@@ -157,1 +157,1 @@\n-            throw new IllegalArgumentException(\"Invalid alignment constraint for address: \" + toHexString(addr));\n+            throw new IllegalArgumentException(\"Invalid alignment constraint for address: \" + addr);\n@@ -159,1 +159,1 @@\n-        return SegmentFactories.makeNativeSegmentUnchecked(addr, size, scope);\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(addr, size, scope);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -467,1 +467,1 @@\n-            storeFunc.store(storage(), stack.pop());\n+            storeFunc.store(storage(), type(), stack.pop());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-        void store(VMStorage storage, Object o);\n+        void store(VMStorage storage, Class<?> type, Object o);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingInterpreter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.foreign.AddressLayout;\n@@ -38,1 +37,0 @@\n-import java.util.ArrayList;\n@@ -40,1 +38,0 @@\n-import java.util.List;\n@@ -44,3 +41,0 @@\n-import jdk.internal.foreign.AbstractMemorySegmentImpl;\n-import jdk.internal.foreign.MemorySessionImpl;\n-\n@@ -102,0 +96,1 @@\n+            Map<VMStorage, Integer> retIndexMap = SharedUtils.indexMap(retMoves);\n@@ -103,1 +98,1 @@\n-            InvocationData invData = new InvocationData(handle, callingSequence, argIndexMap);\n+            InvocationData invData = new InvocationData(handle, argIndexMap, retIndexMap);\n@@ -154,1 +149,1 @@\n-    private record InvocationData(MethodHandle leaf, CallingSequence callingSequence, Map<VMStorage, Integer> argIndexMap) {}\n+    private record InvocationData(MethodHandle leaf, Map<VMStorage, Integer> argIndexMap, Map<VMStorage, Integer> retIndexMap) {}\n@@ -160,1 +155,0 @@\n-        List<MemorySessionImpl> acquiredScopes = new ArrayList<>();\n@@ -165,0 +159,1 @@\n+            Object[] leafArgs = new Object[invData.leaf.type().parameterCount()];\n@@ -173,2 +168,0 @@\n-\n-            Object[] leafArgs = new Object[invData.leaf.type().parameterCount()];\n@@ -177,9 +170,0 @@\n-                if (callingSequence.functionDesc().argumentLayouts().get(i) instanceof AddressLayout) {\n-                    MemorySessionImpl sessionImpl = ((AbstractMemorySegmentImpl) arg).sessionImpl();\n-                    if (!(callingSequence.needsReturnBuffer() && i == 0)) { \/\/ don't acquire unboxArena's scope\n-                        sessionImpl.acquire0();\n-                        \/\/ add this scope _after_ we acquire, so we only release scopes we actually acquired\n-                        \/\/ in case an exception occurs\n-                        acquiredScopes.add(sessionImpl);\n-                    }\n-                }\n@@ -187,1 +171,1 @@\n-                    (storage, value) -> leafArgs[invData.argIndexMap.get(storage)] = value, unboxArena);\n+                        (storage, type, value) -> leafArgs[invData.argIndexMap.get(storage)] = value, unboxArena);\n@@ -213,4 +197,0 @@\n-        } finally {\n-            for (MemorySessionImpl sessionImpl : acquiredScopes) {\n-                sessionImpl.release0();\n-            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/DowncallLinker.java","additions":5,"deletions":25,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+import java.lang.invoke.VarHandle;\n@@ -59,0 +60,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -130,4 +132,0 @@\n-    public static long remainsToAlignment(long addr, long alignment) {\n-        return alignUp(addr, alignment) - addr;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-                        (storage, value) -> returnValues[invData.retIndexMap.get(storage)] = value, null);\n+                        (storage, type, value) -> returnValues[invData.retIndexMap.get(storage)] = value, null);\n@@ -190,1 +190,6 @@\n-                assert returnValues.length == invData.retMoves().length;\n+                Binding.VMStore[] retMoves = invData.callingSequence.returnBindings().stream()\n+                        .filter(Binding.VMStore.class::isInstance)\n+                        .map(Binding.VMStore.class::cast)\n+                        .toArray(Binding.VMStore[]::new);\n+\n+                assert returnValues.length == retMoves.length;\n@@ -192,2 +197,2 @@\n-                for (int i = 0; i < invData.retMoves().length; i++) {\n-                    Binding.VMStore store = invData.retMoves()[i];\n+                for (int i = 0; i < retMoves.length; i++) {\n+                    Binding.VMStore store = retMoves[i];\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallLinker.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.internal.foreign.Utils;\n@@ -40,1 +39,1 @@\n-            throw new IllegalStateException(\"Not a stub address: \" + Utils.toHexString(stubAddress));\n+            throw new IllegalStateException(\"Not a stub address: \" + stubAddress);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallStubs.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -375,1 +375,1 @@\n-     *     <li>{@link AddressLayout}, for {@code MemorySegment.class}<\/li>\n+     *     <li>{@link ValueLayout.OfAddress}, for {@code MemorySegment.class}<\/li>\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/ValueLayouts.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4598,1 +4598,1 @@\n-        if (0 > count || objects.length - count < objectStart) {\n+        if (0 > count || objects.length < (objectStart+count)) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/icu\/text\/BidiBase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,2 +66,2 @@\n-\\                  allow code in modules to access code and data outside the Java runtime.\\n\\\n-\\                  <module name> can also be ALL-UNNAMED to indicate code on the class path.\\n\\\n+\\                  modules that are permitted to perform restricted native operations.\\n\\\n+\\                  <module name> can also be ALL-UNNAMED.\\n\\\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/resources\/launcher.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,0 +53,2 @@\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.foreign.MappedMemorySegmentImpl;\n@@ -54,1 +56,0 @@\n-import jdk.internal.foreign.SegmentFactories;\n@@ -1337,1 +1338,16 @@\n-        return SegmentFactories.mapSegment(size, unmapper, readOnly, sessionImpl);\n+        if (unmapper != null) {\n+            AbstractMemorySegmentImpl segment =\n+                new MappedMemorySegmentImpl(unmapper.address(), unmapper, size,\n+                                            readOnly, sessionImpl);\n+            MemorySessionImpl.ResourceList.ResourceCleanup resource =\n+                new MemorySessionImpl.ResourceList.ResourceCleanup() {\n+                    @Override\n+                    public void cleanup() {\n+                        unmapper.unmap();\n+                    }\n+                };\n+            sessionImpl.addOrCleanupIfFail(resource);\n+            return segment;\n+        } else {\n+            return new MappedMemorySegmentImpl(0, null, 0, readOnly, sessionImpl);\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,2 +73,6 @@\n-    private static final ThreadLocal<GroupAndInvokeCount> myGroupAndInvokeCount\n-        = new ThreadLocal<GroupAndInvokeCount>();\n+    private static final ThreadLocal<GroupAndInvokeCount> myGroupAndInvokeCount =\n+        new ThreadLocal<GroupAndInvokeCount>() {\n+            @Override protected GroupAndInvokeCount initialValue() {\n+                return null;\n+            }\n+        };\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Invoker.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -497,4 +497,1 @@\n-        long duration = SocketReadEvent.timestamp() - start;\n-        if (SocketReadEvent.shouldCommit(duration)) {\n-            SocketReadEvent.emit(start, duration, nbytes, remoteAddress(), 0);\n-        }\n+        SocketReadEvent.offer(start, nbytes, remoteAddress(), 0);\n@@ -514,4 +511,1 @@\n-        long duration = SocketReadEvent.timestamp() - start;\n-        if (SocketReadEvent.shouldCommit(duration)) {\n-            SocketReadEvent.emit(start, duration, nbytes, remoteAddress(), 0);\n-        }\n+        SocketReadEvent.offer(start, nbytes, remoteAddress(), 0);\n@@ -628,4 +622,1 @@\n-        long duration = SocketWriteEvent.timestamp() - start;\n-        if (SocketWriteEvent.shouldCommit(duration)) {\n-            SocketWriteEvent.emit(start, duration, nbytes, remoteAddress());\n-        }\n+        SocketWriteEvent.offer(start, nbytes, remoteAddress());\n@@ -644,4 +635,1 @@\n-        long duration = SocketWriteEvent.timestamp() - start;\n-        if (SocketWriteEvent.shouldCommit(duration)) {\n-            SocketWriteEvent.emit(start, duration, nbytes, remoteAddress());\n-        }\n+        SocketWriteEvent.offer(start, nbytes, remoteAddress());\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":4,"deletions":16,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import java.io.InvalidObjectException;\n-import java.io.ObjectInputStream;\n@@ -46,1 +44,1 @@\n- * <p>\n+ *\n@@ -69,1 +67,0 @@\n-    @java.io.Serial\n@@ -224,16 +221,0 @@\n-\n-    \/**\n-     * Restores the state of this object from the stream.\n-     * <p>\n-     * Deserialization of this object is not supported.\n-     *\n-     * @param  stream the {@code ObjectInputStream} from which data is read\n-     * @throws IOException if an I\/O error occurs\n-     * @throws ClassNotFoundException if a serialized class cannot be loaded\n-     *\/\n-    @java.io.Serial\n-    private void readObject(ObjectInputStream stream)\n-            throws IOException, ClassNotFoundException {\n-        throw new InvalidObjectException(\n-                \"ECPrivateKeyImpl keys are not directly deserializable\");\n-    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECPrivateKeyImpl.java","additions":1,"deletions":20,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,0 @@\n-import java.io.InvalidObjectException;\n-import java.io.ObjectInputStream;\n@@ -49,1 +47,0 @@\n-    @java.io.Serial\n@@ -129,2 +126,1 @@\n-    @java.io.Serial\n-    private Object writeReplace() throws java.io.ObjectStreamException {\n+    protected Object writeReplace() throws java.io.ObjectStreamException {\n@@ -136,17 +132,1 @@\n-\n-    \/**\n-     * Restores the state of this object from the stream.\n-     * <p>\n-     * Deserialization of this object is not supported.\n-     *\n-     * @param  stream the {@code ObjectInputStream} from which data is read\n-     * @throws IOException if an I\/O error occurs\n-     * @throws ClassNotFoundException if a serialized class cannot be loaded\n-     *\/\n-    @java.io.Serial\n-    private void readObject(ObjectInputStream stream)\n-            throws IOException, ClassNotFoundException {\n-        throw new InvalidObjectException(\n-                \"ECPublicKeyImpl keys are not directly deserializable\");\n-    }\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECPublicKeyImpl.java","additions":3,"deletions":23,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-    @java.io.Serial\n@@ -107,1 +106,1 @@\n-        XECParameters params = paramSpec.getName().equalsIgnoreCase(\"X25519\")\n+        XECParameters params = paramSpec.getName().equals(\"X25519\")\n@@ -118,16 +117,0 @@\n-\n-    \/**\n-     * Restores the state of this object from the stream.\n-     * <p>\n-     * Deserialization of this object is not supported.\n-     *\n-     * @param  stream the {@code ObjectInputStream} from which data is read\n-     * @throws IOException if an I\/O error occurs\n-     * @throws ClassNotFoundException if a serialized class cannot be loaded\n-     *\/\n-    @java.io.Serial\n-    private void readObject(ObjectInputStream stream)\n-            throws IOException, ClassNotFoundException {\n-        throw new InvalidObjectException(\n-                \"XDHPrivateKeyImpl keys are not directly deserializable\");\n-    }\n@@ -135,0 +118,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/XDHPrivateKeyImpl.java","additions":2,"deletions":18,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import java.io.IOException;\n-import java.io.InvalidObjectException;\n-import java.io.ObjectInputStream;\n@@ -45,1 +42,0 @@\n-    @java.io.Serial\n@@ -114,2 +110,1 @@\n-    @java.io.Serial\n-    private Object writeReplace() throws java.io.ObjectStreamException {\n+    protected Object writeReplace() throws java.io.ObjectStreamException {\n@@ -138,16 +133,0 @@\n-\n-    \/**\n-     * Restores the state of this object from the stream.\n-     * <p>\n-     * Deserialization of this object is not supported.\n-     *\n-     * @param  stream the {@code ObjectInputStream} from which data is read\n-     * @throws IOException if an I\/O error occurs\n-     * @throws ClassNotFoundException if a serialized class cannot be loaded\n-     *\/\n-    @java.io.Serial\n-    private void readObject(ObjectInputStream stream)\n-            throws IOException, ClassNotFoundException {\n-        throw new InvalidObjectException(\n-                \"XDHPublicKeyImpl keys are not directly deserializable\");\n-    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/XDHPublicKeyImpl.java","additions":2,"deletions":23,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,0 @@\n-import java.io.InvalidObjectException;\n-import java.io.ObjectInputStream;\n@@ -43,1 +41,0 @@\n-    @java.io.Serial\n@@ -108,16 +105,0 @@\n-\n-    \/**\n-     * Restores the state of this object from the stream.\n-     * <p>\n-     * Deserialization of this object is not supported.\n-     *\n-     * @param  stream the {@code ObjectInputStream} from which data is read\n-     * @throws IOException if an I\/O error occurs\n-     * @throws ClassNotFoundException if a serialized class cannot be loaded\n-     *\/\n-    @java.io.Serial\n-    private void readObject(ObjectInputStream stream)\n-            throws IOException, ClassNotFoundException {\n-        throw new InvalidObjectException(\n-                \"EdDSAPrivateKeyImpl keys are not directly deserializable\");\n-    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ed\/EdDSAPrivateKeyImpl.java","additions":1,"deletions":20,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import java.io.IOException;\n-import java.io.InvalidObjectException;\n-import java.io.ObjectInputStream;\n@@ -45,1 +42,0 @@\n-    @java.io.Serial\n@@ -115,2 +111,1 @@\n-    @java.io.Serial\n-    private Object writeReplace() throws java.io.ObjectStreamException {\n+    protected Object writeReplace() throws java.io.ObjectStreamException {\n@@ -137,16 +132,0 @@\n-\n-    \/**\n-     * Restores the state of this object from the stream.\n-     * <p>\n-     * Deserialization of this object is not supported.\n-     *\n-     * @param  stream the {@code ObjectInputStream} from which data is read\n-     * @throws IOException if an I\/O error occurs\n-     * @throws ClassNotFoundException if a serialized class cannot be loaded\n-     *\/\n-    @java.io.Serial\n-    private void readObject(ObjectInputStream stream)\n-            throws IOException, ClassNotFoundException {\n-        throw new InvalidObjectException(\n-                \"EdDSAPublicKeyImpl keys are not directly deserializable\");\n-    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ed\/EdDSAPublicKeyImpl.java","additions":2,"deletions":23,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import java.io.IOException;\n-import java.io.InvalidObjectException;\n-import java.io.ObjectInputStream;\n@@ -37,1 +34,1 @@\n- * <p>\n+ *\n@@ -41,1 +38,1 @@\n- * <p>\n+ *\n@@ -78,1 +75,1 @@\n-    private Object writeReplace() throws java.io.ObjectStreamException {\n+    protected Object writeReplace() throws java.io.ObjectStreamException {\n@@ -84,16 +81,0 @@\n-\n-    \/**\n-     * Restores the state of this object from the stream.\n-     * <p>\n-     * Deserialization of this object is not supported.\n-     *\n-     * @param  stream the {@code ObjectInputStream} from which data is read\n-     * @throws IOException if an I\/O error occurs\n-     * @throws ClassNotFoundException if a serialized class cannot be loaded\n-     *\/\n-    @java.io.Serial\n-    private void readObject(ObjectInputStream stream)\n-            throws IOException, ClassNotFoundException {\n-        throw new InvalidObjectException(\n-                \"DSAPublicKeyImpl keys are not directly deserializable\");\n-    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/DSAPublicKeyImpl.java","additions":4,"deletions":23,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2101,9 +2101,1 @@\n-            if ((this.certs == null) && (that.certs == null)) {\n-                return true;\n-            }\n-\n-            if ((this.certs == null) || (that.certs == null)) {\n-                return false;\n-            }\n-\n-            if (this.certs.length != that.certs.length) {\n+            if (this.certs.length != that.certs.length)\n@@ -2111,1 +2103,0 @@\n-            }\n@@ -2175,1 +2166,1 @@\n-            return (certs == null ? null : certs.clone());\n+            return certs;\n@@ -2188,16 +2179,0 @@\n-\n-        \/**\n-         * Restores the state of this object from the stream.\n-         *\n-         * @param  stream the {@code ObjectInputStream} from which data is read\n-         * @throws IOException if an I\/O error occurs\n-         * @throws ClassNotFoundException if a serialized class cannot be loaded\n-         *\/\n-        @java.io.Serial\n-        private void readObject(ObjectInputStream stream)\n-                throws IOException, ClassNotFoundException {\n-            stream.defaultReadObject();\n-            if (certs != null) {\n-                this.certs = certs.clone();\n-            }\n-        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/PolicyFile.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.io.InvalidObjectException;\n@@ -196,1 +195,1 @@\n-     * <p>\n+     *\n@@ -269,4 +268,2 @@\n-     * This method is called to restore the state of the random object from\n-     * a stream.\n-     * <p>\n-     * We have to create a new instance of {@code MessageDigest}, because\n+     * readObject is called to restore the state of the random object from\n+     * a stream.  We have to create a new instance of MessageDigest, because\n@@ -274,5 +271,0 @@\n-     * <p>\n-     * Note that the {@code engineNextBytes()} method invoked on the restored\n-     * random object will yield the exact same (random) bytes as the original.\n-     * If you do not want this behaviour, you should re-seed the restored\n-     * random object, using {@code engineSetSeed()}.\n@@ -280,3 +272,4 @@\n-     * @param  s the {@code ObjectInputStream} from which data is read\n-     * @throws IOException if an I\/O error occurs\n-     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     * Note that the engineNextBytes() method invoked on the restored random\n+     * object will yield the exact same (random) bytes as the original.\n+     * If you do not want this behaviour, you should re-seed the restored\n+     * random object, using engineSetSeed().\n@@ -286,1 +279,1 @@\n-            throws IOException, ClassNotFoundException {\n+        throws IOException, ClassNotFoundException {\n@@ -305,29 +298,0 @@\n-\n-        \/\/ Various consistency checks\n-        if ((remainder == null) && (remCount > 0)) {\n-            throw new InvalidObjectException(\n-                    \"Remainder indicated, but no data available\");\n-        }\n-\n-        \/\/ Not yet allocated state\n-        if (state == null) {\n-            if (remainder == null) {\n-                return;\n-            } else {\n-                throw new InvalidObjectException(\n-                        \"Inconsistent buffer allocations\");\n-            }\n-        }\n-\n-        \/\/ Sanity check on sizes\/pointer\n-        if ((state.length != DIGEST_SIZE) ||\n-                ((remainder != null) && (remainder.length != DIGEST_SIZE)) ||\n-                (remCount < 0 ) || (remCount >= DIGEST_SIZE)) {\n-            throw new InvalidObjectException(\n-                    \"Inconsistent buffer sizes\/state\");\n-        }\n-\n-        state = state.clone();\n-        if (remainder != null) {\n-            remainder = remainder.clone();\n-        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SecureRandom.java","additions":9,"deletions":45,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.util.Set;\n@@ -31,0 +32,1 @@\n+import java.security.cert.X509CertSelector;\n@@ -33,0 +35,2 @@\n+import sun.security.x509.GeneralNameInterface;\n+\n@@ -54,0 +58,3 @@\n+    protected abstract void implSetPathToNames(X509CertSelector sel,\n+            Set<GeneralNameInterface> names);\n+\n@@ -58,0 +65,5 @@\n+    static void setPathToNames(X509CertSelector sel,\n+            Set<GeneralNameInterface> names) {\n+        instance.implSetPathToNames(sel, names);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/CertPathHelper.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import sun.security.x509.SubjectAlternativeNameExtension;\n@@ -259,0 +260,8 @@\n+            \/*\n+             * Match on subjectNamesTraversed (both DNs and AltNames)\n+             * (checks that current cert's name constraints permit it\n+             * to certify all the DNs and AltNames that have been traversed)\n+             *\/\n+            CertPathHelper.setPathToNames\n+                (caSelector, currentState.subjectNamesTraversed);\n+\n@@ -691,0 +700,13 @@\n+        \/*\n+         * Abort if we encounter the same certificate or a certificate with\n+         * the same public key, subject DN, and subjectAltNames as a cert\n+         * that is already in path.\n+         *\/\n+        for (X509Certificate cpListCert : certPathList) {\n+            if (repeated(cpListCert, cert)) {\n+                throw new CertPathValidatorException(\n+                    \"cert with repeated subject, public key, and \" +\n+                    \"subjectAltNames detected\");\n+            }\n+        }\n+\n@@ -768,0 +790,43 @@\n+    \/**\n+     * Return true if two certificates are equal or have the same subject,\n+     * public key, and subject alternative names.\n+     *\/\n+    private static boolean repeated(\n+            X509Certificate currCert, X509Certificate nextCert) {\n+        if (currCert.equals(nextCert)) {\n+            return true;\n+        }\n+        return (currCert.getSubjectX500Principal().equals(\n+            nextCert.getSubjectX500Principal()) &&\n+            currCert.getPublicKey().equals(nextCert.getPublicKey()) &&\n+            altNamesEqual(currCert, nextCert));\n+    }\n+\n+    \/**\n+     * Return true if two certificates have the same subject alternative names.\n+     *\/\n+    private static boolean altNamesEqual(\n+            X509Certificate currCert, X509Certificate nextCert) {\n+        X509CertImpl curr, next;\n+        try {\n+            curr = X509CertImpl.toImpl(currCert);\n+            next = X509CertImpl.toImpl(nextCert);\n+        } catch (CertificateException ce) {\n+            return false;\n+        }\n+\n+        SubjectAlternativeNameExtension currAltNameExt =\n+            curr.getSubjectAlternativeNameExtension();\n+        SubjectAlternativeNameExtension nextAltNameExt =\n+            next.getSubjectAlternativeNameExtension();\n+        if (currAltNameExt != null) {\n+            if (nextAltNameExt == null) {\n+                return false;\n+            }\n+            return Arrays.equals(currAltNameExt.getExtensionValue(),\n+                nextAltNameExt.getExtensionValue());\n+        } else {\n+            return (nextAltNameExt == null);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/ForwardBuilder.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.HashSet;\n@@ -39,0 +40,5 @@\n+import sun.security.x509.SubjectAlternativeNameExtension;\n+import sun.security.x509.GeneralNames;\n+import sun.security.x509.GeneralName;\n+import sun.security.x509.GeneralNameInterface;\n+import sun.security.x509.X500Name;\n@@ -58,0 +64,3 @@\n+    \/* The set of subjectDNs and subjectAltNames of all certs in the path *\/\n+    HashSet<GeneralNameInterface> subjectNamesTraversed;\n+\n@@ -67,0 +76,1 @@\n+\n@@ -96,0 +106,2 @@\n+                \"\\n  subjectNamesTraversed: \\n\" +\n+                subjectNamesTraversed +\n@@ -108,0 +120,1 @@\n+        subjectNamesTraversed = new HashSet<>();\n@@ -157,0 +170,16 @@\n+        \/* update subjectNamesTraversed only if this is the EE cert or if\n+           this cert is not self-issued *\/\n+        if (init || !selfIssued) {\n+            X500Principal subjName = cert.getSubjectX500Principal();\n+            subjectNamesTraversed.add(X500Name.asX500Name(subjName));\n+\n+            SubjectAlternativeNameExtension subjAltNameExt\n+                    = icert.getSubjectAlternativeNameExtension();\n+            if (subjAltNameExt != null) {\n+                GeneralNames gNames = subjAltNameExt.getNames();\n+                for (GeneralName gName : gNames.names()) {\n+                    subjectNamesTraversed.add(gName.getName());\n+                }\n+            }\n+        }\n+\n@@ -164,0 +193,4 @@\n+     *\n+     * Note that this is a SMART clone. Not all fields are fully copied,\n+     * because some of them will\n+     * not have their contents modified by subsequent calls to updateState.\n@@ -183,0 +216,7 @@\n+            \/*\n+             * Shallow copy traversed names. There is no need to\n+             * deep copy contents, since the elements of the Set\n+             * are never modified by subsequent calls to updateState().\n+             *\/\n+            clonedState.subjectNamesTraversed\n+                = (HashSet<GeneralNameInterface>)subjectNamesTraversed.clone();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/ForwardState.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import java.util.Arrays;\n@@ -46,1 +45,0 @@\n-import sun.security.x509.SubjectAlternativeNameExtension;\n@@ -270,1 +268,1 @@\n-        List<Vertex> vertices = addVertices(certs, adjList, cpList);\n+        List<Vertex> vertices = addVertices(certs, adjList);\n@@ -330,1 +328,0 @@\n-                PublicKey rootKey = cert.getPublicKey();\n@@ -333,6 +330,0 @@\n-                    rootKey = builder.trustAnchor.getCAPublicKey();\n-                    if (debug != null)\n-                        debug.println(\n-                            \"SunCertPathBuilder.depthFirstSearchForward \" +\n-                            \"using buildParams public key: \" +\n-                            rootKey.toString());\n@@ -340,2 +331,0 @@\n-                TrustAnchor anchor = new TrustAnchor\n-                    (cert.getSubjectX500Principal(), rootKey, null);\n@@ -343,7 +332,0 @@\n-                \/\/ add the basic checker\n-                List<PKIXCertPathChecker> checkers = new ArrayList<>();\n-                BasicChecker basicChecker = new BasicChecker(anchor,\n-                                                    buildParams.date(),\n-                                                    buildParams.sigProvider(),\n-                                                    true);\n-                checkers.add(basicChecker);\n@@ -356,0 +338,1 @@\n+                List<PKIXCertPathChecker> checkers = new ArrayList<>();\n@@ -366,3 +349,0 @@\n-                \/\/ add the constraints checker\n-                checkers.add(new ConstraintsChecker(appendedCerts.size()));\n-\n@@ -373,0 +353,18 @@\n+                PublicKey rootKey = cert.getPublicKey();\n+                if (builder.trustAnchor.getTrustedCert() == null) {\n+                    rootKey = builder.trustAnchor.getCAPublicKey();\n+                    if (debug != null)\n+                        debug.println(\n+                            \"SunCertPathBuilder.depthFirstSearchForward \" +\n+                            \"using buildParams public key: \" +\n+                            rootKey.toString());\n+                }\n+                TrustAnchor anchor = new TrustAnchor\n+                    (cert.getSubjectX500Principal(), rootKey, null);\n+\n+                \/\/ add the basic checker\n+                BasicChecker basicChecker = new BasicChecker(anchor,\n+                                                    buildParams.date(),\n+                                                    buildParams.sigProvider(),\n+                                                    true);\n+                checkers.add(basicChecker);\n@@ -568,2 +566,1 @@\n-                                            List<List<Vertex>> adjList,\n-                                            List<X509Certificate> cpList)\n+                                            List<List<Vertex>> adjList)\n@@ -574,19 +571,2 @@\n-            boolean repeated = false;\n-            for (X509Certificate cpListCert : cpList) {\n-                \/*\n-                 * Ignore if we encounter the same certificate or a\n-                 * certificate with the same public key, subject DN, and\n-                 * subjectAltNames as a cert that is already in path.\n-                 *\/\n-                if (repeated(cpListCert, cert)) {\n-                    if (debug != null) {\n-                        debug.println(\"cert with repeated subject, \" +\n-                            \"public key, and subjectAltNames detected\");\n-                    }\n-                    repeated = true;\n-                    break;\n-                }\n-            }\n-            if (!repeated) {\n-                l.add(new Vertex(cert));\n-            }\n+            Vertex v = new Vertex(cert);\n+            l.add(v);\n@@ -598,43 +578,0 @@\n-    \/**\n-     * Return true if two certificates are equal or have the same subject,\n-     * public key, and subject alternative names.\n-     *\/\n-    private static boolean repeated(\n-            X509Certificate currCert, X509Certificate nextCert) {\n-        if (currCert.equals(nextCert)) {\n-            return true;\n-        }\n-        return (currCert.getSubjectX500Principal().equals(\n-            nextCert.getSubjectX500Principal()) &&\n-            currCert.getPublicKey().equals(nextCert.getPublicKey()) &&\n-            altNamesEqual(currCert, nextCert));\n-    }\n-\n-    \/**\n-     * Return true if two certificates have the same subject alternative names.\n-     *\/\n-    private static boolean altNamesEqual(\n-            X509Certificate currCert, X509Certificate nextCert) {\n-        X509CertImpl curr, next;\n-        try {\n-            curr = X509CertImpl.toImpl(currCert);\n-            next = X509CertImpl.toImpl(nextCert);\n-        } catch (CertificateException ce) {\n-            return false;\n-        }\n-\n-        SubjectAlternativeNameExtension currAltNameExt =\n-            curr.getSubjectAlternativeNameExtension();\n-        SubjectAlternativeNameExtension nextAltNameExt =\n-            next.getSubjectAlternativeNameExtension();\n-        if (currAltNameExt != null) {\n-            if (nextAltNameExt == null) {\n-                return false;\n-            }\n-            return Arrays.equals(currAltNameExt.getExtensionValue(),\n-                nextAltNameExt.getExtensionValue());\n-        } else {\n-            return (nextAltNameExt == null);\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/SunCertPathBuilder.java","additions":23,"deletions":86,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,3 @@\n-import java.io.*;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n@@ -380,16 +382,0 @@\n-\n-    \/**\n-     * Restores the state of this object from the stream.\n-     * <p>\n-     * Deserialization of this object is not supported.\n-     *\n-     * @param  stream the {@code ObjectInputStream} from which data is read\n-     * @throws IOException if an I\/O error occurs\n-     * @throws ClassNotFoundException if a serialized class cannot be loaded\n-     *\/\n-    @java.io.Serial\n-    private void readObject(ObjectInputStream stream)\n-            throws IOException, ClassNotFoundException {\n-        throw new InvalidObjectException(\n-                \"X509CertPaths are not directly deserializable\");\n-    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/X509CertPath.java","additions":4,"deletions":18,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,0 @@\n-import java.io.InvalidObjectException;\n-import java.io.ObjectInputStream;\n@@ -48,1 +46,1 @@\n- * <p>\n+ *\n@@ -361,16 +359,0 @@\n-\n-    \/**\n-     * Restores the state of this object from the stream.\n-     * <p>\n-     * Deserialization of this object is not supported.\n-     *\n-     * @param  stream the {@code ObjectInputStream} from which data is read\n-     * @throws IOException if an I\/O error occurs\n-     * @throws ClassNotFoundException if a serialized class cannot be loaded\n-     *\/\n-    @java.io.Serial\n-    private void readObject(ObjectInputStream stream)\n-            throws IOException, ClassNotFoundException {\n-        throw new InvalidObjectException(\n-                \"RSAPrivateCrtKeyImpl keys are not directly deserializable\");\n-    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPrivateCrtKeyImpl.java","additions":2,"deletions":20,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import java.io.IOException;\n-import java.io.InvalidObjectException;\n-import java.io.ObjectInputStream;\n@@ -45,5 +42,4 @@\n- * form (modulus, private exponent only).\n- * <p>\n- * For CRT private keys, see RSAPrivateCrtKeyImpl. We need separate classes\n- * to ensure correct behavior in instanceof checks, etc.\n- * <p>\n+ * form (modulus, private exponent only). For CRT private keys, see\n+ * RSAPrivateCrtKeyImpl. We need separate classes to ensure correct behavior\n+ * in instanceof checks, etc.\n+ *\n@@ -148,16 +144,0 @@\n-\n-    \/**\n-     * Restores the state of this object from the stream.\n-     * <p>\n-     * Deserialization of this object is not supported.\n-     *\n-     * @param  stream the {@code ObjectInputStream} from which data is read\n-     * @throws IOException if an I\/O error occurs\n-     * @throws ClassNotFoundException if a serialized class cannot be loaded\n-     *\/\n-    @java.io.Serial\n-    private void readObject(ObjectInputStream stream)\n-            throws IOException, ClassNotFoundException {\n-        throw new InvalidObjectException(\n-                \"RSAPrivateKeyImpl keys are not directly deserializable\");\n-    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPrivateKeyImpl.java","additions":5,"deletions":25,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,0 @@\n-import java.io.InvalidObjectException;\n-import java.io.ObjectInputStream;\n@@ -44,1 +42,1 @@\n- * <p>\n+ *\n@@ -238,1 +236,1 @@\n-    private Object writeReplace() throws java.io.ObjectStreamException {\n+    protected Object writeReplace() throws java.io.ObjectStreamException {\n@@ -244,16 +242,0 @@\n-\n-    \/**\n-     * Restores the state of this object from the stream.\n-     * <p>\n-     * Deserialization of this object is not supported.\n-     *\n-     * @param  stream the {@code ObjectInputStream} from which data is read\n-     * @throws IOException if an I\/O error occurs\n-     * @throws ClassNotFoundException if a serialized class cannot be loaded\n-     *\/\n-    @java.io.Serial\n-    private void readObject(ObjectInputStream stream)\n-            throws IOException, ClassNotFoundException {\n-        throw new InvalidObjectException(\n-                \"RSAPublicKeyImpl keys are not directly deserializable\");\n-    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPublicKeyImpl.java","additions":3,"deletions":21,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -539,1 +539,1 @@\n-     * <p>\n+     *\n@@ -1221,1 +1221,1 @@\n-            nameEntry.add(name.getType());\n+            nameEntry.add(Integer.valueOf(name.getType()));\n@@ -1634,16 +1634,0 @@\n-\n-    \/**\n-     * Restores the state of this object from the stream.\n-     * <p>\n-     * Deserialization of this object is not supported.\n-     *\n-     * @param  stream the {@code ObjectInputStream} from which data is read\n-     * @throws IOException if an I\/O error occurs\n-     * @throws ClassNotFoundException if a serialized class cannot be loaded\n-     *\/\n-    @java.io.Serial\n-    private void readObject(ObjectInputStream stream)\n-            throws IOException, ClassNotFoundException {\n-        throw new InvalidObjectException(\n-                \"X509CertImpls are not directly deserializable\");\n-    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509CertImpl.java","additions":3,"deletions":19,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -533,5 +533,4 @@\n-Specifies where to find application modules with a list of path\n-elements.\n-The elements of a module path can be a file path to a module or a\n-directory containing modules.\n-Each module is either a modular JAR or an exploded-module directory.\n+Specifies where to find application modules with a list of path elements.\n+The elements of a module path can be a file path to a module or a directory\n+containing modules. Each module is either a modular JAR or an\n+exploded-module directory.\n@@ -540,2 +539,2 @@\n-On Windows, semicolons (\\f[V];\\f[R]) separate path elements in this\n-list; on other platforms it is a colon (\\f[V]:\\f[R]).\n+On Windows, semicolons (\\f[V];\\f[R]) separate path elements in this list;\n+on other platforms it is a colon (\\f[V]:\\f[R]).\n@@ -545,5 +544,5 @@\n-Specifies where to find module replacements of upgradeable modules in\n-the runtime image with a list of path elements.\n-The elements of a module path can be a file path to a module or a\n-directory containing modules.\n-Each module is either a modular JAR or an exploded-module directory.\n+Specifies where to find module replacements of upgradeable modules in the\n+runtime image with a list of path elements.\n+The elements of a module path can be a file path to a module or a directory\n+containing modules. Each module is either a modular JAR or an\n+exploded-module directory.\n@@ -552,2 +551,2 @@\n-On Windows, semicolons (\\f[V];\\f[R]) separate path elements in this\n-list; on other platforms it is a colon (\\f[V]:\\f[R]).\n+On Windows, semicolons (\\f[V];\\f[R]) separate path elements in this list;\n+on other platforms it is a colon (\\f[V]:\\f[R]).\n@@ -1308,1 +1307,0 @@\n-Multiple parameters can be specified by separating them with a comma.\n@@ -1374,0 +1372,3 @@\n+.PP\n+You can specify values for multiple parameters by separating them with a\n+comma.\n@@ -1660,3 +1661,0 @@\n-.PP\n-If %p and\/or %t is specified in the filename, it expands to the\n-JVM\\[aq]s PID and the current timestamp, respectively.\n@@ -1817,0 +1815,13 @@\n+\\f[V]-XX:+UseHugeTLBFS\\f[R]\n+\\f[B]Linux only:\\f[R] This option is the equivalent of specifying\n+\\f[V]-XX:+UseLargePages\\f[R].\n+This option is disabled by default.\n+This option pre-allocates all large pages up-front, when memory is\n+reserved; consequently the JVM can\\[aq]t dynamically grow or shrink\n+large pages memory areas; see \\f[V]-XX:UseTransparentHugePages\\f[R] if\n+you want this behavior.\n+.RS\n+.PP\n+See \\f[B]Large Pages\\f[R].\n+.RE\n+.TP\n@@ -2164,0 +2175,6 @@\n+Specify each method with the full class name (including the packages and\n+subpackages).\n+For example, to compile only the \\f[V]length()\\f[R] method of the\n+\\f[V]String\\f[R] class and the \\f[V]size()\\f[R] method of the\n+\\f[V]List\\f[R] class, use the following:\n+.RS\n@@ -2166,1 +2183,17 @@\n-\\f[V]-XX:CompileOnly=method1,method2,...,methodN\\f[R] is an alias for:\n+\\f[V]-XX:CompileOnly=java\/lang\/String.length,java\/util\/List.size\\f[R]\n+.RE\n+.PP\n+Note that the full class name is specified, including all packages and\n+subpackages separated by a slash (\\f[V]\/\\f[R]).\n+For easier cut and paste operations, it\\[aq]s also possible to use the\n+method name format produced by the \\f[V]-XX:+PrintCompilation\\f[R] and\n+\\f[V]-XX:+LogCompilation\\f[R] options:\n+.RS\n+.PP\n+\\f[V]-XX:CompileOnly=java.lang.String::length,java.util.List::size\\f[R]\n+.RE\n+.PP\n+Although wildcards aren\\[aq]t supported, you can specify only the class\n+or package name to compile all methods in that class or package, as well\n+as specify just the method to compile methods with this name in any\n+class:\n@@ -2170,4 +2203,3 @@\n--XX:CompileCommand=compileonly,method1\n--XX:CompileCommand=compileonly,method2\n-\\&...\n--XX:CompileCommand=compileonly,methodN\n+-XX:CompileOnly=java\/lang\/String\n+-XX:CompileOnly=java\/lang\n+-XX:CompileOnly=.length\n@@ -3626,0 +3658,8 @@\n+\\f[V]-XX:+UseSHM\\f[R]\n+\\f[B]Linux only:\\f[R] Enables the JVM to use shared memory to set up\n+large pages.\n+.RS\n+.PP\n+See \\f[B]Large Pages\\f[R] for setting up large pages.\n+.RE\n+.TP\n@@ -3778,13 +3818,0 @@\n-.TP\n-\\f[V]-XX:+UseHugeTLBFS\\f[R]\n-\\f[B]Linux only:\\f[R] This option is the equivalent of specifying\n-\\f[V]-XX:+UseLargePages\\f[R].\n-This option is disabled by default.\n-This option pre-allocates all large pages up-front, when memory is\n-reserved; consequently the JVM can\\[aq]t dynamically grow or shrink\n-large pages memory areas; see \\f[V]-XX:UseTransparentHugePages\\f[R] if\n-you want this behavior.\n-.TP\n-\\f[V]-XX:+UseSHM\\f[R]\n-\\f[B]Linux only:\\f[R] Enables the JVM to use shared memory to set up\n-large pages.\n@@ -4891,0 +4918,14 @@\n+.PP\n+When using the option \\f[V]-XX:+UseSHM\\f[R] to enable large pages you\n+also need to make sure the \\f[V]SHMMAX\\f[R] parameter is configured to\n+allow large enough shared memory segments to be allocated.\n+To allow a maximum shared segment of 8 GB, login as \\f[V]root\\f[R] and\n+run:\n+.RS\n+.PP\n+\\f[V]# echo 8589934592 > \/proc\/sys\/kernel\/shmmax\\f[R]\n+.RE\n+.PP\n+In some environments this is not needed since the default value is large\n+enough, but it is important to make sure the value is large enough to\n+fit the amount of memory intended to be backed by large pages.\n","filename":"src\/java.base\/share\/man\/java.1","additions":77,"deletions":36,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,8 +28,1 @@\n-import java.nio.file.attribute.BasicFileAttributes;\n-import java.nio.file.attribute.FileTime;\n-import java.nio.file.attribute.GroupPrincipal;\n-import java.nio.file.attribute.PosixFileAttributes;\n-import java.nio.file.attribute.PosixFilePermission;\n-import java.nio.file.attribute.UserPrincipal;\n-import java.util.HashSet;\n-import java.util.Set;\n+import java.nio.file.attribute.*;\n@@ -37,0 +30,2 @@\n+import java.util.Set;\n+import java.util.HashSet;\n@@ -60,1 +55,0 @@\n-    private long    st_birthtime_nsec;\n@@ -167,1 +161,1 @@\n-            return toFileTime(st_birthtime_sec, st_birthtime_nsec);\n+            return FileTime.from(st_birthtime_sec, TimeUnit.SECONDS);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileAttributes.java","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -94,7 +94,7 @@\n-typedef GProxyResolver* g_proxy_resolver_get_default_func(void);\n-typedef char** g_proxy_resolver_lookup_func(GProxyResolver* resolver, char* uri, void *null, GError **error_p);\n-typedef GSocketConnectable* g_network_address_parse_uri_func(char* proxy, unsigned short default_port, GError **error_p);\n-typedef const char* g_network_address_get_hostname_func(GSocketConnectable* conn);\n-typedef unsigned short g_network_address_get_port_func(GSocketConnectable* conn);\n-typedef void g_strfreev_func(char** proxies);\n-typedef void g_clear_error_func(GError **error_p);\n+typedef GProxyResolver* g_proxy_resolver_get_default_func();\n+typedef char** g_proxy_resolver_lookup_func();\n+typedef GSocketConnectable* g_network_address_parse_uri_func();\n+typedef const char* g_network_address_get_hostname_func();\n+typedef unsigned short g_network_address_get_port_func();\n+typedef void g_strfreev_func();\n+typedef void g_clear_error_func();\n","filename":"src\/java.base\/unix\/native\/libnet\/DefaultProxySelector.c","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-#include <sys\/sysmacros.h> \/\/ makedev macros\n@@ -75,92 +74,0 @@\n-#if defined(__linux__)\n-\/\/ Account for the case where we compile on a system without statx\n-\/\/ support. We still want to ensure we can call statx at runtime\n-\/\/ if the runtime glibc version supports it (>= 2.28). We do this\n-\/\/ by defining binary compatible statx structs in this file and\n-\/\/ not relying on included headers.\n-\n-#ifndef __GLIBC__\n-\/\/ Alpine doesn't know these types, define them\n-typedef unsigned int       __uint32_t;\n-typedef unsigned short     __uint16_t;\n-typedef unsigned long int  __uint64_t;\n-#endif\n-\n-\/*\n- * Timestamp structure for the timestamps in struct statx.\n- *\/\n-struct my_statx_timestamp {\n-        int64_t   tv_sec;\n-        __uint32_t  tv_nsec;\n-        int32_t   __reserved;\n-};\n-\n-\/*\n- * struct statx used by statx system call on >= glibc 2.28\n- * systems\n- *\/\n-struct my_statx\n-{\n-  __uint32_t stx_mask;\n-  __uint32_t stx_blksize;\n-  __uint64_t stx_attributes;\n-  __uint32_t stx_nlink;\n-  __uint32_t stx_uid;\n-  __uint32_t stx_gid;\n-  __uint16_t stx_mode;\n-  __uint16_t __statx_pad1[1];\n-  __uint64_t stx_ino;\n-  __uint64_t stx_size;\n-  __uint64_t stx_blocks;\n-  __uint64_t stx_attributes_mask;\n-  struct my_statx_timestamp stx_atime;\n-  struct my_statx_timestamp stx_btime;\n-  struct my_statx_timestamp stx_ctime;\n-  struct my_statx_timestamp stx_mtime;\n-  __uint32_t stx_rdev_major;\n-  __uint32_t stx_rdev_minor;\n-  __uint32_t stx_dev_major;\n-  __uint32_t stx_dev_minor;\n-  __uint64_t __statx_pad2[14];\n-};\n-\n-\/\/ statx masks, flags, constants\n-\n-#ifndef AT_SYMLINK_NOFOLLOW\n-#define AT_SYMLINK_NOFOLLOW 0x100\n-#endif\n-\n-#ifndef AT_STATX_SYNC_AS_STAT\n-#define AT_STATX_SYNC_AS_STAT 0x0000\n-#endif\n-\n-#ifndef AT_EMPTY_PATH\n-#define AT_EMPTY_PATH 0x1000\n-#endif\n-\n-#ifndef STATX_BASIC_STATS\n-#define STATX_BASIC_STATS 0x000007ffU\n-#endif\n-\n-#ifndef STATX_BTIME\n-#define STATX_BTIME 0x00000800U\n-#endif\n-\n-#ifndef STATX_ALL\n-#define STATX_ALL (STATX_BTIME | STATX_BASIC_STATS)\n-#endif\n-\n-#ifndef AT_FDCWD\n-#define AT_FDCWD -100\n-#endif\n-\n-#ifndef RTLD_DEFAULT\n-#define RTLD_DEFAULT RTLD_LOCAL\n-#endif\n-\n-#define NO_FOLLOW_SYMLINK 1\n-#define FOLLOW_SYMLINK 0\n-\n-#endif \/\/ __linux__\n-\n-\n@@ -213,1 +120,1 @@\n-#if defined(_DARWIN_FEATURE_64_BIT_INODE) || defined(__linux__)\n+#ifdef _DARWIN_FEATURE_64_BIT_INODE\n@@ -216,3 +123,0 @@\n-#if defined(__linux__) \/\/ Linux has nsec granularity if supported\n-static jfieldID attrs_st_birthtime_nsec;\n-#endif\n@@ -242,4 +146,0 @@\n-#if defined(__linux__)\n-typedef int statx_func(int dirfd, const char *restrict pathname, int flags,\n-                       unsigned int mask, struct my_statx *restrict statxbuf);\n-#endif\n@@ -255,3 +155,0 @@\n-#if defined(__linux__)\n-static statx_func* my_statx_func = NULL;\n-#endif\n@@ -283,7 +180,0 @@\n-#if defined(__linux__)\n-static int statx_wrapper(int dirfd, const char *restrict pathname, int flags,\n-                         unsigned int mask, struct my_statx *restrict statxbuf) {\n-    return (*my_statx_func)(dirfd, pathname, flags, mask, statxbuf);\n-}\n-#endif\n-\n@@ -342,1 +232,1 @@\n-#if defined(_DARWIN_FEATURE_64_BIT_INODE) || defined(__linux__)\n+#ifdef _DARWIN_FEATURE_64_BIT_INODE\n@@ -346,4 +236,0 @@\n-#if defined (__linux__) \/\/ Linux has nsec granularity\n-    attrs_st_birthtime_nsec = (*env)->GetFieldID(env, clazz, \"st_birthtime_nsec\", \"J\");\n-    CHECK_NULL_RETURN(attrs_st_birthtime_nsec, 0);\n-#endif\n@@ -431,6 +317,0 @@\n-#if defined(__linux__)\n-    my_statx_func = (statx_func*) dlsym(RTLD_DEFAULT, \"statx\");\n-    if (my_statx_func != NULL) {\n-        capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_BIRTHTIME;\n-    }\n-#endif\n@@ -613,27 +493,0 @@\n-#if defined(__linux__)\n-\/**\n- * Copy statx members into sun.nio.fs.UnixFileAttributes\n- *\/\n-static void copy_statx_attributes(JNIEnv* env, struct my_statx* buf, jobject attrs) {\n-    (*env)->SetIntField(env, attrs, attrs_st_mode, (jint)buf->stx_mode);\n-    (*env)->SetLongField(env, attrs, attrs_st_ino, (jlong)buf->stx_ino);\n-    (*env)->SetIntField(env, attrs, attrs_st_nlink, (jint)buf->stx_nlink);\n-    (*env)->SetIntField(env, attrs, attrs_st_uid, (jint)buf->stx_uid);\n-    (*env)->SetIntField(env, attrs, attrs_st_gid, (jint)buf->stx_gid);\n-    (*env)->SetLongField(env, attrs, attrs_st_size, (jlong)buf->stx_size);\n-    (*env)->SetLongField(env, attrs, attrs_st_atime_sec, (jlong)buf->stx_atime.tv_sec);\n-    (*env)->SetLongField(env, attrs, attrs_st_mtime_sec, (jlong)buf->stx_mtime.tv_sec);\n-    (*env)->SetLongField(env, attrs, attrs_st_ctime_sec, (jlong)buf->stx_ctime.tv_sec);\n-    (*env)->SetLongField(env, attrs, attrs_st_birthtime_sec, (jlong)buf->stx_btime.tv_sec);\n-    (*env)->SetLongField(env, attrs, attrs_st_birthtime_nsec, (jlong)buf->stx_btime.tv_nsec);\n-    (*env)->SetLongField(env, attrs, attrs_st_atime_nsec, (jlong)buf->stx_atime.tv_nsec);\n-    (*env)->SetLongField(env, attrs, attrs_st_mtime_nsec, (jlong)buf->stx_mtime.tv_nsec);\n-    (*env)->SetLongField(env, attrs, attrs_st_ctime_nsec, (jlong)buf->stx_ctime.tv_nsec);\n-    \/\/ convert statx major:minor to dev_t using makedev\n-    dev_t dev = makedev(buf->stx_dev_major, buf->stx_dev_minor);\n-    dev_t rdev = makedev(buf->stx_rdev_major, buf->stx_rdev_minor);\n-    (*env)->SetLongField(env, attrs, attrs_st_dev, (jlong)dev);\n-    (*env)->SetLongField(env, attrs, attrs_st_rdev, (jlong)rdev);\n-}\n-#endif\n-\n@@ -643,1 +496,1 @@\n-static void copy_stat64_attributes(JNIEnv* env, struct stat64* buf, jobject attrs) {\n+static void prepAttributes(JNIEnv* env, struct stat64* buf, jobject attrs) {\n@@ -658,1 +511,0 @@\n-    \/\/ rely on default value of 0 for st_birthtime_nsec field on Darwin\n@@ -679,16 +531,1 @@\n-#if defined(__linux__)\n-    struct my_statx statx_buf;\n-    int flags = AT_STATX_SYNC_AS_STAT;\n-    unsigned int mask = STATX_ALL;\n-\n-    if (my_statx_func != NULL) {\n-        \/\/ Prefer statx over stat64 on Linux if it's available\n-        RESTARTABLE(statx_wrapper(AT_FDCWD, path, flags, mask, &statx_buf), err);\n-        if (err == 0) {\n-            copy_statx_attributes(env, &statx_buf, attrs);\n-            return 0;\n-        } else {\n-            return errno;\n-        }\n-    }\n-#endif\n+\n@@ -697,1 +534,1 @@\n-        copy_stat64_attributes(env, &buf, attrs);\n+        prepAttributes(env, &buf, attrs);\n@@ -711,17 +548,1 @@\n-#if defined(__linux__)\n-    struct my_statx statx_buf;\n-    int flags = AT_STATX_SYNC_AS_STAT | AT_SYMLINK_NOFOLLOW;\n-    unsigned int mask = STATX_ALL;\n-\n-    if (my_statx_func != NULL) {\n-        \/\/ Prefer statx over stat64 on Linux if it's available\n-        RESTARTABLE(statx_wrapper(AT_FDCWD, path, flags, mask, &statx_buf), err);\n-        if (err == 0) {\n-            copy_statx_attributes(env, &statx_buf, attrs);\n-        } else {\n-            throwUnixException(env, errno);\n-        }\n-        \/\/ statx was available, so return now\n-        return;\n-    }\n-#endif\n+\n@@ -732,1 +553,1 @@\n-        copy_stat64_attributes(env, &buf, attrs);\n+        prepAttributes(env, &buf, attrs);\n@@ -742,18 +563,1 @@\n-#if defined(__linux__)\n-    struct my_statx statx_buf;\n-    int flags = AT_EMPTY_PATH | AT_STATX_SYNC_AS_STAT;\n-    unsigned int mask = STATX_ALL;\n-\n-    if (my_statx_func != NULL) {\n-        \/\/ statx supports FD use via dirfd iff pathname is an empty string and the\n-        \/\/ AT_EMPTY_PATH flag is specified in flags\n-        RESTARTABLE(statx_wrapper((int)fd, \"\", flags, mask, &statx_buf), err);\n-        if (err == 0) {\n-            copy_statx_attributes(env, &statx_buf, attrs);\n-        } else {\n-            throwUnixException(env, errno);\n-        }\n-        \/\/ statx was available, so return now\n-        return;\n-    }\n-#endif\n+\n@@ -764,1 +568,1 @@\n-        copy_stat64_attributes(env, &buf, attrs);\n+        prepAttributes(env, &buf, attrs);\n@@ -775,20 +579,0 @@\n-#if defined(__linux__)\n-    struct my_statx statx_buf;\n-    int flags = AT_STATX_SYNC_AS_STAT;\n-    unsigned int mask = STATX_ALL;\n-\n-    if (my_statx_func != NULL) {\n-        \/\/ Prefer statx over stat64 on Linux if it's available\n-        if (((int)flag & AT_SYMLINK_NOFOLLOW) > 0) { \/\/ flag set in java code\n-            flags |= AT_SYMLINK_NOFOLLOW;\n-        }\n-        RESTARTABLE(statx_wrapper((int)dfd, path, flags, mask, &statx_buf), err);\n-        if (err == 0) {\n-            copy_statx_attributes(env, &statx_buf, attrs);\n-        } else {\n-            throwUnixException(env, errno);\n-        }\n-        \/\/ statx was available, so return now\n-        return;\n-    }\n-#endif\n@@ -804,1 +588,1 @@\n-        copy_stat64_attributes(env, &buf, attrs);\n+        prepAttributes(env, &buf, attrs);\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixNativeDispatcher.c","additions":10,"deletions":226,"binary":false,"changes":236,"status":"modified"},{"patch":"@@ -242,1 +242,1 @@\n-        swprintf(url, MAX_STR_LEN, L\"%s:\/\/%s\", lpProto, lpHost);\n+        _snwprintf(url, sizeof(url) - 1, L\"%s:\/\/%s\", lpProto, lpHost);\n","filename":"src\/java.base\/windows\/native\/libnet\/DefaultProxySelector.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,0 @@\n-static NSInteger architecture = -1;\n@@ -62,11 +61,1 @@\n-static BOOL isValidDisplayMode(CGDisplayModeRef mode) {\n-    \/\/ Workaround for apple bug FB13261205, since it only affects arm based macs\n-    \/\/ and arm support started with macOS 11 ignore the workaround for previous versions\n-    if (@available(macOS 11, *)) {\n-        if (architecture == -1) {\n-            architecture = [[NSRunningApplication currentApplication] executableArchitecture];\n-        }\n-        if (architecture == NSBundleExecutableArchitectureARM64) {\n-            return (CGDisplayModeGetPixelWidth(mode) >= 800);\n-        }\n-    }\n+static BOOL isValidDisplayMode(CGDisplayModeRef mode){\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CGraphicsDevice.m","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,0 +61,1 @@\n+            class=\"centered\"\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/doc-files\/FocusCycle.svg","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -373,0 +373,7 @@\n+        contentPane.add(component);\n+        if (\"true\".equals(AccessController.\n+            doPrivileged(new GetPropertyAction(\"swing.jlf.contentPaneTransparent\", \"false\"))))\n+        {\n+            contentPane.setOpaque(false);\n+        }\n+        setContentPane(contentPane);\n@@ -392,9 +399,0 @@\n-        contentPane.add(component);\n-        contentPane.revalidate();\n-        contentPane.repaint();\n-        if (\"true\".equals(AccessController.\n-            doPrivileged(new GetPropertyAction(\"swing.jlf.contentPaneTransparent\", \"false\"))))\n-        {\n-            contentPane.setOpaque(false);\n-        }\n-        setContentPane(contentPane);\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/JLightweightFrame.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -53,0 +53,2 @@\n+extern int XShmQueryExtension();\n+\n","filename":"src\/java.desktop\/unix\/native\/common\/awt\/awt_GraphicsEnv.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1468,1 +1468,1 @@\n-                    (*fp_gtk_notebook_new)();\n+                    (*fp_gtk_notebook_new)(NULL);\n@@ -1476,1 +1476,1 @@\n-                    (*fp_gtk_toggle_button_new)();\n+                    (*fp_gtk_toggle_button_new)(NULL);\n@@ -1485,1 +1485,1 @@\n-                    (*fp_gtk_toolbar_new)();\n+                    (*fp_gtk_toolbar_new)(NULL);\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/gtk2_interface.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1259,1 +1259,1 @@\n-                    (*fp_gtk_notebook_new)();\n+                    (*fp_gtk_notebook_new)(NULL);\n@@ -1267,1 +1267,1 @@\n-                    (*fp_gtk_toggle_button_new)();\n+                    (*fp_gtk_toggle_button_new)(NULL);\n@@ -1276,1 +1276,1 @@\n-                    (*fp_gtk_toolbar_new)();\n+                    (*fp_gtk_toolbar_new)(NULL);\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/gtk3_interface.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -581,1 +581,0 @@\n-                        return true;\n@@ -583,1 +582,1 @@\n-                    return false;\n+                    return true;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientImpl.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-            while (!inputQ.isEmpty() && errorRef.get() == null) {\n+            while (!inputQ.isEmpty()) {\n@@ -420,4 +420,0 @@\n-        \/\/ ensure that the body subscriber will be subscribed and onError() is\n-        \/\/ invoked\n-        pendingResponseSubscriber = bodySubscriber;\n-\n@@ -434,0 +430,3 @@\n+        \/\/ ensure that the body subscriber will be subscribed and onError() is\n+        \/\/ invoked\n+        pendingResponseSubscriber = bodySubscriber;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4653,1 +4653,1 @@\n-                    (hasBindings(patternLabel.pat) || hasBindings(c.guard))) {\n+                    hasBindings(patternLabel.pat)) {\n@@ -4657,1 +4657,1 @@\n-                           (hasBindings(patternLabel.pat) || hasBindings(c.guard)) &&\n+                           hasBindings(patternLabel.pat) &&\n@@ -4666,1 +4666,1 @@\n-    boolean hasBindings(JCTree p) {\n+    boolean hasBindings(JCPattern p) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -912,1 +912,0 @@\n-                checkNoMods(pos, mods.flags & Flags.FINAL);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1653,1 +1653,1 @@\n-                    node.body != null && node.body.stats.nonEmpty() && TreeInfo.isSuperCall(node.body.stats.head) &&\n+                    node.body.stats.nonEmpty() && TreeInfo.isSuperCall(node.body.stats.head) &&\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -431,1 +431,0 @@\n-    @java.io.Serial\n@@ -434,1 +433,1 @@\n-            throw new InvalidObjectException(\"Token has been removed\");\n+            throw new NotSerializableException(\"Token has been removed\");\n@@ -439,16 +438,0 @@\n-    \/**\n-     * Restores the state of this object from the stream.\n-     * <p>\n-     * Deserialization of this object is not supported.\n-     *\n-     * @param  stream the {@code ObjectInputStream} from which data is read\n-     * @throws IOException if an I\/O error occurs\n-     * @throws ClassNotFoundException if a serialized class cannot be loaded\n-     *\/\n-    @java.io.Serial\n-    private void readObject(ObjectInputStream stream)\n-            throws IOException, ClassNotFoundException {\n-        throw new InvalidObjectException(\n-                \"Tokens are not directly deserializable\");\n-    }\n-\n@@ -469,1 +452,0 @@\n-        @java.io.Serial\n@@ -479,1 +461,1 @@\n-            throw new InvalidObjectException(\"Could not find token\");\n+            throw new NotSerializableException(\"Could not find token\");\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Token.java","additions":3,"deletions":21,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import java.io.IOException;\n-import java.io.InvalidObjectException;\n-import java.io.ObjectInputStream;\n@@ -41,1 +38,0 @@\n-    @java.io.Serial\n@@ -79,1 +75,0 @@\n-    @java.io.Serial\n@@ -82,18 +77,1 @@\n-        throw new java.io.InvalidObjectException(\n-                \"CPrivateKeys are not serializable\");\n-    }\n-\n-    \/**\n-     * Restores the state of this object from the stream.\n-     * <p>\n-     * Deserialization of this object is not supported.\n-     *\n-     * @param  stream the {@code ObjectInputStream} from which data is read\n-     * @throws IOException if an I\/O error occurs\n-     * @throws ClassNotFoundException if a serialized class cannot be loaded\n-     *\/\n-    @java.io.Serial\n-    private void readObject(ObjectInputStream stream)\n-            throws IOException, ClassNotFoundException {\n-        throw new InvalidObjectException(\n-                \"CPrivateKeys are not deserializable\");\n+        throw new java.io.NotSerializableException();\n","filename":"src\/jdk.crypto.mscapi\/windows\/classes\/sun\/security\/mscapi\/CPrivateKey.java","additions":2,"deletions":24,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import java.io.IOException;\n-import java.io.InvalidObjectException;\n-import java.io.ObjectInputStream;\n@@ -56,1 +53,0 @@\n-    @java.io.Serial\n@@ -65,2 +61,0 @@\n-\n-        @java.io.Serial\n@@ -118,1 +112,1 @@\n-            sb.append(algorithm).append(\"PublicKey [size=\").append(keyLength)\n+            sb.append(algorithm + \"PublicKey [size=\").append(keyLength)\n@@ -129,2 +123,0 @@\n-\n-        @java.io.Serial\n@@ -139,1 +131,1 @@\n-            sb.append(algorithm).append(\"PublicKey [size=\").append(keyLength)\n+            sb.append(algorithm + \"PublicKey [size=\").append(keyLength)\n@@ -226,1 +218,0 @@\n-    @java.io.Serial\n@@ -234,16 +225,0 @@\n-    \/**\n-     * Restores the state of this object from the stream.\n-     * <p>\n-     * Deserialization of this object is not supported.\n-     *\n-     * @param  stream the {@code ObjectInputStream} from which data is read\n-     * @throws IOException if an I\/O error occurs\n-     * @throws ClassNotFoundException if a serialized class cannot be loaded\n-     *\/\n-    @java.io.Serial\n-    private void readObject(ObjectInputStream stream)\n-            throws IOException, ClassNotFoundException {\n-        throw new InvalidObjectException(\n-                \"CPublicKeys are not deserializable\");\n-    }\n-\n","filename":"src\/jdk.crypto.mscapi\/windows\/classes\/sun\/security\/mscapi\/CPublicKey.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1303,5 +1303,0 @@\n-    \/**\n-     * Clears the oop handle in {@code handle}.\n-     *\/\n-    native void clearOopHandle(long handle);\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -158,2 +158,1 @@\n-     * {@link CompilerToVM#releaseClearedOopHandles}. This must be done with a VM call so\n-     * that the JNI handle is cleared at a safepoint.\n+     * {@link CompilerToVM#releaseClearedOopHandles}.\n@@ -162,1 +161,1 @@\n-        runtime().compilerToVm.clearOopHandle(handle);\n+        UNSAFE.putLong(handle, 0);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/IndirectHotSpotObjectConstantImpl.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-        return new RISCV64HotSpotRegisterConfig(target, config.useCompressedOops, target.linuxOs);\n+        return new RISCV64HotSpotRegisterConfig(target, config.useCompressedOops, config.linuxOs);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/riscv64\/RISCV64HotSpotJVMCIBackendFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import jdk.vm.ci.services.Services;\n+import jdk.internal.util.OperatingSystem;\n@@ -39,0 +41,2 @@\n+    final boolean linuxOs = OperatingSystem.isLinux();\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/riscv64\/RISCV64HotSpotVMConfig.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -540,10 +540,0 @@\n-    \/**\n-     * Add the restricted information for the given method.\n-     *\n-     * @param method the method being documented.\n-     * @param content the content to which the preview information will be added.\n-     *\/\n-    protected void addRestrictedInfo(ExecutableElement method, Content content) {\n-        writer.addRestrictedInfo(method, content);\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AbstractMemberWriter.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -97,3 +97,3 @@\n-                Content div = HtmlTree.DIV(HtmlStyle.horizontalScroll);\n-                buildAnnotationTypeMemberChildren(div);\n-                annotationContent.add(div);\n+\n+                buildAnnotationTypeMemberChildren(annotationContent);\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AnnotationTypeMemberWriter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-        Content c = HtmlTree.DIV(HtmlStyle.horizontalScroll);\n+        Content c = new ContentBuilder();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ClassWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -109,7 +109,7 @@\n-                Content div = HtmlTree.DIV(HtmlStyle.horizontalScroll);\n-                buildSignature(div);\n-                buildDeprecationInfo(div);\n-                buildPreviewInfo(div);\n-                buildConstructorComments(div);\n-                buildTagInfo(div);\n-                constructorContent.add(div);\n+\n+                buildSignature(constructorContent);\n+                buildDeprecationInfo(constructorContent);\n+                buildPreviewInfo(constructorContent);\n+                buildConstructorComments(constructorContent);\n+                buildTagInfo(constructorContent);\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ConstructorWriter.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -160,3 +160,0 @@\n-    public final Content restrictedMark;\n-    public final Content restrictedMethods;\n-    public final Content restrictedPhrase;\n@@ -309,3 +306,0 @@\n-        restrictedMark = getContent(\"doclet.Restricted_Mark\");\n-        restrictedMethods = getContent(\"doclet.Restricted_Methods\");\n-        restrictedPhrase = getContent(\"doclet.Restricted\");\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Contents.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -76,7 +76,7 @@\n-                Content div = HtmlTree.DIV(HtmlStyle.horizontalScroll);\n-                buildSignature(div);\n-                buildDeprecationInfo(div);\n-                buildPreviewInfo(div);\n-                buildEnumConstantComments(div);\n-                buildTagInfo(div);\n-                enumConstantContent.add(div);\n+\n+                buildSignature(enumConstantContent);\n+                buildDeprecationInfo(enumConstantContent);\n+                buildPreviewInfo(enumConstantContent);\n+                buildEnumConstantComments(enumConstantContent);\n+                buildTagInfo(enumConstantContent);\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/EnumConstantWriter.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -86,7 +86,7 @@\n-                Content div = HtmlTree.DIV(HtmlStyle.horizontalScroll);\n-                buildSignature(div);\n-                buildDeprecationInfo(div);\n-                buildPreviewInfo(div);\n-                buildFieldComments(div);\n-                buildTagInfo(div);\n-                fieldContent.add(div);\n+\n+                buildSignature(fieldContent);\n+                buildDeprecationInfo(fieldContent);\n+                buildPreviewInfo(fieldContent);\n+                buildFieldComments(fieldContent);\n+                buildTagInfo(fieldContent);\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/FieldWriter.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -345,9 +345,0 @@\n-        \/\/ Restricted\n-        if (configuration.conditionalPages.contains(HtmlConfiguration.ConditionalPage.RESTRICTED)) {\n-            section = newHelpSection(contents.restrictedMethods, PageMode.RESTRICTED, subTOC);\n-            Content restrictedBody = getContent(\"doclet.help.restricted.body\",\n-                    links.createLink(DocPaths.RESTRICTED_LIST, resources.getText(\"doclet.Restricted_Methods\")));\n-            section.add(HtmlTree.P(restrictedBody));\n-            pageKindsSection.add(section);\n-        }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HelpWriter.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -71,1 +71,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.RestrictedAPIListBuilder;\n@@ -143,8 +142,0 @@\n-    \/**\n-     * The collection of restricted methods, if any, to be displayed on the\n-     * restricted-list page, or null if the page should not be generated.\n-     * The page will not be generated if there are no restricted methods to be\n-     * documented.\n-     *\/\n-    protected RestrictedAPIListBuilder restrictedAPIListBuilder;\n-\n@@ -174,2 +165,1 @@\n-        CONSTANT_VALUES, DEPRECATED, EXTERNAL_SPECS, PREVIEW, RESTRICTED,\n-        SERIALIZED_FORM, SYSTEM_PROPERTIES, NEW\n+        CONSTANT_VALUES, DEPRECATED, EXTERNAL_SPECS, PREVIEW, SERIALIZED_FORM, SYSTEM_PROPERTIES, NEW\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlConfiguration.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.RestrictedAPIListBuilder;\n@@ -199,5 +198,0 @@\n-        RestrictedAPIListBuilder restrictedBuilder = new RestrictedAPIListBuilder(configuration);\n-        if (!restrictedBuilder.isEmpty()) {\n-            configuration.restrictedAPIListBuilder = restrictedBuilder;\n-            configuration.conditionalPages.add(HtmlConfiguration.ConditionalPage.RESTRICTED);\n-        }\n@@ -256,1 +250,0 @@\n-                HtmlConfiguration.ConditionalPage.RESTRICTED,\n@@ -263,1 +256,0 @@\n-                    case RESTRICTED -> writerFactory.newRestrictedListWriter();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDoclet.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -507,1 +507,1 @@\n-    protected Content getHeader(Navigation.PageMode pageMode) {\n+    protected HtmlTree getHeader(Navigation.PageMode pageMode) {\n@@ -520,1 +520,1 @@\n-    protected Content getHeader(Navigation.PageMode pageMode, Element element) {\n+    protected HtmlTree getHeader(Navigation.PageMode pageMode, Element element) {\n@@ -522,2 +522,2 @@\n-                        .add(RawHtml.of(replaceDocRootDir(options.top())))\n-                        .add(getNavBar(pageMode, element).getContent());\n+                .add(RawHtml.of(replaceDocRootDir(options.top())))\n+                .add(getNavBar(pageMode, element).getContent());\n@@ -2056,8 +2056,0 @@\n-    public void addRestrictedSummary(Element forWhat, Content target) {\n-        if (utils.isRestrictedAPI(forWhat)) {\n-            var div = HtmlTree.DIV(HtmlStyle.block);\n-            div.add(HtmlTree.SPAN(HtmlStyle.restrictedLabel, contents.restrictedPhrase));\n-            target.add(div);\n-        }\n-    }\n-\n@@ -2214,20 +2206,0 @@\n-    public void addRestrictedInfo(ExecutableElement forWhat, Content target) {\n-        if (utils.isRestrictedAPI(forWhat)) {\n-            \/\/in Java platform:\n-            var restrictedDiv = HtmlTree.DIV(HtmlStyle.restrictedBlock);\n-            restrictedDiv.setId(htmlIds.forRestrictedSection(forWhat));\n-            String name = forWhat.getSimpleName().toString();\n-            var nameCode = HtmlTree.CODE(Text.of(name));\n-            String leadingNoteKey = \"doclet.RestrictedLeadingNote\";\n-            Content leadingNote =\n-                    contents.getContent(leadingNoteKey, nameCode);\n-            restrictedDiv.add(HtmlTree.SPAN(HtmlStyle.restrictedLabel,\n-                    leadingNote));\n-            Content note1 = contents.getContent(\"doclet.RestrictedTrailingNote1\", nameCode);\n-            restrictedDiv.add(HtmlTree.DIV(HtmlStyle.restrictedComment, note1));\n-            Content note2 = contents.getContent(\"doclet.RestrictedTrailingNote2\", nameCode);\n-            restrictedDiv.add(HtmlTree.DIV(HtmlStyle.restrictedComment, note2));\n-            target.add(restrictedDiv);\n-        }\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":4,"deletions":32,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -492,11 +492,0 @@\n-    \/**\n-     * Returns an id for the \"restricted\" section for an executable element.\n-     *\n-     * @param el the executable element\n-     *\n-     * @return the id\n-     *\/\n-    public HtmlId forRestrictedSection(ExecutableElement el) {\n-        return HtmlId.of(\"restricted-\" + forMember(el).name());\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlIds.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.util.function.Consumer;\n@@ -36,1 +35,0 @@\n-import javax.lang.model.element.ExecutableElement;\n@@ -47,1 +45,0 @@\n-import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n@@ -241,1 +238,0 @@\n-        ExecutableElement restrictedTarget;\n@@ -246,1 +242,0 @@\n-            restrictedTarget = null;\n@@ -249,3 +244,0 @@\n-            \/\/ We piggy back on whether to show preview info, for both preview AND\n-            \/\/ restricted methods superscripts. That's because when e.g. we are generating a\n-            \/\/ method summary we do not want either superscript.\n@@ -265,5 +257,0 @@\n-            if (flags.contains(ElementFlag.RESTRICTED)) {\n-                restrictedTarget = (ExecutableElement) linkInfo.getTargetMember();\n-            } else {\n-                restrictedTarget = null;\n-            }\n@@ -272,1 +259,0 @@\n-            restrictedTarget = null;\n@@ -286,1 +272,0 @@\n-                        Content spacer = Text.EMPTY;\n@@ -291,7 +276,0 @@\n-                            spacer = Entity.NO_BREAK_SPACE;\n-                        }\n-                        if (flags.contains(ElementFlag.RESTRICTED)) {\n-                            link.add(spacer);\n-                            link.add(HtmlTree.SUP(m_writer.links.createLink(\n-                                    filename.fragment(m_writer.htmlIds.forRestrictedSection(restrictedTarget).name()),\n-                                    m_writer.contents.restrictedMark)));\n@@ -308,1 +286,0 @@\n-                Content spacer = Text.EMPTY;\n@@ -315,9 +292,0 @@\n-                    spacer = Entity.NO_BREAK_SPACE;\n-                }\n-                if (flags.contains(ElementFlag.RESTRICTED)) {\n-                    link.add(spacer);\n-                    link.add(HtmlTree.SUP(m_writer.getCrossClassLink(\n-                            typeElement,\n-                            m_writer.htmlIds.forRestrictedSection(restrictedTarget).name(),\n-                            m_writer.contents.restrictedMark,\n-                            null, false)));\n@@ -330,1 +298,0 @@\n-        Content spacer = Text.EMPTY;\n@@ -333,5 +300,0 @@\n-            spacer = Entity.NO_BREAK_SPACE;\n-        }\n-        if (flags.contains(ElementFlag.RESTRICTED)) {\n-            link.add(spacer);\n-            link.add(HtmlTree.SUP(m_writer.contents.restrictedMark));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlLinkFactory.java","additions":0,"deletions":38,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -108,8 +108,7 @@\n-                Content div = HtmlTree.DIV(HtmlStyle.horizontalScroll);\n-                buildSignature(div);\n-                buildDeprecationInfo(div);\n-                buildPreviewInfo(div);\n-                buildRestrictedInfo(div);\n-                buildMethodComments(div);\n-                buildTagInfo(div);\n-                methodContent.add(div);\n+\n+                buildSignature(methodContent);\n+                buildDeprecationInfo(methodContent);\n+                buildPreviewInfo(methodContent);\n+                buildMethodComments(methodContent);\n+                buildTagInfo(methodContent);\n+\n@@ -138,9 +137,0 @@\n-    \/**\n-     * Builds the restricted method info.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildRestrictedInfo(Content target) {\n-        addRestricted(currentMethod, target);\n-    }\n-\n@@ -228,4 +218,0 @@\n-    protected void addRestricted(ExecutableElement method, Content content) {\n-        addRestrictedInfo(method, content);\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/MethodWriter.java","additions":7,"deletions":21,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -194,5 +194,3 @@\n-        moduleContent.add(new HtmlTree(TagName.HR));\n-        Content div = HtmlTree.DIV(HtmlStyle.horizontalScroll);\n-        addModuleSignature(div);\n-        buildModuleDescription(div);\n-        moduleContent.add(div);\n+\n+        addModuleSignature(moduleContent);\n+        buildModuleDescription(moduleContent);\n@@ -887,0 +885,1 @@\n+        moduleContent.add(new HtmlTree(TagName.HR));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ModuleWriter.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -94,1 +94,0 @@\n-        RESTRICTED,\n@@ -320,1 +319,0 @@\n-            case RESTRICTED:\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Navigation.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-    private final HtmlTree section = HtmlTree.SECTION(HtmlStyle.packageDescription);\n+    private final HtmlTree section = HtmlTree.SECTION(HtmlStyle.packageDescription, new ContentBuilder());\n@@ -131,6 +131,4 @@\n-        packageContent.add(new HtmlTree(TagName.HR));\n-        Content div = HtmlTree.DIV(HtmlStyle.horizontalScroll);\n-        addPackageSignature(div);\n-        buildPackageDescription(div);\n-        buildPackageTags(div);\n-        packageContent.add(div);\n+\n+        addPackageSignature(packageContent);\n+        buildPackageDescription(packageContent);\n+        buildPackageTags(packageContent);\n@@ -182,2 +180,2 @@\n-        if (!options.noComment()) {\n-            addPackageDescription(packageContent);\n+        if (options.noComment()) {\n+            return;\n@@ -185,0 +183,1 @@\n+        addPackageDescription(packageContent);\n@@ -193,2 +192,2 @@\n-        if (!options.noComment()) {\n-            addPackageTags(packageContent);\n+        if (options.noComment()) {\n+            return;\n@@ -196,0 +195,1 @@\n+        addPackageTags(packageContent);\n@@ -425,0 +425,1 @@\n+        packageContent.add(new HtmlTree(TagName.HR));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/PackageWriter.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -81,7 +81,7 @@\n-                Content div = HtmlTree.DIV(HtmlStyle.horizontalScroll);\n-                buildSignature(div);\n-                buildDeprecationInfo(div);\n-                buildPreviewInfo(div);\n-                buildPropertyComments(div);\n-                buildTagInfo(div);\n-                propertyContent.add(div);\n+\n+                buildSignature(propertyContent);\n+                buildDeprecationInfo(propertyContent);\n+                buildPreviewInfo(propertyContent);\n+                buildPropertyComments(propertyContent);\n+                buildTagInfo(propertyContent);\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/PropertyWriter.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,84 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-import javax.lang.model.element.Element;\n-\n-import jdk.javadoc.internal.doclets.formats.html.Navigation.PageMode;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;\n-import jdk.javadoc.internal.doclets.toolkit.util.IndexItem;\n-import jdk.javadoc.internal.doclets.toolkit.util.RestrictedAPIListBuilder;\n-\n-\/**\n- * Generate File to list all the restricted methods with the\n- * appropriate links.\n- *\/\n-public class RestrictedListWriter extends SummaryListWriter<RestrictedAPIListBuilder> {\n-\n-    \/**\n-     * Constructor.\n-     *\n-     * @param configuration the configuration for this doclet\n-     *\/\n-    public RestrictedListWriter(HtmlConfiguration configuration) {\n-        super(configuration, DocPaths.RESTRICTED_LIST, configuration.restrictedAPIListBuilder);\n-        if (configuration.restrictedAPIListBuilder != null) {\n-            configuration.indexBuilder.add(IndexItem.of(IndexItem.Category.TAGS,\n-                    resources.getText(\"doclet.Restricted_Methods\"), path));\n-        }\n-    }\n-\n-    @Override\n-    protected PageMode getPageMode() {\n-        return PageMode.RESTRICTED;\n-    }\n-\n-    @Override\n-    protected String getDescription() {\n-        return \"restricted methods\";\n-    }\n-\n-    @Override\n-    protected boolean showContentsList() {\n-        \/\/ This list contains only methods, no need to show list of element kinds.\n-        return false;\n-    }\n-\n-    @Override\n-    protected Content getHeadContent() {\n-        return configuration.contents.restrictedMethods;\n-    }\n-\n-    @Override\n-    protected String getTitleKey() {\n-        return \"doclet.Window_Restricted_List\";\n-    }\n-\n-    @Override\n-    protected void addComments(Element e, Content desc) {\n-        addSummaryComment(e, desc);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/RestrictedListWriter.java","additions":0,"deletions":84,"binary":false,"changes":84,"status":"deleted"},{"patch":"@@ -116,1 +116,0 @@\n-        addRestrictedSummary(member, tdSummaryContent);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SubWriterHolderWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.util.Arrays;\n@@ -142,4 +141,2 @@\n-        if (showContentsList()) {\n-            content.add(HtmlTree.HEADING_TITLE(Headings.CONTENT_HEADING, contents.contentsHeading));\n-            content.add(getContentsList());\n-        }\n+        content.add(HtmlTree.HEADING_TITLE(Headings.CONTENT_HEADING, contents.contentsHeading));\n+        content.add(getContentsList());\n@@ -190,7 +187,0 @@\n-    \/**\n-     * {@return {@code true} if the contents list should be generated, {@code false} if not}\n-     *\/\n-    protected boolean showContentsList() {\n-        return true;\n-    }\n-\n@@ -317,2 +307,2 @@\n-     * Allow Subclasses to add a content selector UI such as a row of radio buttons\n-     * near the top of the page. This method does not add anything.\n+     * Subclasses allow the user to show or hide parts of the content in the page.\n+     * This method should be used to add the UI to select the visible page content.\n@@ -322,1 +312,1 @@\n-    protected void addContentSelectors(Content target) {}\n+    protected abstract void addContentSelectors(Content target);\n@@ -325,2 +315,2 @@\n-     * Allow subclasses to add an extra table column for an element.\n-     * This methods does not add any content by returning {@code null}.\n+     * Some subclasses of this class display an extra column in their element tables.\n+     * This methods allows them to return the content to show for {@code element}.\n@@ -331,3 +321,1 @@\n-    protected Content getExtraContent(Element element) {\n-        return null;\n-    }\n+    protected abstract Content getExtraContent(Element element);\n@@ -367,2 +355,1 @@\n-     * Allow subclasses to add extra tabs to the element tables. This method does not\n-     * add any tabs.\n+     * Allow subclasses to add extra tabs to the element tables.\n@@ -373,1 +360,1 @@\n-    protected void addTableTabs(Table<Element> table, String headingKey) {}\n+    protected abstract void addTableTabs(Table<Element> table, String headingKey);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SummaryListWriter.java","additions":10,"deletions":23,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -173,7 +173,0 @@\n-    \/**\n-     * {@return a new writer for the list of restricted methods in this release}\n-     *\/\n-    public HtmlDocletWriter newRestrictedListWriter() {\n-        return new RestrictedListWriter(configuration);\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/WriterFactory.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -46,2 +46,2 @@\n-    private Content header = null;\n-    private Content footer = null;\n+    private HtmlTree header = null;\n+    private HtmlTree footer = null;\n@@ -54,1 +54,1 @@\n-    public BodyContents setHeader(Content header) {\n+    public BodyContents setHeader(HtmlTree header) {\n@@ -59,1 +59,1 @@\n-    public BodyContents setFooter(Content footer) {\n+    public BodyContents setFooter(HtmlTree footer) {\n@@ -90,2 +90,3 @@\n-        return new ContentBuilder()\n-                .add(header)\n+        HtmlTree flexHeader = header.addStyle(HtmlStyle.flexHeader);\n+\n+        var flexContent = HtmlTree.DIV(HtmlStyle.flexContent)\n@@ -94,0 +95,4 @@\n+\n+        return HtmlTree.DIV(HtmlStyle.flexBox)\n+                .add(flexHeader)\n+                .add(flexContent);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/BodyContents.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -385,16 +385,0 @@\n-    \/**\n-     * The class for a block describing the \"restricted\" status of a declaration.\n-     *\/\n-    restrictedBlock,\n-\n-    \/**\n-     * The class for the details in a block describing the \"restricted\" status of a declaration.\n-     *\/\n-    restrictedComment,\n-\n-    \/**\n-     * The class for the \"Restricted\" label in a block describing the \"restricted\" status\n-     * of a declaration.\n-     *\/\n-    restrictedLabel,\n-\n@@ -582,0 +566,23 @@\n+    \/\/<editor-fold desc=\"flex layout\">\n+    \/\/\n+    \/\/ The following constants are used for the components of the top-level structures for \"flex\" layout.\n+\n+    \/**\n+     * The class of the top-level {@code div} element used to arrange for \"flex\" layout in\n+     * a browser window. The element should contain two child elements: one with class\n+     * {@link #flexHeader flex-header} and one with class {@link #flexContent flex-content}.\n+     *\/\n+    flexBox,\n+\n+    \/**\n+     * The class of the {@code header} element within a {@link #flexBox flex-box} container.\n+     * The element is always displayed at the top of the viewport.\n+     *\/\n+    flexHeader,\n+\n+    \/**\n+     * The class of the {@code div} element within a {@link #flexBox flex-box} container\n+     * This element appears below the header and can be scrolled if too big for the available height.\n+     *\/\n+    flexContent,\n+    \/\/<\/editor-fold>\n@@ -812,5 +819,0 @@\n-    \/**\n-     * The class of the {@code body} element for the page listing restricted methods.\n-     *\/\n-    restrictedListPage,\n-\n@@ -965,5 +967,0 @@\n-    \/**\n-     * The class of a {@code div} element that allows its horizontal overflow to be scrolled.\n-     *\/\n-    horizontalScroll,\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/HtmlStyle.java","additions":24,"deletions":27,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-\/\/ Dynamically set scroll margin to accomodate for draft header\n+\/\/ Workaround for scroll position not being included in browser history (8249133)\n@@ -232,4 +232,21 @@\n-    document.querySelectorAll(':not(input)[id]').forEach(\n-        function(c) {\n-            c.style[\"scroll-margin-top\"] = Math.ceil(document.querySelector(\"header\").offsetHeight) + \"px\"\n-        });\n+    var contentDiv = document.querySelector(\"div.flex-content\");\n+    window.addEventListener(\"popstate\", function(e) {\n+        if (e.state !== null) {\n+            contentDiv.scrollTop = e.state;\n+        }\n+    });\n+    window.addEventListener(\"hashchange\", function(e) {\n+        history.replaceState(contentDiv.scrollTop, document.title);\n+    });\n+    var timeoutId;\n+    contentDiv.addEventListener(\"scroll\", function(e) {\n+        if (timeoutId) {\n+            clearTimeout(timeoutId);\n+        }\n+        timeoutId = setTimeout(function() {\n+            history.replaceState(contentDiv.scrollTop, document.title);\n+        }, 100);\n+    });\n+    if (!location.hash) {\n+        history.replaceState(contentDiv.scrollTop, document.title);\n+    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/script.js","additions":22,"deletions":5,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -88,1 +88,0 @@\n-doclet.Window_Restricted_List=Restricted Method List\n@@ -133,2 +132,0 @@\n-doclet.Restricted_Methods=Restricted Methods\n-doclet.Restricted_Mark=RESTRICTED\n@@ -309,3 +306,0 @@\n-doclet.help.restricted.body=\\\n-    The {0} page lists all restricted methods. Restricted methods are unsafe, and, if used \\\n-    incorrectly, might crash the JVM or result in memory corruption.\n@@ -419,4 +413,0 @@\n-doclet.RestrictedLeadingNote={0} is a restricted method of the Java platform.\n-doclet.RestrictedTrailingNote1=Programs can only use {0} when access to restricted methods is enabled.\n-doclet.RestrictedTrailingNote2=Restricted methods are unsafe, and, if used incorrectly, might crash \\\n-    the JVM or result in memory corruption.\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard.properties","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -87,3 +87,0 @@\n-:not(input)[id] {\n-    scroll-margin-top: 78px;\n-}\n@@ -178,5 +175,13 @@\n-    header {\n-        position:sticky;\n-        top:0;\n-        z-index:1;\n-        background: var(--body-background-color);\n+    div.flex-box {\n+        position:fixed;\n+        display:flex;\n+        flex-direction:column;\n+        height: 100%;\n+        width: 100%;\n+    }\n+    header.flex-header {\n+        flex: 0 0 auto;\n+    }\n+    div.flex-content {\n+        flex: 1 1 auto;\n+        overflow-y: auto;\n@@ -303,1 +308,2 @@\n-body.class-declaration-page .details h3 {\n+body.class-declaration-page .details h3,\n+body.class-declaration-page .summary .inherited-list h2 {\n@@ -308,1 +314,0 @@\n-    overflow-x:auto;\n@@ -318,4 +323,0 @@\n-section[id$=-description] :is(dl, ol, ul, p, div, blockquote, pre):last-child,\n-section[id$=-description] :is(dl, ol, ul):last-child > :is(li, dd):last-child {\n-    margin-bottom:4px;\n-}\n@@ -445,2 +446,2 @@\n-    padding: 10px 0 0 1px;\n-    margin: 0;\n+    padding:10px 0 0 1px;\n+    margin:10px 0 0 0;\n@@ -529,1 +530,1 @@\n-    overflow: auto hidden;\n+    overflow-x: auto;\n@@ -617,1 +618,1 @@\n-    margin:8px 0 14px 0;\n+    margin:14px 0;\n@@ -650,1 +651,1 @@\n-.package-hierarchy-label, .type-name-label, .type-name-link, .search-tag-link, .preview-label, .restricted-label {\n+.package-hierarchy-label, .type-name-label, .type-name-link, .search-tag-link, .preview-label {\n@@ -653,1 +654,1 @@\n-.deprecation-comment, .help-footnote, .preview-comment, .restricted-comment {\n+.deprecation-comment, .help-footnote, .preview-comment {\n@@ -656,1 +657,12 @@\n-.deprecation-block, .preview-block, .restricted-block {\n+.deprecation-block {\n+    font-size:1em;\n+    font-family:var(--block-font-family);\n+    border-style:solid;\n+    border-width:thin;\n+    border-radius:10px;\n+    padding:10px;\n+    margin-bottom:10px;\n+    margin-right:10px;\n+    display:inline-block;\n+}\n+.preview-block {\n@@ -689,3 +701,0 @@\n-nav {\n-    overflow:hidden;\n-}\n@@ -848,3 +857,0 @@\n-.horizontal-scroll {\n-    overflow: auto hidden;\n-}\n@@ -1095,1 +1101,1 @@\n-    header {\n+    header.flex-header {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/stylesheet.css","additions":34,"deletions":28,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -432,5 +432,0 @@\n-    public boolean isRestrictedAPI(Element el) {\n-        Symbol sym = (Symbol) el;\n-        return sym.kind == MTH && (sym.flags() & Flags.RESTRICTED) != 0;\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/WorkArounds.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -216,1 +216,0 @@\n-doclet.Restricted=Restricted.\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets.properties","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -151,3 +151,0 @@\n-    \/** The name of the file for restricted methods. *\/\n-    public static final DocPath RESTRICTED_LIST = DocPath.create(\"restricted-list.html\");\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/DocPaths.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.util;\n-\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-\n-import javax.lang.model.element.Element;\n-\n-\/**\n- * Build list of all the restricted methods.\n- *\/\n-public class RestrictedAPIListBuilder extends SummaryAPIListBuilder {\n-\n-\n-    \/**\n-     * Constructor.\n-     *\n-     * @param configuration the current configuration of the doclet\n-     *\/\n-    public RestrictedAPIListBuilder(BaseConfiguration configuration) {\n-        super(configuration, configuration.utils::isRestrictedAPI);\n-        buildSummaryAPIInfo();\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/RestrictedAPIListBuilder.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -2743,10 +2743,0 @@\n-    \/**\n-     * Checks whether the given ExecutableElement should be marked as a restricted API.\n-     *\n-     * @param el the element to check\n-     * @return true if and only if the given element should be marked as a restricted API\n-     *\/\n-    public boolean isRestrictedAPI(Element el) {\n-        return configuration.workArounds.isRestrictedAPI(el);\n-    }\n-\n@@ -2766,4 +2756,0 @@\n-        if (el.getKind() == ElementKind.METHOD && configuration.workArounds.isRestrictedAPI((ExecutableElement)el)) {\n-            flags.add(ElementFlag.RESTRICTED);\n-        }\n-\n@@ -2783,2 +2769,1 @@\n-        PREVIEW,\n-        RESTRICTED\n+        PREVIEW\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -456,2 +456,0 @@\n-If %p and\/or %t is specified in the filename, it expands to the\n-JVM\\[aq]s PID and the current timestamp, respectively.\n@@ -526,2 +524,0 @@\n-If %p and\/or %t is specified in the filename, it expands to the\n-JVM\\[aq]s PID and the current timestamp, respectively.\n@@ -619,2 +615,0 @@\n-If %p and\/or %t is specified in the filename, it expands to the\n-JVM\\[aq]s PID and the current timestamp, respectively.\n","filename":"src\/jdk.jcmd\/share\/man\/jcmd.1","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -247,0 +247,4 @@\n+\\f[V]-P\\f[R] or \\f[V]-profile\\f[R]\n+Shows the profile containing a package.\n+This option is deprecated and may be removed in a future release.\n+.TP\n","filename":"src\/jdk.jdeps\/share\/man\/jdeps.1","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -224,1 +224,1 @@\n-The <\\f[I]view\\f[R]> parameter can be an event type name.\n+The parameter can be an event type name.\n@@ -261,3 +261,2 @@\n-Use the form:\n-<\\f[I]event-name\\f[R]>#<\\f[I]setting-name\\f[R]>=<\\f[I]value\\f[R]> To add\n-a new event setting, prefix the event name with \\[aq]+\\[aq].\n+Use the form: <\\f[I]event-name>#=<value\\f[R]> To add a new event\n+setting, prefix the event name with \\[aq]+\\[aq].\n@@ -320,1 +319,1 @@\n-<\\f[I]filter\\f[R]>] <\\f[I]input-file\\f[R]> [<\\f[I]output-file\\f[R]>]\n+<\\f[I]filter\\f[R]>] <\\f[I]input-file\\f[R]> []\n@@ -339,3 +338,2 @@\n-.TP\n-<\\f[I]input-file\\f[R]>\n-The input file to read events from.\n+.PP\n+<\\f[I]input-file\\f[R]> :The input file to read events from.\n@@ -351,1 +349,1 @@\n-.SS \\f[V]jfr assemble\\f[R] subcommand\n+.SS jfr \\f[V]assemble\\f[R] subcommand\n","filename":"src\/jdk.jfr\/share\/man\/jfr.1","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -193,1 +193,1 @@\n-        UNDERSCORE(TokenKind.UNDERSCORE, XDECL1),  \/\/  _\n+        UNDERSCORE(TokenKind.UNDERSCORE, XERRO),  \/\/  _\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/CompletenessAnalyzer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2013, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import java.io.IOException;\n-import java.io.InvalidObjectException;\n-import java.io.ObjectInputStream;\n@@ -53,1 +50,0 @@\n-    @java.io.Serial\n@@ -142,27 +138,0 @@\n-\n-    \/**\n-     * Restores the state of this object from the stream.\n-     *\n-     * @param  stream the {@code ObjectInputStream} from which data is read\n-     * @throws IOException if an I\/O error occurs\n-     * @throws ClassNotFoundException if a serialized class cannot be loaded\n-     *\/\n-    @java.io.Serial\n-    private void readObject(ObjectInputStream stream)\n-            throws IOException, ClassNotFoundException {\n-        stream.defaultReadObject();\n-        if ((name == null) || (nameString == null)) {\n-            throw new InvalidObjectException(\n-                    \"null name\/nameString is illegal\");\n-        }\n-        try {\n-            if (!name.equals(getLdapName(nameString))) {\n-                throw new InvalidObjectException(\"Inconsistent names\");\n-            }\n-        } catch  (InvalidNameException e) {\n-            InvalidObjectException nse = new InvalidObjectException(\n-                    \"Invalid Name\");\n-            nse.initCause(e);\n-            throw nse;\n-        }\n-    }\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/LdapPrincipal.java","additions":1,"deletions":32,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2013, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import java.io.IOException;\n-import java.io.InvalidObjectException;\n-import java.io.ObjectInputStream;\n@@ -53,1 +50,0 @@\n-    @java.io.Serial\n@@ -127,1 +123,3 @@\n-        return name.equals(that.getName());\n+            if (name.equals(that.getName()))\n+                return true;\n+            return false;\n@@ -138,20 +136,0 @@\n-\n-    \/**\n-     * Restores the state of this object from the stream.\n-     *\n-     * @param  stream the {@code ObjectInputStream} from which data is read\n-     * @throws IOException if an I\/O error occurs\n-     * @throws ClassNotFoundException if a serialized class cannot be loaded\n-     *\/\n-    @java.io.Serial\n-    private void readObject(ObjectInputStream stream)\n-            throws IOException, ClassNotFoundException {\n-        stream.defaultReadObject();\n-        if (name == null) {\n-            java.text.MessageFormat form = new java.text.MessageFormat\n-                    (sun.security.util.ResourcesMgr.getAuthResourceString\n-                            (\"invalid.null.input.value\"));\n-            Object[] source = {\"name\"};\n-            throw new InvalidObjectException(form.format(source));\n-        }\n-    }\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/NTDomainPrincipal.java","additions":4,"deletions":26,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2013, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import java.io.IOException;\n-import java.io.InvalidObjectException;\n-import java.io.ObjectInputStream;\n@@ -55,1 +52,0 @@\n-    @java.io.Serial\n@@ -87,1 +83,1 @@\n-        sid = stringSid;\n+        sid = new String(stringSid);\n@@ -135,1 +131,4 @@\n-        return sid.equals(that.sid);\n+        if (sid.equals(that.sid)) {\n+            return true;\n+        }\n+        return false;\n@@ -146,25 +145,0 @@\n-\n-    \/**\n-     * Restores the state of this object from the stream.\n-     *\n-     * @param  stream the {@code ObjectInputStream} from which data is read\n-     * @throws IOException if an I\/O error occurs\n-     * @throws ClassNotFoundException if a serialized class cannot be loaded\n-     *\/\n-    @java.io.Serial\n-    private void readObject(ObjectInputStream stream)\n-            throws IOException, ClassNotFoundException {\n-        stream.defaultReadObject();\n-        if (sid == null) {\n-            java.text.MessageFormat form = new java.text.MessageFormat\n-                    (sun.security.util.ResourcesMgr.getAuthResourceString\n-                            (\"invalid.null.input.value\"));\n-            Object[] source = {\"stringSid\"};\n-            throw new InvalidObjectException(form.format(source));\n-        }\n-        if (sid.length() == 0) {\n-            throw new InvalidObjectException\n-                    (sun.security.util.ResourcesMgr.getAuthResourceString\n-                            (\"Invalid.NTSid.value\"));\n-        }\n-    }\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/NTSid.java","additions":6,"deletions":32,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2013, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import java.io.IOException;\n-import java.io.InvalidObjectException;\n-import java.io.ObjectInputStream;\n@@ -49,1 +46,0 @@\n-    @java.io.Serial\n@@ -121,1 +117,3 @@\n-        return name.equals(that.getName());\n+            if (name.equals(that.getName()))\n+                return true;\n+            return false;\n@@ -132,21 +130,0 @@\n-\n-\n-    \/**\n-     * Restores the state of this object from the stream.\n-     *\n-     * @param  stream the {@code ObjectInputStream} from which data is read\n-     * @throws IOException if an I\/O error occurs\n-     * @throws ClassNotFoundException if a serialized class cannot be loaded\n-     *\/\n-    @java.io.Serial\n-    private void readObject(ObjectInputStream stream)\n-            throws IOException, ClassNotFoundException {\n-        stream.defaultReadObject();\n-        if (name == null) {\n-            java.text.MessageFormat form = new java.text.MessageFormat\n-                    (sun.security.util.ResourcesMgr.getAuthResourceString\n-                            (\"invalid.null.input.value\"));\n-            Object[] source = {\"name\"};\n-            throw new InvalidObjectException(form.format(source));\n-        }\n-    }\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/NTUserPrincipal.java","additions":4,"deletions":27,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import java.io.IOException;\n-import java.io.InvalidObjectException;\n-import java.io.ObjectInputStream;\n@@ -52,1 +49,0 @@\n-    @java.io.Serial\n@@ -191,2 +187,4 @@\n-        return this.getName().equals(that.getName()) &&\n-                this.isPrimaryGroup() == that.isPrimaryGroup();\n+        if (this.getName().equals(that.getName()) &&\n+            this.isPrimaryGroup() == that.isPrimaryGroup())\n+            return true;\n+        return false;\n@@ -203,20 +201,0 @@\n-\n-    \/**\n-     * Restores the state of this object from the stream.\n-     *\n-     * @param  stream the {@code ObjectInputStream} from which data is read\n-     * @throws IOException if an I\/O error occurs\n-     * @throws ClassNotFoundException if a serialized class cannot be loaded\n-     *\/\n-    @java.io.Serial\n-    private void readObject(ObjectInputStream stream)\n-            throws IOException, ClassNotFoundException {\n-        stream.defaultReadObject();\n-        if (name == null) {\n-            java.text.MessageFormat form = new java.text.MessageFormat\n-                    (sun.security.util.ResourcesMgr.getAuthResourceString\n-                            (\"invalid.null.input.value\"));\n-            Object[] source = {\"name\"};\n-            throw new InvalidObjectException(form.format(source));\n-        }\n-    }\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/UnixNumericGroupPrincipal.java","additions":5,"deletions":27,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2013, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import java.io.IOException;\n-import java.io.InvalidObjectException;\n-import java.io.ObjectInputStream;\n@@ -50,1 +47,0 @@\n-    @java.io.Serial\n@@ -153,1 +149,3 @@\n-        return this.getName().equals(that.getName());\n+        if (this.getName().equals(that.getName()))\n+            return true;\n+        return false;\n@@ -164,20 +162,0 @@\n-\n-    \/**\n-     * Restores the state of this object from the stream.\n-     *\n-     * @param  stream the {@code ObjectInputStream} from which data is read\n-     * @throws IOException if an I\/O error occurs\n-     * @throws ClassNotFoundException if a serialized class cannot be loaded\n-     *\/\n-    @java.io.Serial\n-    private void readObject(ObjectInputStream stream)\n-            throws IOException, ClassNotFoundException {\n-        stream.defaultReadObject();\n-        if (name == null) {\n-            java.text.MessageFormat form = new java.text.MessageFormat\n-                    (sun.security.util.ResourcesMgr.getAuthResourceString\n-                            (\"invalid.null.input.value\"));\n-            Object[] source = {\"name\"};\n-            throw new InvalidObjectException(form.format(source));\n-        }\n-    }\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/UnixNumericUserPrincipal.java","additions":4,"deletions":26,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2013, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import java.io.IOException;\n-import java.io.InvalidObjectException;\n-import java.io.ObjectInputStream;\n@@ -49,1 +46,0 @@\n-    @java.io.Serial\n@@ -122,1 +118,3 @@\n-        return this.getName().equals(that.getName());\n+        if (this.getName().equals(that.getName()))\n+            return true;\n+        return false;\n@@ -133,20 +131,0 @@\n-\n-    \/**\n-     * Restores the state of this object from the stream.\n-     *\n-     * @param  stream the {@code ObjectInputStream} from which data is read\n-     * @throws IOException if an I\/O error occurs\n-     * @throws ClassNotFoundException if a serialized class cannot be loaded\n-     *\/\n-    @java.io.Serial\n-    private void readObject(ObjectInputStream stream)\n-            throws IOException, ClassNotFoundException {\n-        stream.defaultReadObject();\n-        if (name == null) {\n-            java.text.MessageFormat form = new java.text.MessageFormat\n-                    (sun.security.util.ResourcesMgr.getAuthResourceString\n-                            (\"invalid.null.input.value\"));\n-            Object[] source = {\"name\"};\n-            throw new InvalidObjectException(form.format(source));\n-        }\n-    }\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/UnixPrincipal.java","additions":4,"deletions":26,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2013, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import java.io.IOException;\n-import java.io.InvalidObjectException;\n-import java.io.ObjectInputStream;\n@@ -50,1 +47,0 @@\n-    @java.io.Serial\n@@ -116,16 +112,0 @@\n-\n-    \/**\n-     * Restores the state of this object from the stream.\n-     *\n-     * @param  stream the {@code ObjectInputStream} from which data is read\n-     * @throws IOException if an I\/O error occurs\n-     * @throws ClassNotFoundException if a serialized class cannot be loaded\n-     *\/\n-    @java.io.Serial\n-    private void readObject(ObjectInputStream stream)\n-            throws IOException, ClassNotFoundException {\n-        stream.defaultReadObject();\n-        if (name == null) {\n-            throw new InvalidObjectException(\"null name is illegal\");\n-        }\n-    }\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/UserPrincipal.java","additions":1,"deletions":21,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -332,1 +332,1 @@\n-  Arena ar(mtTest, Arena::Tag::tag_other, 4097);\n+  Arena ar(mtTest, 4097);\n@@ -345,1 +345,1 @@\n-  Arena ar(mtTest, Arena::Tag::tag_other, 100); \/\/ first chunk is small\n+  Arena ar(mtTest, 100); \/\/ first chunk is small\n@@ -375,8 +375,8 @@\n-    Arena ar0(mtTest, Arena::Tag::tag_other, random_arena_chunk_size());\n-    Arena ar1(mtTest, Arena::Tag::tag_other, random_arena_chunk_size());\n-    Arena ar2(mtTest, Arena::Tag::tag_other, random_arena_chunk_size());\n-    Arena ar3(mtTest, Arena::Tag::tag_other, random_arena_chunk_size());\n-    Arena ar4(mtTest, Arena::Tag::tag_other, random_arena_chunk_size());\n-    Arena ar5(mtTest, Arena::Tag::tag_other, random_arena_chunk_size());\n-    Arena ar6(mtTest, Arena::Tag::tag_other, random_arena_chunk_size());\n-    Arena ar7(mtTest, Arena::Tag::tag_other, random_arena_chunk_size());\n+    Arena ar0(mtTest, random_arena_chunk_size());\n+    Arena ar1(mtTest, random_arena_chunk_size());\n+    Arena ar2(mtTest, random_arena_chunk_size());\n+    Arena ar3(mtTest, random_arena_chunk_size());\n+    Arena ar4(mtTest, random_arena_chunk_size());\n+    Arena ar5(mtTest, random_arena_chunk_size());\n+    Arena ar6(mtTest, random_arena_chunk_size());\n+    Arena ar7(mtTest, random_arena_chunk_size());\n","filename":"test\/hotspot\/gtest\/memory\/test_arena.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -35,2 +35,1 @@\n-# flag-sensitive:       test is sensitive to certain flags and might fail when flags are passed using -vmoptions and -javaoptions\n-keys=stress headful intermittent randomness cgroups flag-sensitive\n+keys=stress headful intermittent randomness cgroups\n","filename":"test\/hotspot\/jtreg\/TEST.ROOT","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,155 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.c2.irTests;\n-\n-import jdk.test.lib.Asserts;\n-import compiler.lib.ir_framework.*;\n-import java.util.Random;\n-import jdk.test.lib.Utils;\n-\n-\/*\n- * @test\n- * @summary Test that patterns involving duplicated conversion nodes behind phi are properly optimized.\n- * @bug 8316918\n- * @library \/test\/lib \/\n- * @requires vm.compiler2.enabled\n- * @run driver compiler.c2.irTests.TestPhiDuplicatedConversion\n- *\/\n-public class TestPhiDuplicatedConversion {\n-    public static void main(String[] args) {\n-        TestFramework.run();\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.CONV, \"1\"})\n-    public static float int2Float(boolean c, int a, int b) {\n-        return c ? a : b;\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.CONV, \"1\"})\n-    public static double int2Double(boolean c, int a, int b) {\n-        return c ? a : b;\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.CONV, \"1\"})\n-    public static long int2Long(boolean c, int a, int b) {\n-        return c ? a : b;\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.CONV, \"1\"})\n-    public static int float2Int(boolean c, float a, float b) {\n-        return c ? (int)a : (int)b;\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.CONV, \"1\"})\n-    public static double float2Double(boolean c, float a, float b) {\n-        return c ? (double)a : (double)b;\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.CONV, \"1\"})\n-    public static long float2Long(boolean c, float a, float b) {\n-        return c ? (long)a : (long)b;\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.CONV, \"1\"})\n-    public static int double2Int(boolean c, double a, double b) {\n-        return c ? (int)a : (int)b;\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.CONV, \"1\"})\n-    public static float double2Float(boolean c, double a, double b) {\n-        return c ? (float)a : (float)b;\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.CONV, \"1\"})\n-    public static long double2Long(boolean c, double a, double b) {\n-        return c ? (long)a : (long)b;\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.CONV, \"1\"})\n-    public static float long2Float(boolean c, long a, long b) {\n-        return c ? a : b;\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.CONV, \"1\"})\n-    public static double long2Double(boolean c, long a, long b) {\n-        return c ? a : b;\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.CONV, \"1\"})\n-    public static int long2Int(boolean c, long a, long b) {\n-        return c ? (int)a : (int)b;\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.CONV, \"1\"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    public static short float2HalfFloat(boolean c, float a, float b) {\n-        return c ? Float.floatToFloat16(a) : Float.floatToFloat16(b);\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.CONV, \"1\"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    public static float halfFloat2Float(boolean c, short a, short b) {\n-        return c ? Float.float16ToFloat(a) : Float.float16ToFloat(b);\n-    }\n-\n-    @Run(test = {\"int2Float\", \"int2Double\", \"int2Long\",\n-                 \"float2Int\", \"float2Double\", \"float2Long\",\n-                 \"double2Int\", \"double2Float\", \"double2Long\",\n-                 \"long2Float\", \"long2Double\", \"long2Int\",\n-                 \"float2HalfFloat\", \"halfFloat2Float\"})\n-    public void runTests() {\n-        assertResults(true, 10, 20, 3.14f, -1.6f, 3.1415, -1.618, 30L, 400L, Float.floatToFloat16(10.5f), Float.floatToFloat16(20.5f));\n-        assertResults(false, 10, 20, 3.14f, -1.6f, 3.1415, -1.618, 30L, 400L, Float.floatToFloat16(10.5f), Float.floatToFloat16(20.5f));\n-    }\n-\n-    @DontCompile\n-    public void assertResults(boolean c, int intA, int intB, float floatA, float floatB, double doubleA, double doubleB, long longA, long longB, short halfFloatA, short halfFloatB) {\n-        Asserts.assertEQ(c ? (float)intA : (float)intB, int2Float(c, intA, intB));\n-        Asserts.assertEQ(c ? (double)intA : (double)intB, int2Double(c, intA, intB));\n-        Asserts.assertEQ(c ? (long)intA : (long)intB, int2Long(c, intA, intB));\n-        Asserts.assertEQ(c ? (int)floatA : (int)floatB, float2Int(c, floatA, floatB));\n-        Asserts.assertEQ(c ? (double)floatA : (double)floatB, float2Double(c, floatA, floatB));\n-        Asserts.assertEQ(c ? (long)floatA : (long)floatB, float2Long(c, floatA, floatB));\n-        Asserts.assertEQ(c ? (int)doubleA : (int)doubleB, double2Int(c, doubleA, doubleB));\n-        Asserts.assertEQ(c ? (float)doubleA : (float)doubleB, double2Float(c, doubleA, doubleB));\n-        Asserts.assertEQ(c ? (long)doubleA : (long)doubleB, double2Long(c, doubleA, doubleB));\n-        Asserts.assertEQ(c ? (float)longA : (float)longB, long2Float(c, longA, longB));\n-        Asserts.assertEQ(c ? (double)longA : (double)longB, long2Double(c, longA, longB));\n-        Asserts.assertEQ(c ? (int)longA : (int)longB, long2Int(c, longA, longB));\n-        Asserts.assertEQ(c ? Float.floatToFloat16(floatA) : Float.floatToFloat16(floatB), float2HalfFloat(c, floatA, floatB));\n-        Asserts.assertEQ(c ? Float.float16ToFloat(halfFloatA) : Float.float16ToFloat(halfFloatB), halfFloat2Float(c, halfFloatA, halfFloatB));\n-    }\n-}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestPhiDuplicatedConversion.java","additions":0,"deletions":155,"binary":false,"changes":155,"status":"deleted"},{"patch":"@@ -445,5 +445,0 @@\n-    public static final String CONV = PREFIX + \"CONV\" + POSTFIX;\n-    static {\n-        beforeMatchingNameRegex(CONV, \"Conv\");\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Checks that -XX:CompileCommand=PrintMemStat,... works\n- * @library \/test\/lib\n- * @run driver compiler.print.CompileCommandPrintMemStat\n- *\/\n-\n-package compiler.print;\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-public class CompileCommandPrintMemStat {\n-\n-    final static String METHOD1 = \"method1\";\n-    final static String METHOD2 = \"method2\";\n-\n-    public static void main(String[] args) throws Exception {\n-        test(METHOD1, METHOD2);\n-        test(METHOD2, METHOD1);\n-    }\n-\n-    private static void test(String include, String exclude) throws Exception {\n-        List<String> options = new ArrayList<String>();\n-        options.add(\"-Xcomp\");\n-        options.add(\"-XX:-Inline\");\n-        options.add(\"-XX:CompileCommand=compileonly,\" + getTestClass() + \"::*\");\n-        options.add(\"-XX:CompileCommand=MemStat,\" + getTestMethod(include) + \",print\");\n-        options.add(getTestClass());\n-\n-        OutputAnalyzer oa = ProcessTools.executeTestJvm(options);\n-\n-        \/\/ We expect two printouts for \"PrintMemStat\". A line at compilation time, and a line in a summary report\n-        \/\/ that is printed when we exit. Both use the typical <class>::name format but use \/ as separator and also\n-        \/\/ print the signature.\n-        String expectedNameIncl = getTestMethod(include)\n-                .replace('.', '\/')\n-                .replace(\"$\", \"\\\\$\");\n-        String expectedNameExcl = getTestMethod(exclude)\n-                .replace('.', '\/')\n-                .replace(\"$\", \"\\\\$\");\n-\n-        \/\/ Should see trace output when methods are compiled\n-        oa.shouldHaveExitValue(0)\n-          .shouldMatch(\".*\" + expectedNameIncl + \".*\")\n-          .shouldNotMatch(\".*\" + expectedNameExcl + \".*\");\n-\n-        \/\/ Should see final report\n-        \/\/ Looks like this:\n-        \/\/ total     NA        RA        #nodes  time    type  #rc thread              method\n-        \/\/ 621832    0         589104    0       0,025   c1    1   0x00007f5ccc1951a0  java\/util\/zip\/ZipFile$Source::checkAndAddEntry((II)I)\n-        oa.shouldMatch(\"total.*method\");\n-        oa.shouldMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +\\\\d+.*\" + expectedNameIncl + \".*\");\n-        oa.shouldNotMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +\\\\d+.*\" + expectedNameExcl + \".*\");\n-    }\n-\n-    \/\/ Test class that is invoked by the sub process\n-    public static String getTestClass() {\n-        return TestMain.class.getName();\n-    }\n-\n-    public static String getTestMethod(String method) {\n-        return getTestClass() + \"::\" + method;\n-    }\n-\n-    public static class TestMain {\n-        public static void main(String[] args) {\n-            method1();\n-            method2();\n-        }\n-\n-        static void method1() {}\n-        static void method2() {}\n-    }\n-}\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/print\/CompileCommandPrintMemStat.java","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,0 @@\n- * @requires vm.opt.CompressedClassSpaceSize == null & vm.opt.UseCompressedClassPointers == null\n@@ -54,1 +53,1 @@\n-        ProcessBuilder pb = GCArguments.createTestJvm(args);\n+        ProcessBuilder pb = GCArguments.createJavaProcessBuilder(args);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestCompressedClassFlags.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,7 +43,7 @@\n-        ProcessBuilder pb = GCArguments.createTestJvm(\"-XX:-UseSerialGC\",\n-                                                      \"-XX:-UseParallelGC\",\n-                                                      \"-XX:-UseG1GC\",\n-                                                      \"-XX:-UseZGC\",\n-                                                      \"-XX:+UnlockExperimentalVMOptions\",\n-                                                      \"-XX:-UseShenandoahGC\",\n-                                                      \"-version\");\n+        ProcessBuilder pb = GCArguments.createJavaProcessBuilder(\"-XX:-UseSerialGC\",\n+                                                                 \"-XX:-UseParallelGC\",\n+                                                                 \"-XX:-UseG1GC\",\n+                                                                 \"-XX:-UseZGC\",\n+                                                                 \"-XX:+UnlockExperimentalVMOptions\",\n+                                                                 \"-XX:-UseShenandoahGC\",\n+                                                                 \"-version\");\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestDisableDefaultGC.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @requires vm.gc.G1 & vm.opt.G1ConcMarkStepDurationMillis == null\n+ * @requires vm.gc.G1\n@@ -81,1 +81,1 @@\n-    ProcessBuilder pb = GCArguments.createTestJvm(vmOpts);\n+    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(vmOpts);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestG1ConcMarkStepDurationMillis.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @requires vm.gc.G1 & vm.opt.G1ConcRefinementThreads == null\n+ * @requires vm.gc.G1\n@@ -72,1 +72,1 @@\n-    ProcessBuilder pb = GCArguments.createTestJvm(vmOpts);\n+    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(vmOpts);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestG1ConcRefinementThreads.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @requires vm.gc.G1 & vm.opt.G1HeapRegionSize == null\n+ * @requires vm.gc.G1\n@@ -56,1 +56,1 @@\n-    ProcessBuilder pb = GCArguments.createTestJvm(flagList);\n+    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(flagList);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestG1HeapRegionSize.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @requires vm.gc.G1\n@@ -30,2 +31,0 @@\n- * @key flag-sensitive\n- * @requires vm.gc.G1 & vm.opt.x.Xmx == null & vm.opt.x.Xms == null & vm.opt.MinHeapSize == null & vm.opt.MaxHeapSize == null & vm.opt.InitialHeapSize == null\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestG1HeapSizeFlags.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @requires vm.gc.G1 & vm.opt.G1ConfidencePercent == null\n+ * @requires vm.gc.G1\n@@ -66,1 +66,2 @@\n-        ProcessBuilder pb = GCArguments.createTestJvm(\"-XX:+UseG1GC\", flag, \"-version\");\n+        ProcessBuilder pb = GCArguments.createJavaProcessBuilder(\n+                \"-XX:+UseG1GC\", flag, \"-version\");\n@@ -75,1 +76,2 @@\n-    private static void check(String name, String value, boolean is_valid) throws Exception {\n+    private static\n+    void check(String name, String value, boolean is_valid) throws Exception {\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestG1PercentageOptions.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @requires vm.gc.G1 & vm.opt.UnlockExperimentalVMOptions == null & vm.opt.G1RemSetHowlNumBuckets == null & vm.opt.G1RemSetHowlMaxNumBuckets == null\n+ * @requires vm.gc.G1\n@@ -51,1 +51,1 @@\n-    ProcessBuilder pb = GCArguments.createTestJvm(flagList);\n+    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(flagList);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestG1RemSetFlags.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n- * @requires vm.opt.x.Xminf == null & vm.opt.x.Xmaxf == null & vm.opt.MinHeapFreeRatio == null & vm.opt.MaxHeapFreeRatio == null\n@@ -51,1 +50,1 @@\n-    ProcessBuilder pb = GCArguments.createTestJvm(\n+    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestHeapFreeRatio.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @requires vm.gc.Parallel & vm.opt.InitialTenuringThreshold == null & vm.opt.MaxTenuringThreshold == null\n+ * @requires vm.gc.Parallel\n@@ -44,1 +44,1 @@\n-    ProcessBuilder pb = GCArguments.createTestJvm(\n+    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(\n@@ -61,1 +61,1 @@\n-    ProcessBuilder pb = GCArguments.createTestJvm(\n+    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(\n@@ -63,1 +63,0 @@\n-      \"-XX:+UseParallelGC\",\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestInitialTenuringThreshold.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n-import java.util.ArrayList;\n-import java.util.Arrays;\n@@ -30,0 +28,2 @@\n+import java.util.ArrayList;\n+import java.util.Arrays;\n@@ -118,1 +118,1 @@\n-    ProcessBuilder pb = GCArguments.createTestJvm(gcflag,\n+    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(gcflag,\n@@ -211,1 +211,1 @@\n-    ProcessBuilder pb = GCArguments.createTestJvm(finalargs.toArray(String[]::new));\n+    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(finalargs.toArray(String[]::new));\n@@ -311,1 +311,1 @@\n-    ProcessBuilder pb = GCArguments.createTestJvm(flags);\n+    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(flags);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestMaxHeapSizeTools.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,1 @@\n- * @key flag-sensitive\n- * @requires vm.gc.Parallel & vm.opt.x.Xmx == null & vm.opt.x.Xms == null & vm.opt.MinHeapSize == null & vm.opt.MaxHeapSize == null & vm.opt.InitialHeapSize == null\n+ * @requires vm.gc.Parallel\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestParallelHeapSizeFlags.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,0 @@\n- * @key flag-sensitive\n- * @requires vm.gc.Serial & vm.opt.x.Xmx == null & vm.opt.x.Xms == null & vm.opt.MinHeapSize == null & vm.opt.MaxHeapSize == null & vm.opt.InitialHeapSize == null\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestSerialHeapSizeFlags.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,134 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.Utils;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-\n-\/*\n- * @test StackWalkNativeToJava\n- * @bug 8316309\n- * @summary Check that walking the stack works fine when going from C++ frame to Java frame.\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n- * @requires os.family != \"windows\"\n- * @requires vm.flagless\n- * @library \/test\/lib\n- * @run driver StackWalkNativeToJava\n- *\/\n-\n-public class StackWalkNativeToJava {\n-\n-    public static void main(String[] args) throws Exception {\n-        \/\/ Check stack walking works fine when sender of C++ frame\n-        \/\/ is a Java native method.\n-        testStackWalkNativeToJavaNative(\"-Xint\");\n-        testStackWalkNativeToJavaNative(\"-Xcomp\", \"-XX:CompileCommand=dontinline,StackWalkNativeToJava$TestNativeToJavaNative::*\");\n-\n-        \/\/ Check stack walking works fine when sender of C++ frame\n-        \/\/ is a runtime stub or interpreted Java method (VM call from Java).\n-        testStackWalkNativeToJava(\"-Xint\");\n-        testStackWalkNativeToJava(\"-Xcomp\", \"-XX:TieredStopAtLevel=3\",\n-                                  \"-XX:CompileCommand=dontinline,StackWalkNativeToJava$TestNativeToJava::*\");\n-    }\n-\n-    public static void testStackWalkNativeToJavaNative(String... extraFlags) throws Exception {\n-        List<String> commands = new ArrayList<>();\n-        commands.add(\"-Xbootclasspath\/a:.\");\n-        commands.add(\"-XX:-CreateCoredumpOnCrash\");\n-        commands.add(\"-XX:+UnlockDiagnosticVMOptions\");\n-        commands.add(\"-XX:AbortVMOnException=java.lang.IllegalMonitorStateException\");\n-        commands.add(\"-XX:+ErrorFileToStdout\");\n-        commands.addAll(Arrays.asList(extraFlags));\n-        commands.add(\"StackWalkNativeToJava$TestNativeToJavaNative\");\n-\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(commands);\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        output.shouldNotContain(\"java.lang.RuntimeException: Reached statement after obj.wait()\");\n-        output.shouldNotContain(\"[error occurred during error reporting (printing native stack\");\n-        String[] res = output.getOutput().split(\"StackWalkNativeToJava\\\\$TestNativeToJavaNative\\\\.callNativeMethod\\\\(\\\\)V\");\n-        assertTrue(res.length - 1 == 2, res.length - 1);\n-        output.shouldNotHaveExitValue(0);\n-    }\n-\n-    public static class TestNativeToJavaNative {\n-        public static void main(String[] args) throws Exception {\n-            TestNativeToJavaNative test = new TestNativeToJavaNative();\n-            test.callNativeMethod();\n-        }\n-\n-        public void callNativeMethod() throws Exception {\n-            Object obj = new Object();\n-            \/\/ Trigger a fatal exit due to IllegalMonitorStateException during\n-            \/\/ a call to the VM from a Java native method.\n-            obj.wait();\n-            throw new RuntimeException(\"Reached statement after obj.wait()\");\n-        }\n-    }\n-\n-    public static void testStackWalkNativeToJava(String... extraFlags) throws Exception {\n-        List<String> commands = new ArrayList<>();\n-        commands.add(\"-Xbootclasspath\/a:.\");\n-        commands.add(\"-XX:-CreateCoredumpOnCrash\");\n-        commands.add(\"-XX:+UnlockDiagnosticVMOptions\");\n-        commands.add(\"-XX:DiagnoseSyncOnValueBasedClasses=1\");\n-        commands.add(\"-XX:+ErrorFileToStdout\");\n-        commands.addAll(Arrays.asList(extraFlags));\n-        commands.add(\"StackWalkNativeToJava$TestNativeToJava\");\n-\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(commands);\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        output.shouldNotContain(\"java.lang.RuntimeException: Reached statement after synchronized\");\n-        output.shouldNotContain(\"[error occurred during error reporting (printing native stack\");\n-        String[] res = output.getOutput().split(\"StackWalkNativeToJava\\\\$TestNativeToJava\\\\.callVMMethod\\\\(\\\\)V\");\n-        assertTrue(res.length - 1 == 2, res.length - 1);\n-        output.shouldNotHaveExitValue(0);\n-    }\n-\n-    public static class TestNativeToJava {\n-        static Integer counter = 0;\n-\n-        public static void main(String[] args) throws Exception {\n-            TestNativeToJava test = new TestNativeToJava();\n-            test.callVMMethod();\n-        }\n-\n-        public void callVMMethod() throws Exception {\n-            \/\/ Trigger a fatal exit for trying to synchronize on a value based class\n-            \/\/ during a call to the VM from a Java method.\n-            synchronized (counter) {\n-                counter++;\n-            }\n-            throw new RuntimeException(\"Reached statement after synchronized\");\n-        }\n-    }\n-\n-    private static void assertTrue(boolean condition, int count) {\n-        if (!condition) {\n-            throw new RuntimeException(\"Count error: count was \" + count);\n-        }\n-    }\n-}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/StackWalkNativeToJava.java","additions":0,"deletions":134,"binary":false,"changes":134,"status":"deleted"},{"patch":"@@ -38,1 +38,0 @@\n-    private static int classesBeforeGC = 0;\n@@ -100,8 +99,0 @@\n-        \/\/ Every N-th classes, force a GC to kick out the loaded classes from previous tests.\n-        \/\/ Different tests come in with different number of classes, so testNum is not reliable.\n-        classesBeforeGC -= classes.size();\n-        if (classesBeforeGC <= 0) {\n-            System.gc();\n-            classesBeforeGC = 3000;\n-        }\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/InvocationTests\/shared\/AbstractGenerator.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary run NMT baseline, create threads and verify output from summary.diff\n- * @author Evgeny Ignatenko\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:NativeMemoryTracking=summary SummaryDiffThreadCount\n- *\/\n-\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.JDKToolFinder;\n-\n-public class SummaryDiffThreadCount {\n-    public static void main(String args[]) throws Exception {\n-        ProcessBuilder pb = new ProcessBuilder();\n-        OutputAnalyzer output;\n-        \/\/ Grab my own PID.\n-        String pid = Long.toString(ProcessTools.getProcessId());\n-\n-        pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.native_memory\", \"baseline=true\"});\n-        pb.start().waitFor();\n-\n-        output = new OutputAnalyzer(pb.start());\n-        output.shouldContain(\"Baseline taken\");\n-\n-        \/\/ Creating 10 threads.\n-        for (int i = 0; i < 10; i++) {\n-            new Thread(()-> {\n-                while (true) { continue; }\n-            }).start();\n-        }\n-\n-        \/\/ Running \"jcmd <pid> VM.native_memory summary.diff\" and checking for five new threads reported.\n-        pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.native_memory\", \"summary.diff\"});\n-        output = new OutputAnalyzer(pb.start());\n-\n-        \/\/ Trailing '+' is needed to check that NMT now reports that now we have more threads than it\n-        \/\/ was during the baseline.\n-        output.shouldMatch(\"threads #\\\\d+ \\\\+\");\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/SummaryDiffThreadCount.java","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,0 @@\n- * @comment CDS archive heap mapping is not supported with large pages\n- * @requires vm.opt.UseLargePages == null | !vm.opt.UseLargePages\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/sharedStrings\/InternSharedString.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,93 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8317262\n- * @library \/testlibrary \/test\/lib\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+HandshakeALot -XX:GuaranteedSafepointInterval=1 TestStackWalk\n- *\/\n-\n-import jvmti.JVMTIUtils;\n-import jdk.test.lib.Asserts;\n-import jdk.test.whitebox.WhiteBox;\n-import java.util.concurrent.CountDownLatch;\n-\n-public class TestStackWalk {\n-    static Thread worker1;\n-    static Thread worker2;\n-    static volatile boolean done;\n-    static volatile int counter = 0;\n-    static Object lock = new Object();\n-\n-    public static void main(String... args) throws Exception {\n-        worker1 = new Thread(() -> syncedWorker());\n-        worker1.start();\n-        worker2 = new Thread(() -> syncedWorker());\n-        worker2.start();\n-        Thread worker3 = new Thread(() -> stackWalker());\n-        worker3.start();\n-\n-        worker1.join();\n-        worker2.join();\n-        worker3.join();\n-    }\n-\n-    public static void syncedWorker() {\n-        synchronized (lock) {\n-            while (!done) {\n-                counter++;\n-            }\n-        }\n-    }\n-\n-    public static void stackWalker() {\n-        \/\/ Suspend workers so the one looping waiting for \"done\"\n-        \/\/ doesn't execute the handshake below, increasing the\n-        \/\/ chances the VMThread will do it.\n-        suspendWorkers();\n-\n-        WhiteBox wb = WhiteBox.getWhiteBox();\n-        long end = System.currentTimeMillis() + 20000;\n-        while (end > System.currentTimeMillis()) {\n-            wb.handshakeWalkStack(worker1, false \/* all_threads *\/);\n-            wb.handshakeWalkStack(worker2, false \/* all_threads *\/);\n-        }\n-\n-        resumeWorkers();\n-        done = true;\n-    }\n-\n-    static void suspendWorkers() {\n-        JVMTIUtils.suspendThread(worker1);\n-        JVMTIUtils.suspendThread(worker2);\n-    }\n-\n-    static void resumeWorkers() {\n-        JVMTIUtils.resumeThread(worker1);\n-        JVMTIUtils.resumeThread(worker2);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/lockStack\/TestStackWalk.java","additions":0,"deletions":93,"binary":false,"changes":93,"status":"deleted"},{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.test.lib.dcmd.PidJcmdExecutor;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-import java.util.Iterator;\n-\n-\/*\n- * @test CompilerMemoryStatisticTest\n- * @summary Test Compiler.memory\n- * @requires vm.compiler1.enabled\n- * @requires vm.compiler2.enabled\n- *\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @run main\/othervm -XX:CompileCommand=memstat,*.* CompilerMemoryStatisticTest\n- *\/\n-\n-\/*\n- * @test CompilerMemoryStatisticTest\n- * @summary Test Compiler.memory\n- * @requires vm.compiler1.enabled\n- * @requires vm.compiler2.enabled\n- *\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @run main\/othervm -XX:CompileCommand=memstat,*.*,collect CompilerMemoryStatisticTest\n- *\/\n-\n-public class CompilerMemoryStatisticTest {\n-\n-    public static void main(String args[]) throws Exception {\n-        PidJcmdExecutor executor = new PidJcmdExecutor();\n-        OutputAnalyzer out = executor.execute(\"Compiler.memory\");\n-        out.shouldHaveExitValue(0);\n-\n-        \/\/ Looks like this:\n-        \/\/ total     NA        RA        #nodes  time    type  #rc thread              method\n-        \/\/ 621832    0         589104    0       0,025   c1    1   0x00007f5ccc1951a0  java\/util\/zip\/ZipFile$Source.checkAndAddEntry((II)I)\n-        out.shouldMatch(\"total.*method\");\n-        out.shouldMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +\\\\d+.*java.*\\\\(.*\\\\)\");\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/compiler\/CompilerMemoryStatisticTest.java","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -264,1 +264,1 @@\n-            if (root.getReferrerId() == thread.getId()) {\n+            if (root.getRefererId() == thread.getId()) {\n@@ -289,1 +289,1 @@\n-        JavaHeapObject referrer = root.getReferrer();\n+        JavaHeapObject referrer = root.getReferer();\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/HeapDump\/VThreadInHeapDump.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -465,0 +465,1 @@\n+java\/awt\/GraphicsDevice\/CheckDisplayModes.java 8266242 macosx-aarch64\n@@ -763,1 +764,1 @@\n-jdk\/jfr\/api\/consumer\/recordingstream\/TestOnEvent.java           8255404 linux-x64,linux-aarch64\n+jdk\/jfr\/api\/consumer\/recordingstream\/TestOnEvent.java           8255404 linux-x64\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,63 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8318328\n- * @summary DHKEM should check XDH name in case-insensitive mode\n- * @library \/test\/lib\n- * @modules java.base\/com.sun.crypto.provider\n- *\/\n-import javax.crypto.KEM;\n-import java.math.BigInteger;\n-import java.security.KeyPairGenerator;\n-import java.security.interfaces.XECPublicKey;\n-import java.security.spec.AlgorithmParameterSpec;\n-import java.security.spec.NamedParameterSpec;\n-\n-public class NameSensitiveness {\n-    public static void main(String[] args) throws Exception {\n-        var g = KeyPairGenerator.getInstance(\"XDH\");\n-        g.initialize(NamedParameterSpec.X25519);\n-        var pk1 = (XECPublicKey) g.generateKeyPair().getPublic();\n-        var pk2 = new XECPublicKey() {\n-            public BigInteger getU() {\n-                return pk1.getU();\n-            }\n-            public AlgorithmParameterSpec getParams() {\n-                return new NamedParameterSpec(\"x25519\"); \/\/ lowercase!!!\n-            }\n-            public String getAlgorithm() {\n-                return pk1.getAlgorithm();\n-            }\n-            public String getFormat() {\n-                return pk1.getFormat();\n-            }\n-            public byte[] getEncoded() {\n-                return pk1.getEncoded();\n-            }\n-        };\n-        var kem = KEM.getInstance(\"DHKEM\");\n-        kem.newEncapsulator(pk2);\n-    }\n-}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/DHKEM\/NameSensitiveness.java","additions":0,"deletions":63,"binary":false,"changes":63,"status":"deleted"},{"patch":"@@ -53,1 +53,0 @@\n-                .screenCapture()\n","filename":"test\/jdk\/java\/awt\/Frame\/DefaultSizeTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+   @author Anton Nashatyrev\n@@ -31,9 +32,3 @@\n-import java.awt.AWTEvent;\n-import java.awt.Dimension;\n-import java.awt.FlowLayout;\n-import java.awt.Point;\n-import java.awt.Robot;\n-import java.awt.Toolkit;\n-import java.awt.event.AWTEventListener;\n-import java.awt.event.MouseAdapter;\n-import java.awt.event.MouseEvent;\n+import javax.swing.*;\n+import java.awt.*;\n+import java.awt.event.*;\n@@ -42,4 +37,0 @@\n-import javax.swing.JButton;\n-import javax.swing.JFrame;\n-import javax.swing.SwingUtilities;\n-\n@@ -56,3 +47,0 @@\n-    private volatile Point sLoc;\n-    private volatile Dimension bSize;\n-\n@@ -113,5 +101,2 @@\n-        SwingUtilities.invokeAndWait(() -> {\n-            sLoc = fb.getLocationOnScreen();\n-            bSize = fb.getSize();\n-        });\n-\n+        Point sLoc = fb.getLocationOnScreen();\n+        Dimension bSize = fb.getSize();\n@@ -119,1 +104,1 @@\n-        r.mousePress(MouseEvent.BUTTON1_DOWN_MASK);\n+        r.mousePress(MouseEvent.BUTTON1_MASK);\n@@ -137,1 +122,1 @@\n-        r.mouseRelease(MouseEvent.BUTTON1_DOWN_MASK);\n+        r.mouseRelease(MouseEvent.BUTTON1_MASK);\n","filename":"test\/jdk\/java\/awt\/event\/MouseWheelEvent\/WheelModifier\/WheelModifier.java","additions":9,"deletions":24,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -37,13 +37,2 @@\n- * @test id=specialized\n- * @run testng\/othervm\n- *  -Djdk.internal.foreign.DowncallLinker.USE_SPEC=true\n- *  --enable-native-access=ALL-UNNAMED\n- *  LibraryLookupTest\n- *\/\n-\n-\/*\n- * @test id=interpreted\n- * @run testng\/othervm\n- *   -Djdk.internal.foreign.DowncallLinker.USE_SPEC=false\n- *   --enable-native-access=ALL-UNNAMED\n- *   LibraryLookupTest\n+ * @test\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibraryLookupTest\n","filename":"test\/jdk\/java\/foreign\/LibraryLookupTest.java","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -25,13 +25,2 @@\n- * @test id=specialized\n- * @run testng\/othervm\n- *  -Djdk.internal.foreign.DowncallLinker.USE_SPEC=true\n- *  --enable-native-access=ALL-UNNAMED\n- *  SafeFunctionAccessTest\n- *\/\n-\n-\/*\n- * @test id=interpreted\n- * @run testng\/othervm\n- *   -Djdk.internal.foreign.DowncallLinker.USE_SPEC=false\n- *   --enable-native-access=ALL-UNNAMED\n- *   SafeFunctionAccessTest\n+ * @test\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED SafeFunctionAccessTest\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -72,0 +72,3 @@\n+import jdk.internal.foreign.HeapMemorySegmentImpl;\n+import jdk.internal.foreign.MappedMemorySegmentImpl;\n+import jdk.internal.foreign.NativeMemorySegmentImpl;\n@@ -987,3 +990,3 @@\n-        Predicate<MemorySegment> heapTest = segment -> !segment.isNative() && !segment.isMapped();\n-        Predicate<MemorySegment> nativeTest = segment -> segment.isNative() && !segment.isMapped();\n-        Predicate<MemorySegment> mappedTest = segment -> segment.isNative() && segment.isMapped();\n+        Predicate<MemorySegment> heapTest = segment -> segment instanceof HeapMemorySegmentImpl;\n+        Predicate<MemorySegment> nativeTest = segment -> segment instanceof NativeMemorySegmentImpl;\n+        Predicate<MemorySegment> mappedTest = segment -> segment instanceof MappedMemorySegmentImpl;\n@@ -1001,1 +1004,1 @@\n-                            mappedTest }\n+                            nativeTest \/* this seems to be an existing bug in the BB implementation *\/ }\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,101 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test id=Arena_allocateFrom\n- * @run main\/othervm\/timeout=5 --enable-native-access=ALL-UNNAMED -Xlog:class+init TestDeadlock Arena\n- *\/\n-\n-\/*\n- * @test id=FileChannel_map\n- * @run main\/othervm\/timeout=5 --enable-native-access=ALL-UNNAMED -Xlog:class+init TestDeadlock FileChannel\n- *\/\n-\n-import java.lang.foreign.*;\n-import java.io.IOException;\n-import java.nio.channels.FileChannel;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.StandardOpenOption;\n-import java.util.concurrent.CountDownLatch;\n-\n-public class TestDeadlock {\n-    public static void main(String[] args) throws Throwable {\n-        CountDownLatch latch = new CountDownLatch(2);\n-\n-        Runnable tester = switch (args[0]) {\n-            case \"Arena\" -> () -> {\n-                Arena arena = Arena.global();\n-                arena.scope(); \/\/ init ArenaImpl\n-                ValueLayout.JAVA_INT.byteSize(); \/\/ init ValueLayout (and impls)\n-                latch.countDown();\n-                try {\n-                    latch.await();\n-                } catch(InterruptedException e) {\n-                    throw new RuntimeException(e);\n-                }\n-\n-                \/\/ Access ArenaImpl -> NativeMemorySegmentImpl -> MemorySegment\n-                arena.allocateFrom(ValueLayout.JAVA_INT, 42);\n-            };\n-            case \"FileChannel\" -> () -> {\n-                try {\n-                    Arena arena = Arena.global();\n-                    Path p = Files.createFile(Path.of(\"test.out\"));\n-\n-                    try (FileChannel channel = FileChannel.open(p, StandardOpenOption.READ, StandardOpenOption.WRITE)) {\n-                        channel.map(FileChannel.MapMode.READ_WRITE, 0, 4); \/\/ create MappedByteBuffer to initialize other things\n-                        latch.countDown();\n-                        latch.await();\n-\n-                        \/\/ Access MappedMemorySegmentImpl -> MemorySegment\n-                        channel.map(FileChannel.MapMode.READ_WRITE, 0, 4, arena);\n-                    }\n-                } catch(InterruptedException | IOException e) {\n-                    throw new RuntimeException(e);\n-                }\n-            };\n-            default -> throw new IllegalArgumentException(\"Unknown test selection: \" + args[0]);\n-        };\n-\n-        Thread t1 = Thread.ofPlatform().start(tester);\n-        Thread t2 = Thread.ofPlatform().start(() -> {\n-            latch.countDown();\n-            try {\n-                latch.await();\n-            } catch(InterruptedException e) {\n-                throw new RuntimeException(e);\n-            }\n-\n-            \/\/ Access MemorySegment -> NativeMemorySegmentImpl\n-            MemorySegment.ofAddress(42);\n-        });\n-\n-        \/\/ wait for potential deadlock\n-\n-        t1.join();\n-        t2.join();\n-\n-        \/\/ all good\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestDeadlock.java","additions":0,"deletions":101,"binary":false,"changes":101,"status":"deleted"},{"patch":"@@ -37,1 +37,0 @@\n-import java.nio.ByteOrder;\n@@ -140,1 +139,1 @@\n-    public void testBadAlignmentOfRoot() {\n+    public void testBadAlignmentOfRoot() throws Throwable {\n@@ -151,1 +150,1 @@\n-            String expectedMessage = \"Target offset 0 is incompatible with alignment constraint \" + struct.byteAlignment() + \" (of [i4s2(x)]) for segment MemorySegment\";\n+            String expectedMessage = \"Target offset incompatible with alignment constraints: \" + struct.byteAlignment();\n@@ -157,1 +156,1 @@\n-            assertTrue(iae.getMessage().startsWith(expectedMessage));\n+            assertEquals(iae.getMessage(), expectedMessage);\n@@ -163,1 +162,1 @@\n-            assertTrue(iae.getMessage().startsWith(expectedMessage));\n+            assertEquals(iae.getMessage(), expectedMessage);\n@@ -167,36 +166,0 @@\n-    @Test\n-    public void testWrongTypeRoot() {\n-        MemoryLayout struct = MemoryLayout.structLayout(\n-                JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN),\n-                JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN)\n-        );\n-\n-        var expectedMessage = \"Bad layout path: attempting to select a sequence element from a non-sequence layout: [i4i4]\";\n-\n-        IllegalArgumentException iae = expectThrows(IllegalArgumentException.class, () ->\n-                struct.select(PathElement.sequenceElement()));\n-        assertEquals(iae.getMessage(), expectedMessage);\n-    }\n-\n-    @Test\n-    public void testWrongTypeEnclosing() {\n-        MemoryLayout struct = MemoryLayout.structLayout(\n-                MemoryLayout.sequenceLayout(2, MemoryLayout.structLayout(\n-                                JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN).withName(\"3a\"),\n-                                JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN).withName(\"3b\")\n-                        ).withName(\"2\")\n-                ).withName(\"1\")\n-        ).withName(\"0\");\n-\n-        var expectedMessage = \"Bad layout path: attempting to select a sequence element from a non-sequence layout: \" +\n-                \"[i4(3a)i4(3b)](2), selected from: \" +\n-                \"[2:[i4(3a)i4(3b)](2)](1), selected from: \" +\n-                \"[[2:[i4(3a)i4(3b)](2)](1)](0)\";\n-\n-        IllegalArgumentException iae = expectThrows(IllegalArgumentException.class, () ->\n-                struct.select(PathElement.groupElement(\"1\"),\n-                        PathElement.sequenceElement(),\n-                        PathElement.sequenceElement()));\n-        assertEquals(iae.getMessage(), expectedMessage);\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":4,"deletions":41,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.internal.foreign.NativeMemorySegmentImpl;\n@@ -241,1 +242,1 @@\n-                assertTrue(segment.isNative());\n+                assertEquals(segment.isNative(), segment instanceof NativeMemorySegmentImpl);\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,2 +25,0 @@\n-import java.io.IOException;\n-import java.io.RandomAccessFile;\n@@ -28,3 +26,0 @@\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.MemoryLayout;\n@@ -32,3 +27,0 @@\n-import java.lang.foreign.SegmentAllocator;\n-import java.lang.foreign.ValueLayout;\n-import java.lang.invoke.MethodHandle;\n@@ -36,1 +28,0 @@\n-import java.nio.channels.FileChannel;\n@@ -39,8 +30,0 @@\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Random;\n-import java.util.function.Consumer;\n-import java.util.function.UnaryOperator;\n@@ -48,1 +31,0 @@\n-import jdk.internal.foreign.StringSupport;\n@@ -50,2 +32,0 @@\n-\n-import static java.lang.foreign.ValueLayout.*;\n@@ -56,1 +36,0 @@\n- * @modules java.base\/jdk.internal.foreign\n@@ -63,1 +42,1 @@\n-    public void testStrings(String testString) {\n+    public void testStrings(String testString) throws ReflectiveOperationException {\n@@ -66,17 +45,2 @@\n-                for (Arena arena : arenas()) {\n-                    try (arena) {\n-                        MemorySegment text = arena.allocateFrom(testString, charset);\n-\n-                        int terminatorSize = \"\\0\".getBytes(charset).length;\n-                        if (charset == StandardCharsets.UTF_16) {\n-                            terminatorSize -= 2; \/\/ drop BOM\n-                        }\n-                        \/\/ Note that the JDK's UTF_32 encoder doesn't add a BOM.\n-                        \/\/ This is legal under the Unicode standard, and means the byte order is BE.\n-                        \/\/ See: https:\/\/unicode.org\/faq\/utf_bom.html#gen7\n-\n-                        int expectedByteLength =\n-                                testString.getBytes(charset).length +\n-                                        terminatorSize;\n-\n-                        assertEquals(text.byteSize(), expectedByteLength);\n+                try (Arena arena = Arena.ofConfined()) {\n+                    MemorySegment text = arena.allocateFrom(testString, charset);\n@@ -84,4 +48,3 @@\n-                        String roundTrip = text.getString(0, charset);\n-                        if (charset.newEncoder().canEncode(testString)) {\n-                            assertEquals(roundTrip, testString);\n-                        }\n+                    int terminatorSize = \"\\0\".getBytes(charset).length;\n+                    if (charset == StandardCharsets.UTF_16) {\n+                        terminatorSize -= 2; \/\/ drop BOM\n@@ -89,15 +52,3 @@\n-                }\n-            } else {\n-                assertThrows(IllegalArgumentException.class, () -> Arena.global().allocateFrom(testString, charset));\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"strings\")\n-    public void testStringsHeap(String testString) {\n-        for (Charset charset : singleByteCharsets()) {\n-            for (var arena : arenas()) {\n-                try (arena) {\n-                    MemorySegment text = arena.allocateFrom(testString, charset);\n-                    text = toHeapSegment(text);\n+                    \/\/ Note that the JDK's UTF_32 encoder doesn't add a BOM.\n+                    \/\/ This is legal under the Unicode standard, and means the byte order is BE.\n+                    \/\/ See: https:\/\/unicode.org\/faq\/utf_bom.html#gen7\n@@ -106,1 +57,2 @@\n-                            testString.getBytes(charset).length + 1;\n+                            testString.getBytes(charset).length +\n+                            terminatorSize;\n@@ -115,217 +67,2 @@\n-            }\n-        }\n-    }\n-\n-    MemorySegment toHeapSegment(MemorySegment segment) {\n-        var heapArray = segment.toArray(JAVA_BYTE);\n-        return MemorySegment.ofArray(heapArray);\n-    }\n-\n-    @Test(dataProvider = \"strings\")\n-    public void unboundedSegment(String testString) {\n-        testModifyingSegment(testString,\n-                standardCharsets(),\n-                s -> s.reinterpret(Long.MAX_VALUE),\n-                UnaryOperator.identity());\n-    }\n-\n-    @Test(dataProvider = \"strings\")\n-    public void unalignedSegmentSingleByte(String testString) {\n-        testModifyingSegment(testString,\n-                singleByteCharsets(),\n-                s -> s.byteSize() > 1 ? s.asSlice(1) : s,\n-                s -> s.length() > 0 ? s.substring(1) : s);\n-    }\n-\n-    @Test(dataProvider = \"strings\")\n-    public void expandedSegment(String testString) {\n-        try (var arena = Arena.ofConfined()) {\n-            for (int i = 0; i < Long.BYTES; i++) {\n-                int extra = i;\n-                testModifyingSegment(testString,\n-                        \/\/ Single byte charsets\n-                        standardCharsets(),\n-                        s -> {\n-                            var s2 = arena.allocate(s.byteSize() + extra);\n-                            MemorySegment.copy(s, 0, s2, 0, s.byteSize());\n-                            return s2;\n-                        },\n-                        UnaryOperator.identity());\n-            }\n-        }\n-    }\n-\n-    public void testModifyingSegment(String testString,\n-                                     List<Charset> charsets,\n-                                     UnaryOperator<MemorySegment> segmentMapper,\n-                                     UnaryOperator<String> stringMapper) {\n-        for (var charset : charsets) {\n-            try (Arena arena = Arena.ofConfined()) {\n-                MemorySegment text = arena.allocateFrom(testString, charset);\n-                text = segmentMapper.apply(text);\n-                String roundTrip = text.getString(0, charset);\n-                String expected = stringMapper.apply(testString);\n-                if (charset.newEncoder().canEncode(testString)) {\n-                    assertEquals(roundTrip, expected);\n-                }\n-            }\n-        }\n-    }\n-\n-    @Test()\n-    public void testPeculiarContentSingleByte() {\n-        Random random = new Random(42);\n-        for (int len = 7; len < 71; len++) {\n-            for (var arena : arenas()) {\n-                try (arena) {\n-                    var segment = arena.allocate(len, 1);\n-                    var arr = new byte[len];\n-                    random.nextBytes(arr);\n-                    segment.copyFrom(MemorySegment.ofArray(arr));\n-                    int terminatorIndex = random.nextInt(len);\n-                    segment.set(ValueLayout.JAVA_BYTE, terminatorIndex, (byte) 0);\n-                    for (Charset charset : singleByteCharsets()) {\n-                        var s = segment.getString(0, charset);\n-                        var ref = referenceImpl(segment, 0, charset);\n-                        assertEquals(s, ref);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"strings\")\n-    public void testOffset(String testString) {\n-        if (testString.length() < 3 || !containsOnlyRegularCharacters(testString)) {\n-            return;\n-        }\n-        for (var charset : singleByteCharsets()) {\n-            for (var arena: arenas()) {\n-                try (arena) {\n-                    MemorySegment inSegment = arena.allocateFrom(testString, charset);\n-                    for (int i = 0; i < 3; i++) {\n-                        String actual = inSegment.getString(i, charset);\n-                        assertEquals(actual, testString.substring(i));\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    private static final MemoryLayout CHAR_POINTER = ADDRESS\n-            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, JAVA_BYTE));\n-    private static final Linker LINKER = Linker.nativeLinker();\n-    private static final MethodHandle STRCAT = LINKER.downcallHandle(\n-            LINKER.defaultLookup().find(\"strcat\").orElseThrow(),\n-            FunctionDescriptor.of(CHAR_POINTER, CHAR_POINTER, CHAR_POINTER));\n-\n-    @Test(dataProvider = \"strings\")\n-    public void nativeSegFromNativeCall(String testString) {\n-        String addition = \"123\";\n-        try (var arena = Arena.ofConfined()) {\n-            try {\n-                var testStringSegment = arena.allocateFrom(testString);\n-                var additionSegment = arena.allocateFrom(addition);\n-                var destination = arena.allocate(testStringSegment.byteSize() + additionSegment.byteSize() - 1);\n-                destination.copyFrom(testStringSegment);\n-\n-                MemorySegment concatenation = (MemorySegment) STRCAT.invokeExact(destination, arena.allocateFrom(addition));\n-                var actual = concatenation.getString(0);\n-                assertEquals(actual, testString + addition);\n-            } catch (Throwable t) {\n-                throw new AssertionError(t);\n-            }\n-        }\n-    }\n-\n-    @Test\n-    public void segmentationFault() {\n-        for (int i = 1; i < 18; i++) {\n-            var size = 1 << i;\n-            try (var arena = Arena.ofConfined()) {\n-                var seg = arena.allocate(size, size);\n-                seg.fill((byte) 1);\n-                try {\n-                    var s = seg.getString(0);\n-                    System.out.println(\"s.length() = \" + s.length());\n-                } catch (IndexOutOfBoundsException e) {\n-                    \/\/ we will end up here if strlen finds a zero outside the MS\n-                }\n-            }\n-        }\n-    }\n-\n-    private static final int TEST_LENGTH_MAX = 277;\n-\n-    private Random deterministicRandom() {\n-        return new Random(42);\n-    }\n-\n-    @Test\n-    public void chunked_strlen_byte() {\n-        Random random = deterministicRandom();\n-        for (int skew = 0; skew < Long.BYTES; skew++) {\n-            for (int len = 0; len < TEST_LENGTH_MAX; len++) {\n-                try (var arena = Arena.ofConfined()) {\n-                    var segment = arena.allocate(len + 1 + skew)\n-                            .asSlice(skew);\n-                    for (int i = 0; i < len; i++) {\n-                        byte value;\n-                        while ((value = (byte) random.nextInt()) == 0) {\n-                        }\n-                        segment.setAtIndex(JAVA_BYTE, i, value);\n-                    }\n-                    segment.setAtIndex(JAVA_BYTE, len, (byte) 0);\n-                    for (int j = 0; j < len; j++) {\n-                        int actual = StringSupport.chunkedStrlenByte(segment, j);\n-                        assertEquals(actual, len - j);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    @Test\n-    public void chunked_strlen_short() {\n-        Random random = deterministicRandom();\n-        for (int skew = 0; skew < Long.BYTES; skew += Short.BYTES) {\n-            for (int len = 0; len < TEST_LENGTH_MAX; len++) {\n-                try (var arena = Arena.ofConfined()) {\n-                    var segment = arena.allocate((len + 1) * Short.BYTES + skew, JAVA_SHORT.byteAlignment())\n-                            .asSlice(skew);\n-                    for (int i = 0; i < len; i++) {\n-                        short value;\n-                        while ((value = (short) random.nextInt()) == 0) {\n-                        }\n-                        segment.setAtIndex(JAVA_SHORT, i, value);\n-                    }\n-                    segment.setAtIndex(JAVA_SHORT, len, (short) 0);\n-                    for (int j = 0; j < len; j++) {\n-                        int actual = StringSupport.chunkedStrlenShort(segment, j * Short.BYTES);\n-                        assertEquals(actual, (len - j) * Short.BYTES);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    @Test\n-    public void strlen_int() {\n-        Random random = deterministicRandom();\n-        for (int skew = 0; skew < Long.BYTES; skew += Integer.BYTES) {\n-            for (int len = 0; len < TEST_LENGTH_MAX; len++) {\n-                try (var arena = Arena.ofConfined()) {\n-                    var segment = arena.allocate((len + 1) * Integer.BYTES + skew, JAVA_INT.byteAlignment())\n-                            .asSlice(skew);\n-                    for (int i = 0; i < len; i++) {\n-                        int value;\n-                        while ((value = random.nextInt()) == 0) {\n-                        }\n-                        segment.setAtIndex(JAVA_INT, i, value);\n-                    }\n-                    segment.setAtIndex(JAVA_INT, len, 0);\n-                    for (int j = 0; j < len; j++) {\n-                        int actual = StringSupport.strlenInt(segment, j * Integer.BYTES);\n-                        assertEquals(actual, (len - j) * Integer.BYTES);\n-                    }\n-                }\n+            } else {\n+                assertThrows(IllegalArgumentException.class, () -> Arena.global().allocateFrom(testString, charset));\n@@ -338,18 +75,8 @@\n-        return new Object[][]{\n-                {\"testing\"},\n-                {\"\"},\n-                {\"X\"},\n-                {\"12345\"},\n-                {\"yen \\u00A5\"},\n-                {\"snowman \\u26C4\"},\n-                {\"rainbow \\uD83C\\uDF08\"},\n-                {\"0\"},\n-                {\"01\"},\n-                {\"012\"},\n-                {\"0123\"},\n-                {\"01234\"},\n-                {\"012345\"},\n-                {\"0123456\"},\n-                {\"01234567\"},\n-                {\"012345678\"},\n-                {\"0123456789\"}\n+        return new Object[][] {\n+            { \"testing\" },\n+            { \"\" },\n+            { \"X\" },\n+            { \"12345\" },\n+            { \"yen \\u00A5\" },\n+            { \"snowman \\u26C4\" },\n+            { \"rainbow \\uD83C\\uDF08\" }\n@@ -359,6 +86,1 @@\n-    public static boolean containsOnlyRegularCharacters(String s) {\n-        return s.chars()\n-                .allMatch(c -> Character.isLetterOrDigit((char) c));\n-    }\n-\n-    boolean isStandard(Charset charset) {\n+    boolean isStandard(Charset charset) throws ReflectiveOperationException {\n@@ -366,6 +88,2 @@\n-            try {\n-                if (standardCharset.get(null) == charset) {\n-                    return true;\n-                }\n-            } catch (ReflectiveOperationException e) {\n-                throw new AssertionError(e);\n+            if (standardCharset.get(null) == charset) {\n+                return true;\n@@ -376,83 +94,0 @@\n-\n-    List<Charset> standardCharsets() {\n-        return Charset.availableCharsets().values().stream()\n-                .filter(this::isStandard)\n-                .toList();\n-    }\n-\n-    List<Charset> singleByteCharsets() {\n-        return Arrays.asList(StandardCharsets.UTF_8, StandardCharsets.ISO_8859_1, StandardCharsets.US_ASCII);\n-    }\n-\n-    static String referenceImpl(MemorySegment segment, long offset, Charset charset) {\n-        long len = strlen_byte(segment, offset);\n-        byte[] bytes = new byte[(int) len];\n-        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, (int) len);\n-        return new String(bytes, charset);\n-    }\n-\n-    \/\/ Reference implementation\n-    private static int strlen_byte(MemorySegment segment, long start) {\n-        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n-        for (int offset = 0; offset >= 0; offset++) {\n-            byte curr = segment.get(JAVA_BYTE, start + offset);\n-            if (curr == 0) {\n-                return offset;\n-            }\n-        }\n-        throw new IllegalArgumentException(\"String too large\");\n-    }\n-\n-    private static List<Arena> arenas() {\n-        return Arrays.asList(\n-                Arena.ofConfined(),          \/\/ Native memory\n-                new HeapArena(byte.class),   \/\/ Heap memory backed by a byte array\n-                new HeapArena(short.class),  \/\/ Heap memory backed by a short array\n-                new HeapArena(int.class),    \/\/ Heap memory backed by an int array\n-                new HeapArena(long.class));  \/\/ Heap memory backed by a long array\n-    }\n-\n-    private static final class HeapArena implements Arena {\n-\n-        private static final int ELEMENT_SIZE = 1_000;\n-\n-        private final MemorySegment backingSegment;\n-        private final SegmentAllocator allocator;\n-\n-        public HeapArena(Class<?> type) {\n-            backingSegment = switch (type) {\n-                case Class<?> c when byte.class.equals(c) -> MemorySegment.ofArray(new byte[ELEMENT_SIZE]);\n-                case Class<?> c when short.class.equals(c) ->\n-                        MemorySegment.ofArray(new short[ELEMENT_SIZE]);\n-                case Class<?> c when int.class.equals(c) ->\n-                        MemorySegment.ofArray(new int[ELEMENT_SIZE]);\n-                case Class<?> c when long.class.equals(c) ->\n-                        MemorySegment.ofArray(new long[ELEMENT_SIZE]);\n-                default -> throw new IllegalArgumentException(type.toString());\n-            };\n-            allocator = SegmentAllocator.slicingAllocator(backingSegment);\n-        }\n-\n-        @Override\n-        public MemorySegment allocate(long byteSize, long byteAlignment) {\n-            return allocator.allocate(byteSize, byteAlignment);\n-        }\n-\n-        @Override\n-        public MemorySegment.Scope scope() {\n-            return backingSegment.scope();\n-        }\n-\n-        @Override\n-        public void close() {\n-            \/\/ Do nothing\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"HeapArena{\" +\n-                    \"type=\" + backingSegment.heapBase().orElseThrow().getClass().getName() +\n-                    '}';\n-        }\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestStringEncoding.java","additions":24,"deletions":389,"binary":false,"changes":413,"status":"modified"},{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.testng.annotations.*;\n-\n-import java.io.IOException;\n-import java.io.RandomAccessFile;\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemorySegment;\n-import java.nio.channels.FileChannel;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.function.Consumer;\n-\n-import static java.lang.foreign.ValueLayout.*;\n-import static org.testng.Assert.*;\n-\n-\/*\n- * @test\n- * @modules java.base\/jdk.internal.foreign\n- * @requires sun.arch.data.model == \"64\"\n- * @requires vm.flavor != \"zero\"\n- *\n- * @run testng\/othervm -Xmx6G TestStringEncodingJumbo\n- *\/\n-\n-public class TestStringEncodingJumbo {\n-\n-    @Test()\n-    public void testJumboSegment() {\n-        testWithJumboSegment(\"testJumboSegment\", segment -> {\n-            segment.fill((byte) 1);\n-            segment.set(JAVA_BYTE, Integer.MAX_VALUE + 10L, (byte) 0);\n-            String big = segment.getString(100);\n-            assertEquals(big.length(), Integer.MAX_VALUE - (100 - 10));\n-        });\n-    }\n-\n-    @Test()\n-    public void testStringLargerThanMaxInt() {\n-        testWithJumboSegment(\"testStringLargerThanMaxInt\", segment -> {\n-            segment.fill((byte) 1);\n-            segment.set(JAVA_BYTE, Integer.MAX_VALUE + 10L, (byte) 0);\n-            assertThrows(IllegalArgumentException.class, () -> {\n-                segment.getString(0);\n-            });\n-        });\n-    }\n-\n-    private static void testWithJumboSegment(String testName, Consumer<MemorySegment> tester) {\n-        Path path = Paths.get(\"mapped_file\");\n-        try {\n-            \/\/ Relly try to make sure the file is deleted after use\n-            path.toFile().deleteOnExit();\n-            deleteIfExistsOrThrow(path);\n-            try (RandomAccessFile raf = new RandomAccessFile(path.toFile(), \"rw\")) {\n-                FileChannel fc = raf.getChannel();\n-                try (Arena arena = Arena.ofConfined()) {\n-                    var segment = fc.map(FileChannel.MapMode.READ_WRITE, 0L, (long) Integer.MAX_VALUE + 100, arena);\n-                    tester.accept(segment);\n-                }\n-            }\n-        } catch (Exception e) {\n-            throw new AssertionError(e);\n-        } catch (OutOfMemoryError oome) {\n-            \/\/ Unfortunately, we run out of memory and cannot run this test in this configuration\n-            System.out.println(\"Skipping test because of insufficient memory: \" + testName);\n-        } finally {\n-            deleteIfExistsOrThrow(path);\n-        }\n-    }\n-\n-    private static void deleteIfExistsOrThrow(Path file) {\n-        try {\n-            Files.deleteIfExists(file);\n-        } catch (IOException ioe) {\n-            throw new AssertionError(\"Unable to delete mapped file: \" + file);\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/foreign\/TestStringEncodingJumbo.java","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -477,1 +477,0 @@\n-            var tracker = TRACKER.getTracker(client);\n@@ -486,0 +485,1 @@\n+                var tracker = TRACKER.getTracker(client);\n@@ -494,8 +494,0 @@\n-            } else {\n-                System.out.println(now() + \"waiting for operation to finish: \" + tracker.getName());\n-                System.err.println(now() + \"waiting for operation to finish: \" + tracker.getName());\n-                var error = TRACKER.checkFinished(tracker, 10000);\n-                if (error != null) throw error;\n-                System.out.println(now() + \"operation finished normally: \" + tracker.getName());\n-                System.err.println(now() + \"operation finished normally: \" + tracker.getName());\n-\n@@ -811,1 +803,1 @@\n-        AssertionError fail = TRACKER.check(5000);\n+        AssertionError fail = TRACKER.check(500);\n","filename":"test\/jdk\/java\/net\/httpclient\/AbstractThrowingSubscribers.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -118,8 +118,0 @@\n-    public AssertionError checkFinished(Tracker tracker, long graceDelayMs) {\n-        Predicate<Tracker> hasOperations = (t) -> t.getOutstandingOperations() > 0;\n-        Predicate<Tracker> hasSubscribers = (t) -> t.getOutstandingSubscribers() > 0;\n-        return check(tracker, graceDelayMs,\n-                hasOperations.or(hasSubscribers),\n-                \"outstanding operations or unreleased resources\", false);\n-    }\n-\n","filename":"test\/jdk\/java\/net\/httpclient\/ReferenceTracker.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -48,12 +48,0 @@\n-    private static final String FAT32_TYPE;\n-    static {\n-        if (Platform.isLinux())\n-            FAT32_TYPE = \"vfat\";\n-        else if (Platform.isOSX())\n-            FAT32_TYPE = \"msdos\";\n-        else if (Platform.isWindows())\n-            FAT32_TYPE = \"FAT32\";\n-        else\n-            FAT32_TYPE = \"unknown\";\n-    }\n-\n@@ -63,1 +51,0 @@\n-    private static boolean targetVolumeIsFAT32 = false;\n@@ -81,2 +68,0 @@\n-            targetVolumeIsFAT32 = fileStore2.type().equals(FAT32_TYPE);\n-\n@@ -116,1 +101,0 @@\n-            targetVolumeIsFAT32 = false;\n@@ -150,9 +134,4 @@\n-            long delta = Math.abs(Math.subtractExact(time1, time2));\n-\n-            \/\/ FAT32 volumes have a time stamp resolution of 2 seconds for\n-            \/\/ last modified time (write time)\n-            if ((delta != 0 && !targetVolumeIsFAT32) || delta > 2) {\n-                System.err.format(\"File time for %s is %s\\n\",\n-                                  attrs1.fileKey(), attrs1.lastModifiedTime());\n-                System.err.format(\"File time for %s is %s\\n\",\n-                                  attrs2.fileKey(), attrs2.lastModifiedTime());\n+\n+            if (time1 != time2) {\n+                System.err.format(\"File time for %s is %s\\n\", attrs1.fileKey(), attrs1.lastModifiedTime());\n+                System.err.format(\"File time for %s is %s\\n\", attrs2.fileKey(), attrs2.lastModifiedTime());\n","filename":"test\/jdk\/java\/nio\/file\/Files\/CopyAndMove.java","additions":4,"deletions":25,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @bug 8011536 8151430 8316304\n+ * @bug 8011536 8151430\n@@ -33,1 +33,0 @@\n-import java.lang.foreign.Linker;\n@@ -92,5 +91,0 @@\n-        } else if (Platform.isLinux()) {\n-            \/\/ Creation time read depends on statx system call support\n-            supportsCreationTimeRead = Linker.nativeLinker().defaultLookup().find(\"statx\").isPresent();\n-            \/\/ Creation time updates are not supported on Linux\n-            supportsCreationTimeWrite = false;\n@@ -98,1 +92,0 @@\n-        System.out.println(\"supportsCreationTimeRead == \" + supportsCreationTimeRead);\n","filename":"test\/jdk\/java\/nio\/file\/attribute\/BasicFileAttributeView\/CreationTime.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"filename":"test\/jdk\/java\/security\/KeyRep\/RSA.pre.1.5.key","binary":true,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2005, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4532506 8301126\n+ * @bug 4532506\n@@ -33,0 +33,1 @@\n+import java.security.*;\n@@ -42,7 +43,1 @@\n-        \/\/ verify pre-tiger keys still deserialize in our VM.\n-\n-        \/\/ There used to be a RSA test here, but the serialized file contained\n-        \/\/ classes introduced in JDK 5.0 (sun.security.rsa.RSA*).  The older\n-        \/\/ RSA keys from JDK 1.4.2 were of class JSA_* which were removed when\n-        \/\/ sun.security.rsa was introduced.  (See JDK-8301126 for more\n-        \/\/ details.)  The test\/data has been removed.\n+        \/\/ verify pre-tiger keys still deserialize in our VM\n@@ -51,0 +46,1 @@\n+        deserializeKey(\"RSA\");\n","filename":"test\/jdk\/java\/security\/KeyRep\/SerialOld.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,5 +27,1 @@\n- * @summary Confirm that DecimalFormat.parse() parses BigDecimal and BigInteger\n- *          string values as expected. Specifically, ensure a ParseException is\n- *          not thrown as well as the parsed value being numerically correct.\n- *          Tests large String values with combinations of multipliers and exponents.\n- * @run junit BigDecimalCompatibilityTest\n+ * @summary Confirm that DecimalFormat.parse() parses BigDecimal and BigInteger as expected.\n@@ -34,15 +30,3 @@\n-import java.math.BigDecimal;\n-import java.math.RoundingMode;\n-import java.text.DecimalFormat;\n-import java.util.ArrayList;\n-import java.util.Locale;\n-import java.util.stream.Stream;\n-\n-import org.junit.jupiter.api.AfterAll;\n-import org.junit.jupiter.api.BeforeAll;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.Arguments;\n-import org.junit.jupiter.params.provider.MethodSource;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import java.math.*;\n+import java.text.*;\n+import java.util.*;\n@@ -52,14 +36,1 @@\n-    private static DecimalFormat df = new DecimalFormat();\n-    \/\/ Save JVM default Locale\n-    private static final Locale savedLocale = Locale.getDefault();\n-\n-    \/\/ ---- Used for the test data (start) ----\n-\n-    \/\/ Both ArrayList composed of Arguments(String longString, int multiplier)\n-    private static final ArrayList<Arguments> bigIntegers = new ArrayList<Arguments>();\n-    private static final ArrayList<Arguments> bigDecimals = new ArrayList<Arguments>();\n-\n-    \/\/ Long string data to generate combinations of test values\n-    private static final String[] inputData = {\n-            \"0\".repeat(400),\n-            \"1234567890\".repeat(40)};\n+    static boolean err = false;\n@@ -67,3 +38,3 @@\n-    \/\/ Variety of exponents to test parse() against\n-    private static final String[] exponents = {\n-            \"E-100\", \"E100\", \"E-900\", \"E900\", \"\"\n+    static final String[] input_data = {\n+        \"0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n+        \"1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890\"\n@@ -71,4 +42,5 @@\n-\n-    \/\/ Variety of multipliers that DecimalFormat can apply\n-    private static final int[] multipliers = {\n-            -1, 1, -100, 100, -9999, 9999\n+    static final String[] exponents = {\n+        \"E-100\", \"E100\", \"E-900\", \"E900\", \"\"\n+    };\n+    static final int[] multipliers = {\n+        -1, 1, -100, 100, -9999, 9999\n@@ -76,1 +48,0 @@\n-    \/\/ ---- Used for the test data (end) ----\n@@ -78,3 +49,2 @@\n-    \/\/ Set JVM default Locale to US and populate the test arrayLists\n-    @BeforeAll\n-    static void initAll() {\n+    public static void main(String[] args) throws Exception {\n+        Locale loc = Locale.getDefault();\n@@ -82,1 +52,9 @@\n-        buildTestData();\n+\n+        testBigDecimal();\n+        testBigInteger();\n+\n+        Locale.setDefault(loc);\n+\n+        if (err) {\n+            throw new RuntimeException(\"Error: Unexpected value\");\n+        }\n@@ -85,21 +63,16 @@\n-    \/*\n-     * Uses inputData and exponents to build long string\n-     * decimal and integer values and populate bigDecimals and bigIntegers\n-     * accordingly. Attaches a multiplier value as well to the test data.\n-     *\/\n-    private static void buildTestData() {\n-        for (String longString1 : inputData) {\n-            for (String longString2 : inputData) {\n-                String bigInteger = longString1 + longString2;\n-                for (int multiplier : multipliers) {\n-                    bigIntegers.add(Arguments.of(bigInteger, multiplier));\n-                    bigIntegers.add(Arguments.of('-' + bigInteger, multiplier));\n-                }\n-                for (String longString3 : inputData) {\n-                    for (String longString4 : inputData) {\n-                        for (String exponent : exponents) {\n-                            String bigDecimal = longString1 + longString2 + '.'\n-                                    + longString3 + longString4 + exponent;\n-                            for (int multiplier : multipliers) {\n-                                bigDecimals.add(Arguments.of(bigDecimal, multiplier));\n-                                bigDecimals.add(Arguments.of('-' + bigDecimal, multiplier));\n+    static private void testBigDecimal() {\n+        DecimalFormat df = new DecimalFormat();\n+        df.setParseBigDecimal(true);\n+        df.setMaximumFractionDigits(Integer.MAX_VALUE);\n+\n+        for (int i = 0; i < input_data.length; i++) {\n+            for (int j = 0; j < input_data.length; j++) {\n+                for (int k = 0; k < input_data.length; k++) {\n+                    for (int l = 0; l < input_data.length; l++) {\n+                        for (int m = 0; m < exponents.length; m++) {\n+                            String s = input_data[i] + input_data[j] + '.' +\n+                                       input_data[k] + input_data[l] +\n+                                       exponents[m];\n+                            for (int n = 0; n < multipliers.length; n++) {\n+                                test(df, s, multipliers[n]);\n+                                test(df, '-'+s, multipliers[n]);\n@@ -114,25 +87,4 @@\n-    \/\/ Restore JVM default Locale\n-    @AfterAll\n-    static void tearDownAll() {\n-        Locale.setDefault(savedLocale);\n-    }\n-\n-    \/\/ Tests strings with length 1600+. See test() for specific details.\n-    @ParameterizedTest\n-    @MethodSource(\"bigDecimalProvider\")\n-    public void bigDecimalParseTest(String longString, int multiplier) {\n-        test(longString, multiplier);\n-    }\n-\n-    \/\/ Returns 960 arrangements of bigDecimal string values and multipliers\n-    \/\/ In the form of (String, int).\n-    private static Stream<Arguments> bigDecimalProvider() {\n-        return bigDecimals.stream();\n-    }\n-\n-    \/\/ Tests strings with length 800+. See test() for specific details.\n-    @ParameterizedTest\n-    @MethodSource(\"bigIntegerProvider\")\n-    public void bigIntegerParseTest(String longString, int multiplier) {\n-        test(longString, multiplier);\n-    }\n+    static private void testBigInteger() {\n+        DecimalFormat df = new DecimalFormat();\n+        df.setParseBigDecimal(true);\n+        df.setMaximumFractionDigits(Integer.MAX_VALUE);\n@@ -140,4 +92,9 @@\n-    \/\/ Returns 48 arrangements of bigInteger string values and multipliers\n-    \/\/ In the form of (String, int).\n-    private static Stream<Arguments> bigIntegerProvider() {\n-        return bigIntegers.stream();\n+        for (int i = 0; i < input_data.length; i++) {\n+            for (int j = 0; j < input_data.length; j++) {\n+                String s = input_data[i] + input_data[j];\n+                for (int k = 0; k < multipliers.length; k++) {\n+                    test(df, s, multipliers[k]);\n+                    test(df, '-'+s, multipliers[k]);\n+                }\n+            }\n+        }\n@@ -146,12 +103,1 @@\n-    \/*\n-     * Tests that parsing a large BigDecimal\/BigInteger string value\n-     * will not throw a ParseException with setParseBigDecimal as true.\n-     * Parses with a variety of multiplier values. Then ensures that the parsed\n-     * value is the expected number.\n-     *\/\n-    private static void test(String longString, int multiplier) {\n-        \/\/ Reset DecimalFormat for a clean test\n-        df = new DecimalFormat();\n-        df.setParseBigDecimal(true);\n-        \/\/ wide enough to support the long string test data\n-        df.setMaximumFractionDigits(Integer.MAX_VALUE);\n+    static void test(DecimalFormat df, String s, int multiplier) {\n@@ -160,7 +106,9 @@\n-        \/\/ Check parse and returned value. This was originally intended to ensure\n-        \/\/ a ParseException is not thrown\n-        Number parsedValue = assertDoesNotThrow(()-> df.parse(longString),\n-                \"Should not throw an Exception\");\n-        BigDecimal expectedValue = getExpected(longString, multiplier);\n-        assertEquals(expectedValue, parsedValue, \"With multiplier: \" + multiplier);\n-    }\n+        Number num = null;\n+        try {\n+            num = df.parse(s);\n+        }\n+        catch (ParseException e) {\n+            err = true;\n+            System.err.println(\"Failed: Exception occurred: \" + e.getMessage());\n+            return;\n+        }\n@@ -168,4 +116,1 @@\n-    \/\/ Utility to get a numerically correct value of a long string.\n-    \/\/ Dependent on BigDecimal implementation\n-    private static BigDecimal getExpected(String longString, int multiplier) {\n-        BigDecimal expected = new BigDecimal(longString);\n+        BigDecimal bd = new BigDecimal(s);\n@@ -173,1 +118,1 @@\n-            expected = expected.divide(new BigDecimal(multiplier));\n+           bd = bd.divide(new BigDecimal(multiplier));\n@@ -176,1 +121,11 @@\n-            expected = expected.divide(new BigDecimal(multiplier), RoundingMode.HALF_EVEN);\n+           bd = bd.divide(new BigDecimal(multiplier), RoundingMode.HALF_EVEN);\n+        }\n+        check(num, bd, multiplier);\n+    }\n+\n+    static void check(Number got, BigDecimal expected, int multiplier) {\n+        if (!got.equals(expected)) {\n+            err = true;\n+            System.err.println(\"Failed: got:\" + got +\n+                               \", expected: \" + expected +\n+                               \", multiplier=\" + multiplier);\n@@ -178,1 +133,0 @@\n-        return expected;\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/BigDecimalCompatibilityTest.java","additions":77,"deletions":123,"binary":false,"changes":200,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,3 +26,1 @@\n- * @summary Confirm that the decimal separator is shown when explicitly requested\n- *          (or not shown if not requested). Tests against double, long, BigDecimal,\n- *          and BigInteger with a combination of different patterns.\n+ * @summary Confirm that the decimal separator is shown when explicitly requested.\n@@ -30,1 +28,0 @@\n- * @run junit Bug4208135\n@@ -33,13 +30,3 @@\n-import java.math.BigDecimal;\n-import java.math.BigInteger;\n-import java.text.DecimalFormat;\n-import java.util.Locale;\n-import java.util.stream.Stream;\n-\n-import org.junit.jupiter.api.AfterAll;\n-import org.junit.jupiter.api.BeforeAll;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.Arguments;\n-import org.junit.jupiter.params.provider.MethodSource;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n+import java.math.*;\n+import java.text.*;\n+import java.util.*;\n@@ -49,69 +36,1 @@\n-    private static DecimalFormat df;\n-    \/\/ Save JVM default Locale\n-    private static final Locale savedLocale = Locale.getDefault();\n-\n-    \/\/ Set JVM default locale to US\n-    @BeforeAll\n-    static void init() {\n-        Locale.setDefault(Locale.US);\n-    }\n-\n-    \/\/ Restore JVM default locale\n-    @AfterAll\n-    static void tearDown() {\n-        Locale.setDefault(savedLocale);\n-    }\n-\n-    \/\/ Confirm that decimal separator shown when formatting a number\n-    @ParameterizedTest\n-    @MethodSource(\"fractionalDigitsWithSeparatorProvider\")\n-    public void fractionalDigitsWithSeparatorTest(Number num, String expected) {\n-        df = getDF(\"0.#E0\", true);\n-        String actualFormatted = df.format(num);\n-        assertEquals(expected, actualFormatted, getErrMsg(\"0.#E0\", true));\n-    }\n-\n-    \/\/ Combination of numbers and a fractional exponent pattern with a separator\n-    private static Stream<Arguments> fractionalDigitsWithSeparatorProvider() {\n-        return Stream.of(\n-                Arguments.of(0.0, \"0.E0\"),\n-                Arguments.of(10.0, \"1.E1\"),\n-                Arguments.of(1000.0, \"1.E3\"),\n-                Arguments.of(0L, \"0.E0\"),\n-                Arguments.of(10L, \"1.E1\"),\n-                Arguments.of(1000L, \"1.E3\"),\n-                Arguments.of(new BigDecimal(\"0.0\"), \"0.E0\"),\n-                Arguments.of(new BigDecimal(\"10.0\"), \"1.E1\"),\n-                Arguments.of(new BigDecimal(\"1000.0\"), \"1.E3\"),\n-                Arguments.of(new BigInteger(\"00\"), \"0.E0\"),\n-                Arguments.of(new BigInteger(\"10\"), \"1.E1\"),\n-                Arguments.of(new BigInteger(\"1000\"), \"1.E3\")\n-        );\n-    }\n-\n-    \/\/ Confirm that decimal separator not shown when formatting a number\n-    @ParameterizedTest\n-    @MethodSource(\"fractionalDigitsNoSeparatorProvider\")\n-    public void fractionalDigitsNoSeparatorTest(Number num, String expected) {\n-        df = getDF(\"0.#E0\", false);\n-        String actualFormatted = df.format(num);\n-        assertEquals(expected, actualFormatted, getErrMsg(\"0.#E0\", false));\n-    }\n-\n-    \/\/ Combination of numbers and a fractional exponent pattern with no separator\n-    private static Stream<Arguments> fractionalDigitsNoSeparatorProvider() {\n-        return Stream.of(\n-                Arguments.of(0.0, \"0E0\"),\n-                Arguments.of(10.0, \"1E1\"),\n-                Arguments.of(1000.0, \"1E3\"),\n-                Arguments.of(0L, \"0E0\"),\n-                Arguments.of(10L, \"1E1\"),\n-                Arguments.of(1000L, \"1E3\"),\n-                Arguments.of(new BigDecimal(\"0.0\"), \"0E0\"),\n-                Arguments.of(new BigDecimal(\"10.0\"), \"1E1\"),\n-                Arguments.of(new BigDecimal(\"1000.0\"), \"1E3\"),\n-                Arguments.of(new BigInteger(\"00\"), \"0E0\"),\n-                Arguments.of(new BigInteger(\"10\"), \"1E1\"),\n-                Arguments.of(new BigInteger(\"1000\"), \"1E3\")\n-        );\n-    }\n+    static DecimalFormat df;\n@@ -119,8 +38,1 @@\n-    \/\/ Confirm that decimal separator shown when formatting a number\n-    @ParameterizedTest\n-    @MethodSource(\"noFractionalDigitsWithSeparatorProvider\")\n-    public void noFractionalDigitsWithSeparatorTest(Number num, String expected) {\n-        df = getDF(\"0.###\", true);\n-        String actualFormatted = df.format(num);\n-        assertEquals(expected, actualFormatted, getErrMsg(\"0.###\", true));\n-    }\n+    static boolean err = false;\n@@ -128,17 +40,1 @@\n-    \/\/ Combination of numbers and a non-fractional exponent pattern with a separator\n-    private static Stream<Arguments> noFractionalDigitsWithSeparatorProvider() {\n-        return Stream.of(\n-                Arguments.of(0.0, \"0.\"),\n-                Arguments.of(10.0, \"10.\"),\n-                Arguments.of(1000.0, \"1000.\"),\n-                Arguments.of(0L, \"0.\"),\n-                Arguments.of(10L, \"10.\"),\n-                Arguments.of(1000L, \"1000.\"),\n-                Arguments.of(new BigDecimal(\"0.0\"), \"0.\"),\n-                Arguments.of(new BigDecimal(\"10.0\"), \"10.\"),\n-                Arguments.of(new BigDecimal(\"1000.0\"), \"1000.\"),\n-                Arguments.of(new BigInteger(\"00\"), \"0.\"),\n-                Arguments.of(new BigInteger(\"10\"), \"10.\"),\n-                Arguments.of(new BigInteger(\"1000\"), \"1000.\")\n-        );\n-    }\n+    static public void main(String[] args){\n@@ -146,26 +42,2 @@\n-    \/\/ Confirm that decimal separator not shown when formatting a number\n-    @ParameterizedTest\n-    @MethodSource(\"noFractionalDigitsNoSeparatorProvider\")\n-    public void noFractionalDigitsNoSeparatorTest(Number num, String expected) {\n-        df = getDF(\"0.###\", false);\n-        String actualFormatted = df.format(num);\n-        assertEquals(expected, actualFormatted, getErrMsg(\"0.###\", false));\n-    }\n-\n-    \/\/ Combination of numbers and a non-fractional exponent pattern with no separator\n-    private static Stream<Arguments> noFractionalDigitsNoSeparatorProvider() {\n-        return Stream.of(\n-                Arguments.of(0.0, \"0\"),\n-                Arguments.of(10.0, \"10\"),\n-                Arguments.of(1000.0, \"1000\"),\n-                Arguments.of(0L, \"0\"),\n-                Arguments.of(10L, \"10\"),\n-                Arguments.of(1000L, \"1000\"),\n-                Arguments.of(new BigDecimal(\"0.0\"), \"0\"),\n-                Arguments.of(new BigDecimal(\"10.0\"), \"10\"),\n-                Arguments.of(new BigDecimal(\"1000.0\"), \"1000\"),\n-                Arguments.of(new BigInteger(\"00\"), \"0\"),\n-                Arguments.of(new BigInteger(\"10\"), \"10\"),\n-                Arguments.of(new BigInteger(\"1000\"), \"1000\")\n-        );\n-    }\n+        Locale defaultLoc = Locale.getDefault();\n+        Locale.setDefault(Locale.US);\n@@ -173,2 +45,0 @@\n-    \/\/ Creates clean DF and sets the pattern and separatorShown value\n-    private static DecimalFormat getDF(String pattern, boolean separatorShown) {\n@@ -176,3 +46,66 @@\n-        df.applyPattern(pattern);\n-        df.setDecimalSeparatorAlwaysShown(separatorShown);\n-        return df;\n+\n+        df.applyPattern(\"0.#E0\");\n+\n+        df.setDecimalSeparatorAlwaysShown(true);\n+        checkFormat(0.0, \"0.E0\");\n+        checkFormat(10.0, \"1.E1\");\n+        checkFormat(1000.0, \"1.E3\");\n+        checkFormat(0L, \"0.E0\");\n+        checkFormat(10L, \"1.E1\");\n+        checkFormat(1000L, \"1.E3\");\n+        checkFormat(new BigDecimal(\"0.0\"), \"0.E0\");\n+        checkFormat(new BigDecimal(\"10.0\"), \"1.E1\");\n+        checkFormat(new BigDecimal(\"1000.0\"), \"1.E3\");\n+        checkFormat(new BigInteger(\"00\"), \"0.E0\");\n+        checkFormat(new BigInteger(\"10\"), \"1.E1\");\n+        checkFormat(new BigInteger(\"1000\"), \"1.E3\");\n+\n+        df.setDecimalSeparatorAlwaysShown(false);\n+        checkFormat(0.0, \"0E0\");\n+        checkFormat(10.0, \"1E1\");\n+        checkFormat(1000.0, \"1E3\");\n+        checkFormat(0L, \"0E0\");\n+        checkFormat(10L, \"1E1\");\n+        checkFormat(1000L, \"1E3\");\n+        checkFormat(new BigDecimal(\"0.0\"), \"0E0\");\n+        checkFormat(new BigDecimal(\"10.0\"), \"1E1\");\n+        checkFormat(new BigDecimal(\"1000.0\"), \"1E3\");\n+        checkFormat(new BigInteger(\"0\"), \"0E0\");\n+        checkFormat(new BigInteger(\"10\"), \"1E1\");\n+        checkFormat(new BigInteger(\"1000\"), \"1E3\");\n+\n+        df.applyPattern(\"0.###\");\n+\n+        df.setDecimalSeparatorAlwaysShown(true);\n+        checkFormat(0.0, \"0.\");\n+        checkFormat(10.0, \"10.\");\n+        checkFormat(1000.0, \"1000.\");\n+        checkFormat(0L, \"0.\");\n+        checkFormat(10L, \"10.\");\n+        checkFormat(1000L, \"1000.\");\n+        checkFormat(new BigDecimal(\"0.0\"), \"0.\");\n+        checkFormat(new BigDecimal(\"10.0\"), \"10.\");\n+        checkFormat(new BigDecimal(\"1000.0\"), \"1000.\");\n+        checkFormat(new BigInteger(\"0\"), \"0.\");\n+        checkFormat(new BigInteger(\"10\"), \"10.\");\n+        checkFormat(new BigInteger(\"1000\"), \"1000.\");\n+\n+        df.setDecimalSeparatorAlwaysShown(false);\n+        checkFormat(0.0, \"0\");\n+        checkFormat(10.0, \"10\");\n+        checkFormat(1000.0, \"1000\");\n+        checkFormat(0L, \"0\");\n+        checkFormat(10L, \"10\");\n+        checkFormat(1000L, \"1000\");\n+        checkFormat(new BigDecimal(\"0.0\"), \"0\");\n+        checkFormat(new BigDecimal(\"10.0\"), \"10\");\n+        checkFormat(new BigDecimal(\"1000.0\"), \"1000\");\n+        checkFormat(new BigInteger(\"0\"), \"0\");\n+        checkFormat(new BigInteger(\"10\"), \"10\");\n+        checkFormat(new BigInteger(\"1000\"), \"1000\");\n+\n+        Locale.setDefault(defaultLoc);\n+\n+        if (err) {\n+            throw new RuntimeException(\"Wrong format\/parse with DecimalFormat\");\n+        }\n@@ -181,4 +114,12 @@\n-    \/\/ Utility to get a helpful error message when values are not as expected\n-    private static String getErrMsg(String pattern, boolean separatorShown) {\n-        return String.format(\"Fails with pattern= %s, with separatorShown = %s\",\n-                pattern, separatorShown);\n+    static void checkFormat(Number num, String expected) {\n+        String got = df.format(num);\n+        if (!got.equals(expected)) {\n+            err = true;\n+            System.err.println(\"    DecimalFormat format(\" +\n+                               num.getClass().getName() +\n+                               \") error:\" +\n+                               \"\\n\\tnumber:           \" + num +\n+                               \"\\n\\tSeparatorShown? : \" + df.isDecimalSeparatorAlwaysShown() +\n+                               \"\\n\\tgot:              \" + got +\n+                               \"\\n\\texpected:         \" + expected);\n+        }\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/Bug4208135.java","additions":88,"deletions":147,"binary":false,"changes":235,"status":"modified"},{"patch":"@@ -27,3 +27,1 @@\n- * @summary Confirm that DecimalFormat can format a number with a negative\n- *          exponent number correctly. Tests also involve using a DecimalFormat\n- *          with a custom pattern or a custom minus sign.\n+ * @summary Confirm that DecimalFormat can format a number with negative exponent number correctly.\n@@ -33,6 +31,3 @@\n-import java.math.BigDecimal;\n-import java.math.BigInteger;\n-import java.text.DecimalFormat;\n-import java.text.DecimalFormatSymbols;\n-import java.util.Locale;\n-import java.util.stream.Stream;\n+import java.math.*;\n+import java.util.*;\n+import java.text.*;\n@@ -40,5 +35,1 @@\n-import org.junit.jupiter.api.AfterAll;\n-import org.junit.jupiter.api.BeforeAll;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.Arguments;\n-import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.api.Test;\n@@ -46,1 +37,0 @@\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -49,10 +39,0 @@\n-\/*\n- * This bug is about exponential formatting. But I added test cases for:\n- *   - Double and BigDecimal numbers which don't have exponent parts.\n- *   - Long and BigInteger numbers which don't support exponential\n- *     notation.\n- * because there are few test cases for suffix and prefix.\n- * And also, I added test cases to guarantee further formatting and\n- * parsing using the same DecimalFormat instance will not change the\n- * Number's value anymore.\n- *\/\n@@ -61,2 +41,3 @@\n-    \/\/ Save JVM default Locale\n-    private static final Locale savedLocale = Locale.getDefault();\n+    static DecimalFormat df;\n+    static DecimalFormatSymbols dfs;\n+    static boolean err = false;\n@@ -64,3 +45,2 @@\n-    \/\/ Set JVM default Locale to US\n-    @BeforeAll\n-    static void init() {\n+    static public void main(String[] args) {\n+        Locale defaultLoc = Locale.getDefault();\n@@ -68,1 +48,0 @@\n-    }\n@@ -70,4 +49,21 @@\n-    \/\/ Restore the original JVM default locale\n-    @AfterAll\n-    static void tearDown() {\n-        Locale.setDefault(savedLocale);\n+        \/**\n+         * This bug is about exponential formatting. But I added test cases for:\n+         *   - Double and BigDecimal numbers which don't have exponent parts.\n+         *   - Long and BigInteger numbers which don't support exponential\n+         *     notation.\n+         * because there are few test cases for suffix and prefix.\n+         * And also, I added test cases to guarantee further formatting and\n+         * parsing using the same DecimalFormat instance will not change the\n+         * Number's value anymore.\n+         *\/\n+\n+        test_double();\n+        test_long();\n+        test_BigDecimal();\n+        test_BigInteger();\n+\n+        Locale.setDefault(defaultLoc);\n+\n+        if (err) {\n+            throw new RuntimeException(\"Wrong format with DecimalFormat\");\n+        }\n@@ -76,5 +72,46 @@\n-    \/\/ Check that negative exponent number recognized for doubles\n-    @ParameterizedTest\n-    @MethodSource(\"doubles\")\n-    public void doubleTest(Number num, String str, DecimalFormat df) {\n-        test(num, str, df);\n+    static void test_double() {\n+        df = new DecimalFormat();\n+        dfs = df.getDecimalFormatSymbols();\n+\n+        \/* Test with default pattern *\/\n+        test(1234D,    \"1,234\");\n+        test(0.1234,  \"0.123\");     \/\/ rounded\n+        test(-1234D,   \"-1,234\");\n+        test(-0.1234, \"-0.123\");    \/\/ rounded\n+\n+        test(Double.POSITIVE_INFINITY, \"\\u221e\");\n+        test(Double.NEGATIVE_INFINITY, \"-\\u221e\");\n+        test(Double.NaN, \"\\ufffd\"); \/\/ without prefix and suffix\n+        test(0.0,  \"0\");\n+        test(-0.0, \"-0\");   \/\/ with the minus sign\n+\n+        \/* Specify a pattern and the minus sign. *\/\n+        prepareFormatter(\"<P>#.###E00<S>\", 'm');\n+        test(1234D,    \"<P>1.234E03<S>\");\n+        test(0.1234,  \"<P>1.234Em01<S>\");\n+        test(-1234D,   \"m<P>1.234E03<S>\");\n+        test(-0.1234, \"m<P>1.234Em01<S>\");\n+\n+        prepareFormatter(\"<P>#.###E00<S>;#.###E00\", 'm');\n+        test(1234D,    \"<P>1.234E03<S>\");\n+        test(0.1234,  \"<P>1.234Em01<S>\");\n+        test(-1234D,   \"1.234E03\");\n+        test(-0.1234, \"1.234Em01\");\n+\n+        prepareFormatter(\"#.###E00;<P>#.###E00<S>\", 'm');\n+        test(1234D,    \"1.234E03\");\n+        test(0.1234,  \"1.234Em01\");\n+        test(-1234D,   \"<P>1.234E03<S>\");\n+        test(-0.1234, \"<P>1.234Em01<S>\");\n+\n+        prepareFormatter(\"<P>#.###E00<S>;<p>-#.###E00<s>\", 'm');\n+        test(1234D,    \"<P>1.234E03<S>\");\n+        test(0.1234,  \"<P>1.234Em01<S>\");\n+        test(-1234D,   \"<p>m1.234E03<s>\");\n+        test(-0.1234, \"<p>m1.234Em01<s>\");\n+\n+        test(Double.POSITIVE_INFINITY, \"<P>\\u221e<S>\");\n+        test(Double.NEGATIVE_INFINITY, \"<p>m\\u221e<s>\");\n+        test(Double.NaN, \"\\ufffd\"); \/\/ without prefix and suffix\n+        test(0.0,  \"<P>0E00<S>\");\n+        test(-0.0, \"<p>m0E00<s>\");  \/\/ with the minus sign\n@@ -83,43 +120,30 @@\n-    \/\/ Provides a double to be formatted, which is compared to the expected String.\n-    \/\/ Additionally, provides a DecimalFormat to do the formatting (can have a custom\n-    \/\/ pattern and minus sign). Given in the form (double, String, DecimalFormat).\n-    private static Stream<Arguments> doubles() {\n-        DecimalFormat defaultDf = new DecimalFormat();\n-        DecimalFormat customDf1 = getDecimalFormat(\"<P>#.###E00<S>\", 'm');\n-        DecimalFormat customDf2 = getDecimalFormat(\"<P>#.###E00<S>;#.###E00\", 'm');\n-        DecimalFormat customDf3 = getDecimalFormat(\"#.###E00;<P>#.###E00<S>\", 'm');\n-        DecimalFormat customDf4 = getDecimalFormat(\"<P>#.###E00<S>;<p>-#.###E00<s>\", 'm');\n-        return Stream.of(\n-                \/\/ Test with default pattern\n-                Arguments.of(1234D,    \"1,234\", defaultDf),\n-                Arguments.of(0.1234,  \"0.123\", defaultDf),    \/\/ rounded\n-                Arguments.of(-1234D,   \"-1,234\", defaultDf),\n-                Arguments.of(-0.1234, \"-0.123\", defaultDf),    \/\/ rounded\n-                Arguments.of(Double.POSITIVE_INFINITY, \"\\u221e\", defaultDf),\n-                Arguments.of(Double.NEGATIVE_INFINITY, \"-\\u221e\", defaultDf),\n-                Arguments.of(Double.NaN, \"\\ufffd\", defaultDf), \/\/ without prefix and suffix\n-                Arguments.of(0.0,  \"0\", defaultDf),\n-                Arguments.of(-0.0, \"-0\", defaultDf),   \/\/ with the minus sign\n-                \/\/ Test with a pattern and the minus sign\n-                Arguments.of(1234D,    \"<P>1.234E03<S>\", customDf1),\n-                Arguments.of(0.1234,  \"<P>1.234Em01<S>\", customDf1),\n-                Arguments.of(-1234D,   \"m<P>1.234E03<S>\", customDf1),\n-                Arguments.of(-0.1234, \"m<P>1.234Em01<S>\", customDf1),\n-                Arguments.of(1234D,    \"<P>1.234E03<S>\", customDf2),\n-                Arguments.of(0.1234,  \"<P>1.234Em01<S>\", customDf2),\n-                Arguments.of(-1234D,   \"1.234E03\", customDf2),\n-                Arguments.of(-0.1234, \"1.234Em01\", customDf2),\n-                Arguments.of(1234D,    \"1.234E03\", customDf3),\n-                Arguments.of(0.1234,  \"1.234Em01\", customDf3),\n-                Arguments.of(-1234D,   \"<P>1.234E03<S>\", customDf3),\n-                Arguments.of(-0.1234, \"<P>1.234Em01<S>\", customDf3),\n-                Arguments.of(1234D,    \"<P>1.234E03<S>\", customDf4),\n-                Arguments.of(0.1234,  \"<P>1.234Em01<S>\", customDf4),\n-                Arguments.of(-1234D,   \"<p>m1.234E03<s>\", customDf4),\n-                Arguments.of(-0.1234, \"<p>m1.234Em01<s>\", customDf4),\n-                Arguments.of(Double.POSITIVE_INFINITY, \"<P>\\u221e<S>\", customDf4),\n-                Arguments.of(Double.NEGATIVE_INFINITY, \"<p>m\\u221e<s>\", customDf4),\n-                Arguments.of(Double.NaN, \"\\ufffd\", customDf4), \/\/ without prefix and suffix\n-                Arguments.of(0.0,  \"<P>0E00<S>\", customDf4),\n-                Arguments.of(-0.0, \"<p>m0E00<s>\", customDf4) \/\/ with the minus sign\n-        );\n+    static void test_BigDecimal() {\n+        df = new DecimalFormat();\n+        dfs = df.getDecimalFormatSymbols();\n+\n+        \/* Test with default pattern *\/\n+        test(new BigDecimal(\"123456789012345678901234567890\"),\n+             \"123,456,789,012,345,678,901,234,567,890\");\n+        test(new BigDecimal(\"0.000000000123456789012345678901234567890\"),\n+             \"0\");\n+        test(new BigDecimal(\"-123456789012345678901234567890\"),\n+             \"-123,456,789,012,345,678,901,234,567,890\");\n+        test(new BigDecimal(\"-0.000000000123456789012345678901234567890\"),\n+              \"-0\");\n+\n+        test(new BigDecimal(\"0\"), \"0\");\n+        test(new BigDecimal(\"-0\"), \"0\");\n+\n+        \/* Specify a pattern and the minus sign. *\/\n+        prepareFormatter(\"<P>#.####################E00<S>;<p>-#.####################E00<s>\", 'm');\n+        test(new BigDecimal(\"123456789012345678901234567890\"),\n+             \"<P>1.23456789012345678901E29<S>\");\n+        test(new BigDecimal(\"0.000000000123456789012345678901234567890\"),\n+             \"<P>1.23456789012345678901Em10<S>\");\n+        test(new BigDecimal(\"-123456789012345678901234567890\"),\n+             \"<p>m1.23456789012345678901E29<s>\");\n+        test(new BigDecimal(\"-0.000000000123456789012345678901234567890\"),\n+              \"<p>m1.23456789012345678901Em10<s>\");\n+\n+        test(new BigDecimal(\"0\"), \"<P>0E00<S>\");\n+        test(new BigDecimal(\"-0\"), \"<P>0E00<S>\");\n@@ -128,6 +152,3 @@\n-    \/\/ Check that negative exponent number recognized for longs\n-    @ParameterizedTest\n-    @MethodSource(\"longs\")\n-    public void longTest(Number num, String str, DecimalFormat df) {\n-        test(num, str, df);\n-    }\n+    static void test_long() {\n+        df = new DecimalFormat();\n+        dfs = df.getDecimalFormatSymbols();\n@@ -135,19 +156,3 @@\n-    \/\/ Same as doubles() data provider, but with long values\n-    \/\/ Given in the form (long, String, DecimalFormat).\n-    private static Stream<Arguments> longs() {\n-        DecimalFormat defaultDf = new DecimalFormat();\n-        DecimalFormat customDf = getDecimalFormat(\n-                \"<P>#,###<S>;<p>-#,###<s>\", 'm');\n-        return Stream.of(\n-                \/\/ Test with default pattern\n-                Arguments.of(123456789L,  \"123,456,789\", defaultDf),\n-                Arguments.of(-123456789L, \"-123,456,789\", defaultDf),\n-                Arguments.of(0L, \"0\", defaultDf),\n-                Arguments.of(-0L, \"0\", defaultDf),\n-                \/\/ Test with a pattern and the minus sign\n-                Arguments.of(123456789L,  \"<P>123,456,789<S>\", customDf),\n-                Arguments.of(-123456789L, \"<p>m123,456,789<s>\", customDf),\n-                Arguments.of(0L, \"<P>0<S>\", customDf),\n-                Arguments.of(-0L, \"<P>0<S>\", customDf)\n-        );\n-    }\n+        \/* Test with default pattern *\/\n+        test(123456789L,  \"123,456,789\");\n+        test(-123456789L, \"-123,456,789\");\n@@ -155,6 +160,7 @@\n-    \/\/ Check that negative exponent number recognized for bigDecimals\n-    @ParameterizedTest\n-    @MethodSource(\"bigDecimals\")\n-    public void bigDecimalTest(Number num, String str, DecimalFormat df) {\n-        test(num, str, df);\n-    }\n+        test(0L, \"0\");\n+        test(-0L, \"0\");\n+\n+        \/* Specify a pattern and the minus sign. *\/\n+        prepareFormatter(\"<P>#,###<S>;<p>-#,###<s>\", 'm');\n+        test(123456789L,  \"<P>123,456,789<S>\");\n+        test(-123456789L, \"<p>m123,456,789<s>\");\n@@ -162,30 +168,2 @@\n-    \/\/ Same as doubles() data provider, but with BigDecimal values\n-    \/\/ Given in the form (BigDecimal, String, DecimalFormat).\n-    private static Stream<Arguments> bigDecimals() {\n-        DecimalFormat defaultDf = new DecimalFormat();\n-        DecimalFormat customDf = getDecimalFormat(\n-                \"<P>#.####################E00<S>;<p>-#.####################E00<s>\", 'm');\n-        return Stream.of(\n-                \/\/ Test with default pattern\n-                Arguments.of(new BigDecimal(\"123456789012345678901234567890\"),\n-                        \"123,456,789,012,345,678,901,234,567,890\", defaultDf),\n-                Arguments.of(new BigDecimal(\"0.000000000123456789012345678901234567890\"),\n-                        \"0\", defaultDf),\n-                Arguments.of(new BigDecimal(\"-123456789012345678901234567890\"),\n-                        \"-123,456,789,012,345,678,901,234,567,890\", defaultDf),\n-                Arguments.of(new BigDecimal(\"-0.000000000123456789012345678901234567890\"),\n-                        \"-0\", defaultDf),\n-                Arguments.of(new BigDecimal(\"0\"), \"0\", defaultDf),\n-                Arguments.of(new BigDecimal(\"-0\"), \"0\", defaultDf),\n-                \/\/ Test with a pattern and the minus sign\n-                Arguments.of(new BigDecimal(\"123456789012345678901234567890\"),\n-                        \"<P>1.23456789012345678901E29<S>\", customDf),\n-                Arguments.of(new BigDecimal(\"0.000000000123456789012345678901234567890\"),\n-                        \"<P>1.23456789012345678901Em10<S>\", customDf),\n-                Arguments.of(new BigDecimal(\"-123456789012345678901234567890\"),\n-                        \"<p>m1.23456789012345678901E29<s>\", customDf),\n-                Arguments.of(new BigDecimal(\"-0.000000000123456789012345678901234567890\"),\n-                        \"<p>m1.23456789012345678901Em10<s>\", customDf),\n-                Arguments.of(new BigDecimal(\"0\"), \"<P>0E00<S>\", customDf),\n-                Arguments.of(new BigDecimal(\"-0\"), \"<P>0E00<S>\", customDf)\n-        );\n+        test(0L, \"<P>0<S>\");\n+        test(-0L, \"<P>0<S>\");\n@@ -194,5 +172,22 @@\n-    \/\/ Check that negative exponent number recognized for bigIntegers\n-    @ParameterizedTest\n-    @MethodSource(\"bigIntegers\")\n-    public void bigIntegerTest(Number num, String str, DecimalFormat df) {\n-        test(num, str, df);\n+    static void test_BigInteger() {\n+        df = new DecimalFormat();\n+        dfs = df.getDecimalFormatSymbols();\n+\n+        \/* Test with default pattern *\/\n+        test(new BigInteger(\"123456789012345678901234567890\"),\n+             \"123,456,789,012,345,678,901,234,567,890\");\n+        test(new BigInteger(\"-123456789012345678901234567890\"),\n+             \"-123,456,789,012,345,678,901,234,567,890\");\n+\n+        test(new BigInteger(\"0\"), \"0\");\n+        test(new BigInteger(\"-0\"), \"0\");\n+\n+        \/* Specify a pattern and the minus sign. *\/\n+        prepareFormatter(\"<P>#,###<S>;<p>-#,###<s>\", 'm');\n+        test(new BigInteger(\"123456789012345678901234567890\"),\n+             \"<P>123,456,789,012,345,678,901,234,567,890<S>\");\n+        test(new BigInteger(\"-123456789012345678901234567890\"),\n+             \"<p>m123,456,789,012,345,678,901,234,567,890<s>\");\n+\n+        test(new BigInteger(\"0\"), \"<P>0<S>\");\n+        test(new BigInteger(\"-0\"), \"<P>0<S>\");\n@@ -201,22 +196,5 @@\n-    \/\/ Same as doubles() data provider, but with BigInteger values\n-    \/\/ Given in the form (BigInteger, String, DecimalFormat).\n-    private static Stream<Arguments> bigIntegers() {\n-        DecimalFormat defaultDf = new DecimalFormat();\n-        DecimalFormat customDf = getDecimalFormat(\n-                \"<P>#,###<S>;<p>-#,###<s>\", 'm');\n-        return Stream.of(\n-                \/\/ Test with default pattern\n-                Arguments.of(new BigInteger(\"123456789012345678901234567890\"),\n-                        \"123,456,789,012,345,678,901,234,567,890\", defaultDf),\n-                Arguments.of(new BigInteger(\"-123456789012345678901234567890\"),\n-                        \"-123,456,789,012,345,678,901,234,567,890\", defaultDf),\n-                Arguments.of(new BigInteger(\"0\"), \"0\", defaultDf),\n-                Arguments.of(new BigInteger(\"-0\"), \"0\", defaultDf),\n-                \/\/ Test with a pattern and the minus sign\n-                Arguments.of(new BigInteger(\"123456789012345678901234567890\"),\n-                        \"<P>123,456,789,012,345,678,901,234,567,890<S>\", customDf),\n-                Arguments.of(new BigInteger(\"-123456789012345678901234567890\"),\n-                        \"<p>m123,456,789,012,345,678,901,234,567,890<s>\", customDf),\n-                Arguments.of(new BigInteger(\"0\"), \"<P>0<S>\", customDf),\n-                Arguments.of(new BigInteger(\"-0\"), \"<P>0<S>\", customDf)\n-        );\n+    static void prepareFormatter(String pattern, char minusSign) {\n+        dfs = df.getDecimalFormatSymbols();\n+        df.applyPattern(pattern);\n+        dfs.setMinusSign(minusSign);\n+        df.setDecimalFormatSymbols(dfs);\n@@ -225,3 +203,1 @@\n-    \/\/ Check that the formatted value is correct and also check that\n-    \/\/ it can be round-tripped via parse() and format()\n-    private static void test(Number num, String str, DecimalFormat df) {\n+    static void test(Number num, String str) {\n@@ -229,2 +205,10 @@\n-        assertEquals(str, formatted, String.format(\"DecimalFormat format(%s) \" +\n-                \"Error: number: %s, minus sign: %s\", num.getClass().getName(), num, df.getDecimalFormatSymbols().getMinusSign()));\n+        if (!formatted.equals(str)) {\n+            err = true;\n+            System.err.println(\"    DecimalFormat format(\" +\n+                               num.getClass().getName() +\n+                               \") error: \\n\\tnumber: \" + num +\n+                               \"\\n\\tminus sign: \" + dfs.getMinusSign() +\n+                               \"\\n\\tgot:        \" + formatted +\n+                               \"\\n\\texpected:   \" + str);\n+            return;\n+        }\n@@ -235,6 +219,0 @@\n-        testRoundTrip(formatted, str, num, df);\n-    }\n-\n-    \/\/ Test that a parsed value can be round-tripped via format() and parse()\n-    private static void testRoundTrip(String formatted, String str,\n-                                      Number num, DecimalFormat df) {\n@@ -246,11 +224,12 @@\n-            assertEquals(parsed2, parsed1, \"\"\"\n-                            DecimalFormat round trip parse(%s) error:\n-                                original number: %s\n-                                parsed number: %s\n-                                (%s)\n-                                formatted number: %s\n-                                re-parsed number: %s\n-                                (%s)\n-                                minus sign: %s\n-                            \"\"\".formatted(num.getClass().getName(), str, parsed1, parsed1.getClass().getName(),\n-                                    formatted, parsed2, parsed2.getClass().getName(), df.getDecimalFormatSymbols().getMinusSign()));\n+            if (!parsed1.equals(parsed2)) {\n+                err = true;\n+                System.err.println(\"    DecimalFormat roundtrip parse(\" +\n+                                   num.getClass().getName() +\n+                                   \") error: \\n\\toriginal number:  \" + str +\n+                                   \"\\n\\tparsed number:    \" + parsed1 +\n+                                   \"  (\" + parsed1.getClass().getName() + \")\" +\n+                                   \"\\n\\tformatted number: \" + formatted +\n+                                   \"\\n\\tre-parsed number: \" + parsed2 +\n+                                   \"  (\" + parsed2.getClass().getName() + \")\" +\n+                                   \"\\n\\tminus sign: \" + dfs.getMinusSign());\n+            }\n@@ -259,11 +238,11 @@\n-            fail(\"\"\"\n-                    DecimalFormat parse(%s) threw an Exception: %s\n-                        original number: %s\n-                        parsed number: %s\n-                        (%s)\n-                        formatted number: %s\n-                        re-parsed number: %s\n-                        (%s)\n-                        minus sign: %s\n-                    \"\"\".formatted(num.getClass().getName(), e.getMessage(), str, parsed1, parsed1.getClass().getName(),\n-                            formatted, parsed2, parsed2.getClass().getName(), df.getDecimalFormatSymbols().getMinusSign()));\n+            err = true;\n+            System.err.println(\"    DecimalFormat parse(\" +\n+                               num.getClass().getName() +\n+                               \") threw an Exception:  \" + e.getMessage() +\n+                               \"\\n\\toriginal number:  \" + str +\n+                               \"\\n\\tparsed number   : \" + parsed1 +\n+                               \"  (\" + parsed1.getClass().getName() + \")\" +\n+                               \"\\n\\tformatted number: \" + formatted +\n+                               \"\\n\\tre-parsed number: \" + parsed2 +\n+                               \"  (\" + parsed2.getClass().getName() + \")\" +\n+                               \"\\n\\tminus sign: \" + dfs.getMinusSign());\n@@ -272,10 +251,0 @@\n-\n-    \/\/ Set up custom DecimalFormat with DecimalFormatSymbols\n-    private static DecimalFormat getDecimalFormat(String pattern, char minusSign) {\n-        DecimalFormat df = new DecimalFormat();\n-        DecimalFormatSymbols dfs = df.getDecimalFormatSymbols();\n-        df.applyPattern(pattern);\n-        dfs.setMinusSign(minusSign);\n-        df.setDecimalFormatSymbols(dfs);\n-        return df;\n-    }\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/Bug4838107.java","additions":183,"deletions":214,"binary":false,"changes":397,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,1 @@\n- *          and which are between Long.MIN_VALUE and Long.MAX_VALUE are returned\n- *          as Long(not double).\n- * @run junit Bug4944439\n+ * and which are between Long.MIN_VALUE and Long.MAX_VALUE are returned as Long(not double).\n@@ -33,0 +31,2 @@\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n@@ -34,1 +34,0 @@\n-import java.util.ArrayList;\n@@ -36,11 +35,0 @@\n-import java.util.stream.Stream;\n-\n-import org.junit.jupiter.api.AfterAll;\n-import org.junit.jupiter.api.BeforeAll;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.Arguments;\n-import org.junit.jupiter.params.provider.MethodSource;\n-\n-import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertInstanceOf;\n@@ -50,3 +38,2 @@\n-    \/\/ Save JVM default locale\n-    private static final Locale savedLocale = Locale.getDefault();\n-    private static final DecimalFormat df = new DecimalFormat();\n+    static boolean err = false;\n+    static DecimalFormat df;\n@@ -54,3 +41,3 @@\n-    \/\/ Set JVM default locale to US for testing\n-    @BeforeAll\n-    static void initAll() {\n+    public static void main(String[] args) throws Exception {\n+\n+        Locale defaultLoc = Locale.getDefault();\n@@ -58,1 +45,0 @@\n-    }\n@@ -60,5 +46,3 @@\n-    \/\/ Restore JVM default locale\n-    @AfterAll\n-    static void tearDownAll() {\n-        Locale.setDefault(savedLocale);\n-    }\n+        df = new DecimalFormat();\n+        String s = \"-9223372036854775809\";      \/\/ Long.MIN_VALUE-1\n+        check_Double(s);\n@@ -66,14 +50,13 @@\n-    \/\/ Check return type and value returned by DecimalFormat.parse() for longs\n-    @ParameterizedTest\n-    @MethodSource(\"longs\")\n-    public void parseLongTest(String s) {\n-        \/\/ This was originally intended to ensure a ParseException is not thrown\n-        Number parsedNumber = assertDoesNotThrow(() -> df.parse(s),\n-                \"DecimalFormat.parse(\\\"%s\\\") should not throw an Exception\");\n-        assertInstanceOf(Long.class, parsedNumber,\n-                \"DecimalFormat.parse(\\\"%s\\\") did not return Long\");\n-        \/\/ Grab integer portion of value\n-        Long expectedVal = Long.valueOf(s.substring(0, s.indexOf('.')));\n-        assertEquals(parsedNumber, expectedVal,\n-                \"DecimalFormat.parse(\\\"%s\\\") returned numerically incorrect value\");\n-    }\n+        test(Long.MIN_VALUE, Long.MIN_VALUE+10);\n+        test(-10, 10);\n+        test(Long.MAX_VALUE-10, Long.MAX_VALUE-1);\n+\n+        s = \"9223372036854775807.00\";   \/\/ Long.MAX_VALUE\n+        check_Long(s);\n+        s = \"9223372036854775808\";      \/\/ Long.MAX_VALUE+1\n+        check_Double(s);\n+\n+        s = \"-0.0\";\n+        check_Double(s);\n+        s = \"0.0\";\n+        check_Long(s);\n@@ -81,9 +64,5 @@\n-    \/\/ Test some values between Long.MIN_VALUE and Long.MAX_VALUE\n-    private static Stream<String> longs() {\n-        ArrayList<String> longs = new ArrayList<>();\n-        addLongData(Long.MIN_VALUE, Long.MIN_VALUE+10, longs);\n-        addLongData(-10, 10, longs);\n-        addLongData(Long.MAX_VALUE-10, Long.MAX_VALUE-1, longs);\n-        longs.add(\"9223372036854775807.00\");\n-        longs.add(\"0.0\");\n-        return longs.stream();\n+        Locale.setDefault(defaultLoc);\n+\n+        if (err) {\n+            throw new RuntimeException(\"Wrong parsing with DecimalFormat\");\n+        }\n@@ -92,2 +71,1 @@\n-    \/\/ Utility to add values between parameters(long, to) to testLongs ArrayList\n-    private static void addLongData(long from, long to, ArrayList<String> testLongs){\n+    private static void test(long from, long to) throws Exception {\n@@ -95,1 +73,1 @@\n-            testLongs.add(l + \".00\");\n+            check_Long(Long.toString(l) + \".00\");\n@@ -99,12 +77,16 @@\n-    \/\/ Check return type and value returned by DecimalFormat.parse() for doubles\n-    @ParameterizedTest\n-    @MethodSource(\"doubles\")\n-    public void parseDoubleTest(String s) {\n-        \/\/ This was originally intended to ensure a ParseException is not thrown\n-        Number parsedNumber = assertDoesNotThrow(() -> df.parse(s),\n-                \"DecimalFormat.parse(\\\"%s\\\") should not throw an Exception\");\n-        assertInstanceOf(Double.class, parsedNumber,\n-                \"DecimalFormat.parse(\\\"%s\\\") did not return Double\");\n-        Double expectedVal = Double.valueOf(s);\n-        assertEquals(parsedNumber, expectedVal,\n-                \"DecimalFormat.parse(\\\"%s\\\") returned numerically incorrect value\");\n+    private static void check_Long(String s) throws Exception {\n+        Number number = df.parse(s);\n+        if (!(number instanceof Long)) {\n+            err = true;\n+            System.err.println(\"Failed: DecimalFormat.parse(\\\"\" + s +\n+                \"\\\") should return a Long, but returned a \" +\n+                number.getClass().getName());\n+        }\n+\n+        int index = s.indexOf('.');\n+        Long l = Long.valueOf(s.substring(0, index));\n+        if (!l.equals(number)) {\n+            err = true;\n+            System.err.println(\"Failed: DecimalFormat.parse(\" + s +\n+                \") should return a Long(\" + l + \"), but returned \" + number);\n+        }\n@@ -113,7 +95,15 @@\n-    \/\/ Check values not between Long.MIN_VALUE and Long.MAX_VALUE\n-    private static Stream<String> doubles() {\n-        return Stream.of(\n-                \"-9223372036854775809\", \/\/ Long.MIN_VALUE-1\n-                \"9223372036854775808\", \/\/ Long.MAX_VALUE+1\n-                \"-0.0\"\n-        );\n+    private static void check_Double(String s) throws Exception {\n+        Number number = df.parse(s);\n+        if (!(number instanceof Double)) {\n+            err = true;\n+            System.err.println(\"Failed: DecimalFormat.parse(\\\"\" + s +\n+                \"\\\") should return a Double, but returned a \" +\n+                number.getClass().getName());\n+        }\n+\n+        Double d = Double.valueOf(s);\n+        if (!d.equals(number)) {\n+            err = true;\n+            System.err.println(\"Failed: DecimalFormat.parse(\" + s +\n+                \") should return a Double(\" + d + \"), but returned \" + number);\n+        }\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/Bug4944439.java","additions":63,"deletions":73,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2016, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/*\n+\/**\n@@ -27,3 +27,1 @@\n- * @summary Make sure that any subclass of Number can be formatted using\n- *          DecimalFormat.format() without throwing an exception.\n- * @run junit Bug4990596\n+ * @summary Make sure that any subclass of Number can be formatted using DecimalFormat.format().\n@@ -34,4 +32,0 @@\n-import org.junit.jupiter.api.Test;\n-\n-import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n-\n@@ -40,6 +34,2 @@\n-    \/\/ Test that a custom subclass of Number can be formatted by\n-    \/\/ DecimalFormat without throwing an IllegalArgumentException\n-    @Test\n-    public void formatSubclassedNumberTest() {\n-        assertDoesNotThrow(() -> new DecimalFormat().format(new MutableInteger(0)),\n-                \"DecimalFormat.format() should support subclasses of Number\");\n+    public static void main(String[] args) {\n+        new DecimalFormat().format(new MutableInteger(0));\n@@ -48,2 +38,0 @@\n-    \/\/ A custom subclass of Number. Prior to this fix, if an instance of this\n-    \/\/ class was formatted by DecimalFormat, an exception would be thrown.\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/Bug4990596.java","additions":5,"deletions":17,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2016, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,0 @@\n- *          That is, make sure they are not treated as a double when formatted\n- *          anymore (which can result in the loss of precision).\n@@ -30,1 +28,0 @@\n- * @run junit Bug6278616\n@@ -37,5 +34,1 @@\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.Arguments;\n-import org.junit.jupiter.params.provider.MethodSource;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n+import java.util.Locale;\n@@ -45,1 +38,3 @@\n-    private static final NumberFormat nf = NumberFormat.getInstance();\n+    static final int[] ints = {\n+        Integer.MIN_VALUE, -1, 0, 1, Integer.MAX_VALUE\n+    };\n@@ -47,10 +42,3 @@\n-    \/\/ Test that NumberFormat formats numerically equivalent int\n-    \/\/ and AtomicInteger values the same\n-    @ParameterizedTest\n-    @MethodSource(\"ints\")\n-    public void formattedAtomicIntTest(int testInt) {\n-        String formattedInt = nf.format(testInt);\n-        String formattedAtomicInt = nf.format(new AtomicInteger(testInt));\n-        assertEquals(formattedAtomicInt, formattedInt, \"Formatting numerically\" +\n-                \" equivalent AtomicInteger and int should produce the same String value\");\n-    }\n+    static final long[] longs = {\n+        Long.MIN_VALUE, -1, 0, 1, Long.MAX_VALUE\n+    };\n@@ -58,4 +46,2 @@\n-    \/\/ Various int values\n-    private static int[] ints() {\n-        return new int[] { Integer.MIN_VALUE, -1, 0, 1, Integer.MAX_VALUE};\n-    }\n+    public static void main(String[] args) {\n+        NumberFormat nf = NumberFormat.getInstance();\n@@ -63,10 +49,9 @@\n-    \/\/ Test that NumberFormat formats numerically equivalent long\n-    \/\/ and AtomicLong values the same\n-    @ParameterizedTest\n-    @MethodSource(\"longs\")\n-    public void formattedAtomicLongTest(long testLong) {\n-        String formattedLong = nf.format(testLong);\n-        String formattedAtomicLong = nf.format(new AtomicLong(testLong));\n-        assertEquals(formattedAtomicLong, formattedLong, \"Formatting numerically\" +\n-                \" equivalent AtomicLong and long should produce the same String value\");\n-    }\n+        for (int j = 0; j < ints.length; j++) {\n+            String s_i = nf.format(ints[j]);\n+            String s_ai = nf.format(new AtomicInteger(ints[j]));\n+            if (!s_i.equals(s_ai)) {\n+                throw new RuntimeException(\"format(AtomicInteger \" + s_ai +\n+                                           \") doesn't equal format(Integer \" +\n+                                           s_i + \")\");\n+            }\n+        }\n@@ -74,3 +59,9 @@\n-    \/\/ Various long values\n-    private static long[] longs() {\n-        return new long[] { Long.MIN_VALUE, -1, 0, 1, Long.MAX_VALUE};\n+        for (int j = 0; j < longs.length; j++) {\n+            String s_l = nf.format(longs[j]);\n+            String s_al = nf.format(new AtomicLong(longs[j]));\n+            if (!s_l.equals(s_al)) {\n+                throw new RuntimeException(\"format(AtomicLong \" + s_al +\n+                                           \") doesn't equal format(Long \" +\n+                                           s_l + \")\");\n+            }\n+        }\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/Bug6278616.java","additions":28,"deletions":37,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @run junit Bug8132125\n@@ -32,6 +31,2 @@\n-import java.text.NumberFormat;\n-import java.util.Locale;\n-\n-import org.junit.jupiter.api.Test;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n+import java.text.*;\n+import java.util.*;\n@@ -40,4 +35,1 @@\n-\n-    \/\/ Ensure the CLDRConverter does not omit the Swiss number elements\n-    @Test\n-    public void swissNumElementsTest() {\n+    public static void main(String[] args) {\n@@ -47,2 +39,1 @@\n-        \/\/ \"\\u002E\" as decimal separator, \"\\u2019\" as grouping separator\n-        String expected = \"54\\u2019839\\u2019483.142\";\n+        String expected = \"54\\u2019839\\u2019483.142\"; \/\/ i.e. \"\\u2019\" as decimal separator, \"\\u2019\" as grouping separator\n@@ -50,1 +41,3 @@\n-        assertEquals(expected, actual, \"incorrect number elements for de_CH\");\n+        if (!actual.equals(expected)) {\n+            throw new RuntimeException(\"incorrect for de_CH: \" + expected + \" vs. actual \" + actual);\n+        }\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/Bug8132125.java","additions":8,"deletions":15,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- *          Tests both COMPAT and CLDR data.\n@@ -30,2 +29,2 @@\n- * @run junit\/othervm -Djava.locale.providers=COMPAT CurrencyFormat\n- * @run junit\/othervm -Djava.locale.providers=CLDR CurrencyFormat\n+ * @run main\/othervm -Djava.locale.providers=COMPAT CurrencyFormat COMPAT\n+ * @run main\/othervm -Djava.locale.providers=CLDR CurrencyFormat CLDR\n@@ -36,1 +35,0 @@\n-import java.io.IOException;\n@@ -39,2 +37,0 @@\n-import java.text.ParseException;\n-import java.util.ArrayList;\n@@ -49,7 +45,0 @@\n-import java.util.stream.Stream;\n-\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.Arguments;\n-import org.junit.jupiter.params.provider.MethodSource;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -59,4 +48,1 @@\n-    \/\/ Expected data is switched depending on COMPAT or CLDR\n-    \/\/ currencySymbolsTest() is only ran for COMPAT\n-    private static final boolean isCompat =\n-            \"COMPAT\".equals(System.getProperty(\"java.locale.providers\"));\n+    private static boolean isCompat;\n@@ -64,15 +50,4 @@\n-    \/\/ Tests the formatting of data for COMPAT + CLDR under various currencies\n-    \/\/ Using a NumberFormat generated by getCurrencyInstance()\n-    @ParameterizedTest\n-    @MethodSource(\"currencyFormatDataProvider\")\n-    public void currencyFormatTest(String expected, Currency currency,\n-                                   NumberFormat format, Locale locale) {\n-        if (currency != null) {\n-            format.setCurrency(currency);\n-            int digits = currency.getDefaultFractionDigits();\n-            format.setMinimumFractionDigits(digits);\n-            format.setMaximumFractionDigits(digits);\n-        }\n-        String result = format.format(1234.56);\n-        assertEquals(expected, result, String.format(\"Failed with locale: %s%s\",\n-                locale, (currency == null ? \", default currency\" : (\", currency: \" + currency))));\n+    public static void main(String[] args) throws Exception {\n+        isCompat = \"COMPAT\".equals(args[0]);\n+        testFormatting();\n+        testSymbols();\n@@ -81,4 +56,2 @@\n-    \/\/ Generate a combination of expected data for 1234.56 formatted\n-    \/\/ under various currencies\/locale provider\/locale\n-    private static Stream<Arguments> currencyFormatDataProvider() {\n-        ArrayList<Arguments> data = new ArrayList<Arguments>();\n+    static void testFormatting() {\n+        boolean failed = false;\n@@ -86,7 +59,7 @@\n-                Locale.US,\n-                Locale.JAPAN,\n-                Locale.GERMANY,\n-                Locale.ITALY,\n-                Locale.of(\"it\", \"IT\", \"EURO\"),\n-                Locale.forLanguageTag(\"de-AT\"),\n-                Locale.forLanguageTag(\"fr-CH\"),\n+            Locale.US,\n+            Locale.JAPAN,\n+            Locale.GERMANY,\n+            Locale.ITALY,\n+            Locale.of(\"it\", \"IT\", \"EURO\"),\n+            Locale.forLanguageTag(\"de-AT\"),\n+            Locale.forLanguageTag(\"fr-CH\"),\n@@ -95,5 +68,5 @@\n-                null,\n-                Currency.getInstance(\"USD\"),\n-                Currency.getInstance(\"JPY\"),\n-                Currency.getInstance(\"DEM\"),\n-                Currency.getInstance(\"EUR\"),\n+            null,\n+            Currency.getInstance(\"USD\"),\n+            Currency.getInstance(\"JPY\"),\n+            Currency.getInstance(\"DEM\"),\n+            Currency.getInstance(\"EUR\"),\n@@ -101,8 +74,8 @@\n-        String[][] expectedCOMPATData = {\n-                {\"$1,234.56\", \"$1,234.56\", \"JPY1,235\", \"DEM1,234.56\", \"EUR1,234.56\"},\n-                {\"\\uFFE51,235\", \"USD1,234.56\", \"\\uFFE51,235\", \"DEM1,234.56\", \"EUR1,234.56\"},\n-                {\"1.234,56 \\u20AC\", \"1.234,56 USD\", \"1.235 JPY\", \"1.234,56 DM\", \"1.234,56 \\u20AC\"},\n-                {\"\\u20AC 1.234,56\", \"USD 1.234,56\", \"JPY 1.235\", \"DEM 1.234,56\", \"\\u20AC 1.234,56\"},\n-                {\"\\u20AC 1.234,56\", \"USD 1.234,56\", \"JPY 1.235\", \"DEM 1.234,56\", \"\\u20AC 1.234,56\"},\n-                {\"\\u20AC 1.234,56\", \"USD 1.234,56\", \"JPY 1.235\", \"DEM 1.234,56\", \"\\u20AC 1.234,56\"},\n-                {\"SFr. 1'234.56\", \"USD 1'234.56\", \"JPY 1'235\", \"DEM 1'234.56\", \"EUR 1'234.56\"},\n+        String[][] expecteds = {\n+            {\"$1,234.56\", \"$1,234.56\", \"JPY1,235\", \"DEM1,234.56\", \"EUR1,234.56\"},\n+            {\"\\uFFE51,235\", \"USD1,234.56\", \"\\uFFE51,235\", \"DEM1,234.56\", \"EUR1,234.56\"},\n+            {\"1.234,56 \\u20AC\", \"1.234,56 USD\", \"1.235 JPY\", \"1.234,56 DM\", \"1.234,56 \\u20AC\"},\n+            {\"\\u20AC 1.234,56\", \"USD 1.234,56\", \"JPY 1.235\", \"DEM 1.234,56\", \"\\u20AC 1.234,56\"},\n+            {\"\\u20AC 1.234,56\", \"USD 1.234,56\", \"JPY 1.235\", \"DEM 1.234,56\", \"\\u20AC 1.234,56\"},\n+            {\"\\u20AC 1.234,56\", \"USD 1.234,56\", \"JPY 1.235\", \"DEM 1.234,56\", \"\\u20AC 1.234,56\"},\n+            {\"SFr. 1'234.56\", \"USD 1'234.56\", \"JPY 1'235\", \"DEM 1'234.56\", \"EUR 1'234.56\"},\n@@ -110,8 +83,8 @@\n-        String[][] expectedCLDRData = {\n-                {\"$1,234.56\", \"$1,234.56\", \"\\u00a51,235\", \"DEM1,234.56\", \"\\u20ac1,234.56\"},\n-                {\"\\uFFE51,235\", \"$1,234.56\", \"\\uFFE51,235\", \"DEM1,234.56\", \"\\u20ac1,234.56\"},\n-                {\"1.234,56\\u00a0\\u20ac\", \"1.234,56\\u00a0$\", \"1.235\\u00a0\\u00a5\", \"1.234,56\\u00a0DM\", \"1.234,56\\u00a0\\u20ac\"},\n-                {\"1.234,56\\u00a0\\u20ac\", \"1.234,56\\u00a0USD\", \"1.235\\u00a0JPY\", \"1.234,56\\u00a0DEM\", \"1.234,56\\u00a0\\u20ac\"},\n-                {\"1.234,56\\u00a0\\u20ac\", \"1.234,56\\u00a0USD\", \"1.235\\u00a0JPY\", \"1.234,56\\u00a0DEM\", \"1.234,56\\u00a0\\u20ac\"},\n-                {\"\\u20ac\\u00a01.234,56\", \"$\\u00a01.234,56\", \"\\u00a5\\u00a01.235\", \"DM\\u00a01.234,56\", \"\\u20ac\\u00a01.234,56\"},\n-                {\"1\\u202f234.56\\u00a0CHF\", \"1\\u202f234.56\\u00a0$US\", \"1\\u202f235\\u00a0JPY\", \"1\\u202f234.56\\u00a0DEM\", \"1\\u202f234.56\\u00a0\\u20ac\"},\n+        String[][] expecteds_cldr = {\n+            {\"$1,234.56\", \"$1,234.56\", \"\\u00a51,235\", \"DEM1,234.56\", \"\\u20ac1,234.56\"},\n+            {\"\\uFFE51,235\", \"$1,234.56\", \"\\uFFE51,235\", \"DEM1,234.56\", \"\\u20ac1,234.56\"},\n+            {\"1.234,56\\u00a0\\u20ac\", \"1.234,56\\u00a0$\", \"1.235\\u00a0\\u00a5\", \"1.234,56\\u00a0DM\", \"1.234,56\\u00a0\\u20ac\"},\n+            {\"1.234,56\\u00a0\\u20ac\", \"1.234,56\\u00a0USD\", \"1.235\\u00a0JPY\", \"1.234,56\\u00a0DEM\", \"1.234,56\\u00a0\\u20ac\"},\n+            {\"1.234,56\\u00a0\\u20ac\", \"1.234,56\\u00a0USD\", \"1.235\\u00a0JPY\", \"1.234,56\\u00a0DEM\", \"1.234,56\\u00a0\\u20ac\"},\n+            {\"\\u20ac\\u00a01.234,56\", \"$\\u00a01.234,56\", \"\\u00a5\\u00a01.235\", \"DM\\u00a01.234,56\", \"\\u20ac\\u00a01.234,56\"},\n+            {\"1\\u202f234.56\\u00a0CHF\", \"1\\u202f234.56\\u00a0$US\", \"1\\u202f235\\u00a0JPY\", \"1\\u202f234.56\\u00a0DEM\", \"1\\u202f234.56\\u00a0\\u20ac\"},\n@@ -119,0 +92,1 @@\n+\n@@ -124,2 +98,15 @@\n-                String expected = isCompat ? expectedCOMPATData[i][j] : expectedCLDRData[i][j];\n-                data.add(Arguments.of(expected, currency, format, locale));\n+                String expected = isCompat ? expecteds[i][j] : expecteds_cldr[i][j];\n+                if (currency != null) {\n+                    format.setCurrency(currency);\n+                    int digits = currency.getDefaultFractionDigits();\n+                    format.setMinimumFractionDigits(digits);\n+                    format.setMaximumFractionDigits(digits);\n+                }\n+                String result = format.format(1234.56);\n+                if (!result.equals(expected)) {\n+                    failed = true;\n+                    System.out.println(\"FAIL: Locale \" + locale\n+                        + (currency == null ? \", default currency\" : (\", currency: \" + currency))\n+                        + \", expected: \" + expected\n+                        + \", actual: \" + result);\n+                }\n@@ -128,1 +115,4 @@\n-        return data.stream();\n+\n+        if (failed) {\n+            throw new RuntimeException();\n+        }\n@@ -131,5 +121,1 @@\n-    \/\/ Compares the expected currency symbol of a locale to the value returned by\n-    \/\/ DecimalFormatSymbols.getCurrencySymbol().\n-    @ParameterizedTest\n-    @MethodSource(\"currencySymbolsDataProvider\")\n-    public void currencySymbolsTest(String expected, Locale locale) throws ParseException {\n+    static void testSymbols() throws Exception {\n@@ -137,1 +123,2 @@\n-            return; \/\/ For COMPAT only.\n+            \/\/ For COMPAT only.\n+            return;\n@@ -139,13 +126,0 @@\n-        if (expected == null) {\n-            System.out.println(\"Warning: No expected currency symbol defined for locale \" + locale);\n-        } else {\n-            \/\/ Reserved for when a currency will change its symbol at a given time in the future\n-            if (expected.contains(\";\")) {\n-                expected = getFutureSymbol(expected);\n-            }\n-            DecimalFormatSymbols symbols = DecimalFormatSymbols.getInstance(locale);\n-            String result = symbols.getCurrencySymbol();\n-            assertEquals(expected, result, \"Wrong currency symbol for locale \" +\n-                        locale + \", expected: \" + expected + \", got: \" + result);\n-        }\n-    }\n@@ -153,6 +127,1 @@\n-    \/\/ Grabs the custom CurrencySymbols.properties and loads the file into a Properties\n-    \/\/ instance. Building the data set, which consists of the currency symbol for the locale.\n-    private static Stream<Arguments> currencySymbolsDataProvider() throws IOException {\n-        ArrayList<Arguments> data = new ArrayList<Arguments>();\n-        FileInputStream stream = new FileInputStream(new File(\n-                System.getProperty(\"test.src\", \".\"), \"CurrencySymbols.properties\"));\n+        FileInputStream stream = new FileInputStream(new File(System.getProperty(\"test.src\", \".\"), \"CurrencySymbols.properties\"));\n@@ -162,0 +131,2 @@\n+        SimpleDateFormat format = null;\n+\n@@ -163,1 +134,4 @@\n-        for (Locale locale : locales) {\n+        for (int i = 0; i < locales.length; i++) {\n+            Locale locale = locales[i];\n+            DecimalFormatSymbols symbols = DecimalFormatSymbols.getInstance(locale);\n+            String result = symbols.getCurrencySymbol();\n@@ -165,4 +139,0 @@\n-            data.add(Arguments.of(expected, locale));\n-        }\n-        return data.stream();\n-    }\n@@ -170,11 +140,25 @@\n-    \/\/ Utility to grab the future symbol if in the right format and date cut-over allows\n-    private static String getFutureSymbol(String expected) throws ParseException {\n-        StringTokenizer tokens = new StringTokenizer(expected, \";\");\n-        int tokensCount = tokens.countTokens();\n-        if (tokensCount == 3) {\n-            expected = tokens.nextToken();\n-            SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd-HH-mm-ss\", Locale.US);\n-            format.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n-            format.setLenient(false);\n-            if (format.parse(tokens.nextToken()).getTime() < System.currentTimeMillis()) {\n-                expected = tokens.nextToken();\n+            if (expected == null) {\n+                System.out.println(\"Warning: No expected currency symbol defined for locale \" + locale);\n+            } else {\n+                    if (expected.contains(\";\")) {\n+                        StringTokenizer tokens = new StringTokenizer(expected, \";\");\n+                        int tokensCount = tokens.countTokens();\n+\n+                        if (tokensCount == 3) {\n+                            expected = tokens.nextToken();\n+                            if (format == null) {\n+                                format = new SimpleDateFormat(\"yyyy-MM-dd-HH-mm-ss\", Locale.US);\n+                                format.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+                                format.setLenient(false);\n+                            }\n+\n+                            if (format.parse(tokens.nextToken()).getTime() < System.currentTimeMillis()) {\n+                                expected = tokens.nextToken();\n+                            }\n+                        }\n+                    }\n+\n+                    if (!expected.equals(result)) {\n+                        throw new RuntimeException(\"Wrong currency symbol for locale \" +\n+                            locale + \", expected: \" + expected + \", got: \" + result);\n+                    }\n@@ -183,1 +167,0 @@\n-        return expected;\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/CurrencyFormat.java","additions":92,"deletions":109,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/*\n+\/**\n@@ -27,0 +27,1 @@\n+ * @summary Currency decimal marker incorrect for Peru.\n@@ -28,2 +29,1 @@\n- * @summary Currency decimal marker incorrect for Peru (COMPAT).\n- * @run junit\/othervm -Djava.locale.providers=COMPAT TestPeruCurrencyFormat\n+ * @run main\/othervm -Djava.locale.providers=JRE TestPeruCurrencyFormat\n@@ -35,4 +35,0 @@\n-import org.junit.jupiter.api.Test;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-\n@@ -41,3 +37,1 @@\n-    \/\/ Confirm correct decimal marker for Peru locale on COMPAT\n-    @Test\n-    public void peruDecimalMarketCOMPAT() {\n+    public static void main(String[] args) {\n@@ -48,2 +42,4 @@\n-        assertEquals(expected, s,\n-                \"Currency format for Peru failed, expected \" + expected + \", got \" + s);\n+\n+        if (!s.equals(expected)) {\n+            throw new RuntimeException(\"Currency format for Peru failed, expected \" + expected + \", got \" + s);\n+        }\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/TestPeruCurrencyFormat.java","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * @ignore 8303920 This test has brittle dependencies on an external working python.\n+ * @ignore This test has brittle dependencies on an external working python.\n","filename":"test\/jdk\/java\/util\/zip\/DataDescriptorSignatureMissing.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -355,40 +355,0 @@\n-\/*\n- * @test id=affirmtrustcommercialca\n- * @bug 8040012\n- * @summary Interoperability tests with AffirmTrust Commercial CA\n- * @library \/test\/lib\n- * @build jtreg.SkippedException ValidatePathWithURL CAInterop\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop affirmtrustcommercialca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop affirmtrustcommercialca CRL\n- *\/\n-\n-\/*\n- * @test id=affirmtrustnetworkingca\n- * @bug 8040012\n- * @summary Interoperability tests with AffirmTrust Networking CA\n- * @library \/test\/lib\n- * @build jtreg.SkippedException ValidatePathWithURL CAInterop\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop affirmtrustnetworkingca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop affirmtrustnetworkingca CRL\n- *\/\n-\n-\/*\n- * @test id=affirmtrustpremiumca\n- * @bug 8040012\n- * @summary Interoperability tests with AffirmTrust Premium CA\n- * @library \/test\/lib\n- * @build jtreg.SkippedException ValidatePathWithURL CAInterop\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop affirmtrustpremiumca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop affirmtrustpremiumca CRL\n- *\/\n-\n-\/*\n- * @test id=affirmtrustpremiumeccca\n- * @bug 8040012\n- * @summary Interoperability tests with AffirmTrust Premium ECC CA\n- * @library \/test\/lib\n- * @build jtreg.SkippedException ValidatePathWithURL CAInterop\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop affirmtrustpremiumeccca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop affirmtrustpremiumeccca CRL\n- *\/\n-\n@@ -522,14 +482,0 @@\n-            \/\/ These are listed at https:\/\/www.affirmtrust.com\/resources\/\n-            case \"affirmtrustcommercialca\" ->\n-                    new CATestURLs(\"https:\/\/validcommercial.affirmtrust.com\",\n-                            \"https:\/\/revokedcommercial.affirmtrust.com\");\n-            case \"affirmtrustnetworkingca\" ->\n-                    new CATestURLs(\"https:\/\/validnetworking.affirmtrust.com\",\n-                            \"https:\/\/revokednetworking.affirmtrust.com\");\n-            case \"affirmtrustpremiumca\" ->\n-                    new CATestURLs(\"https:\/\/validpremium.affirmtrust.com\",\n-                            \"https:\/\/revokedpremium.affirmtrust.com\");\n-            case \"affirmtrustpremiumeccca\" ->\n-                    new CATestURLs(\"https:\/\/validpremiumecc.affirmtrust.com\",\n-                            \"https:\/\/revokedpremiumecc.affirmtrust.com\");\n-\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/CAInterop.java","additions":0,"deletions":54,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -311,1 +311,2 @@\n-            ProcessBuilder pb = ProcessTools.createTestJvm(\n+            String classPath = System.getProperty(\"test.classes\");\n+            ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n@@ -313,1 +314,1 @@\n-                className, mainArgsIdentifier);\n+                \"-cp\", classPath, className, mainArgsIdentifier);\n","filename":"test\/jdk\/sun\/jvmstat\/monitor\/MonitoredVm\/MonitorVmStartTerminate.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -50,2 +50,0 @@\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n@@ -54,0 +52,1 @@\n+\n@@ -87,4 +86,0 @@\n-\n-        public void putAll(Map<String, String> map) {\n-            map.entrySet().forEach(e -> put(e.getKey(), () -> e.getValue()));\n-        }\n@@ -143,1 +138,0 @@\n-        map.putAll(xOptFlags()); \/\/ -Xmx4g -> @requires vm.opt.x.Xmx == \"4g\" )\n@@ -671,1 +665,3 @@\n-        List<String> allFlags = allFlags().toList();\n+        List<String> allFlags = new ArrayList<String>();\n+        Collections.addAll(allFlags, System.getProperty(\"test.vm.opts\", \"\").trim().split(\"\\\\s+\"));\n+        Collections.addAll(allFlags, System.getProperty(\"test.java.opts\", \"\").trim().split(\"\\\\s+\"));\n@@ -718,25 +714,0 @@\n-    private Stream<String> allFlags() {\n-        return Stream.of((System.getProperty(\"test.vm.opts\", \"\") + \" \" + System.getProperty(\"test.java.opts\", \"\")).trim().split(\"\\\\s+\"));\n-    }\n-\n-    \/**\n-     * Parses extra options, options that start with -X excluding the\n-     * bare -X option (as it is not considered an extra option).\n-     * Ignores extra options not starting with -X\n-     *\n-     * This could be improved to handle extra options not starting\n-     * with -X as well as \"standard\" options.\n-     *\/\n-    private Map<String, String> xOptFlags() {\n-        return allFlags()\n-            .filter(s -> s.startsWith(\"-X\") && !s.startsWith(\"-XX:\") && !s.equals(\"-X\"))\n-            .map(s -> s.replaceFirst(\"-\", \"\"))\n-            .map(flag -> flag.splitWithDelimiters(\"[:0123456789]\", 2))\n-            .collect(Collectors.toMap(a -> \"vm.opt.x.\" + a[0],\n-                                      a -> (a.length == 1)\n-                                      ? \"true\" \/\/ -Xnoclassgc\n-                                      : (a[1].equals(\":\")\n-                                         ? a[2]            \/\/ [\"-XshowSettings\", \":\", \"system\"]\n-                                         : a[1] + a[2]))); \/\/ [\"-Xmx\", \"4\", \"g\"]\n-    }\n-\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":4,"deletions":33,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-                    <div class=\"horizontal-scroll\">\n@@ -136,1 +135,0 @@\n-                    <div class=\"horizontal-scroll\">\n@@ -138,1 +136,0 @@\n-                    <\/div>\n@@ -144,1 +141,0 @@\n-                    <div class=\"horizontal-scroll\">\n@@ -150,1 +146,0 @@\n-                    <\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testAnnotationTypes\/TestAnnotationTypes.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -196,1 +196,1 @@\n-        checkOutput(\"pkg\/TestClass.html\", true,\n+        checkOutput(\"pkg\/TestClass.html\", false,\n@@ -208,1 +208,1 @@\n-                    <div class=\"deprecation-comment\">class_test5 passes. This is the second sentence\\\n+                    <div class=\"deprecation-comment\">class_test4 passes. This is the second sentence\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testDeprecatedDocs\/TestDeprecatedDocs.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -280,1 +280,0 @@\n-                <div class=\"horizontal-scroll\">\n@@ -340,1 +339,0 @@\n-                <div class=\"horizontal-scroll\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testDirectedInheritance\/TestDirectedInheritance.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -389,1 +389,0 @@\n-                    <\/div>\n@@ -396,1 +395,0 @@\n-                    <\/div>\n@@ -406,1 +404,0 @@\n-                    <\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHtmlDefinitionListTag\/TestHtmlDefinitionListTag.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-                    <header role=\"banner\">\n+                    <header role=\"banner\" class=\"flex-header\">\n@@ -109,1 +109,1 @@\n-                    <header role=\"banner\">\n+                    <header role=\"banner\" class=\"flex-header\">\n@@ -147,1 +147,1 @@\n-                    <header role=\"banner\">\n+                    <header role=\"banner\" class=\"flex-header\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHtmlLandmarkRegions\/TestHtmlLandmarkRegions.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-                    <header role=\"banner\">\n+                    <header role=\"banner\" class=\"flex-header\">\n@@ -102,1 +102,1 @@\n-                    <header role=\"banner\">\n+                    <header role=\"banner\" class=\"flex-header\">\n@@ -134,1 +134,1 @@\n-                    <header role=\"banner\">\n+                    <header role=\"banner\" class=\"flex-header\">\n@@ -167,1 +167,1 @@\n-                    <header role=\"banner\">\n+                    <header role=\"banner\" class=\"flex-header\">\n@@ -188,1 +188,1 @@\n-                    <header role=\"banner\">\n+                    <header role=\"banner\" class=\"flex-header\">\n@@ -217,1 +217,1 @@\n-                    <header role=\"banner\">\n+                    <header role=\"banner\" class=\"flex-header\">\n@@ -236,1 +236,1 @@\n-                    <header role=\"banner\">\n+                    <header role=\"banner\" class=\"flex-header\">\n@@ -260,1 +260,1 @@\n-                    <header role=\"banner\">\n+                    <header role=\"banner\" class=\"flex-header\">\n@@ -295,1 +295,1 @@\n-                    <header role=\"banner\">\n+                    <header role=\"banner\" class=\"flex-header\">\n@@ -300,0 +300,1 @@\n+                    <div class=\"flex-content\">\n@@ -321,1 +322,1 @@\n-                    <header role=\"banner\">\n+                    <header role=\"banner\" class=\"flex-header\">\n@@ -352,1 +353,1 @@\n-                    <header role=\"banner\">\n+                    <header role=\"banner\" class=\"flex-header\">\n@@ -402,1 +403,1 @@\n-                    <header role=\"banner\">\n+                    <header role=\"banner\" class=\"flex-header\">\n@@ -443,1 +444,1 @@\n-                    <header role=\"banner\">\n+                    <header role=\"banner\" class=\"flex-header\">\n@@ -475,1 +476,1 @@\n-                    <header role=\"banner\">\n+                    <header role=\"banner\" class=\"flex-header\">\n@@ -502,1 +503,1 @@\n-                    <header role=\"banner\">\n+                    <header role=\"banner\" class=\"flex-header\">\n@@ -529,1 +530,1 @@\n-                    <header role=\"banner\">\n+                    <header role=\"banner\" class=\"flex-header\">\n@@ -567,1 +568,1 @@\n-                    <header role=\"banner\">\n+                    <header role=\"banner\" class=\"flex-header\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHtmlVersion\/TestHtmlVersion.java","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -131,1 +131,0 @@\n-                    <div class=\"horizontal-scroll\">\n@@ -151,1 +150,0 @@\n-                    <div class=\"horizontal-scroll\">\n@@ -162,1 +160,0 @@\n-                    <div class=\"horizontal-scroll\">\n@@ -317,1 +314,0 @@\n-                <div class=\"horizontal-scroll\">\n@@ -324,1 +320,0 @@\n-                <\/div>\n@@ -330,1 +325,0 @@\n-                <div class=\"horizontal-scroll\">\n@@ -338,1 +332,0 @@\n-                <\/div>\n@@ -344,1 +337,0 @@\n-                <div class=\"horizontal-scroll\">\n@@ -351,1 +343,0 @@\n-                <\/div>\n@@ -357,1 +348,0 @@\n-                <div class=\"horizontal-scroll\">\n@@ -360,1 +350,0 @@\n-                <\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testInterface\/TestInterface.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -110,1 +110,0 @@\n-                    <div class=\"horizontal-scroll\">\n@@ -118,1 +117,0 @@\n-                    <div class=\"horizontal-scroll\">\n@@ -126,1 +124,0 @@\n-                    <div class=\"horizontal-scroll\">\n@@ -139,1 +136,0 @@\n-                    <div class=\"horizontal-scroll\">\n@@ -152,1 +148,0 @@\n-                    <div class=\"horizontal-scroll\">\n@@ -161,1 +156,0 @@\n-                    <div class=\"horizontal-scroll\">\n@@ -179,1 +173,0 @@\n-                    <div class=\"horizontal-scroll\">\n@@ -272,1 +265,0 @@\n-                        <div class=\"horizontal-scroll\">\n@@ -284,1 +276,0 @@\n-                        <\/div>\n@@ -290,1 +281,0 @@\n-                        <div class=\"horizontal-scroll\">\n@@ -302,1 +292,0 @@\n-                        <\/div>\n@@ -308,1 +297,0 @@\n-                        <div class=\"horizontal-scroll\">\n@@ -320,1 +308,0 @@\n-                        <\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testJavaFX\/TestJavaFX.java","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,1 +157,0 @@\n-                                <div class=\"horizontal-scroll\">\n@@ -167,1 +166,0 @@\n-                                <\/div>\n@@ -181,1 +179,0 @@\n-                                <div class=\"horizontal-scroll\">\n@@ -188,1 +185,0 @@\n-                                <\/div>\n@@ -206,1 +202,0 @@\n-                                <div class=\"horizontal-scroll\">\n@@ -216,1 +211,0 @@\n-                                <\/div>\n@@ -229,1 +223,0 @@\n-                                <div class=\"horizontal-scroll\">\n@@ -236,1 +229,0 @@\n-                                <\/div>\n@@ -253,1 +245,0 @@\n-                                <div class=\"horizontal-scroll\">\n@@ -261,1 +252,0 @@\n-                                <\/div>\n@@ -275,1 +265,0 @@\n-                                <div class=\"horizontal-scroll\">\n@@ -283,1 +272,0 @@\n-                                <\/div>\n@@ -435,1 +423,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testJavaFX\/TestJavaFXCombo.java","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,0 @@\n-                    <div class=\"horizontal-scroll\">\n@@ -109,1 +108,0 @@\n-                    <\/div>\n@@ -158,1 +156,0 @@\n-                    <div class=\"horizontal-scroll\">\n@@ -175,1 +172,0 @@\n-                    <\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testJavaFX\/TestJavaFXMissingPropComments.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,1 +123,0 @@\n-                    <div class=\"horizontal-scroll\">\n@@ -128,1 +127,0 @@\n-                    <\/div>\n@@ -147,1 +145,0 @@\n-                    <div class=\"horizontal-scroll\">\n@@ -175,1 +172,0 @@\n-                    <div class=\"horizontal-scroll\">\n@@ -180,1 +176,0 @@\n-                    <\/div>\n@@ -193,1 +188,0 @@\n-                    <div class=\"horizontal-scroll\">\n@@ -197,1 +191,0 @@\n-                    <\/div>\n@@ -241,1 +234,0 @@\n-                    <div class=\"horizontal-scroll\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMemberInheritance\/TestMemberInheritance.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -524,0 +524,1 @@\n+                    <div class=\"flex-content\">\n@@ -548,1 +549,0 @@\n-                    <div class=\"horizontal-scroll\">\n@@ -551,1 +551,0 @@\n-                    <\/div>\n@@ -563,1 +562,0 @@\n-                    <div class=\"horizontal-scroll\">\n@@ -570,1 +568,0 @@\n-                    <\/div>\n@@ -713,0 +710,1 @@\n+                    <div class=\"flex-content\">\n@@ -1134,1 +1132,0 @@\n-                    <div class=\"horizontal-scroll\">\n@@ -1148,1 +1145,0 @@\n-                    <div class=\"horizontal-scroll\">\n@@ -1361,1 +1357,0 @@\n-                    <div class=\"horizontal-scroll\">\n@@ -1367,1 +1362,0 @@\n-                    <\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testModules\/TestModules.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,0 +94,1 @@\n+                    <div class=\"flex-content\">\n@@ -102,0 +103,1 @@\n+                    <div class=\"flex-content\">\n@@ -121,0 +123,1 @@\n+                    <div class=\"flex-content\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNavigation\/TestNavigation.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -235,1 +235,0 @@\n-                    <div class=\"horizontal-scroll\">\n@@ -243,1 +242,0 @@\n-                    <div class=\"horizontal-scroll\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOptions\/TestOptions.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,0 @@\n-                    <div class=\"horizontal-scroll\">\n@@ -95,1 +94,0 @@\n-                    <div class=\"horizontal-scroll\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testPackageAnnotation\/TestPackageAnnotation.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,175 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8316972\n- * @summary Add javadoc support for restricted methods\n- * @library \/tools\/lib ..\/..\/lib\n- * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n- * @build toolbox.ToolBox javadoc.tester.*\n- * @run main TestRestricted\n- *\/\n-\n-import java.io.IOException;\n-import java.nio.file.Path;\n-\n-import javadoc.tester.JavadocTester;\n-import toolbox.ToolBox;\n-\n-public class TestRestricted extends JavadocTester {\n-\n-    public final ToolBox tb;\n-    public static void main(String... args) throws Exception {\n-        var tester = new TestRestricted();\n-        tester.runTests();\n-    }\n-\n-    public TestRestricted() {\n-        tb = new ToolBox();\n-    }\n-\n-    @Test\n-    public void testRestricted(Path base) throws IOException {\n-        var src = base.resolve(\"src\");\n-        tb.writeJavaFiles(src, \"\"\"\n-                   package pkg;\n-\n-                   import jdk.internal.javac.PreviewFeature;\n-                   import jdk.internal.javac.PreviewFeature.Feature;\n-                   import jdk.internal.javac.Restricted;\n-\n-                   \/**\n-                    * Interface containing restricted methods.\n-                    * @see #restrictedMethod()\n-                    * @see #restrictedPreviewMethod()\n-                    *\/\n-                   public interface I {\n-\n-                       \/**\n-                        * Restricted method.\n-                        *\/\n-                       @Restricted\n-                       public void restrictedMethod();\n-\n-                       \/**\n-                        * Restricted preview method.\n-                        *\/\n-                       @PreviewFeature(feature=Feature.TEST)\n-                       @Restricted\n-                       public int restrictedPreviewMethod();\n-                   }\n-                   \"\"\");\n-\n-        javadoc(\"--enable-preview\", \"-source\", System.getProperty(\"java.specification.version\"),\n-                \"--add-exports\", \"java.base\/jdk.internal.javac=ALL-UNNAMED\",\n-                \"-d\", base.resolve(\"api\").toString(),\n-                \"-sourcepath\", src.toString(),\n-                \"pkg\");\n-        checkExit(Exit.OK);\n-\n-        \/\/ Test restricted method note in class documentation\n-        checkOutput(\"pkg\/I.html\", true,\n-                \"\"\"\n-                <ul class=\"tag-list-long\">\n-                <li><a href=\"#restrictedMethod()\"><code>restrictedMethod()<\/code><\/a><sup><a href=\"\\\n-                #restricted-restrictedMethod()\">RESTRICTED<\/a><\/sup><\/li>\n-                <li><a href=\"#restrictedPreviewMethod()\"><code>restrictedPreviewMethod()<\/code><\/a>\\\n-                <sup><a href=\"#preview-restrictedPreviewMethod()\">PREVIEW<\/a><\/sup>&nbsp;<sup><a hr\\\n-                ef=\"#restricted-restrictedPreviewMethod()\">RESTRICTED<\/a><\/sup><\/li>\"\"\",\n-                        \"\"\"\n-                <div class=\"block\"><span class=\"restricted-label\">Restricted.<\/span><\/div>\n-                <div class=\"block\">Restricted method.<\/div>\"\"\",\n-                        \"\"\"\n-                <div class=\"block\"><span class=\"preview-label\">Preview.<\/span><\/div>\n-                <div class=\"block\"><span class=\"restricted-label\">Restricted.<\/span><\/div>\n-                <div class=\"block\">Restricted preview method.<\/div>\"\"\",\n-                        \"\"\"\n-                <h3>restrictedMethod<\/h3>\n-                <div class=\"horizontal-scroll\">\n-                <div class=\"member-signature\"><span class=\"modifiers\">sealed<\/span>&nbsp;<span clas\\\n-                s=\"return-type\">void<\/span>&nbsp;<span class=\"element-name\">restrictedMethod<\/span>\\\n-                ()<\/div>\n-                <div class=\"restricted-block\" id=\"restricted-restrictedMethod()\"><span class=\"restr\\\n-                icted-label\"><code>restrictedMethod<\/code> is a restricted method of the Java platf\\\n-                orm.<\/span>\n-                <div class=\"restricted-comment\">Programs can only use <code>restrictedMethod<\/code>\\\n-                 when access to restricted methods is enabled.<\/div>\n-                <div class=\"restricted-comment\">Restricted methods are unsafe, and, if used incorre\\\n-                ctly, might crash the JVM or result in memory corruption.<\/div>\n-                <\/div>\"\"\",\n-                        \"\"\"\n-                <h3>restrictedPreviewMethod<\/h3>\n-                <div class=\"horizontal-scroll\">\n-                <div class=\"member-signature\"><span class=\"modifiers\">sealed<\/span>&nbsp;<span clas\\\n-                s=\"return-type\">int<\/span>&nbsp;<span class=\"element-name\">restrictedPreviewMethod<\\\n-                \/span>()<\/div>\n-                <div class=\"preview-block\" id=\"preview-restrictedPreviewMethod()\"><span class=\"prev\\\n-                iew-label\"><code>restrictedPreviewMethod<\/code> is a preview API of the Java platfo\\\n-                rm.<\/span>\n-                <div class=\"preview-comment\">Programs can only use <code>restrictedPreviewMethod<\/c\\\n-                ode> when preview features are enabled.<\/div>\n-                <div class=\"preview-comment\">Preview features may be removed in a future release, o\\\n-                r upgraded to permanent features of the Java platform.<\/div>\n-                <\/div>\n-                <div class=\"restricted-block\" id=\"restricted-restrictedPreviewMethod()\"><span class\\\n-                =\"restricted-label\"><code>restrictedPreviewMethod<\/code> is a restricted method of \\\n-                the Java platform.<\/span>\n-                <div class=\"restricted-comment\">Programs can only use <code>restrictedPreviewMethod\\\n-                <\/code> when access to restricted methods is enabled.<\/div>\n-                <div class=\"restricted-comment\">Restricted methods are unsafe, and, if used incorre\\\n-                ctly, might crash the JVM or result in memory corruption.<\/div>\n-                <\/div>\"\"\");\n-\n-        \/\/ Test link on index page\n-        checkOutput(\"index-all.html\", true,\n-                        \"\"\"\n-                <a href=\"restricted-list.html\">Restricted&nbsp;Methods<\/a>\"\"\");\n-\n-        \/\/ Test restricted methods list\n-        checkOutput(\"restricted-list.html\", true,\n-                \"\"\"\n-                <h1 title=\"Restricted Methods\" class=\"title\">Restricted Methods<\/h1>\n-                <\/div>\n-                <ul class=\"block-list\">\n-                <li>\n-                <div id=\"method\">\n-                <div class=\"caption\"><span>Methods<\/span><\/div>\n-                <div class=\"summary-table two-column-summary\">\n-                <div class=\"table-header col-first\">Method<\/div>\n-                <div class=\"table-header col-last\">Description<\/div>\n-                <div class=\"col-summary-item-name even-row-color\"><a href=\"pkg\/I.html#restrictedMet\\\n-                hod()\">pkg.I.restrictedMethod()<\/a><sup><a href=\"pkg\/I.html#restricted-restrictedMe\\\n-                thod()\">RESTRICTED<\/a><\/sup><\/div>\n-                <div class=\"col-last even-row-color\">\n-                <div class=\"block\">Restricted method.<\/div>\n-                <\/div>\n-                <div class=\"col-summary-item-name odd-row-color\"><a href=\"pkg\/I.html#restrictedPrev\\\n-                iewMethod()\">pkg.I.restrictedPreviewMethod()<\/a><sup><a href=\"pkg\/I.html#preview-re\\\n-                strictedPreviewMethod()\">PREVIEW<\/a><\/sup>&nbsp;<sup><a href=\"pkg\/I.html#restricted\\\n-                -restrictedPreviewMethod()\">RESTRICTED<\/a><\/sup><\/div>\n-                <div class=\"col-last odd-row-color\">\n-                <div class=\"block\">Restricted preview method.<\/div>\n-                <\/div>\"\"\");\n-    }\n-}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testRestricted\/TestRestricted.java","additions":0,"deletions":175,"binary":false,"changes":175,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -295,1 +295,0 @@\n-                    <\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testReturnTag\/TestReturnTag.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -437,0 +437,2 @@\n+        checkOutput(fileName, true,\n+                \"<div class=\\\"flex-box\\\">\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSearch\/TestSearch.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-                        overflow: auto hidden;\n+                        overflow-x: auto;\n@@ -164,1 +164,1 @@\n-                    .deprecation-block, .preview-block, .restricted-block {\n+                    .deprecation-block {\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testStylesheet\/TestStylesheet.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,1 +95,0 @@\n-                 <div class=\"horizontal-scroll\">\n@@ -99,1 +98,0 @@\n-                 <\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSummaryTag\/TestSummaryTag.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,2 @@\n-                    <header role=\"banner\">\"\"\",\n+                    <div class=\"flex-box\">\n+                    <header role=\"banner\" class=\"flex-header\">\"\"\",\n@@ -73,0 +74,1 @@\n+                    <div class=\"flex-content\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSystemPropertyPage\/TestSystemPropertyPage.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -683,1 +683,0 @@\n-                <\/div>\n@@ -739,1 +738,0 @@\n-                <\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritanceMultiple\/TestOneToMany.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -110,1 +110,0 @@\n-                    <div class=\"horizontal-scroll\">\n@@ -119,1 +118,0 @@\n-                    <\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testUnicode\/TestUnicode.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,1 +83,0 @@\n-                    <div class=\"horizontal-scroll\">\n@@ -89,1 +88,0 @@\n-                    <div class=\"horizontal-scroll\">\n@@ -118,1 +116,0 @@\n-                    <div class=\"horizontal-scroll\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testValueTag\/TestValueFormats.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -427,1 +427,0 @@\n-        boolean haveSourcePath = false;\n@@ -434,1 +433,0 @@\n-                case \"-sourcepath\", \"--source-path\", \"--module-source-path\" -> haveSourcePath = true;\n@@ -456,10 +454,0 @@\n-        \/\/ explicitly set the source path if none specified\n-        \/\/ to override the javadoc tool default to use the classpath\n-        if (!haveSourcePath) {\n-            var newArgs = new String[args.length + 2];\n-            newArgs[0] = \"-sourcepath\";\n-            newArgs[1] = testSrc;\n-            System.arraycopy(args, 0, newArgs, 2, args.length);\n-            args = newArgs;\n-        }\n-\n","filename":"test\/langtools\/jdk\/javadoc\/lib\/javadoc\/tester\/JavadocTester.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8315851 8315588\n+ * @bug 9999999\n@@ -37,2 +37,0 @@\n-\n-import jdk.jshell.SourceCodeAnalysis;\n@@ -45,3 +43,0 @@\n-import static jdk.jshell.SourceCodeAnalysis.Completeness.COMPLETE;\n-import static jdk.jshell.SourceCodeAnalysis.Completeness.DEFINITELY_INCOMPLETE;\n-\n@@ -58,73 +53,0 @@\n-    static final String[] definitely_incomplete = new String[]{\n-            \"int _ = \",\n-            \"int m(String v, int r) {\\n\" +\n-                    \"    try {\\n\" +\n-                    \"        return Integer.parseInt(v, r);\\n\" +\n-                    \"    } catch (NumberFormatException _) {\",\n-            \"try (final Lock _ = \",\n-            \"try (Lock _ = null) {\\n\" +\n-                \"            try (Lock _ = null) {\",\n-            \"for (var _ : strs\",\n-            \"TwoParams p1 = (_, _) ->\",\n-            \"for (int _ = 0, _ = 1, x = 1;\",\n-            \"if (r instanceof R(_\"\n-    };\n-\n-    static final String[] complete = new String[]{\n-            \"int _ = 42;\",\n-            \"int m(String v, int r) {\\n\" +\n-                    \"    try {\\n\" +\n-                    \"        return Integer.parseInt(v, r);\\n\" +\n-                    \"    } catch (NumberFormatException _) { } }\",\n-            \"try (final Lock _ = TEST) {}\",\n-            \"try (Lock _ = null) {\\n\" +\n-                    \"            try (Lock _ = null) { } }\",\n-            \"for (var _ : strs) { }\",\n-            \"TwoParams p1 = (_, _) -> {};\",\n-            \"for (int _ = 0, _ = 1, x = 1; x <= 1 ; x++) {}\",\n-            \"if (r instanceof R(_)) { }\"\n-    };\n-\n-    private void assertStatus(String input, SourceCodeAnalysis.Completeness status, String source) {\n-        String augSrc;\n-        switch (status) {\n-            case COMPLETE_WITH_SEMI:\n-                augSrc = source + \";\";\n-                break;\n-\n-            case DEFINITELY_INCOMPLETE:\n-                augSrc = null;\n-                break;\n-\n-            case CONSIDERED_INCOMPLETE:\n-                augSrc = source + \";\";\n-                break;\n-\n-            case EMPTY:\n-            case COMPLETE:\n-            case UNKNOWN:\n-                augSrc = source;\n-                break;\n-\n-            default:\n-                throw new AssertionError();\n-        }\n-        assertAnalyze(input, status, augSrc);\n-    }\n-\n-    private void assertStatus(String[] ins, SourceCodeAnalysis.Completeness status) {\n-        for (String input : ins) {\n-            assertStatus(input, status, input);\n-        }\n-    }\n-\n-    @Test\n-    public void test_definitely_incomplete() {\n-        assertStatus(definitely_incomplete, DEFINITELY_INCOMPLETE);\n-    }\n-\n-    @Test\n-    public void test_definitely_complete() {\n-        assertStatus(complete, COMPLETE);\n-    }\n-\n","filename":"test\/langtools\/jdk\/jshell\/UnnamedTest.java","additions":1,"deletions":79,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# This file identifies root(s) of the JUnit hierarchy.\n+# This file identifies root(s) of the test-ng hierarchy.\n@@ -3,1 +3,1 @@\n-JUnit.dirs = .\n+TestNG.dirs = .\n","filename":"test\/langtools\/lib\/combo\/TEST.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,31 +0,0 @@\n-package tools.javac.combo;\n-\n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.Set;\n-\n-import org.junit.jupiter.api.extension.AfterAllCallback;\n-import org.junit.jupiter.api.extension.ExtensionContext;\n-import org.junit.jupiter.api.extension.TestWatcher;\n-\n-public class ComboWatcher implements TestWatcher, AfterAllCallback {\n-    private final Set<String> errors = Collections.synchronizedSet(new HashSet<>());\n-\n-    @Override\n-    public void testFailed(ExtensionContext context, Throwable cause) {\n-        if (context.getRequiredTestInstance() instanceof JavacTemplateTestBase instance) {\n-            errors.addAll(instance.diags.errorKeys());\n-            if (instance instanceof CompilationTestCase) {\n-                \/\/ Make sure offending template ends up in log file on failure\n-                System.err.printf(\"Diagnostics: %s%nTemplate: %s%n\", instance.diags.errorKeys(),\n-                        instance.sourceFiles.stream().map(SourceFile::template).toList());\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void afterAll(ExtensionContext extensionContext) {\n-        if (errors.isEmpty()) return;\n-        System.err.println(\"Errors found in tests: \" + errors);\n-    }\n-}\n","filename":"test\/langtools\/lib\/combo\/tools\/javac\/combo\/ComboWatcher.java","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,6 @@\n+import org.testng.ITestResult;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.Test;\n+\n+import static java.util.stream.Collectors.toList;\n+\n@@ -37,0 +43,1 @@\n+@Test\n@@ -38,1 +45,1 @@\n-    private String[] compileOptions = new String[]{};\n+    private String[] compileOptions = new String[] { };\n@@ -42,0 +49,9 @@\n+    @AfterMethod\n+    public void dumpTemplateIfError(ITestResult result) {\n+        \/\/ Make sure offending template ends up in log file on failure\n+        if (!result.isSuccess()) {\n+            System.err.printf(\"Diagnostics: %s%nTemplate: %s%n\", diags.errorKeys(),\n+                              sourceFiles.stream().map(p -> p.snd).collect(toList()));\n+        }\n+    }\n+\n@@ -68,1 +84,1 @@\n-            compileOptions = new String[]{};\n+            compileOptions = new String[] {};\n@@ -92,1 +108,2 @@\n-        } catch (IOException e) {\n+        }\n+        catch (IOException e) {\n","filename":"test\/langtools\/lib\/combo\/tools\/javac\/combo\/CompilationTestCase.java","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.util.HashSet;\n@@ -38,0 +39,1 @@\n+import java.util.Set;\n@@ -49,2 +51,6 @@\n-import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.extension.ExtendWith;\n+import com.sun.tools.javac.util.Pair;\n+import org.testng.ITestResult;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.AfterSuite;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n@@ -52,1 +58,1 @@\n-import static org.junit.jupiter.api.Assertions.fail;\n+import static org.testng.Assert.fail;\n@@ -55,1 +61,1 @@\n- * Base class for template-driven JUnit javac tests that support on-the-fly\n+ * Base class for template-driven TestNG javac tests that support on-the-fly\n@@ -67,1 +73,1 @@\n-@ExtendWith(ComboWatcher.class)\n+@Test\n@@ -69,0 +75,1 @@\n+    private static final Set<String> suiteErrors = Collections.synchronizedSet(new HashSet<>());\n@@ -75,1 +82,1 @@\n-    protected final List<SourceFile> sourceFiles = new ArrayList<>();\n+    protected final List<Pair<String, String>> sourceFiles = new ArrayList<>();\n@@ -91,1 +98,1 @@\n-        sourceFiles.add(new SourceFile(name, template));\n+        sourceFiles.add(new Pair<>(name, template));\n@@ -126,1 +133,1 @@\n-    @BeforeEach\n+    @BeforeMethod\n@@ -135,0 +142,32 @@\n+    \/\/ After each test method, if the test failed, capture source files and diagnostics and put them in the log\n+    @AfterMethod\n+    public void copyErrors(ITestResult result) {\n+        if (!result.isSuccess()) {\n+            suiteErrors.addAll(diags.errorKeys());\n+\n+            List<Object> list = new ArrayList<>();\n+            Collections.addAll(list, result.getParameters());\n+            list.add(\"Test case: \" + getTestCaseDescription());\n+            for (Pair<String, String> e : sourceFiles)\n+                list.add(\"Source file \" + e.fst + \": \" + e.snd);\n+            if (diags.errorsFound())\n+                list.add(\"Compile diagnostics: \" + diags.toString());\n+            result.setParameters(list.toArray(new Object[list.size()]));\n+        }\n+    }\n+\n+    @AfterSuite\n+    \/\/ After the suite is done, dump any errors to output\n+    public void dumpErrors() {\n+        if (!suiteErrors.isEmpty())\n+            System.err.println(\"Errors found in test suite: \" + suiteErrors);\n+    }\n+\n+    \/**\n+     * Get a description of this test case; since test cases may be combinatorially\n+     * generated, this should include all information needed to describe the test case\n+     *\/\n+    protected String getTestCaseDescription() {\n+        return this.toString();\n+    }\n+\n@@ -222,1 +261,3 @@\n-        var files = sourceFiles.stream().map(FileAdapter::new).toList();\n+        List<JavaFileObject> files = new ArrayList<>();\n+        for (Pair<String, String> e : sourceFiles)\n+            files.add(new FileAdapter(e.fst, e.snd));\n@@ -230,1 +271,3 @@\n-        var files = sourceFiles.stream().map(FileAdapter::new).toList();\n+        List<JavaFileObject> files = new ArrayList<>();\n+        for (Pair<String, String> e : sourceFiles)\n+            files.add(new FileAdapter(e.fst, e.snd));\n@@ -234,1 +277,1 @@\n-    private File compile(List<File> classpaths, List<? extends JavaFileObject> files, boolean generate) throws IOException {\n+    private File compile(List<File> classpaths, List<JavaFileObject> files, boolean generate) throws IOException {\n@@ -287,3 +330,3 @@\n-        FileAdapter(SourceFile file) {\n-            super(URI.create(\"myfo:\/\" + file.name()), Kind.SOURCE);\n-            this.templateString = file.template();\n+        FileAdapter(String filename, String templateString) {\n+            super(URI.create(\"myfo:\/\" + filename), Kind.SOURCE);\n+            this.templateString = templateString;\n","filename":"test\/langtools\/lib\/combo\/tools\/javac\/combo\/JavacTemplateTestBase.java","additions":58,"deletions":15,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -1,26 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package tools.javac.combo;\n-\n-public record SourceFile(String name, String template) {}\n","filename":"test\/langtools\/lib\/combo\/tools\/javac\/combo\/SourceFile.java","additions":0,"deletions":26,"binary":false,"changes":26,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,4 +26,2 @@\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.BeforeEach;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.Test;\n@@ -34,0 +32,2 @@\n+import static org.testng.Assert.assertEquals;\n+\n@@ -37,2 +37,3 @@\n-class TemplateTest {\n-    final Map<String, Template> vars = new HashMap<>();\n+@Test\n+public class TemplateTest {\n+    Map<String, Template> vars = new HashMap<>();\n@@ -40,1 +41,1 @@\n-    @BeforeEach\n+    @BeforeTest\n@@ -45,1 +46,1 @@\n-        assertEquals(expected, result, \"for \" + template);\n+        assertEquals(result, expected, \"for \" + template);\n@@ -52,2 +53,1 @@\n-    @Test\n-    void testTemplateExpansion() {\n+    public void testTemplateExpansion() {\n@@ -75,2 +75,1 @@\n-    @Test\n-    void testIndexedTemplate() {\n+    public void testIndexedTemplate() {\n@@ -86,2 +85,1 @@\n-    @Test\n-    void testAngleBrackets() {\n+    public void testAngleBrackets() {\n@@ -92,3 +90,3 @@\n-    @Test\n-    void testUnknownKey() {\n-        assertThrows(IllegalStateException.class, () -> assertTemplate(\"#{Q}\", \"#{Q}\"));\n+    @Test(expectedExceptions = IllegalStateException.class )\n+    public void testUnknownKey() {\n+        assertTemplate(\"#{Q}\", \"#{Q}\");\n","filename":"test\/langtools\/lib\/combo\/tools\/javac\/combo\/TemplateTest.java","additions":16,"deletions":18,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1,131 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8305971\n- * @summary NPE in JavacProcessingEnvironment for missing enum constructor body\n- * @library \/tools\/lib \/tools\/javac\/lib\n- * @modules\n- *      jdk.compiler\/com.sun.tools.javac.api\n- *      jdk.compiler\/com.sun.tools.javac.main\n- * @build toolbox.ToolBox toolbox.JavacTask\n- * @run main CrashEmptyEnumConstructorTest\n- *\/\n-\n-import java.io.IOException;\n-\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-\n-import java.util.List;\n-import java.util.Set;\n-import javax.annotation.processing.AbstractProcessor;\n-import javax.annotation.processing.RoundEnvironment;\n-import javax.annotation.processing.SupportedAnnotationTypes;\n-import javax.lang.model.SourceVersion;\n-import javax.lang.model.element.TypeElement;\n-\n-import toolbox.JavacTask;\n-import toolbox.Task;\n-import toolbox.Task.Mode;\n-import toolbox.Task.OutputKind;\n-import toolbox.TestRunner;\n-import toolbox.ToolBox;\n-\n-public class CrashEmptyEnumConstructorTest extends TestRunner {\n-    protected ToolBox tb;\n-\n-    CrashEmptyEnumConstructorTest() {\n-        super(System.err);\n-        tb = new ToolBox();\n-    }\n-\n-    public static void main(String... args) throws Exception {\n-        new CrashEmptyEnumConstructorTest().runTests();\n-    }\n-\n-    protected void runTests() throws Exception {\n-        runTests(m -> new Object[]{Paths.get(m.getName())});\n-    }\n-\n-    Path[] findJavaFiles(Path... paths) throws IOException {\n-        return tb.findJavaFiles(paths);\n-    }\n-\n-    @Test\n-    public void testEmptyEnumConstructor(Path base) throws Exception {\n-        Path src = base.resolve(\"src\");\n-        Path r = src.resolve(\"E\");\n-\n-        Path classes = base.resolve(\"classes\");\n-\n-        Files.createDirectories(classes);\n-\n-        tb.writeJavaFiles(r,\n-                \"\"\"\n-                enum E {\n-                    ONE(\"\");\n-                    E(String one);\n-                }\n-                \"\"\");\n-\n-        List<String> expected = List.of(\n-            \"E.java:3: error: missing method body, or declare abstract\",\n-            \"    E(String one);\",\n-            \"    ^\",\n-            \"1 error\");\n-\n-        List<String> log = new JavacTask(tb)\n-                .options(\"-processor\", SimpleProcessor.class.getName())\n-                .files(findJavaFiles(src))\n-                .outdir(classes)\n-                .run(Task.Expect.FAIL)\n-                .writeAll()\n-                .getOutputLines(Task.OutputKind.DIRECT);\n-\n-        if (log.size() != expected.size()) {\n-            throw new AssertionError(\"Unexpected output: \" + log);\n-        } else {\n-            for (int i = 0; i < expected.size(); i++) {\n-                if (!log.get(i).contains(expected.get(i))) {\n-                    throw new AssertionError(\"Unexpected output: \" + log);\n-                }\n-            }\n-        }\n-    }\n-\n-    @SupportedAnnotationTypes(\"*\")\n-    public static final class SimpleProcessor extends AbstractProcessor {\n-        @Override\n-        public SourceVersion getSupportedSourceVersion() {\n-            return SourceVersion.latestSupported();\n-        }\n-\n-        @Override\n-        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n-            return false;\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/annotations\/crash_empty_enum_const\/CrashEmptyEnumConstructorTest.java","additions":0,"deletions":131,"binary":false,"changes":131,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,1 @@\n+import java.io.IOException;\n@@ -26,1 +27,3 @@\n-import org.junit.jupiter.api.Test;\n+import org.testng.ITestResult;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.Test;\n@@ -28,0 +31,1 @@\n+import tools.javac.combo.JavacTemplateTestBase;\n@@ -29,1 +33,4 @@\n-class ExpSwitchNestingTest extends CompilationTestCase {\n+import static java.util.stream.Collectors.toList;\n+\n+@Test\n+public class ExpSwitchNestingTest extends CompilationTestCase {\n@@ -73,2 +80,1 @@\n-    @Test\n-    void testReallySimpleCases() {\n+    public void testReallySimpleCases() {\n@@ -81,2 +87,1 @@\n-    @Test\n-    void testLambda() {\n+    public void testLambda() {\n@@ -104,2 +109,1 @@\n-    @Test\n-    void testEswitch() {\n+    public void testEswitch() {\n@@ -150,2 +154,1 @@\n-    @Test\n-    void testNestedInExpSwitch() {\n+    public void testNestedInExpSwitch() {\n@@ -184,2 +187,1 @@\n-    @Test\n-    void testBreakExpressionLabelDisambiguation() {\n+    public void testBreakExpressionLabelDisambiguation() {\n@@ -195,2 +197,1 @@\n-    @Test\n-    void testFunReturningSwitchExp() {\n+    public void testFunReturningSwitchExp() {\n@@ -200,2 +201,1 @@\n-    @Test\n-    void testContinueLoops() {\n+    public void testContinueLoops() {\n","filename":"test\/langtools\/tools\/javac\/expswitch\/ExpSwitchNestingTest.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-JUnit.dirs = .\n+TestNG.dirs = .\n","filename":"test\/langtools\/tools\/javac\/expswitch\/TEST.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,2 @@\n-import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.Test;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n@@ -39,1 +39,1 @@\n-import static org.junit.jupiter.api.Assertions.fail;\n+import static org.testng.Assert.fail;\n@@ -59,0 +59,1 @@\n+@Test\n@@ -231,1 +232,1 @@\n-    @BeforeEach\n+    @BeforeMethod\n","filename":"test\/langtools\/tools\/javac\/lambda\/bridge\/template_tests\/BridgeMethodTestCase.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,3 +25,2 @@\n-import tools.javac.combo.*;\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import org.testng.annotations.Test;\n@@ -34,1 +33,2 @@\n-class BridgeMethodsTemplateTest extends BridgeMethodTestCase {\n+@Test\n+public class BridgeMethodsTemplateTest extends BridgeMethodTestCase {\n@@ -42,2 +42,1 @@\n-    @Test\n-    void test1() throws IOException, ReflectiveOperationException {\n+    public void test1() throws IOException, ReflectiveOperationException {\n@@ -56,2 +55,1 @@\n-    @Test\n-    void test2() throws IOException, ReflectiveOperationException {\n+    public void test2() throws IOException, ReflectiveOperationException {\n@@ -70,2 +68,1 @@\n-    @Test\n-    void test3() throws IOException, ReflectiveOperationException {\n+    public void test3() throws IOException, ReflectiveOperationException {\n@@ -84,2 +81,1 @@\n-    @Test\n-    void test4() throws IOException, ReflectiveOperationException {\n+    public void test4() throws IOException, ReflectiveOperationException {\n@@ -98,2 +94,1 @@\n-    @Test\n-    void test5() throws IOException, ReflectiveOperationException {\n+    public void test5() throws IOException, ReflectiveOperationException {\n@@ -112,2 +107,1 @@\n-    @Test\n-    void test6() throws IOException, ReflectiveOperationException {\n+    public void test6() throws IOException, ReflectiveOperationException {\n@@ -126,2 +120,1 @@\n-    @Test\n-    void test7() throws IOException, ReflectiveOperationException {\n+    public void test7() throws IOException, ReflectiveOperationException {\n@@ -140,2 +133,1 @@\n-    @Test\n-    void test8() throws IOException, ReflectiveOperationException {\n+    public void test8() throws IOException, ReflectiveOperationException {\n@@ -154,2 +146,1 @@\n-    @Test\n-    void test9() throws IOException, ReflectiveOperationException {\n+    public void test9() throws IOException, ReflectiveOperationException {\n@@ -168,2 +159,1 @@\n-    @Test\n-    void test10() throws IOException, ReflectiveOperationException {\n+    public void test10() throws IOException, ReflectiveOperationException {\n@@ -182,2 +172,1 @@\n-    @Test\n-    void test11() throws IOException, ReflectiveOperationException {\n+    public void test11() throws IOException, ReflectiveOperationException {\n@@ -197,2 +186,1 @@\n-    @Test\n-    void test12() throws IOException, ReflectiveOperationException {\n+    public void test12() throws IOException, ReflectiveOperationException {\n@@ -212,2 +200,1 @@\n-    @Test\n-    void test13() throws IOException, ReflectiveOperationException {\n+    public void test13() throws IOException, ReflectiveOperationException {\n@@ -227,2 +214,1 @@\n-    @Test\n-    void test14() throws IOException, ReflectiveOperationException {\n+    public void test14() throws IOException, ReflectiveOperationException {\n@@ -242,2 +228,1 @@\n-    @Test\n-    void test15() throws IOException, ReflectiveOperationException {\n+    public void test15() throws IOException, ReflectiveOperationException {\n@@ -257,2 +242,1 @@\n-    @Test\n-    void test16() throws IOException, ReflectiveOperationException {\n+    public void test16() throws IOException, ReflectiveOperationException {\n@@ -272,2 +256,1 @@\n-    @Test\n-    void test17() throws IOException, ReflectiveOperationException {\n+    public void test17() throws IOException, ReflectiveOperationException {\n@@ -287,2 +270,1 @@\n-    @Test\n-    void test18() throws IOException, ReflectiveOperationException {\n+    public void test18() throws IOException, ReflectiveOperationException {\n@@ -302,2 +284,1 @@\n-    @Test\n-    void test19() throws IOException, ReflectiveOperationException {\n+    public void test19() throws IOException, ReflectiveOperationException {\n@@ -317,2 +298,1 @@\n-    @Test\n-    void test20() throws IOException, ReflectiveOperationException {\n+    public void test20() throws IOException, ReflectiveOperationException {\n@@ -332,2 +312,1 @@\n-    @Test\n-    void test21() throws IOException, ReflectiveOperationException {\n+    public void test21() throws IOException, ReflectiveOperationException {\n@@ -347,2 +326,1 @@\n-    @Test\n-    void test22() throws IOException, ReflectiveOperationException {\n+    public void test22() throws IOException, ReflectiveOperationException {\n@@ -362,2 +340,1 @@\n-    @Test\n-    void test23() throws IOException, ReflectiveOperationException {\n+    public void test23() throws IOException, ReflectiveOperationException {\n@@ -377,2 +354,1 @@\n-    @Test\n-    void test24() throws IOException, ReflectiveOperationException {\n+    public void test24() throws IOException, ReflectiveOperationException {\n@@ -392,2 +368,1 @@\n-    @Test\n-    void test25() throws IOException, ReflectiveOperationException {\n+    public void test25() throws IOException, ReflectiveOperationException {\n@@ -407,2 +382,1 @@\n-    @Test\n-    void test26() throws IOException, ReflectiveOperationException {\n+    public void test26() throws IOException, ReflectiveOperationException {\n@@ -421,2 +395,1 @@\n-    @Test\n-    void test27() throws IOException, ReflectiveOperationException {\n+    public void test27() throws IOException, ReflectiveOperationException {\n@@ -435,2 +408,1 @@\n-    @Test\n-    void test28() throws IOException, ReflectiveOperationException {\n+    public void test28() throws IOException, ReflectiveOperationException {\n@@ -449,2 +421,1 @@\n-    @Test\n-    void test29() throws IOException, ReflectiveOperationException {\n+    public void test29() throws IOException, ReflectiveOperationException {\n@@ -464,2 +435,1 @@\n-    @Test\n-    void test30() throws IOException, ReflectiveOperationException {\n+    public void test30() throws IOException, ReflectiveOperationException {\n@@ -479,2 +449,1 @@\n-    @Test\n-    void test31() throws IOException, ReflectiveOperationException {\n+    public void test31() throws IOException, ReflectiveOperationException {\n@@ -494,2 +463,1 @@\n-    @Test\n-    void test32() throws IOException, ReflectiveOperationException {\n+    public void test32() throws IOException, ReflectiveOperationException {\n@@ -509,2 +477,1 @@\n-    @Test\n-    void test33() throws IOException, ReflectiveOperationException {\n+    public void test33() throws IOException, ReflectiveOperationException {\n@@ -524,2 +491,1 @@\n-    @Test\n-    void test34() throws IOException, ReflectiveOperationException {\n+    public void test34() throws IOException, ReflectiveOperationException {\n@@ -539,2 +505,1 @@\n-    @Test\n-    void test35() throws IOException, ReflectiveOperationException {\n+    public void test35() throws IOException, ReflectiveOperationException {\n@@ -554,2 +519,1 @@\n-    @Test\n-    void test36() throws IOException, ReflectiveOperationException {\n+    public void test36() throws IOException, ReflectiveOperationException {\n@@ -569,2 +533,1 @@\n-    @Test\n-    void test37() throws IOException, ReflectiveOperationException {\n+    public void test37() throws IOException, ReflectiveOperationException {\n@@ -584,2 +547,1 @@\n-    @Test\n-    void test38() throws IOException, ReflectiveOperationException {\n+    public void test38() throws IOException, ReflectiveOperationException {\n@@ -599,2 +561,1 @@\n-    @Test\n-    void test39() throws IOException, ReflectiveOperationException {\n+    public void test39() throws IOException, ReflectiveOperationException {\n@@ -615,2 +576,1 @@\n-    @Test\n-    void test40() throws IOException, ReflectiveOperationException {\n+    public void test40() throws IOException, ReflectiveOperationException {\n@@ -630,2 +590,1 @@\n-    @Test\n-    void test41() throws IOException, ReflectiveOperationException {\n+    public void test41() throws IOException, ReflectiveOperationException {\n@@ -645,2 +604,1 @@\n-    @Test\n-    void test42() throws IOException, ReflectiveOperationException {\n+    public void test42() throws IOException, ReflectiveOperationException {\n@@ -660,2 +618,1 @@\n-    @Test\n-    void test43() throws IOException, ReflectiveOperationException {\n+    public void test43() throws IOException, ReflectiveOperationException {\n@@ -676,2 +633,1 @@\n-    @Test\n-    void test44() throws IOException, ReflectiveOperationException {\n+    public void test44() throws IOException, ReflectiveOperationException {\n@@ -692,2 +648,1 @@\n-    @Test\n-    void test45() throws IOException, ReflectiveOperationException {\n+    public void test45() throws IOException, ReflectiveOperationException {\n@@ -707,2 +662,1 @@\n-    @Test\n-    void test46() throws IOException, ReflectiveOperationException {\n+    public void test46() throws IOException, ReflectiveOperationException {\n@@ -722,2 +676,1 @@\n-    @Test\n-    void test47() throws IOException, ReflectiveOperationException {\n+    public void test47() throws IOException, ReflectiveOperationException {\n@@ -737,2 +690,1 @@\n-    @Test\n-    void test48() throws IOException, ReflectiveOperationException {\n+    public void test48() throws IOException, ReflectiveOperationException {\n@@ -752,2 +704,1 @@\n-    @Test\n-    void test49() throws IOException, ReflectiveOperationException {\n+    public void test49() throws IOException, ReflectiveOperationException {\n@@ -769,2 +720,1 @@\n-    @Test\n-    void test50() throws IOException, ReflectiveOperationException {\n+    public void test50() throws IOException, ReflectiveOperationException {\n@@ -785,2 +735,1 @@\n-    @Test\n-    void test51() throws IOException, ReflectiveOperationException {\n+    public void test51() throws IOException, ReflectiveOperationException {\n@@ -800,2 +749,1 @@\n-    @Test\n-    void test52() throws IOException, ReflectiveOperationException {\n+    public void test52() throws IOException, ReflectiveOperationException {\n@@ -815,2 +763,1 @@\n-    @Test\n-    void test53() throws IOException, ReflectiveOperationException {\n+    public void test53() throws IOException, ReflectiveOperationException {\n@@ -831,2 +778,1 @@\n-    @Test\n-    void test54() throws IOException, ReflectiveOperationException {\n+    public void test54() throws IOException, ReflectiveOperationException {\n@@ -847,2 +793,1 @@\n-    @Test\n-    void test55() throws IOException, ReflectiveOperationException {\n+    public void test55() throws IOException, ReflectiveOperationException {\n@@ -863,2 +808,1 @@\n-    @Test\n-    void test56() throws IOException, ReflectiveOperationException {\n+    public void test56() throws IOException, ReflectiveOperationException {\n@@ -879,2 +823,1 @@\n-    @Test\n-    void test57() throws IOException, ReflectiveOperationException {\n+    public void test57() throws IOException, ReflectiveOperationException {\n@@ -895,2 +838,1 @@\n-    @Test\n-    void test58() throws IOException, ReflectiveOperationException {\n+    public void test58() throws IOException, ReflectiveOperationException {\n@@ -911,2 +853,1 @@\n-    @Test\n-    void test59() throws IOException, ReflectiveOperationException {\n+    public void test59() throws IOException, ReflectiveOperationException {\n@@ -927,2 +868,1 @@\n-    @Test\n-    void test60() throws IOException, ReflectiveOperationException {\n+    public void test60() throws IOException, ReflectiveOperationException {\n@@ -943,2 +883,1 @@\n-    @Test\n-    void test61() throws IOException, ReflectiveOperationException {\n+    public void test61() throws IOException, ReflectiveOperationException {\n@@ -959,2 +898,1 @@\n-    @Test\n-    void test62() throws IOException, ReflectiveOperationException {\n+    public void test62() throws IOException, ReflectiveOperationException {\n@@ -975,2 +913,1 @@\n-    @Test\n-    void test63() throws IOException, ReflectiveOperationException {\n+    public void test63() throws IOException, ReflectiveOperationException {\n@@ -991,2 +928,1 @@\n-    @Test\n-    void test64() throws IOException, ReflectiveOperationException {\n+    public void test64() throws IOException, ReflectiveOperationException {\n@@ -1007,2 +943,1 @@\n-    @Test\n-    void test65() throws IOException, ReflectiveOperationException {\n+    public void test65() throws IOException, ReflectiveOperationException {\n@@ -1023,2 +958,1 @@\n-    @Test\n-    void test66() throws IOException, ReflectiveOperationException {\n+    public void test66() throws IOException, ReflectiveOperationException {\n@@ -1039,2 +973,1 @@\n-    @Test\n-    void test67() throws IOException, ReflectiveOperationException {\n+    public void test67() throws IOException, ReflectiveOperationException {\n@@ -1048,2 +981,1 @@\n-    @Test\n-    void testA1() throws IOException, ReflectiveOperationException {\n+    public void testA1() throws IOException, ReflectiveOperationException {\n@@ -1054,2 +986,1 @@\n-    @Test\n-    void testA2() throws IOException, ReflectiveOperationException {\n+    public void testA2() throws IOException, ReflectiveOperationException {\n@@ -1060,2 +991,1 @@\n-    @Test\n-    void testA3() throws IOException, ReflectiveOperationException {\n+    public void testA3() throws IOException, ReflectiveOperationException {\n@@ -1066,2 +996,1 @@\n-    @Test\n-    void testA4() throws IOException, ReflectiveOperationException {\n+    public void testA4() throws IOException, ReflectiveOperationException {\n@@ -1073,2 +1002,1 @@\n-    @Test\n-    void testA5() throws IOException, ReflectiveOperationException {\n+    public void testA5() throws IOException, ReflectiveOperationException {\n@@ -1079,2 +1007,1 @@\n-    @Test\n-    void testA6() throws IOException, ReflectiveOperationException {\n+    public void testA6() throws IOException, ReflectiveOperationException {\n@@ -1086,2 +1013,1 @@\n-    @Test\n-    void testA7() throws IOException, ReflectiveOperationException {\n+    public void testA7() throws IOException, ReflectiveOperationException {\n@@ -1092,2 +1018,1 @@\n-    @Test\n-    void testA8() throws IOException, ReflectiveOperationException {\n+    public void testA8() throws IOException, ReflectiveOperationException {\n@@ -1097,2 +1022,1 @@\n-    @Test\n-    void testA9() throws IOException, ReflectiveOperationException {\n+    public void testA9() throws IOException, ReflectiveOperationException {\n@@ -1103,2 +1027,1 @@\n-    @Test\n-    void testA10() throws IOException, ReflectiveOperationException {\n+    public void testA10() throws IOException, ReflectiveOperationException {\n@@ -1108,2 +1031,1 @@\n-    @Test\n-    void testA11() throws IOException, ReflectiveOperationException {\n+    public void testA11() throws IOException, ReflectiveOperationException {\n@@ -1117,2 +1039,1 @@\n-    @Test\n-    void testB1() throws IOException, ReflectiveOperationException {\n+    public void testB1() throws IOException, ReflectiveOperationException {\n@@ -1125,2 +1046,1 @@\n-    @Test\n-    void testB2() throws IOException, ReflectiveOperationException {\n+    public void testB2() throws IOException, ReflectiveOperationException {\n@@ -1139,2 +1059,1 @@\n-    @Test\n-    void testB5() throws IOException, ReflectiveOperationException {\n+    public void testB5() throws IOException, ReflectiveOperationException {\n@@ -1145,2 +1064,1 @@\n-    @Test\n-    void testB6() throws IOException, ReflectiveOperationException {\n+    public void testB6() throws IOException, ReflectiveOperationException {\n@@ -1151,2 +1069,1 @@\n-    @Test\n-    void testB7() throws IOException, ReflectiveOperationException {\n+    public void testB7() throws IOException, ReflectiveOperationException {\n@@ -1157,2 +1074,1 @@\n-    @Test\n-    void testB8() throws IOException, ReflectiveOperationException {\n+    public void testB8() throws IOException, ReflectiveOperationException {\n","filename":"test\/langtools\/tools\/javac\/lambda\/bridge\/template_tests\/BridgeMethodsTemplateTest.java","additions":89,"deletions":173,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# This file identifies root(s) of the JUnit hierarchy.\n+# This file identifies root(s) of the test-ng hierarchy.\n@@ -3,1 +3,1 @@\n-JUnit.dirs = .\n+TestNG.dirs = .\n","filename":"test\/langtools\/tools\/javac\/lambda\/bridge\/template_tests\/TEST.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @run junit BoundUnboundSearchTest\n+ * @run testng BoundUnboundSearchTest\n@@ -43,1 +43,1 @@\n-import org.junit.jupiter.api.Test;\n+import org.testng.annotations.Test;\n@@ -46,1 +46,4 @@\n-class BoundUnboundSearchTest extends CompilationTestCase {\n+import static org.testng.Assert.assertEquals;\n+\n+@Test\n+public class BoundUnboundSearchTest extends CompilationTestCase {\n@@ -58,1 +61,1 @@\n-    BoundUnboundSearchTest() {\n+    public BoundUnboundSearchTest() {\n@@ -75,2 +78,1 @@\n-    @Test\n-    void test() {\n+    public void test() {\n","filename":"test\/langtools\/tools\/javac\/lambda\/methodReference\/BoundUnboundSearchTest.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1,43 +0,0 @@\n-\/**\n- * @test \/nodynamiccopyright\/\n- * @bug 8314578\n- * @enablePreview\n- * @summary Parsing of erroneous patterns succeeds\n- * @compile\/fail\/ref=T8314578.out -XDrawDiagnostics T8314578.java\n- *\/\n-public class T8314578 {\n-    record R1() {}\n-    record R2() {}\n-\n-    static void test(Object o) {\n-        switch (o) {\n-            case R1() when o instanceof String s:\n-            case R2() when o instanceof Integer i:\n-                System.out.println(\"hello: \" + i);\n-                break;\n-            default:\n-                break;\n-        }\n-    }\n-\n-    static void test2(Object o) {\n-        switch (o) {\n-            case R1() when o instanceof String s:\n-                System.out.println(\"hello: \" + s);\n-            case R2() when o instanceof Integer i:\n-                System.out.println(\"hello: \" + i);\n-                break;\n-            default:\n-                break;\n-        }\n-    }\n-\n-    static int unnamedInGuardsOK(String s) {\n-        return switch (s) {\n-            case String _ when s instanceof String _ ->  \/\/ should be OK\n-                    1;\n-            default ->\n-                    -1;\n-        };\n-    }\n-}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/T8314578.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -1,6 +0,0 @@\n-T8314578.java:14:18: compiler.err.flows.through.from.pattern\n-T8314578.java:15:18: compiler.err.flows.through.to.pattern\n-T8314578.java:27:18: compiler.err.flows.through.to.pattern\n-- compiler.note.preview.filename: T8314578.java, DEFAULT\n-- compiler.note.preview.recompile\n-3 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/T8314578.out","additions":0,"deletions":6,"binary":false,"changes":6,"status":"deleted"},{"patch":"@@ -1,24 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8317300\n- * @summary javac erroneously allows \"final\" in front of a record pattern\n- * @compile\/fail\/ref=T8317300.out -XDrawDiagnostics T8317300.java\n- *\/\n-public class T8317300 {\n-    record Foo (int x) {}\n-    record Bar (Foo x) {}\n-\n-    void test1(Object obj) {\n-        switch (obj) {\n-            case final Foo(int x) -> {}\n-            default -> {}\n-        }\n-    }\n-\n-    void test2(Object obj) {\n-        switch (obj) {\n-            case Bar(final Foo(int x)) -> {}\n-            default -> {}\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/patterns\/T8317300.java","additions":0,"deletions":24,"binary":false,"changes":24,"status":"deleted"},{"patch":"@@ -1,5 +0,0 @@\n-T8317300.java:13:18: compiler.err.mod.not.allowed.here: final\n-T8317300.java:20:22: compiler.err.illegal.start.of.expr\n-T8317300.java:20:31: compiler.err.expected: token.identifier\n-T8317300.java:20:37: compiler.err.expected: ';'\n-4 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/T8317300.out","additions":0,"deletions":5,"binary":false,"changes":5,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import java.util.List;\n@@ -27,1 +28,4 @@\n-import org.junit.jupiter.api.Test;\n+\n+import org.testng.ITestResult;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.Test;\n@@ -30,1 +34,4 @@\n-class ScopeTest extends JavacTemplateTestBase {\n+import static java.util.stream.Collectors.toList;\n+\n+@Test\n+public class ScopeTest extends JavacTemplateTestBase {\n@@ -80,0 +87,8 @@\n+    @AfterMethod\n+    public void dumpTemplateIfError(ITestResult result) {\n+        \/\/ Make sure offending template ends up in log file on failure\n+        if (!result.isSuccess()) {\n+            System.err.printf(\"Diagnostics: %s%nTemplate: %s%n\", diags.errorKeys(), sourceFiles.stream().map(p -> p.snd).collect(toList()));\n+        }\n+    }\n+\n@@ -109,2 +124,1 @@\n-    @Test\n-    void testIf() {\n+    public void testIf() {\n@@ -117,2 +131,1 @@\n-    @Test\n-    void testWhile() {\n+    public void testWhile() {\n@@ -123,2 +136,1 @@\n-    @Test\n-    void testDoWhile() {\n+    public void testDoWhile() {\n@@ -129,2 +141,1 @@\n-    @Test\n-    void testFor() {\n+    public void testFor() {\n","filename":"test\/langtools\/tools\/javac\/patterns\/scope\/ScopeTest.java","additions":22,"deletions":11,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-JUnit.dirs = .\n+TestNG.dirs = .\n","filename":"test\/langtools\/tools\/javac\/patterns\/scope\/TEST.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @run junit\/othervm LocalStaticDeclarations2\n+ * @run testng\/othervm LocalStaticDeclarations2\n@@ -35,1 +35,1 @@\n-import org.junit.jupiter.api.Test;\n+import org.testng.annotations.Test;\n@@ -38,3 +38,5 @@\n-class LocalStaticDeclarations2 extends CompilationTestCase {\n-    @Test\n-    void testLocalStatic() {\n+import static org.testng.Assert.assertEquals;\n+\n+@Test\n+public class LocalStaticDeclarations2 extends CompilationTestCase {\n+    public void testLocalStatic() {\n","filename":"test\/langtools\/tools\/javac\/records\/LocalStaticDeclarations2.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,2 +42,2 @@\n- * @run junit\/othervm -DuseAP=false RecordCompilationTests\n- * @run junit\/othervm -DuseAP=true RecordCompilationTests\n+ * @run testng\/othervm -DuseAP=false RecordCompilationTests\n+ * @run testng\/othervm -DuseAP=true RecordCompilationTests\n@@ -84,0 +84,1 @@\n+import org.testng.annotations.Test;\n@@ -85,1 +86,0 @@\n-import org.junit.jupiter.api.Test;\n@@ -88,0 +88,1 @@\n+import static org.testng.Assert.assertEquals;\n@@ -101,1 +102,2 @@\n-class RecordCompilationTests extends CompilationTestCase {\n+@Test\n+public class RecordCompilationTests extends CompilationTestCase {\n@@ -129,2 +131,1 @@\n-    @Test\n-    void testMalformedDeclarations() {\n+    public void testMalformedDeclarations() {\n@@ -152,2 +153,1 @@\n-    @Test\n-    void testGoodDeclarations() {\n+    public void testGoodDeclarations() {\n@@ -183,2 +183,1 @@\n-    @Test\n-    void testGoodMemberDeclarations() {\n+    public void testGoodMemberDeclarations() {\n@@ -195,2 +194,1 @@\n-    @Test\n-    void testBadComponentNames() {\n+    public void testBadComponentNames() {\n@@ -201,2 +199,1 @@\n-    @Test\n-    void testRestrictedIdentifiers() {\n+    public void testRestrictedIdentifiers() {\n@@ -221,2 +218,1 @@\n-    @Test\n-    void testValidMembers() {\n+    public void testValidMembers() {\n@@ -233,2 +229,1 @@\n-    @Test\n-    void testCyclic() {\n+    public void testCyclic() {\n@@ -239,2 +234,1 @@\n-    @Test\n-    void testBadExtends() {\n+    public void testBadExtends() {\n@@ -248,2 +242,1 @@\n-    @Test\n-    void testNoExtendRecord() {\n+    public void testNoExtendRecord() {\n@@ -261,2 +254,1 @@\n-    @Test\n-    void testFieldDeclarations() {\n+    public void testFieldDeclarations() {\n@@ -290,2 +282,1 @@\n-    @Test\n-    void testAccessorRedeclaration() {\n+    public void testAccessorRedeclaration() {\n@@ -347,2 +338,1 @@\n-    @Test\n-    void testConstructorRedeclaration() {\n+    public void testConstructorRedeclaration() {\n@@ -439,2 +429,1 @@\n-    @Test\n-    void testAnnotationCriteria() {\n+    public void testAnnotationCriteria() {\n@@ -449,1 +438,1 @@\n-        Assert.check(goodSet.size() + badSet.size() == values().length);\n+        assertEquals(goodSet.size() + badSet.size(), values().length);\n@@ -473,2 +462,1 @@\n-    @Test\n-    void testNestedRecords() {\n+    public void testNestedRecords() {\n@@ -492,2 +480,1 @@\n-    @Test\n-    void testDuplicatedMember() {\n+    public void testDuplicatedMember() {\n@@ -502,2 +489,1 @@\n-    @Test\n-    void testStaticLocals() {\n+    public void testStaticLocals() {\n@@ -593,2 +579,1 @@\n-    @Test\n-    void testStaticDefinitionsInInnerClasses() {\n+    public void testStaticDefinitionsInInnerClasses() {\n@@ -1060,2 +1045,1 @@\n-    @Test\n-    void testReturnInCanonical_Compact() {\n+    public void testReturnInCanonical_Compact() {\n@@ -1070,2 +1054,1 @@\n-    @Test\n-    void testArgumentsAreNotFinalInCompact() {\n+    public void testArgumentsAreNotFinalInCompact() {\n@@ -1082,2 +1065,1 @@\n-    @Test\n-    void testNoNativeMethods() {\n+    public void testNoNativeMethods() {\n@@ -1090,2 +1072,1 @@\n-    @Test\n-    void testRecordsInsideInner() {\n+    public void testRecordsInsideInner() {\n@@ -1132,2 +1113,1 @@\n-    @Test\n-    void testAnnoInsideLocalOrAnonymous() {\n+    public void testAnnoInsideLocalOrAnonymous() {\n@@ -1237,2 +1217,1 @@\n-    @Test\n-    void testReceiverParameter() {\n+    public void testReceiverParameter() {\n@@ -1266,2 +1245,1 @@\n-    @Test\n-    void testOnlyOneFieldRef() throws Exception {\n+    public void testOnlyOneFieldRef() throws Exception {\n@@ -1317,2 +1295,1 @@\n-    @Test\n-    void testCheckInitializationOrderInCompactConstructor() throws Exception {\n+    public void testCheckInitializationOrderInCompactConstructor() throws Exception {\n@@ -1357,2 +1334,1 @@\n-    @Test\n-    void testAcceptRecordId() {\n+    public void testAcceptRecordId() {\n@@ -1375,2 +1351,1 @@\n-    @Test\n-    void testMultipleAnnosInRecord() throws Exception {\n+    public void testMultipleAnnosInRecord() throws Exception {\n@@ -1417,2 +1392,1 @@\n-    @Test\n-    void testAnnos() throws Exception {\n+    public void testAnnos() throws Exception {\n@@ -1561,2 +1535,1 @@\n-    @Test\n-    void testOnlyTypeAnnotationsOnComponentField() throws Exception {\n+    public void testOnlyTypeAnnotationsOnComponentField() throws Exception {\n@@ -1785,2 +1758,1 @@\n-    @Test\n-    void testMethodsInheritedFromRecordArePublicAndFinal() throws Exception {\n+    public void testMethodsInheritedFromRecordArePublicAndFinal() throws Exception {\n@@ -1805,2 +1777,1 @@\n-    @Test\n-    void testCanonicalAccessibility() throws Exception {\n+    public void testCanonicalAccessibility() throws Exception {\n@@ -1855,2 +1826,1 @@\n-    @Test\n-    void testSameArity() {\n+    public void testSameArity() {\n@@ -1930,2 +1900,1 @@\n-    @Test\n-    void testSafeVararsAnno() {\n+    public void testSafeVararsAnno() {\n@@ -1993,2 +1962,1 @@\n-    @Test\n-    void testOverrideAtAccessor() {\n+    public void testOverrideAtAccessor() {\n@@ -2032,2 +2000,1 @@\n-    @Test\n-    void testNoAssigmentInsideCompactRecord() {\n+    public void testNoAssigmentInsideCompactRecord() {\n@@ -2054,2 +2021,1 @@\n-    @Test\n-    void testNoNPEStaticAnnotatedFields() {\n+    public void testNoNPEStaticAnnotatedFields() {\n@@ -2088,2 +2054,1 @@\n-    @Test\n-    void testDoNotAllowCStyleArraySyntaxForRecComponents() {\n+    public void testDoNotAllowCStyleArraySyntaxForRecComponents() {\n@@ -2107,2 +2072,1 @@\n-    @Test\n-    void testNoWarningForSerializableRecords() {\n+    public void testNoWarningForSerializableRecords() {\n@@ -2123,2 +2087,1 @@\n-    @Test\n-    void testAnnotationsOnVarargsRecComp() {\n+    public void testAnnotationsOnVarargsRecComp() {\n@@ -2159,2 +2122,1 @@\n-    @Test\n-    void testSaveVarargsAnno() {\n+    public void testSaveVarargsAnno() {\n","filename":"test\/langtools\/tools\/javac\/records\/RecordCompilationTests.java","additions":48,"deletions":86,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,2 @@\n- * @run junit\/othervm -DuseAP=false SealedCompilationTests\n- * @run junit\/othervm -DuseAP=true SealedCompilationTests\n+ * @run testng\/othervm -DuseAP=false SealedCompilationTests\n+ * @run testng\/othervm -DuseAP=true SealedCompilationTests\n@@ -40,0 +40,4 @@\n+import java.lang.constant.ClassDesc;\n+\n+import java.io.File;\n+\n@@ -44,0 +48,2 @@\n+\n+import java.util.ArrayList;\n@@ -51,0 +57,1 @@\n+\n@@ -56,1 +63,4 @@\n-import org.junit.jupiter.api.Test;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+import org.testng.annotations.Test;\n@@ -64,3 +74,2 @@\n-import static org.junit.jupiter.api.Assertions.fail;\n-\n-class SealedCompilationTests extends CompilationTestCase {\n+@Test\n+public class SealedCompilationTests extends CompilationTestCase {\n@@ -88,1 +97,1 @@\n-    SealedCompilationTests() {\n+    public SealedCompilationTests() {\n@@ -110,2 +119,1 @@\n-    @Test\n-    void testSimpleExtension() {\n+    public void testSimpleExtension() {\n@@ -189,2 +197,1 @@\n-    @Test\n-    void testSealedAndRecords() {\n+    public void testSealedAndRecords() {\n@@ -206,2 +213,1 @@\n-    @Test\n-    void testBadExtension() {\n+    public void testBadExtension() {\n@@ -238,2 +244,1 @@\n-    @Test\n-    void testRestrictedKeyword() {\n+    public void testRestrictedKeyword() {\n@@ -287,2 +292,1 @@\n-    @Test\n-    void testRejectPermitsInNonSealedClass() {\n+    public void testRejectPermitsInNonSealedClass() {\n@@ -301,2 +305,1 @@\n-    @Test\n-    void testTypeInPermitsIsSameClassOrSuper() {\n+    public void testTypeInPermitsIsSameClassOrSuper() {\n@@ -326,2 +329,1 @@\n-    @Test\n-    void testBadModifiers() {\n+    public void testBadModifiers() {\n@@ -345,2 +347,1 @@\n-    @Test\n-    void testAnonymous_FunctionalExpr_and_Sealed() {\n+    public void testAnonymous_FunctionalExpr_and_Sealed() {\n@@ -405,2 +406,1 @@\n-    @Test\n-    void testNoLocalSealedClasses() {\n+    public void testNoLocalSealedClasses() {\n@@ -425,2 +425,1 @@\n-    @Test\n-    void testLocalCantExtendSealed() {\n+    public void testLocalCantExtendSealed() {\n@@ -458,2 +457,1 @@\n-    @Test\n-    void testSealedInterfaceAndAbstracClasses() {\n+    public void testSealedInterfaceAndAbstracClasses() {\n@@ -501,2 +499,1 @@\n-    @Test\n-    void testEnumsCantBeSealedOrNonSealed() {\n+    public void testEnumsCantBeSealedOrNonSealed() {\n@@ -517,2 +514,1 @@\n-    @Test\n-    void testEnumsCanImplementSealedInterfaces() {\n+    public void testEnumsCanImplementSealedInterfaces() {\n@@ -528,2 +524,1 @@\n-    @Test\n-    void testClassesCanExtendNonSealed() {\n+    public void testClassesCanExtendNonSealed() {\n@@ -542,2 +537,1 @@\n-    @Test\n-    void testEmptyPermits() {\n+    public void testEmptyPermits() {\n@@ -553,2 +547,1 @@\n-    @Test\n-    void testTypeVarInPermits() {\n+    public void testTypeVarInPermits() {\n@@ -565,2 +558,1 @@\n-    @Test\n-    void testRepeatedTypeInPermits() {\n+    public void testRepeatedTypeInPermits() {\n@@ -577,2 +569,1 @@\n-    @Test\n-    void testSubtypeDoesntExtendSealed() {\n+    public void testSubtypeDoesntExtendSealed() {\n@@ -602,2 +593,1 @@\n-    @Test\n-    void testAPIForPrimitiveAndArrayClasses() {\n+    public void testAPIForPrimitiveAndArrayClasses() {\n@@ -612,2 +602,1 @@\n-    @Test\n-    void testPrinting() throws Exception {\n+    public void testPrinting() throws Exception {\n@@ -729,2 +718,1 @@\n-    @Test\n-    void testNonSealedErroneousSuper() {\n+    public void testNonSealedErroneousSuper() {\n@@ -742,2 +730,1 @@\n-    @Test\n-    void testNonSealedErroneousSuperInterface() {\n+    public void testNonSealedErroneousSuperInterface() {\n@@ -755,2 +742,1 @@\n-    @Test\n-    void testIllFormedNonSealed() {\n+    public void testIllFormedNonSealed() {\n@@ -784,2 +770,1 @@\n-    @Test\n-    void testPermitsClause() {\n+    public void testPermitsClause() {\n@@ -847,2 +832,1 @@\n-    @Test\n-    void testSealedNonSealedWithOtherModifiers() {\n+    public void testSealedNonSealedWithOtherModifiers() {\n@@ -891,2 +875,1 @@\n-    @Test\n-    void testSubClassBeforeSealedClassInSameCU() {\n+    public void testSubClassBeforeSealedClassInSameCU() {\n@@ -971,2 +954,1 @@\n-    @Test\n-    void testDoNotAllowSealedAnnotation() {\n+    public void testDoNotAllowSealedAnnotation() {\n@@ -983,2 +965,1 @@\n-    @Test\n-    void testNarrowConversion() {\n+    public void testNarrowConversion() {\n@@ -1286,2 +1267,1 @@\n-    @Test\n-    void testIntersectionWithSealedClasses() {\n+    public void testIntersectionWithSealedClasses() {\n","filename":"test\/langtools\/tools\/javac\/sealed\/SealedCompilationTests.java","additions":46,"deletions":66,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,3 +56,3 @@\n-    \/\/ referrers and referrersLen go through two phases:  Building and\n-    \/\/ resolved.  When building, referrers might have duplicates, but can\n-    \/\/ be appended to.  When resolved, referrers has no duplicates or\n+    \/\/ referers and referersLen go through two phases:  Building and\n+    \/\/ resolved.  When building, referers might have duplicates, but can\n+    \/\/ be appended to.  When resolved, referers has no duplicates or\n@@ -61,2 +61,2 @@\n-    private JavaThing[] referrers = null;\n-    private int referrersLen = 0;        \/\/ -1 when resolved\n+    private JavaThing[] referers = null;\n+    private int referersLen = 0;        \/\/ -1 when resolved\n@@ -80,1 +80,1 @@\n-    \/\/ Eliminate duplicates from referrers, and size the array exactly.\n+    \/\/  Eliminate duplicates from referers, and size the array exactly.\n@@ -82,1 +82,1 @@\n-    \/\/ referrers data member for details.\n+    \/\/ referers data member for details.\n@@ -84,3 +84,3 @@\n-    void setupReferrers() {\n-        if (referrersLen > 1) {\n-            \/\/ Copy referrers to map, screening out duplicates\n+    void setupReferers() {\n+        if (referersLen > 1) {\n+            \/\/ Copy referers to map, screening out duplicates\n@@ -88,3 +88,3 @@\n-            for (int i = 0; i < referrersLen; i++) {\n-                if (map.get(referrers[i]) == null) {\n-                    map.put(referrers[i], referrers[i]);\n+            for (int i = 0; i < referersLen; i++) {\n+                if (map.get(referers[i]) == null) {\n+                    map.put(referers[i], referers[i]);\n@@ -95,2 +95,2 @@\n-            referrers = new JavaThing[map.size()];\n-            map.keySet().toArray(referrers);\n+            referers = new JavaThing[map.size()];\n+            map.keySet().toArray(referers);\n@@ -98,1 +98,1 @@\n-        referrersLen = -1;\n+        referersLen = -1;\n@@ -137,6 +137,6 @@\n-        if (referrersLen == 0) {\n-            referrers = new JavaThing[1];        \/\/ It was null\n-        } else if (referrersLen == referrers.length) {\n-            JavaThing[] copy = new JavaThing[(3 * (referrersLen + 1)) \/ 2];\n-            System.arraycopy(referrers, 0, copy, 0, referrersLen);\n-            referrers = copy;\n+        if (referersLen == 0) {\n+            referers = new JavaThing[1];        \/\/ It was null\n+        } else if (referersLen == referers.length) {\n+            JavaThing[] copy = new JavaThing[(3 * (referersLen + 1)) \/ 2];\n+            System.arraycopy(referers, 0, copy, 0, referersLen);\n+            referers = copy;\n@@ -144,2 +144,2 @@\n-        referrers[referrersLen++] = other;\n-        \/\/ We just append to referrers here.  Measurements have shown that\n+        referers[referersLen++] = other;\n+        \/\/ We just append to referers here.  Measurements have shown that\n@@ -167,2 +167,2 @@\n-    public Enumeration<JavaThing> getReferrers() {\n-        if (referrersLen != -1) {\n+    public Enumeration<JavaThing> getReferers() {\n+        if (referersLen != -1) {\n@@ -176,1 +176,1 @@\n-                return referrers != null && num < referrers.length;\n+                return referers != null && num < referers.length;\n@@ -180,1 +180,1 @@\n-                return referrers[num++];\n+                return referers[num++];\n@@ -186,1 +186,1 @@\n-     * Given other, which the caller promises is in referrers, determines if\n+     * Given other, which the caller promises is in referers, determines if\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/JavaHeapObject.java","additions":30,"deletions":30,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -49,2 +49,2 @@\n-    private long referrerId;    \/\/ Thread or Class responsible for this, or 0\n-    private int index = -1;     \/\/ Index in Snapshot.roots\n+    private long refererId;     \/\/ Thread or Class responsible for this, or 0\n+    private int index = -1;             \/\/ Index in Snapshot.roots\n@@ -53,1 +53,1 @@\n-    private JavaHeapObject referrer = null;\n+    private JavaHeapObject referer = null;\n@@ -71,2 +71,2 @@\n-    public Root(long id, long referrerId, int type, String description) {\n-        this(id, referrerId, type, description, null);\n+    public Root(long id, long refererId, int type, String description) {\n+        this(id, refererId, type, description, null);\n@@ -76,1 +76,1 @@\n-    public Root(long id, long referrerId, int type, String description,\n+    public Root(long id, long refererId, int type, String description,\n@@ -79,1 +79,1 @@\n-        this.referrerId = referrerId;\n+        this.refererId = refererId;\n@@ -140,2 +140,2 @@\n-    public JavaHeapObject getReferrer() {\n-        return referrer;\n+    public JavaHeapObject getReferer() {\n+        return referer;\n@@ -144,2 +144,2 @@\n-    public long getReferrerId() {\n-        return referrerId;\n+    public long getRefererId() {\n+        return refererId;\n@@ -164,2 +164,2 @@\n-        if (referrerId != 0) {\n-            referrer = ss.findThing(referrerId);\n+        if (refererId != 0) {\n+            referer = ss.findThing(refererId);\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/Root.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -303,1 +303,1 @@\n-            t.setupReferrers();\n+            t.setupReferers();\n@@ -464,1 +464,1 @@\n-                \/\/ referrers, because they might be more interesting.\n+                \/\/ referers, because they might be more interesting.\n@@ -466,3 +466,3 @@\n-            Enumeration<JavaThing> referrers = curr.getReferrers();\n-            while (referrers.hasMoreElements()) {\n-                JavaHeapObject t = (JavaHeapObject)referrers.nextElement();\n+            Enumeration<JavaThing> referers = curr.getReferers();\n+            while (referers.hasMoreElements()) {\n+                JavaHeapObject t = (JavaHeapObject) referers.nextElement();\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/Snapshot.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,145 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.bench.java.lang.foreign;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.TearDown;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.MemorySegment.Scope;\n-import java.lang.foreign.SegmentAllocator;\n-import java.lang.foreign.ValueLayout;\n-import java.lang.invoke.MethodHandle;\n-import java.util.concurrent.TimeUnit;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@State(org.openjdk.jmh.annotations.Scope.Thread)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n-public class AllocTest extends CLayouts {\n-\n-    Arena arena = Arena.ofConfined();\n-\n-    @Param({\"5\", \"20\", \"100\", \"500\", \"1000\"})\n-    public int size;\n-\n-    @TearDown\n-    public void tearDown() {\n-        arena.close();\n-    }\n-\n-    @Benchmark\n-    public MemorySegment alloc_confined() {\n-        Arena arena = Arena.ofConfined();\n-        MemorySegment segment = arena.allocate(size);\n-        arena.close();\n-        return segment;\n-    }\n-\n-    @Benchmark\n-    public long alloc_calloc_arena() {\n-        CallocArena arena = new CallocArena();\n-        MemorySegment segment = arena.allocate(size);\n-        arena.close();\n-        return segment.address();\n-    }\n-\n-    @Benchmark\n-    public long alloc_unsafe_arena() {\n-        UnsafeArena arena = new UnsafeArena();\n-        MemorySegment segment = arena.allocate(size);\n-        arena.close();\n-        return segment.address();\n-    }\n-\n-    public static class CallocArena implements Arena {\n-\n-        static final MethodHandle CALLOC = Linker.nativeLinker()\n-                .downcallHandle(\n-                        Linker.nativeLinker().defaultLookup().find(\"calloc\").get(),\n-                        FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG));\n-\n-        static MemorySegment calloc(long size) {\n-            try {\n-                return (MemorySegment)CALLOC.invokeExact(size, 1L);\n-            } catch (Throwable ex) {\n-                throw new IllegalStateException(ex);\n-            }\n-        }\n-\n-        final Arena arena = Arena.ofConfined();\n-\n-        @Override\n-        public Scope scope() {\n-            return arena.scope();\n-        }\n-\n-        @Override\n-        public void close() {\n-            arena.close();\n-        }\n-\n-        @Override\n-        public MemorySegment allocate(long byteSize, long byteAlignment) {\n-            return calloc(byteSize)\n-                    .reinterpret(byteSize, arena, CLayouts::freeMemory);\n-        }\n-    }\n-\n-    public static class UnsafeArena implements Arena {\n-\n-        final Arena arena = Arena.ofConfined();\n-\n-        @Override\n-        public Scope scope() {\n-            return arena.scope();\n-        }\n-\n-        @Override\n-        public void close() {\n-            arena.close();\n-        }\n-\n-        @Override\n-        public MemorySegment allocate(long byteSize, long byteAlignment) {\n-            MemorySegment segment = MemorySegment.ofAddress(Utils.unsafe.allocateMemory(byteSize));\n-            Utils.unsafe.setMemory(segment.address(), byteSize, (byte)0);\n-            return segment.reinterpret(byteSize, arena, ms -> Utils.unsafe.freeMemory(segment.address()));\n-        }\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/AllocTest.java","additions":0,"deletions":145,"binary":false,"changes":145,"status":"deleted"},{"patch":"@@ -1,161 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.java.lang.foreign;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.ValueLayout;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.TimeUnit;\n-import java.util.stream.IntStream;\n-import java.util.stream.Stream;\n-\n-import static java.lang.foreign.ValueLayout.*;\n-import static jdk.internal.foreign.StringSupport.*;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@State(Scope.Benchmark)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@Fork(value = 3, jvmArgsAppend = {\"--add-exports=java.base\/jdk.internal.foreign=ALL-UNNAMED\", \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\"})\n-public class InternalStrLen {\n-\n-    private MemorySegment singleByteSegment;\n-    private MemorySegment singleByteSegmentMisaligned;\n-    private MemorySegment doubleByteSegment;\n-    private MemorySegment quadByteSegment;\n-\n-    @Param({\"1\", \"4\", \"16\", \"251\", \"1024\"})\n-    int size;\n-\n-    @Setup\n-    public void setup() {\n-        var arena = Arena.ofAuto();\n-        singleByteSegment = arena.allocate((size + 1L) * Byte.BYTES);\n-        singleByteSegmentMisaligned = arena.allocate((size + 1L) * Byte.BYTES);\n-        doubleByteSegment = arena.allocate((size + 1L) * Short.BYTES);\n-        quadByteSegment = arena.allocate((size + 1L) * Integer.BYTES);\n-        Stream.of(singleByteSegment, doubleByteSegment, quadByteSegment)\n-                .forEach(s -> IntStream.range(0, (int) s.byteSize() - 1)\n-                        .forEach(i -> s.set(\n-                                ValueLayout.JAVA_BYTE,\n-                                i,\n-                                (byte) ThreadLocalRandom.current().nextInt(1, 254)\n-                        )));\n-        singleByteSegment.set(ValueLayout.JAVA_BYTE, singleByteSegment.byteSize() - Byte.BYTES, (byte) 0);\n-        doubleByteSegment.set(ValueLayout.JAVA_SHORT, doubleByteSegment.byteSize() - Short.BYTES, (short) 0);\n-        quadByteSegment.set(ValueLayout.JAVA_INT, quadByteSegment.byteSize() - Integer.BYTES, 0);\n-        singleByteSegmentMisaligned = arena.allocate(singleByteSegment.byteSize() + 1).\n-                asSlice(1);\n-        MemorySegment.copy(singleByteSegment, 0, singleByteSegmentMisaligned, 0, singleByteSegment.byteSize());\n-    }\n-\n-    @Benchmark\n-    public int elementSingle() {\n-        return legacy_strlen_byte(singleByteSegment, 0);\n-    }\n-\n-    @Benchmark\n-    public int elementByteMisaligned() {\n-        return legacy_strlen_byte(singleByteSegmentMisaligned, 0);\n-    }\n-\n-    @Benchmark\n-    public int elementDouble() {\n-        return legacy_strlen_short(doubleByteSegment, 0);\n-    }\n-\n-    @Benchmark\n-    public int elementQuad() {\n-        return legacy_strlen_int(quadByteSegment, 0);\n-    }\n-\n-    @Benchmark\n-    public int chunkedSingle() {\n-        return chunkedStrlenByte(singleByteSegment, 0);\n-    }\n-\n-    @Benchmark\n-    public int chunkedSingleMisaligned() {\n-        return chunkedStrlenByte(singleByteSegmentMisaligned, 0);\n-    }\n-\n-    @Benchmark\n-    public int chunkedDouble() {\n-        return chunkedStrlenShort(doubleByteSegment, 0);\n-    }\n-\n-    @Benchmark\n-    public int changedElementQuad() {\n-        return strlenInt(quadByteSegment, 0);\n-    }\n-\n-    \/\/ These are the legacy methods\n-\n-    private static int legacy_strlen_byte(MemorySegment segment, long start) {\n-        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n-        for (int offset = 0; offset >= 0; offset++) {\n-            byte curr = segment.get(JAVA_BYTE, start + offset);\n-            if (curr == 0) {\n-                return offset;\n-            }\n-        }\n-        throw new IllegalArgumentException(\"String too large\");\n-    }\n-\n-    private static int legacy_strlen_short(MemorySegment segment, long start) {\n-        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n-        for (int offset = 0; offset >= 0; offset += 2) {\n-            short curr = segment.get(JAVA_SHORT, start + offset);\n-            if (curr == 0) {\n-                return offset;\n-            }\n-        }\n-        throw new IllegalArgumentException(\"String too large\");\n-    }\n-\n-    private static int legacy_strlen_int(MemorySegment segment, long start) {\n-        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n-        for (int offset = 0; offset >= 0; offset += 4) {\n-            int curr = segment.get(JAVA_INT, start + offset);\n-            if (curr == 0) {\n-                return offset;\n-            }\n-        }\n-        throw new IllegalArgumentException(\"String too large\");\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/InternalStrLen.java","additions":0,"deletions":161,"binary":false,"changes":161,"status":"deleted"},{"patch":"@@ -1,103 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.bench.java.lang.foreign;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.TearDown;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.MemorySegment.Scope;\n-import java.lang.foreign.SegmentAllocator;\n-import java.lang.invoke.MethodHandle;\n-import java.util.concurrent.TimeUnit;\n-\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@State(org.openjdk.jmh.annotations.Scope.Thread)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n-public class ToCStringTest extends CLayouts {\n-\n-    @Param({\"5\", \"20\", \"100\", \"200\"})\n-    public int size;\n-    public String str;\n-\n-    static {\n-        System.loadLibrary(\"ToCString\");\n-    }\n-\n-    static final MethodHandle STRLEN;\n-\n-    static {\n-        Linker abi = Linker.nativeLinker();\n-        STRLEN = abi.downcallHandle(abi.defaultLookup().find(\"strlen\").get(),\n-                FunctionDescriptor.of(C_INT, C_POINTER));\n-    }\n-\n-    @Setup\n-    public void setup() {\n-        str = makeString(size);\n-    }\n-\n-    @Benchmark\n-    public long jni_writeString() throws Throwable {\n-        return writeString(str);\n-    }\n-\n-    @Benchmark\n-    public MemorySegment panama_writeString() throws Throwable {\n-        Arena arena = Arena.ofConfined();\n-        MemorySegment segment = arena.allocateFrom(str);\n-        arena.close();\n-        return segment;\n-    }\n-\n-    static native long writeString(String str);\n-\n-    static String makeString(int size) {\n-        String lorem = \"\"\"\n-                Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et\n-                 dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip\n-                 ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu\n-                 fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt\n-                 mollit anim id est laborum.\n-                \"\"\";\n-        return lorem.substring(0, size);\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ToCStringTest.java","additions":0,"deletions":103,"binary":false,"changes":103,"status":"deleted"},{"patch":"@@ -1,84 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.java.lang.foreign;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemorySegment;\n-import java.util.concurrent.TimeUnit;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@State(Scope.Benchmark)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\"})\n-public class ToJavaStringTest {\n-\n-    private MemorySegment strSegment;\n-\n-    @Param({\"5\", \"20\", \"100\", \"200\"})\n-    int size;\n-\n-    static {\n-        System.loadLibrary(\"ToJavaString\");\n-    }\n-\n-    @Setup\n-    public void setup() {\n-        var arena = Arena.ofAuto();\n-        strSegment = arena.allocateFrom(LOREM.substring(0, size));\n-    }\n-\n-    @Benchmark\n-    public String panama_readString() {\n-        return strSegment.getString(0);\n-    }\n-\n-    @Benchmark\n-    public String jni_readString() {\n-        return readString(strSegment.address());\n-    }\n-\n-    static native String readString(long addr);\n-\n-    static String LOREM = \"\"\"\n-                Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et\n-                 dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip\n-                 ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu\n-                 fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt\n-                 mollit anim id est laborum.\n-                \"\"\";\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ToJavaStringTest.java","additions":0,"deletions":84,"binary":false,"changes":84,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <jni.h>\n-#include <stdlib.h>\n-#include <string.h>\n-\n-JNIEXPORT jlong JNICALL Java_org_openjdk_bench_java_lang_foreign_ToCStringTest_writeString(JNIEnv *const env, const jclass cls, const jstring text) {\n-    const char *str = (*env)->GetStringUTFChars(env, text, NULL);\n-    jlong addr = (jlong)(void*)str;\n-    (*env)->ReleaseStringUTFChars(env, text, str);\n-    return addr;\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/libToCString.c","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <jni.h>\n-#include <stdlib.h>\n-#include <string.h>\n-\n-JNIEXPORT jstring JNICALL Java_org_openjdk_bench_java_lang_foreign_ToJavaStringTest_readString(JNIEnv *const env, const jclass cls, jlong addr) {\n-    return (*env)->NewStringUTF(env, (char*)(void*)addr);\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/libToJavaString.c","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -140,4 +140,1 @@\n-                long duration = start - SocketWriteEvent.timestamp();\n-                if (SocketWriteEvent.shouldCommit(duration)) {\n-                    SocketWriteEvent.emit(start, duration, nbytes, getRemoteAddress());\n-                }\n+                SocketWriteEvent.offer(start, nbytes, getRemoteAddress());\n@@ -161,4 +158,1 @@\n-                long duration = start - SocketReadEvent.timestamp();\n-                if (SocketReadEvent.shouldCommit(duration)) {\n-                    SocketReadEvent.emit(start, duration, nbytes, getRemoteAddress(), 0);\n-                }\n+                SocketReadEvent.offer(start, nbytes, getRemoteAddress(), 0);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/net\/SocketEventOverhead.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,220 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.vm.compiler;\n-\n-import org.openjdk.jmh.annotations.*;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-import java.util.Random;\n-import java.util.concurrent.TimeUnit;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@Measurement(iterations = 4, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n-@Warmup(iterations = 3, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n-@Fork(3)\n-public class PhiDuplicatedConversion {\n-    public static final int SIZE = 300;\n-\n-    \/\/ Ints\n-\n-    @Benchmark\n-    public void testInt2Float(Blackhole blackhole, BenchState state) {\n-        for (int i = 0; i < SIZE; i++) {\n-            blackhole.consume(i2f(state.bools[i], state.ints[i], state.ints[SIZE - 1 - i]));\n-        }\n-    }\n-\n-    @Benchmark\n-    public void testInt2Double(Blackhole blackhole, BenchState state) {\n-        for (int i = 0; i < SIZE; i++) {\n-            blackhole.consume(i2d(state.bools[i], state.ints[i], state.ints[SIZE - 1 - i]));\n-        }\n-    }\n-\n-    @Benchmark\n-    public void testInt2Long(Blackhole blackhole, BenchState state) {\n-        for (int i = 0; i < SIZE; i++) {\n-            blackhole.consume(i2l(state.bools[i], state.ints[i], state.ints[SIZE - 1 - i]));\n-        }\n-    }\n-\n-    \/\/ Floats\n-\n-    @Benchmark\n-    public void testFloat2Int(Blackhole blackhole, BenchState state) {\n-        for (int i = 0; i < SIZE; i++) {\n-            blackhole.consume(f2i(state.bools[i], state.floats[i], state.floats[SIZE - 1 - i]));\n-        }\n-    }\n-\n-    @Benchmark\n-    public void testFloat2Double(Blackhole blackhole, BenchState state) {\n-        for (int i = 0; i < SIZE; i++) {\n-            blackhole.consume(f2d(state.bools[i], state.floats[i], state.floats[SIZE - 1 - i]));\n-        }\n-    }\n-\n-    @Benchmark\n-    public void testFloat2Long(Blackhole blackhole, BenchState state) {\n-        for (int i = 0; i < SIZE; i++) {\n-            blackhole.consume(f2l(state.bools[i], state.floats[i], state.floats[SIZE - 1 - i]));\n-        }\n-    }\n-\n-    \/\/ Doubles\n-\n-    @Benchmark\n-    public void testDouble2Int(Blackhole blackhole, BenchState state) {\n-        for (int i = 0; i < SIZE; i++) {\n-            blackhole.consume(d2i(state.bools[i], state.doubles[i], state.doubles[SIZE - 1 - i]));\n-        }\n-    }\n-\n-    @Benchmark\n-    public void testDouble2Float(Blackhole blackhole, BenchState state) {\n-        for (int i = 0; i < SIZE; i++) {\n-            blackhole.consume(d2f(state.bools[i], state.doubles[i], state.doubles[SIZE - 1 - i]));\n-        }\n-    }\n-\n-    @Benchmark\n-    public void testDouble2Long(Blackhole blackhole, BenchState state) {\n-        for (int i = 0; i < SIZE; i++) {\n-            blackhole.consume(d2l(state.bools[i], state.doubles[i], state.doubles[SIZE - 1 - i]));\n-        }\n-    }\n-\n-    \/\/ Longs\n-\n-    @Benchmark\n-    public void testLong2Float(Blackhole blackhole, BenchState state) {\n-        for (int i = 0; i < SIZE; i++) {\n-            blackhole.consume(l2f(state.bools[i], state.longs[i], state.longs[SIZE - 1 - i]));\n-        }\n-    }\n-\n-    @Benchmark\n-    public void testLong2Double(Blackhole blackhole, BenchState state) {\n-        for (int i = 0; i < SIZE; i++) {\n-            blackhole.consume(l2d(state.bools[i], state.longs[i], state.longs[SIZE - 1 - i]));\n-        }\n-    }\n-\n-    @Benchmark\n-    public void testLong2Int(Blackhole blackhole, BenchState state) {\n-        for (int i = 0; i < SIZE; i++) {\n-            blackhole.consume(l2i(state.bools[i], state.longs[i], state.longs[SIZE - 1 - i]));\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public static float i2f(boolean c, int a, int b) {\n-        return c ? a : b;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public static double i2d(boolean c, int a, int b) {\n-        return c ? a : b;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public static long i2l(boolean c, int a, int b) {\n-        return c ? a : b;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public static int f2i(boolean c, float a, float b) {\n-        return c ? (int)a : (int)b;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public static double f2d(boolean c, float a, float b) {\n-        return c ? (double)a : (double)b;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public static long f2l(boolean c, float a, float b) {\n-        return c ? (long)a : (long)b;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public static int d2i(boolean c, double a, double b) {\n-        return c ? (int)a : (int)b;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public static float d2f(boolean c, double a, double b) {\n-        return c ? (float)a : (float)b;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public static long d2l(boolean c, double a, double b) {\n-        return c ? (long)a : (long)b;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public static float l2f(boolean c, long a, long b) {\n-        return c ? a : b;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public static double l2d(boolean c, long a, long b) {\n-        return c ? a : b;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public static int l2i(boolean c, long a, long b) {\n-        return c ? (int)a : (int)b;\n-    }\n-\n-    @State(Scope.Benchmark)\n-    public static class BenchState {\n-        public boolean[] bools;\n-        public int[] ints;\n-        public long[] longs;\n-        public float[] floats;\n-        public double[] doubles;\n-        public BenchState() {\n-\n-        }\n-\n-        @Setup(Level.Iteration)\n-        public void setup() {\n-            Random random = new Random(1000);\n-            bools = new boolean[SIZE];\n-            ints = new int[SIZE];\n-            longs = new long[SIZE];\n-            floats = new float[SIZE];\n-            doubles = new double[SIZE];\n-\n-            for (int i = 0; i < SIZE; i++) {\n-                bools[i] = random.nextBoolean();\n-                ints[i] = random.nextInt(100);\n-                longs[i] = random.nextLong(100);\n-                floats[i] = random.nextFloat(100);\n-                doubles[i] = random.nextDouble(100);\n-            }\n-        }\n-    }\n-}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/PhiDuplicatedConversion.java","additions":0,"deletions":220,"binary":false,"changes":220,"status":"deleted"}]}