{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,0 +75,34 @@\n+\n+    \/**\n+     * {@return a representation of the provided {@code uncaptured} lambda or method reference\n+     * in the form of a {@code BiConsumer}}\n+     * <p>\n+     * This method is useful in cases where there is an ambiguity in a lambda or method reference\n+     * or when using composition or fluent coding as shown in this example:\n+     * {@snippet :\n+     * void toConsole(long id, String message) {\n+     *      System.out.format(\"%d = %s%n\", id, message);\n+     * }\n+     *\n+     * void toLogger(long id, String message) {\n+     *      LOGGER.info(String.format(\"%d = %s\", id, message));\n+     * }\n+     *\n+     * \/\/ Capturing\n+     * var con = BiConsumer.of(this::toConsole); \/\/ BiConsumer<Long, String>\n+     *\n+     *  \/\/ Fluent composition\n+     * var composed = BiConsumer.of(this::toConsole)\n+     *                    .andThen(this::toLogger);  \/\/ BiConsumer<Long, String>\n+     *\n+     * }\n+     *\n+     * @param uncaptured to capture\n+     * @param <T> the type of the first argument to the operation\n+     * @param <U> the type of the second argument to the operation\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    static <T, U> BiConsumer<T, U> of(BiConsumer<? super T, ? super U> uncaptured) {\n+        return (BiConsumer<T, U>) Objects.requireNonNull(uncaptured);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/function\/BiConsumer.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,0 +72,27 @@\n+\n+    \/**\n+     * {@return a representation of the provided {@code uncaptured} lambda or method reference\n+     * in the form of a {@code BiFunction}}\n+     * <p>\n+     * This method is useful in cases where there is an ambiguity in a lambda or method reference\n+     * or when using composition or fluent coding as shown in this example:\n+     * {@snippet :\n+     * \/\/ Resolve ambiguity\n+     * var function = BiFunction.of(String::endsWith);   \/\/ BiFunction<String, String, Boolean>\n+     * var predicate = BiPredicate.of(String::endsWith); \/\/ BiPredicate<String, String>\n+     *\n+     * \/\/ Fluent composition\n+     * var chained = BiFunction.of(String::repeat)     \/\/ BiFunction<String, Integer, String>\n+     *                   .andThen(String::length);     \/\/ Function<String, Integer>\n+     * }\n+     *\n+     * @param uncaptured to capture\n+     * @param <T> the type of the first argument to the function\n+     * @param <U> the type of the second argument to the function\n+     * @param <R> the type of the result of the function\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    static <T, U, R> BiFunction<T, U, R> of(BiFunction<? super T, ? super U, ? extends R> uncaptured) {\n+        return (BiFunction<T, U, R>) Objects.requireNonNull(uncaptured);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/function\/BiFunction.java","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,0 +107,26 @@\n+\n+    \/**\n+     * {@return a representation of the provided {@code uncaptured} lambda or method reference\n+     * in the form of a {@code BinaryOperator}}\n+     * <p>\n+     * This method is useful in cases where there is an ambiguity in a lambda or method reference\n+     * or when using composition or fluent coding as shown in this example:\n+     * {@snippet :\n+     * \/\/ Resolve ambiguity\n+     * var biFunction = BiFunction.of(String::equals);     \/\/ BiFunction<String, Object, Boolean>\n+     * var biPredicate = BiPredicate.of(String::equals);   \/\/ BiPredicate<Integer, Object>\n+     *\n+     * \/\/ Fluent composition\n+     * var composed = BiPredicate.of(String::endsWith)     \/\/ BiPredicate<String, String>\n+     *                    .or(String::startsWith);         \/\/ BiPredicate<String, String>\n+     *}\n+     *\n+     * @param uncaptured to capture\n+     * @param <T> the type of the first argument to the predicate\n+     * @param <U> the type of the second argument the predicate\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    static <T, U> BiPredicate<T, U> of(BiPredicate<? super T, ? super U> uncaptured) {\n+        return (BiPredicate<T, U>) Objects.requireNonNull(uncaptured);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/function\/BiPredicate.java","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,0 +76,23 @@\n+\n+    \/**\n+     * {@return a representation of the provided {@code uncaptured} lambda or method reference\n+     * in the form of a {@code BinaryOperator}}\n+     * <p>\n+     * This method is useful in cases where there is an ambiguity in a lambda or method reference\n+     * or when using composition or fluent coding as shown in this example:\n+     * {@snippet :\n+     * \/\/ Resolve ambiguity\n+     * var biFunction = BiFunction.of(Integer::sum);        \/\/ BiFunction<Integer, Integer, Integer>\n+     * var unaryOperator = BinaryOperator.of(Integer::sum); \/\/ BinaryOperator<Integer>\n+     *\n+     * \/\/ Fluent composition\n+     * var composed = BinaryOperator.of(Integer::sum)     \/\/ BinaryOperator<Integer>\n+     *                    .andThen(Integer::toHexString); \/\/ BiFunction<Integer, Integer, String>\n+     * }\n+     *\n+     * @param uncaptured to capture\n+     * @param <T> the type of the operands and result of the operator\n+     *\/\n+    static <T> BinaryOperator<T> of(BinaryOperator<T> uncaptured) {\n+        return Objects.requireNonNull(uncaptured);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/function\/BinaryOperator.java","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,0 +67,25 @@\n+\n+    \/**\n+     * {@return a representation of the provided {@code uncaptured} lambda or method reference\n+     * in the form of a {@code Consumer}}\n+     * <p>\n+     * This method is useful in cases where there is an ambiguity in a lambda or method reference\n+     * or when using composition or fluent coding as shown in this example:\n+     * {@snippet :\n+     * List<String> list = new ArrayList<>();\n+     *\n+     * var con = Consumer.of(list::addLast); \/\/ Consumer<String>\n+     *\n+     * \/\/ Fluent composition\n+     * var composed = Consumer.of(list::addLast)       \/\/ Consumer<String>\n+     *                    .andThen(System.out::print); \/\/ Consumer<String>\n+     *}\n+     *\n+     * @param uncaptured to capture\n+     * @param <T> the type of the input to the operation\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    static <T> Consumer<T> of(Consumer<? super T> uncaptured) {\n+        return (Consumer<T>) Objects.requireNonNull(uncaptured);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/function\/Consumer.java","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,0 +100,26 @@\n+\n+    \/**\n+     * {@return a representation of the provided {@code uncaptured} lambda or method reference\n+     * in the form of a {@code Function}}\n+     * <p>\n+     * This method is useful in cases where there is an ambiguity in a lambda or method reference\n+     * or when using composition or fluent coding as shown in these examples:\n+     * {@snippet :\n+     * \/\/ Resolve ambiguity\n+     * var function = Function.of(String::isEmpty); \/\/ Function<String, Boolean>\n+     * var predicate = Predicate.of(String::isEmpty); \/\/ Predicate<String>\n+     *\n+     * \/\/ Fluent composition\n+     * var chained = Function.of(String::length)       \/\/ Function<String, Integer>\n+     *                   .andThen(Integer::byteValue); \/\/ Function<String, Byte>\n+     * }\n+     *\n+     * @param uncaptured to capture\n+     * @param <T> the type of the input to the function\n+     * @param <R> the type of the result of the function\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    static <T, R> Function<T, R> of(Function<? super T, ? extends R> uncaptured) {\n+        return (Function<T, R>) Objects.requireNonNull(uncaptured);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/function\/Function.java","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -140,0 +140,25 @@\n+\n+    \/**\n+     * {@return a representation of the provided {@code uncaptured} lambda or method reference\n+     * in the form of a {@code Predicate}}\n+     * <p>\n+     * This method is useful in cases where there is an ambiguity of a lambda or method reference\n+     * or when using composition and\/or fluent coding as shown in this example:\n+     * {@snippet :\n+     * \/\/ Resolve ambiguity\n+     * var function = Function.of(String::isEmpty);   \/\/ Function<String, Boolean>\n+     * var predicate = Predicate.of(String::isEmpty); \/\/ Predicate<String>\n+     *\n+     * \/\/ Fluent composition\n+     * var composed = Predicate.of(String::isEmpty)\n+     *                   .or(s -> s.startsWith(\"*\")); \/\/ Predicate<String>\n+     * }\n+     *\n+     * @param uncaptured to capture\n+     * @param <T> the type of the input to the predicate\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    static <T> Predicate<T> of(Predicate<? super T> uncaptured) {\n+        return (Predicate<T>) Objects.requireNonNull(uncaptured);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/function\/Predicate.java","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import java.util.Objects;\n+\n@@ -52,0 +54,42 @@\n+\n+    \/**\n+     * Returns a composed function that first applies this unary operator to\n+     * its input, and then applies the {@code after} unary function to the result.\n+     * If evaluation of either function throws an exception, it is relayed to\n+     * the caller of the composed function.\n+     *\n+     * @param after the unary operator to apply after this unary operator is applied\n+     * @return a composed unary operator that first applies this function and then\n+     * applies the {@code after} unary operator\n+     * @throws NullPointerException if after is null\n+     *\n+     * @see Function#andThen(Function)\n+     *\/\n+    default UnaryOperator<T> andThenUnary(UnaryOperator<T> after) {\n+        Objects.requireNonNull(after);\n+        return (T t) -> after.apply(apply(t));\n+    }\n+\n+    \/**\n+     * {@return a representation of the provided {@code uncaptured} lambda or method reference\n+     * in the form of a {@code UnaryOperator}}\n+     * <p>\n+     * This method is useful in cases where there is an ambiguity of a lambda or method reference\n+     * or when using composition and\/or fluent coding as shown in this example:\n+     * {@snippet :\n+     * \/\/ Resolve ambiguity\n+     * var function = Function.of(String::stripTrailing); \/\/ Function<String, String>\n+     * var unaryOperator = UnaryOperator.of(String::stripTrailing); \/\/ UnaryOperator<String>\n+     *\n+     * \/\/ Fluent composition\n+     * var composed = UnaryOperator.of(String::stripTrailing)\n+     *                    .andThenUnary(String::stripIndent);  \/\/ UnaryOperator<String>\n+     * }\n+     *\n+     * @param uncaptured to capture\n+     * @param <T> the type of the operand and result of the operator\n+     *\/\n+    static <T> UnaryOperator<T> of(UnaryOperator<T> uncaptured) {\n+        return Objects.requireNonNull(uncaptured);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/function\/UnaryOperator.java","additions":45,"deletions":1,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -0,0 +1,203 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test capturing factories for functional interfaces\n+ * @run junit CapturingFactoriesTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.BiPredicate;\n+import java.util.function.BinaryOperator;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class CapturingFactoriesTest {\n+\n+    @Test\n+    void nullTests() {\n+        assertThrows(NullPointerException.class, () -> BiConsumer.of(null));\n+        assertThrows(NullPointerException.class, () -> BiFunction.of(null));\n+        assertThrows(NullPointerException.class, () -> BinaryOperator.of(null));\n+        assertThrows(NullPointerException.class, () -> BiPredicate.of(null));\n+        assertThrows(NullPointerException.class, () -> Consumer.of(null));\n+        assertThrows(NullPointerException.class, () -> Function.of(null));\n+        assertThrows(NullPointerException.class, () -> Predicate.of(null));\n+        assertThrows(NullPointerException.class, () -> UnaryOperator.of(null));\n+    }\n+\n+    \/\/ The tests below reflect the JavaDoc examples\n+\n+    @Test\n+    void biConsumer() {\n+\n+        \/\/ Capturing\n+        var con = BiConsumer.of(CapturingFactoriesTest::toConsole); \/\/ BiConsumer<Long, String>\n+\n+        \/\/ Fluent composition\n+        var composed = BiConsumer.of(CapturingFactoriesTest::toConsole)\n+                .andThen(CapturingFactoriesTest::toLogger);  \/\/ BiConsumer<Long, String>\n+\n+        assertDoesNotThrow(() -> composed.accept(42L, \"A\"));\n+    }\n+\n+    @Test\n+    void biFunction() {\n+      \/\/ Resolve ambiguity\n+      var function = BiFunction.of(String::endsWith);   \/\/ BiFunction<String, String, Boolean>\n+      var predicate = BiPredicate.of(String::endsWith); \/\/ BiPredicate<String, String>\n+\n+      \/\/ Fluent composition\n+      var chained = BiFunction.of(String::repeat)     \/\/ BiFunction<String, Integer, String>\n+                                   .andThen(String::length);     \/\/ Function<String, Integer>\n+\n+      assertEquals(4, chained.apply(\"AB\", 2));\n+    }\n+\n+    @Test\n+    void binaryOperator() {\n+        \/\/ Resolve ambiguity\n+        var biFunction = BiFunction.of(Integer::sum);        \/\/ BiFunction<Integer, Integer, Integer>\n+        var unaryOperator = BinaryOperator.of(Integer::sum); \/\/ BinaryOperator<Integer>\n+\n+        \/\/ Fluent composition\n+        var composed = BinaryOperator.of(Integer::sum)     \/\/ BinaryOperator<Integer>\n+                .andThen(Integer::toHexString); \/\/ BiFunction<Integer, Integer, String>\n+\n+        assertEquals(\"f\", composed.apply(14, 1));\n+    }\n+\n+    @Test\n+    void biPredicate() {\n+        var biFunction = BiFunction.of(String::equals);      \/\/ BiFunction<String, Object, Boolean>\n+        var biPredicate = BiPredicate.of(String::equals);    \/\/ BiPredicate<Integer, Object>\n+\n+        \/\/ Fluent composition\n+        var composed = BiPredicate.of(String::endsWith)     \/\/ BiPredicate<String, String>\n+                .or(String::startsWith);                    \/\/ BiPredicate<String, String>\n+\n+        assertTrue(composed.test(\"abc\", \"c\"));\n+        assertTrue(composed.test(\"abc\", \"a\"));\n+        assertFalse(composed.test(\"abc\", \"b\"));\n+    }\n+\n+    @Test\n+    void consumer() {\n+      List<String> list = new ArrayList<>();\n+\n+      \/\/ Capturing\n+      var con = Consumer.of(list::addLast); \/\/ Consumer<String>\n+\n+\n+      \/\/ Fluent composition\n+      var composed = Consumer.of(list::addLast)       \/\/ Consumer<String>\n+                         .andThen(System.out::print); \/\/ Consumer<String>\n+\n+    }\n+\n+    @Test\n+    void function() {\n+        var function = Function.of(String::isEmpty); \/\/ Function<String, Boolean>\n+        var predicate = Predicate.of(String::isEmpty); \/\/ Predicate<String>\n+\n+        \/\/ Fluent composition\n+        var chained = Function.of(String::length)  \/\/ Function<String, Integer>\n+                .andThen(Integer::byteValue);      \/\/ Function<String, Byte>\n+\n+        assertEquals((byte) 3, chained.apply(\"abc\"));\n+    }\n+\n+    @Test\n+    void predicate() {\n+        \/\/ Resolve ambiguity\n+        var function = Function.of(String::isEmpty); \/\/ Function<String, Boolean>\n+        var predicate = Predicate.of(String::isEmpty); \/\/ Predicate<String>\n+\n+        \/\/ Fluent composition\n+        var composed = Predicate.of(String::isEmpty)\n+                .or(s -> s.startsWith(\"*\")); \/\/ Predicate<String>\n+\n+        assertTrue(composed.test(\"\"));\n+        assertTrue(composed.test(\"*Star\"));\n+        assertFalse(composed.test(\"Tryggve\"));\n+    }\n+\n+    @Test\n+    void unaryOperator() {\n+        var function = Function.of(String::stripTrailing); \/\/ Function<String, String>\n+        var unaryOperator = UnaryOperator.of(String::stripTrailing); \/\/ UnaryOperator<String>\n+\n+        \/\/ Fluent composition\n+        var composed = UnaryOperator.of(String::stripTrailing)\n+                .andThenUnary(String::stripIndent);  \/\/ UnaryOperator<String>\n+\n+        assertEquals(\"a\", composed.apply(\" a \"));\n+    }\n+\n+\n+    @Test\n+    void coVariants() {\n+        var function = Function.of(Number::toString);                \/\/ Function<Number, String>\n+        Function<Integer, String> sFunction = Function.of(function); \/\/ Function<String, String>\n+        var sFunction2 = Function.of(function);                      \/\/ Function<Number, String>\n+    }\n+\n+    @Test\n+    void contraVariants() {\n+        var function = Function.of(Object::toString);                \/\/ Function<Object, String>\n+        Function<String, String> sFunction = Function.of(function);  \/\/ Function<String, String>\n+        var sFunction2 = Function.of(function);                      \/\/ Function<Object, String>\n+    }\n+\n+    \/\/ Methods\n+\n+    static boolean not(boolean original) {\n+        return !original;\n+    }\n+\n+    static int not(int original) {\n+        return ~original;\n+    }\n+\n+    static boolean not(Object o) {\n+        return false;\n+    }\n+\n+    static void toConsole(long id, String message) {\n+    }\n+\n+    static void toLogger(long id, String message) {\n+    }\n+\n+\n+}\n","filename":"test\/jdk\/java\/util\/function\/CapturingFactoriesTest.java","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"}]}