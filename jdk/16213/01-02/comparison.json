{"files":[{"patch":"@@ -77,1 +77,1 @@\n-     * {@return a representation of the provided {@code uncaptured} lambda or method reference\n+     * {@return a representation of the provided {@code source} construct\n@@ -80,2 +80,3 @@\n-     * This method is useful in cases where there is an ambiguity in a lambda or method reference\n-     * or when using composition or fluent coding as shown in this example:\n+     * This method is particularly useful in cases where there is; an ambiguity\n+     * in a lambda or method reference, when inferring a local-variable type or\n+     * when using composition or fluent coding as shown in these examples:\n@@ -91,1 +92,1 @@\n-     * \/\/ Capturing\n+     * \/\/ Inferring\n@@ -100,1 +101,1 @@\n-     * @param uncaptured to capture\n+     * @param source to convert\n@@ -103,0 +104,1 @@\n+     * @throws NullPointerException if source is null\n@@ -105,2 +107,2 @@\n-    static <T, U> BiConsumer<T, U> of(BiConsumer<? super T, ? super U> uncaptured) {\n-        return (BiConsumer<T, U>) Objects.requireNonNull(uncaptured);\n+    static <T, U> BiConsumer<T, U> of(BiConsumer<? super T, ? super U> source) {\n+        return (BiConsumer<T, U>) Objects.requireNonNull(source);\n","filename":"src\/java.base\/share\/classes\/java\/util\/function\/BiConsumer.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-     * {@return a representation of the provided {@code uncaptured} lambda or method reference\n+     * {@return a representation of the provided {@code source} construct\n@@ -77,2 +77,3 @@\n-     * This method is useful in cases where there is an ambiguity in a lambda or method reference\n-     * or when using composition or fluent coding as shown in this example:\n+     * This method is particularly useful in cases where there is; an ambiguity\n+     * in a lambda or method reference, when inferring a local-variable type or\n+     * when using composition or fluent coding as shown in these examples:\n@@ -80,1 +81,1 @@\n-     * \/\/ Resolve ambiguity\n+     * \/\/ Inferring and resolving ambiguity\n@@ -89,1 +90,1 @@\n-     * @param uncaptured to capture\n+     * @param source to convert\n@@ -93,0 +94,1 @@\n+     * @throws NullPointerException if source is null\n@@ -95,2 +97,2 @@\n-    static <T, U, R> BiFunction<T, U, R> of(BiFunction<? super T, ? super U, ? extends R> uncaptured) {\n-        return (BiFunction<T, U, R>) Objects.requireNonNull(uncaptured);\n+    static <T, U, R> BiFunction<T, U, R> of(BiFunction<? super T, ? super U, ? extends R> source) {\n+        return (BiFunction<T, U, R>) Objects.requireNonNull(source);\n","filename":"src\/java.base\/share\/classes\/java\/util\/function\/BiFunction.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -109,2 +109,2 @@\n-     * {@return a representation of the provided {@code uncaptured} lambda or method reference\n-     * in the form of a {@code BinaryOperator}}\n+     * {@return a representation of the provided {@code source} construct\n+     * in the form of a {@code BiPredicate}}\n@@ -112,2 +112,3 @@\n-     * This method is useful in cases where there is an ambiguity in a lambda or method reference\n-     * or when using composition or fluent coding as shown in this example:\n+     * This method is particularly useful in cases where there is; an ambiguity\n+     * in a lambda or method reference, when inferring a local-variable type or\n+     * when using composition or fluent coding as shown in these examples:\n@@ -115,1 +116,1 @@\n-     * \/\/ Resolve ambiguity\n+     * \/\/ Inferring and resolving ambiguity\n@@ -124,1 +125,1 @@\n-     * @param uncaptured to capture\n+     * @param source to convert\n@@ -127,0 +128,1 @@\n+     * @throws NullPointerException if source is null\n@@ -129,2 +131,2 @@\n-    static <T, U> BiPredicate<T, U> of(BiPredicate<? super T, ? super U> uncaptured) {\n-        return (BiPredicate<T, U>) Objects.requireNonNull(uncaptured);\n+    static <T, U> BiPredicate<T, U> of(BiPredicate<? super T, ? super U> source) {\n+        return (BiPredicate<T, U>) Objects.requireNonNull(source);\n","filename":"src\/java.base\/share\/classes\/java\/util\/function\/BiPredicate.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-     * {@return a representation of the provided {@code uncaptured} lambda or method reference\n+     * {@return a representation of the provided {@code source} construct\n@@ -81,2 +81,3 @@\n-     * This method is useful in cases where there is an ambiguity in a lambda or method reference\n-     * or when using composition or fluent coding as shown in this example:\n+     * This method is particularly useful in cases where there is; an ambiguity\n+     * in a lambda or method reference, when inferring a local-variable type or\n+     * when using composition or fluent coding as shown in these examples:\n@@ -84,1 +85,1 @@\n-     * \/\/ Resolve ambiguity\n+     * \/\/ Inferring and resolving ambiguity\n@@ -93,1 +94,1 @@\n-     * @param uncaptured to capture\n+     * @param source to convert\n@@ -95,0 +96,1 @@\n+     * @throws NullPointerException if source is null\n@@ -96,2 +98,2 @@\n-    static <T> BinaryOperator<T> of(BinaryOperator<T> uncaptured) {\n-        return Objects.requireNonNull(uncaptured);\n+    static <T> BinaryOperator<T> of(BinaryOperator<T> source) {\n+        return Objects.requireNonNull(source);\n","filename":"src\/java.base\/share\/classes\/java\/util\/function\/BinaryOperator.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-     * {@return a representation of the provided {@code uncaptured} lambda or method reference\n+     * {@return a representation of the provided {@code source} construct\n@@ -72,2 +72,3 @@\n-     * This method is useful in cases where there is an ambiguity in a lambda or method reference\n-     * or when using composition or fluent coding as shown in this example:\n+     * This method is particularly useful in cases where there is; an ambiguity\n+     * in a lambda or method reference, when inferring a local-variable type or\n+     * when using composition or fluent coding as shown in these examples:\n@@ -77,0 +78,1 @@\n+     * \/\/ Inferring\n@@ -84,1 +86,1 @@\n-     * @param uncaptured to capture\n+     * @param source to convert\n@@ -86,0 +88,1 @@\n+     * @throws NullPointerException if source is null\n@@ -88,2 +91,2 @@\n-    static <T> Consumer<T> of(Consumer<? super T> uncaptured) {\n-        return (Consumer<T>) Objects.requireNonNull(uncaptured);\n+    static <T> Consumer<T> of(Consumer<? super T> source) {\n+        return (Consumer<T>) Objects.requireNonNull(source);\n","filename":"src\/java.base\/share\/classes\/java\/util\/function\/Consumer.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-     * {@return a representation of the provided {@code uncaptured} lambda or method reference\n+     * {@return a representation of the provided {@code source} construct\n@@ -105,2 +105,3 @@\n-     * This method is useful in cases where there is an ambiguity in a lambda or method reference\n-     * or when using composition or fluent coding as shown in these examples:\n+     * This method is particularly useful in cases where there is; an ambiguity\n+     * in a lambda or method reference, when inferring a local-variable type or\n+     * when using composition or fluent coding as shown in these examples:\n@@ -108,3 +109,3 @@\n-     * \/\/ Resolve ambiguity\n-     * var function = Function.of(String::isEmpty); \/\/ Function<String, Boolean>\n-     * var predicate = Predicate.of(String::isEmpty); \/\/ Predicate<String>\n+     * \/\/ Inferring and resolving ambiguity\n+     * var function = Function.of(String::isEmpty);    \/\/ Function<String, Boolean>\n+     * var predicate = Predicate.of(String::isEmpty);  \/\/ Predicate<String>\n@@ -117,1 +118,1 @@\n-     * @param uncaptured to capture\n+     * @param source to convert\n@@ -120,0 +121,1 @@\n+     * @throws NullPointerException if source is null\n@@ -122,2 +124,2 @@\n-    static <T, R> Function<T, R> of(Function<? super T, ? extends R> uncaptured) {\n-        return (Function<T, R>) Objects.requireNonNull(uncaptured);\n+    static <T, R> Function<T, R> of(Function<? super T, ? extends R> source) {\n+        return (Function<T, R>) Objects.requireNonNull(source);\n","filename":"src\/java.base\/share\/classes\/java\/util\/function\/Function.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-     * {@return a representation of the provided {@code uncaptured} lambda or method reference\n+     * {@return a representation of the provided {@code source} construct\n@@ -145,2 +145,3 @@\n-     * This method is useful in cases where there is an ambiguity of a lambda or method reference\n-     * or when using composition and\/or fluent coding as shown in this example:\n+     * This method is particularly useful in cases where there is; an ambiguity\n+     * in a lambda or method reference, when inferring a local-variable type or\n+     * when using composition or fluent coding as shown in these examples:\n@@ -148,1 +149,1 @@\n-     * \/\/ Resolve ambiguity\n+     * \/\/ Inferring and resolving ambiguity\n@@ -157,1 +158,1 @@\n-     * @param uncaptured to capture\n+     * @param source to convert\n@@ -159,0 +160,1 @@\n+     * @throws NullPointerException if source is null\n@@ -161,2 +163,2 @@\n-    static <T> Predicate<T> of(Predicate<? super T> uncaptured) {\n-        return (Predicate<T>) Objects.requireNonNull(uncaptured);\n+    static <T> Predicate<T> of(Predicate<? super T> source) {\n+        return (Predicate<T>) Objects.requireNonNull(source);\n","filename":"src\/java.base\/share\/classes\/java\/util\/function\/Predicate.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-     * {@return a representation of the provided {@code uncaptured} lambda or method reference\n+     * {@return a representation of the provided {@code source} construct\n@@ -77,2 +77,3 @@\n-     * This method is useful in cases where there is an ambiguity of a lambda or method reference\n-     * or when using composition and\/or fluent coding as shown in this example:\n+     * This method is particularly useful in cases where there is; an ambiguity\n+     * in a lambda or method reference, when inferring a local-variable type or\n+     * when using composition or fluent coding as shown in these examples:\n@@ -80,1 +81,1 @@\n-     * \/\/ Resolve ambiguity\n+     * \/\/ \/\/ Inferring and resolving ambiguity\n@@ -89,1 +90,1 @@\n-     * @param uncaptured to capture\n+     * @param source to convert\n@@ -91,0 +92,1 @@\n+     * @throws NullPointerException if source is null\n@@ -92,2 +94,2 @@\n-    static <T> UnaryOperator<T> of(UnaryOperator<T> uncaptured) {\n-        return Objects.requireNonNull(uncaptured);\n+    static <T> UnaryOperator<T> of(UnaryOperator<T> source) {\n+        return Objects.requireNonNull(source);\n","filename":"src\/java.base\/share\/classes\/java\/util\/function\/UnaryOperator.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"}]}