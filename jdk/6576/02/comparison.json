{"files":[{"patch":"@@ -13132,0 +13132,18 @@\n+instruct cmovLL_reg_LTGE_U(cmpOpU cmp, flagsReg_ulong_LTGE flags, eRegL dst, eRegL src) %{\n+  match(Set dst (CMoveL (Binary cmp flags) (Binary dst src)));\n+  predicate(VM_Version::supports_cmov() && ( _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::lt || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::ge ));\n+  ins_cost(400);\n+  expand %{\n+    cmovLL_reg_LTGE(cmp, flags, dst, src);\n+  %}\n+%}\n+\n+instruct cmovLL_mem_LTGE_U(cmpOpU cmp, flagsReg_ulong_LTGE flags, eRegL dst, load_long_memory src) %{\n+  match(Set dst (CMoveL (Binary cmp flags) (Binary dst (LoadL src))));\n+  predicate(VM_Version::supports_cmov() && ( _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::lt || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::ge ));\n+  ins_cost(500);\n+  expand %{\n+    cmovLL_mem_LTGE(cmp, flags, dst, src);\n+  %}\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3466,1 +3466,1 @@\n-    assert(!n->as_Loop()->is_transformed_long_inner_loop() || _loop_opts_cnt == 0, \"should have been turned into a counted loop\");\n+    assert(!n->as_Loop()->is_loop_nest_inner_loop() || _loop_opts_cnt == 0, \"should have been turned into a counted loop\");\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1068,1 +1068,1 @@\n-bool IdealLoopTree::policy_range_check(PhaseIdealLoop* phase, bool provisional) const {\n+bool IdealLoopTree::policy_range_check(PhaseIdealLoop* phase, bool provisional, BasicType bt) const {\n@@ -1090,1 +1090,1 @@\n-  BasicType bt = cl->bt();\n+  assert(!cl->is_LongCountedLoop() || bt == T_LONG, \"only long range checks in long counted loops\");\n@@ -1138,1 +1138,1 @@\n-        if (!phase->is_scaled_iv_plus_offset(rc_exp, trip_counter, NULL, NULL)) {\n+        if (!phase->is_scaled_iv_plus_offset(rc_exp, trip_counter, NULL, NULL, bt)) {\n@@ -1148,1 +1148,3 @@\n-        return provisional || phase->may_require_nodes(est_loop_clone_sz(2));\n+        \/\/ Long range checks cause the loop to be transformed in a loop nest which only causes a fixed number of nodes\n+        \/\/ to be added\n+        return provisional || bt == T_LONG || phase->may_require_nodes(est_loop_clone_sz(2));\n@@ -2477,0 +2479,11 @@\n+bool PhaseIdealLoop::is_iv(Node* exp, Node* iv, BasicType bt) {\n+  if (exp == iv) {\n+    return true;\n+  }\n+\n+  if (bt == T_LONG && iv->bottom_type()->isa_int() && exp->Opcode() == Op_ConvI2L && exp->in(1) == iv) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n@@ -2479,1 +2492,1 @@\n-bool PhaseIdealLoop::is_scaled_iv(Node* exp, Node* iv, jlong* p_scale, BasicType bt) {\n+bool PhaseIdealLoop::is_scaled_iv(Node* exp, Node* iv, jlong* p_scale, BasicType bt, bool* converted) {\n@@ -2482,1 +2495,1 @@\n-  if (exp == iv) {\n+  if (is_iv(exp, iv, bt)) {\n@@ -2488,0 +2501,7 @@\n+  if (bt == T_LONG && iv->bottom_type()->isa_int() && exp->Opcode() == Op_ConvI2L) {\n+    exp = exp->in(1);\n+    bt = T_INT;\n+    if (converted != NULL) {\n+      *converted = true;\n+    }\n+  }\n@@ -2491,1 +2511,1 @@\n-    if (exp->in(1)->uncast() == iv && exp->in(2)->is_Con()) {\n+    if (is_iv(exp->in(1)->uncast(), iv, bt) && exp->in(2)->is_Con()) {\n@@ -2497,1 +2517,1 @@\n-    if (exp->in(2)->uncast() == iv && exp->in(1)->is_Con()) {\n+    if (is_iv(exp->in(2)->uncast(), iv, bt) && exp->in(1)->is_Con()) {\n@@ -2504,1 +2524,1 @@\n-    if (exp->in(1)->uncast() == iv && exp->in(2)->is_Con()) {\n+    if (is_iv(exp->in(1)->uncast(), iv, bt) && exp->in(2)->is_Con()) {\n@@ -2521,1 +2541,1 @@\n-bool PhaseIdealLoop::is_scaled_iv_plus_offset(Node* exp, Node* iv, jlong* p_scale, Node** p_offset, BasicType bt, int depth) {\n+bool PhaseIdealLoop::is_scaled_iv_plus_offset(Node* exp, Node* iv, jlong* p_scale, Node** p_offset, BasicType bt, bool* converted, int depth) {\n@@ -2523,1 +2543,1 @@\n-  if (is_scaled_iv(exp, iv, p_scale, bt)) {\n+  if (is_scaled_iv(exp, iv, p_scale, bt, converted)) {\n@@ -2533,1 +2553,1 @@\n-    if (is_scaled_iv(exp->in(1), iv, p_scale, bt)) {\n+    if (is_scaled_iv(exp->in(1), iv, p_scale, bt, converted)) {\n@@ -2539,1 +2559,1 @@\n-    if (is_scaled_iv(exp->in(2), iv, p_scale, bt)) {\n+    if (is_scaled_iv(exp->in(2), iv, p_scale, bt, converted)) {\n@@ -2549,1 +2569,1 @@\n-                                   p_offset != NULL ? &offset2 : NULL, bt, depth+1)) {\n+                                   p_offset != NULL ? &offset2 : NULL, bt, converted, depth+1)) {\n@@ -2560,1 +2580,1 @@\n-    if (is_scaled_iv(exp->in(1), iv, p_scale, bt)) {\n+    if (is_scaled_iv(exp->in(1), iv, p_scale, bt, converted)) {\n@@ -2571,1 +2591,1 @@\n-    if (is_scaled_iv(exp->in(2), iv, p_scale, bt)) {\n+    if (is_scaled_iv(exp->in(2), iv, p_scale, bt, converted)) {\n@@ -3400,0 +3420,2 @@\n+    } else if (_head->is_LongCountedLoop()) {\n+      phase->create_loop_nest(this, old_new);\n@@ -3443,1 +3465,2 @@\n-  bool should_rce    = policy_range_check(phase, false);\n+  bool should_rce    = policy_range_check(phase, false, T_INT);\n+  bool should_rce_long = policy_range_check(phase, false, T_LONG);\n@@ -3458,0 +3481,3 @@\n+      if (should_rce_long && phase->create_loop_nest(this, old_new)) {\n+        return true;\n+      }\n@@ -3499,0 +3525,3 @@\n+    if (should_rce_long) {\n+      phase->create_loop_nest(this, old_new);\n+    }\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":46,"deletions":17,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -528,4 +528,10 @@\n-Node* PhaseIdealLoop::long_loop_replace_long_iv(Node* iv_to_replace, Node* inner_iv, Node* outer_phi, Node* inner_head) {\n-  Node* iv_as_long = new ConvI2LNode(inner_iv, TypeLong::INT);\n-  register_new_node(iv_as_long, inner_head);\n-  Node* iv_replacement = new AddLNode(outer_phi, iv_as_long);\n+Node* PhaseIdealLoop::loop_nest_replace_iv(Node* iv_to_replace, Node* inner_iv, Node* outer_phi, Node* inner_head,\n+                                           BasicType bt) {\n+  Node* iv_as_long;\n+  if (bt == T_LONG) {\n+    iv_as_long = new ConvI2LNode(inner_iv, TypeLong::INT);\n+    register_new_node(iv_as_long, inner_head);\n+  } else {\n+    iv_as_long = inner_iv;\n+  }\n+  Node* iv_replacement = AddNode::make(outer_phi, iv_as_long, bt);\n@@ -765,1 +771,4 @@\n-bool PhaseIdealLoop::transform_long_counted_loop(IdealLoopTree* loop, Node_List &old_new) {\n+\/\/\n+\/\/ The same logic is used to transform an int counted loop that contains long range checks into a loop nest of 2 int\n+\/\/ loops with long range checks transformed to int range checks in the inner loop.\n+bool PhaseIdealLoop::create_loop_nest(IdealLoopTree* loop, Node_List &old_new) {\n@@ -768,1 +777,1 @@\n-  if (loop->_child != NULL || !x->is_LongCountedLoop() || x->as_Loop()->is_transformed_long_outer_loop()) {\n+  if (loop->_child != NULL || !x->is_BaseCountedLoop() || x->as_Loop()->is_loop_nest_outer_loop()) {\n@@ -772,1 +781,6 @@\n-  check_long_counted_loop(loop, x);\n+  if (x->is_CountedLoop() && !x->as_CountedLoop()->is_main_loop() && !x->as_CountedLoop()->is_normal_loop()) {\n+    return false;\n+  }\n+\n+  BaseCountedLoopNode* head = x->as_BaseCountedLoop();\n+  BasicType bt = x->as_BaseCountedLoop()->bt();\n@@ -774,1 +788,1 @@\n-  LongCountedLoopNode* head = x->as_LongCountedLoop();\n+  check_counted_loop_shape(loop, x, bt);\n@@ -777,1 +791,3 @@\n-  Atomic::inc(&_long_loop_candidates);\n+  if (bt == T_LONG) {\n+    Atomic::inc(&_long_loop_candidates);\n+  }\n@@ -784,0 +800,1 @@\n+    assert(bt == T_LONG, \"only for long loops\");\n@@ -791,1 +808,1 @@\n-  if (StressLongCountedLoop > 0) {\n+  if (bt == T_LONG && StressLongCountedLoop > 0) {\n@@ -817,3 +834,3 @@\n-  const TypeLong* phi_t = phi->bottom_type()->is_long();\n-  assert(phi_t->_hi >= phi_t->_lo, \"dead phi?\");\n-  iters_limit = (int)MIN2((julong)iters_limit, (julong)(phi_t->_hi - phi_t->_lo));\n+  const TypeInteger* phi_t = phi->bottom_type()->is_integer(bt);\n+  assert(phi_t->hi_as_long() >= phi_t->lo_as_long(), \"dead phi?\");\n+  iters_limit = checked_cast<int>(MIN2((julong)iters_limit, (julong)(phi_t->hi_as_long() - phi_t->lo_as_long())));\n@@ -821,5 +838,3 @@\n-  LongCountedLoopEndNode* exit_test = head->loopexit();\n-  BoolTest::mask bt = exit_test->test_trip();\n-\n-  \/\/ We need a safepoint to insert empty predicates for the inner loop.\n-  SafePointNode* safepoint = find_safepoint(back_control, x, loop);\n+  IfNode* exit_test = head->loopexit();\n+  BoolTest::mask mask = exit_test->as_BaseCountedLoopEnd()->test_trip();\n+  Node* cmp = exit_test->as_BaseCountedLoopEnd()->cmp_node();\n@@ -828,3 +843,0 @@\n-  Node* exit_branch = exit_test->proj_out(false);\n-  Node* entry_control = x->in(LoopNode::EntryControl);\n-  Node* cmp = exit_test->cmp_node();\n@@ -835,0 +847,19 @@\n+  if (bt == T_INT) {\n+    \/\/ The only purpose of creating a loop nest is to handle long range checks. If there are none, do not proceed further.\n+    if (range_checks.size() == 0) {\n+      return false;\n+    }\n+  }\n+\n+  \/\/ We need a safepoint to insert empty predicates for the inner loop.\n+  SafePointNode* safepoint;\n+  if (bt == T_INT && head->as_CountedLoop()->is_strip_mined()) {\n+    \/\/ Loop is strip mined: use the safepoint of the outer strip mined loop\n+    strip_mined_nest_back_to_counted_loop(loop, head, back_control, exit_test, safepoint);\n+  } else {\n+    safepoint = find_safepoint(back_control, x, loop);\n+  }\n+\n+  Node* exit_branch = exit_test->proj_out(false);\n+  Node* entry_control = head->in(LoopNode::EntryControl);\n+\n@@ -870,1 +901,1 @@\n-    inner_iters_max = MaxNode::max_diff_with_zero(limit, outer_phi, TypeLong::LONG, _igvn);\n+    inner_iters_max = MaxNode::max_diff_with_zero(limit, outer_phi, TypeInteger::bottom(bt), _igvn);\n@@ -872,1 +903,1 @@\n-    inner_iters_max = MaxNode::max_diff_with_zero(outer_phi, limit, TypeLong::LONG, _igvn);\n+    inner_iters_max = MaxNode::max_diff_with_zero(outer_phi, limit, TypeInteger::bottom(bt), _igvn);\n@@ -875,1 +906,1 @@\n-  Node* inner_iters_limit = _igvn.longcon(iters_limit);\n+  Node* inner_iters_limit = _igvn.integercon(iters_limit, bt);\n@@ -879,1 +910,1 @@\n-  Node* inner_iters_actual = MaxNode::unsigned_min(inner_iters_max, inner_iters_limit, TypeLong::make(0, iters_limit, Type::WidenMin), _igvn);\n+  Node* inner_iters_actual = MaxNode::unsigned_min(inner_iters_max, inner_iters_limit, TypeInteger::make(0, iters_limit, Type::WidenMin, bt), _igvn);\n@@ -881,2 +912,7 @@\n-  Node* inner_iters_actual_int = new ConvL2INode(inner_iters_actual);\n-  _igvn.register_new_node_with_optimizer(inner_iters_actual_int);\n+  Node* inner_iters_actual_int;\n+  if (bt == T_LONG) {\n+    inner_iters_actual_int = new ConvL2INode(inner_iters_actual);\n+    _igvn.register_new_node_with_optimizer(inner_iters_actual_int);\n+  } else {\n+    inner_iters_actual_int = inner_iters_actual;\n+  }\n@@ -922,1 +958,1 @@\n-  Node* iv_add = long_loop_replace_long_iv(phi, inner_phi, outer_phi, head);\n+  Node* iv_add = loop_nest_replace_iv(phi, inner_phi, outer_phi, head, bt);\n@@ -926,1 +962,1 @@\n-  long_loop_replace_long_iv(incr, inner_incr, outer_phi, head);\n+  loop_nest_replace_iv(incr, inner_incr, outer_phi, head, bt);\n@@ -986,0 +1022,5 @@\n+  if (bt == T_INT) {\n+    outer_phi = new ConvI2LNode(outer_phi);\n+    register_new_node(outer_phi, outer_head);\n+  }\n+\n@@ -1012,1 +1053,3 @@\n-  Atomic::inc(&_long_loop_nests);\n+  if (bt == T_LONG) {\n+    Atomic::inc(&_long_loop_nests);\n+  }\n@@ -1015,2 +1058,2 @@\n-  inner_head->mark_transformed_long_inner_loop();\n-  outer_head->mark_transformed_long_outer_loop();\n+  inner_head->mark_loop_nest_inner_loop();\n+  outer_head->mark_loop_nest_outer_loop();\n@@ -1021,0 +1064,62 @@\n+\/\/ Convert the strip mined loop nest back to a single loop with the safepoint right before the loop exit test\n+void PhaseIdealLoop::strip_mined_nest_back_to_counted_loop(IdealLoopTree* loop, const BaseCountedLoopNode* head,\n+                                                           Node* back_control, IfNode*& exit_test,\n+                                                           SafePointNode*& safepoint) {\n+  CountedLoopNode* cl = head->as_CountedLoop();\n+  cl->verify_strip_mined(1);\n+  safepoint = cl->outer_safepoint();\n+  CountedLoopEndNode* cle = cl->loopexit();\n+  OuterStripMinedLoopNode* outer_head = cl->outer_loop();\n+  OuterStripMinedLoopEndNode* outer_end = cl->outer_loop_end();\n+\n+  cl->clear_strip_mined();\n+\n+  _igvn.replace_input_of(cl, LoopNode::EntryControl, outer_head->in(LoopNode::EntryControl));\n+  _igvn.replace_input_of(outer_head, LoopNode::EntryControl, C->top());\n+  set_idom(cl, cl->in(LoopNode::EntryControl), dom_depth(cl));\n+\n+  Node* exit_bol = cle->in(1);\n+  Node *zero = _igvn.intcon(0);\n+  set_ctrl(zero, C->root());\n+  _igvn.replace_input_of(cle, 1, zero);\n+\n+  _igvn.replace_input_of(outer_end, 1, exit_bol);\n+\n+  assert(outer_head->in(LoopNode::LoopBackControl)->in(0) == outer_end, \"\");\n+  _igvn.replace_input_of(outer_head->in(LoopNode::LoopBackControl), 0, C->top());\n+  _igvn.replace_input_of(back_control, 0, outer_end);\n+  set_idom(back_control, outer_end, dom_depth(outer_end) + 1);\n+\n+  Unique_Node_List wq;\n+  wq.push(safepoint);\n+\n+  IdealLoopTree* outer_loop_ilt = get_loop(outer_head);\n+\n+  for (uint i = 0; i < wq.size(); i++) {\n+    Node* n = wq.at(i);\n+    for (uint j = 0; j < n->req(); ++j) {\n+      Node* in = n->in(j);\n+      if (in == NULL || in->is_CFG()) {\n+        continue;\n+      }\n+      if (get_loop(get_ctrl(in)) != outer_loop_ilt) {\n+        continue;\n+      }\n+      assert(!loop->_body.contains(in), \"\");\n+      loop->_body.push(in);\n+      wq.push(in);\n+    }\n+  }\n+\n+  set_loop(outer_end, loop);\n+  loop->_body.push(outer_end);\n+  set_loop(safepoint, loop);\n+  loop->_body.push(safepoint);\n+  set_loop(safepoint->in(0), loop);\n+  loop->_body.push(safepoint->in(0));\n+\n+  exit_test = outer_end;\n+\n+  outer_loop_ilt->_tail = C->top();\n+}\n+\n@@ -1167,1 +1272,2 @@\n-    bool ok = is_scaled_iv_plus_offset(rc_cmp->in(1), iv_add, &scale, &offset, T_LONG);\n+    bool converted = false;\n+    bool ok = is_scaled_iv_plus_offset(rc_cmp->in(1), iv_add, &scale, &offset, T_LONG, &converted);\n@@ -1176,0 +1282,1 @@\n+\n@@ -1177,0 +1284,36 @@\n+\n+    if (converted) {\n+      \/\/ This converts:\n+      \/\/ i*K + L <u64 R\n+      \/\/ with K an int into:\n+      \/\/ i*(long)K + L <u64 unsigned_min((long)max_jint + L + 1, R)\n+      \/\/ to protect against an overflow of i*K\n+      \/\/\n+      \/\/ Because if i*K overflows, there are K,L where:\n+      \/\/ i*K + L <u64 R is false\n+      \/\/ when\n+      \/\/ i*(long)K is > (long)max_jint and < R\n+      \/\/ and so i*(long)K + L <u64 R is true\n+      \/\/ As a consequence simply converting:\n+      \/\/ i*K + L <u64 R to i*(long)K + L <u64 R could cause incorrect execution\n+      \/\/\n+      \/\/ It's always true that:\n+      \/\/ i*K <u64 (long)max_jint + 1\n+      \/\/ which implies i*K + L <u64 (long)max_jint + 1 + L\n+      \/\/ As a consequence:\n+      \/\/ i*(long)K + L <u64 unsigned_min((long)max_jint + L + 1, R)\n+      \/\/ is always false in case of overflow of i*K\n+      \/\/\n+      \/\/ Note, there are K,L where i*K overflows and\n+      \/\/ i*K + L <u64 R is true, but\n+      \/\/ i*(long)K + L <u64 unsigned_min((long)max_jint + L + 1, R) is false\n+      \/\/ So this transformation could cause spurious deoptimizations and failed range check elimination\n+      \/\/ (but not incorrect execution) for unlikely corner cases with overflow\n+      Node* max_jint_plus_one_long = _igvn.longcon((jlong)max_jint + 1);\n+      set_ctrl(max_jint_plus_one_long, C->root());\n+      Node* max_range = new AddLNode(max_jint_plus_one_long, L);\n+      register_new_node(max_range, entry_control);\n+      R = MaxNode::unsigned_min(R, max_range, TypeLong::POS, _igvn);\n+      set_subtree_ctrl(R, true);\n+    }\n+\n@@ -1254,2 +1397,2 @@\n-LoopNode* PhaseIdealLoop::create_inner_head(IdealLoopTree* loop, LongCountedLoopNode* head,\n-                                            LongCountedLoopEndNode* exit_test) {\n+LoopNode* PhaseIdealLoop::create_inner_head(IdealLoopTree* loop, BaseCountedLoopNode* head,\n+                                            IfNode* exit_test) {\n@@ -1275,1 +1418,1 @@\n-void PhaseIdealLoop::check_long_counted_loop(IdealLoopTree* loop, Node* x) {\n+void PhaseIdealLoop::check_counted_loop_shape(IdealLoopTree* loop, Node* x, BasicType bt) {\n@@ -1279,1 +1422,1 @@\n-  BoolTest::mask bt = BoolTest::illegal;\n+  BoolTest::mask mask = BoolTest::illegal;\n@@ -1284,2 +1427,2 @@\n-  Node* cmp = loop_exit_test(back_control, loop, incr, limit, bt, cl_prob);\n-  assert(cmp != NULL && cmp->Opcode() == Op_CmpL, \"no exit test\");\n+  Node* cmp = loop_exit_test(back_control, loop, incr, limit, mask, cl_prob);\n+  assert(cmp != NULL && cmp->is_Cmp() && cmp->operates_on(bt, true), \"no exit test\");\n@@ -1289,1 +1432,1 @@\n-  assert(incr != NULL && incr->Opcode() == Op_AddL, \"no incr\");\n+  assert(incr != NULL && incr->is_Add() && incr->operates_on(bt, true), \"no incr\");\n@@ -1300,1 +1443,1 @@\n-  jlong stride_con = stride->get_long();\n+  jlong stride_con = stride->get_integer_as_long(bt);\n@@ -1302,1 +1445,1 @@\n-  assert(condition_stride_ok(bt, stride_con), \"illegal condition\");\n+  assert(condition_stride_ok(mask, stride_con), \"illegal condition\");\n@@ -1304,1 +1447,1 @@\n-  assert(bt != BoolTest::ne, \"unexpected condition\");\n+  assert(mask != BoolTest::ne, \"unexpected condition\");\n@@ -1633,1 +1776,1 @@\n-    assert(!x->as_Loop()->is_transformed_long_inner_loop(), \"long loop was transformed\");\n+    assert(!x->as_Loop()->is_loop_nest_inner_loop(), \"loop was transformed\");\n@@ -1723,1 +1866,1 @@\n-      !x->as_Loop()->is_transformed_long_inner_loop() &&\n+      !x->as_Loop()->is_loop_nest_inner_loop() &&\n@@ -1928,1 +2071,1 @@\n-  if (x->as_Loop()->is_transformed_long_inner_loop()) {\n+  if (x->as_Loop()->is_loop_nest_inner_loop() && iv_bt == T_LONG) {\n@@ -1932,2 +2075,2 @@\n-  if (iv_bt == T_LONG && x->as_Loop()->is_transformed_long_outer_loop()) {\n-    l->mark_transformed_long_outer_loop();\n+  if (iv_bt == T_LONG && x->as_Loop()->is_loop_nest_outer_loop()) {\n+    l->mark_loop_nest_outer_loop();\n@@ -2406,5 +2549,0 @@\n-jlong LongCountedLoopNode::stride_con() const {\n-  LongCountedLoopEndNode* cle = loopexit_or_null();\n-  return cle != NULL ? cle->stride_con() : 0;\n-}\n-\n@@ -3543,1 +3681,1 @@\n-    assert(!_head->is_Loop() || !_head->as_Loop()->is_transformed_long_inner_loop(), \"transformation to counted loop should not fail\");\n+    assert(!_head->is_Loop() || !_head->as_Loop()->is_loop_nest_inner_loop(), \"transformation to counted loop should not fail\");\n@@ -4215,1 +4353,3 @@\n-      if (SplitIfBlocks && do_split_ifs && lpt->policy_range_check(this, true)) {\n+      if (SplitIfBlocks && do_split_ifs &&\n+          (lpt->policy_range_check(this, true, T_LONG) ||\n+           (head->is_CountedLoop() && lpt->policy_range_check(this, true, T_INT)))) {\n@@ -4267,7 +4407,0 @@\n-  if (C->has_loops() && !C->major_progress()) {\n-    for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {\n-      IdealLoopTree *lpt = iter.current();\n-      transform_long_counted_loop(lpt, worklist);\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":195,"deletions":62,"binary":false,"changes":257,"status":"modified"},{"patch":"@@ -80,2 +80,2 @@\n-         TransformedLongInnerLoop = 1<<18,\n-         TransformedLongOuterLoop = 1<<19};\n+         LoopNestInnerLoop = 1 << 18,\n+         LoopNestLongOuterLoop = 1 << 19};\n@@ -106,2 +106,2 @@\n-  bool is_transformed_long_inner_loop() const { return _loop_flags & TransformedLongInnerLoop; }\n-  bool is_transformed_long_outer_loop() const { return _loop_flags & TransformedLongOuterLoop; }\n+  bool is_loop_nest_inner_loop() const { return _loop_flags & LoopNestInnerLoop; }\n+  bool is_loop_nest_outer_loop() const { return _loop_flags & LoopNestLongOuterLoop; }\n@@ -122,2 +122,2 @@\n-  void mark_transformed_long_inner_loop() { _loop_flags |= TransformedLongInnerLoop; }\n-  void mark_transformed_long_outer_loop() { _loop_flags |= TransformedLongOuterLoop; }\n+  void mark_loop_nest_inner_loop() { _loop_flags |= LoopNestInnerLoop; }\n+  void mark_loop_nest_outer_loop() { _loop_flags |= LoopNestLongOuterLoop; }\n@@ -223,0 +223,2 @@\n+  jlong stride_con() const;\n+\n@@ -380,1 +382,0 @@\n-  jlong   stride_con() const;\n@@ -539,0 +540,6 @@\n+inline jlong BaseCountedLoopNode::stride_con() const {\n+  BaseCountedLoopEndNode* cle = loopexit_or_null();\n+  return cle != NULL ? cle->stride_con() : 0;\n+}\n+\n+\n@@ -737,1 +744,1 @@\n-  bool policy_range_check(PhaseIdealLoop* phase, bool provisional) const;\n+  bool policy_range_check(PhaseIdealLoop* phase, bool provisional, BasicType bt) const;\n@@ -1173,2 +1180,2 @@\n-  Node* long_loop_replace_long_iv(Node* iv_to_replace, Node* inner_iv, Node* outer_phi, Node* inner_head);\n-  bool transform_long_counted_loop(IdealLoopTree* loop, Node_List &old_new);\n+  Node* loop_nest_replace_iv(Node* iv_to_replace, Node* inner_iv, Node* outer_phi, Node* inner_head, BasicType bt);\n+  bool create_loop_nest(IdealLoopTree* loop, Node_List &old_new);\n@@ -1275,1 +1282,3 @@\n-  bool is_scaled_iv(Node* exp, Node* iv, jlong* p_scale, BasicType bt);\n+  bool is_scaled_iv(Node* exp, Node* iv, jlong* p_scale, BasicType bt, bool* converted);\n+\n+  bool is_iv(Node* exp, Node* iv, BasicType bt);\n@@ -1278,1 +1287,1 @@\n-  bool is_scaled_iv_plus_offset(Node* exp, Node* iv, jlong* p_scale, Node** p_offset, BasicType bt, int depth = 0);\n+  bool is_scaled_iv_plus_offset(Node* exp, Node* iv, jlong* p_scale, Node** p_offset, BasicType bt, bool* converted = NULL, int depth = 0);\n@@ -1636,1 +1645,1 @@\n-  void check_long_counted_loop(IdealLoopTree* loop, Node* x) NOT_DEBUG_RETURN;\n+  void check_counted_loop_shape(IdealLoopTree* loop, Node* x, BasicType bt) NOT_DEBUG_RETURN;\n@@ -1638,1 +1647,1 @@\n-  LoopNode* create_inner_head(IdealLoopTree* loop, LongCountedLoopNode* head, LongCountedLoopEndNode* exit_test);\n+  LoopNode* create_inner_head(IdealLoopTree* loop, BaseCountedLoopNode* head, IfNode* exit_test);\n@@ -1661,0 +1670,3 @@\n+\n+  void strip_mined_nest_back_to_counted_loop(IdealLoopTree* loop, const BaseCountedLoopNode* head, Node* back_control,\n+                                             IfNode*&exit_test, SafePointNode*&safepoint);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":26,"deletions":14,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1056,1 +1056,1 @@\n-  if (((n_blk->is_CountedLoop() || (n_blk->is_Loop() && n_blk->as_Loop()->is_transformed_long_inner_loop())) && n->Opcode() == Op_AddI) ||\n+  if (((n_blk->is_CountedLoop() || (n_blk->is_Loop() && n_blk->as_Loop()->is_loop_nest_inner_loop())) && n->Opcode() == Op_AddI) ||\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @bug 8259609\n+ * @bug 8259609 8276116\n@@ -44,2 +44,2 @@\n-    @IR(counts = { IRNode.LOOP, \"1\"})\n-    @IR(failOn = { IRNode.COUNTEDLOOP})\n+    @IR(counts = { IRNode.LOOP, \"1\" })\n+    @IR(failOn = { IRNode.COUNTEDLOOP })\n@@ -63,0 +63,36 @@\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\" })\n+    @IR(failOn = { IRNode.COUNTEDLOOP })\n+    public static void testStridePosScalePosInIntLoop1(int start, int stop, long length, long offset) {\n+        final long scale = 2;\n+        final int stride = 1;\n+\n+        \/\/ Same but with int loop\n+        for (int i = start; i < stop; i += stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStridePosScalePosInIntLoop1\")\n+    private void testStridePosScalePosInIntLoop1_runner() {\n+        testStridePosScalePosInIntLoop1(0, 100, 200, 0);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\" })\n+    @IR(failOn = { IRNode.COUNTEDLOOP })\n+    public static void testStridePosScalePosInIntLoop2(int start, int stop, long length, long offset) {\n+        final int scale = 2;\n+        final int stride = 1;\n+\n+        \/\/ Same but with int loop\n+        for (int i = start; i < stop; i += stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStridePosScalePosInIntLoop2\")\n+    private void testStridePosScalePosInIntLoop2_runner() {\n+        testStridePosScalePosInIntLoop2(0, 100, 200, 0);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestLongRangeChecks.java","additions":39,"deletions":3,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8259609\n+ * @bug 8259609 8276116\n@@ -35,1 +35,1 @@\n- * @run main\/othervm -ea -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:-BackgroundCompilation TestLongRangeCheck\n+ * @run main\/othervm -ea -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:-BackgroundCompilation -XX:-UseOnStackReplacement TestLongRangeCheck\n@@ -196,0 +196,109 @@\n+\n+        test(\"testStridePosScalePosInIntLoop\", 0, 100, 100, 0);\n+\n+        test(\"testStrideNegScaleNegInIntLoop\", 0, 100, 100, 100);\n+\n+        test(\"testStrideNegScalePosInIntLoop\", 0, 100, 100, 0);\n+\n+        test(\"testStridePosScaleNegInIntLoop\", 0, 100, 100, 99);\n+\n+        test(\"testStridePosScalePosNotOneInIntLoop\", 0, 100, 1090, 0);\n+\n+        test(\"testStrideNegScaleNegNotOneInIntLoop\", 0, 100, 1090, 1100);\n+\n+        test(\"testStrideNegScalePosNotOneInIntLoop\", 0, 100, 1090, 0);\n+\n+        test(\"testStridePosScaleNegNotOneInIntLoop\", 0, 100, 1090, 1089);\n+\n+        v = ((long)Integer.MAX_VALUE \/ 10000) * 9999;\n+\n+        test(\"testStridePosNotOneScalePosInIntLoop\", -v, v, v * 4, 2 * v);\n+\n+        test(\"testStrideNegNotOneScaleNegInIntLoop\", -v, v, v * 4, 2 * v);\n+\n+        test(\"testStrideNegNotOneScalePosInIntLoop\", -v, v, v * 4, 2 * v);\n+\n+        test(\"testStridePosNotOneScaleNegInIntLoop\", -v, v, v * 4, 2 * v - 1);\n+\n+        \/\/ offset causes overflow\n+        {\n+            Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(\"testStridePosScalePosInIntLoop\", long.class, long.class, long.class, long.class);\n+            m.invoke(null, 0, 100, 100, 0);\n+            compile(m);\n+\n+            m.invoke(null, 0, 100, 100, 0);\n+            assertIsCompiled(m);\n+            try {\n+                m.invoke(null, 0, 100, 100, Long.MAX_VALUE - 50);\n+                throw new RuntimeException(\"should have thrown\");\n+            } catch(InvocationTargetException e) {\n+                if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n+                    throw new RuntimeException(\"unexpected exception\");\n+                }\n+            }\n+            assertIsNotCompiled(m);\n+        }\n+        \/\/ no spurious deopt if the range check doesn't fail because not executed\n+        {\n+            Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(\"testStridePosScalePosConditional\", long.class, long.class, long.class, long.class, long.class, long.class);\n+            m.invoke(null, 0, 100, 100, 0, 0, 100);\n+            compile(m);\n+\n+            m.invoke(null, 0, 100, 100, -50, 50, 100);\n+            assertIsCompiled(m);\n+        }\n+        {\n+            Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(\"testStridePosScalePosConditional\", long.class, long.class, long.class, long.class, long.class, long.class);\n+            m.invoke(null, 0, 100, 100, 0, 0, 100);\n+            compile(m);\n+\n+            m.invoke(null, 0, 100, Long.MAX_VALUE, Long.MAX_VALUE - 50, 0, 50);\n+            assertIsCompiled(m);\n+        }\n+\n+        test(\"testStridePosScalePosNotOneInIntLoop2\", 0, 100, 1090, 0);\n+\n+        test(\"testStrideNegScaleNegNotOneInIntLoop2\", 0, 100, 1090, 1100);\n+\n+        test(\"testStrideNegScalePosNotOneInIntLoop2\", 0, 100, 1090, 0);\n+\n+        test(\"testStridePosScaleNegNotOneInIntLoop2\", 0, 100, 1090, 1089);\n+\n+        {\n+            Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(\"testStridePosScalePosInIntLoopOverflow\", long.class, long.class, long.class, long.class);\n+            long stride = 1 << 14;\n+            long scale = 1 << 15;\n+            long offset = stride * scale * 4;\n+            long length = offset + stride * scale * 3 + 1;\n+            long stop = stride * 5;\n+\n+            m.invoke(null, 0, stop, length, offset);\n+            compile(m);\n+\n+            m.invoke(null, 0, stop, length, offset);\n+            \/\/ deoptimizes even though no range check fails\n+        }\n+        {\n+            Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(\"testStridePosScalePosInIntLoopOverflow\", long.class, long.class, long.class, long.class);\n+            long stride = 1 << 14;\n+            long scale = 1 << 15;\n+            long offset = stride * scale * 4;\n+            long length = offset + stride * scale * 3 + 1;\n+            long stop = stride * 5;\n+\n+            m.invoke(null, 0, stop, length, offset);\n+            compile(m);\n+\n+            offset = 0;\n+            stop = stride * 5;\n+\n+            try {\n+                m.invoke(null, 0, stop, length, offset);\n+                throw new RuntimeException(\"should have thrown\");\n+            } catch(InvocationTargetException e) {\n+                if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n+                    throw new RuntimeException(\"unexpected exception\");\n+                }\n+            }\n+            assertIsNotCompiled(m);\n+        }\n@@ -304,0 +413,173 @@\n+\n+    private static void checkInputs(long... inputs) {\n+        for (int i = 0; i < inputs.length; i++) {\n+            if ((long)((int)inputs[i]) != inputs[i]) {\n+                throw new RuntimeException(\"bad arguments\");\n+            }\n+        }\n+    }\n+\n+    public static void testStridePosScalePosInIntLoop(long start, long stop, long length, long offset) {\n+        checkInputs(start, stop);\n+        final long scale = 1;\n+        final int stride = 1;\n+        for (int i = (int)start; i < (int)stop; i += stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStrideNegScaleNegInIntLoop(long start, long stop, long length, long offset) {\n+        checkInputs(start, stop);\n+        final long scale = -1;\n+        final int stride = 1;\n+        for (int i = (int)stop; i > (int)start; i -= stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStrideNegScalePosInIntLoop(long start, long stop, long length, long offset) {\n+        checkInputs(start, stop);\n+        final long scale = 1;\n+        final int stride = 1;\n+        for (int i = (int)(stop-1); i >= (int)start; i -= stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStridePosScaleNegInIntLoop(long start, long stop, long length, long offset) {\n+        checkInputs(start, stop);\n+        final long scale = -1;\n+        final int stride = 1;\n+        for (int i = (int)start; i < (int)stop; i += stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStridePosScalePosNotOneInIntLoop(long start, long stop, long length, long offset) {\n+        checkInputs(start, stop);\n+        final long scale = 11;\n+        final int stride = 1;\n+        for (int i = (int)start; i < (int)stop; i += stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStrideNegScaleNegNotOneInIntLoop(long start, long stop, long length, long offset) {\n+        checkInputs(start, stop);\n+        final long scale = -11;\n+        final int stride = 1;\n+        for (int i = (int)stop; i > (int)start; i -= stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStrideNegScalePosNotOneInIntLoop(long start, long stop, long length, long offset) {\n+        checkInputs(start, stop);\n+        final long scale = 11;\n+        final int stride = 1;\n+        for (int i = (int)(stop-1); i >= (int)start; i -= stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStridePosScaleNegNotOneInIntLoop(long start, long stop, long length, long offset) {\n+        checkInputs(start, stop);\n+        final long scale = -11;\n+        final int stride = 1;\n+        for (int i = (int)start; i < (int)stop; i += stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStridePosNotOneScalePosInIntLoop(long start, long stop, long length, long offset) {\n+        checkInputs(start, stop);\n+        final long scale = 2;\n+        final int stride = Integer.MAX_VALUE \/ 10000;\n+        for (int i = (int)start; i < (int)stop; i += stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStrideNegNotOneScaleNegInIntLoop(long start, long stop, long length, long offset) {\n+        checkInputs(start, stop);\n+        final long scale = -2;\n+        final int stride = Integer.MAX_VALUE \/ 10000;\n+        for (int i = (int)stop; i > (int)start; i -= stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStrideNegNotOneScalePosInIntLoop(long start, long stop, long length, long offset) {\n+        checkInputs(start, stop);\n+        final long scale = 2;\n+        final int stride = Integer.MAX_VALUE \/ 10000;\n+        for (int i = (int)(stop-1); i >= (int)start; i -= stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStridePosNotOneScaleNegInIntLoop(long start, long stop, long length, long offset) {\n+        checkInputs(start, stop);\n+        final long scale = -2;\n+        final int stride = Integer.MAX_VALUE \/ 10000;\n+        for (int i = (int)start; i < (int)stop; i += stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStridePosScalePosConditionalInIntLoop(long start, long stop, long length, long offset, long start2, long stop2) {\n+        checkInputs(start, stop, start2, stop2);\n+        Preconditions.checkIndex(0, length, null);\n+        final long scale = 1;\n+        final int stride = 1;\n+        for (int i = (int)start; i < (int)stop; i += stride) {\n+            if (i >= (int)start2 && i < (int)stop2) {\n+                Preconditions.checkIndex(scale * i + offset, length, null);\n+            }\n+        }\n+    }\n+\n+    public static void testStridePosScalePosNotOneInIntLoop2(long start, long stop, long length, long offset) {\n+        checkInputs(start, stop);\n+        final int scale = 11;\n+        final int stride = 1;\n+        for (int i = (int)start; i < (int)stop; i += stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStrideNegScaleNegNotOneInIntLoop2(long start, long stop, long length, long offset) {\n+        checkInputs(start, stop);\n+        final int scale = -11;\n+        final int stride = 1;\n+        for (int i = (int)stop; i > (int)start; i -= stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStrideNegScalePosNotOneInIntLoop2(long start, long stop, long length, long offset) {\n+        checkInputs(start, stop);\n+        final int scale = 11;\n+        final int stride = 1;\n+        for (int i = (int)(stop-1); i >= (int)start; i -= stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStridePosScaleNegNotOneInIntLoop2(long start, long stop, long length, long offset) {\n+        checkInputs(start, stop);\n+        final int scale = -11;\n+        final int stride = 1;\n+        for (int i = (int)start; i < (int)stop; i += stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStridePosScalePosInIntLoopOverflow(long start, long stop, long length, long offset) {\n+        checkInputs(start, stop);\n+        final int scale = 1 << 15;\n+        final int stride = 1 << 14;\n+        for (int i = (int)start; i < (int)stop; i += stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestLongRangeCheck.java","additions":284,"deletions":2,"binary":false,"changes":286,"status":"modified"}]}