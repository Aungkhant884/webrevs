{"files":[{"patch":"@@ -37,1 +37,1 @@\n-jint CodeInstaller::pd_next_offset(NativeInstruction* inst, jint pc_offset, JVMCIObject method, JVMCI_TRAPS) {\n+jint CodeInstaller::pd_next_offset(NativeInstruction* inst, jint pc_offset, JVMCI_TRAPS) {\n@@ -50,1 +50,1 @@\n-void CodeInstaller::pd_patch_OopConstant(int pc_offset, JVMCIObject constant, JVMCI_TRAPS) {\n+void CodeInstaller::pd_patch_OopConstant(int pc_offset, Handle& obj, bool compressed, JVMCI_TRAPS) {\n@@ -55,1 +55,1 @@\n-    if (jvmci_env()->get_HotSpotObjectConstantImpl_compressed(constant)) {\n+    if (compressed) {\n@@ -66,1 +66,0 @@\n-  Handle obj = jvmci_env()->asConstant(constant, JVMCI_CHECK);\n@@ -74,1 +73,1 @@\n-void CodeInstaller::pd_patch_MetaspaceConstant(int pc_offset, JVMCIObject constant, JVMCI_TRAPS) {\n+void CodeInstaller::pd_patch_MetaspaceConstant(int pc_offset, HotSpotCompiledCodeStream* stream, u1 tag, JVMCI_TRAPS) {\n@@ -76,2 +75,2 @@\n-  if (jvmci_env()->get_HotSpotMetaspaceConstantImpl_compressed(constant)) {\n-    narrowKlass narrowOop = record_narrow_metadata_reference(_instructions, pc, constant, JVMCI_CHECK);\n+  if (tag == PATCH_NARROW_KLASS) {\n+    narrowKlass narrowOop = record_narrow_metadata_reference(_instructions, pc, stream, tag, JVMCI_CHECK);\n@@ -82,1 +81,1 @@\n-    void* reference = record_metadata_reference(_instructions, pc, constant, JVMCI_CHECK);\n+    void* reference = record_metadata_reference(_instructions, pc, stream, tag, JVMCI_CHECK);\n@@ -125,8 +124,1 @@\n-void CodeInstaller::pd_relocate_JavaMethod(CodeBuffer &cbuf, JVMCIObject hotspot_method, jint pc_offset, JVMCI_TRAPS) {\n-#ifdef ASSERT\n-  Method* method = NULL;\n-  \/\/ we need to check, this might also be an unresolved method\n-  if (JVMCIENV->isa_HotSpotResolvedJavaMethodImpl(hotspot_method)) {\n-    method = JVMCIENV->asMethod(hotspot_method);\n-  }\n-#endif\n+void CodeInstaller::pd_relocate_JavaMethod(CodeBuffer &cbuf, methodHandle& method, jint pc_offset, JVMCI_TRAPS) {\n@@ -138,1 +130,1 @@\n-      assert(method == NULL || !method->is_static(), \"cannot call static method with invokeinterface\");\n+      assert(!method->is_static(), \"cannot call static method with invokeinterface\");\n@@ -145,1 +137,1 @@\n-      assert(method == NULL || method->is_static(), \"cannot call non-static method with invokestatic\");\n+      assert(method->is_static(), \"cannot call non-static method with invokestatic\");\n@@ -152,1 +144,1 @@\n-      assert(method == NULL || !method->is_static(), \"cannot call static method with invokespecial\");\n+      assert(!method->is_static(), \"cannot call static method with invokespecial\");\n","filename":"src\/hotspot\/cpu\/aarch64\/jvmciCodeInstaller_aarch64.cpp","additions":11,"deletions":19,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-jint CodeInstaller::pd_next_offset(NativeInstruction* inst, jint pc_offset, JVMCIObject method, JVMCI_TRAPS) {\n+jint CodeInstaller::pd_next_offset(NativeInstruction* inst, jint pc_offset, JVMCI_TRAPS) {\n@@ -59,1 +59,0 @@\n-    assert(method.is_non_null(), \"only valid for virtual calls\");\n@@ -69,1 +68,1 @@\n-void CodeInstaller::pd_patch_OopConstant(int pc_offset, JVMCIObject constant, JVMCI_TRAPS) {\n+void CodeInstaller::pd_patch_OopConstant(int pc_offset, Handle& obj, bool compressed, JVMCI_TRAPS) {\n@@ -71,1 +70,0 @@\n-  Handle obj = jvmci_env()->asConstant(constant, JVMCI_CHECK);\n@@ -73,1 +71,1 @@\n-  if (jvmci_env()->get_HotSpotObjectConstantImpl_compressed(constant)) {\n+  if (compressed) {\n@@ -90,1 +88,1 @@\n-void CodeInstaller::pd_patch_MetaspaceConstant(int pc_offset, JVMCIObject constant, JVMCI_TRAPS) {\n+void CodeInstaller::pd_patch_MetaspaceConstant(int pc_offset, HotSpotCompiledCodeStream* stream, u1 tag, JVMCI_TRAPS) {\n@@ -92,1 +90,1 @@\n-  if (jvmci_env()->get_HotSpotMetaspaceConstantImpl_compressed(constant)) {\n+  if (tag == PATCH_NARROW_KLASS) {\n@@ -95,1 +93,1 @@\n-    *((narrowKlass*) operand) = record_narrow_metadata_reference(_instructions, operand, constant, JVMCI_CHECK);\n+    *((narrowKlass*) operand) = record_narrow_metadata_reference(_instructions, operand, stream, tag, JVMCI_CHECK);\n@@ -102,1 +100,1 @@\n-    *((void**) operand) = record_metadata_reference(_instructions, operand, constant, JVMCI_CHECK);\n+    *((void**) operand) = record_metadata_reference(_instructions, operand, stream, tag, JVMCI_CHECK);\n@@ -150,8 +148,1 @@\n-void CodeInstaller::pd_relocate_JavaMethod(CodeBuffer &, JVMCIObject hotspot_method, jint pc_offset, JVMCI_TRAPS) {\n-#ifdef ASSERT\n-  Method* method = NULL;\n-  \/\/ we need to check, this might also be an unresolved method\n-  if (JVMCIENV->isa_HotSpotResolvedJavaMethodImpl(hotspot_method)) {\n-    method = JVMCIENV->asMethod(hotspot_method);\n-  }\n-#endif\n+void CodeInstaller::pd_relocate_JavaMethod(CodeBuffer &, methodHandle& method, jint pc_offset, JVMCI_TRAPS) {\n@@ -164,1 +155,1 @@\n-      assert(method == NULL || !method->is_static(), \"cannot call static method with invokeinterface\");\n+      assert(!method->is_static(), \"cannot call static method with invokeinterface\");\n@@ -174,1 +165,1 @@\n-      assert(method == NULL || method->is_static(), \"cannot call non-static method with invokestatic\");\n+      assert(method->is_static(), \"cannot call non-static method with invokestatic\");\n@@ -183,1 +174,1 @@\n-      assert(method == NULL || !method->is_static(), \"cannot call static method with invokespecial\");\n+      assert(!method->is_static(), \"cannot call static method with invokespecial\");\n","filename":"src\/hotspot\/cpu\/x86\/jvmciCodeInstaller_x86.cpp","additions":11,"deletions":20,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+class ConstantOopWriteValue;\n@@ -65,0 +66,5 @@\n+  ConstantOopWriteValue* as_ConstantOopWriteValue() {\n+    assert(is_constant_oop(), \"must be\");\n+    return (ConstantOopWriteValue*) this;\n+  }\n+\n","filename":"src\/hotspot\/share\/code\/debugInfo.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2738,2 +2738,5 @@\n-    tty->cr();\n-    JVMCICompiler::print_hosted_timers();\n+    JVMCICompiler *jvmci_comp = JVMCICompiler::instance(false, JavaThread::current_or_null());\n+    if (jvmci_comp != nullptr && jvmci_comp != comp) {\n+      tty->cr();\n+      jvmci_comp->print_timers();\n+    }\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -55,3 +55,10 @@\n-VMReg CodeInstaller::getVMRegFromLocation(JVMCIObject location, int total_frame_size, JVMCI_TRAPS) {\n-  if (location.is_null()) {\n-    JVMCI_THROW_NULL(NullPointerException);\n+static bool is_set(u1 flags, u1 bit) {\n+  return flags & bit;\n+}\n+\n+oop HotSpotCompiledCodeStream::get_oop(int id, JVMCI_TRAPS) const {\n+  if (_object_pool.is_null()) {\n+    JVMCI_ERROR_NULL(\"object pool is null%s\", context());\n+  }\n+  if (!_object_pool.is_null() && 0 <= id && id < _object_pool->length()) {\n+    return _object_pool->obj_at(id);\n@@ -59,0 +66,2 @@\n+  JVMCI_ERROR_NULL(\"unknown direct object id %d%s\", id, context());\n+}\n@@ -60,2 +69,12 @@\n-  JVMCIObject reg = jvmci_env()->get_code_Location_reg(location);\n-  jint offset = jvmci_env()->get_code_Location_offset(location);\n+u4 HotSpotCompiledCodeStream::offset() const {\n+  u4 res = 0;\n+  for (Chunk* c = _head; c != nullptr; c = c->next()) {\n+    if (c == _chunk) {\n+      res += _pos - c->data();\n+      break;\n+    } else {\n+      res += c->size();\n+    }\n+  }\n+  return res;\n+}\n@@ -63,4 +82,142 @@\n-  if (reg.is_non_null()) {\n-    \/\/ register\n-    jint number = jvmci_env()->get_code_Register_number(reg);\n-    VMReg vmReg = CodeInstaller::get_hotspot_reg(number, JVMCI_CHECK_NULL);\n+bool HotSpotCompiledCodeStream::available() const {\n+  u4 rem = _chunk->data_end() - _pos;\n+  for (Chunk* c = _chunk->next(); c != nullptr; c = c->next()) {\n+    rem += c->size();\n+  }\n+  return rem;\n+}\n+\n+void HotSpotCompiledCodeStream::dump_buffer(outputStream* st) const {\n+  st->print_cr(\"HotSpotCompiledCode stream for %s:\", code_desc());\n+  int chunk_index = 0;\n+  for (Chunk* c = _head; c != nullptr; c = c->next()) {\n+    const u1* data     = c->data();\n+    const u1* data_end = c->data_end();\n+\n+    int to_dump = data_end - data;\n+    st->print_cr(\"# chunk %d, %d bytes\", chunk_index, to_dump);\n+    st->print_data((void*) data, to_dump, true, false);\n+    chunk_index++;\n+  }\n+}\n+\n+void HotSpotCompiledCodeStream::dump_buffer_tail(int len, outputStream* st) const {\n+  const u1* start;\n+  int avail = _pos - _chunk->data();\n+  if (len >= avail) {\n+    len = avail;\n+    start = _chunk->data();\n+  } else {\n+    start = _pos - len;\n+\n+    \/\/ Ensure start is 16-byte aligned wrt chunk start\n+    int start_offset = start - _chunk->data();\n+    start -= (start_offset % 16);\n+    len = _pos - start;\n+  }\n+\n+  st->print_cr(\"Last %d bytes up to current read position \" INTPTR_FORMAT \" in HotSpotCompiledCode stream for %s:\", len, p2i(_pos), code_desc());\n+  st->print_data((void*) start, len, true, false);\n+}\n+\n+const char* HotSpotCompiledCodeStream::context() const {\n+  stringStream st;\n+  st.cr();\n+  st.print_cr(\"at \" INTPTR_FORMAT \" in HotSpotCompiledCode stream\", p2i(_pos));\n+  dump_buffer_tail(100, &st);\n+  return st.as_string();\n+}\n+\n+void HotSpotCompiledCodeStream::before_read(u1 size) {\n+  if (_pos + size > _chunk->data_end()) {\n+    Chunk* next = _chunk->next();\n+    if (next == nullptr || size > next->size()) {\n+      dump_buffer();\n+      fatal(\"%s: reading %d bytes overflows buffer at \" INTPTR_FORMAT, code_desc(), size, p2i(_pos));\n+    }\n+    _chunk = next;\n+    _pos = _chunk->data();\n+  }\n+}\n+\n+\/\/ Reads a size followed by an ascii string from the stream and\n+\/\/ checks that they match `expect_size` and `expect_name` respectively. This\n+\/\/ implements a rudimentary type checking of the stream between the stream producer\n+\/\/ (Java) and the consumer (C++).\n+void HotSpotCompiledCodeStream::check_data(u2 expect_size, const char* expect_name) {\n+  u2 actual_size = get_u1();\n+  u2 ascii_len = get_u1();\n+  const char* actual_name = (const char*) _pos;\n+  char* end = (char*) _pos + ascii_len;\n+  _pos = (const u1*) end;\n+  if (strlen(expect_name) != ascii_len || strncmp(expect_name, actual_name, ascii_len) != 0) {\n+    dump_buffer();\n+    fatal(\"%s: expected \\\"%s\\\" at \" INTPTR_FORMAT \", got \\\"%.*s\\\" (len: %d)\",\n+        code_desc(), expect_name, p2i(actual_name), ascii_len, actual_name, ascii_len);\n+  }\n+  if (actual_size != expect_size) {\n+    dump_buffer();\n+    fatal(\"%s: expected \\\"%s\\\" at \" INTPTR_FORMAT \" to have size %u, got %u\",\n+        code_desc(), expect_name, p2i(actual_name), expect_size, actual_size);\n+  }\n+}\n+\n+const char* HotSpotCompiledCodeStream::read_utf8(const char* name, JVMCI_TRAPS) {\n+  jint utf_len = read_s4(name);\n+  if (utf_len == -1) {\n+    return nullptr;\n+  }\n+  guarantee(utf_len >= 0, \"bad utf_len: %d\", utf_len);\n+\n+  const char* utf = (const char*) _pos;\n+  char* end = (char*) _pos + utf_len;\n+  _pos = (const u1*) (end + 1);\n+  if (*end != '\\0') {\n+    JVMCI_ERROR_NULL(\"UTF8 string at \" INTPTR_FORMAT \" of length %d missing 0 terminator: \\\"%.*s\\\"%s\",\n+        p2i(utf), utf_len, utf_len, utf, context());\n+  }\n+  return utf;\n+}\n+\n+Method* HotSpotCompiledCodeStream::read_method(const char* name) {\n+  return (Method*) read_u8(name);\n+}\n+\n+Klass* HotSpotCompiledCodeStream::read_klass(const char* name) {\n+  return (Klass*) read_u8(name);\n+}\n+\n+ScopeValue* HotSpotCompiledCodeStream::virtual_object_at(int id, JVMCI_TRAPS) const {\n+  if (_virtual_objects == nullptr) {\n+    JVMCI_ERROR_NULL(\"virtual object id %d read outside scope of decoding DebugInfo%s\", id, context());\n+  }\n+  if (id < 0 || id >= _virtual_objects->length()) {\n+    JVMCI_ERROR_NULL(\"invalid virtual object id %d%s\", id, context());\n+  }\n+  return _virtual_objects->at(id);\n+}\n+\n+#ifndef PRODUCT\n+void CodeInstaller::verify_bci_constants(JVMCIEnv* env) {\n+#define CHECK_IN_SYNC(name) do { \\\n+  int expect = env->get_BytecodeFrame_ ## name ##_BCI(); \\\n+  int actual = name##_BCI; \\\n+  if (expect != actual) fatal(\"CodeInstaller::\" #name \"_BCI(%d) != BytecodeFrame.\" #name \"_BCI(%d)\", expect, actual); \\\n+} while(0)\n+\n+  CHECK_IN_SYNC(UNWIND);\n+  CHECK_IN_SYNC(BEFORE);\n+  CHECK_IN_SYNC(AFTER);\n+  CHECK_IN_SYNC(AFTER_EXCEPTION);\n+  CHECK_IN_SYNC(UNKNOWN);\n+  CHECK_IN_SYNC(INVALID_FRAMESTATE);\n+#undef CHECK_IN_SYNC\n+}\n+#endif\n+\n+VMReg CodeInstaller::getVMRegFromLocation(HotSpotCompiledCodeStream* stream, int total_frame_size, JVMCI_TRAPS) {\n+  u2 reg = stream->read_u2(\"register\");\n+  u2 offset = stream->read_u2(\"offset\");\n+\n+  if (reg != NO_REGISTER) {\n+    VMReg vmReg = CodeInstaller::get_hotspot_reg(reg, JVMCI_CHECK_NULL);\n@@ -70,1 +227,1 @@\n-      JVMCI_ERROR_NULL(\"unaligned subregister offset %d in oop map\", offset);\n+      JVMCI_ERROR_NULL(\"unaligned subregister offset %d in oop map%s\", offset, stream->context());\n@@ -73,1 +230,0 @@\n-    \/\/ stack slot\n@@ -83,2 +239,2 @@\n-        JVMCI_ERROR_NULL(\"stack offset %d is too large to be encoded in OopMap (max %d)\",\n-                         offset, CompilerToVM::Data::max_oop_map_stack_offset());\n+        JVMCI_ERROR_NULL(\"stack offset %d is too large to be encoded in OopMap (max %d)%s\",\n+                         offset, CompilerToVM::Data::max_oop_map_stack_offset(), stream->context());\n@@ -89,1 +245,1 @@\n-      JVMCI_ERROR_NULL(\"unaligned stack offset %d in oop map\", offset);\n+      JVMCI_ERROR_NULL(\"unaligned stack offset %d in oop map%s\", offset, stream->context());\n@@ -94,10 +250,4 @@\n-\/\/ creates a HotSpot oop map out of the byte arrays provided by DebugInfo\n-OopMap* CodeInstaller::create_oop_map(JVMCIObject debug_info, JVMCI_TRAPS) {\n-  JVMCIObject reference_map = jvmci_env()->get_DebugInfo_referenceMap(debug_info);\n-  if (reference_map.is_null()) {\n-    JVMCI_THROW_NULL(NullPointerException);\n-  }\n-  if (!jvmci_env()->isa_HotSpotReferenceMap(reference_map)) {\n-    JVMCI_ERROR_NULL(\"unknown reference map: %s\", jvmci_env()->klass_name(reference_map));\n-  }\n-  if (!_has_wide_vector && SharedRuntime::is_wide_vector(jvmci_env()->get_HotSpotReferenceMap_maxRegisterSize(reference_map))) {\n+OopMap* CodeInstaller::create_oop_map(HotSpotCompiledCodeStream* stream, u1 debug_info_flags, JVMCI_TRAPS) {\n+  assert(is_set(debug_info_flags, DI_HAS_REFERENCE_MAP), \"must be\");\n+  u2 max_register_size = stream->read_u2(\"maxRegisterSize\");\n+  if (!_has_wide_vector && SharedRuntime::is_wide_vector(max_register_size)) {\n@@ -105,1 +255,1 @@\n-      JVMCI_ERROR_NULL(\"JVMCI is producing code using vectors larger than the runtime supports\");\n+      JVMCI_ERROR_NULL(\"JVMCI is producing code using vectors larger than the runtime supports%s\", stream->context());\n@@ -109,14 +259,1 @@\n-  OopMap* map = new OopMap(_total_frame_size, _parameter_count);\n-  JVMCIObjectArray objects = jvmci_env()->get_HotSpotReferenceMap_objects(reference_map);\n-  JVMCIObjectArray derivedBase = jvmci_env()->get_HotSpotReferenceMap_derivedBase(reference_map);\n-  JVMCIPrimitiveArray sizeInBytes = jvmci_env()->get_HotSpotReferenceMap_sizeInBytes(reference_map);\n-  if (objects.is_null() || derivedBase.is_null() || sizeInBytes.is_null()) {\n-    JVMCI_THROW_NULL(NullPointerException);\n-  }\n-  if (JVMCIENV->get_length(objects) != JVMCIENV->get_length(derivedBase) || JVMCIENV->get_length(objects) != JVMCIENV->get_length(sizeInBytes)) {\n-    JVMCI_ERROR_NULL(\"arrays in reference map have different sizes: %d %d %d\", JVMCIENV->get_length(objects), JVMCIENV->get_length(derivedBase), JVMCIENV->get_length(sizeInBytes));\n-  }\n-  for (int i = 0; i < JVMCIENV->get_length(objects); i++) {\n-    JVMCIObject location = JVMCIENV->get_object_at(objects, i);\n-    JVMCIObject baseLocation = JVMCIENV->get_object_at(derivedBase, i);\n-    jint bytes = JVMCIENV->get_int_at(sizeInBytes, i);\n+  u2 length = stream->read_u2(\"referenceMap:length\");\n@@ -124,2 +261,6 @@\n-    VMReg vmReg = getVMRegFromLocation(location, _total_frame_size, JVMCI_CHECK_NULL);\n-    if (baseLocation.is_non_null()) {\n+  OopMap* map = new OopMap(_total_frame_size, _parameter_count);\n+  for (int i = 0; i < length; i++) {\n+    bool has_derived = stream->read_bool(\"hasDerived\");\n+    u2 bytes = stream->read_u2(\"sizeInBytes\");\n+    VMReg vmReg = getVMRegFromLocation(stream, _total_frame_size, JVMCI_CHECK_NULL);\n+    if (has_derived) {\n@@ -127,6 +268,2 @@\n-#ifdef _LP64\n-      if (bytes == 8) {\n-#else\n-      if (bytes == 4) {\n-#endif\n-        VMReg baseReg = getVMRegFromLocation(baseLocation, _total_frame_size, JVMCI_CHECK_NULL);\n+      if (bytes == LP64_ONLY(8) NOT_LP64(4)) {\n+        VMReg baseReg = getVMRegFromLocation(stream, _total_frame_size, JVMCI_CHECK_NULL);\n@@ -135,1 +272,1 @@\n-        JVMCI_ERROR_NULL(\"invalid derived oop size in ReferenceMap: %d\", bytes);\n+        JVMCI_ERROR_NULL(\"invalid derived oop size in ReferenceMap: %d%s\", bytes, stream->context());\n@@ -149,1 +286,1 @@\n-      JVMCI_ERROR_NULL(\"invalid oop size in ReferenceMap: %d\", bytes);\n+      JVMCI_ERROR_NULL(\"invalid oop size in ReferenceMap: %d%s\", bytes, stream->context());\n@@ -153,7 +290,4 @@\n-  JVMCIObject callee_save_info = jvmci_env()->get_DebugInfo_calleeSaveInfo(debug_info);\n-  if (callee_save_info.is_non_null()) {\n-    JVMCIObjectArray registers = jvmci_env()->get_RegisterSaveLayout_registers(callee_save_info);\n-    JVMCIPrimitiveArray slots = jvmci_env()->get_RegisterSaveLayout_slots(callee_save_info);\n-    for (jint i = 0; i < JVMCIENV->get_length(slots); i++) {\n-      JVMCIObject jvmci_reg = JVMCIENV->get_object_at(registers, i);\n-      jint jvmci_reg_number = jvmci_env()->get_code_Register_number(jvmci_reg);\n+  if (is_set(debug_info_flags, DI_HAS_CALLEE_SAVE_INFO)) {\n+    length = stream->read_u2(\"calleeSaveInfo:length\");\n+    for (jint i = 0; i < length; i++) {\n+      u2 jvmci_reg_number = stream->read_u2(\"register\");\n@@ -162,1 +296,1 @@\n-      jint jvmci_slot = JVMCIENV->get_int_at(slots, i);\n+      u2 jvmci_slot = stream->read_u2(\"slot\");\n@@ -176,1 +310,1 @@\n-void* CodeInstaller::record_metadata_reference(CodeSection* section, address dest, JVMCIObject constant, JVMCI_TRAPS) {\n+void* CodeInstaller::record_metadata_reference(CodeSection* section, address dest, HotSpotCompiledCodeStream* stream, u1 tag, JVMCI_TRAPS) {\n@@ -183,4 +317,2 @@\n-  JVMCIObject obj = jvmci_env()->get_HotSpotMetaspaceConstantImpl_metaspaceObject(constant);\n-  if (jvmci_env()->isa_HotSpotResolvedObjectTypeImpl(obj)) {\n-    Klass* klass = JVMCIENV->asKlass(obj);\n-    assert(!jvmci_env()->get_HotSpotMetaspaceConstantImpl_compressed(constant), \"unexpected compressed klass pointer %s @ \" INTPTR_FORMAT, klass->name()->as_C_string(), p2i(klass));\n+  if (tag == PATCH_KLASS) {\n+    Klass* klass = stream->read_klass(\"patch:klass\");\n@@ -191,3 +323,2 @@\n-  } else if (jvmci_env()->isa_HotSpotResolvedJavaMethodImpl(obj)) {\n-    Method* method = jvmci_env()->asMethod(obj);\n-    assert(!jvmci_env()->get_HotSpotMetaspaceConstantImpl_compressed(constant), \"unexpected compressed method pointer %s @ \" INTPTR_FORMAT, method->name()->as_C_string(), p2i(method));\n+  } else if (tag == PATCH_METHOD) {\n+    Method* method = stream->read_method(\"patch:method\");\n@@ -199,1 +330,1 @@\n-    JVMCI_ERROR_NULL(\"unexpected metadata reference for constant of type %s\", jvmci_env()->klass_name(obj));\n+    JVMCI_ERROR_NULL(\"unexpected metadata reference tag: %d%s\", tag, stream->context());\n@@ -204,6 +335,3 @@\n-narrowKlass CodeInstaller::record_narrow_metadata_reference(CodeSection* section, address dest, JVMCIObject constant, JVMCI_TRAPS) {\n-  JVMCIObject obj = jvmci_env()->get_HotSpotMetaspaceConstantImpl_metaspaceObject(constant);\n-  assert(jvmci_env()->get_HotSpotMetaspaceConstantImpl_compressed(constant), \"unexpected uncompressed pointer\");\n-\n-  if (!jvmci_env()->isa_HotSpotResolvedObjectTypeImpl(obj)) {\n-    JVMCI_ERROR_0(\"unexpected compressed pointer of type %s\", jvmci_env()->klass_name(obj));\n+narrowKlass CodeInstaller::record_narrow_metadata_reference(CodeSection* section, address dest, HotSpotCompiledCodeStream* stream, u1 tag, JVMCI_TRAPS) {\n+  if (tag != PATCH_NARROW_KLASS) {\n+    JVMCI_ERROR_0(\"unexpected compressed pointer tag %d%s\", tag, stream->context());\n@@ -211,2 +339,1 @@\n-\n-  Klass* klass = JVMCIENV->asKlass(obj);\n+  Klass* klass = stream->read_klass(\"patch:klass\");\n@@ -220,3 +347,18 @@\n-Location::Type CodeInstaller::get_oop_type(JVMCIObject value) {\n-  JVMCIObject valueKind = jvmci_env()->get_Value_valueKind(value);\n-  JVMCIObject platformKind = jvmci_env()->get_ValueKind_platformKind(valueKind);\n+ScopeValue* CodeInstaller::to_primitive_value(HotSpotCompiledCodeStream* stream, jlong raw, BasicType type, ScopeValue* &second, JVMCI_TRAPS) {\n+  if (type == T_INT || type == T_FLOAT) {\n+    jint prim = (jint) raw;\n+    switch (prim) {\n+      case -1: return _int_m1_scope_value;\n+      case  0: return _int_0_scope_value;\n+      case  1: return _int_1_scope_value;\n+      case  2: return _int_2_scope_value;\n+      default: return new ConstantIntValue(prim);\n+    }\n+  } else if (type == T_LONG || type == T_DOUBLE) {\n+    jlong prim = raw;\n+    second = _int_1_scope_value;\n+    return new ConstantLongValue(prim);\n+  } else {\n+    JVMCI_ERROR_NULL(\"unexpected primitive constant type %s%s\", basictype_to_str(type), stream->context());\n+  }\n+}\n@@ -224,2 +366,14 @@\n-  if (jvmci_env()->equals(platformKind, word_kind())) {\n-    return Location::oop;\n+Handle CodeInstaller::read_oop(HotSpotCompiledCodeStream* stream, u1 tag, JVMCI_TRAPS) {\n+  oop obj;\n+  if (tag == OBJECT_ID) {\n+    obj = stream->get_oop(stream->read_u1(\"id\"), JVMCI_CHECK_(Handle()));\n+  } else if (tag == OBJECT_ID2) {\n+    obj = stream->get_oop(stream->read_u2(\"id:2\"), JVMCI_CHECK_(Handle()));\n+  } else if (tag == JOBJECT) {\n+    jlong object_handle = stream->read_u8(\"jobject\");\n+    obj = jvmci_env()->resolve_oop_handle(object_handle);\n+  } else {\n+    JVMCI_ERROR_(Handle(), \"unexpected oop tag: %d\", tag)\n+  }\n+  if (obj == nullptr) {\n+    JVMCI_THROW_MSG_(InternalError, \"Constant was unexpectedly NULL\", Handle());\n@@ -227,1 +381,1 @@\n-    return Location::narrowoop;\n+    oopDesc::verify(obj);\n@@ -229,0 +383,1 @@\n+  return Handle(stream->thread(), obj);\n@@ -231,1 +386,1 @@\n-ScopeValue* CodeInstaller::get_scope_value(JVMCIObject value, BasicType type, GrowableArray<ScopeValue*>* objects, ScopeValue* &second, JVMCI_TRAPS) {\n+ScopeValue* CodeInstaller::get_scope_value(HotSpotCompiledCodeStream* stream, u1 tag, BasicType type, ScopeValue* &second, JVMCI_TRAPS) {\n@@ -233,5 +388,6 @@\n-  if (value.is_null()) {\n-    JVMCI_THROW_NULL(NullPointerException);\n-  } else if (JVMCIENV->equals(value, jvmci_env()->get_Value_ILLEGAL())) {\n-    if (type != T_ILLEGAL) {\n-      JVMCI_ERROR_NULL(\"unexpected illegal value, expected %s\", basictype_to_str(type));\n+  switch (tag) {\n+    case ILLEGAL: {\n+      if (type != T_ILLEGAL) {\n+        JVMCI_ERROR_NULL(\"unexpected illegal value, expected %s%s\", basictype_to_str(type), stream->context());\n+      }\n+      return _illegal_value;\n@@ -239,13 +395,21 @@\n-    return _illegal_value;\n-  } else if (jvmci_env()->isa_RegisterValue(value)) {\n-    JVMCIObject reg = jvmci_env()->get_RegisterValue_reg(value);\n-    jint number = jvmci_env()->get_code_Register_number(reg);\n-    VMReg hotspotRegister = get_hotspot_reg(number, JVMCI_CHECK_NULL);\n-    if (is_general_purpose_reg(hotspotRegister)) {\n-      Location::Type locationType;\n-      if (type == T_OBJECT) {\n-        locationType = get_oop_type(value);\n-      } else if (type == T_LONG) {\n-        locationType = Location::lng;\n-      } else if (type == T_INT || type == T_FLOAT || type == T_SHORT || type == T_CHAR || type == T_BYTE || type == T_BOOLEAN) {\n-        locationType = Location::int_in_long;\n+    case REGISTER_PRIMITIVE:\n+    case REGISTER_NARROW_OOP:\n+    case REGISTER_OOP: {\n+      u2 number = stream->read_u2(\"register\");\n+      VMReg hotspotRegister = get_hotspot_reg(number, JVMCI_CHECK_NULL);\n+      if (is_general_purpose_reg(hotspotRegister)) {\n+        Location::Type locationType;\n+        if (type == T_OBJECT) {\n+          locationType = tag == REGISTER_NARROW_OOP ? Location::narrowoop : Location::oop;\n+        } else if (type == T_LONG) {\n+          locationType = Location::lng;\n+        } else if (type == T_INT || type == T_FLOAT || type == T_SHORT || type == T_CHAR || type == T_BYTE || type == T_BOOLEAN) {\n+          locationType = Location::int_in_long;\n+        } else {\n+          JVMCI_ERROR_NULL(\"unexpected type %s in CPU register%s\", basictype_to_str(type), stream->context());\n+        }\n+        ScopeValue* value = new LocationValue(Location::new_reg_loc(locationType, hotspotRegister));\n+        if (type == T_LONG) {\n+          second = value;\n+        }\n+        return value;\n@@ -253,1 +417,14 @@\n-        JVMCI_ERROR_NULL(\"unexpected type %s in cpu register\", basictype_to_str(type));\n+        Location::Type locationType;\n+        if (type == T_FLOAT) {\n+          \/\/ this seems weird, but the same value is used in c1_LinearScan\n+          locationType = Location::normal;\n+        } else if (type == T_DOUBLE) {\n+          locationType = Location::dbl;\n+        } else {\n+          JVMCI_ERROR_NULL(\"unexpected type %s in floating point register%s\", basictype_to_str(type), stream->context());\n+        }\n+        ScopeValue* value = new LocationValue(Location::new_reg_loc(locationType, hotspotRegister));\n+        if (type == T_DOUBLE) {\n+          second = value;\n+        }\n+        return value;\n@@ -255,3 +432,7 @@\n-      ScopeValue* value = new LocationValue(Location::new_reg_loc(locationType, hotspotRegister));\n-      if (type == T_LONG) {\n-        second = value;\n+    }\n+    case STACK_SLOT_PRIMITIVE:\n+    case STACK_SLOT_NARROW_OOP:\n+    case STACK_SLOT_OOP: {\n+      jint offset = (jshort) stream->read_s2(\"offset\");\n+      if (stream->read_bool(\"addRawFrameSize\")) {\n+        offset += _total_frame_size;\n@@ -259,2 +440,0 @@\n-      return value;\n-    } else {\n@@ -262,3 +441,4 @@\n-      if (type == T_FLOAT) {\n-        \/\/ this seems weird, but the same value is used in c1_LinearScan\n-        locationType = Location::normal;\n+      if (type == T_OBJECT) {\n+        locationType = tag == STACK_SLOT_NARROW_OOP ? Location::narrowoop : Location::oop;\n+      } else if (type == T_LONG) {\n+        locationType = Location::lng;\n@@ -267,0 +447,2 @@\n+      } else if (type == T_INT || type == T_FLOAT || type == T_SHORT || type == T_CHAR || type == T_BYTE || type == T_BOOLEAN) {\n+        locationType = Location::normal;\n@@ -268,1 +450,1 @@\n-        JVMCI_ERROR_NULL(\"unexpected type %s in floating point register\", basictype_to_str(type));\n+        JVMCI_ERROR_NULL(\"unexpected type %s in stack slot%s\", basictype_to_str(type), stream->context());\n@@ -270,2 +452,2 @@\n-      ScopeValue* value = new LocationValue(Location::new_reg_loc(locationType, hotspotRegister));\n-      if (type == T_DOUBLE) {\n+      ScopeValue* value = new LocationValue(Location::new_stk_loc(locationType, offset));\n+      if (type == T_DOUBLE || type == T_LONG) {\n@@ -276,4 +458,13 @@\n-  } else if (jvmci_env()->isa_StackSlot(value)) {\n-    jint offset = jvmci_env()->get_StackSlot_offset(value);\n-    if (jvmci_env()->get_StackSlot_addFrameSize(value)) {\n-      offset += _total_frame_size;\n+    case NULL_CONSTANT:      { return _oop_null_scope_value; }\n+    case RAW_CONSTANT:       { return new ConstantLongValue(stream->read_u8(\"primitive\")); }\n+    case PRIMITIVE_0:        { ScopeValue* v = to_primitive_value(stream, 0, type, second, JVMCI_CHECK_NULL); return v; }\n+    case PRIMITIVE4:         { ScopeValue* v = to_primitive_value(stream, stream->read_s4(\"primitive4\"), type, second, JVMCI_CHECK_NULL); return v; }\n+    case PRIMITIVE8:         { ScopeValue* v = to_primitive_value(stream, stream->read_s8(\"primitive8\"), type, second, JVMCI_CHECK_NULL); return v; }\n+    case VIRTUAL_OBJECT_ID:  { ScopeValue* v = stream->virtual_object_at(stream->read_u1(\"id\"),   JVMCI_CHECK_NULL); return v; }\n+    case VIRTUAL_OBJECT_ID2: { ScopeValue* v = stream->virtual_object_at(stream->read_u2(\"id:2\"), JVMCI_CHECK_NULL); return v; }\n+\n+    case OBJECT_ID:\n+    case OBJECT_ID2:\n+    case JOBJECT: {\n+      Handle obj = read_oop(stream, tag, JVMCI_CHECK_NULL);\n+      return new ConstantOopWriteValue(JNIHandles::make_local(obj()));\n@@ -281,74 +472,2 @@\n-\n-    Location::Type locationType;\n-    if (type == T_OBJECT) {\n-      locationType = get_oop_type(value);\n-    } else if (type == T_LONG) {\n-      locationType = Location::lng;\n-    } else if (type == T_DOUBLE) {\n-      locationType = Location::dbl;\n-    } else if (type == T_INT || type == T_FLOAT || type == T_SHORT || type == T_CHAR || type == T_BYTE || type == T_BOOLEAN) {\n-      locationType = Location::normal;\n-    } else {\n-      JVMCI_ERROR_NULL(\"unexpected type %s in stack slot\", basictype_to_str(type));\n-    }\n-    ScopeValue* value = new LocationValue(Location::new_stk_loc(locationType, offset));\n-    if (type == T_DOUBLE || type == T_LONG) {\n-      second = value;\n-    }\n-    return value;\n-  } else if (jvmci_env()->isa_JavaConstant(value)) {\n-    if (jvmci_env()->isa_PrimitiveConstant(value)) {\n-      if (jvmci_env()->isa_RawConstant(value)) {\n-        jlong prim = jvmci_env()->get_PrimitiveConstant_primitive(value);\n-        return new ConstantLongValue(prim);\n-      } else {\n-        BasicType constantType = jvmci_env()->kindToBasicType(jvmci_env()->get_PrimitiveConstant_kind(value), JVMCI_CHECK_NULL);\n-        if (type != constantType) {\n-          JVMCI_ERROR_NULL(\"primitive constant type doesn't match, expected %s but got %s\", basictype_to_str(type), basictype_to_str(constantType));\n-        }\n-        if (type == T_INT || type == T_FLOAT) {\n-          jint prim = (jint)jvmci_env()->get_PrimitiveConstant_primitive(value);\n-          switch (prim) {\n-            case -1: return _int_m1_scope_value;\n-            case  0: return _int_0_scope_value;\n-            case  1: return _int_1_scope_value;\n-            case  2: return _int_2_scope_value;\n-            default: return new ConstantIntValue(prim);\n-          }\n-        } else if (type == T_LONG || type == T_DOUBLE) {\n-          jlong prim = jvmci_env()->get_PrimitiveConstant_primitive(value);\n-          second = _int_1_scope_value;\n-          return new ConstantLongValue(prim);\n-        } else {\n-          JVMCI_ERROR_NULL(\"unexpected primitive constant type %s\", basictype_to_str(type));\n-        }\n-      }\n-    } else if (jvmci_env()->isa_NullConstant(value) || jvmci_env()->isa_HotSpotCompressedNullConstant(value)) {\n-      if (type == T_OBJECT) {\n-        return _oop_null_scope_value;\n-      } else {\n-        JVMCI_ERROR_NULL(\"unexpected null constant, expected %s\", basictype_to_str(type));\n-      }\n-    } else if (jvmci_env()->isa_HotSpotObjectConstantImpl(value)) {\n-      if (type == T_OBJECT) {\n-        Handle obj = jvmci_env()->asConstant(value, JVMCI_CHECK_NULL);\n-        if (obj == NULL) {\n-          JVMCI_ERROR_NULL(\"null value must be in NullConstant\");\n-        }\n-        return new ConstantOopWriteValue(JNIHandles::make_local(obj()));\n-      } else {\n-        JVMCI_ERROR_NULL(\"unexpected object constant, expected %s\", basictype_to_str(type));\n-      }\n-    }\n-  } else if (jvmci_env()->isa_VirtualObject(value)) {\n-    if (type == T_OBJECT) {\n-      int id = jvmci_env()->get_VirtualObject_id(value);\n-      if (0 <= id && id < objects->length()) {\n-        ScopeValue* object = objects->at(id);\n-        if (object != NULL) {\n-          return object;\n-        }\n-      }\n-      JVMCI_ERROR_NULL(\"unknown virtual object id %d\", id);\n-    } else {\n-      JVMCI_ERROR_NULL(\"unexpected virtual object, expected %s\", basictype_to_str(type));\n+    default: {\n+      JVMCI_ERROR_NULL(\"unexpected tag in scope: %d%s\", tag, stream->context())\n@@ -357,2 +476,0 @@\n-\n-  JVMCI_ERROR_NULL(\"unexpected value in scope: %s\", jvmci_env()->klass_name(value))\n@@ -361,4 +478,3 @@\n-void CodeInstaller::record_object_value(ObjectValue* sv, JVMCIObject value, GrowableArray<ScopeValue*>* objects, JVMCI_TRAPS) {\n-  JVMCIObject type = jvmci_env()->get_VirtualObject_type(value);\n-  int id = jvmci_env()->get_VirtualObject_id(value);\n-  Klass* klass = JVMCIENV->asKlass(type);\n+void CodeInstaller::record_object_value(ObjectValue* sv, HotSpotCompiledCodeStream* stream, JVMCI_TRAPS) {\n+  oop javaMirror = JNIHandles::resolve(sv->klass()->as_ConstantOopWriteValue()->value());\n+  Klass* klass = java_lang_Class::as_Klass(javaMirror);\n@@ -368,3 +484,2 @@\n-  JVMCIObjectArray values = jvmci_env()->get_VirtualObject_values(value);\n-  JVMCIObjectArray slotKinds = jvmci_env()->get_VirtualObject_slotKinds(value);\n-  for (jint i = 0; i < JVMCIENV->get_length(values); i++) {\n+  u2 length = stream->read_u2(\"values:length\");\n+  for (jint i = 0; i < length; i++) {\n@@ -372,2 +487,1 @@\n-    JVMCIObject object = JVMCIENV->get_object_at(values, i);\n-    BasicType type = jvmci_env()->kindToBasicType(JVMCIENV->get_object_at(slotKinds, i), JVMCI_CHECK);\n+    BasicType type = (BasicType) stream->read_u1(\"basicType\");\n@@ -375,1 +489,2 @@\n-    if (JVMCIENV->equals(object, jvmci_env()->get_Value_ILLEGAL())) {\n+    u1 tag = stream->read_u1(\"tag\");\n+    if (tag == ILLEGAL) {\n@@ -390,1 +505,1 @@\n-      value = get_scope_value(object, type, objects, cur_second, JVMCI_CHECK);\n+      value = get_scope_value(stream, tag, type, cur_second, JVMCI_CHECK);\n@@ -413,3 +528,12 @@\n-MonitorValue* CodeInstaller::get_monitor_value(JVMCIObject value, GrowableArray<ScopeValue*>* objects, JVMCI_TRAPS) {\n-  if (value.is_null()) {\n-    JVMCI_THROW_NULL(NullPointerException);\n+GrowableArray<ScopeValue*>* CodeInstaller::read_local_or_stack_values(HotSpotCompiledCodeStream* stream, u1 frame_flags, bool is_locals, JVMCI_TRAPS) {\n+  u2 length;\n+  if (is_locals) {\n+    if (!is_set(frame_flags, DIF_HAS_LOCALS)) {\n+      return nullptr;\n+    }\n+    length = stream->read_u2(\"numLocals\");\n+  } else {\n+    if (!is_set(frame_flags, DIF_HAS_STACK)) {\n+      return nullptr;\n+    }\n+    length = stream->read_u2(\"numStack\");\n@@ -417,2 +541,19 @@\n-  if (!jvmci_env()->isa_StackLockValue(value)) {\n-    JVMCI_ERROR_NULL(\"Monitors must be of type StackLockValue, got %s\", jvmci_env()->klass_name(value));\n+  GrowableArray<ScopeValue*>* values = new GrowableArray<ScopeValue*> (length);\n+  for (int i = 0; i < length; i++) {\n+    ScopeValue* second = nullptr;\n+    BasicType type = (BasicType) stream->read_u1(\"basicType\");\n+    u1 tag = stream->read_u1(\"tag\");\n+    ScopeValue* first = get_scope_value(stream, tag, type, second, JVMCI_CHECK_NULL);\n+    if (second != nullptr) {\n+      if (i == length) {\n+        JVMCI_ERROR_NULL(\"double-slot value not followed by Value.ILLEGAL%s\", stream->context());\n+      }\n+      i++;\n+      stream->read_u1(\"basicType\");\n+      tag = stream->read_u1(\"tag\");\n+      if (tag != ILLEGAL) {\n+        JVMCI_ERROR_NULL(\"double-slot value not followed by Value.ILLEGAL%s\", stream->context());\n+      }\n+      values->append(second);\n+    }\n+    values->append(first);\n@@ -420,0 +561,2 @@\n+  return values;\n+}\n@@ -421,12 +564,3 @@\n-  ScopeValue* second = NULL;\n-  ScopeValue* owner_value = get_scope_value(jvmci_env()->get_StackLockValue_owner(value), T_OBJECT, objects, second, JVMCI_CHECK_NULL);\n-  assert(second == NULL, \"monitor cannot occupy two stack slots\");\n-\n-  ScopeValue* lock_data_value = get_scope_value(jvmci_env()->get_StackLockValue_slot(value), T_LONG, objects, second, JVMCI_CHECK_NULL);\n-  assert(second == lock_data_value, \"monitor is LONG value that occupies two stack slots\");\n-  assert(lock_data_value->is_location(), \"invalid monitor location\");\n-  Location lock_data_loc = ((LocationValue*)lock_data_value)->location();\n-\n-  bool eliminated = false;\n-  if (jvmci_env()->get_StackLockValue_eliminated(value)) {\n-    eliminated = true;\n+GrowableArray<MonitorValue*>* CodeInstaller::read_monitor_values(HotSpotCompiledCodeStream* stream, u1 frame_flags, JVMCI_TRAPS) {\n+  if (!is_set(frame_flags, DIF_HAS_LOCKS)) {\n+    return nullptr;\n@@ -434,2 +568,19 @@\n-\n-  return new MonitorValue(owner_value, lock_data_loc, eliminated);\n+  if (!_has_monitors) {\n+    _has_monitors = true;\n+  }\n+  u2 length = stream->read_u2(\"numLocks\");\n+  GrowableArray<MonitorValue*>* monitors = new GrowableArray<MonitorValue*>(length);\n+  for (int i = 0; i < length; i++) {\n+    bool eliminated = stream->read_bool(\"isEliminated\");\n+    ScopeValue* second = NULL;\n+    ScopeValue* owner_value = get_scope_value(stream, stream->read_u1(\"tag\"), T_OBJECT, second, JVMCI_CHECK_NULL);\n+    assert(second == NULL, \"monitor cannot occupy two stack slots\");\n+\n+    ScopeValue* lock_data_value = get_scope_value(stream, stream->read_u1(\"tag\"), T_LONG, second, JVMCI_CHECK_NULL);\n+    assert(second == lock_data_value, \"monitor is LONG value that occupies two stack slots\");\n+    assert(lock_data_value->is_location(), \"invalid monitor location\");\n+    Location lock_data_loc = ((LocationValue*) lock_data_value)->location();\n+\n+    monitors->append(new MonitorValue(owner_value, lock_data_loc, eliminated));\n+  }\n+  return monitors;\n@@ -438,2 +589,2 @@\n-void CodeInstaller::initialize_dependencies(JVMCIObject compiled_code, OopRecorder* oop_recorder, JVMCI_TRAPS) {\n-  JavaThread* thread = JavaThread::current();\n+void CodeInstaller::initialize_dependencies(HotSpotCompiledCodeStream* stream, u1 code_flags, OopRecorder* oop_recorder, JVMCI_TRAPS) {\n+  JavaThread* thread = stream->thread();\n@@ -443,3 +594,2 @@\n-  JVMCIObjectArray assumptions = jvmci_env()->get_HotSpotCompiledCode_assumptions(compiled_code);\n-  if (assumptions.is_non_null()) {\n-    int length = JVMCIENV->get_length(assumptions);\n+  if (is_set(code_flags, HCC_HAS_ASSUMPTIONS)) {\n+    u2 length = stream->read_u2(\"assumptions:length\");\n@@ -447,14 +597,35 @@\n-      JVMCIObject assumption = JVMCIENV->get_object_at(assumptions, i);\n-      if (assumption.is_non_null()) {\n-        if (jvmci_env()->isa_Assumptions_NoFinalizableSubclass(assumption)) {\n-          assumption_NoFinalizableSubclass(assumption);\n-        } else if (jvmci_env()->isa_Assumptions_ConcreteSubtype(assumption)) {\n-          assumption_ConcreteSubtype(assumption);\n-        } else if (jvmci_env()->isa_Assumptions_LeafType(assumption)) {\n-          assumption_LeafType(assumption);\n-        } else if (jvmci_env()->isa_Assumptions_ConcreteMethod(assumption)) {\n-          assumption_ConcreteMethod(assumption);\n-        } else if (jvmci_env()->isa_Assumptions_CallSiteTargetValue(assumption)) {\n-          assumption_CallSiteTargetValue(assumption, JVMCI_CHECK);\n-        } else {\n-          JVMCI_ERROR(\"unexpected Assumption subclass %s\", jvmci_env()->klass_name(assumption));\n+      u1 tag = stream->read_u1(\"tag\");\n+      switch (tag) {\n+        case NO_FINALIZABLE_SUBCLASS: {\n+          Klass* receiver_type = stream->read_klass(\"receiverType\");\n+          _dependencies->assert_has_no_finalizable_subclasses(receiver_type);\n+          break;\n+        }\n+        case CONCRETE_SUBTYPE: {\n+          Klass* context = stream->read_klass(\"context\");\n+          Klass* subtype = stream->read_klass(\"subtype\");\n+          assert(context->is_abstract(), \"must be\");\n+          _dependencies->assert_abstract_with_unique_concrete_subtype(context, subtype);\n+          break;\n+        }\n+        case LEAF_TYPE: {\n+          Klass* context = stream->read_klass(\"context\");\n+          _dependencies->assert_leaf_type(context);\n+          break;\n+        }\n+        case CONCRETE_METHOD: {\n+          Klass* context = stream->read_klass(\"context\");\n+          Method* impl = stream->read_method(\"impl\");\n+          _dependencies->assert_unique_concrete_method(context, impl);\n+          break;\n+        }\n+        case CALLSITE_TARGET_VALUE: {\n+          u1 obj_tag = stream->read_u1(\"tag\");\n+          Handle callSite = read_oop(stream, obj_tag, JVMCI_CHECK);\n+          obj_tag = stream->read_u1(\"tag\");\n+          Handle methodHandle = read_oop(stream, obj_tag, JVMCI_CHECK);\n+          _dependencies->assert_call_site_target_value(callSite(), methodHandle());\n+          break;\n+        }\n+        default: {\n+          JVMCI_ERROR(\"unexpected assumption tag %d%s\", tag, stream->context());\n@@ -465,7 +636,5 @@\n-  if (JvmtiExport::can_hotswap_or_post_breakpoint()) {\n-    JVMCIObjectArray methods = jvmci_env()->get_HotSpotCompiledCode_methods(compiled_code);\n-    if (methods.is_non_null()) {\n-      int length = JVMCIENV->get_length(methods);\n-      for (int i = 0; i < length; ++i) {\n-        JVMCIObject method_handle = JVMCIENV->get_object_at(methods, i);\n-        Method* method = jvmci_env()->asMethod(method_handle);\n+  if (is_set(code_flags, HCC_HAS_METHODS)) {\n+    u2 length = stream->read_u2(\"methods:length\");\n+    for (int i = 0; i < length; ++i) {\n+      Method* method = stream->read_method(\"method\");\n+      if (JvmtiExport::can_hotswap_or_post_breakpoint()) {\n@@ -478,1 +647,0 @@\n-\/\/ constructor used to create a method\n@@ -480,1 +648,2 @@\n-    JVMCIObject target,\n+    jlong compiled_code_buffer,\n+    bool with_type_info,\n@@ -482,0 +651,1 @@\n+    objArrayHandle object_pool,\n@@ -490,0 +660,22 @@\n+  JavaThread* thread = JavaThread::current();\n+  HotSpotCompiledCodeStream* stream = new HotSpotCompiledCodeStream(thread, (const u1*) compiled_code_buffer, with_type_info, object_pool);\n+\n+  u1 code_flags = stream->read_u1(\"code:flags\");\n+  bool is_nmethod = is_set(code_flags, HCC_IS_NMETHOD);\n+  const char* name = stream->read_utf8(\"name\", JVMCI_CHECK_OK);\n+\n+  methodHandle method;\n+  jint entry_bci = -1;\n+  JVMCICompileState* compile_state = nullptr;\n+  bool has_unsafe_access = false;\n+  jint id = -1;\n+\n+  if (is_nmethod) {\n+    method = methodHandle(thread, stream->read_method(\"method\"));\n+    entry_bci = is_nmethod ? stream->read_s4(\"entryBCI\") : -1;\n+    compile_state = (JVMCICompileState*) stream->read_u8(\"compileState\");\n+    has_unsafe_access = stream->read_bool(\"hasUnsafeAccess\");\n+    id = stream->read_s4(\"id\");\n+  }\n+  stream->set_code_desc(name, method);\n+\n@@ -492,1 +684,1 @@\n-  initialize_dependencies(compiled_code, recorder, JVMCI_CHECK_OK);\n+  initialize_dependencies(stream, code_flags, recorder, JVMCI_CHECK_OK);\n@@ -498,2 +690,8 @@\n-  initialize_fields(target, compiled_code, JVMCI_CHECK_OK);\n-  JVMCI::CodeInstallResult result = initialize_buffer(buffer, true, JVMCI_CHECK_OK);\n+  initialize_fields(stream, code_flags, method, JVMCI_CHECK_OK);\n+  JVMCI::CodeInstallResult result = initialize_buffer(compiled_code, buffer, stream, code_flags, JVMCI_CHECK_OK);\n+\n+  u4 available = stream->available();\n+  if (available != 0) {\n+    JVMCI_ERROR_OK(\"%d bytes remaining in stream%s\", available, stream->context());\n+  }\n+\n@@ -506,3 +704,2 @@\n-  if (!jvmci_env()->isa_HotSpotCompiledNmethod(compiled_code)) {\n-    JVMCIObject stubName = jvmci_env()->get_HotSpotCompiledCode_name(compiled_code);\n-    if (stubName.is_null()) {\n+  if (!is_nmethod) {\n+    if (name == nullptr) {\n@@ -511,1 +708,1 @@\n-    char* name = strdup(jvmci_env()->as_utf8_string(stubName));\n+    name = strdup(name);\n@@ -520,1 +717,0 @@\n-    JVMCICompileState* compile_state = (JVMCICompileState*) (address) jvmci_env()->get_HotSpotCompiledNmethod_compileState(compiled_code);\n@@ -525,6 +721,0 @@\n-    Thread* thread = Thread::current();\n-\n-    methodHandle method(thread, jvmci_env()->asMethod(jvmci_env()->get_HotSpotCompiledNmethod_method(compiled_code)));\n-    jint entry_bci = jvmci_env()->get_HotSpotCompiledNmethod_entryBCI(compiled_code);\n-    bool has_unsafe_access = jvmci_env()->get_HotSpotCompiledNmethod_hasUnsafeAccess(compiled_code) == JNI_TRUE;\n-    jint id = jvmci_env()->get_HotSpotCompiledNmethod_id(compiled_code);\n@@ -541,5 +731,23 @@\n-    result = runtime()->register_method(jvmci_env(), method, nmethod_handle, entry_bci, &_offsets, _orig_pc_offset, &buffer,\n-                                        stack_slots, _debug_recorder->_oopmaps, &_exception_handler_table, &_implicit_exception_table,\n-                                        compiler, _debug_recorder, _dependencies, id,\n-                                        _has_monitors, has_unsafe_access, _has_wide_vector, compiled_code, mirror,\n-                                        failed_speculations, speculations, speculations_len);\n+    result = runtime()->register_method(jvmci_env(),\n+                                        method,\n+                                        nmethod_handle,\n+                                        entry_bci,\n+                                        &_offsets,\n+                                        _orig_pc_offset,\n+                                        &buffer,\n+                                        stack_slots,\n+                                        _debug_recorder->_oopmaps,\n+                                        &_exception_handler_table,\n+                                        &_implicit_exception_table,\n+                                        compiler,\n+                                        _debug_recorder,\n+                                        _dependencies,\n+                                        id,\n+                                        _has_monitors,\n+                                        has_unsafe_access,\n+                                        _has_wide_vector,\n+                                        compiled_code,\n+                                        mirror,\n+                                        failed_speculations,\n+                                        speculations,\n+                                        speculations_len);\n@@ -565,5 +773,2 @@\n-void CodeInstaller::initialize_fields(JVMCIObject target, JVMCIObject compiled_code, JVMCI_TRAPS) {\n-  if (jvmci_env()->isa_HotSpotCompiledNmethod(compiled_code)) {\n-    JVMCIObject hotspotJavaMethod = jvmci_env()->get_HotSpotCompiledNmethod_method(compiled_code);\n-    Thread* thread = Thread::current();\n-    methodHandle method(thread, jvmci_env()->asMethod(hotspotJavaMethod));\n+void CodeInstaller::initialize_fields(HotSpotCompiledCodeStream* stream, u1 code_flags, methodHandle& method, JVMCI_TRAPS) {\n+  if (!method.is_null()) {\n@@ -573,1 +778,1 @@\n-    \/\/ Must be a HotSpotCompiledRuntimeStub.\n+    \/\/ Must be a HotSpotCompiledCode for a stub.\n@@ -577,8 +782,4 @@\n-  _sites_handle = jvmci_env()->get_HotSpotCompiledCode_sites(compiled_code);\n-\n-  _code_handle = jvmci_env()->get_HotSpotCompiledCode_targetCode(compiled_code);\n-  _code_size = jvmci_env()->get_HotSpotCompiledCode_targetCodeSize(compiled_code);\n-  _total_frame_size = jvmci_env()->get_HotSpotCompiledCode_totalFrameSize(compiled_code);\n-\n-  JVMCIObject deoptRescueSlot = jvmci_env()->get_HotSpotCompiledCode_deoptRescueSlot(compiled_code);\n-  if (deoptRescueSlot.is_null()) {\n+  _sites_count = stream->read_s4(\"sites:length\");\n+  _code_size = stream->read_s4(\"targetCodeSize\");\n+  _total_frame_size = stream->read_s4(\"totalFrameSize\");\n+  if (!is_set(code_flags, HCC_HAS_DEOPT_RESCUE_SLOT)) {\n@@ -587,2 +788,2 @@\n-    _orig_pc_offset = jvmci_env()->get_StackSlot_offset(deoptRescueSlot);\n-    if (jvmci_env()->get_StackSlot_addFrameSize(deoptRescueSlot)) {\n+    _orig_pc_offset = stream->read_s2(\"offset\");\n+    if (stream->read_bool(\"addRawFrameSize\")) {\n@@ -592,1 +793,1 @@\n-      JVMCI_ERROR(\"invalid deopt rescue slot: %d\", _orig_pc_offset);\n+      JVMCI_ERROR(\"invalid deopt rescue slot: %d%s\", _orig_pc_offset, stream->context());\n@@ -597,3 +798,5 @@\n-  _data_section_handle = jvmci_env()->get_HotSpotCompiledCode_dataSection(compiled_code);\n-  if ((_constants->alignment() % jvmci_env()->get_HotSpotCompiledCode_dataSectionAlignment(compiled_code)) != 0) {\n-    JVMCI_ERROR(\"invalid data section alignment: %d\", jvmci_env()->get_HotSpotCompiledCode_dataSectionAlignment(compiled_code));\n+  u4 data_section_size = stream->read_u4(\"dataSectionSize\");\n+  u1 data_section_alignment = stream->read_u1(\"dataSectionAlignment\");\n+  if ((_constants->alignment() % data_section_alignment) != 0) {\n+    JVMCI_ERROR(\"invalid data section alignment: %d [constants alignment: %d]%s\",\n+        data_section_alignment, _constants->alignment(), stream->context());\n@@ -601,8 +804,1 @@\n-  _constants_size = JVMCIENV->get_length(data_section());\n-\n-  _data_section_patches_handle = jvmci_env()->get_HotSpotCompiledCode_dataSectionPatches(compiled_code);\n-\n-#ifndef PRODUCT\n-  _comments_handle = jvmci_env()->get_HotSpotCompiledCode_comments(compiled_code);\n-#endif\n-\n+  _constants_size = data_section_size;\n@@ -610,1 +806,0 @@\n-\n@@ -612,3 +807,0 @@\n-\n-  JVMCIObject arch = jvmci_env()->get_TargetDescription_arch(target);\n-  _word_kind_handle = jvmci_env()->get_Architecture_wordKind(arch);\n@@ -617,30 +809,16 @@\n-int CodeInstaller::estimate_stubs_size(JVMCI_TRAPS) {\n-  \/\/ Estimate the number of static call stubs that might be emitted.\n-  int static_call_stubs = 0;\n-  int trampoline_stubs = 0;\n-  JVMCIObjectArray sites = this->sites();\n-  for (int i = 0; i < JVMCIENV->get_length(sites); i++) {\n-    JVMCIObject site = JVMCIENV->get_object_at(sites, i);\n-    if (!site.is_null()) {\n-      if (jvmci_env()->isa_site_Mark(site)) {\n-        JVMCIObject id_obj = jvmci_env()->get_site_Mark_id(site);\n-        if (id_obj.is_non_null()) {\n-          if (!jvmci_env()->is_boxing_object(T_INT, id_obj)) {\n-            JVMCI_ERROR_0(\"expected Integer id, got %s\", jvmci_env()->klass_name(id_obj));\n-          }\n-          jint id = jvmci_env()->get_boxed_value(T_INT, id_obj).i;\n-          switch (id) {\n-            case INVOKEINTERFACE:\n-            case INVOKEVIRTUAL:\n-              trampoline_stubs++;\n-              break;\n-            case INVOKESTATIC:\n-            case INVOKESPECIAL:\n-              static_call_stubs++;\n-              trampoline_stubs++;\n-              break;\n-            default:\n-              break;\n-          }\n-        }\n-      }\n+u1 CodeInstaller::as_read_oop_tag(HotSpotCompiledCodeStream* stream, u1 patch_object_tag, JVMCI_TRAPS) {\n+  switch (patch_object_tag) {\n+    case PATCH_OBJECT_ID:\n+    case PATCH_NARROW_OBJECT_ID: {\n+      return OBJECT_ID;\n+    }\n+    case PATCH_OBJECT_ID2:\n+    case PATCH_NARROW_OBJECT_ID2: {\n+      return OBJECT_ID2;\n+    }\n+    case PATCH_NARROW_JOBJECT:\n+    case PATCH_JOBJECT: {\n+      return JOBJECT;\n+    }\n+    default: {\n+      JVMCI_ERROR_0(\"unknown object patch tag: %d%s\", patch_object_tag, stream->context());\n@@ -649,0 +827,6 @@\n+}\n+\n+int CodeInstaller::estimate_stubs_size(HotSpotCompiledCodeStream* stream, JVMCI_TRAPS) {\n+  \/\/ Estimate the number of static call stubs that might be emitted.\n+  u2 static_call_stubs = stream->read_u2(\"numStaticCallStubs\");\n+  u2 trampoline_stubs = stream->read_u2(\"numTrampolineStubs\");\n@@ -655,4 +839,5 @@\n-JVMCI::CodeInstallResult CodeInstaller::initialize_buffer(CodeBuffer& buffer, bool check_size, JVMCI_TRAPS) {\n-  HandleMark hm(Thread::current());\n-  JVMCIObjectArray sites = this->sites();\n-  int locs_buffer_size = JVMCIENV->get_length(sites) * (relocInfo::length_limit + sizeof(relocInfo));\n+JVMCI::CodeInstallResult CodeInstaller::initialize_buffer(JVMCIObject compiled_code, CodeBuffer& buffer, HotSpotCompiledCodeStream* stream, u1 code_flags, JVMCI_TRAPS) {\n+  JavaThread* thread = stream->thread();\n+  HandleMark hm(thread);\n+  int locs_buffer_size = _sites_count * (relocInfo::length_limit + sizeof(relocInfo));\n+\n@@ -664,1 +849,1 @@\n-  int stubs_size = estimate_stubs_size(JVMCI_CHECK_OK);\n+  int stubs_size = estimate_stubs_size(stream, JVMCI_CHECK_OK);\n@@ -673,1 +858,1 @@\n-  if (check_size && total_size > JVMCINMethodSizeLimit) {\n+  if (total_size > JVMCINMethodSizeLimit) {\n@@ -691,1 +876,2 @@\n-  JVMCIENV->copy_bytes_to(data_section(), (jbyte*) _constants->start(), 0, _constants_size);\n+  JVMCIObject data_section = jvmci_env()->get_HotSpotCompiledCode_dataSection(compiled_code);\n+  JVMCIENV->copy_bytes_to(data_section, (jbyte*) _constants->start(), 0, _constants_size);\n@@ -697,1 +883,3 @@\n-  JVMCIENV->copy_bytes_to(code(), (jbyte*) _instructions->start(), 0, _code_size);\n+\n+  JVMCIPrimitiveArray code = jvmci_env()->get_HotSpotCompiledCode_targetCode(compiled_code);\n+  JVMCIENV->copy_bytes_to(code, (jbyte*) _instructions->start(), 0, _code_size);\n@@ -700,20 +888,13 @@\n-  for (int i = 0; i < JVMCIENV->get_length(data_section_patches()); i++) {\n-    \/\/ HandleMark hm(THREAD);\n-    JVMCIObject patch = JVMCIENV->get_object_at(data_section_patches(), i);\n-    if (patch.is_null()) {\n-      JVMCI_THROW_(NullPointerException, JVMCI::ok);\n-    }\n-    JVMCIObject reference = jvmci_env()->get_site_DataPatch_reference(patch);\n-    if (reference.is_null()) {\n-      JVMCI_THROW_(NullPointerException, JVMCI::ok);\n-    }\n-    if (!jvmci_env()->isa_site_ConstantReference(reference)) {\n-      JVMCI_ERROR_OK(\"invalid patch in data section: %s\", jvmci_env()->klass_name(reference));\n-    }\n-    JVMCIObject constant = jvmci_env()->get_site_ConstantReference_constant(reference);\n-    if (constant.is_null()) {\n-      JVMCI_THROW_(NullPointerException, JVMCI::ok);\n-    }\n-    address dest = _constants->start() + jvmci_env()->get_site_Site_pcOffset(patch);\n-    if (jvmci_env()->isa_HotSpotMetaspaceConstantImpl(constant)) {\n-      if (jvmci_env()->get_HotSpotMetaspaceConstantImpl_compressed(constant)) {\n+\n+  u2 length = stream->read_u2(\"dataSectionPatches:length\");\n+  for (int i = 0; i < length; i++) {\n+    address dest = _constants->start() + stream->read_u4(\"patch:pcOffset\");\n+    u1 tag = stream->read_u1(\"tag\");\n+\n+    switch (tag) {\n+      case PATCH_METHOD:\n+      case PATCH_KLASS: {\n+        *((void**) dest) = record_metadata_reference(_constants, dest, stream, tag, JVMCI_CHECK_OK);\n+        break;\n+      }\n+      case PATCH_NARROW_KLASS: {\n@@ -721,1 +902,1 @@\n-        *((narrowKlass*) dest) = record_narrow_metadata_reference(_constants, dest, constant, JVMCI_CHECK_OK);\n+        *((narrowKlass*) dest) = record_narrow_metadata_reference(_constants, dest, stream, tag, JVMCI_CHECK_OK);\n@@ -725,2 +906,1 @@\n-      } else {\n-        *((void**) dest) = record_metadata_reference(_constants, dest, constant, JVMCI_CHECK_OK);\n+        break;\n@@ -728,13 +908,14 @@\n-    } else if (jvmci_env()->isa_HotSpotObjectConstantImpl(constant)) {\n-      Handle obj = jvmci_env()->asConstant(constant, JVMCI_CHECK_OK);\n-      jobject value = JNIHandles::make_local(obj());\n-      int oop_index = _oop_recorder->find_index(value);\n-\n-      if (jvmci_env()->get_HotSpotObjectConstantImpl_compressed(constant)) {\n-#ifdef _LP64\n-        _constants->relocate(dest, oop_Relocation::spec(oop_index), relocInfo::narrow_oop_in_const);\n-#else\n-        JVMCI_ERROR_OK(\"unexpected compressed oop in 32-bit mode\");\n-#endif\n-      } else {\n-        _constants->relocate(dest, oop_Relocation::spec(oop_index));\n+      case PATCH_OBJECT_ID:\n+      case PATCH_OBJECT_ID2:\n+      case PATCH_NARROW_OBJECT_ID:\n+      case PATCH_NARROW_OBJECT_ID2:\n+      case PATCH_JOBJECT:\n+      case PATCH_NARROW_JOBJECT: {\n+        bool narrow = tag == PATCH_NARROW_OBJECT_ID || tag == PATCH_NARROW_OBJECT_ID2  || tag == PATCH_NARROW_JOBJECT;\n+        u1 read_tag = as_read_oop_tag(stream, tag, JVMCI_CHECK_OK);\n+        record_oop_patch(stream, dest, read_tag, narrow, JVMCI_CHECK_OK);\n+        break;\n+      }\n+      default: {\n+        JVMCI_ERROR_OK(\"invalid constant tag: %d%s\", tag, stream->context());\n+        break;\n@@ -742,2 +923,0 @@\n-    } else {\n-      JVMCI_ERROR_OK(\"invalid constant in data section: %s\", jvmci_env()->klass_name(constant));\n@@ -746,7 +925,0 @@\n-  jint last_pc_offset = -1;\n-  for (int i = 0; i < JVMCIENV->get_length(sites); i++) {\n-    \/\/ HandleMark hm(THREAD);\n-    JVMCIObject site = JVMCIENV->get_object_at(sites, i);\n-    if (site.is_null()) {\n-      JVMCI_THROW_(NullPointerException, JVMCI::ok);\n-    }\n@@ -754,29 +926,35 @@\n-    jint pc_offset = jvmci_env()->get_site_Site_pcOffset(site);\n-\n-    if (jvmci_env()->isa_site_Call(site)) {\n-      JVMCI_event_4(\"call at %i\", pc_offset);\n-      site_Call(buffer, pc_offset, site, JVMCI_CHECK_OK);\n-    } else if (jvmci_env()->isa_site_Infopoint(site)) {\n-      \/\/ three reasons for infopoints denote actual safepoints\n-      JVMCIObject reason = jvmci_env()->get_site_Infopoint_reason(site);\n-      if (JVMCIENV->equals(reason, jvmci_env()->get_site_InfopointReason_SAFEPOINT()) ||\n-          JVMCIENV->equals(reason, jvmci_env()->get_site_InfopointReason_CALL()) ||\n-          JVMCIENV->equals(reason, jvmci_env()->get_site_InfopointReason_IMPLICIT_EXCEPTION())) {\n-        JVMCI_event_4(\"safepoint at %i\", pc_offset);\n-        site_Safepoint(buffer, pc_offset, site, JVMCI_CHECK_OK);\n-        if (_orig_pc_offset < 0) {\n-          JVMCI_ERROR_OK(\"method contains safepoint, but has no deopt rescue slot\");\n-        }\n-        if (JVMCIENV->equals(reason, jvmci_env()->get_site_InfopointReason_IMPLICIT_EXCEPTION())) {\n-          if (jvmci_env()->isa_site_ImplicitExceptionDispatch(site)) {\n-            jint dispatch_offset = jvmci_env()->get_site_ImplicitExceptionDispatch_dispatchOffset(site);\n-            JVMCI_event_4(\"implicit exception at %i, dispatch to %i\", pc_offset, dispatch_offset);\n-            _implicit_exception_table.append(pc_offset, dispatch_offset);\n-          } else {\n-            JVMCI_event_4(\"implicit exception at %i\", pc_offset);\n-            _implicit_exception_table.add_deoptimize(pc_offset);\n-          }\n-        }\n-      } else {\n-        JVMCI_event_4(\"infopoint at %i\", pc_offset);\n-        site_Infopoint(buffer, pc_offset, site, JVMCI_CHECK_OK);\n+  jint last_pc_offset = -1;\n+  for (int i = 0; i < _sites_count; i++) {\n+    u4 pc_offset = stream->read_s4(\"site:pcOffset\");\n+    u1 tag = stream->read_u1(\"tag\");\n+    switch (tag) {\n+      case SITE_FOREIGN_CALL:\n+      case SITE_FOREIGN_CALL_NO_DEBUG_INFO:\n+      case SITE_CALL: {\n+        site_Call(buffer, tag, pc_offset, stream, JVMCI_CHECK_OK);\n+        break;\n+      }\n+      case SITE_SAFEPOINT:\n+      case SITE_IMPLICIT_EXCEPTION:\n+      case SITE_IMPLICIT_EXCEPTION_DISPATCH: {\n+        site_Safepoint(buffer, pc_offset, stream, tag, JVMCI_CHECK_OK);\n+        break;\n+      }\n+      case SITE_INFOPOINT: {\n+        site_Infopoint(buffer, pc_offset, stream, JVMCI_CHECK_OK);\n+        break;\n+      }\n+      case SITE_MARK: {\n+        site_Mark(buffer, pc_offset, stream, JVMCI_CHECK_OK);\n+        break;\n+      }\n+      case SITE_DATA_PATCH: {\n+        site_DataPatch(buffer, pc_offset, stream, JVMCI_CHECK_OK);\n+        break;\n+      }\n+      case SITE_EXCEPTION_HANDLER: {\n+        site_ExceptionHandler(pc_offset, stream);\n+        break;\n+      }\n+      default: {\n+        JVMCI_ERROR_OK(\"unexpected site tag at \" INTPTR_FORMAT \": %d\", p2i(stream->pos() - 1), tag);\n@@ -784,11 +962,0 @@\n-    } else if (jvmci_env()->isa_site_DataPatch(site)) {\n-      JVMCI_event_4(\"datapatch at %i\", pc_offset);\n-      site_DataPatch(buffer, pc_offset, site, JVMCI_CHECK_OK);\n-    } else if (jvmci_env()->isa_site_Mark(site)) {\n-      JVMCI_event_4(\"mark at %i\", pc_offset);\n-      site_Mark(buffer, pc_offset, site, JVMCI_CHECK_OK);\n-    } else if (jvmci_env()->isa_site_ExceptionHandler(site)) {\n-      JVMCI_event_4(\"exceptionhandler at %i\", pc_offset);\n-      site_ExceptionHandler(pc_offset, site);\n-    } else {\n-      JVMCI_ERROR_OK(\"unexpected site subclass: %s\", jvmci_env()->klass_name(site));\n@@ -796,0 +963,1 @@\n+\n@@ -798,3 +966,2 @@\n-    JavaThread* thread = JavaThread::current();\n-    if (SafepointMechanism::should_process(thread)) {\n-      \/\/ this is a hacky way to force a safepoint check but nothing else was jumping out at me.\n+    if ((i % 32 == 0) && SafepointMechanism::should_process(thread)) {\n+      \/\/ Force a safepoint to mitigate pause time installing large code\n@@ -805,0 +972,5 @@\n+  if (is_set(code_flags, HCC_HAS_COMMENTS)) {\n+    u2 length = stream->read_u2(\"comments:length\");\n+    for (int i = 0; i < length; i++) {\n+      u4 pc_offset = stream->read_u4(\"comment:pcOffset\");\n+      const char* text = stream->read_utf8(\"comment:text\", JVMCI_CHECK_OK);\n@@ -806,7 +978,2 @@\n-  if (comments().is_non_null()) {\n-    for (int i = 0; i < JVMCIENV->get_length(comments()); i++) {\n-      JVMCIObject comment = JVMCIENV->get_object_at(comments(), i);\n-      assert(jvmci_env()->isa_HotSpotCompiledCode_Comment(comment), \"cce\");\n-      jint offset = jvmci_env()->get_HotSpotCompiledCode_Comment_pcOffset(comment);\n-      const char* text = jvmci_env()->as_utf8_string(jvmci_env()->get_HotSpotCompiledCode_Comment_text(comment));\n-      buffer.block_comment(offset, text);\n+      buffer.block_comment(pc_offset, text);\n+#endif\n@@ -815,1 +982,0 @@\n-#endif\n@@ -817,1 +983,1 @@\n-    JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n+    JavaThread* THREAD = thread; \/\/ For exception macros.\n@@ -823,39 +989,13 @@\n-void CodeInstaller::assumption_NoFinalizableSubclass(JVMCIObject assumption) {\n-  JVMCIObject receiverType_handle = jvmci_env()->get_Assumptions_NoFinalizableSubclass_receiverType(assumption);\n-  Klass* receiverType = jvmci_env()->asKlass(receiverType_handle);\n-  _dependencies->assert_has_no_finalizable_subclasses(receiverType);\n-}\n-\n-void CodeInstaller::assumption_ConcreteSubtype(JVMCIObject assumption) {\n-  JVMCIObject context_handle = jvmci_env()->get_Assumptions_ConcreteSubtype_context(assumption);\n-  JVMCIObject subtype_handle = jvmci_env()->get_Assumptions_ConcreteSubtype_subtype(assumption);\n-  Klass* context = jvmci_env()->asKlass(context_handle);\n-  Klass* subtype = jvmci_env()->asKlass(subtype_handle);\n-\n-  assert(context->is_abstract(), \"\");\n-  _dependencies->assert_abstract_with_unique_concrete_subtype(context, subtype);\n-}\n-\n-void CodeInstaller::assumption_LeafType(JVMCIObject assumption) {\n-  JVMCIObject context_handle = jvmci_env()->get_Assumptions_LeafType_context(assumption);\n-  Klass* context = jvmci_env()->asKlass(context_handle);\n-\n-  _dependencies->assert_leaf_type(context);\n-}\n-\n-void CodeInstaller::assumption_ConcreteMethod(JVMCIObject assumption) {\n-  JVMCIObject impl_handle = jvmci_env()->get_Assumptions_ConcreteMethod_impl(assumption);\n-  JVMCIObject context_handle = jvmci_env()->get_Assumptions_ConcreteMethod_context(assumption);\n-\n-  Method* impl = jvmci_env()->asMethod(impl_handle);\n-  Klass* context = jvmci_env()->asKlass(context_handle);\n-\n-  _dependencies->assert_unique_concrete_method(context, impl);\n-}\n-\n-void CodeInstaller::assumption_CallSiteTargetValue(JVMCIObject assumption, JVMCI_TRAPS) {\n-  JVMCIObject callSiteConstant = jvmci_env()->get_Assumptions_CallSiteTargetValue_callSite(assumption);\n-  Handle callSite = jvmci_env()->asConstant(callSiteConstant, JVMCI_CHECK);\n-  JVMCIObject methodConstant = jvmci_env()->get_Assumptions_CallSiteTargetValue_methodHandle(assumption);\n-  Handle methodHandle = jvmci_env()->asConstant(methodConstant, JVMCI_CHECK);\n-  _dependencies->assert_call_site_target_value(callSite(), methodHandle());\n+void CodeInstaller::record_oop_patch(HotSpotCompiledCodeStream* stream, address dest, u1 read_tag, bool narrow, JVMCI_TRAPS) {\n+  Handle obj = read_oop(stream, read_tag, JVMCI_CHECK);\n+  jobject value = JNIHandles::make_local(obj());\n+  int oop_index = _oop_recorder->find_index(value);\n+  if (narrow) {\n+#ifdef _LP64\n+    _constants->relocate(dest, oop_Relocation::spec(oop_index), relocInfo::narrow_oop_in_const);\n+#else\n+    JVMCI_ERROR(\"unexpected compressed oop in 32-bit mode\");\n+#endif\n+  } else {\n+    _constants->relocate(dest, oop_Relocation::spec(oop_index));\n+  }\n@@ -864,2 +1004,2 @@\n-void CodeInstaller::site_ExceptionHandler(jint pc_offset, JVMCIObject exc) {\n-  jint handler_offset = jvmci_env()->get_site_ExceptionHandler_handlerPos(exc);\n+void CodeInstaller::site_ExceptionHandler(jint pc_offset, HotSpotCompiledCodeStream* stream) {\n+  u4 handler_offset = stream->read_u4(\"site:handlerPos\");\n@@ -874,20 +1014,4 @@\n-\/\/ If deoptimization happens, the interpreter should reexecute these bytecodes.\n-\/\/ This function mainly helps the compilers to set up the reexecute bit.\n-static bool bytecode_should_reexecute(Bytecodes::Code code) {\n-  switch (code) {\n-    case Bytecodes::_invokedynamic:\n-    case Bytecodes::_invokevirtual:\n-    case Bytecodes::_invokeinterface:\n-    case Bytecodes::_invokespecial:\n-    case Bytecodes::_invokestatic:\n-      return false;\n-    default:\n-      return true;\n-    }\n-  return true;\n-}\n-\n-GrowableArray<ScopeValue*>* CodeInstaller::record_virtual_objects(JVMCIObject debug_info, JVMCI_TRAPS) {\n-  JVMCIObjectArray virtualObjects = jvmci_env()->get_DebugInfo_virtualObjectMapping(debug_info);\n-  if (virtualObjects.is_null()) {\n-    return NULL;\n+void CodeInstaller::read_virtual_objects(HotSpotCompiledCodeStream* stream, JVMCI_TRAPS) {\n+  u2 length = stream->read_u2(\"virtualObjects:length\");\n+  if (length == 0) {\n+    return;\n@@ -895,1 +1019,2 @@\n-  GrowableArray<ScopeValue*>* objects = new GrowableArray<ScopeValue*>(JVMCIENV->get_length(virtualObjects), JVMCIENV->get_length(virtualObjects), NULL);\n+  GrowableArray<ScopeValue*> *objects = new GrowableArray<ScopeValue*>(length, length, NULL);\n+  stream->set_virtual_objects(objects);\n@@ -897,6 +1022,4 @@\n-  for (int i = 0; i < JVMCIENV->get_length(virtualObjects); i++) {\n-    \/\/ HandleMark hm(THREAD);\n-    JVMCIObject value = JVMCIENV->get_object_at(virtualObjects, i);\n-    int id = jvmci_env()->get_VirtualObject_id(value);\n-    JVMCIObject type = jvmci_env()->get_VirtualObject_type(value);\n-    bool is_auto_box = jvmci_env()->get_VirtualObject_isAutoBox(value);\n+  JavaThread* thread = stream->thread();\n+  for (int id = 0; id < length; id++) {\n+    Klass* klass = stream->read_klass(\"type\");\n+    bool is_auto_box = stream->read_bool(\"isAutoBox\");\n@@ -906,1 +1029,0 @@\n-    Klass* klass = jvmci_env()->asKlass(type);\n@@ -910,6 +1032,0 @@\n-    if (id < 0 || id >= objects->length()) {\n-      JVMCI_ERROR_NULL(\"virtual object id %d out of bounds\", id);\n-    }\n-    if (objects->at(id) != NULL) {\n-      JVMCI_ERROR_NULL(\"duplicate virtual object id %d\", id);\n-    }\n@@ -920,5 +1036,2 @@\n-  for (int i = 0; i < JVMCIENV->get_length(virtualObjects); i++) {\n-    \/\/ HandleMark hm(THREAD);\n-    JVMCIObject value = JVMCIENV->get_object_at(virtualObjects, i);\n-    int id = jvmci_env()->get_VirtualObject_id(value);\n-    record_object_value(objects->at(id)->as_ObjectValue(), value, objects, JVMCI_CHECK_NULL);\n+  for (int id = 0; id < length; id++) {\n+    record_object_value(objects->at(id)->as_ObjectValue(), stream, JVMCI_CHECK);\n@@ -928,17 +1041,1 @@\n-  return objects;\n-}\n-\n-void CodeInstaller::record_scope(jint pc_offset, JVMCIObject debug_info, ScopeMode scope_mode, bool is_mh_invoke, bool return_oop, JVMCI_TRAPS) {\n-  JVMCIObject position = jvmci_env()->get_DebugInfo_bytecodePosition(debug_info);\n-  if (position.is_null()) {\n-    \/\/ Stubs do not record scope info, just oop maps\n-    return;\n-  }\n-\n-  GrowableArray<ScopeValue*>* objectMapping;\n-  if (scope_mode == CodeInstaller::FullFrame) {\n-    objectMapping = record_virtual_objects(debug_info, JVMCI_CHECK);\n-  } else {\n-    objectMapping = NULL;\n-  }\n-  record_scope(pc_offset, position, scope_mode, objectMapping, is_mh_invoke, return_oop, JVMCI_CHECK);\n+  stream->set_virtual_objects(objects);\n@@ -949,12 +1046,7 @@\n-    if (bci == jvmci_env()->get_BytecodeFrame_BEFORE_BCI()) {\n-      return BeforeBci;\n-    } else if (bci == jvmci_env()->get_BytecodeFrame_AFTER_BCI()) {\n-      return AfterBci;\n-    } else if (bci == jvmci_env()->get_BytecodeFrame_UNWIND_BCI()) {\n-      return UnwindBci;\n-    } else if (bci == jvmci_env()->get_BytecodeFrame_AFTER_EXCEPTION_BCI()) {\n-      return AfterExceptionBci;\n-    } else if (bci == jvmci_env()->get_BytecodeFrame_UNKNOWN_BCI()) {\n-      return UnknownBci;\n-    } else if (bci == jvmci_env()->get_BytecodeFrame_INVALID_FRAMESTATE_BCI()) {\n-      return InvalidFrameStateBci;\n+    switch (bci) {\n+      case BEFORE_BCI: return BeforeBci;\n+      case AFTER_BCI: return AfterBci;\n+      case UNWIND_BCI: return UnwindBci;\n+      case AFTER_EXCEPTION_BCI: return AfterExceptionBci;\n+      case UNKNOWN_BCI: return UnknownBci;\n+      case INVALID_FRAMESTATE_BCI: return InvalidFrameStateBci;\n@@ -967,19 +1059,3 @@\n-void CodeInstaller::record_scope(jint pc_offset, JVMCIObject position, ScopeMode scope_mode, GrowableArray<ScopeValue*>* objects, bool is_mh_invoke, bool return_oop, JVMCI_TRAPS) {\n-  JVMCIObject frame;\n-  if (scope_mode == CodeInstaller::FullFrame) {\n-    if (!jvmci_env()->isa_BytecodeFrame(position)) {\n-      JVMCI_ERROR(\"Full frame expected for debug info at %i\", pc_offset);\n-    }\n-    frame = position;\n-  }\n-  JVMCIObject caller_frame = jvmci_env()->get_BytecodePosition_caller(position);\n-  if (caller_frame.is_non_null()) {\n-    record_scope(pc_offset, caller_frame, scope_mode, objects, is_mh_invoke, return_oop, JVMCI_CHECK);\n-  }\n-\n-  JVMCIObject hotspot_method = jvmci_env()->get_BytecodePosition_method(position);\n-  Thread* thread = Thread::current();\n-  methodHandle method(thread, jvmci_env()->asMethod(hotspot_method));\n-  jint bci = map_jvmci_bci(jvmci_env()->get_BytecodePosition_bci(position));\n-  if (bci == jvmci_env()->get_BytecodeFrame_BEFORE_BCI()) {\n-    bci = SynchronizationEntryBCI;\n+void CodeInstaller::record_scope(jint pc_offset, HotSpotCompiledCodeStream* stream, u1 debug_info_flags, bool full_info, bool is_mh_invoke, bool return_oop, JVMCI_TRAPS) {\n+  if (full_info) {\n+    read_virtual_objects(stream, JVMCI_CHECK);\n@@ -987,0 +1063,9 @@\n+  if (is_set(debug_info_flags, DI_HAS_FRAMES)) {\n+    u2 depth = stream->read_u2(\"depth\");\n+    for (int i = 0; i < depth; i++) {\n+      Thread* thread = Thread::current();\n+      methodHandle method(thread, stream->read_method(\"method\"));\n+      jint bci = map_jvmci_bci(stream->read_s4(\"bci\"));\n+      if (bci == BEFORE_BCI) {\n+        bci = SynchronizationEntryBCI;\n+      }\n@@ -988,1 +1073,1 @@\n-  JVMCI_event_2(\"Recording scope pc_offset=%d bci=%d method=%s\", pc_offset, bci, method->name_and_sig_as_C_string());\n+      JVMCI_event_2(\"Recording scope pc_offset=%d bci=%d method=%s\", pc_offset, bci, method->name_and_sig_as_C_string());\n@@ -990,12 +1075,2 @@\n-  bool reexecute = false;\n-  if (frame.is_non_null()) {\n-    if (bci < 0){\n-       reexecute = false;\n-    } else {\n-      Bytecodes::Code code = Bytecodes::java_code_at(method(), method->bcp_from(bci));\n-      reexecute = bytecode_should_reexecute(code);\n-      if (frame.is_non_null()) {\n-        reexecute = (jvmci_env()->get_BytecodeFrame_duringCall(frame) == JNI_FALSE);\n-      }\n-    }\n-  }\n+      bool reexecute = false;\n+      bool rethrow_exception = false;\n@@ -1003,14 +1078,3 @@\n-  DebugToken* locals_token = NULL;\n-  DebugToken* expressions_token = NULL;\n-  DebugToken* monitors_token = NULL;\n-  bool throw_exception = false;\n-\n-  if (frame.is_non_null()) {\n-    jint local_count = jvmci_env()->get_BytecodeFrame_numLocals(frame);\n-    jint expression_count = jvmci_env()->get_BytecodeFrame_numStack(frame);\n-    jint monitor_count = jvmci_env()->get_BytecodeFrame_numLocks(frame);\n-    if (monitor_count > 0 && !_has_monitors) {\n-      _has_monitors = true;\n-    }\n-    JVMCIObjectArray values = jvmci_env()->get_BytecodeFrame_values(frame);\n-    JVMCIObjectArray slotKinds = jvmci_env()->get_BytecodeFrame_slotKinds(frame);\n+      DebugToken* locals_token = NULL;\n+      DebugToken* stack_token = NULL;\n+      DebugToken* monitors_token = NULL;\n@@ -1018,9 +1082,3 @@\n-    if (values.is_null() || slotKinds.is_null()) {\n-      JVMCI_THROW(NullPointerException);\n-    }\n-    if (local_count + expression_count + monitor_count != JVMCIENV->get_length(values)) {\n-      JVMCI_ERROR(\"unexpected values length %d in scope (%d locals, %d expressions, %d monitors)\", JVMCIENV->get_length(values), local_count, expression_count, monitor_count);\n-    }\n-    if (local_count + expression_count != JVMCIENV->get_length(slotKinds)) {\n-      JVMCI_ERROR(\"unexpected slotKinds length %d in scope (%d locals, %d expressions)\", JVMCIENV->get_length(slotKinds), local_count, expression_count);\n-    }\n+      if (full_info) {\n+        u1 frame_flags = stream->read_u1(\"flags\");\n+        rethrow_exception = is_set(frame_flags, DIF_RETHROW_EXCEPTION);\n@@ -1028,16 +1086,2 @@\n-    GrowableArray<ScopeValue*>* locals = local_count > 0 ? new GrowableArray<ScopeValue*> (local_count) : NULL;\n-    GrowableArray<ScopeValue*>* expressions = expression_count > 0 ? new GrowableArray<ScopeValue*> (expression_count) : NULL;\n-    GrowableArray<MonitorValue*>* monitors = monitor_count > 0 ? new GrowableArray<MonitorValue*> (monitor_count) : NULL;\n-\n-    JVMCI_event_2(\"Scope at bci %d with %d values\", bci, JVMCIENV->get_length(values));\n-    JVMCI_event_2(\"%d locals %d expressions, %d monitors\", local_count, expression_count, monitor_count);\n-\n-    for (jint i = 0; i < JVMCIENV->get_length(values); i++) {\n-      \/\/ HandleMark hm(THREAD);\n-      ScopeValue* second = NULL;\n-      JVMCIObject value = JVMCIENV->get_object_at(values, i);\n-      if (i < local_count) {\n-        BasicType type = jvmci_env()->kindToBasicType(JVMCIENV->get_object_at(slotKinds, i), JVMCI_CHECK);\n-        ScopeValue* first = get_scope_value(value, type, objects, second, JVMCI_CHECK);\n-        if (second != NULL) {\n-          locals->append(second);\n+        if (bci >= 0) {\n+          reexecute = !is_set(frame_flags, DIF_DURING_CALL);\n@@ -1045,19 +1089,0 @@\n-        locals->append(first);\n-      } else if (i < local_count + expression_count) {\n-        BasicType type = jvmci_env()->kindToBasicType(JVMCIENV->get_object_at(slotKinds, i), JVMCI_CHECK);\n-        ScopeValue* first = get_scope_value(value, type, objects, second, JVMCI_CHECK);\n-        if (second != NULL) {\n-          expressions->append(second);\n-        }\n-        expressions->append(first);\n-      } else {\n-        MonitorValue *monitor = get_monitor_value(value, objects, JVMCI_CHECK);\n-        monitors->append(monitor);\n-      }\n-      if (second != NULL) {\n-        i++;\n-        if (i >= JVMCIENV->get_length(values) || !JVMCIENV->equals(JVMCIENV->get_object_at(values, i), jvmci_env()->get_Value_ILLEGAL())) {\n-          JVMCI_ERROR(\"double-slot value not followed by Value.ILLEGAL\");\n-        }\n-      }\n-    }\n@@ -1065,3 +1090,3 @@\n-    locals_token = _debug_recorder->create_scope_values(locals);\n-    expressions_token = _debug_recorder->create_scope_values(expressions);\n-    monitors_token = _debug_recorder->create_monitor_values(monitors);\n+        GrowableArray<ScopeValue*>* locals = read_local_or_stack_values(stream, frame_flags, true, JVMCI_CHECK);\n+        GrowableArray<ScopeValue*>* stack = read_local_or_stack_values(stream, frame_flags, false, JVMCI_CHECK);\n+        GrowableArray<MonitorValue*>* monitors = read_monitor_values(stream, frame_flags, JVMCI_CHECK);\n@@ -1069,10 +1094,4 @@\n-    throw_exception = jvmci_env()->get_BytecodeFrame_rethrowException(frame) == JNI_TRUE;\n-  }\n-\n-  \/\/ has_ea_local_in_scope and arg_escape should be added to JVMCI\n-  const bool has_ea_local_in_scope = false;\n-  const bool arg_escape            = false;\n-  _debug_recorder->describe_scope(pc_offset, method, NULL, bci, reexecute, throw_exception, is_mh_invoke, return_oop,\n-                                  has_ea_local_in_scope, arg_escape,\n-                                  locals_token, expressions_token, monitors_token);\n-}\n+        locals_token = _debug_recorder->create_scope_values(locals);\n+        stack_token = _debug_recorder->create_scope_values(stack);\n+        monitors_token = _debug_recorder->create_monitor_values(monitors);\n+      }\n@@ -1080,4 +1099,7 @@\n-void CodeInstaller::site_Safepoint(CodeBuffer& buffer, jint pc_offset, JVMCIObject site, JVMCI_TRAPS) {\n-  JVMCIObject debug_info = jvmci_env()->get_site_Infopoint_debugInfo(site);\n-  if (debug_info.is_null()) {\n-    JVMCI_ERROR(\"debug info expected at safepoint at %i\", pc_offset);\n+      \/\/ has_ea_local_in_scope and arg_escape should be added to JVMCI\n+      const bool has_ea_local_in_scope = false;\n+      const bool arg_escape            = false;\n+      _debug_recorder->describe_scope(pc_offset, method, NULL, bci, reexecute, rethrow_exception, is_mh_invoke, return_oop,\n+                                      has_ea_local_in_scope, arg_escape,\n+                                      locals_token, stack_token, monitors_token);\n+    }\n@@ -1085,0 +1107,5 @@\n+  if (full_info) {\n+    \/\/ Clear the virtual objects as they are specific to one DebugInfo\n+    stream->set_virtual_objects(nullptr);\n+  }\n+}\n@@ -1086,3 +1113,3 @@\n-  \/\/ address instruction = _instructions->start() + pc_offset;\n-  \/\/ jint next_pc_offset = Assembler::locate_next_instruction(instruction) - _instructions->start();\n-  OopMap *map = create_oop_map(debug_info, JVMCI_CHECK);\n+void CodeInstaller::site_Safepoint(CodeBuffer& buffer, jint pc_offset, HotSpotCompiledCodeStream* stream, u1 tag, JVMCI_TRAPS) {\n+  u1 flags = stream->read_u1(\"debugInfo:flags\");\n+  OopMap *map = create_oop_map(stream, flags, JVMCI_CHECK);\n@@ -1090,1 +1117,1 @@\n-  record_scope(pc_offset, debug_info, CodeInstaller::FullFrame, JVMCI_CHECK);\n+  record_scope(pc_offset, stream, flags, true, JVMCI_CHECK);\n@@ -1092,6 +1119,2 @@\n-}\n-\n-void CodeInstaller::site_Infopoint(CodeBuffer& buffer, jint pc_offset, JVMCIObject site, JVMCI_TRAPS) {\n-  JVMCIObject debug_info = jvmci_env()->get_site_Infopoint_debugInfo(site);\n-  if (debug_info.is_null()) {\n-    JVMCI_ERROR(\"debug info expected at infopoint at %i\", pc_offset);\n+  if (_orig_pc_offset < 0) {\n+    JVMCI_ERROR(\"method contains safepoint, but has no deopt rescue slot\");\n@@ -1099,0 +1122,7 @@\n+  if (tag == SITE_IMPLICIT_EXCEPTION_DISPATCH) {\n+    jint dispatch_offset = stream->read_s4(\"dispatchOffset\");\n+    _implicit_exception_table.append(pc_offset, dispatch_offset);\n+  } else if (tag == SITE_IMPLICIT_EXCEPTION) {\n+    _implicit_exception_table.add_deoptimize(pc_offset);\n+  }\n+}\n@@ -1100,4 +1130,2 @@\n-  \/\/ We'd like to check that pc_offset is greater than the\n-  \/\/ last pc recorded with _debug_recorder (raising an exception if not)\n-  \/\/ but DebugInformationRecorder doesn't have sufficient public API.\n-\n+void CodeInstaller::site_Infopoint(CodeBuffer& buffer, jint pc_offset, HotSpotCompiledCodeStream* stream, JVMCI_TRAPS) {\n+  u1 flags = stream->read_u1(\"debugInfo:flags\");\n@@ -1105,1 +1133,1 @@\n-  record_scope(pc_offset, debug_info, CodeInstaller::BytecodePosition, JVMCI_CHECK);\n+  record_scope(pc_offset, stream, flags, false, JVMCI_CHECK);\n@@ -1109,9 +1137,12 @@\n-void CodeInstaller::site_Call(CodeBuffer& buffer, jint pc_offset, JVMCIObject site, JVMCI_TRAPS) {\n-  JVMCIObject target = jvmci_env()->get_site_Call_target(site);\n-  JVMCIObject hotspot_method; \/\/ JavaMethod\n-  JVMCIObject foreign_call;\n-\n-  if (jvmci_env()->isa_HotSpotForeignCallTarget(target)) {\n-    foreign_call = target;\n-  } else {\n-    hotspot_method = target;\n+void CodeInstaller::site_Call(CodeBuffer& buffer, u1 tag, jint pc_offset, HotSpotCompiledCodeStream* stream, JVMCI_TRAPS) {\n+  JavaThread* thread = stream->thread();\n+  jlong target = stream->read_u8(\"target\");\n+  methodHandle method;\n+  bool direct_call = false;\n+  if (tag == SITE_CALL) {\n+    method = methodHandle(thread, (Method*) target);\n+    assert(Method::is_valid_method(method()), \"invalid method\");\n+    direct_call = stream->read_bool(\"direct\");\n+    if (method.is_null()) {\n+      JVMCI_THROW(NullPointerException);\n+    }\n@@ -1120,4 +1151,0 @@\n-  JVMCIObject debug_info = jvmci_env()->get_site_Infopoint_debugInfo(site);\n-\n-  assert(hotspot_method.is_non_null() ^ foreign_call.is_non_null(), \"Call site needs exactly one type\");\n-\n@@ -1125,1 +1152,1 @@\n-  jint next_pc_offset = CodeInstaller::pd_next_offset(inst, pc_offset, hotspot_method, JVMCI_CHECK);\n+  jint next_pc_offset = CodeInstaller::pd_next_offset(inst, pc_offset, JVMCI_CHECK);\n@@ -1127,2 +1154,3 @@\n-  if (debug_info.is_non_null()) {\n-    OopMap *map = create_oop_map(debug_info, JVMCI_CHECK);\n+  if (tag != SITE_FOREIGN_CALL_NO_DEBUG_INFO) {\n+    u1 flags = stream->read_u1(\"debugInfo:flags\");\n+    OopMap *map = create_oop_map(stream, flags, JVMCI_CHECK);\n@@ -1131,2 +1159,1 @@\n-    if (hotspot_method.is_non_null()) {\n-      Method *method = jvmci_env()->asMethod(hotspot_method);\n+    if (!method.is_null()) {\n@@ -1135,1 +1162,1 @@\n-      if (jvmci_env()->get_site_Call_direct(site)) {\n+      if (direct_call) {\n@@ -1140,1 +1167,1 @@\n-      record_scope(next_pc_offset, debug_info, CodeInstaller::FullFrame, is_mh_invoke, return_oop, JVMCI_CHECK);\n+      record_scope(next_pc_offset, stream, flags, true, is_mh_invoke, return_oop, JVMCI_CHECK);\n@@ -1142,1 +1169,1 @@\n-      record_scope(next_pc_offset, debug_info, CodeInstaller::FullFrame, JVMCI_CHECK);\n+      record_scope(next_pc_offset, stream, flags, true, JVMCI_CHECK);\n@@ -1146,2 +1173,2 @@\n-  if (foreign_call.is_non_null()) {\n-    jlong foreign_call_destination = jvmci_env()->get_HotSpotForeignCallTarget_address(foreign_call);\n+  if (tag != SITE_CALL) {\n+    jlong foreign_call_destination = target;\n@@ -1149,7 +1176,2 @@\n-  } else { \/\/ method != NULL\n-    if (debug_info.is_null()) {\n-      JVMCI_ERROR(\"debug info expected at call at %i\", pc_offset);\n-    }\n-\n-    JVMCI_event_3(\"method call\");\n-    CodeInstaller::pd_relocate_JavaMethod(buffer, hotspot_method, pc_offset, JVMCI_CHECK);\n+  } else {\n+    CodeInstaller::pd_relocate_JavaMethod(buffer, method, pc_offset, JVMCI_CHECK);\n@@ -1164,1 +1186,1 @@\n-  if (debug_info.is_non_null()) {\n+  if (tag != SITE_FOREIGN_CALL_NO_DEBUG_INFO) {\n@@ -1169,13 +1191,27 @@\n-void CodeInstaller::site_DataPatch(CodeBuffer& buffer, jint pc_offset, JVMCIObject site, JVMCI_TRAPS) {\n-  JVMCIObject reference = jvmci_env()->get_site_DataPatch_reference(site);\n-  if (reference.is_null()) {\n-    JVMCI_THROW(NullPointerException);\n-  } else if (jvmci_env()->isa_site_ConstantReference(reference)) {\n-    JVMCIObject constant = jvmci_env()->get_site_ConstantReference_constant(reference);\n-    if (constant.is_null()) {\n-      JVMCI_THROW(NullPointerException);\n-    } else if (jvmci_env()->isa_DirectHotSpotObjectConstantImpl(constant)) {\n-      if (!JVMCIENV->is_hotspot()) {\n-        JVMCIObject string = JVMCIENV->call_HotSpotJVMCIRuntime_callToString(constant, JVMCI_CHECK);\n-        const char* to_string = JVMCIENV->as_utf8_string(string);\n-        JVMCI_THROW_MSG(IllegalArgumentException, err_msg(\"Direct object constant reached the backend: %s\", to_string));\n+void CodeInstaller::site_DataPatch(CodeBuffer& buffer, jint pc_offset, HotSpotCompiledCodeStream* stream, JVMCI_TRAPS) {\n+  u1 tag = stream->read_u1(\"tag\");\n+  switch (tag) {\n+    case PATCH_OBJECT_ID:\n+    case PATCH_OBJECT_ID2:\n+    case PATCH_NARROW_OBJECT_ID:\n+    case PATCH_NARROW_OBJECT_ID2:\n+    case PATCH_JOBJECT:\n+    case PATCH_NARROW_JOBJECT: {\n+      bool narrow = tag == PATCH_NARROW_OBJECT_ID || tag == PATCH_NARROW_OBJECT_ID2  || tag == PATCH_NARROW_JOBJECT;\n+      u1 read_tag = as_read_oop_tag(stream, tag, JVMCI_CHECK);\n+      Handle obj = read_oop(stream, read_tag, JVMCI_CHECK);\n+      pd_patch_OopConstant(pc_offset, obj, narrow, JVMCI_CHECK);\n+      break;\n+    }\n+    case PATCH_METHOD:\n+    case PATCH_KLASS:\n+    case PATCH_NARROW_KLASS: {\n+      pd_patch_MetaspaceConstant(pc_offset, stream, tag, JVMCI_CHECK);\n+      break;\n+    }\n+    case PATCH_DATA_SECTION_REFERENCE: {\n+      int data_offset = stream->read_u4(\"data:offset\");\n+      if (0 <= data_offset && data_offset < _constants_size) {\n+        pd_patch_DataSectionReference(pc_offset, data_offset, JVMCI_CHECK);\n+      } else {\n+        JVMCI_ERROR(\"data offset 0x%x points outside data section (size 0x%x)%s\", data_offset, _constants_size, stream->context());\n@@ -1183,7 +1219,1 @@\n-      pd_patch_OopConstant(pc_offset, constant, JVMCI_CHECK);\n-    } else if (jvmci_env()->isa_IndirectHotSpotObjectConstantImpl(constant)) {\n-      pd_patch_OopConstant(pc_offset, constant, JVMCI_CHECK);\n-    } else if (jvmci_env()->isa_HotSpotMetaspaceConstantImpl(constant)) {\n-      pd_patch_MetaspaceConstant(pc_offset, constant, JVMCI_CHECK);\n-    } else {\n-      JVMCI_ERROR(\"unknown constant type in data patch: %s\", jvmci_env()->klass_name(constant));\n+      break;\n@@ -1191,6 +1221,2 @@\n-  } else if (jvmci_env()->isa_site_DataSectionReference(reference)) {\n-    int data_offset = jvmci_env()->get_site_DataSectionReference_offset(reference);\n-    if (0 <= data_offset && data_offset < _constants_size) {\n-      pd_patch_DataSectionReference(pc_offset, data_offset, JVMCI_CHECK);\n-    } else {\n-      JVMCI_ERROR(\"data offset 0x%X points outside data section (size 0x%X)\", data_offset, _constants_size);\n+    default: {\n+      JVMCI_ERROR(\"unknown data patch tag: %d%s\", tag, stream->context());\n@@ -1198,2 +1224,0 @@\n-  } else {\n-    JVMCI_ERROR(\"unknown data patch type: %s\", jvmci_env()->klass_name(reference));\n@@ -1203,65 +1227,57 @@\n-void CodeInstaller::site_Mark(CodeBuffer& buffer, jint pc_offset, JVMCIObject site, JVMCI_TRAPS) {\n-  JVMCIObject id_obj = jvmci_env()->get_site_Mark_id(site);\n-\n-  if (id_obj.is_non_null()) {\n-    if (!jvmci_env()->is_boxing_object(T_INT, id_obj)) {\n-      JVMCI_ERROR(\"expected Integer id, got %s\", jvmci_env()->klass_name(id_obj));\n-    }\n-    jint id = jvmci_env()->get_boxed_value(T_INT, id_obj).i;\n-\n-    address pc = _instructions->start() + pc_offset;\n-\n-    switch (id) {\n-      case UNVERIFIED_ENTRY:\n-        _offsets.set_value(CodeOffsets::Entry, pc_offset);\n-        break;\n-      case VERIFIED_ENTRY:\n-        _offsets.set_value(CodeOffsets::Verified_Entry, pc_offset);\n-        break;\n-      case OSR_ENTRY:\n-        _offsets.set_value(CodeOffsets::OSR_Entry, pc_offset);\n-        break;\n-      case EXCEPTION_HANDLER_ENTRY:\n-        _offsets.set_value(CodeOffsets::Exceptions, pc_offset);\n-        break;\n-      case DEOPT_HANDLER_ENTRY:\n-        _offsets.set_value(CodeOffsets::Deopt, pc_offset);\n-        break;\n-      case DEOPT_MH_HANDLER_ENTRY:\n-        _offsets.set_value(CodeOffsets::DeoptMH, pc_offset);\n-        break;\n-      case FRAME_COMPLETE:\n-        _offsets.set_value(CodeOffsets::Frame_Complete, pc_offset);\n-        break;\n-      case INVOKEVIRTUAL:\n-      case INVOKEINTERFACE:\n-      case INLINE_INVOKE:\n-      case INVOKESTATIC:\n-      case INVOKESPECIAL:\n-        _next_call_type = (MarkId) id;\n-        _invoke_mark_pc = pc;\n-        break;\n-      case POLL_NEAR:\n-      case POLL_FAR:\n-      case POLL_RETURN_NEAR:\n-      case POLL_RETURN_FAR:\n-        pd_relocate_poll(pc, id, JVMCI_CHECK);\n-        break;\n-      case CARD_TABLE_SHIFT:\n-      case CARD_TABLE_ADDRESS:\n-      case HEAP_TOP_ADDRESS:\n-      case HEAP_END_ADDRESS:\n-      case NARROW_KLASS_BASE_ADDRESS:\n-      case NARROW_OOP_BASE_ADDRESS:\n-      case CRC_TABLE_ADDRESS:\n-      case LOG_OF_HEAP_REGION_GRAIN_BYTES:\n-      case INLINE_CONTIGUOUS_ALLOCATION_SUPPORTED:\n-      case VERIFY_OOPS:\n-      case VERIFY_OOP_BITS:\n-      case VERIFY_OOP_MASK:\n-      case VERIFY_OOP_COUNT_ADDRESS:\n-        break;\n-      default:\n-        JVMCI_ERROR(\"invalid mark id: %d\", id);\n-        break;\n-    }\n+void CodeInstaller::site_Mark(CodeBuffer& buffer, jint pc_offset, HotSpotCompiledCodeStream* stream, JVMCI_TRAPS) {\n+  u1 id = stream->read_u1(\"mark:id\");\n+  address pc = _instructions->start() + pc_offset;\n+\n+  switch (id) {\n+    case UNVERIFIED_ENTRY:\n+      _offsets.set_value(CodeOffsets::Entry, pc_offset);\n+      break;\n+    case VERIFIED_ENTRY:\n+      _offsets.set_value(CodeOffsets::Verified_Entry, pc_offset);\n+      break;\n+    case OSR_ENTRY:\n+      _offsets.set_value(CodeOffsets::OSR_Entry, pc_offset);\n+      break;\n+    case EXCEPTION_HANDLER_ENTRY:\n+      _offsets.set_value(CodeOffsets::Exceptions, pc_offset);\n+      break;\n+    case DEOPT_HANDLER_ENTRY:\n+      _offsets.set_value(CodeOffsets::Deopt, pc_offset);\n+      break;\n+    case DEOPT_MH_HANDLER_ENTRY:\n+      _offsets.set_value(CodeOffsets::DeoptMH, pc_offset);\n+      break;\n+    case FRAME_COMPLETE:\n+      _offsets.set_value(CodeOffsets::Frame_Complete, pc_offset);\n+      break;\n+    case INVOKEVIRTUAL:\n+    case INVOKEINTERFACE:\n+    case INLINE_INVOKE:\n+    case INVOKESTATIC:\n+    case INVOKESPECIAL:\n+      _next_call_type = (MarkId) id;\n+      _invoke_mark_pc = pc;\n+      break;\n+    case POLL_NEAR:\n+    case POLL_FAR:\n+    case POLL_RETURN_NEAR:\n+    case POLL_RETURN_FAR:\n+      pd_relocate_poll(pc, id, JVMCI_CHECK);\n+      break;\n+    case CARD_TABLE_SHIFT:\n+    case CARD_TABLE_ADDRESS:\n+    case HEAP_TOP_ADDRESS:\n+    case HEAP_END_ADDRESS:\n+    case NARROW_KLASS_BASE_ADDRESS:\n+    case NARROW_OOP_BASE_ADDRESS:\n+    case CRC_TABLE_ADDRESS:\n+    case LOG_OF_HEAP_REGION_GRAIN_BYTES:\n+    case INLINE_CONTIGUOUS_ALLOCATION_SUPPORTED:\n+    case VERIFY_OOPS:\n+    case VERIFY_OOP_BITS:\n+    case VERIFY_OOP_MASK:\n+    case VERIFY_OOP_COUNT_ADDRESS:\n+      break;\n+    default:\n+      JVMCI_ERROR(\"invalid mark id: %d%s\", id, stream->context());\n+      break;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":806,"deletions":790,"binary":false,"changes":1596,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"classfile\/classFileStream.hpp\"\n@@ -33,15 +34,15 @@\n-class CodeMetadata {\n-public:\n-  CodeMetadata() {}\n-\n-  CodeBlob* get_code_blob() const { return _cb; }\n-\n-  PcDesc* get_pc_desc() const { return _pc_desc; }\n-  int get_nr_pc_desc() const { return _nr_pc_desc; }\n-\n-  u_char* get_scopes_desc() const { return _scopes_desc; }\n-  int get_scopes_size() const { return _nr_scopes_desc; }\n-\n-  ExceptionHandlerTable* get_exception_table() { return _exception_table; }\n-\n-  ImplicitExceptionTable* get_implicit_exception_table() { return _implicit_exception_table; }\n+\/\/ Object for decoding a serialized HotSpotCompiledCode object.\n+\/\/ Encoding is done by jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.\n+class HotSpotCompiledCodeStream : public ResourceObj {\n+ private:\n+  class Chunk {\n+   private:\n+    Chunk* _next;\n+    u4 _size;\n+\n+   public:\n+    u4 size() const            { return _size; }\n+    const u1* data()     const { return ((const u1*)this) + HEADER; }\n+    const u1* data_end() const { return data() + _size; }\n+    Chunk* next() const        { return _next; }\n+  };\n@@ -49,3 +50,61 @@\n-  void set_pc_desc(PcDesc* desc, int count) {\n-    _pc_desc = desc;\n-    _nr_pc_desc = count;\n+  \/\/ Mirrors jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.HEADER\n+  static const int HEADER = sizeof(Chunk*) + sizeof(u4);\n+\n+  Chunk* _head;                 \/\/ First chunk in buffer\n+  Chunk* _chunk;                \/\/ Chunk currently being read\n+  mutable const u1* _pos;       \/\/ Read position in _chunk\n+  const bool _with_type_info;\n+  objArrayHandle _object_pool;  \/\/ Pool for objects in Java heap (ignored if libjvmci)\n+  JavaThread* _thread;          \/\/ Current thread\n+\n+  \/\/ Virtual objects in DebugInfo currently being decoded\n+  GrowableArray<ScopeValue*>* _virtual_objects;\n+\n+  \/\/ HotSpotCompiledCode.name or HotSpotCompiledNmethod.method\n+  const char* _code_desc;\n+\n+#define checked_read(value, name, type) do { \\\n+  if (_with_type_info) { check_data(sizeof(type), name); } \\\n+  return (type) value; \\\n+} while (0)\n+\n+  void before_read(u1 size);\n+\n+  u1 get_u1() { before_read(1); u1 res = *_pos;         _pos += 1; return res; }\n+  u2 get_u2() { before_read(2); u2 res = *((u2*) _pos); _pos += 2; return res; }\n+  u4 get_u4() { before_read(4); u4 res = *((u4*) _pos); _pos += 4; return res; }\n+  u8 get_u8() { before_read(8); u8 res = *((u8*) _pos); _pos += 8; return res; }\n+\n+  void check_data(u2 expect_size, const char *expect_name);\n+\n+ public:\n+  HotSpotCompiledCodeStream(JavaThread* thread, const u1* buffer, bool with_type_info, objArrayHandle& object_pool) :\n+    _head((Chunk*) buffer),\n+    _chunk((Chunk*) buffer),\n+    _pos(_chunk->data()),\n+    _with_type_info(with_type_info),\n+    _object_pool(object_pool),\n+    _thread(thread),\n+    _virtual_objects(nullptr),\n+    _code_desc(\"<unknown>\")\n+  {}\n+\n+  \/\/ Dump complete buffer to `st`.\n+  void dump_buffer(outputStream* st=tty) const;\n+\n+  \/\/ Dump last `len` bytes of current buffer chunk to `st`\n+  void dump_buffer_tail(int len, outputStream* st=tty) const;\n+\n+  \/\/ Gets a string containing code_desc() followed by a hexdump\n+  \/\/ of about 100 bytes in the stream up to the current read position.\n+  const char* context() const;\n+\n+  \/\/ Gets HotSpotCompiledCode.name or HotSpotCompiledNmethod.method.name_and_sig_as_C_string().\n+  const char* code_desc() const { return _code_desc; }\n+\n+  void set_code_desc(const char* name, methodHandle& method) {\n+    if (name != nullptr) {\n+      _code_desc = name;\n+    } else if (!method.is_null()) {\n+      _code_desc = method->name_and_sig_as_C_string();\n+    }\n@@ -54,4 +113,2 @@\n-  void set_scopes(u_char* scopes, int size) {\n-    _scopes_desc = scopes;\n-    _nr_scopes_desc = size;\n-  }\n+  \/\/ Current read address.\n+  address pos() const { return (address) _pos; }\n@@ -59,3 +116,2 @@\n-  void set_exception_table(ExceptionHandlerTable* table) {\n-    _exception_table = table;\n-  }\n+  \/\/ Offset of current read position from start of buffer.\n+  u4 offset() const;\n@@ -63,3 +119,2 @@\n-  void set_implicit_exception_table(ImplicitExceptionTable* table) {\n-    _implicit_exception_table = table;\n-  }\n+  \/\/ Gets the number of remaining bytes in the stream.\n+  bool available() const;\n@@ -67,4 +122,5 @@\n-private:\n-  CodeBlob* _cb;\n-  PcDesc* _pc_desc;\n-  int _nr_pc_desc;\n+  oop get_oop(int id, JVMCI_TRAPS) const;\n+  JavaThread* thread() const { return _thread; }\n+\n+  void set_virtual_objects(GrowableArray<ScopeValue*>* objs) { _virtual_objects = objs; }\n+  ScopeValue* virtual_object_at(int id, JVMCI_TRAPS) const;\n@@ -72,2 +128,7 @@\n-  u_char* _scopes_desc;\n-  int _nr_scopes_desc;\n+  u1 read_u1(const char* name) { checked_read(get_u1(), name, u1); }\n+  u2 read_u2(const char* name) { checked_read(get_u2(), name, u2); }\n+  u4 read_u4(const char* name) { checked_read(get_u4(), name, u4); }\n+  u8 read_u8(const char* name) { checked_read(get_u8(), name, u8); }\n+  s2 read_s2(const char* name) { checked_read(get_u2(), name, s2); }\n+  s4 read_s4(const char* name) { checked_read(get_u4(), name, s4); }\n+  s8 read_s8(const char* name) { checked_read(get_u8(), name, s8); }\n@@ -75,2 +136,5 @@\n-  ExceptionHandlerTable* _exception_table;\n-  ImplicitExceptionTable* _implicit_exception_table;\n+  bool        read_bool(const char* name) { checked_read((get_u1() != 0), name, bool); }\n+  Method*     read_method(const char* name);\n+  Klass*      read_klass(const char* name);\n+  const char* read_utf8(const char* name, JVMCI_TRAPS);\n+#undef checked_read\n@@ -79,3 +143,1 @@\n-\/*\n- * This class handles the conversion from a InstalledCode to a CodeBlob or an nmethod.\n- *\/\n+\/\/ Converts a HotSpotCompiledCode to a CodeBlob or an nmethod.\n@@ -116,1 +178,69 @@\n-    INVOKE_INVALID                         = -1\n+    INVOKE_INVALID = -1\n+  };\n+\n+  \/\/ Mirrors jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag\n+  enum Tag {\n+    ILLEGAL,\n+    REGISTER_PRIMITIVE,\n+    REGISTER_OOP,\n+    REGISTER_NARROW_OOP,\n+    STACK_SLOT_PRIMITIVE,\n+    STACK_SLOT_OOP,\n+    STACK_SLOT_NARROW_OOP,\n+    VIRTUAL_OBJECT_ID,\n+    VIRTUAL_OBJECT_ID2,\n+    NULL_CONSTANT,\n+    RAW_CONSTANT,\n+    PRIMITIVE_0,\n+    PRIMITIVE4,\n+    PRIMITIVE8,\n+    JOBJECT,\n+    OBJECT_ID,\n+    OBJECT_ID2,\n+\n+    NO_FINALIZABLE_SUBCLASS,\n+    CONCRETE_SUBTYPE,\n+    LEAF_TYPE,\n+    CONCRETE_METHOD,\n+    CALLSITE_TARGET_VALUE,\n+\n+    PATCH_OBJECT_ID,\n+    PATCH_OBJECT_ID2,\n+    PATCH_NARROW_OBJECT_ID,\n+    PATCH_NARROW_OBJECT_ID2,\n+    PATCH_JOBJECT,\n+    PATCH_NARROW_JOBJECT,\n+    PATCH_KLASS,\n+    PATCH_NARROW_KLASS,\n+    PATCH_METHOD,\n+    PATCH_DATA_SECTION_REFERENCE,\n+\n+    SITE_CALL,\n+    SITE_FOREIGN_CALL,\n+    SITE_FOREIGN_CALL_NO_DEBUG_INFO,\n+    SITE_SAFEPOINT,\n+    SITE_INFOPOINT,\n+    SITE_IMPLICIT_EXCEPTION,\n+    SITE_IMPLICIT_EXCEPTION_DISPATCH,\n+    SITE_MARK,\n+    SITE_DATA_PATCH,\n+    SITE_EXCEPTION_HANDLER,\n+  };\n+\n+  \/\/ Mirrors constants from jdk.vm.ci.code.BytecodeFrame.\n+  enum BytecodeFrameBCI {\n+    UNWIND_BCI = -1,\n+    BEFORE_BCI = -2,\n+    AFTER_BCI = -3,\n+    AFTER_EXCEPTION_BCI = -4,\n+    UNKNOWN_BCI = -5,\n+    INVALID_FRAMESTATE_BCI = -6\n+  };\n+\n+  \/\/ Mirrors HotSpotCompiledCode flags from jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.\n+  enum HotSpotCompiledCodeFlags {\n+    HCC_IS_NMETHOD            = 0x01,\n+    HCC_HAS_ASSUMPTIONS       = 0x02,\n+    HCC_HAS_METHODS           = 0x04,\n+    HCC_HAS_DEOPT_RESCUE_SLOT = 0x08,\n+    HCC_HAS_COMMENTS          = 0x10\n@@ -119,0 +249,19 @@\n+  \/\/ Mirrors DebugInfo flags from jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.\n+  enum DebugInfoFlags {\n+    DI_HAS_REFERENCE_MAP    = 0x01,\n+    DI_HAS_CALLEE_SAVE_INFO = 0x02,\n+    DI_HAS_FRAMES           = 0x04\n+  };\n+\n+  \/\/ Mirrors BytecodeFrame flags from jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.\n+  enum DebugInfoFrameFlags {\n+    DIF_HAS_LOCALS        = 0x01,\n+    DIF_HAS_STACK         = 0x02,\n+    DIF_HAS_LOCKS         = 0x04,\n+    DIF_DURING_CALL       = 0x08,\n+    DIF_RETHROW_EXCEPTION = 0x10\n+  };\n+\n+  \/\/ Sentinel value in a DebugInfo stream denoting no register.\n+  static const int NO_REGISTER = 0xFFFF;\n+\n@@ -122,8 +271,1 @@\n-  JVMCIPrimitiveArray    _data_section_handle;\n-  JVMCIObjectArray       _data_section_patches_handle;\n-  JVMCIObjectArray       _sites_handle;\n-#ifndef PRODUCT\n-  JVMCIObjectArray       _comments_handle;\n-#endif\n-  JVMCIPrimitiveArray    _code_handle;\n-  JVMCIObject            _word_kind_handle;\n+  jint          _sites_count;\n@@ -163,3 +305,3 @@\n-  jint pd_next_offset(NativeInstruction* inst, jint pc_offset, JVMCIObject method, JVMCI_TRAPS);\n-  void pd_patch_OopConstant(int pc_offset, JVMCIObject constant, JVMCI_TRAPS);\n-  void pd_patch_MetaspaceConstant(int pc_offset, JVMCIObject constant, JVMCI_TRAPS);\n+  jint pd_next_offset(NativeInstruction* inst, jint pc_offset, JVMCI_TRAPS);\n+  void pd_patch_OopConstant(int pc_offset, Handle& obj, bool compressed, JVMCI_TRAPS);\n+  void pd_patch_MetaspaceConstant(int pc_offset, HotSpotCompiledCodeStream* stream, u1 tag, JVMCI_TRAPS);\n@@ -168,1 +310,1 @@\n-  void pd_relocate_JavaMethod(CodeBuffer &cbuf, JVMCIObject method, jint pc_offset, JVMCI_TRAPS);\n+  void pd_relocate_JavaMethod(CodeBuffer &cbuf, methodHandle& method, jint pc_offset, JVMCI_TRAPS);\n@@ -171,4 +313,2 @@\n-  JVMCIObjectArray sites()                { return _sites_handle; }\n-  JVMCIPrimitiveArray code()              { return _code_handle; }\n-  JVMCIPrimitiveArray  data_section()     { return _data_section_handle; }\n-  JVMCIObjectArray data_section_patches() { return _data_section_patches_handle; }\n+public:\n+\n@@ -176,1 +316,2 @@\n-  JVMCIObjectArray comments()             { return _comments_handle; }\n+  \/\/ Verifies the enum mirroring BCI constants in BytecodeFrame is in sync.\n+  static void verify_bci_constants(JVMCIEnv* env);\n@@ -178,3 +319,0 @@\n-  JVMCIObject word_kind()                 { return _word_kind_handle; }\n-\n-public:\n@@ -188,1 +326,2 @@\n-                                   JVMCIObject target,\n+                                   jlong compiled_code_buffer,\n+                                   bool with_type_info,\n@@ -190,0 +329,1 @@\n+                                   objArrayHandle object_pool,\n@@ -204,0 +344,1 @@\n+  static ScopeValue* to_primitive_value(HotSpotCompiledCodeStream* stream, jlong raw, BasicType type, ScopeValue* &second, JVMCI_TRAPS);\n@@ -207,0 +348,3 @@\n+  \/\/ Gets the tag to be used with `read_oop()` corresponding to `patch_object_tag`.\n+  static u1 as_read_oop_tag(HotSpotCompiledCodeStream* stream, u1 patch_object_tag, JVMCI_TRAPS);\n+\n@@ -208,3 +352,3 @@\n-  Location::Type get_oop_type(JVMCIObject value);\n-  ScopeValue* get_scope_value(JVMCIObject value, BasicType type, GrowableArray<ScopeValue*>* objects, ScopeValue* &second, JVMCI_TRAPS);\n-  MonitorValue* get_monitor_value(JVMCIObject value, GrowableArray<ScopeValue*>* objects, JVMCI_TRAPS);\n+  Handle read_oop(HotSpotCompiledCodeStream* stream, u1 tag, JVMCI_TRAPS);\n+\n+  ScopeValue* get_scope_value(HotSpotCompiledCodeStream* stream, u1 tag, BasicType type, ScopeValue* &second, JVMCI_TRAPS);\n@@ -212,1 +356,3 @@\n-  void* record_metadata_reference(CodeSection* section, address dest, JVMCIObject constant, JVMCI_TRAPS);\n+  GrowableArray<ScopeValue*>* read_local_or_stack_values(HotSpotCompiledCodeStream* stream, u1 frame_flags, bool is_locals, JVMCI_TRAPS);\n+\n+  void* record_metadata_reference(CodeSection* section, address dest, HotSpotCompiledCodeStream* stream, u1 tag, JVMCI_TRAPS);\n@@ -214,1 +360,1 @@\n-  narrowKlass record_narrow_metadata_reference(CodeSection* section, address dest, JVMCIObject constant, JVMCI_TRAPS);\n+  narrowKlass record_narrow_metadata_reference(CodeSection* section, address dest, HotSpotCompiledCodeStream* stream, u1 tag, JVMCI_TRAPS);\n@@ -216,0 +362,1 @@\n+  GrowableArray<MonitorValue*>* read_monitor_values(HotSpotCompiledCodeStream* stream, u1 frame_flags, JVMCI_TRAPS);\n@@ -218,2 +365,2 @@\n-  void initialize_fields(JVMCIObject target, JVMCIObject compiled_code, JVMCI_TRAPS);\n-  void initialize_dependencies(JVMCIObject compiled_code, OopRecorder* oop_recorder, JVMCI_TRAPS);\n+  void initialize_fields(HotSpotCompiledCodeStream* stream, u1 code_flags, methodHandle& method, JVMCI_TRAPS);\n+  void initialize_dependencies(HotSpotCompiledCodeStream* stream, u1 code_flags, OopRecorder* oop_recorder, JVMCI_TRAPS);\n@@ -221,1 +368,1 @@\n-  int estimate_stubs_size(JVMCI_TRAPS);\n+  int estimate_stubs_size(HotSpotCompiledCodeStream* stream, JVMCI_TRAPS);\n@@ -224,28 +371,12 @@\n-  JVMCI::CodeInstallResult initialize_buffer(CodeBuffer& buffer, bool check_size, JVMCI_TRAPS);\n-\n-  void assumption_NoFinalizableSubclass(JVMCIObject assumption);\n-  void assumption_ConcreteSubtype(JVMCIObject assumption);\n-  void assumption_LeafType(JVMCIObject assumption);\n-  void assumption_ConcreteMethod(JVMCIObject assumption);\n-  void assumption_CallSiteTargetValue(JVMCIObject assumption, JVMCI_TRAPS);\n-\n-  void site_Safepoint(CodeBuffer& buffer, jint pc_offset, JVMCIObject site, JVMCI_TRAPS);\n-  void site_Infopoint(CodeBuffer& buffer, jint pc_offset, JVMCIObject site, JVMCI_TRAPS);\n-  void site_Call(CodeBuffer& buffer, jint pc_offset, JVMCIObject site, JVMCI_TRAPS);\n-  void site_DataPatch(CodeBuffer& buffer, jint pc_offset, JVMCIObject site, JVMCI_TRAPS);\n-  void site_Mark(CodeBuffer& buffer, jint pc_offset, JVMCIObject site, JVMCI_TRAPS);\n-  void site_ExceptionHandler(jint pc_offset, JVMCIObject site);\n-\n-  OopMap* create_oop_map(JVMCIObject debug_info, JVMCI_TRAPS);\n-\n-  VMReg getVMRegFromLocation(JVMCIObject location, int total_frame_size, JVMCI_TRAPS);\n-\n-  \/**\n-   * Specifies the level of detail to record for a scope.\n-   *\/\n-  enum ScopeMode {\n-    \/\/ Only record a method and BCI\n-    BytecodePosition,\n-    \/\/ Record a method, bci and JVM frame state\n-    FullFrame\n-  };\n+  JVMCI::CodeInstallResult initialize_buffer(JVMCIObject compiled_code, CodeBuffer& buffer, HotSpotCompiledCodeStream* stream, u1 code_flags, JVMCI_TRAPS);\n+\n+  void site_Safepoint(CodeBuffer& buffer, jint pc_offset, HotSpotCompiledCodeStream* stream, u1 tag, JVMCI_TRAPS);\n+  void site_Infopoint(CodeBuffer& buffer, jint pc_offset, HotSpotCompiledCodeStream* stream, JVMCI_TRAPS);\n+  void site_Call(CodeBuffer& buffer, u1 tag, jint pc_offset, HotSpotCompiledCodeStream* stream, JVMCI_TRAPS);\n+  void site_DataPatch(CodeBuffer& buffer, jint pc_offset, HotSpotCompiledCodeStream* stream, JVMCI_TRAPS);\n+  void site_Mark(CodeBuffer& buffer, jint pc_offset, HotSpotCompiledCodeStream* stream, JVMCI_TRAPS);\n+  void site_ExceptionHandler(jint pc_offset, HotSpotCompiledCodeStream* stream);\n+\n+  OopMap* create_oop_map(HotSpotCompiledCodeStream* stream, u1 debug_info_flags, JVMCI_TRAPS);\n+\n+  VMReg getVMRegFromLocation(HotSpotCompiledCodeStream* stream, int total_frame_size, JVMCI_TRAPS);\n@@ -255,3 +386,7 @@\n-  void record_scope(jint pc_offset, JVMCIObject debug_info, ScopeMode scope_mode, bool is_mh_invoke, bool return_oop, JVMCI_TRAPS);\n-  void record_scope(jint pc_offset, JVMCIObject debug_info, ScopeMode scope_mode, JVMCI_TRAPS) {\n-    record_scope(pc_offset, debug_info, scope_mode, false \/* is_mh_invoke *\/, false \/* return_oop *\/, JVMCIENV);\n+  void record_oop_patch(HotSpotCompiledCodeStream* stream, address dest, u1 read_tag, bool narrow, JVMCI_TRAPS);\n+\n+  \/\/ full_info: if false, only BytecodePosition is in stream otherwise all DebugInfo is in stream\n+  void record_scope(jint pc_offset, HotSpotCompiledCodeStream* stream, u1 debug_info_flags, bool full_info, bool is_mh_invoke, bool return_oop, JVMCI_TRAPS);\n+\n+  void record_scope(jint pc_offset, HotSpotCompiledCodeStream* stream, u1 debug_info_flags, bool full_info, JVMCI_TRAPS) {\n+    record_scope(pc_offset, stream, debug_info_flags, full_info, false \/* is_mh_invoke *\/, false \/* return_oop *\/, JVMCIENV);\n@@ -259,2 +394,1 @@\n-  void record_scope(jint pc_offset, JVMCIObject position, ScopeMode scope_mode, GrowableArray<ScopeValue*>* objects, bool is_mh_invoke, bool return_oop, JVMCI_TRAPS);\n-  void record_object_value(ObjectValue* sv, JVMCIObject value, GrowableArray<ScopeValue*>* objects, JVMCI_TRAPS);\n+  void record_object_value(ObjectValue* sv, HotSpotCompiledCodeStream* stream, JVMCI_TRAPS);\n@@ -262,1 +396,1 @@\n-  GrowableArray<ScopeValue*>* record_virtual_objects(JVMCIObject debug_info, JVMCI_TRAPS);\n+  void read_virtual_objects(HotSpotCompiledCodeStream* stream, JVMCI_TRAPS);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.hpp","additions":237,"deletions":103,"binary":false,"changes":340,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-elapsedTimer JVMCICompiler::_codeInstallTimer;\n-elapsedTimer JVMCICompiler::_hostedCodeInstallTimer;\n@@ -186,1 +184,1 @@\n-\/\/ Print CompileBroker compilation timers\n+\/\/ Print compilation timers\n@@ -188,1 +186,0 @@\n-  double code_install_time = _codeInstallTimer.seconds();\n@@ -191,1 +188,4 @@\n-  tty->print_cr(\"       Install Code:   %7.3f s\", code_install_time);\n+  _jit_code_installs.print_on(tty, \"       Install Code:   \");\n+  tty->cr();\n+  tty->print_cr(\"    JVMCI Hosted Time:\");\n+  _hosted_code_installs.print_on(tty, \"       Install Code:   \");\n@@ -194,5 +194,10 @@\n-\/\/ Print non-CompileBroker compilation timers\n-void JVMCICompiler::print_hosted_timers() {\n-  double code_install_time = _hostedCodeInstallTimer.seconds();\n-  tty->print_cr(\"    JVMCI Hosted Time:\");\n-  tty->print_cr(\"       Install Code:   %7.3f s\", code_install_time);\n+void JVMCICompiler::CodeInstallStats::print_on(outputStream* st, const char* prefix) const {\n+  double time = _timer.seconds();\n+  st->print_cr(\"%s%7.3f s (installs: %d, CodeBlob total size: %d, CodeBlob code size: %d)\",\n+      prefix, time, _count, _codeBlobs_size, _codeBlobs_code_size);\n+}\n+\n+void JVMCICompiler::CodeInstallStats::on_install(CodeBlob* cb) {\n+  Atomic::inc(&_count);\n+  Atomic::add(&_codeBlobs_size, cb->size());\n+  Atomic::add(&_codeBlobs_code_size, cb->code_size());\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompiler.cpp","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -32,1 +32,24 @@\n-private:\n+ public:\n+  \/\/ Code installation specific statistics.\n+  class CodeInstallStats {\n+   private:\n+    elapsedTimer _timer;\n+    volatile int _count;\n+    volatile int _codeBlobs_size;\n+    volatile int _codeBlobs_code_size;\n+   public:\n+    CodeInstallStats() :\n+      _count(0),\n+      _codeBlobs_size(0),\n+      _codeBlobs_code_size(0)\n+    {}\n+\n+    elapsedTimer* timer() { return &_timer; }\n+    void print_on(outputStream* st, const char* prefix) const;\n+\n+    \/\/ Notifies this object that `cb` has just been\n+    \/\/ installed in the code cache.\n+    void on_install(CodeBlob* cb);\n+  };\n+\n+ private:\n@@ -52,5 +75,2 @@\n-  \/\/ Code installation timer for CompileBroker compilations\n-  static elapsedTimer _codeInstallTimer;\n-\n-  \/\/ Code installation timer for non-CompileBroker compilations\n-  static elapsedTimer _hostedCodeInstallTimer;\n+  CodeInstallStats _jit_code_installs;     \/\/ CompileBroker compilations\n+  CodeInstallStats _hosted_code_installs;  \/\/ Non-CompileBroker compilations\n@@ -115,4 +135,1 @@\n-  \/\/ Print timers related to non-CompileBroker compilations\n-  static void print_hosted_timers();\n-\n-  static elapsedTimer* codeInstallTimer(bool hosted) {\n+  CodeInstallStats* code_install_stats(bool hosted) {\n@@ -120,1 +137,1 @@\n-      return &_codeInstallTimer;\n+      return &_jit_code_installs;\n@@ -122,1 +139,1 @@\n-      return &_hostedCodeInstallTimer;\n+      return &_hosted_code_installs;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompiler.hpp","additions":29,"deletions":12,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -231,2 +231,6 @@\n-C2V_VMENTRY_NULL(jbyteArray, getBytecode, (JNIEnv* env, jobject, jobject jvmci_method))\n-  methodHandle method(THREAD, JVMCIENV->asMethod(jvmci_method));\n+\/\/ Macros for argument pairs representing a wrapper object and its wrapped VM pointer\n+#define ARGUMENT_PAIR(name) jobject name ## _obj, jlong name ## _pointer\n+#define UNPACK_PAIR(type, name) ((type*) name ## _pointer)\n+\n+C2V_VMENTRY_NULL(jbyteArray, getBytecode, (JNIEnv* env, jobject, ARGUMENT_PAIR(method)))\n+  methodHandle method(THREAD, UNPACK_PAIR(Method, method));\n@@ -309,2 +313,2 @@\n-C2V_VMENTRY_0(jint, getExceptionTableLength, (JNIEnv* env, jobject, jobject jvmci_method))\n-  Method* method = JVMCIENV->asMethod(jvmci_method);\n+C2V_VMENTRY_0(jint, getExceptionTableLength, (JNIEnv* env, jobject, ARGUMENT_PAIR(method)))\n+  Method* method = UNPACK_PAIR(Method, method);\n@@ -314,2 +318,2 @@\n-C2V_VMENTRY_0(jlong, getExceptionTableStart, (JNIEnv* env, jobject, jobject jvmci_method))\n-  Method* method = JVMCIENV->asMethod(jvmci_method);\n+C2V_VMENTRY_0(jlong, getExceptionTableStart, (JNIEnv* env, jobject, ARGUMENT_PAIR(method)))\n+  Method* method = UNPACK_PAIR(Method, method);\n@@ -347,1 +351,1 @@\n-  } else if (JVMCIENV->isa_HotSpotObjectConstantImpl(base_object)) {\n+  } else {\n@@ -354,2 +358,0 @@\n-  } else if (JVMCIENV->isa_HotSpotResolvedJavaMethodImpl(base_object)) {\n-    method = JVMCIENV->asMethod(base_object);\n@@ -365,1 +367,1 @@\n-C2V_VMENTRY_NULL(jobject, getConstantPool, (JNIEnv* env, jobject, jobject object_handle))\n+C2V_VMENTRY_NULL(jobject, getConstantPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass_or_method), jboolean is_klass))\n@@ -367,2 +369,1 @@\n-  JVMCIObject object = JVMCIENV->wrap(object_handle);\n-  if (object.is_null()) {\n+  if (UNPACK_PAIR(address, klass_or_method) == 0) {\n@@ -371,4 +372,2 @@\n-  if (JVMCIENV->isa_HotSpotResolvedJavaMethodImpl(object)) {\n-    cp = JVMCIENV->asMethod(object)->constMethod()->constants();\n-  } else if (JVMCIENV->isa_HotSpotResolvedObjectTypeImpl(object)) {\n-    cp = InstanceKlass::cast(JVMCIENV->asKlass(object))->constants();\n+  if (!is_klass) {\n+    cp = (UNPACK_PAIR(Method, klass_or_method))->constMethod()->constants();\n@@ -376,2 +375,1 @@\n-    JVMCI_THROW_MSG_NULL(IllegalArgumentException,\n-                err_msg(\"Unexpected type: %s\", JVMCIENV->klass_name(object)));\n+    cp = InstanceKlass::cast(UNPACK_PAIR(Klass, klass_or_method))->constants();\n@@ -379,1 +377,0 @@\n-  assert(cp != NULL, \"npe\");\n@@ -390,1 +387,0 @@\n-    \/\/ klass = JVMCIENV->unhandle(base_object)->klass();\n@@ -428,3 +424,3 @@\n-C2V_VMENTRY_NULL(jobject, findUniqueConcreteMethod, (JNIEnv* env, jobject, jobject jvmci_type, jobject jvmci_method))\n-  methodHandle method (THREAD, JVMCIENV->asMethod(jvmci_method));\n-  InstanceKlass* holder = InstanceKlass::cast(JVMCIENV->asKlass(jvmci_type));\n+C2V_VMENTRY_NULL(jobject, findUniqueConcreteMethod, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass), ARGUMENT_PAIR(method)))\n+  methodHandle method (THREAD, UNPACK_PAIR(Method, method));\n+  InstanceKlass* holder = InstanceKlass::cast(UNPACK_PAIR(Klass, klass));\n@@ -447,2 +443,2 @@\n-C2V_VMENTRY_NULL(jobject, getImplementor, (JNIEnv* env, jobject, jobject jvmci_type))\n-  Klass* klass = JVMCIENV->asKlass(jvmci_type);\n+C2V_VMENTRY_NULL(jobject, getImplementor, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass)))\n+  Klass* klass = UNPACK_PAIR(Klass, klass);\n@@ -464,2 +460,2 @@\n-C2V_VMENTRY_0(jboolean, methodIsIgnoredBySecurityStackWalk,(JNIEnv* env, jobject, jobject jvmci_method))\n-  Method* method = JVMCIENV->asMethod(jvmci_method);\n+C2V_VMENTRY_0(jboolean, methodIsIgnoredBySecurityStackWalk,(JNIEnv* env, jobject, ARGUMENT_PAIR(method)))\n+  Method* method = UNPACK_PAIR(Method, method);\n@@ -469,2 +465,2 @@\n-C2V_VMENTRY_0(jboolean, isCompilable,(JNIEnv* env, jobject, jobject jvmci_method))\n-  Method* method = JVMCIENV->asMethod(jvmci_method);\n+C2V_VMENTRY_0(jboolean, isCompilable,(JNIEnv* env, jobject, ARGUMENT_PAIR(method)))\n+  Method* method = UNPACK_PAIR(Method, method);\n@@ -478,2 +474,2 @@\n-C2V_VMENTRY_0(jboolean, hasNeverInlineDirective,(JNIEnv* env, jobject, jobject jvmci_method))\n-  methodHandle method (THREAD, JVMCIENV->asMethod(jvmci_method));\n+C2V_VMENTRY_0(jboolean, hasNeverInlineDirective,(JNIEnv* env, jobject, ARGUMENT_PAIR(method)))\n+  methodHandle method (THREAD, UNPACK_PAIR(Method, method));\n@@ -483,2 +479,2 @@\n-C2V_VMENTRY_0(jboolean, shouldInlineMethod,(JNIEnv* env, jobject, jobject jvmci_method))\n-  methodHandle method (THREAD, JVMCIENV->asMethod(jvmci_method));\n+C2V_VMENTRY_0(jboolean, shouldInlineMethod,(JNIEnv* env, jobject, ARGUMENT_PAIR(method)))\n+  methodHandle method (THREAD, UNPACK_PAIR(Method, method));\n@@ -488,1 +484,1 @@\n-C2V_VMENTRY_NULL(jobject, lookupType, (JNIEnv* env, jobject, jstring jname, jclass accessing_class, jboolean resolve))\n+C2V_VMENTRY_NULL(jobject, lookupType, (JNIEnv* env, jobject, jstring jname, ARGUMENT_PAIR(accessing_klass), jboolean resolve))\n@@ -498,1 +494,1 @@\n-  Klass* accessing_klass = NULL;\n+  Klass* accessing_klass = UNPACK_PAIR(Klass, accessing_klass);\n@@ -501,2 +497,1 @@\n-  if (accessing_class != NULL) {\n-    accessing_klass = JVMCIENV->asKlass(accessing_class);\n+  if (accessing_klass != nullptr) {\n@@ -513,1 +508,1 @@\n-    if (resolved_klass == NULL) {\n+    if (resolved_klass == nullptr) {\n@@ -548,6 +543,1 @@\n-C2V_VMENTRY_NULL(jobject, getArrayType, (JNIEnv* env, jobject, jobject jvmci_type))\n-  if (jvmci_type == NULL) {\n-    JVMCI_THROW_0(NullPointerException);\n-  }\n-\n-  JVMCIObject jvmci_type_object = JVMCIENV->wrap(jvmci_type);\n+C2V_VMENTRY_NULL(jobject, getArrayType, (JNIEnv* env, jobject, jchar type_char, ARGUMENT_PAIR(klass)))\n@@ -555,2 +545,3 @@\n-  if (JVMCIENV->isa_HotSpotResolvedPrimitiveType(jvmci_type_object)) {\n-    BasicType type = JVMCIENV->kindToBasicType(JVMCIENV->get_HotSpotResolvedPrimitiveType_kind(jvmci_type_object), JVMCI_CHECK_0);\n+  Klass* klass = UNPACK_PAIR(Klass, klass);\n+  if (klass == nullptr) {\n+    BasicType type = JVMCIENV->typeCharToBasicType(type_char, JVMCI_CHECK_0);\n@@ -558,1 +549,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -561,1 +552,1 @@\n-    if (array_klass == NULL) {\n+    if (array_klass == nullptr) {\n@@ -565,4 +556,0 @@\n-    Klass* klass = JVMCIENV->asKlass(jvmci_type);\n-    if (klass == NULL) {\n-      JVMCI_THROW_0(NullPointerException);\n-    }\n@@ -577,2 +564,2 @@\n-  if (mirror == NULL) {\n-    return NULL;\n+  if (mirror == nullptr) {\n+    return nullptr;\n@@ -582,1 +569,1 @@\n-  if (klass == NULL) {\n+  if (klass == nullptr) {\n@@ -589,2 +576,2 @@\n-C2V_VMENTRY_NULL(jobject, resolvePossiblyCachedConstantInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))\n-  constantPoolHandle cp(THREAD, JVMCIENV->asConstantPool(jvmci_constant_pool));\n+C2V_VMENTRY_NULL(jobject, resolvePossiblyCachedConstantInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index))\n+  constantPoolHandle cp(THREAD, UNPACK_PAIR(ConstantPool, cp));\n@@ -606,1 +593,1 @@\n-      JVMCIObject kind;\n+      jchar type_char;\n@@ -610,8 +597,8 @@\n-        case T_LONG:    kind = JVMCIENV->get_JavaKind_Long();    raw_value = value.j; break;\n-        case T_DOUBLE:  kind = JVMCIENV->get_JavaKind_Double();  raw_value = value.j; break;\n-        case T_FLOAT:   kind = JVMCIENV->get_JavaKind_Float();   raw_value = value.i; break;\n-        case T_INT:     kind = JVMCIENV->get_JavaKind_Int();     raw_value = value.i; break;\n-        case T_SHORT:   kind = JVMCIENV->get_JavaKind_Short();   raw_value = value.s; break;\n-        case T_BYTE:    kind = JVMCIENV->get_JavaKind_Byte();    raw_value = value.b; break;\n-        case T_CHAR:    kind = JVMCIENV->get_JavaKind_Char();    raw_value = value.c; break;\n-        case T_BOOLEAN: kind = JVMCIENV->get_JavaKind_Boolean(); raw_value = value.z; break;\n+        case T_LONG:    type_char = 'J'; raw_value = value.j; break;\n+        case T_DOUBLE:  type_char = 'D'; raw_value = value.j; break;\n+        case T_FLOAT:   type_char = 'F'; raw_value = value.i; break;\n+        case T_INT:     type_char = 'I'; raw_value = value.i; break;\n+        case T_SHORT:   type_char = 'S'; raw_value = value.s; break;\n+        case T_BYTE:    type_char = 'B'; raw_value = value.b; break;\n+        case T_CHAR:    type_char = 'C'; raw_value = value.c; break;\n+        case T_BOOLEAN: type_char = 'Z'; raw_value = value.z; break;\n@@ -621,1 +608,1 @@\n-      JVMCIObject result = JVMCIENV->call_JavaConstant_forPrimitive(kind, raw_value, JVMCI_CHECK_NULL);\n+      JVMCIObject result = JVMCIENV->call_JavaConstant_forPrimitive(type_char, raw_value, JVMCI_CHECK_NULL);\n@@ -628,2 +615,2 @@\n-C2V_VMENTRY_NULL(jobjectArray, resolveBootstrapMethod, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))\n-  constantPoolHandle cp(THREAD, JVMCIENV->asConstantPool(jvmci_constant_pool));\n+C2V_VMENTRY_NULL(jobjectArray, resolveBootstrapMethod, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index))\n+  constantPoolHandle cp(THREAD, UNPACK_PAIR(ConstantPool, cp));\n@@ -699,2 +686,2 @@\n-C2V_VMENTRY_0(jint, lookupNameAndTypeRefIndexInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))\n-  constantPoolHandle cp(THREAD, JVMCIENV->asConstantPool(jvmci_constant_pool));\n+C2V_VMENTRY_0(jint, lookupNameAndTypeRefIndexInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index))\n+  constantPoolHandle cp(THREAD, UNPACK_PAIR(ConstantPool, cp));\n@@ -704,2 +691,2 @@\n-C2V_VMENTRY_NULL(jobject, lookupNameInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint which))\n-  constantPoolHandle cp(THREAD, JVMCIENV->asConstantPool(jvmci_constant_pool));\n+C2V_VMENTRY_NULL(jobject, lookupNameInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint which))\n+  constantPoolHandle cp(THREAD, UNPACK_PAIR(ConstantPool, cp));\n@@ -710,2 +697,2 @@\n-C2V_VMENTRY_NULL(jobject, lookupSignatureInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint which))\n-  constantPoolHandle cp(THREAD, JVMCIENV->asConstantPool(jvmci_constant_pool));\n+C2V_VMENTRY_NULL(jobject, lookupSignatureInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint which))\n+  constantPoolHandle cp(THREAD, UNPACK_PAIR(ConstantPool, cp));\n@@ -716,2 +703,2 @@\n-C2V_VMENTRY_0(jint, lookupKlassRefIndexInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))\n-  constantPoolHandle cp(THREAD, JVMCIENV->asConstantPool(jvmci_constant_pool));\n+C2V_VMENTRY_0(jint, lookupKlassRefIndexInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index))\n+  constantPoolHandle cp(THREAD, UNPACK_PAIR(ConstantPool, cp));\n@@ -721,2 +708,2 @@\n-C2V_VMENTRY_NULL(jobject, resolveTypeInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))\n-  constantPoolHandle cp(THREAD, JVMCIENV->asConstantPool(jvmci_constant_pool));\n+C2V_VMENTRY_NULL(jobject, resolveTypeInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index))\n+  constantPoolHandle cp(THREAD, UNPACK_PAIR(ConstantPool, cp));\n@@ -736,2 +723,2 @@\n-C2V_VMENTRY_NULL(jobject, lookupKlassInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))\n-  constantPoolHandle cp(THREAD, JVMCIENV->asConstantPool(jvmci_constant_pool));\n+C2V_VMENTRY_NULL(jobject, lookupKlassInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index))\n+  constantPoolHandle cp(THREAD, UNPACK_PAIR(ConstantPool, cp));\n@@ -741,1 +728,1 @@\n-  Symbol* symbol = NULL;\n+  Symbol* symbol = nullptr;\n@@ -764,2 +751,2 @@\n-C2V_VMENTRY_NULL(jobject, lookupAppendixInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))\n-  constantPoolHandle cp(THREAD, JVMCIENV->asConstantPool(jvmci_constant_pool));\n+C2V_VMENTRY_NULL(jobject, lookupAppendixInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index))\n+  constantPoolHandle cp(THREAD, UNPACK_PAIR(ConstantPool, cp));\n@@ -770,2 +757,2 @@\n-C2V_VMENTRY_NULL(jobject, lookupMethodInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))\n-  constantPoolHandle cp(THREAD, JVMCIENV->asConstantPool(jvmci_constant_pool));\n+C2V_VMENTRY_NULL(jobject, lookupMethodInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index, jbyte opcode))\n+  constantPoolHandle cp(THREAD, UNPACK_PAIR(ConstantPool, cp));\n@@ -779,2 +766,2 @@\n-C2V_VMENTRY_0(jint, constantPoolRemapInstructionOperandFromCache, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))\n-  constantPoolHandle cp(THREAD, JVMCIENV->asConstantPool(jvmci_constant_pool));\n+C2V_VMENTRY_0(jint, constantPoolRemapInstructionOperandFromCache, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index))\n+  constantPoolHandle cp(THREAD, UNPACK_PAIR(ConstantPool, cp));\n@@ -784,2 +771,2 @@\n-C2V_VMENTRY_NULL(jobject, resolveFieldInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index, jobject jvmci_method, jbyte opcode, jintArray info_handle))\n-  constantPoolHandle cp(THREAD, JVMCIENV->asConstantPool(jvmci_constant_pool));\n+C2V_VMENTRY_NULL(jobject, resolveFieldInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index, ARGUMENT_PAIR(method), jbyte opcode, jintArray info_handle))\n+  constantPoolHandle cp(THREAD, UNPACK_PAIR(ConstantPool, cp));\n@@ -788,1 +775,1 @@\n-  methodHandle mh(THREAD, (jvmci_method != NULL) ? JVMCIENV->asMethod(jvmci_method) : NULL);\n+  methodHandle mh(THREAD, UNPACK_PAIR(Method, method));\n@@ -803,3 +790,3 @@\n-C2V_VMENTRY_0(jint, getVtableIndexForInterfaceMethod, (JNIEnv* env, jobject, jobject jvmci_type, jobject jvmci_method))\n-  Klass* klass = JVMCIENV->asKlass(jvmci_type);\n-  methodHandle method(THREAD, JVMCIENV->asMethod(jvmci_method));\n+C2V_VMENTRY_0(jint, getVtableIndexForInterfaceMethod, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass), ARGUMENT_PAIR(method)))\n+  Klass* klass = UNPACK_PAIR(Klass, klass);\n+  methodHandle method(THREAD, UNPACK_PAIR(Method, method));\n@@ -825,4 +812,4 @@\n-C2V_VMENTRY_NULL(jobject, resolveMethod, (JNIEnv* env, jobject, jobject receiver_jvmci_type, jobject jvmci_method, jobject caller_jvmci_type))\n-  Klass* recv_klass = JVMCIENV->asKlass(receiver_jvmci_type);\n-  Klass* caller_klass = JVMCIENV->asKlass(caller_jvmci_type);\n-  methodHandle method(THREAD, JVMCIENV->asMethod(jvmci_method));\n+C2V_VMENTRY_NULL(jobject, resolveMethod, (JNIEnv* env, jobject, ARGUMENT_PAIR(receiver), ARGUMENT_PAIR(method), ARGUMENT_PAIR(caller)))\n+  Klass* recv_klass = UNPACK_PAIR(Klass, receiver);\n+  Klass* caller_klass = UNPACK_PAIR(Klass, caller);\n+  methodHandle method(THREAD, UNPACK_PAIR(Method, method));\n@@ -836,1 +823,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -851,1 +838,1 @@\n-  Method* m = NULL;\n+  Method* m = nullptr;\n@@ -863,1 +850,1 @@\n-  if (m == NULL) {\n+  if (m == nullptr) {\n@@ -865,1 +852,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -872,3 +859,3 @@\n-C2V_VMENTRY_0(jboolean, hasFinalizableSubclass,(JNIEnv* env, jobject, jobject jvmci_type))\n-  Klass* klass = JVMCIENV->asKlass(jvmci_type);\n-  assert(klass != NULL, \"method must not be called for primitive types\");\n+C2V_VMENTRY_0(jboolean, hasFinalizableSubclass,(JNIEnv* env, jobject, ARGUMENT_PAIR(klass)))\n+  Klass* klass = UNPACK_PAIR(Klass, klass);\n+  assert(klass != nullptr, \"method must not be called for primitive types\");\n@@ -879,1 +866,1 @@\n-  return Dependencies::find_finalizable_subclass(iklass) != NULL;\n+  return Dependencies::find_finalizable_subclass(iklass) != nullptr;\n@@ -882,2 +869,2 @@\n-C2V_VMENTRY_NULL(jobject, getClassInitializer, (JNIEnv* env, jobject, jobject jvmci_type))\n-  Klass* klass = JVMCIENV->asKlass(jvmci_type);\n+C2V_VMENTRY_NULL(jobject, getClassInitializer, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass)))\n+  Klass* klass = UNPACK_PAIR(Klass, klass);\n@@ -885,1 +872,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -903,2 +890,2 @@\n-C2V_VMENTRY(void, setNotInlinableOrCompilable,(JNIEnv* env, jobject,  jobject jvmci_method))\n-  methodHandle method(THREAD, JVMCIENV->asMethod(jvmci_method));\n+C2V_VMENTRY(void, setNotInlinableOrCompilable,(JNIEnv* env, jobject, ARGUMENT_PAIR(method)))\n+  methodHandle method(THREAD, UNPACK_PAIR(Method, method));\n@@ -910,2 +897,22 @@\n-C2V_VMENTRY_0(jint, installCode, (JNIEnv *env, jobject, jobject target, jobject compiled_code,\n-            jobject installed_code, jlong failed_speculations_address, jbyteArray speculations_obj))\n+C2V_VMENTRY_0(jint, getInstallCodeFlags, (JNIEnv *env, jobject))\n+  int flags = 0;\n+#ifndef PRODUCT\n+  flags |= 0x0001; \/\/ VM will install block comments\n+  flags |= 0x0004; \/\/ Enable HotSpotJVMCIRuntime.Option.CodeSerializationTypeInfo if not explicitly set\n+#endif\n+  if (JvmtiExport::can_hotswap_or_post_breakpoint()) {\n+    \/\/ VM needs to track method dependencies\n+    flags |= 0x0002;\n+  }\n+  return flags;\n+C2V_END\n+\n+C2V_VMENTRY_0(jint, installCode0, (JNIEnv *env, jobject,\n+    jlong compiled_code_buffer,\n+    jlong serialization_ns,\n+    bool with_type_info,\n+    jobject compiled_code,\n+    jobjectArray object_pool,\n+    jobject installed_code,\n+    jlong failed_speculations_address,\n+    jbyteArray speculations_obj))\n@@ -915,1 +922,0 @@\n-  JVMCIObject target_handle = JVMCIENV->wrap(target);\n@@ -917,0 +923,2 @@\n+  objArrayHandle object_pool_handle(thread, JVMCIENV->is_hotspot() ? (objArrayOop) JNIHandles::resolve(object_pool) : nullptr);\n+\n@@ -926,2 +934,4 @@\n-\n-  TraceTime install_time(\"installCode\", JVMCICompiler::codeInstallTimer(!thread->is_Compiler_thread()));\n+  JVMCICompiler::CodeInstallStats* stats = compiler->code_install_stats(!thread->is_Compiler_thread());\n+  elapsedTimer *timer = stats->timer();\n+  timer->add_nanoseconds(serialization_ns);\n+  TraceTime install_time(\"installCode\", timer);\n@@ -932,1 +942,2 @@\n-      target_handle,\n+      compiled_code_buffer,\n+      with_type_info,\n@@ -934,0 +945,1 @@\n+      object_pool_handle,\n@@ -956,0 +968,1 @@\n+    stats->on_install(cb);\n@@ -1017,1 +1030,1 @@\n-C2V_VMENTRY_NULL(jobject, getStackTraceElement, (JNIEnv* env, jobject, jobject jvmci_method, int bci))\n+C2V_VMENTRY_NULL(jobject, getStackTraceElement, (JNIEnv* env, jobject, ARGUMENT_PAIR(method), int bci))\n@@ -1020,1 +1033,1 @@\n-  methodHandle method(THREAD, JVMCIENV->asMethod(jvmci_method));\n+  methodHandle method(THREAD, UNPACK_PAIR(Method, method));\n@@ -1075,2 +1088,2 @@\n-C2V_VMENTRY_NULL(jlongArray, getLineNumberTable, (JNIEnv* env, jobject, jobject jvmci_method))\n-  Method* method = JVMCIENV->asMethod(jvmci_method);\n+C2V_VMENTRY_NULL(jlongArray, getLineNumberTable, (JNIEnv* env, jobject, ARGUMENT_PAIR(method)))\n+  Method* method = UNPACK_PAIR(Method, method);\n@@ -1102,2 +1115,2 @@\n-C2V_VMENTRY_0(jlong, getLocalVariableTableStart, (JNIEnv* env, jobject, jobject jvmci_method))\n-  Method* method = JVMCIENV->asMethod(jvmci_method);\n+C2V_VMENTRY_0(jlong, getLocalVariableTableStart, (JNIEnv* env, jobject, ARGUMENT_PAIR(method)))\n+  Method* method = UNPACK_PAIR(Method, method);\n@@ -1110,2 +1123,2 @@\n-C2V_VMENTRY_0(jint, getLocalVariableTableLength, (JNIEnv* env, jobject, jobject jvmci_method))\n-  Method* method = JVMCIENV->asMethod(jvmci_method);\n+C2V_VMENTRY_0(jint, getLocalVariableTableLength, (JNIEnv* env, jobject, ARGUMENT_PAIR(method)))\n+  Method* method = UNPACK_PAIR(Method, method);\n@@ -1115,2 +1128,2 @@\n-C2V_VMENTRY(void, reprofile, (JNIEnv* env, jobject, jobject jvmci_method))\n-  methodHandle method(THREAD, JVMCIENV->asMethod(jvmci_method));\n+C2V_VMENTRY(void, reprofile, (JNIEnv* env, jobject, ARGUMENT_PAIR(method)))\n+  methodHandle method(THREAD, UNPACK_PAIR(Method, method));\n@@ -1163,1 +1176,1 @@\n-C2V_VMENTRY_0(jint, allocateCompileId, (JNIEnv* env, jobject, jobject jvmci_method, int entry_bci))\n+C2V_VMENTRY_0(jint, allocateCompileId, (JNIEnv* env, jobject, ARGUMENT_PAIR(method), int entry_bci))\n@@ -1165,1 +1178,2 @@\n-  if (jvmci_method == NULL) {\n+  methodHandle method(THREAD, UNPACK_PAIR(Method, method));\n+  if (method.is_null()) {\n@@ -1168,1 +1182,0 @@\n-  methodHandle method(THREAD, JVMCIENV->asMethod(jvmci_method));\n@@ -1176,2 +1189,2 @@\n-C2V_VMENTRY_0(jboolean, isMature, (JNIEnv* env, jobject, jlong metaspace_method_data))\n-  MethodData* mdo = JVMCIENV->asMethodData(metaspace_method_data);\n+C2V_VMENTRY_0(jboolean, isMature, (JNIEnv* env, jobject, jlong method_data_pointer))\n+  MethodData* mdo = (MethodData*) method_data_pointer;\n@@ -1181,2 +1194,2 @@\n-C2V_VMENTRY_0(jboolean, hasCompiledCodeForOSR, (JNIEnv* env, jobject, jobject jvmci_method, int entry_bci, int comp_level))\n-  Method* method = JVMCIENV->asMethod(jvmci_method);\n+C2V_VMENTRY_0(jboolean, hasCompiledCodeForOSR, (JNIEnv* env, jobject, ARGUMENT_PAIR(method), int entry_bci, int comp_level))\n+  Method* method = UNPACK_PAIR(Method, method);\n@@ -1191,0 +1204,6 @@\n+C2V_VMENTRY_NULL(jobject, getSignatureName, (JNIEnv* env, jobject, jlong klass_pointer))\n+  Klass* klass = UNPACK_PAIR(Klass, klass);\n+  JVMCIObject signature = JVMCIENV->create_string(klass->signature_name(), JVMCI_CHECK_NULL);\n+  return JVMCIENV->get_jobject(signature);\n+C2V_END\n+\n@@ -1436,2 +1455,2 @@\n-C2V_VMENTRY(void, resolveInvokeDynamicInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))\n-  constantPoolHandle cp(THREAD, JVMCIENV->asConstantPool(jvmci_constant_pool));\n+C2V_VMENTRY(void, resolveInvokeDynamicInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index))\n+  constantPoolHandle cp(THREAD, UNPACK_PAIR(ConstantPool, cp));\n@@ -1444,2 +1463,2 @@\n-C2V_VMENTRY(void, resolveInvokeHandleInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))\n-  constantPoolHandle cp(THREAD, JVMCIENV->asConstantPool(jvmci_constant_pool));\n+C2V_VMENTRY(void, resolveInvokeHandleInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index))\n+  constantPoolHandle cp(THREAD, UNPACK_PAIR(ConstantPool, cp));\n@@ -1456,2 +1475,2 @@\n-C2V_VMENTRY_0(jint, isResolvedInvokeHandleInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))\n-  constantPoolHandle cp(THREAD, JVMCIENV->asConstantPool(jvmci_constant_pool));\n+C2V_VMENTRY_0(jint, isResolvedInvokeHandleInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index))\n+  constantPoolHandle cp(THREAD, UNPACK_PAIR(ConstantPool, cp));\n@@ -1655,2 +1674,2 @@\n-C2V_VMENTRY_0(jint, methodDataProfileDataSize, (JNIEnv* env, jobject, jlong metaspace_method_data, jint position))\n-  MethodData* mdo = JVMCIENV->asMethodData(metaspace_method_data);\n+C2V_VMENTRY_0(jint, methodDataProfileDataSize, (JNIEnv* env, jobject, jlong method_data_pointer, jint position))\n+  MethodData* mdo = (MethodData*) method_data_pointer;\n@@ -1673,2 +1692,3 @@\n-C2V_VMENTRY_NULL(jobject, getInterfaces, (JNIEnv* env, jobject, jobject jvmci_type))\n-  if (jvmci_type == NULL) {\n+C2V_VMENTRY_NULL(jobject, getInterfaces, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass)))\n+  Klass* klass = UNPACK_PAIR(Klass, klass);\n+  if (klass == nullptr) {\n@@ -1678,4 +1698,0 @@\n-  Klass* klass = JVMCIENV->asKlass(jvmci_type);\n-  if (klass == NULL) {\n-    JVMCI_THROW_0(NullPointerException);\n-  }\n@@ -1700,2 +1716,3 @@\n-C2V_VMENTRY_NULL(jobject, getComponentType, (JNIEnv* env, jobject, jobject jvmci_type))\n-  if (jvmci_type == NULL) {\n+C2V_VMENTRY_NULL(jobject, getComponentType, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass)))\n+  Klass* klass = UNPACK_PAIR(Klass, klass);\n+  if (klass == nullptr) {\n@@ -1705,5 +1722,2 @@\n-  Klass* klass = JVMCIENV->asKlass(jvmci_type);\n-  oop mirror = klass->java_mirror();\n-  if (java_lang_Class::is_primitive(mirror) ||\n-      !java_lang_Class::as_Klass(mirror)->is_array_klass()) {\n-    return NULL;\n+  if (!klass->is_array_klass()) {\n+    return nullptr;\n@@ -1711,1 +1725,1 @@\n-\n+  oop mirror = klass->java_mirror();\n@@ -1713,2 +1727,3 @@\n-  if (component_mirror == NULL) {\n-    return NULL;\n+  if (component_mirror == nullptr) {\n+    JVMCI_THROW_MSG_0(NullPointerException,\n+                    err_msg(\"Component mirror for array class %s is null\", klass->external_name()))\n@@ -1716,0 +1731,1 @@\n+\n@@ -1718,2 +1734,1 @@\n-    JVMCIKlassHandle klass_handle(THREAD);\n-    klass_handle = component_klass;\n+    JVMCIKlassHandle klass_handle(THREAD, component_klass);\n@@ -1728,2 +1743,3 @@\n-C2V_VMENTRY(void, ensureInitialized, (JNIEnv* env, jobject, jobject jvmci_type))\n-  if (jvmci_type == NULL) {\n+C2V_VMENTRY(void, ensureInitialized, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass)))\n+  Klass* klass = UNPACK_PAIR(Klass, klass);\n+  if (klass == nullptr) {\n@@ -1732,3 +1748,1 @@\n-\n-  Klass* klass = JVMCIENV->asKlass(jvmci_type);\n-  if (klass != NULL && klass->should_be_initialized()) {\n+  if (klass->should_be_initialized()) {\n@@ -1740,2 +1754,3 @@\n-C2V_VMENTRY(void, ensureLinked, (JNIEnv* env, jobject, jobject jvmci_type))\n-  if (jvmci_type == NULL) {\n+C2V_VMENTRY(void, ensureLinked, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass)))\n+  Klass* klass = UNPACK_PAIR(Klass, klass);\n+  if (klass == nullptr) {\n@@ -1744,3 +1759,1 @@\n-\n-  Klass* klass = JVMCIENV->asKlass(jvmci_type);\n-  if (klass != NULL && klass->is_instance_klass()) {\n+  if (klass->is_instance_klass()) {\n@@ -1874,2 +1887,3 @@\n-C2V_VMENTRY_NULL(jobjectArray, getDeclaredConstructors, (JNIEnv* env, jobject, jobject holder))\n-  if (holder == NULL) {\n+C2V_VMENTRY_NULL(jobjectArray, getDeclaredConstructors, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass)))\n+  Klass* klass = UNPACK_PAIR(Klass, klass);\n+  if (klass == nullptr) {\n@@ -1878,1 +1892,0 @@\n-  Klass* klass = JVMCIENV->asKlass(holder);\n@@ -1904,2 +1917,3 @@\n-C2V_VMENTRY_NULL(jobjectArray, getDeclaredMethods, (JNIEnv* env, jobject, jobject holder))\n-  if (holder == NULL) {\n+C2V_VMENTRY_NULL(jobjectArray, getDeclaredMethods, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass)))\n+  Klass* klass = UNPACK_PAIR(Klass, klass);\n+  if (klass == nullptr) {\n@@ -1908,1 +1922,0 @@\n-  Klass* klass = JVMCIENV->asKlass(holder);\n@@ -1934,39 +1947,1 @@\n-C2V_VMENTRY_NULL(jobject, readFieldValue, (JNIEnv* env, jobject, jobject object, jobject expected_type, jlong displacement, jobject kind_object))\n-  if (object == NULL || kind_object == NULL) {\n-    JVMCI_THROW_0(NullPointerException);\n-  }\n-\n-  JVMCIObject kind = JVMCIENV->wrap(kind_object);\n-  BasicType basic_type = JVMCIENV->kindToBasicType(kind, JVMCI_CHECK_NULL);\n-\n-  InstanceKlass* holder = NULL;\n-  if (expected_type != NULL) {\n-    holder = InstanceKlass::cast(JVMCIENV->asKlass(JVMCIENV->wrap(expected_type)));\n-  }\n-\n-  bool is_static = false;\n-  Handle obj;\n-  JVMCIObject base = JVMCIENV->wrap(object);\n-  if (JVMCIENV->isa_HotSpotObjectConstantImpl(base)) {\n-    obj = JVMCIENV->asConstant(base, JVMCI_CHECK_NULL);\n-    \/\/ asConstant will throw an NPE if a constant contains NULL\n-\n-    if (holder != NULL && !obj->is_a(holder)) {\n-      \/\/ Not a subtype of field holder\n-      return NULL;\n-    }\n-    is_static = false;\n-    if (holder == NULL && java_lang_Class::is_instance(obj()) && displacement >= InstanceMirrorKlass::offset_of_static_fields()) {\n-      is_static = true;\n-    }\n-  } else if (JVMCIENV->isa_HotSpotResolvedObjectTypeImpl(base)) {\n-    is_static = true;\n-    Klass* klass = JVMCIENV->asKlass(base);\n-    if (holder != NULL && holder != klass) {\n-      return NULL;\n-    }\n-    obj = Handle(THREAD, klass->java_mirror());\n-  } else {\n-    \/\/ The Java code is expected to guard against this path\n-    ShouldNotReachHere();\n-  }\n+static jobject read_field_value(Handle obj, long displacement, jchar type_char, bool is_static, Thread* THREAD, JVMCIEnv* JVMCIENV) {\n@@ -1974,0 +1949,1 @@\n+  BasicType basic_type = JVMCIENV->typeCharToBasicType(type_char, JVMCI_CHECK_NULL);\n@@ -2040,1 +2016,1 @@\n-          (java_lang_Class::as_Klass(obj()) == NULL || !java_lang_Class::as_Klass(obj())->is_array_klass())) {\n+          (java_lang_Class::as_Klass(obj()) == nullptr || !java_lang_Class::as_Klass(obj())->is_array_klass())) {\n@@ -2048,1 +2024,1 @@\n-      if (value == NULL) {\n+      if (value == nullptr) {\n@@ -2051,1 +2027,1 @@\n-        if (value != NULL && !oopDesc::is_oop(value)) {\n+        if (value != nullptr && !oopDesc::is_oop(value)) {\n@@ -2068,1 +2044,1 @@\n-  JVMCIObject result = JVMCIENV->call_JavaConstant_forPrimitive(kind, value, JVMCI_CHECK_NULL);\n+  JVMCIObject result = JVMCIENV->call_JavaConstant_forPrimitive(type_char, value, JVMCI_CHECK_NULL);\n@@ -2070,0 +2046,26 @@\n+}\n+\n+C2V_VMENTRY_NULL(jobject, readStaticFieldValue, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass), long displacement, jchar type_char))\n+  Klass* klass = UNPACK_PAIR(Klass, klass);\n+  Handle obj(THREAD, klass->java_mirror());\n+  return read_field_value(obj, displacement, type_char, true, THREAD, JVMCIENV);\n+C2V_END\n+\n+C2V_VMENTRY_NULL(jobject, readFieldValue, (JNIEnv* env, jobject, jobject object, ARGUMENT_PAIR(expected_type), long displacement, jchar type_char))\n+  if (object == nullptr) {\n+    JVMCI_THROW_0(NullPointerException);\n+  }\n+\n+  \/\/ asConstant will throw an NPE if a constant contains NULL\n+  Handle obj = JVMCIENV->asConstant(JVMCIENV->wrap(object), JVMCI_CHECK_NULL);\n+\n+  Klass* expected_klass = UNPACK_PAIR(Klass, expected_type);\n+  if (expected_klass != nullptr) {\n+    InstanceKlass* expected_iklass = InstanceKlass::cast(expected_klass);\n+    if (!obj->is_a(expected_iklass)) {\n+      \/\/ Not of the expected type\n+      return nullptr;\n+    }\n+  }\n+  bool is_static = expected_klass == nullptr && java_lang_Class::is_instance(obj()) && displacement >= InstanceMirrorKlass::offset_of_static_fields();\n+  return read_field_value(obj, displacement, type_char, is_static, THREAD, JVMCIENV);\n@@ -2072,2 +2074,3 @@\n-C2V_VMENTRY_0(jboolean, isInstance, (JNIEnv* env, jobject, jobject holder, jobject object))\n-  if (object == NULL || holder == NULL) {\n+C2V_VMENTRY_0(jboolean, isInstance, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass), jobject object))\n+  Klass* klass = UNPACK_PAIR(Klass, klass);\n+  if (object == NULL || klass == nullptr) {\n@@ -2077,1 +2080,0 @@\n-  Klass* klass = JVMCIENV->asKlass(JVMCIENV->wrap(holder));\n@@ -2081,2 +2083,4 @@\n-C2V_VMENTRY_0(jboolean, isAssignableFrom, (JNIEnv* env, jobject, jobject holder, jobject otherHolder))\n-  if (holder == NULL || otherHolder == NULL) {\n+C2V_VMENTRY_0(jboolean, isAssignableFrom, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass), ARGUMENT_PAIR(subklass)))\n+  Klass* klass = UNPACK_PAIR(Klass, klass);\n+  Klass* subklass = UNPACK_PAIR(Klass, subklass);\n+  if (klass == nullptr || subklass == nullptr) {\n@@ -2085,3 +2089,1 @@\n-  Klass* klass = JVMCIENV->asKlass(JVMCIENV->wrap(holder));\n-  Klass* otherKlass = JVMCIENV->asKlass(JVMCIENV->wrap(otherHolder));\n-  return otherKlass->is_subtype_of(klass);\n+  return subklass->is_subtype_of(klass);\n@@ -2090,2 +2092,3 @@\n-C2V_VMENTRY_0(jboolean, isTrustedForIntrinsics, (JNIEnv* env, jobject, jobject holder))\n-  if (holder == NULL) {\n+C2V_VMENTRY_0(jboolean, isTrustedForIntrinsics, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass)))\n+  Klass* klass = UNPACK_PAIR(Klass, klass);\n+  if (klass == nullptr) {\n@@ -2094,1 +2097,1 @@\n-  InstanceKlass* ik = InstanceKlass::cast(JVMCIENV->asKlass(JVMCIENV->wrap(holder)));\n+  InstanceKlass* ik = InstanceKlass::cast(klass);\n@@ -2139,2 +2142,3 @@\n-C2V_VMENTRY_NULL(jobject, getJavaMirror, (JNIEnv* env, jobject, jobject object))\n-  if (object == NULL) {\n+C2V_VMENTRY_NULL(jobject, getJavaMirror, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass)))\n+  Klass* klass = UNPACK_PAIR(Klass, klass);\n+  if (klass == nullptr) {\n@@ -2143,10 +2147,1 @@\n-  JVMCIObject base_object = JVMCIENV->wrap(object);\n-  Handle mirror;\n-  if (JVMCIENV->isa_HotSpotResolvedObjectTypeImpl(base_object)) {\n-    mirror = Handle(THREAD, JVMCIENV->asKlass(base_object)->java_mirror());\n-  } else if (JVMCIENV->isa_HotSpotResolvedPrimitiveType(base_object)) {\n-    mirror = JVMCIENV->asConstant(JVMCIENV->get_HotSpotResolvedPrimitiveType_mirror(base_object), JVMCI_CHECK_NULL);\n-  } else {\n-    JVMCI_THROW_MSG_NULL(IllegalArgumentException,\n-                         err_msg(\"Unexpected type: %s\", JVMCIENV->klass_name(base_object)));\n- }\n+  Handle mirror(THREAD, klass->java_mirror());\n@@ -2210,5 +2205,2 @@\n-C2V_VMENTRY_0(jint, arrayBaseOffset, (JNIEnv* env, jobject, jobject kind))\n-  if (kind == NULL) {\n-    JVMCI_THROW_0(NullPointerException);\n-  }\n-  BasicType type = JVMCIENV->kindToBasicType(JVMCIENV->wrap(kind), JVMCI_CHECK_0);\n+C2V_VMENTRY_0(jint, arrayBaseOffset, (JNIEnv* env, jobject, jchar type_char))\n+  BasicType type = JVMCIENV->typeCharToBasicType(type_char, JVMCI_CHECK_0);\n@@ -2218,5 +2210,2 @@\n-C2V_VMENTRY_0(jint, arrayIndexScale, (JNIEnv* env, jobject, jobject kind))\n-  if (kind == NULL) {\n-    JVMCI_THROW_0(NullPointerException);\n-  }\n-  BasicType type = JVMCIENV->kindToBasicType(JVMCIENV->wrap(kind), JVMCI_CHECK_0);\n+C2V_VMENTRY_0(jint, arrayIndexScale, (JNIEnv* env, jobject, jchar type_char))\n+  BasicType type = JVMCIENV->typeCharToBasicType(type_char, JVMCI_CHECK_0);\n@@ -2428,0 +2417,3 @@\n+    if (runtime->GetEnv(thread, (void**) &peerJNIEnv, JNI_VERSION_1_2) == JNI_OK) {\n+      return false;\n+    }\n@@ -2617,1 +2609,1 @@\n-C2V_VMENTRY_NULL(jobject, asReflectionExecutable, (JNIEnv* env, jobject, jobject jvmci_method))\n+C2V_VMENTRY_NULL(jobject, asReflectionExecutable, (JNIEnv* env, jobject, ARGUMENT_PAIR(method)))\n@@ -2619,1 +2611,1 @@\n-  methodHandle m(THREAD, JVMCIENV->asMethod(jvmci_method));\n+  methodHandle m(THREAD, UNPACK_PAIR(Method, method));\n@@ -2633,1 +2625,1 @@\n-C2V_VMENTRY_NULL(jobject, asReflectionField, (JNIEnv* env, jobject, jobject jvmci_type, jint index))\n+C2V_VMENTRY_NULL(jobject, asReflectionField, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass), jint index))\n@@ -2635,1 +2627,1 @@\n-  Klass* klass = JVMCIENV->asKlass(jvmci_type);\n+  Klass* klass = UNPACK_PAIR(Klass, klass);\n@@ -2683,2 +2675,2 @@\n-C2V_VMENTRY_0(jlong, getFailedSpeculationsAddress, (JNIEnv* env, jobject, jobject jvmci_method))\n-  methodHandle method(THREAD, JVMCIENV->asMethod(jvmci_method));\n+C2V_VMENTRY_0(jlong, getFailedSpeculationsAddress, (JNIEnv* env, jobject, ARGUMENT_PAIR(method)))\n+  methodHandle method(THREAD, UNPACK_PAIR(Method, method));\n@@ -2739,1 +2731,1 @@\n-C2V_VMENTRY(void, notifyCompilerInliningEvent, (JNIEnv* env, jobject, jint compileId, jobject caller, jobject callee, jboolean succeeded, jstring jmessage, jint bci))\n+C2V_VMENTRY(void, notifyCompilerInliningEvent, (JNIEnv* env, jobject, jint compileId, ARGUMENT_PAIR(caller), ARGUMENT_PAIR(callee), jboolean succeeded, jstring jmessage, jint bci))\n@@ -2742,2 +2734,2 @@\n-    Method* caller_method = JVMCIENV->asMethod(caller);\n-    Method* callee_method = JVMCIENV->asMethod(callee);\n+    Method* caller = UNPACK_PAIR(Method, caller);\n+    Method* callee = UNPACK_PAIR(Method, callee);\n@@ -2745,1 +2737,1 @@\n-    CompilerEvent::InlineEvent::post(event, compileId, caller_method, callee_method, succeeded, JVMCIENV->as_utf8_string(message), bci);\n+    CompilerEvent::InlineEvent::post(event, compileId, caller, callee, succeeded, JVMCIENV->as_utf8_string(message), bci);\n@@ -2799,1 +2791,0 @@\n-#define HANDLECONSTANT          \"Ljdk\/vm\/ci\/hotspot\/IndirectHotSpotObjectConstantImpl;\"\n@@ -2803,1 +2794,0 @@\n-#define TARGET_DESCRIPTION      \"Ljdk\/vm\/ci\/code\/TargetDescription;\"\n@@ -2808,2 +2798,0 @@\n-#define HS_RESOLVED_METHOD      \"Ljdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethodImpl;\"\n-#define HS_RESOLVED_KLASS       \"Ljdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl;\"\n@@ -2811,1 +2799,0 @@\n-#define HS_RESOLVED_FIELD       \"Ljdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaField;\"\n@@ -2814,1 +2801,0 @@\n-#define HS_CONSTANT_POOL        \"Ljdk\/vm\/ci\/hotspot\/HotSpotConstantPool;\"\n@@ -2819,1 +2805,0 @@\n-#define METASPACE_OBJECT        \"Ljdk\/vm\/ci\/hotspot\/MetaspaceObject;\"\n@@ -2822,1 +2807,8 @@\n-#define METASPACE_METHOD_DATA   \"J\"\n+\n+\/\/ Types wrapping VM pointers. The ...2 macro is for a pair: (wrapper, pointer)\n+#define HS_METHOD               \"Ljdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethodImpl;\"\n+#define HS_METHOD2              \"Ljdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethodImpl;J\"\n+#define HS_KLASS                \"Ljdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl;\"\n+#define HS_KLASS2               \"Ljdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl;J\"\n+#define HS_CONSTANT_POOL        \"Ljdk\/vm\/ci\/hotspot\/HotSpotConstantPool;\"\n+#define HS_CONSTANT_POOL2       \"Ljdk\/vm\/ci\/hotspot\/HotSpotConstantPool;J\"\n@@ -2825,13 +2817,13 @@\n-  {CC \"getBytecode\",                                  CC \"(\" HS_RESOLVED_METHOD \")[B\",                                                      FN_PTR(getBytecode)},\n-  {CC \"getExceptionTableStart\",                       CC \"(\" HS_RESOLVED_METHOD \")J\",                                                       FN_PTR(getExceptionTableStart)},\n-  {CC \"getExceptionTableLength\",                      CC \"(\" HS_RESOLVED_METHOD \")I\",                                                       FN_PTR(getExceptionTableLength)},\n-  {CC \"findUniqueConcreteMethod\",                     CC \"(\" HS_RESOLVED_KLASS HS_RESOLVED_METHOD \")\" HS_RESOLVED_METHOD,                   FN_PTR(findUniqueConcreteMethod)},\n-  {CC \"getImplementor\",                               CC \"(\" HS_RESOLVED_KLASS \")\" HS_RESOLVED_KLASS,                                       FN_PTR(getImplementor)},\n-  {CC \"getStackTraceElement\",                         CC \"(\" HS_RESOLVED_METHOD \"I)\" STACK_TRACE_ELEMENT,                                   FN_PTR(getStackTraceElement)},\n-  {CC \"methodIsIgnoredBySecurityStackWalk\",           CC \"(\" HS_RESOLVED_METHOD \")Z\",                                                       FN_PTR(methodIsIgnoredBySecurityStackWalk)},\n-  {CC \"setNotInlinableOrCompilable\",                  CC \"(\" HS_RESOLVED_METHOD \")V\",                                                       FN_PTR(setNotInlinableOrCompilable)},\n-  {CC \"isCompilable\",                                 CC \"(\" HS_RESOLVED_METHOD \")Z\",                                                       FN_PTR(isCompilable)},\n-  {CC \"hasNeverInlineDirective\",                      CC \"(\" HS_RESOLVED_METHOD \")Z\",                                                       FN_PTR(hasNeverInlineDirective)},\n-  {CC \"shouldInlineMethod\",                           CC \"(\" HS_RESOLVED_METHOD \")Z\",                                                       FN_PTR(shouldInlineMethod)},\n-  {CC \"lookupType\",                                   CC \"(\" STRING HS_RESOLVED_KLASS \"Z)\" HS_RESOLVED_TYPE,                                FN_PTR(lookupType)},\n-  {CC \"getArrayType\",                                 CC \"(\" HS_RESOLVED_TYPE \")\" HS_RESOLVED_KLASS,                                        FN_PTR(getArrayType)},\n+  {CC \"getBytecode\",                                  CC \"(\" HS_METHOD2 \")[B\",                                                              FN_PTR(getBytecode)},\n+  {CC \"getExceptionTableStart\",                       CC \"(\" HS_METHOD2 \")J\",                                                               FN_PTR(getExceptionTableStart)},\n+  {CC \"getExceptionTableLength\",                      CC \"(\" HS_METHOD2 \")I\",                                                               FN_PTR(getExceptionTableLength)},\n+  {CC \"findUniqueConcreteMethod\",                     CC \"(\" HS_KLASS2 HS_METHOD2 \")\" HS_METHOD,                                            FN_PTR(findUniqueConcreteMethod)},\n+  {CC \"getImplementor\",                               CC \"(\" HS_KLASS2 \")\" HS_KLASS,                                                        FN_PTR(getImplementor)},\n+  {CC \"getStackTraceElement\",                         CC \"(\" HS_METHOD2 \"I)\" STACK_TRACE_ELEMENT,                                           FN_PTR(getStackTraceElement)},\n+  {CC \"methodIsIgnoredBySecurityStackWalk\",           CC \"(\" HS_METHOD2 \")Z\",                                                               FN_PTR(methodIsIgnoredBySecurityStackWalk)},\n+  {CC \"setNotInlinableOrCompilable\",                  CC \"(\" HS_METHOD2 \")V\",                                                               FN_PTR(setNotInlinableOrCompilable)},\n+  {CC \"isCompilable\",                                 CC \"(\" HS_METHOD2 \")Z\",                                                               FN_PTR(isCompilable)},\n+  {CC \"hasNeverInlineDirective\",                      CC \"(\" HS_METHOD2 \")Z\",                                                               FN_PTR(hasNeverInlineDirective)},\n+  {CC \"shouldInlineMethod\",                           CC \"(\" HS_METHOD2 \")Z\",                                                               FN_PTR(shouldInlineMethod)},\n+  {CC \"lookupType\",                                   CC \"(\" STRING HS_KLASS2 \"Z)\" HS_RESOLVED_TYPE,                                        FN_PTR(lookupType)},\n+  {CC \"getArrayType\",                                 CC \"(C\" HS_KLASS2 \")\" HS_KLASS,                                                       FN_PTR(getArrayType)},\n@@ -2839,16 +2831,16 @@\n-  {CC \"lookupNameInPool\",                             CC \"(\" HS_CONSTANT_POOL \"I)\" STRING,                                                  FN_PTR(lookupNameInPool)},\n-  {CC \"lookupNameAndTypeRefIndexInPool\",              CC \"(\" HS_CONSTANT_POOL \"I)I\",                                                        FN_PTR(lookupNameAndTypeRefIndexInPool)},\n-  {CC \"lookupSignatureInPool\",                        CC \"(\" HS_CONSTANT_POOL \"I)\" STRING,                                                  FN_PTR(lookupSignatureInPool)},\n-  {CC \"lookupKlassRefIndexInPool\",                    CC \"(\" HS_CONSTANT_POOL \"I)I\",                                                        FN_PTR(lookupKlassRefIndexInPool)},\n-  {CC \"lookupKlassInPool\",                            CC \"(\" HS_CONSTANT_POOL \"I)Ljava\/lang\/Object;\",                                       FN_PTR(lookupKlassInPool)},\n-  {CC \"lookupAppendixInPool\",                         CC \"(\" HS_CONSTANT_POOL \"I)\" OBJECTCONSTANT,                                          FN_PTR(lookupAppendixInPool)},\n-  {CC \"lookupMethodInPool\",                           CC \"(\" HS_CONSTANT_POOL \"IB)\" HS_RESOLVED_METHOD,                                     FN_PTR(lookupMethodInPool)},\n-  {CC \"constantPoolRemapInstructionOperandFromCache\", CC \"(\" HS_CONSTANT_POOL \"I)I\",                                                        FN_PTR(constantPoolRemapInstructionOperandFromCache)},\n-  {CC \"resolveBootstrapMethod\",                       CC \"(\" HS_CONSTANT_POOL \"I)[\" OBJECT,                                                 FN_PTR(resolveBootstrapMethod)},\n-  {CC \"resolvePossiblyCachedConstantInPool\",          CC \"(\" HS_CONSTANT_POOL \"I)\" JAVACONSTANT,                                            FN_PTR(resolvePossiblyCachedConstantInPool)},\n-  {CC \"resolveTypeInPool\",                            CC \"(\" HS_CONSTANT_POOL \"I)\" HS_RESOLVED_KLASS,                                       FN_PTR(resolveTypeInPool)},\n-  {CC \"resolveFieldInPool\",                           CC \"(\" HS_CONSTANT_POOL \"I\" HS_RESOLVED_METHOD \"B[I)\" HS_RESOLVED_KLASS,              FN_PTR(resolveFieldInPool)},\n-  {CC \"resolveInvokeDynamicInPool\",                   CC \"(\" HS_CONSTANT_POOL \"I)V\",                                                        FN_PTR(resolveInvokeDynamicInPool)},\n-  {CC \"resolveInvokeHandleInPool\",                    CC \"(\" HS_CONSTANT_POOL \"I)V\",                                                        FN_PTR(resolveInvokeHandleInPool)},\n-  {CC \"isResolvedInvokeHandleInPool\",                 CC \"(\" HS_CONSTANT_POOL \"I)I\",                                                        FN_PTR(isResolvedInvokeHandleInPool)},\n-  {CC \"resolveMethod\",                                CC \"(\" HS_RESOLVED_KLASS HS_RESOLVED_METHOD HS_RESOLVED_KLASS \")\" HS_RESOLVED_METHOD, FN_PTR(resolveMethod)},\n+  {CC \"lookupNameInPool\",                             CC \"(\" HS_CONSTANT_POOL2 \"I)\" STRING,                                                 FN_PTR(lookupNameInPool)},\n+  {CC \"lookupNameAndTypeRefIndexInPool\",              CC \"(\" HS_CONSTANT_POOL2 \"I)I\",                                                       FN_PTR(lookupNameAndTypeRefIndexInPool)},\n+  {CC \"lookupSignatureInPool\",                        CC \"(\" HS_CONSTANT_POOL2 \"I)\" STRING,                                                 FN_PTR(lookupSignatureInPool)},\n+  {CC \"lookupKlassRefIndexInPool\",                    CC \"(\" HS_CONSTANT_POOL2 \"I)I\",                                                       FN_PTR(lookupKlassRefIndexInPool)},\n+  {CC \"lookupKlassInPool\",                            CC \"(\" HS_CONSTANT_POOL2 \"I)Ljava\/lang\/Object;\",                                      FN_PTR(lookupKlassInPool)},\n+  {CC \"lookupAppendixInPool\",                         CC \"(\" HS_CONSTANT_POOL2 \"I)\" OBJECTCONSTANT,                                         FN_PTR(lookupAppendixInPool)},\n+  {CC \"lookupMethodInPool\",                           CC \"(\" HS_CONSTANT_POOL2 \"IB)\" HS_METHOD,                                             FN_PTR(lookupMethodInPool)},\n+  {CC \"constantPoolRemapInstructionOperandFromCache\", CC \"(\" HS_CONSTANT_POOL2 \"I)I\",                                                       FN_PTR(constantPoolRemapInstructionOperandFromCache)},\n+  {CC \"resolveBootstrapMethod\",                       CC \"(\" HS_CONSTANT_POOL2 \"I)[\" OBJECT,                                                FN_PTR(resolveBootstrapMethod)},\n+  {CC \"resolvePossiblyCachedConstantInPool\",          CC \"(\" HS_CONSTANT_POOL2 \"I)\" JAVACONSTANT,                                           FN_PTR(resolvePossiblyCachedConstantInPool)},\n+  {CC \"resolveTypeInPool\",                            CC \"(\" HS_CONSTANT_POOL2 \"I)\" HS_KLASS,                                               FN_PTR(resolveTypeInPool)},\n+  {CC \"resolveFieldInPool\",                           CC \"(\" HS_CONSTANT_POOL2 \"I\" HS_METHOD2 \"B[I)\" HS_KLASS,                              FN_PTR(resolveFieldInPool)},\n+  {CC \"resolveInvokeDynamicInPool\",                   CC \"(\" HS_CONSTANT_POOL2 \"I)V\",                                                       FN_PTR(resolveInvokeDynamicInPool)},\n+  {CC \"resolveInvokeHandleInPool\",                    CC \"(\" HS_CONSTANT_POOL2 \"I)V\",                                                       FN_PTR(resolveInvokeHandleInPool)},\n+  {CC \"isResolvedInvokeHandleInPool\",                 CC \"(\" HS_CONSTANT_POOL2 \"I)I\",                                                       FN_PTR(isResolvedInvokeHandleInPool)},\n+  {CC \"resolveMethod\",                                CC \"(\" HS_KLASS2 HS_METHOD2 HS_KLASS2 \")\" HS_METHOD,                                  FN_PTR(resolveMethod)},\n@@ -2856,3 +2848,3 @@\n-  {CC \"getVtableIndexForInterfaceMethod\",             CC \"(\" HS_RESOLVED_KLASS HS_RESOLVED_METHOD \")I\",                                     FN_PTR(getVtableIndexForInterfaceMethod)},\n-  {CC \"getClassInitializer\",                          CC \"(\" HS_RESOLVED_KLASS \")\" HS_RESOLVED_METHOD,                                      FN_PTR(getClassInitializer)},\n-  {CC \"hasFinalizableSubclass\",                       CC \"(\" HS_RESOLVED_KLASS \")Z\",                                                        FN_PTR(hasFinalizableSubclass)},\n+  {CC \"getVtableIndexForInterfaceMethod\",             CC \"(\" HS_KLASS2 HS_METHOD2 \")I\",                                                     FN_PTR(getVtableIndexForInterfaceMethod)},\n+  {CC \"getClassInitializer\",                          CC \"(\" HS_KLASS2 \")\" HS_METHOD,                                                       FN_PTR(getClassInitializer)},\n+  {CC \"hasFinalizableSubclass\",                       CC \"(\" HS_KLASS2 \")Z\",                                                                FN_PTR(hasFinalizableSubclass)},\n@@ -2860,4 +2852,4 @@\n-  {CC \"asResolvedJavaMethod\",                         CC \"(\" EXECUTABLE \")\" HS_RESOLVED_METHOD,                                             FN_PTR(asResolvedJavaMethod)},\n-  {CC \"getResolvedJavaMethod\",                        CC \"(\" OBJECTCONSTANT \"J)\" HS_RESOLVED_METHOD,                                        FN_PTR(getResolvedJavaMethod)},\n-  {CC \"getConstantPool\",                              CC \"(\" METASPACE_OBJECT \")\" HS_CONSTANT_POOL,                                         FN_PTR(getConstantPool)},\n-  {CC \"getResolvedJavaType0\",                         CC \"(Ljava\/lang\/Object;JZ)\" HS_RESOLVED_KLASS,                                        FN_PTR(getResolvedJavaType0)},\n+  {CC \"asResolvedJavaMethod\",                         CC \"(\" EXECUTABLE \")\" HS_METHOD,                                                      FN_PTR(asResolvedJavaMethod)},\n+  {CC \"getResolvedJavaMethod\",                        CC \"(\" OBJECTCONSTANT \"J)\" HS_METHOD,                                                 FN_PTR(getResolvedJavaMethod)},\n+  {CC \"getConstantPool\",                              CC \"(\" OBJECT \"JZ)\" HS_CONSTANT_POOL,                                                 FN_PTR(getConstantPool)},\n+  {CC \"getResolvedJavaType0\",                         CC \"(Ljava\/lang\/Object;JZ)\" HS_KLASS,                                                 FN_PTR(getResolvedJavaType0)},\n@@ -2865,1 +2857,2 @@\n-  {CC \"installCode\",                                  CC \"(\" TARGET_DESCRIPTION HS_COMPILED_CODE INSTALLED_CODE \"J[B)I\",                    FN_PTR(installCode)},\n+  {CC \"installCode0\",                                 CC \"(JJZ\" HS_COMPILED_CODE \"[\" OBJECT INSTALLED_CODE \"J[B)I\",                         FN_PTR(installCode0)},\n+  {CC \"getInstallCodeFlags\",                          CC \"()I\",                                                                             FN_PTR(getInstallCodeFlags)},\n@@ -2869,4 +2862,4 @@\n-  {CC \"getLineNumberTable\",                           CC \"(\" HS_RESOLVED_METHOD \")[J\",                                                      FN_PTR(getLineNumberTable)},\n-  {CC \"getLocalVariableTableStart\",                   CC \"(\" HS_RESOLVED_METHOD \")J\",                                                       FN_PTR(getLocalVariableTableStart)},\n-  {CC \"getLocalVariableTableLength\",                  CC \"(\" HS_RESOLVED_METHOD \")I\",                                                       FN_PTR(getLocalVariableTableLength)},\n-  {CC \"reprofile\",                                    CC \"(\" HS_RESOLVED_METHOD \")V\",                                                       FN_PTR(reprofile)},\n+  {CC \"getLineNumberTable\",                           CC \"(\" HS_METHOD2 \")[J\",                                                              FN_PTR(getLineNumberTable)},\n+  {CC \"getLocalVariableTableStart\",                   CC \"(\" HS_METHOD2 \")J\",                                                               FN_PTR(getLocalVariableTableStart)},\n+  {CC \"getLocalVariableTableLength\",                  CC \"(\" HS_METHOD2 \")I\",                                                               FN_PTR(getLocalVariableTableLength)},\n+  {CC \"reprofile\",                                    CC \"(\" HS_METHOD2 \")V\",                                                               FN_PTR(reprofile)},\n@@ -2877,3 +2870,3 @@\n-  {CC \"allocateCompileId\",                            CC \"(\" HS_RESOLVED_METHOD \"I)I\",                                                      FN_PTR(allocateCompileId)},\n-  {CC \"isMature\",                                     CC \"(\" METASPACE_METHOD_DATA \")Z\",                                                    FN_PTR(isMature)},\n-  {CC \"hasCompiledCodeForOSR\",                        CC \"(\" HS_RESOLVED_METHOD \"II)Z\",                                                     FN_PTR(hasCompiledCodeForOSR)},\n+  {CC \"allocateCompileId\",                            CC \"(\" HS_METHOD2 \"I)I\",                                                              FN_PTR(allocateCompileId)},\n+  {CC \"isMature\",                                     CC \"(J)Z\",                                                                            FN_PTR(isMature)},\n+  {CC \"hasCompiledCodeForOSR\",                        CC \"(\" HS_METHOD2 \"II)Z\",                                                             FN_PTR(hasCompiledCodeForOSR)},\n@@ -2881,0 +2874,1 @@\n+  {CC \"getSignatureName\",                             CC \"(J)\" STRING,                                                                      FN_PTR(getSignatureName)},\n@@ -2890,4 +2884,4 @@\n-  {CC \"getInterfaces\",                                CC \"(\" HS_RESOLVED_KLASS \")[\" HS_RESOLVED_KLASS,                                      FN_PTR(getInterfaces)},\n-  {CC \"getComponentType\",                             CC \"(\" HS_RESOLVED_KLASS \")\" HS_RESOLVED_TYPE,                                        FN_PTR(getComponentType)},\n-  {CC \"ensureInitialized\",                            CC \"(\" HS_RESOLVED_KLASS \")V\",                                                        FN_PTR(ensureInitialized)},\n-  {CC \"ensureLinked\",                                 CC \"(\" HS_RESOLVED_KLASS \")V\",                                                        FN_PTR(ensureLinked)},\n+  {CC \"getInterfaces\",                                CC \"(\" HS_KLASS2 \")[\" HS_KLASS,                                                       FN_PTR(getInterfaces)},\n+  {CC \"getComponentType\",                             CC \"(\" HS_KLASS2 \")\" HS_RESOLVED_TYPE,                                                FN_PTR(getComponentType)},\n+  {CC \"ensureInitialized\",                            CC \"(\" HS_KLASS2 \")V\",                                                                FN_PTR(ensureInitialized)},\n+  {CC \"ensureLinked\",                                 CC \"(\" HS_KLASS2 \")V\",                                                                FN_PTR(ensureLinked)},\n@@ -2898,7 +2892,7 @@\n-  {CC \"getDeclaredConstructors\",                      CC \"(\" HS_RESOLVED_KLASS \")[\" RESOLVED_METHOD,                                        FN_PTR(getDeclaredConstructors)},\n-  {CC \"getDeclaredMethods\",                           CC \"(\" HS_RESOLVED_KLASS \")[\" RESOLVED_METHOD,                                        FN_PTR(getDeclaredMethods)},\n-  {CC \"readFieldValue\",                               CC \"(\" HS_RESOLVED_KLASS HS_RESOLVED_KLASS \"JLjdk\/vm\/ci\/meta\/JavaKind;)\" JAVACONSTANT, FN_PTR(readFieldValue)},\n-  {CC \"readFieldValue\",                               CC \"(\" OBJECTCONSTANT HS_RESOLVED_KLASS \"JLjdk\/vm\/ci\/meta\/JavaKind;)\" JAVACONSTANT,   FN_PTR(readFieldValue)},\n-  {CC \"isInstance\",                                   CC \"(\" HS_RESOLVED_KLASS OBJECTCONSTANT \")Z\",                                         FN_PTR(isInstance)},\n-  {CC \"isAssignableFrom\",                             CC \"(\" HS_RESOLVED_KLASS HS_RESOLVED_KLASS \")Z\",                                      FN_PTR(isAssignableFrom)},\n-  {CC \"isTrustedForIntrinsics\",                       CC \"(\" HS_RESOLVED_KLASS \")Z\",                                                        FN_PTR(isTrustedForIntrinsics)},\n+  {CC \"getDeclaredConstructors\",                      CC \"(\" HS_KLASS2 \")[\" RESOLVED_METHOD,                                                FN_PTR(getDeclaredConstructors)},\n+  {CC \"getDeclaredMethods\",                           CC \"(\" HS_KLASS2 \")[\" RESOLVED_METHOD,                                                FN_PTR(getDeclaredMethods)},\n+  {CC \"readStaticFieldValue\",                         CC \"(\" HS_KLASS2 \"JC)\" JAVACONSTANT,                                                  FN_PTR(readStaticFieldValue)},\n+  {CC \"readFieldValue\",                               CC \"(\" OBJECTCONSTANT HS_KLASS2 \"JC)\" JAVACONSTANT,                                   FN_PTR(readFieldValue)},\n+  {CC \"isInstance\",                                   CC \"(\" HS_KLASS2 OBJECTCONSTANT \")Z\",                                                 FN_PTR(isInstance)},\n+  {CC \"isAssignableFrom\",                             CC \"(\" HS_KLASS2 HS_KLASS2 \")Z\",                                                      FN_PTR(isAssignableFrom)},\n+  {CC \"isTrustedForIntrinsics\",                       CC \"(\" HS_KLASS2 \")Z\",                                                                FN_PTR(isTrustedForIntrinsics)},\n@@ -2908,1 +2902,1 @@\n-  {CC \"getJavaMirror\",                                CC \"(\" HS_RESOLVED_TYPE \")\" OBJECTCONSTANT,                                           FN_PTR(getJavaMirror)},\n+  {CC \"getJavaMirror\",                                CC \"(\" HS_KLASS2 \")\" OBJECTCONSTANT,                                                  FN_PTR(getJavaMirror)},\n@@ -2911,2 +2905,2 @@\n-  {CC \"arrayBaseOffset\",                              CC \"(Ljdk\/vm\/ci\/meta\/JavaKind;)I\",                                                    FN_PTR(arrayBaseOffset)},\n-  {CC \"arrayIndexScale\",                              CC \"(Ljdk\/vm\/ci\/meta\/JavaKind;)I\",                                                    FN_PTR(arrayIndexScale)},\n+  {CC \"arrayBaseOffset\",                              CC \"(C)I\",                                                                            FN_PTR(arrayBaseOffset)},\n+  {CC \"arrayIndexScale\",                              CC \"(C)I\",                                                                            FN_PTR(arrayIndexScale)},\n@@ -2923,2 +2917,2 @@\n-  {CC \"asReflectionExecutable\",                       CC \"(\" HS_RESOLVED_METHOD \")\" REFLECTION_EXECUTABLE,                                  FN_PTR(asReflectionExecutable)},\n-  {CC \"asReflectionField\",                            CC \"(\" HS_RESOLVED_KLASS \"I)\" REFLECTION_FIELD,                                       FN_PTR(asReflectionField)},\n+  {CC \"asReflectionExecutable\",                       CC \"(\" HS_METHOD2 \")\" REFLECTION_EXECUTABLE,                                          FN_PTR(asReflectionExecutable)},\n+  {CC \"asReflectionField\",                            CC \"(\" HS_KLASS2 \"I)\" REFLECTION_FIELD,                                               FN_PTR(asReflectionField)},\n@@ -2926,1 +2920,1 @@\n-  {CC \"getFailedSpeculationsAddress\",                 CC \"(\" HS_RESOLVED_METHOD \")J\",                                                       FN_PTR(getFailedSpeculationsAddress)},\n+  {CC \"getFailedSpeculationsAddress\",                 CC \"(\" HS_METHOD2 \")J\",                                                               FN_PTR(getFailedSpeculationsAddress)},\n@@ -2937,1 +2931,1 @@\n-  {CC \"notifyCompilerInliningEvent\",                  CC \"(I\" HS_RESOLVED_METHOD HS_RESOLVED_METHOD \"ZLjava\/lang\/String;I)V\",               FN_PTR(notifyCompilerInliningEvent)},\n+  {CC \"notifyCompilerInliningEvent\",                  CC \"(I\" HS_METHOD2 HS_METHOD2 \"ZLjava\/lang\/String;I)V\",                               FN_PTR(notifyCompilerInliningEvent)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":326,"deletions":332,"binary":false,"changes":658,"status":"modified"},{"patch":"@@ -928,1 +928,1 @@\n-JVMCIObject JVMCIEnv::call_JavaConstant_forPrimitive(JVMCIObject kind, jlong value, JVMCI_TRAPS) {\n+JVMCIObject JVMCIEnv::call_JavaConstant_forPrimitive(jchar type_char, jlong value, JVMCI_TRAPS) {\n@@ -932,1 +932,1 @@\n-    jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(kind)));\n+    jargs.push_int(type_char);\n@@ -944,1 +944,1 @@\n-                                                             kind.as_jobject(), value);\n+                                                             type_char, value);\n@@ -1145,1 +1145,1 @@\n-  if (get_HotSpotResolvedJavaMethodImpl_metadataHandle(method_object) != (jlong) handle) {\n+  if (get_HotSpotResolvedJavaMethodImpl_methodHandle(method_object) != (jlong) handle) {\n@@ -1160,1 +1160,0 @@\n-  JVMCIObject signature = create_string(klass->signature_name(), JVMCI_CHECK_(JVMCIObject()));\n@@ -1166,1 +1165,0 @@\n-    args.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(signature)));\n@@ -1183,1 +1181,1 @@\n-                                                        pointer, signature.as_jstring()));\n+                                                        pointer));\n@@ -1227,1 +1225,1 @@\n-  assert(get_HotSpotConstantPool_metadataHandle(cp_object) == (jlong) handle, \"must use same handle\");\n+  assert(get_HotSpotConstantPool_constantPoolHandle(cp_object) == (jlong) handle, \"must use same handle\");\n@@ -1464,5 +1462,1 @@\n-BasicType JVMCIEnv::kindToBasicType(JVMCIObject kind, JVMCI_TRAPS) {\n-  if (kind.is_null()) {\n-    JVMCI_THROW_(NullPointerException, T_ILLEGAL);\n-  }\n-  jchar ch = get_JavaKind_typeChar(kind);\n+BasicType JVMCIEnv::typeCharToBasicType(jchar ch, JVMCI_TRAPS) {\n@@ -1481,1 +1475,7 @@\n-      JVMCI_ERROR_(T_ILLEGAL, \"unexpected Kind: %c\", ch);\n+      JVMCI_ERROR_(T_ILLEGAL, \"unexpected type char: %c\", ch);\n+  }\n+}\n+\n+BasicType JVMCIEnv::kindToBasicType(JVMCIObject kind, JVMCI_TRAPS) {\n+  if (kind.is_null()) {\n+    JVMCI_THROW_(NullPointerException, T_ILLEGAL);\n@@ -1483,0 +1483,3 @@\n+  jchar ch = get_JavaKind_typeChar(kind);\n+  BasicType bt = typeCharToBasicType(ch, JVMCI_CHECK_(T_ILLEGAL));\n+  return bt;\n@@ -1545,1 +1548,1 @@\n-  return (Klass*) get_HotSpotResolvedObjectTypeImpl_metadataPointer(obj);\n+  return (Klass*) get_HotSpotResolvedObjectTypeImpl_klassPointer(obj);\n@@ -1549,2 +1552,2 @@\n-  Method** metadataHandle = (Method**) get_HotSpotResolvedJavaMethodImpl_metadataHandle(obj);\n-  return *metadataHandle;\n+  Method** methodHandle = (Method**) get_HotSpotResolvedJavaMethodImpl_methodHandle(obj);\n+  return *methodHandle;\n@@ -1554,2 +1557,2 @@\n-  ConstantPool** metadataHandle = (ConstantPool**) get_HotSpotConstantPool_metadataHandle(obj);\n-  return *metadataHandle;\n+  ConstantPool** constantPoolHandle = (ConstantPool**) get_HotSpotConstantPool_constantPoolHandle(obj);\n+  return *constantPoolHandle;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":22,"deletions":19,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -150,1 +150,0 @@\n-\n@@ -319,1 +318,1 @@\n-  JVMCIObject call_JavaConstant_forPrimitive(JVMCIObject kind, jlong value, JVMCI_TRAPS);\n+  JVMCIObject call_JavaConstant_forPrimitive(jchar type_char, jlong value, JVMCI_TRAPS);\n@@ -325,0 +324,4 @@\n+  \/\/ Converts the JavaKind.typeChar value in `ch` to a BasicType\n+  BasicType typeCharToBasicType(jchar ch, JVMCI_TRAPS);\n+\n+  \/\/ Converts the JavaKind value in `kind` to a BasicType\n@@ -352,4 +355,0 @@\n-  MethodData* asMethodData(jlong metaspaceMethodData) {\n-    return (MethodData*) (address) metaspaceMethodData;\n-  }\n-\n@@ -360,1 +359,0 @@\n-  Method* asMethod(jobject jvmci_method) { return asMethod(wrap(jvmci_method)); }\n@@ -364,1 +362,0 @@\n-  Klass* asKlass(jobject jvmci_type)  { return asKlass(wrap(jvmci_type)); }\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.hpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,3 +65,0 @@\n-  start_class(TargetDescription, jdk_vm_ci_code_TargetDescription)                                            \\\n-    object_field(TargetDescription, arch, \"Ljdk\/vm\/ci\/code\/Architecture;\")                                    \\\n-  end_class                                                                                                   \\\n@@ -69,1 +66,1 @@\n-    long_field(HotSpotResolvedObjectTypeImpl, metadataPointer)                                                \\\n+    long_field(HotSpotResolvedObjectTypeImpl, klassPointer)                                                   \\\n@@ -83,1 +80,1 @@\n-    long_field(HotSpotResolvedJavaMethodImpl, metadataHandle)                                                 \\\n+    long_field(HotSpotResolvedJavaMethodImpl, methodHandle)                                                   \\\n@@ -103,1 +100,0 @@\n-    object_field(HotSpotCompiledCode, name, \"Ljava\/lang\/String;\")                                             \\\n@@ -105,5 +101,0 @@\n-    int_field(HotSpotCompiledCode, targetCodeSize)                                                            \\\n-    objectarray_field(HotSpotCompiledCode, sites, \"[Ljdk\/vm\/ci\/code\/site\/Site;\")                              \\\n-    objectarray_field(HotSpotCompiledCode, assumptions, \"[Ljdk\/vm\/ci\/meta\/Assumptions$Assumption;\")           \\\n-    objectarray_field(HotSpotCompiledCode, methods, \"[Ljdk\/vm\/ci\/meta\/ResolvedJavaMethod;\")                   \\\n-    objectarray_field(HotSpotCompiledCode, comments, \"[Ljdk\/vm\/ci\/hotspot\/HotSpotCompiledCode$Comment;\")      \\\n@@ -111,9 +102,0 @@\n-    int_field(HotSpotCompiledCode, dataSectionAlignment)                                                      \\\n-    objectarray_field(HotSpotCompiledCode, dataSectionPatches, \"[Ljdk\/vm\/ci\/code\/site\/DataPatch;\")            \\\n-    boolean_field(HotSpotCompiledCode, isImmutablePIC)                                                        \\\n-    int_field(HotSpotCompiledCode, totalFrameSize)                                                            \\\n-    object_field(HotSpotCompiledCode, deoptRescueSlot, \"Ljdk\/vm\/ci\/code\/StackSlot;\")                          \\\n-  end_class                                                                                                   \\\n-  start_class(HotSpotCompiledCode_Comment, jdk_vm_ci_hotspot_HotSpotCompiledCode_Comment)                     \\\n-    object_field(HotSpotCompiledCode_Comment, text, \"Ljava\/lang\/String;\")                                     \\\n-    int_field(HotSpotCompiledCode_Comment, pcOffset)                                                          \\\n@@ -122,1 +104,0 @@\n-    object_field(HotSpotCompiledNmethod, method, \"Ljdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethod;\")             \\\n@@ -124,1 +105,0 @@\n-    int_field(HotSpotCompiledNmethod, entryBCI)                                                               \\\n@@ -126,5 +106,0 @@\n-    long_field(HotSpotCompiledNmethod, compileState)                                                          \\\n-    boolean_field(HotSpotCompiledNmethod, hasUnsafeAccess)                                                    \\\n-  end_class                                                                                                   \\\n-  start_class(HotSpotForeignCallTarget, jdk_vm_ci_hotspot_HotSpotForeignCallTarget)                           \\\n-    long_field(HotSpotForeignCallTarget, address)                                                             \\\n@@ -153,53 +128,0 @@\n-  start_class(Assumptions_NoFinalizableSubclass, jdk_vm_ci_meta_Assumptions_NoFinalizableSubclass)            \\\n-    object_field(Assumptions_NoFinalizableSubclass, receiverType, \"Ljdk\/vm\/ci\/meta\/ResolvedJavaType;\")        \\\n-  end_class                                                                                                   \\\n-  start_class(Assumptions_ConcreteSubtype, jdk_vm_ci_meta_Assumptions_ConcreteSubtype)                        \\\n-    object_field(Assumptions_ConcreteSubtype, context, \"Ljdk\/vm\/ci\/meta\/ResolvedJavaType;\")                   \\\n-    object_field(Assumptions_ConcreteSubtype, subtype, \"Ljdk\/vm\/ci\/meta\/ResolvedJavaType;\")                   \\\n-  end_class                                                                                                   \\\n-  start_class(Assumptions_LeafType, jdk_vm_ci_meta_Assumptions_LeafType)                                      \\\n-    object_field(Assumptions_LeafType, context, \"Ljdk\/vm\/ci\/meta\/ResolvedJavaType;\")                          \\\n-  end_class                                                                                                   \\\n-  start_class(Assumptions_ConcreteMethod, jdk_vm_ci_meta_Assumptions_ConcreteMethod)                          \\\n-    object_field(Assumptions_ConcreteMethod, method, \"Ljdk\/vm\/ci\/meta\/ResolvedJavaMethod;\")                   \\\n-    object_field(Assumptions_ConcreteMethod, context, \"Ljdk\/vm\/ci\/meta\/ResolvedJavaType;\")                    \\\n-    object_field(Assumptions_ConcreteMethod, impl, \"Ljdk\/vm\/ci\/meta\/ResolvedJavaMethod;\")                     \\\n-  end_class                                                                                                   \\\n-  start_class(Assumptions_CallSiteTargetValue, jdk_vm_ci_meta_Assumptions_CallSiteTargetValue)                \\\n-    object_field(Assumptions_CallSiteTargetValue, callSite, \"Ljdk\/vm\/ci\/meta\/JavaConstant;\")                  \\\n-    object_field(Assumptions_CallSiteTargetValue, methodHandle, \"Ljdk\/vm\/ci\/meta\/JavaConstant;\")              \\\n-  end_class                                                                                                   \\\n-  start_class(site_Site, jdk_vm_ci_code_site_Site)                                                            \\\n-    int_field(site_Site, pcOffset)                                                                            \\\n-  end_class                                                                                                   \\\n-  start_class(site_Call, jdk_vm_ci_code_site_Call)                                                            \\\n-    object_field(site_Call, target, \"Ljdk\/vm\/ci\/meta\/InvokeTarget;\")                                          \\\n-    boolean_field(site_Call, direct)                                                                          \\\n-  end_class                                                                                                   \\\n-  start_class(site_ImplicitExceptionDispatch, jdk_vm_ci_code_site_ImplicitExceptionDispatch)                  \\\n-    int_field(site_ImplicitExceptionDispatch, dispatchOffset)                                                 \\\n-  end_class                                                                                                   \\\n-  start_class(site_DataPatch, jdk_vm_ci_code_site_DataPatch)                                                  \\\n-    object_field(site_DataPatch, reference, \"Ljdk\/vm\/ci\/code\/site\/Reference;\")                                \\\n-  end_class                                                                                                   \\\n-  start_class(site_ConstantReference, jdk_vm_ci_code_site_ConstantReference)                                  \\\n-    object_field(site_ConstantReference, constant, \"Ljdk\/vm\/ci\/meta\/VMConstant;\")                             \\\n-  end_class                                                                                                   \\\n-  start_class(site_DataSectionReference, jdk_vm_ci_code_site_DataSectionReference)                            \\\n-    int_field(site_DataSectionReference, offset)                                                              \\\n-  end_class                                                                                                   \\\n-  start_class(site_InfopointReason, jdk_vm_ci_code_site_InfopointReason)                                      \\\n-    static_object_field(site_InfopointReason, SAFEPOINT, \"Ljdk\/vm\/ci\/code\/site\/InfopointReason;\")             \\\n-    static_object_field(site_InfopointReason, CALL, \"Ljdk\/vm\/ci\/code\/site\/InfopointReason;\")                  \\\n-    static_object_field(site_InfopointReason, IMPLICIT_EXCEPTION, \"Ljdk\/vm\/ci\/code\/site\/InfopointReason;\")    \\\n-  end_class                                                                                                   \\\n-  start_class(site_Infopoint, jdk_vm_ci_code_site_Infopoint)                                                  \\\n-    object_field(site_Infopoint, debugInfo, \"Ljdk\/vm\/ci\/code\/DebugInfo;\")                                     \\\n-    object_field(site_Infopoint, reason, \"Ljdk\/vm\/ci\/code\/site\/InfopointReason;\")                             \\\n-  end_class                                                                                                   \\\n-  start_class(site_ExceptionHandler, jdk_vm_ci_code_site_ExceptionHandler)                                    \\\n-    int_field(site_ExceptionHandler, handlerPos)                                                              \\\n-  end_class                                                                                                   \\\n-  start_class(site_Mark, jdk_vm_ci_code_site_Mark)                                                            \\\n-    object_field(site_Mark, id, \"Ljava\/lang\/Object;\")                                                         \\\n-  end_class                                                                                                   \\\n@@ -211,16 +133,0 @@\n-  start_class(DebugInfo, jdk_vm_ci_code_DebugInfo)                                                            \\\n-    object_field(DebugInfo, bytecodePosition, \"Ljdk\/vm\/ci\/code\/BytecodePosition;\")                            \\\n-    object_field(DebugInfo, referenceMap, \"Ljdk\/vm\/ci\/code\/ReferenceMap;\")                                    \\\n-    object_field(DebugInfo, calleeSaveInfo, \"Ljdk\/vm\/ci\/code\/RegisterSaveLayout;\")                            \\\n-    objectarray_field(DebugInfo, virtualObjectMapping, \"[Ljdk\/vm\/ci\/code\/VirtualObject;\")                     \\\n-  end_class                                                                                                   \\\n-  start_class(HotSpotReferenceMap, jdk_vm_ci_hotspot_HotSpotReferenceMap)                                     \\\n-    objectarray_field(HotSpotReferenceMap, objects, \"[Ljdk\/vm\/ci\/code\/Location;\")                             \\\n-    objectarray_field(HotSpotReferenceMap, derivedBase, \"[Ljdk\/vm\/ci\/code\/Location;\")                         \\\n-    primarray_field(HotSpotReferenceMap, sizeInBytes, \"[I\")                                                   \\\n-    int_field(HotSpotReferenceMap, maxRegisterSize)                                                           \\\n-  end_class                                                                                                   \\\n-  start_class(RegisterSaveLayout, jdk_vm_ci_code_RegisterSaveLayout)                                          \\\n-    objectarray_field(RegisterSaveLayout, registers, \"[Ljdk\/vm\/ci\/code\/Register;\")                            \\\n-    primarray_field(RegisterSaveLayout, slots, \"[I\")                                                          \\\n-  end_class                                                                                                   \\\n@@ -228,2 +134,0 @@\n-    objectarray_field(BytecodeFrame, values, \"[Ljdk\/vm\/ci\/meta\/JavaValue;\")                                   \\\n-    objectarray_field(BytecodeFrame, slotKinds, \"[Ljdk\/vm\/ci\/meta\/JavaKind;\")                                 \\\n@@ -233,2 +137,0 @@\n-    boolean_field(BytecodeFrame, rethrowException)                                                            \\\n-    boolean_field(BytecodeFrame, duringCall)                                                                  \\\n@@ -258,6 +160,0 @@\n-  start_class(RawConstant, jdk_vm_ci_meta_RawConstant)                                                        \\\n-  end_class                                                                                                   \\\n-  start_class(NullConstant, jdk_vm_ci_meta_NullConstant)                                                      \\\n-  end_class                                                                                                   \\\n-  start_class(HotSpotCompressedNullConstant, jdk_vm_ci_hotspot_HotSpotCompressedNullConstant)                 \\\n-  end_class                                                                                                   \\\n@@ -275,6 +171,0 @@\n-  start_class(HotSpotMetaspaceConstantImpl, jdk_vm_ci_hotspot_HotSpotMetaspaceConstantImpl)                   \\\n-    object_field(HotSpotMetaspaceConstantImpl, metaspaceObject, \"Ljdk\/vm\/ci\/hotspot\/MetaspaceObject;\")        \\\n-    boolean_field(HotSpotMetaspaceConstantImpl, compressed)                                                   \\\n-  end_class                                                                                                   \\\n-  start_class(HotSpotSentinelConstant, jdk_vm_ci_hotspot_HotSpotSentinelConstant)                             \\\n-  end_class                                                                                                   \\\n@@ -283,8 +173,0 @@\n-    static_object_field(JavaKind, Boolean, \"Ljdk\/vm\/ci\/meta\/JavaKind;\")                                       \\\n-    static_object_field(JavaKind, Byte, \"Ljdk\/vm\/ci\/meta\/JavaKind;\")                                          \\\n-    static_object_field(JavaKind, Char, \"Ljdk\/vm\/ci\/meta\/JavaKind;\")                                          \\\n-    static_object_field(JavaKind, Short, \"Ljdk\/vm\/ci\/meta\/JavaKind;\")                                         \\\n-    static_object_field(JavaKind, Int, \"Ljdk\/vm\/ci\/meta\/JavaKind;\")                                           \\\n-    static_object_field(JavaKind, Float, \"Ljdk\/vm\/ci\/meta\/JavaKind;\")                                         \\\n-    static_object_field(JavaKind, Long, \"Ljdk\/vm\/ci\/meta\/JavaKind;\")                                          \\\n-    static_object_field(JavaKind, Double, \"Ljdk\/vm\/ci\/meta\/JavaKind;\")                                        \\\n@@ -295,31 +177,0 @@\n-  start_class(Value, jdk_vm_ci_meta_Value)                                                                    \\\n-    object_field(Value, valueKind, \"Ljdk\/vm\/ci\/meta\/ValueKind;\")                                              \\\n-    static_object_field(Value, ILLEGAL, \"Ljdk\/vm\/ci\/meta\/AllocatableValue;\")                                  \\\n-  end_class                                                                                                   \\\n-  start_class(RegisterValue, jdk_vm_ci_code_RegisterValue)                                                    \\\n-    object_field(RegisterValue, reg, \"Ljdk\/vm\/ci\/code\/Register;\")                                             \\\n-  end_class                                                                                                   \\\n-  start_class(code_Location, jdk_vm_ci_code_Location)                                                         \\\n-    object_field(code_Location, reg, \"Ljdk\/vm\/ci\/code\/Register;\")                                             \\\n-    int_field(code_Location, offset)                                                                          \\\n-  end_class                                                                                                   \\\n-  start_class(code_Register, jdk_vm_ci_code_Register)                                                         \\\n-    int_field(code_Register, number)                                                                          \\\n-    int_field(code_Register, encoding)                                                                        \\\n-  end_class                                                                                                   \\\n-  start_class(StackSlot, jdk_vm_ci_code_StackSlot)                                                            \\\n-    int_field(StackSlot, offset)                                                                              \\\n-    boolean_field(StackSlot, addFrameSize)                                                                    \\\n-  end_class                                                                                                   \\\n-  start_class(VirtualObject, jdk_vm_ci_code_VirtualObject)                                                    \\\n-    int_field(VirtualObject, id)                                                                              \\\n-    boolean_field(VirtualObject, isAutoBox)                                                                   \\\n-    object_field(VirtualObject, type, \"Ljdk\/vm\/ci\/meta\/ResolvedJavaType;\")                                    \\\n-    objectarray_field(VirtualObject, values, \"[Ljdk\/vm\/ci\/meta\/JavaValue;\")                                   \\\n-    objectarray_field(VirtualObject, slotKinds, \"[Ljdk\/vm\/ci\/meta\/JavaKind;\")                                 \\\n-  end_class                                                                                                   \\\n-  start_class(StackLockValue, jdk_vm_ci_code_StackLockValue)                                                  \\\n-    object_field(StackLockValue, owner, \"Ljdk\/vm\/ci\/meta\/JavaValue;\")                                         \\\n-    object_field(StackLockValue, slot, \"Ljdk\/vm\/ci\/meta\/AllocatableValue;\")                                   \\\n-    boolean_field(StackLockValue, eliminated)                                                                 \\\n-  end_class                                                                                                   \\\n@@ -337,1 +188,1 @@\n-    long_field(HotSpotConstantPool, metadataHandle)                                                           \\\n+    long_field(HotSpotConstantPool, constantPoolHandle)                                                       \\\n@@ -520,1 +371,1 @@\n-    return *(Method**) HotSpotResolvedJavaMethodImpl::metadataHandle(env, jvmci_method);\n+    return *(Method**) HotSpotResolvedJavaMethodImpl::methodHandle(env, jvmci_method);\n@@ -523,4 +374,1 @@\n-    return *(ConstantPool**) HotSpotConstantPool::metadataHandle(env, jvmci_constant_pool);\n-  }\n-  static inline Klass* asKlass(JVMCIEnv* env, oop jvmci_type) {\n-    return (Klass*) HotSpotResolvedObjectTypeImpl::metadataPointer(env, jvmci_type);\n+    return *(ConstantPool**) HotSpotConstantPool::constantPoolHandle(env, jvmci_constant_pool);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.hpp","additions":6,"deletions":158,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"jvmci\/jvmciCodeInstaller.hpp\"\n@@ -1417,0 +1418,2 @@\n+    DEBUG_ONLY(CodeInstaller::verify_bci_constants(JVMCIENV);)\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -496,0 +496,64 @@\n+  declare_constant(CodeInstaller::ILLEGAL)                                \\\n+  declare_constant(CodeInstaller::REGISTER_PRIMITIVE)                     \\\n+  declare_constant(CodeInstaller::REGISTER_OOP)                           \\\n+  declare_constant(CodeInstaller::REGISTER_NARROW_OOP)                    \\\n+  declare_constant(CodeInstaller::STACK_SLOT_PRIMITIVE)                   \\\n+  declare_constant(CodeInstaller::STACK_SLOT_OOP)                         \\\n+  declare_constant(CodeInstaller::STACK_SLOT_NARROW_OOP)                  \\\n+  declare_constant(CodeInstaller::VIRTUAL_OBJECT_ID)                      \\\n+  declare_constant(CodeInstaller::VIRTUAL_OBJECT_ID2)                     \\\n+  declare_constant(CodeInstaller::NULL_CONSTANT)                          \\\n+  declare_constant(CodeInstaller::RAW_CONSTANT)                           \\\n+  declare_constant(CodeInstaller::PRIMITIVE_0)                            \\\n+  declare_constant(CodeInstaller::PRIMITIVE4)                             \\\n+  declare_constant(CodeInstaller::PRIMITIVE8)                             \\\n+  declare_constant(CodeInstaller::JOBJECT)                                \\\n+  declare_constant(CodeInstaller::OBJECT_ID)                              \\\n+  declare_constant(CodeInstaller::OBJECT_ID2)                             \\\n+                                                                          \\\n+  declare_constant(CodeInstaller::NO_FINALIZABLE_SUBCLASS)                \\\n+  declare_constant(CodeInstaller::CONCRETE_SUBTYPE)                       \\\n+  declare_constant(CodeInstaller::LEAF_TYPE)                              \\\n+  declare_constant(CodeInstaller::CONCRETE_METHOD)                        \\\n+  declare_constant(CodeInstaller::CALLSITE_TARGET_VALUE)                  \\\n+                                                                          \\\n+  declare_constant(CodeInstaller::PATCH_OBJECT_ID)                        \\\n+  declare_constant(CodeInstaller::PATCH_OBJECT_ID2)                       \\\n+  declare_constant(CodeInstaller::PATCH_NARROW_OBJECT_ID)                 \\\n+  declare_constant(CodeInstaller::PATCH_NARROW_OBJECT_ID2)                \\\n+  declare_constant(CodeInstaller::PATCH_JOBJECT)                          \\\n+  declare_constant(CodeInstaller::PATCH_NARROW_JOBJECT)                   \\\n+  declare_constant(CodeInstaller::PATCH_KLASS)                            \\\n+  declare_constant(CodeInstaller::PATCH_NARROW_KLASS)                     \\\n+  declare_constant(CodeInstaller::PATCH_METHOD)                           \\\n+  declare_constant(CodeInstaller::PATCH_DATA_SECTION_REFERENCE)           \\\n+                                                                          \\\n+  declare_constant(CodeInstaller::SITE_CALL)                              \\\n+  declare_constant(CodeInstaller::SITE_FOREIGN_CALL)                      \\\n+  declare_constant(CodeInstaller::SITE_FOREIGN_CALL_NO_DEBUG_INFO)        \\\n+  declare_constant(CodeInstaller::SITE_SAFEPOINT)                         \\\n+  declare_constant(CodeInstaller::SITE_INFOPOINT)                         \\\n+  declare_constant(CodeInstaller::SITE_IMPLICIT_EXCEPTION)                \\\n+  declare_constant(CodeInstaller::SITE_IMPLICIT_EXCEPTION_DISPATCH)       \\\n+  declare_constant(CodeInstaller::SITE_MARK)                              \\\n+  declare_constant(CodeInstaller::SITE_DATA_PATCH)                        \\\n+  declare_constant(CodeInstaller::SITE_EXCEPTION_HANDLER)                 \\\n+                                                                          \\\n+  declare_constant(CodeInstaller::DI_HAS_REFERENCE_MAP)                   \\\n+  declare_constant(CodeInstaller::DI_HAS_CALLEE_SAVE_INFO)                \\\n+  declare_constant(CodeInstaller::DI_HAS_FRAMES)                          \\\n+                                                                          \\\n+  declare_constant(CodeInstaller::DIF_HAS_LOCALS)                         \\\n+  declare_constant(CodeInstaller::DIF_HAS_STACK)                          \\\n+  declare_constant(CodeInstaller::DIF_HAS_LOCKS)                          \\\n+  declare_constant(CodeInstaller::DIF_DURING_CALL)                        \\\n+  declare_constant(CodeInstaller::DIF_RETHROW_EXCEPTION)                  \\\n+                                                                          \\\n+  declare_constant(CodeInstaller::HCC_IS_NMETHOD)                         \\\n+  declare_constant(CodeInstaller::HCC_HAS_ASSUMPTIONS)                    \\\n+  declare_constant(CodeInstaller::HCC_HAS_METHODS)                        \\\n+  declare_constant(CodeInstaller::HCC_HAS_DEOPT_RESCUE_SLOT)              \\\n+  declare_constant(CodeInstaller::HCC_HAS_COMMENTS)                       \\\n+                                                                          \\\n+  declare_constant(CodeInstaller::NO_REGISTER)                            \\\n+                                                                          \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":64,"deletions":0,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-  template(jdk_vm_ci_hotspot_HotSpotCompiledCode_Comment,         \"jdk\/vm\/ci\/hotspot\/HotSpotCompiledCode$Comment\")                        \\\n@@ -37,2 +36,0 @@\n-  template(jdk_vm_ci_hotspot_HotSpotForeignCallTarget,            \"jdk\/vm\/ci\/hotspot\/HotSpotForeignCallTarget\")                           \\\n-  template(jdk_vm_ci_hotspot_HotSpotReferenceMap,                 \"jdk\/vm\/ci\/hotspot\/HotSpotReferenceMap\")                                \\\n@@ -50,2 +47,0 @@\n-  template(jdk_vm_ci_hotspot_HotSpotMetaspaceConstantImpl,        \"jdk\/vm\/ci\/hotspot\/HotSpotMetaspaceConstantImpl\")                       \\\n-  template(jdk_vm_ci_hotspot_HotSpotSentinelConstant,             \"jdk\/vm\/ci\/hotspot\/HotSpotSentinelConstant\")                            \\\n@@ -77,1 +72,0 @@\n-  template(jdk_vm_ci_code_DebugInfo,                              \"jdk\/vm\/ci\/code\/DebugInfo\")                                             \\\n@@ -79,8 +73,0 @@\n-  template(jdk_vm_ci_code_Location,                               \"jdk\/vm\/ci\/code\/Location\")                                              \\\n-  template(jdk_vm_ci_code_Register,                               \"jdk\/vm\/ci\/code\/Register\")                                              \\\n-  template(jdk_vm_ci_code_RegisterValue,                          \"jdk\/vm\/ci\/code\/RegisterValue\")                                         \\\n-  template(jdk_vm_ci_code_StackSlot,                              \"jdk\/vm\/ci\/code\/StackSlot\")                                             \\\n-  template(jdk_vm_ci_code_StackLockValue,                         \"jdk\/vm\/ci\/code\/StackLockValue\")                                        \\\n-  template(jdk_vm_ci_code_TargetDescription,                      \"jdk\/vm\/ci\/code\/TargetDescription\")                                     \\\n-  template(jdk_vm_ci_code_VirtualObject,                          \"jdk\/vm\/ci\/code\/VirtualObject\")                                         \\\n-  template(jdk_vm_ci_code_RegisterSaveLayout,                     \"jdk\/vm\/ci\/code\/RegisterSaveLayout\")                                    \\\n@@ -88,8 +74,0 @@\n-  template(jdk_vm_ci_code_site_Call,                              \"jdk\/vm\/ci\/code\/site\/Call\")                                             \\\n-  template(jdk_vm_ci_code_site_ConstantReference,                 \"jdk\/vm\/ci\/code\/site\/ConstantReference\")                                \\\n-  template(jdk_vm_ci_code_site_DataPatch,                         \"jdk\/vm\/ci\/code\/site\/DataPatch\")                                        \\\n-  template(jdk_vm_ci_code_site_DataSectionReference,              \"jdk\/vm\/ci\/code\/site\/DataSectionReference\")                             \\\n-  template(jdk_vm_ci_code_site_ExceptionHandler,                  \"jdk\/vm\/ci\/code\/site\/ExceptionHandler\")                                 \\\n-  template(jdk_vm_ci_code_site_Mark,                              \"jdk\/vm\/ci\/code\/site\/Mark\")                                             \\\n-  template(jdk_vm_ci_code_site_ImplicitExceptionDispatch,         \"jdk\/vm\/ci\/code\/site\/ImplicitExceptionDispatch\")                        \\\n-  template(jdk_vm_ci_code_site_Infopoint,                         \"jdk\/vm\/ci\/code\/site\/Infopoint\")                                        \\\n@@ -97,2 +75,0 @@\n-  template(jdk_vm_ci_code_site_Site,                              \"jdk\/vm\/ci\/code\/site\/Site\")                                             \\\n-  template(jdk_vm_ci_code_site_InfopointReason,                   \"jdk\/vm\/ci\/code\/site\/InfopointReason\")                                  \\\n@@ -112,1 +88,1 @@\n-  template(klass_fromMetaspace_signature,                         \"(JLjava\/lang\/String;)Ljdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl;\") \\\n+  template(klass_fromMetaspace_signature,                         \"(J)Ljdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl;\")                 \\\n@@ -128,1 +104,1 @@\n-  template(forPrimitive_signature,                                \"(Ljdk\/vm\/ci\/meta\/JavaKind;J)Ljdk\/vm\/ci\/meta\/PrimitiveConstant;\")       \\\n+  template(forPrimitive_signature,                                \"(CJ)Ljdk\/vm\/ci\/meta\/PrimitiveConstant;\")                               \\\n","filename":"src\/hotspot\/share\/jvmci\/vmSymbols_jvmci.hpp","additions":2,"deletions":26,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -55,0 +55,5 @@\n+void elapsedTimer::add_nanoseconds(jlong ns) {\n+  jlong freq = os::elapsed_frequency() \/ NANOUNITS;\n+  _counter += ns * freq;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/timer.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+  void add_nanoseconds(jlong ns);\n","filename":"src\/hotspot\/share\/runtime\/timer.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -284,1 +284,1 @@\n-void outputStream::print_data(void* data, size_t len, bool with_ascii) {\n+void outputStream::print_data(void* data, size_t len, bool with_ascii, bool rel_addr) {\n@@ -288,1 +288,5 @@\n-      indent().print(INTPTR_FORMAT_W(07) \":\", i);\n+      if (rel_addr) {\n+        indent().print(INTPTR_FORMAT_W(07) \":\", i);\n+      } else {\n+        indent().print(INTPTR_FORMAT \":\", p2i((unsigned char*)data + i));\n+      }\n","filename":"src\/hotspot\/share\/utilities\/ostream.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-   void print_data(void* data, size_t len, bool with_ascii);\n+   void print_data(void* data, size_t len, bool with_ascii, bool rel_addr=true);\n","filename":"src\/hotspot\/share\/utilities\/ostream.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.vm.ci.common.JVMCIError;\n@@ -179,1 +180,15 @@\n-     * Creates a new frame object.\n+     * Creates a new frame object. A well formed frame has the following invariants:\n+     * <ul>\n+     * <li>{@code values != null}<\/li>\n+     * <li>{@code slotKinds != null}<\/li>\n+     * <li>{@code numLocals + numStack + numLocks == values.length}<\/li>\n+     * <li>{@code numLocals + numStack + numLocks == values.length}<\/li>\n+     * <li>{@code numLocals + numStack == slotKinds.length}<\/li>\n+     * <li>all entries in {@code values} starting at index {@code numLocals + numStack} must be of\n+     * type {@link StackLockValue}<\/li>\n+     * <li>for each index {@code i} between 0 (inclusive) and {@code numLocals + numStack}\n+     * (exclusive), if {@code slotKinds[i].needsTwoSlots()} then\n+     * {@code values[i + 1] == Value.ILLEGAL}.<\/li>\n+     * <\/ul>\n+     *\n+     * These invariants are not checked in this constructor but by {@link #verifyInvariants()}.\n@@ -186,1 +201,1 @@\n-     * @param values the frame state {@link #values}.\n+     * @param values the frame state {@link #values}\n@@ -194,1 +209,9 @@\n-    public BytecodeFrame(BytecodeFrame caller, ResolvedJavaMethod method, int bci, boolean rethrowException, boolean duringCall, JavaValue[] values, JavaKind[] slotKinds, int numLocals, int numStack,\n+    public BytecodeFrame(BytecodeFrame caller,\n+                    ResolvedJavaMethod method,\n+                    int bci,\n+                    boolean rethrowException,\n+                    boolean duringCall,\n+                    JavaValue[] values,\n+                    JavaKind[] slotKinds,\n+                    int numLocals,\n+                    int numStack,\n@@ -208,0 +231,32 @@\n+    \/**\n+     * Checks the invariants described in {@link #BytecodeFrame}.\n+     *\n+     * @throws NullPointerException if {@code values == null || slotKinds == null} or any of the\n+     *             entries in {@code values} is null\n+     * @throws JVMCIError if any of the other invariants are violated\n+     *\/\n+    public void verifyInvariants() {\n+        if (values.length != numLocals + numStack + numLocks) {\n+            throw new JVMCIError(\"unexpected values length %d in frame (%d locals, %d stack slots, %d locks)\", values.length, numLocals, numStack, numLocks);\n+        }\n+        if (slotKinds.length != numLocals + numStack) {\n+            throw new JVMCIError(\"unexpected slotKinds length %d in frame (%d locals, %d stack slots)\", values.length, numLocals, numStack);\n+        }\n+        for (int i = 0; i < slotKinds.length; i++) {\n+            Objects.requireNonNull(values[i]);\n+            JavaKind kind = slotKinds[i];\n+            if (kind.needsTwoSlots()) {\n+                if (i + 1 >= values.length || values[i + 1] != Value.ILLEGAL) {\n+                    throw new JVMCIError(\"2 slot value at index %d not followed by Value.ILLEGAL\", i);\n+                }\n+            }\n+        }\n+        for (int i = slotKinds.length; i < values.length; i++) {\n+            JavaValue lock = values[i];\n+            Objects.requireNonNull(lock);\n+            if (!(lock instanceof StackLockValue)) {\n+                throw new JVMCIError(\"Lock at %d must be of type StackLockValue, got %s\", i, lock.getClass().getName());\n+            }\n+        }\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.code\/src\/jdk\/vm\/ci\/code\/BytecodeFrame.java","additions":58,"deletions":3,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -62,0 +62,7 @@\n+    \/**\n+     * Gets the number of entries in this map.\n+     *\/\n+    public int size() {\n+        return registers.length;\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.code\/src\/jdk\/vm\/ci\/code\/RegisterSaveLayout.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-    public Value getSlot() {\n+    public AllocatableValue getSlot() {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.code\/src\/jdk\/vm\/ci\/code\/StackLockValue.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+        assert reason != InfopointReason.CALL || this instanceof Call : getClass();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.code\/src\/jdk\/vm\/ci\/code\/site\/Infopoint.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.vm.ci.code.TargetDescription;\n@@ -39,0 +38,1 @@\n+import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.Option;\n@@ -87,18 +87,18 @@\n-            ARRAY_BOOLEAN_BASE_OFFSET = arrayBaseOffset(JavaKind.Boolean);\n-            ARRAY_BYTE_BASE_OFFSET = arrayBaseOffset(JavaKind.Byte);\n-            ARRAY_SHORT_BASE_OFFSET = arrayBaseOffset(JavaKind.Short);\n-            ARRAY_CHAR_BASE_OFFSET = arrayBaseOffset(JavaKind.Char);\n-            ARRAY_INT_BASE_OFFSET = arrayBaseOffset(JavaKind.Int);\n-            ARRAY_LONG_BASE_OFFSET = arrayBaseOffset(JavaKind.Long);\n-            ARRAY_FLOAT_BASE_OFFSET = arrayBaseOffset(JavaKind.Float);\n-            ARRAY_DOUBLE_BASE_OFFSET = arrayBaseOffset(JavaKind.Double);\n-            ARRAY_OBJECT_BASE_OFFSET = arrayBaseOffset(JavaKind.Object);\n-            ARRAY_BOOLEAN_INDEX_SCALE = arrayIndexScale(JavaKind.Boolean);\n-            ARRAY_BYTE_INDEX_SCALE = arrayIndexScale(JavaKind.Byte);\n-            ARRAY_SHORT_INDEX_SCALE = arrayIndexScale(JavaKind.Short);\n-            ARRAY_CHAR_INDEX_SCALE = arrayIndexScale(JavaKind.Char);\n-            ARRAY_INT_INDEX_SCALE = arrayIndexScale(JavaKind.Int);\n-            ARRAY_LONG_INDEX_SCALE = arrayIndexScale(JavaKind.Long);\n-            ARRAY_FLOAT_INDEX_SCALE = arrayIndexScale(JavaKind.Float);\n-            ARRAY_DOUBLE_INDEX_SCALE = arrayIndexScale(JavaKind.Double);\n-            ARRAY_OBJECT_INDEX_SCALE = arrayIndexScale(JavaKind.Object);\n+            ARRAY_BOOLEAN_BASE_OFFSET = arrayBaseOffset(JavaKind.Boolean.getTypeChar());\n+            ARRAY_BYTE_BASE_OFFSET = arrayBaseOffset(JavaKind.Byte.getTypeChar());\n+            ARRAY_SHORT_BASE_OFFSET = arrayBaseOffset(JavaKind.Short.getTypeChar());\n+            ARRAY_CHAR_BASE_OFFSET = arrayBaseOffset(JavaKind.Char.getTypeChar());\n+            ARRAY_INT_BASE_OFFSET = arrayBaseOffset(JavaKind.Int.getTypeChar());\n+            ARRAY_LONG_BASE_OFFSET = arrayBaseOffset(JavaKind.Long.getTypeChar());\n+            ARRAY_FLOAT_BASE_OFFSET = arrayBaseOffset(JavaKind.Float.getTypeChar());\n+            ARRAY_DOUBLE_BASE_OFFSET = arrayBaseOffset(JavaKind.Double.getTypeChar());\n+            ARRAY_OBJECT_BASE_OFFSET = arrayBaseOffset(JavaKind.Object.getTypeChar());\n+            ARRAY_BOOLEAN_INDEX_SCALE = arrayIndexScale(JavaKind.Boolean.getTypeChar());\n+            ARRAY_BYTE_INDEX_SCALE = arrayIndexScale(JavaKind.Byte.getTypeChar());\n+            ARRAY_SHORT_INDEX_SCALE = arrayIndexScale(JavaKind.Short.getTypeChar());\n+            ARRAY_CHAR_INDEX_SCALE = arrayIndexScale(JavaKind.Char.getTypeChar());\n+            ARRAY_INT_INDEX_SCALE = arrayIndexScale(JavaKind.Int.getTypeChar());\n+            ARRAY_LONG_INDEX_SCALE = arrayIndexScale(JavaKind.Long.getTypeChar());\n+            ARRAY_FLOAT_INDEX_SCALE = arrayIndexScale(JavaKind.Float.getTypeChar());\n+            ARRAY_DOUBLE_INDEX_SCALE = arrayIndexScale(JavaKind.Double.getTypeChar());\n+            ARRAY_OBJECT_INDEX_SCALE = arrayIndexScale(JavaKind.Object.getTypeChar());\n@@ -108,1 +108,1 @@\n-    native int arrayBaseOffset(JavaKind kind);\n+    native int arrayBaseOffset(char typeChar);\n@@ -110,1 +110,1 @@\n-    native int arrayIndexScale(JavaKind kind);\n+    native int arrayIndexScale(char typeChar);\n@@ -125,1 +125,5 @@\n-    native byte[] getBytecode(HotSpotResolvedJavaMethodImpl method);\n+    byte[] getBytecode(HotSpotResolvedJavaMethodImpl method) {\n+        return getBytecode(method, method.getMethodPointer());\n+    }\n+\n+    private native byte[] getBytecode(HotSpotResolvedJavaMethodImpl method, long methodPointer);\n@@ -131,1 +135,5 @@\n-    native int getExceptionTableLength(HotSpotResolvedJavaMethodImpl method);\n+    int getExceptionTableLength(HotSpotResolvedJavaMethodImpl method) {\n+        return getExceptionTableLength(method, method.getMethodPointer());\n+    }\n+\n+    private native int getExceptionTableLength(HotSpotResolvedJavaMethodImpl method, long methodPointer);\n@@ -149,1 +157,5 @@\n-    native long getExceptionTableStart(HotSpotResolvedJavaMethodImpl method);\n+    long getExceptionTableStart(HotSpotResolvedJavaMethodImpl method) {\n+        return getExceptionTableStart(method, method.getMethodPointer());\n+    }\n+\n+    private native long getExceptionTableStart(HotSpotResolvedJavaMethodImpl method, long methodPointer);\n@@ -157,1 +169,5 @@\n-    native boolean isCompilable(HotSpotResolvedJavaMethodImpl method);\n+    boolean isCompilable(HotSpotResolvedJavaMethodImpl method) {\n+        return isCompilable(method, method.getMethodPointer());\n+    }\n+\n+    private native boolean isCompilable(HotSpotResolvedJavaMethodImpl method, long methodPointer);\n@@ -164,1 +180,5 @@\n-    native boolean hasNeverInlineDirective(HotSpotResolvedJavaMethodImpl method);\n+    boolean hasNeverInlineDirective(HotSpotResolvedJavaMethodImpl method) {\n+        return hasNeverInlineDirective(method, method.getMethodPointer());\n+    }\n+\n+    private native boolean hasNeverInlineDirective(HotSpotResolvedJavaMethodImpl method, long methodPointer);\n@@ -173,1 +193,5 @@\n-    native boolean shouldInlineMethod(HotSpotResolvedJavaMethodImpl method);\n+    boolean shouldInlineMethod(HotSpotResolvedJavaMethodImpl method) {\n+        return shouldInlineMethod(method, method.getMethodPointer());\n+    }\n+\n+    private native boolean shouldInlineMethod(HotSpotResolvedJavaMethodImpl method, long methodPointer);\n@@ -178,1 +202,0 @@\n-     * @param method the method on which to base the search\n@@ -180,0 +203,1 @@\n+     * @param method the method on which to base the search\n@@ -182,1 +206,5 @@\n-    native HotSpotResolvedJavaMethodImpl findUniqueConcreteMethod(HotSpotResolvedObjectTypeImpl actualHolderType, HotSpotResolvedJavaMethodImpl method);\n+    HotSpotResolvedJavaMethodImpl findUniqueConcreteMethod(HotSpotResolvedObjectTypeImpl actualHolderType, HotSpotResolvedJavaMethodImpl method) {\n+        return findUniqueConcreteMethod(actualHolderType, actualHolderType.getKlassPointer(), method, method.getMetaspacePointer());\n+    }\n+\n+    private native HotSpotResolvedJavaMethodImpl findUniqueConcreteMethod(HotSpotResolvedObjectTypeImpl klass, long klassPointer, HotSpotResolvedJavaMethodImpl method, long methodPointer);\n@@ -191,1 +219,5 @@\n-    native HotSpotResolvedObjectTypeImpl getImplementor(HotSpotResolvedObjectTypeImpl type);\n+    HotSpotResolvedObjectTypeImpl getImplementor(HotSpotResolvedObjectTypeImpl type) {\n+        return getImplementor(type, type.getKlassPointer());\n+    }\n+\n+    private native HotSpotResolvedObjectTypeImpl getImplementor(HotSpotResolvedObjectTypeImpl type, long klassPointer);\n@@ -196,1 +228,5 @@\n-    native boolean methodIsIgnoredBySecurityStackWalk(HotSpotResolvedJavaMethodImpl method);\n+    boolean methodIsIgnoredBySecurityStackWalk(HotSpotResolvedJavaMethodImpl method) {\n+        return methodIsIgnoredBySecurityStackWalk(method, method.getMetaspacePointer());\n+    }\n+\n+    private native boolean methodIsIgnoredBySecurityStackWalk(HotSpotResolvedJavaMethodImpl method, long methodPointer);\n@@ -203,1 +239,2 @@\n-     *            class should be resolved with the class loader.\n+     *            class should be resolved with the {@linkplain ClassLoader#getSystemClassLoader()\n+     *            system class loader}.\n@@ -209,1 +246,5 @@\n-    native HotSpotResolvedJavaType lookupType(String name, HotSpotResolvedObjectTypeImpl accessingClass, boolean resolve) throws ClassNotFoundException;\n+    HotSpotResolvedJavaType lookupType(String name, HotSpotResolvedObjectTypeImpl accessingClass, boolean resolve) throws ClassNotFoundException {\n+        return lookupType(name, accessingClass, accessingClass != null ? accessingClass.getKlassPointer() : 0L, resolve);\n+    }\n+\n+    private native HotSpotResolvedJavaType lookupType(String name, HotSpotResolvedObjectTypeImpl accessingClass, long klassPointer, boolean resolve) throws ClassNotFoundException;\n@@ -222,1 +263,5 @@\n-    native JavaConstant resolvePossiblyCachedConstantInPool(HotSpotConstantPool constantPool, int cpi);\n+    JavaConstant resolvePossiblyCachedConstantInPool(HotSpotConstantPool constantPool, int cpi) {\n+        return resolvePossiblyCachedConstantInPool(constantPool, constantPool.getConstantPoolPointer(), cpi);\n+    }\n+\n+    private native JavaConstant resolvePossiblyCachedConstantInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int cpi);\n@@ -231,1 +276,5 @@\n-    native int lookupNameAndTypeRefIndexInPool(HotSpotConstantPool constantPool, int cpi);\n+    int lookupNameAndTypeRefIndexInPool(HotSpotConstantPool constantPool, int cpi) {\n+        return lookupNameAndTypeRefIndexInPool(constantPool, constantPool.getConstantPoolPointer(), cpi);\n+    }\n+\n+    private native int lookupNameAndTypeRefIndexInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int cpi);\n@@ -240,1 +289,5 @@\n-    native String lookupNameInPool(HotSpotConstantPool constantPool, int which);\n+    String lookupNameInPool(HotSpotConstantPool constantPool, int which) {\n+        return lookupNameInPool(constantPool, constantPool.getConstantPoolPointer(), which);\n+    }\n+\n+    private native String lookupNameInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int which);\n@@ -249,1 +302,5 @@\n-    native String lookupSignatureInPool(HotSpotConstantPool constantPool, int which);\n+    String lookupSignatureInPool(HotSpotConstantPool constantPool, int which) {\n+        return lookupSignatureInPool(constantPool, constantPool.getConstantPoolPointer(), which);\n+    }\n+\n+    private native String lookupSignatureInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int which);\n@@ -258,1 +315,5 @@\n-    native int lookupKlassRefIndexInPool(HotSpotConstantPool constantPool, int cpi);\n+    int lookupKlassRefIndexInPool(HotSpotConstantPool constantPool, int cpi) {\n+        return lookupKlassRefIndexInPool(constantPool, constantPool.getConstantPoolPointer(), cpi);\n+    }\n+\n+    private native int lookupKlassRefIndexInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int cpi);\n@@ -269,1 +330,5 @@\n-    native Object lookupKlassInPool(HotSpotConstantPool constantPool, int cpi);\n+    Object lookupKlassInPool(HotSpotConstantPool constantPool, int cpi) {\n+        return lookupKlassInPool(constantPool, constantPool.getConstantPoolPointer(), cpi);\n+    }\n+\n+    private native Object lookupKlassInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int cpi);\n@@ -284,1 +349,5 @@\n-    native HotSpotResolvedJavaMethodImpl lookupMethodInPool(HotSpotConstantPool constantPool, int cpi, byte opcode);\n+    HotSpotResolvedJavaMethodImpl lookupMethodInPool(HotSpotConstantPool constantPool, int cpi, byte opcode) {\n+        return lookupMethodInPool(constantPool, constantPool.getConstantPoolPointer(), cpi, opcode);\n+    }\n+\n+    private native HotSpotResolvedJavaMethodImpl lookupMethodInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int cpi, byte opcode);\n@@ -293,1 +362,5 @@\n-    native void resolveInvokeDynamicInPool(HotSpotConstantPool constantPool, int cpi);\n+    void resolveInvokeDynamicInPool(HotSpotConstantPool constantPool, int cpi) {\n+        resolveInvokeDynamicInPool(constantPool, constantPool.getConstantPoolPointer(), cpi);\n+    }\n+\n+    private native void resolveInvokeDynamicInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int cpi);\n@@ -317,1 +390,5 @@\n-    native Object[] resolveBootstrapMethod(HotSpotConstantPool constantPool, int cpi);\n+    Object[] resolveBootstrapMethod(HotSpotConstantPool constantPool, int cpi) {\n+        return resolveBootstrapMethod(constantPool, constantPool.getConstantPoolPointer(), cpi);\n+    }\n+\n+    private native Object[] resolveBootstrapMethod(HotSpotConstantPool constantPool, long constantPoolPointer, int cpi);\n@@ -324,1 +401,5 @@\n-    native void resolveInvokeHandleInPool(HotSpotConstantPool constantPool, int cpi);\n+    void resolveInvokeHandleInPool(HotSpotConstantPool constantPool, int cpi) {\n+        resolveInvokeHandleInPool(constantPool, constantPool.getConstantPoolPointer(), cpi);\n+    }\n+\n+    private native void resolveInvokeHandleInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int cpi);\n@@ -332,1 +413,5 @@\n-    native int isResolvedInvokeHandleInPool(HotSpotConstantPool constantPool, int cpi);\n+    int isResolvedInvokeHandleInPool(HotSpotConstantPool constantPool, int cpi) {\n+        return isResolvedInvokeHandleInPool(constantPool, constantPool.getConstantPoolPointer(), cpi);\n+    }\n+\n+    private native int isResolvedInvokeHandleInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int cpi);\n@@ -348,1 +433,5 @@\n-    native HotSpotResolvedObjectTypeImpl resolveTypeInPool(HotSpotConstantPool constantPool, int cpi) throws LinkageError;\n+    HotSpotResolvedObjectTypeImpl resolveTypeInPool(HotSpotConstantPool constantPool, int cpi) throws LinkageError {\n+        return resolveTypeInPool(constantPool, constantPool.getConstantPoolPointer(), cpi);\n+    }\n+\n+    private native HotSpotResolvedObjectTypeImpl resolveTypeInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int cpi) throws LinkageError;\n@@ -367,1 +456,1 @@\n-     * @return the type defining the field if resolution is successful, 0 otherwise\n+     * @return the type defining the field if resolution is successful, null otherwise\n@@ -369,1 +458,7 @@\n-    native HotSpotResolvedObjectTypeImpl resolveFieldInPool(HotSpotConstantPool constantPool, int cpi, HotSpotResolvedJavaMethodImpl method, byte opcode, int[] info);\n+    HotSpotResolvedObjectTypeImpl resolveFieldInPool(HotSpotConstantPool constantPool, int cpi, HotSpotResolvedJavaMethodImpl method, byte opcode, int[] info) {\n+        long methodPointer = method != null ? method.getMethodPointer() : 0L;\n+        return resolveFieldInPool(constantPool, constantPool.getConstantPoolPointer(), cpi, method, methodPointer, opcode, info);\n+    }\n+\n+    private native HotSpotResolvedObjectTypeImpl resolveFieldInPool(HotSpotConstantPool constantPool, long constantPoolPointer,\n+                    int cpi, HotSpotResolvedJavaMethodImpl method, long methodPointer, byte opcode, int[] info);\n@@ -375,1 +470,1 @@\n-     * The behavior of this method is undefined if {@code ccpi} is an invalid constant pool cache\n+     * The behavior of this method is undefined if {@code cpci} is an invalid constant pool cache\n@@ -378,1 +473,5 @@\n-    native int constantPoolRemapInstructionOperandFromCache(HotSpotConstantPool constantPool, int cpci);\n+    int constantPoolRemapInstructionOperandFromCache(HotSpotConstantPool constantPool, int cpci) {\n+        return constantPoolRemapInstructionOperandFromCache(constantPool, constantPool.getConstantPoolPointer(), cpci);\n+    }\n+\n+    private native int constantPoolRemapInstructionOperandFromCache(HotSpotConstantPool constantPool, long constantPoolPointer, int cpci);\n@@ -384,1 +483,5 @@\n-    native HotSpotObjectConstantImpl lookupAppendixInPool(HotSpotConstantPool constantPool, int cpi);\n+    HotSpotObjectConstantImpl lookupAppendixInPool(HotSpotConstantPool constantPool, int cpi) {\n+        return lookupAppendixInPool(constantPool, constantPool.getConstantPoolPointer(), cpi);\n+    }\n+\n+    private native HotSpotObjectConstantImpl lookupAppendixInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int cpi);\n@@ -389,1 +492,0 @@\n-     * @param target the target where this code should be installed\n@@ -392,0 +494,1 @@\n+     *\n@@ -400,1 +503,37 @@\n-    native int installCode(TargetDescription target, HotSpotCompiledCode compiledCode, InstalledCode code, long failedSpeculationsAddress, byte[] speculations);\n+     int installCode(HotSpotCompiledCode compiledCode, InstalledCode code, long failedSpeculationsAddress, byte[] speculations) {\n+         int codeInstallFlags = getInstallCodeFlags();\n+         boolean withComments = (codeInstallFlags & 0x0001) != 0;\n+         boolean withMethods = (codeInstallFlags & 0x0002) != 0;\n+         boolean withTypeInfo;\n+         if ((codeInstallFlags & 0x0004) != 0 && HotSpotJVMCIRuntime.Option.CodeSerializationTypeInfo.isDefault) {\n+             withTypeInfo = true;\n+         } else {\n+             withTypeInfo = HotSpotJVMCIRuntime.Option.CodeSerializationTypeInfo.getBoolean();\n+         }\n+         try (HotSpotCompiledCodeStream stream = new HotSpotCompiledCodeStream(compiledCode, withTypeInfo, withComments, withMethods)) {\n+             return installCode0(stream.headChunk, stream.timeNS, withTypeInfo, compiledCode, stream.objectPool, code, failedSpeculationsAddress, speculations);\n+         }\n+     }\n+\n+     native int installCode0(long compiledCodeBuffer,\n+                     long serializationNS,\n+                     boolean withTypeInfo,\n+                     HotSpotCompiledCode compiledCode,\n+                     Object[] objectPool,\n+                     InstalledCode code,\n+                     long failedSpeculationsAddress,\n+                     byte[] speculations);\n+\n+    \/**\n+     * Gets flags specifying optional parts of code info. Only if a flag is set, will the\n+     * corresponding code info being included in the {@linkplain HotSpotCompiledCodeStream\n+     * serialized code stream}.\n+     *\n+     * <ul>\n+     * <li>0x0001: code comments ({@link HotSpotCompiledCode#comments})<\/li>\n+     * <li>0x0002: methods ({@link HotSpotCompiledCode#methods})<\/li>\n+     * <li>0x0004: enable {@link Option#CodeSerializationTypeInfo} if it not explicitly specified\n+     * (i.e., {@link Option#isDefault} is {@code true})<\/li>\n+     * <\/ul>\n+     *\/\n+    private native int getInstallCodeFlags();\n@@ -431,0 +570,1 @@\n+     * @param exactReceiver the exact receiver type\n@@ -435,1 +575,7 @@\n-    native HotSpotResolvedJavaMethodImpl resolveMethod(HotSpotResolvedObjectTypeImpl exactReceiver, HotSpotResolvedJavaMethodImpl method, HotSpotResolvedObjectTypeImpl caller);\n+    HotSpotResolvedJavaMethodImpl resolveMethod(HotSpotResolvedObjectTypeImpl exactReceiver, HotSpotResolvedJavaMethodImpl method, HotSpotResolvedObjectTypeImpl caller) {\n+        return resolveMethod(exactReceiver, exactReceiver.getKlassPointer(), method, method.getMethodPointer(), caller, caller.getKlassPointer());\n+    }\n+\n+    private native HotSpotResolvedJavaMethodImpl resolveMethod(HotSpotResolvedObjectTypeImpl exactReceiver, long exactReceiverKlass,\n+                    HotSpotResolvedJavaMethodImpl method, long methodPointer,\n+                    HotSpotResolvedObjectTypeImpl caller, long callerKlass);\n@@ -442,1 +588,5 @@\n-    native HotSpotResolvedJavaMethodImpl getClassInitializer(HotSpotResolvedObjectTypeImpl type);\n+    HotSpotResolvedJavaMethodImpl getClassInitializer(HotSpotResolvedObjectTypeImpl type) {\n+        return getClassInitializer(type, type.getKlassPointer());\n+    }\n+\n+    private native HotSpotResolvedJavaMethodImpl getClassInitializer(HotSpotResolvedObjectTypeImpl type, long klassPointer);\n@@ -448,1 +598,5 @@\n-    native boolean hasFinalizableSubclass(HotSpotResolvedObjectTypeImpl type);\n+    boolean hasFinalizableSubclass(HotSpotResolvedObjectTypeImpl type) {\n+        return hasFinalizableSubclass(type, type.getKlassPointer());\n+    }\n+\n+    private native boolean hasFinalizableSubclass(HotSpotResolvedObjectTypeImpl type, long klassPointer);\n@@ -476,1 +630,5 @@\n-    native StackTraceElement getStackTraceElement(HotSpotResolvedJavaMethodImpl method, int bci);\n+    StackTraceElement getStackTraceElement(HotSpotResolvedJavaMethodImpl method, int bci) {\n+        return getStackTraceElement(method, method.getMethodPointer(), bci);\n+    }\n+\n+    private native StackTraceElement getStackTraceElement(HotSpotResolvedJavaMethodImpl method, long methodPointer, int bci);\n@@ -492,1 +650,5 @@\n-    native long[] getLineNumberTable(HotSpotResolvedJavaMethodImpl method);\n+    long[] getLineNumberTable(HotSpotResolvedJavaMethodImpl method) {\n+        return getLineNumberTable(method, method.getMethodPointer());\n+    }\n+\n+    private native long[] getLineNumberTable(HotSpotResolvedJavaMethodImpl method, long methodPointer);\n@@ -499,1 +661,5 @@\n-    native int getLocalVariableTableLength(HotSpotResolvedJavaMethodImpl method);\n+    int getLocalVariableTableLength(HotSpotResolvedJavaMethodImpl method) {\n+        return getLocalVariableTableLength(method, method.getMethodPointer());\n+    }\n+\n+    private native int getLocalVariableTableLength(HotSpotResolvedJavaMethodImpl method, long methodPointer);\n@@ -517,1 +683,5 @@\n-    native long getLocalVariableTableStart(HotSpotResolvedJavaMethodImpl method);\n+    long getLocalVariableTableStart(HotSpotResolvedJavaMethodImpl method) {\n+        return getLocalVariableTableStart(method, method.getMetaspacePointer());\n+    }\n+\n+    private native long getLocalVariableTableStart(HotSpotResolvedJavaMethodImpl method, long methodPointer);\n@@ -523,1 +693,5 @@\n-    native void setNotInlinableOrCompilable(HotSpotResolvedJavaMethodImpl method);\n+    void setNotInlinableOrCompilable(HotSpotResolvedJavaMethodImpl method) {\n+        setNotInlinableOrCompilable(method, method.getMethodPointer());\n+    }\n+\n+    private native void setNotInlinableOrCompilable(HotSpotResolvedJavaMethodImpl method, long methodPointer);\n@@ -529,1 +703,5 @@\n-    native void reprofile(HotSpotResolvedJavaMethodImpl method);\n+    void reprofile(HotSpotResolvedJavaMethodImpl method) {\n+        reprofile(method, method.getMethodPointer());\n+    }\n+\n+    private native void reprofile(HotSpotResolvedJavaMethodImpl method, long methodPointer);\n@@ -557,1 +735,3 @@\n-     * Determines if {@code metaspaceMethodData} is mature.\n+     * Determines if {@code methodData} is mature.\n+     *\n+     * @param methodData a {@code MethodData*} value\n@@ -559,1 +739,1 @@\n-    native boolean isMature(long metaspaceMethodData);\n+    native boolean isMature(long methodData);\n@@ -564,1 +744,5 @@\n-    native int allocateCompileId(HotSpotResolvedJavaMethodImpl method, int entryBCI);\n+    int allocateCompileId(HotSpotResolvedJavaMethodImpl method, int entryBCI) {\n+        return allocateCompileId(method, method.getMethodPointer(), entryBCI);\n+    }\n+\n+    private native int allocateCompileId(HotSpotResolvedJavaMethodImpl method, long methodPointer, int entryBCI);\n@@ -570,1 +754,12 @@\n-    native boolean hasCompiledCodeForOSR(HotSpotResolvedJavaMethodImpl method, int entryBCI, int level);\n+    boolean hasCompiledCodeForOSR(HotSpotResolvedJavaMethodImpl method, int entryBCI, int level) {\n+        return hasCompiledCodeForOSR(method, method.getMethodPointer(), entryBCI, level);\n+    }\n+\n+    private native boolean hasCompiledCodeForOSR(HotSpotResolvedJavaMethodImpl method, long methodPoiner, int entryBCI, int level);\n+\n+    \/**\n+     * Gets the value of {@code symbol} as a String.\n+     *\n+     * @param symbol a {@code Symbol*} value\n+     *\/\n+    native String getSymbol(long symbol);\n@@ -573,1 +768,3 @@\n-     * Gets the value of {@code metaspaceSymbol} as a String.\n+     * Gets the name for a {@code klass} as it would appear in a signature.\n+     *\n+     * @param klass a {@code Klass*} value\n@@ -575,1 +772,1 @@\n-    native String getSymbol(long metaspaceSymbol);\n+    native String getSignatureName(long klass);\n@@ -599,1 +796,5 @@\n-    native int getVtableIndexForInterfaceMethod(HotSpotResolvedObjectTypeImpl type, HotSpotResolvedJavaMethodImpl method);\n+    int getVtableIndexForInterfaceMethod(HotSpotResolvedObjectTypeImpl type, HotSpotResolvedJavaMethodImpl method) {\n+        return getVtableIndexForInterfaceMethod(type, type.getKlassPointer(), method, method.getMethodPointer());\n+    }\n+\n+    private native int getVtableIndexForInterfaceMethod(HotSpotResolvedObjectTypeImpl type, long klassPointer, HotSpotResolvedJavaMethodImpl method, long methodPointer);\n@@ -622,1 +823,1 @@\n-     * Read a HotSpot Method* value from the memory location described by {@code base} plus\n+     * Read a HotSpot {@code Method*} value from the memory location described by {@code base} plus\n@@ -625,1 +826,1 @@\n-     * crash the VM if an invalid location is provided. If the {@code base} is null then\n+     * crash the VM if an invalid location is provided. If {@code base == null} is null then\n@@ -650,1 +851,5 @@\n-    native HotSpotConstantPool getConstantPool(MetaspaceObject object);\n+    HotSpotConstantPool getConstantPool(MetaspaceObject object) {\n+        return getConstantPool(object, object.getMetaspacePointer(), object instanceof HotSpotResolvedJavaType);\n+    }\n+\n+    native HotSpotConstantPool getConstantPool(Object object, long klassOrMethod, boolean isKlass);\n@@ -653,1 +858,1 @@\n-     * Read a HotSpot Klass* value from the memory location described by {@code base} plus\n+     * Read a {@code Klass*} value from the memory location described by {@code base} plus\n@@ -725,1 +930,5 @@\n-    native HotSpotResolvedObjectTypeImpl[] getInterfaces(HotSpotResolvedObjectTypeImpl type);\n+    HotSpotResolvedObjectTypeImpl[] getInterfaces(HotSpotResolvedObjectTypeImpl klass) {\n+        return getInterfaces(klass, klass.getKlassPointer());\n+    }\n+\n+    native HotSpotResolvedObjectTypeImpl[] getInterfaces(HotSpotResolvedObjectTypeImpl klass, long klassPointer);\n@@ -730,1 +939,5 @@\n-    native HotSpotResolvedJavaType getComponentType(HotSpotResolvedObjectTypeImpl type);\n+    HotSpotResolvedJavaType getComponentType(HotSpotResolvedObjectTypeImpl klass) {\n+        return getComponentType(klass, klass.getKlassPointer());\n+    }\n+\n+    native HotSpotResolvedJavaType getComponentType(HotSpotResolvedObjectTypeImpl klass, long klassPointer);\n@@ -733,2 +946,8 @@\n-     * Get the array class for {@code type}. This can't be done symbolically since hidden classes\n-     * can't be looked up by name.\n+     * Get the array class for the primitive type represented by the {@link JavaKind#getTypeChar()}\n+     * value in {@code typeChar} or the non-primitive type represented by {@code nonPrimitiveKlass}.\n+     * This can't be done symbolically since hidden classes can't be looked up by name.\n+     *\n+     * Exactly one of {@code primitiveTypeChar} or {@code nonPrimitiveKlass} must be non-zero.\n+     *\n+     * @param primitiveTypeChar a {@link JavaKind#getTypeChar()} value for a primitive type\n+     * @param nonPrimitiveKlass a non-primitive type\n@@ -736,1 +955,6 @@\n-    native HotSpotResolvedObjectTypeImpl getArrayType(HotSpotResolvedJavaType type);\n+    HotSpotResolvedObjectTypeImpl getArrayType(char primitiveTypeChar, HotSpotResolvedObjectTypeImpl nonPrimitiveKlass) {\n+        long nonPrimitiveKlassPointer = nonPrimitiveKlass != null ? nonPrimitiveKlass.getKlassPointer() : 0L;\n+        return getArrayType(primitiveTypeChar, nonPrimitiveKlass, nonPrimitiveKlassPointer);\n+    }\n+\n+    native HotSpotResolvedObjectTypeImpl getArrayType(char typeChar, HotSpotResolvedObjectTypeImpl klass, long klassPointer);\n@@ -739,1 +963,1 @@\n-     * Forces initialization of {@code type}.\n+     * Forces initialization of {@code klass}.\n@@ -741,1 +965,5 @@\n-    native void ensureInitialized(HotSpotResolvedObjectTypeImpl type);\n+    void ensureInitialized(HotSpotResolvedObjectTypeImpl klass) {\n+        ensureInitialized(klass, klass.getKlassPointer());\n+    }\n+\n+    native void ensureInitialized(HotSpotResolvedObjectTypeImpl klass, long klassPointer);\n@@ -744,1 +972,1 @@\n-     * Forces linking of {@code type}.\n+     * Forces linking of {@code klass}.\n@@ -746,1 +974,5 @@\n-    native void ensureLinked(HotSpotResolvedObjectTypeImpl type);\n+    void ensureLinked(HotSpotResolvedObjectTypeImpl klass) {\n+        ensureLinked(klass, klass.getKlassPointer());\n+    }\n+\n+    native void ensureLinked(HotSpotResolvedObjectTypeImpl klass, long klassPointer);\n@@ -770,1 +1002,1 @@\n-     * Gets the {@link ResolvedJavaMethod}s for all the constructors of the type {@code holder}.\n+     * Gets the {@link ResolvedJavaMethod}s for all the constructors of {@code klass}.\n@@ -772,1 +1004,5 @@\n-    native ResolvedJavaMethod[] getDeclaredConstructors(HotSpotResolvedObjectTypeImpl holder);\n+    ResolvedJavaMethod[] getDeclaredConstructors(HotSpotResolvedObjectTypeImpl klass) {\n+        return getDeclaredConstructors(klass, klass.getKlassPointer());\n+    }\n+\n+    native ResolvedJavaMethod[] getDeclaredConstructors(HotSpotResolvedObjectTypeImpl klass, long klassPointer);\n@@ -775,2 +1011,1 @@\n-     * Gets the {@link ResolvedJavaMethod}s for all the non-constructor methods of the type\n-     * {@code holder}.\n+     * Gets the {@link ResolvedJavaMethod}s for all the non-constructor methods of {@code klass}.\n@@ -778,1 +1013,5 @@\n-    native ResolvedJavaMethod[] getDeclaredMethods(HotSpotResolvedObjectTypeImpl holder);\n+    ResolvedJavaMethod[] getDeclaredMethods(HotSpotResolvedObjectTypeImpl klass) {\n+        return getDeclaredMethods(klass, klass.getKlassPointer());\n+    }\n+\n+    native ResolvedJavaMethod[] getDeclaredMethods(HotSpotResolvedObjectTypeImpl klass, long klassPointer);\n@@ -781,2 +1020,1 @@\n-     * Reads the current value of a static field. If {@code expectedType} is non-null, then the\n-     * object is expected to be a subtype of {@code expectedType} and extra sanity checking is\n+     * Reads the current value of a static field of {@code declaringKlass}. Extra sanity checking is\n@@ -785,0 +1023,2 @@\n+     * @param declaringKlass the type in which the static field is declared\n+     * @param offset the offset of the field in the {@link Class} mirror of {@code declaringKlass}\n@@ -787,1 +1027,5 @@\n-    native JavaConstant readFieldValue(HotSpotResolvedObjectTypeImpl object, HotSpotResolvedObjectTypeImpl expectedType, long offset, JavaKind kind);\n+    JavaConstant readStaticFieldValue(HotSpotResolvedObjectTypeImpl declaringKlass, long offset, char typeChar) {\n+        return readStaticFieldValue(declaringKlass, declaringKlass.getKlassPointer(), offset, typeChar);\n+    }\n+\n+    native JavaConstant readStaticFieldValue(HotSpotResolvedObjectTypeImpl declaringKlass, long declaringKlassPointer, long offset, char typeChar);\n@@ -790,2 +1034,2 @@\n-     * Reads the current value of an instance field. If {@code expectedType} is non-null, then the\n-     * object is expected to be a subtype of {@code expectedType} and extra sanity checking is\n+     * Reads the current value of an instance field. If {@code expectedType} is non-null, then\n+     * {@code object} is expected to be a subtype of {@code expectedType}. Extra sanity checking is\n@@ -794,0 +1038,4 @@\n+     * @param object the object from which the field is to be read. If {@code object} is of type\n+     *            {@link Class} and {@code offset} is >= the offset of the static field storage in a\n+     *            {@link Class} instance, then this operation is a static field read.\n+     * @param expectedType the expected type of {@code object}\n@@ -796,1 +1044,6 @@\n-    native JavaConstant readFieldValue(HotSpotObjectConstantImpl object, HotSpotResolvedObjectTypeImpl expectedType, long offset, JavaKind kind);\n+    JavaConstant readFieldValue(HotSpotObjectConstantImpl object, HotSpotResolvedObjectTypeImpl expectedType, long offset, char typeChar) {\n+        long expectedTypePointer = expectedType != null ? expectedType.getKlassPointer() : 0L;\n+        return readFieldValue(object, expectedType, expectedTypePointer, offset, typeChar);\n+    }\n+\n+    native JavaConstant readFieldValue(HotSpotObjectConstantImpl object, HotSpotResolvedObjectTypeImpl expectedType, long expectedTypePointer, long offset, char typeChar);\n@@ -801,1 +1054,5 @@\n-    native boolean isInstance(HotSpotResolvedObjectTypeImpl holder, HotSpotObjectConstantImpl object);\n+    boolean isInstance(HotSpotResolvedObjectTypeImpl klass, HotSpotObjectConstantImpl object) {\n+        return isInstance(klass, klass.getKlassPointer(), object);\n+    }\n+\n+    native boolean isInstance(HotSpotResolvedObjectTypeImpl klass, long klassPointer, HotSpotObjectConstantImpl object);\n@@ -806,1 +1063,5 @@\n-    native boolean isAssignableFrom(HotSpotResolvedObjectTypeImpl holder, HotSpotResolvedObjectTypeImpl otherType);\n+    boolean isAssignableFrom(HotSpotResolvedObjectTypeImpl klass, HotSpotResolvedObjectTypeImpl subklass) {\n+        return isAssignableFrom(klass, klass.getKlassPointer(), subklass, subklass.getKlassPointer());\n+    }\n+\n+    native boolean isAssignableFrom(HotSpotResolvedObjectTypeImpl klass, long klassPointer, HotSpotResolvedObjectTypeImpl subklass, long subklassPointer);\n@@ -824,1 +1085,1 @@\n-     * Gets a {@link JavaConstant} wrapping the {@link java.lang.Class} mirror for {@code type}.\n+     * Gets a {@link JavaConstant} wrapping the {@link java.lang.Class} mirror for {@code klass}.\n@@ -826,1 +1087,5 @@\n-    native HotSpotObjectConstantImpl getJavaMirror(HotSpotResolvedJavaType type);\n+    HotSpotObjectConstantImpl getJavaMirror(HotSpotResolvedObjectTypeImpl klass) {\n+        return getJavaMirror(klass, klass.getKlassPointer());\n+    }\n+\n+    native HotSpotObjectConstantImpl getJavaMirror(HotSpotResolvedObjectTypeImpl type, long klassPointer);\n@@ -870,1 +1135,5 @@\n-    native Executable asReflectionExecutable(HotSpotResolvedJavaMethodImpl method);\n+    Executable asReflectionExecutable(HotSpotResolvedJavaMethodImpl method) {\n+        return asReflectionExecutable(method, method.getMethodPointer());\n+    }\n+\n+    native Executable asReflectionExecutable(HotSpotResolvedJavaMethodImpl method, long methodPointer);\n@@ -878,1 +1147,5 @@\n-    native Field asReflectionField(HotSpotResolvedObjectTypeImpl holder, int fieldIndex);\n+    Field asReflectionField(HotSpotResolvedObjectTypeImpl holder, int fieldIndex) {\n+        return asReflectionField(holder, holder.getKlassPointer(), fieldIndex);\n+    }\n+\n+    native Field asReflectionField(HotSpotResolvedObjectTypeImpl holder, long holderPointer, int fieldIndex);\n@@ -883,1 +1156,5 @@\n-    native boolean isTrustedForIntrinsics(HotSpotResolvedObjectTypeImpl type);\n+    boolean isTrustedForIntrinsics(HotSpotResolvedObjectTypeImpl klass) {\n+        return isTrustedForIntrinsics(klass, klass.getKlassPointer());\n+    }\n+\n+    native boolean isTrustedForIntrinsics(HotSpotResolvedObjectTypeImpl klass, long klassPointer);\n@@ -905,1 +1182,5 @@\n-    native long getFailedSpeculationsAddress(HotSpotResolvedJavaMethodImpl method);\n+    long getFailedSpeculationsAddress(HotSpotResolvedJavaMethodImpl method) {\n+        return getFailedSpeculationsAddress(method, method.getMethodPointer());\n+    }\n+\n+    native long getFailedSpeculationsAddress(HotSpotResolvedJavaMethodImpl method, long methodPointer);\n@@ -986,1 +1267,3 @@\n-    native void notifyCompilerInliningEvent(int compileId, HotSpotResolvedJavaMethodImpl caller, HotSpotResolvedJavaMethodImpl callee, boolean succeeded, String message, int bci);\n+    void notifyCompilerInliningEvent(int compileId, HotSpotResolvedJavaMethodImpl caller, HotSpotResolvedJavaMethodImpl callee, boolean succeeded, String message, int bci) {\n+        notifyCompilerInliningEvent(compileId, caller, caller.getMethodPointer(), callee, callee.getMethodPointer(), succeeded, message, bci);\n+    }\n@@ -988,0 +1271,2 @@\n+    native void notifyCompilerInliningEvent(int compileId, HotSpotResolvedJavaMethodImpl caller, long callerPointer,\n+                    HotSpotResolvedJavaMethodImpl callee, long calleePointer, boolean succeeded, String message, int bci);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":386,"deletions":101,"binary":false,"changes":487,"status":"modified"},{"patch":"@@ -139,1 +139,1 @@\n-        int result = runtime.getCompilerToVM().installCode(target, (HotSpotCompiledCode) compiledCode, resultInstalledCode, failedSpeculationsAddress, speculations);\n+        int result = runtime.getCompilerToVM().installCode(hsCompiledCode, resultInstalledCode, failedSpeculationsAddress, speculations);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotCodeCacheProvider.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -121,2 +121,13 @@\n-    public HotSpotCompiledCode(String name, byte[] targetCode, int targetCodeSize, Site[] sites, Assumption[] assumptions, ResolvedJavaMethod[] methods, Comment[] comments, byte[] dataSection,\n-                    int dataSectionAlignment, DataPatch[] dataSectionPatches, boolean isImmutablePIC, int totalFrameSize, StackSlot deoptRescueSlot) {\n+    public HotSpotCompiledCode(String name,\n+                    byte[] targetCode,\n+                    int targetCodeSize,\n+                    Site[] sites,\n+                    Assumption[] assumptions,\n+                    ResolvedJavaMethod[] methods,\n+                    Comment[] comments,\n+                    byte[] dataSection,\n+                    int dataSectionAlignment,\n+                    DataPatch[] dataSectionPatches,\n+                    boolean isImmutablePIC,\n+                    int totalFrameSize,\n+                    StackSlot deoptRescueSlot) {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotCompiledCode.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,1243 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.hotspot;\n+\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.CALLSITE_TARGET_VALUE;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.CONCRETE_METHOD;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.CONCRETE_SUBTYPE;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.ILLEGAL;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.JOBJECT;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.LEAF_TYPE;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.NO_FINALIZABLE_SUBCLASS;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.NULL_CONSTANT;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.OBJECT_ID;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.OBJECT_ID2;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.PATCH_JOBJECT;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.PATCH_KLASS;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.PATCH_METHOD;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.PATCH_NARROW_JOBJECT;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.PATCH_NARROW_KLASS;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.PATCH_NARROW_OBJECT_ID;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.PATCH_NARROW_OBJECT_ID2;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.PATCH_OBJECT_ID;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.PATCH_OBJECT_ID2;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.PRIMITIVE4;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.PRIMITIVE8;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.PRIMITIVE_0;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.RAW_CONSTANT;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.REGISTER_NARROW_OOP;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.REGISTER_OOP;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.REGISTER_PRIMITIVE;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.SITE_CALL;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.SITE_DATA_PATCH;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.SITE_EXCEPTION_HANDLER;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.SITE_FOREIGN_CALL;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.SITE_FOREIGN_CALL_NO_DEBUG_INFO;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.SITE_IMPLICIT_EXCEPTION;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.SITE_IMPLICIT_EXCEPTION_DISPATCH;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.SITE_INFOPOINT;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.SITE_MARK;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.SITE_SAFEPOINT;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.STACK_SLOT_NARROW_OOP;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.STACK_SLOT_OOP;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.STACK_SLOT_PRIMITIVE;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.VIRTUAL_OBJECT_ID;\n+import static jdk.vm.ci.hotspot.HotSpotCompiledCodeStream.Tag.VIRTUAL_OBJECT_ID2;\n+\n+import java.io.PrintStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.vm.ci.code.BytecodeFrame;\n+import jdk.vm.ci.code.BytecodePosition;\n+import jdk.vm.ci.code.DebugInfo;\n+import jdk.vm.ci.code.Location;\n+import jdk.vm.ci.code.ReferenceMap;\n+import jdk.vm.ci.code.Register;\n+import jdk.vm.ci.code.RegisterSaveLayout;\n+import jdk.vm.ci.code.RegisterValue;\n+import jdk.vm.ci.code.StackLockValue;\n+import jdk.vm.ci.code.StackSlot;\n+import jdk.vm.ci.code.VirtualObject;\n+import jdk.vm.ci.code.site.Call;\n+import jdk.vm.ci.code.site.ConstantReference;\n+import jdk.vm.ci.code.site.DataPatch;\n+import jdk.vm.ci.code.site.DataSectionReference;\n+import jdk.vm.ci.code.site.ExceptionHandler;\n+import jdk.vm.ci.code.site.ImplicitExceptionDispatch;\n+import jdk.vm.ci.code.site.Infopoint;\n+import jdk.vm.ci.code.site.InfopointReason;\n+import jdk.vm.ci.code.site.Mark;\n+import jdk.vm.ci.code.site.Reference;\n+import jdk.vm.ci.code.site.Site;\n+import jdk.vm.ci.common.JVMCIError;\n+import jdk.vm.ci.hotspot.HotSpotCompiledCode.Comment;\n+import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.Option;\n+import jdk.vm.ci.meta.Assumptions.Assumption;\n+import jdk.vm.ci.meta.Assumptions.CallSiteTargetValue;\n+import jdk.vm.ci.meta.Assumptions.ConcreteMethod;\n+import jdk.vm.ci.meta.Assumptions.ConcreteSubtype;\n+import jdk.vm.ci.meta.Assumptions.LeafType;\n+import jdk.vm.ci.meta.Assumptions.NoFinalizableSubclass;\n+import jdk.vm.ci.meta.InvokeTarget;\n+import jdk.vm.ci.meta.JavaConstant;\n+import jdk.vm.ci.meta.JavaKind;\n+import jdk.vm.ci.meta.JavaValue;\n+import jdk.vm.ci.meta.PrimitiveConstant;\n+import jdk.vm.ci.meta.RawConstant;\n+import jdk.vm.ci.meta.ResolvedJavaMethod;\n+import jdk.vm.ci.meta.ResolvedJavaType;\n+import jdk.vm.ci.meta.VMConstant;\n+import jdk.vm.ci.meta.Value;\n+import jdk.vm.ci.services.Services;\n+\n+\/**\n+ * Serializes {@link HotSpotCompiledCode} to a list linked native memory chunks. Each chunk has the\n+ * following layout:\n+ *\n+ * <pre>\n+ *   | word |  4   |<------  size -------->|             |\n+ *   +------+------+-----------------------+-------------+\n+ *   | next | size |       used data       | unused data |\n+ *   +------+------+-----------------------+-------------+\n+ *\n+ *   |<----------- chunkSize --------------------------->|\n+ *   |<-- HEADER ->|\n+ * <\/pre>\n+ *\n+ * Each chunk is twice as large as its predecessor. See {@link #ensureCapacity(int)}.\n+ *\n+ * @see Option#DumpSerializedCode\n+ * @see Option#CodeSerializationTypeInfo\n+ *\/\n+final class HotSpotCompiledCodeStream implements AutoCloseable {\n+\n+    \/\/ 24K is sufficient for most compilations.\n+    private static final int INITIAL_CHUNK_SIZE = 24 * 1024;\n+    private static final int HEADER = Unsafe.ADDRESS_SIZE + 4;\n+\n+    \/\/ @formatter:off\n+    \/\/ HotSpotCompiledCode flags.\n+    \/\/ Defined by HotSpotCompiledCodeFlags enum in jvmciCodeInstaller.hpp.\n+    private static final int IS_NMETHOD            = c(\"HCC_IS_NMETHOD\");\n+    private static final int HAS_ASSUMPTIONS       = c(\"HCC_HAS_ASSUMPTIONS\");\n+    private static final int HAS_METHODS           = c(\"HCC_HAS_METHODS\");\n+    private static final int HAS_DEOPT_RESCUE_SLOT = c(\"HCC_HAS_DEOPT_RESCUE_SLOT\");\n+    private static final int HAS_COMMENTS          = c(\"HCC_HAS_COMMENTS\");\n+\n+    \/\/ DebugInfo flags.\n+    \/\/ Defined by DebugInfoFlags enum in jvmciCodeInstaller.hpp.\n+    private static final int HAS_REFERENCE_MAP    = c(\"DI_HAS_REFERENCE_MAP\");\n+    private static final int HAS_CALLEE_SAVE_INFO = c(\"DI_HAS_CALLEE_SAVE_INFO\");\n+    private static final int HAS_FRAMES           = c(\"DI_HAS_FRAMES\");\n+\n+    \/\/ BytecodeFrame flags\n+    \/\/ Defined by DebugInfoFrameFlags enum in jvmciCodeInstaller.hpp.\n+    private static final int HAS_LOCALS        = c(\"DIF_HAS_LOCALS\");\n+    private static final int HAS_STACK         = c(\"DIF_HAS_STACK\");\n+    private static final int HAS_LOCKS         = c(\"DIF_HAS_LOCKS\");\n+    private static final int DURING_CALL       = c(\"DIF_DURING_CALL\");\n+    private static final int RETHROW_EXCEPTION = c(\"DIF_RETHROW_EXCEPTION\");\n+    \/\/ @formatter:on\n+\n+    \/\/ Sentinel value in a DebugInfo stream denoting no register.\n+    private static final int NO_REGISTER = c(\"NO_REGISTER\");\n+\n+    enum Tag {\n+        ILLEGAL,\n+        REGISTER_PRIMITIVE,\n+        REGISTER_OOP,\n+        REGISTER_NARROW_OOP,\n+        STACK_SLOT_PRIMITIVE,\n+        STACK_SLOT_OOP,\n+        STACK_SLOT_NARROW_OOP,\n+        VIRTUAL_OBJECT_ID,\n+        VIRTUAL_OBJECT_ID2,\n+        NULL_CONSTANT,\n+        RAW_CONSTANT,\n+        PRIMITIVE_0,\n+        PRIMITIVE4,\n+        PRIMITIVE8,\n+        JOBJECT,\n+        OBJECT_ID,\n+        OBJECT_ID2,\n+\n+        NO_FINALIZABLE_SUBCLASS,\n+        CONCRETE_SUBTYPE,\n+        LEAF_TYPE,\n+        CONCRETE_METHOD,\n+        CALLSITE_TARGET_VALUE,\n+\n+        PATCH_OBJECT_ID,\n+        PATCH_OBJECT_ID2,\n+        PATCH_NARROW_OBJECT_ID,\n+        PATCH_NARROW_OBJECT_ID2,\n+        PATCH_JOBJECT,\n+        PATCH_NARROW_JOBJECT,\n+        PATCH_KLASS,\n+        PATCH_NARROW_KLASS,\n+        PATCH_METHOD,\n+        PATCH_DATA_SECTION_REFERENCE,\n+\n+        SITE_CALL,\n+        SITE_FOREIGN_CALL,\n+        SITE_FOREIGN_CALL_NO_DEBUG_INFO,\n+        SITE_SAFEPOINT,\n+        SITE_INFOPOINT,\n+        SITE_IMPLICIT_EXCEPTION,\n+        SITE_IMPLICIT_EXCEPTION_DISPATCH,\n+        SITE_MARK,\n+        SITE_DATA_PATCH,\n+        SITE_EXCEPTION_HANDLER;\n+\n+        Tag() {\n+            int expect = ordinal();\n+            int actual = c(name());\n+            if (expect != actual) {\n+                throw new JVMCIError(\"%s: expected %d, got %d\", name(), expect, actual);\n+            }\n+        }\n+    }\n+\n+    private final Unsafe unsafe = UnsafeAccess.UNSAFE;\n+    private final HotSpotJVMCIRuntime runtime;\n+\n+    \/**\n+     * Specifies if the name and size of each data element is written to the buffer.\n+     *\/\n+    private final boolean withTypeInfo;\n+\n+    \/**\n+     * Lazily initialized string from {@link HotSpotCompiledCode#name} or\n+     * {@link HotSpotCompiledNmethod#method}.\n+     *\/\n+    private Object codeDesc;\n+\n+    \/**\n+     * Constant pool for {@linkplain DirectHotSpotObjectConstantImpl direct} object references.\n+     *\/\n+\n+    \/**\n+     * Alternative to using {@link IdentityHashMap} which would require dealing with the\n+     * {@link IdentityHashMap#NULL_KEY} constant.\n+     *\/\n+    static class IdentityBox {\n+        Object obj;\n+\n+        IdentityBox(Object obj) {\n+            this.obj = obj;\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            IdentityBox that = (IdentityBox) other;\n+            return that.obj == obj;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return System.identityHashCode(obj);\n+        }\n+    }\n+\n+    private HashMap<IdentityBox, Integer> objects;\n+    final Object[] objectPool;\n+\n+    \/**\n+     * Head and current chunk.\n+     *\/\n+    final long headChunk;\n+    private long currentChunk;\n+\n+    \/**\n+     * Size of current chunk.\n+     *\/\n+    private int currentChunkSize;\n+\n+    \/**\n+     * Index of current chunk.\n+     *\/\n+    private int currentChunkIndex;\n+\n+    \/**\n+     * Insertion position in current chunk.\n+     *\/\n+    private int currentChunkOffset;\n+\n+    \/**\n+     * Nanoseconds spent in {@link HotSpotCompiledCodeStream#HotSpotCompiledCodeStream}.\n+     *\/\n+    long timeNS;\n+\n+    private JVMCIError error(String format, Object... args) {\n+        String prefix = String.format(\"%s[offset=%d]\", codeDesc(), getTotalDataSize());\n+        throw new JVMCIError(prefix + \": \" + format, args);\n+    }\n+\n+    \/**\n+     * Gets the size of payload data in the buffer.\n+     *\/\n+    private int getTotalDataSize() {\n+        int offset = currentChunkOffset - HEADER;\n+        for (long chunk = headChunk; chunk != currentChunk; chunk = getChunkNext(chunk)) {\n+            offset += getDataSize(chunk);\n+        }\n+        return offset;\n+    }\n+\n+    \/**\n+     * Reads the size of the payload in {@code chunk}.\n+     *\/\n+    private int getDataSize(long chunk) {\n+        int sizeOffset = Unsafe.ADDRESS_SIZE;\n+        return unsafe.getInt(chunk + sizeOffset);\n+    }\n+\n+    \/**\n+     * Writes the size of the payload in {@code chunk}.\n+     *\/\n+    private void setDataSize(long chunk, int size) {\n+        int sizeOffset = Unsafe.ADDRESS_SIZE;\n+        unsafe.putInt(chunk + sizeOffset, size);\n+    }\n+\n+    \/**\n+     * Reads the pointer in chunk pointing to the next chunk in the list.\n+     *\/\n+    private long getChunkNext(long chunk) {\n+        return unsafe.getAddress(chunk);\n+    }\n+\n+    \/**\n+     * Writes the pointer in chunk pointing to the next chunk in the list.\n+     *\/\n+    private void setChunkNext(long chunk, long next) {\n+        unsafe.putAddress(chunk, next);\n+    }\n+\n+    \/**\n+     * Ensures there is capacity for appending {@code toWrite} additional bytes.\n+     *\/\n+    private void ensureCapacity(int toWrite) {\n+        if (currentChunkOffset + toWrite > currentChunkSize) {\n+            \/\/ Save current chunk data size\n+            int dataSize = currentChunkOffset - HEADER;\n+            setDataSize(currentChunk, dataSize);\n+\n+            \/\/ Allocate new chunk and link it. Each chunk is\n+            \/\/ at least as twice as large as its predecessor.\n+            int nextChunkSize = currentChunkSize * 2;\n+            if (nextChunkSize < toWrite + HEADER) {\n+                nextChunkSize = toWrite + HEADER;\n+            }\n+            long nextChunk = unsafe.allocateMemory(nextChunkSize);\n+            setChunkNext(currentChunk, nextChunk);\n+            setChunkNext(nextChunk, 0);\n+\n+            \/\/ Make new chunk current\n+            currentChunk = nextChunk;\n+            currentChunkSize = nextChunkSize;\n+            currentChunkOffset = HEADER;\n+            currentChunkIndex++;\n+        }\n+    }\n+\n+    \/**\n+     * Emits type info for a write to the buffer and ensures there's sufficient capacity.\n+     *\n+     * @param name name of data element to be written\n+     * @param sizeInBytes the size of the data element to be written\n+     *\/\n+    private void beforeWrite(String name, int sizeInBytes) {\n+        emitType(name, sizeInBytes);\n+        ensureCapacity(sizeInBytes);\n+    }\n+\n+    \/**\n+     * Emits the name and size in bytes of a data element if type info is enabled.\n+     *\n+     * @param name\n+     * @param sizeInBytes\n+     *\/\n+    private void emitType(String name, int sizeInBytes) {\n+        if (withTypeInfo) {\n+            int len = name.length();\n+            if ((len & 0xFF) != len) {\n+                \/\/ Length must be <= 0xFF\n+                throw error(\"Data element label is too long (%d): %s\", len, name);\n+            }\n+            if (sizeInBytes < 0 || sizeInBytes > 8) {\n+                throw error(\"Data element size is not between 0 and 8 inclusive: %d\", sizeInBytes);\n+            }\n+            int toWrite = 1 + 1 + len + 1;\n+            ensureCapacity(toWrite);\n+\n+            \/\/ sizeInBytes\n+            unsafe.putByte(currentChunk + currentChunkOffset, (byte) sizeInBytes);\n+            currentChunkOffset++;\n+\n+            \/\/ length\n+            unsafe.putByte(currentChunk + currentChunkOffset, (byte) len);\n+            currentChunkOffset++;\n+\n+            \/\/ body\n+            for (int i = 0; i < len; i++) {\n+                int c = name.charAt(i);\n+                if (c >= 0x80 || c == 0) {\n+                    throw error(\"label contains non-ascii char at %d: %s\", i, name);\n+                }\n+                unsafe.putByte(currentChunk + currentChunkOffset, (byte) c);\n+                currentChunkOffset++;\n+            }\n+        }\n+    }\n+\n+    private static boolean isU1(int value) {\n+        return (value & 0xFF) == value;\n+    }\n+\n+    private void writeU1(String name, int value) {\n+        if (!isU1(value)) {\n+            throw error(\"value not a u1: \" + value);\n+        }\n+        byte b = (byte) value;\n+        beforeWrite(name, 1);\n+        unsafe.putByte(currentChunk + currentChunkOffset, b);\n+        currentChunkOffset++;\n+    }\n+\n+    private void writeBoolean(String name, boolean value) {\n+        writeU1(name, value ? 1 : 0);\n+    }\n+\n+    private void writeInt(String name, int value) {\n+        beforeWrite(name, 4);\n+        unsafe.putInt(currentChunk + currentChunkOffset, value);\n+        currentChunkOffset += 4;\n+    }\n+\n+    private void rawWriteU2(String name, int value) {\n+        beforeWrite(name, 2);\n+        char ch = (char) value;\n+        unsafe.putChar(currentChunk + currentChunkOffset, ch);\n+        currentChunkOffset += 2;\n+    }\n+\n+    private void writeU2(String name, int value) {\n+        if (value < Character.MIN_VALUE || value > Character.MAX_VALUE) {\n+            throw error(\"value not a u2: \" + value);\n+        }\n+        rawWriteU2(name, value);\n+    }\n+\n+    private void writeS2(String name, int value) {\n+        if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) {\n+            throw error(\"value not an s2: \" + value);\n+        }\n+        rawWriteU2(name, value);\n+    }\n+\n+    private void writeLong(String name, long value) {\n+        beforeWrite(name, 8);\n+        unsafe.putLong(currentChunk + currentChunkOffset, value);\n+        currentChunkOffset += 8;\n+    }\n+\n+    \/**\n+     * Writes the UTF8 bytes for {@code value} to the stream followed by a 0.\n+     *\/\n+    private void writeUTF8(String name, String value) {\n+        if (value == null) {\n+            writeInt(name, -1);\n+            return;\n+        }\n+\n+        byte[] utf = value.getBytes(StandardCharsets.UTF_8);\n+\n+        emitType(name, 4);\n+\n+        int toWrite = 4 + utf.length + 1;\n+        ensureCapacity(toWrite);\n+\n+        \/\/ length\n+        unsafe.putInt(currentChunk + currentChunkOffset, utf.length);\n+        currentChunkOffset += 4;\n+\n+        \/\/ body\n+        for (int i = 0; i < utf.length; i++) {\n+            byte b = utf[i];\n+            unsafe.putByte(currentChunk + currentChunkOffset, b);\n+            currentChunkOffset++;\n+        }\n+\n+        \/\/ trailing 0\n+        unsafe.putByte(currentChunk + currentChunkOffset, (byte) 0);\n+        currentChunkOffset++;\n+    }\n+\n+    private String codeDesc() {\n+        if (codeDesc instanceof ResolvedJavaMethod) {\n+            codeDesc = ((ResolvedJavaMethod) codeDesc).format(\"%H.%n(%p)\");\n+        } else if (codeDesc == null) {\n+            codeDesc = \"<unknown>\";\n+        }\n+        return codeDesc.toString();\n+    }\n+\n+    \/**\n+     * Serializes {@code}.\n+     *\n+     * @param code the object to serialize\n+     * @param withTypeInfo see {@link Option#CodeSerializationTypeInfo}\n+     * @param withComments include {@link HotSpotCompiledCode#comments} in the stream\n+     * @param withMethods include {@link HotSpotCompiledCode#methods} in the stream\n+     *\/\n+    HotSpotCompiledCodeStream(HotSpotCompiledCode code, boolean withTypeInfo, boolean withComments, boolean withMethods) {\n+        long start = System.nanoTime();\n+        this.currentChunkSize = INITIAL_CHUNK_SIZE;\n+        this.headChunk = unsafe.allocateMemory(currentChunkSize);\n+        this.currentChunk = headChunk;\n+        this.currentChunkOffset = HEADER;\n+        setChunkNext(currentChunk, 0);\n+        setDataSize(currentChunk, 0);\n+\n+        this.runtime = HotSpotJVMCIRuntime.runtime();\n+        this.withTypeInfo = withTypeInfo;\n+\n+        ResolvedJavaMethod[] methods = withMethods ? code.methods : null;\n+        Assumption[] assumptions = code.assumptions;\n+        StackSlot deoptRescueSlot = code.deoptRescueSlot;\n+        Comment[] comments = withComments ? code.comments : null;\n+\n+        String name = code.name;\n+        codeDesc = name;\n+        HotSpotCompiledNmethod nmethod;\n+        if (code instanceof HotSpotCompiledNmethod) {\n+            nmethod = (HotSpotCompiledNmethod) code;\n+            if (codeDesc == null) {\n+                codeDesc = nmethod.method;\n+            }\n+        } else {\n+            nmethod = null;\n+        }\n+\n+        \/\/ @formatter:off\n+        int flags = setIf(IS_NMETHOD, nmethod != null) |\n+                    setIf(HAS_METHODS, nmethod != null && methods != null && methods.length != 0 ) |\n+                    setIf(HAS_ASSUMPTIONS, assumptions) |\n+                    setIf(HAS_DEOPT_RESCUE_SLOT, deoptRescueSlot != null) |\n+                    setIf(HAS_COMMENTS, comments);\n+        \/\/ @formatter:on\n+\n+        writeU1(\"code:flags\", flags);\n+        writeUTF8(\"name\", name);\n+        if (nmethod != null) {\n+            writeMethod(\"method\", nmethod.method);\n+            writeInt(\"entryBCI\", nmethod.entryBCI);\n+            writeLong(\"compileState\", nmethod.compileState);\n+            writeBoolean(\"hasUnsafeAccess\", nmethod.hasUnsafeAccess);\n+            writeInt(\"id\", nmethod.id);\n+        }\n+\n+        if (isSet(flags, HAS_ASSUMPTIONS)) {\n+            writeAssumptions(assumptions);\n+        }\n+        if (isSet(flags, HAS_METHODS)) {\n+            writeU2(\"methods:length\", methods.length);\n+            for (ResolvedJavaMethod method : methods) {\n+                writeMethod(\"method\", method);\n+            }\n+        }\n+\n+        writeInt(\"sites:length\", code.sites.length);\n+        writeInt(\"targetCodeSize\", code.targetCodeSize);\n+        writeInt(\"totalFrameSize\", code.totalFrameSize);\n+        if (isSet(flags, HAS_DEOPT_RESCUE_SLOT)) {\n+            writeS2(\"offset\", deoptRescueSlot.getRawOffset());\n+            writeBoolean(\"addRawFrameSize\", deoptRescueSlot.getRawAddFrameSize());\n+        }\n+        writeInt(\"dataSectionSize\", code.dataSection.length);\n+        writeU1(\"dataSectionAlignment\", code.dataSectionAlignment);\n+\n+        writeStubCounts(code);\n+        writeDataSectionPatches(code.dataSectionPatches);\n+        writeSites(code);\n+\n+        if (isSet(flags, HAS_COMMENTS)) {\n+            writeU2(\"comments:length\", comments.length);\n+            for (Comment c : comments) {\n+                writeInt(\"comment:pcOffset\", c.pcOffset);\n+                writeUTF8(\"comment:text\", c.text);\n+            }\n+        }\n+\n+        \/\/ Finalize current (and last) chunk\n+        int dataSize = currentChunkOffset - HEADER;\n+        setDataSize(currentChunk, dataSize);\n+\n+        objectPool = !Services.IS_IN_NATIVE_IMAGE ? finalizeObjectPool() : null;\n+\n+        maybeDump(name, nmethod);\n+\n+        this.timeNS = System.nanoTime() - start;\n+    }\n+\n+    \/**\n+     * Creates the pool for {@link DirectHotSpotObjectConstantImpl} values written to the stream.\n+     *\/\n+    private Object[] finalizeObjectPool() throws JVMCIError {\n+        if (objects != null) {\n+            Object[] pool = new Object[objects.size()];\n+            for (Map.Entry<IdentityBox, Integer> e : objects.entrySet()) {\n+                int id = e.getValue();\n+                Object object = e.getKey().obj;\n+                if (object == null) {\n+                    throw error(\"unexpected null in object pool at %d - map is %s\", id, objects);\n+                }\n+                pool[id] = object;\n+            }\n+            return pool;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    \/**\n+     * Determines if {@code name} or {@code method} are matched by\n+     * {@link Option#DumpSerializedCode}.\n+     *\n+     * @returns the matched value or null if no match was made\n+     *\/\n+    private static String shouldDump(String name, HotSpotCompiledNmethod nmethod) {\n+        String filter = Option.DumpSerializedCode.getString();\n+        if (filter == null) {\n+            return null;\n+        }\n+        if (name != null && name.contains(filter)) {\n+            return name;\n+        }\n+        if (nmethod != null) {\n+            String fqn = nmethod.method.format(\"%H.%n(%p)\");\n+            if (fqn.contains(filter)) {\n+                return fqn;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Dumps the buffer to TTY if {@code name} or {@code method} are matched by\n+     * {@link Option#DumpSerializedCode}.\n+     *\/\n+    private void maybeDump(String name, HotSpotCompiledNmethod nmethod) {\n+        String dumpName = shouldDump(name, nmethod);\n+        if (dumpName != null) {\n+            dump(dumpName);\n+        }\n+    }\n+\n+    private void dump(String dumpName) {\n+        int dataSize;\n+        PrintStream out = new PrintStream(runtime.getLogStream());\n+        out.printf(\"Dumping serialized HotSpotCompiledMethod data for %s (head: 0x%016x, chunks: %d, total data size:%d):%n\",\n+                        dumpName, headChunk, currentChunkIndex + 1, getTotalDataSize());\n+        int chunkIndex = 0;\n+        for (long c = headChunk; c != 0; c = getChunkNext(c)) {\n+            long data0 = c + HEADER;\n+            dataSize = getDataSize(c);\n+            byte[] data = new byte[dataSize];\n+            unsafe.copyMemory(null, data0, data, Unsafe.ARRAY_BYTE_BASE_OFFSET, dataSize);\n+            out.printf(\"[CHUNK %d: address=0x%016x, data=0x%016x:0x%016x, data size=%d]%n\",\n+                            chunkIndex, c, data0, data0 + dataSize, dataSize);\n+            hexdump(out, data0, data);\n+            chunkIndex++;\n+        }\n+    }\n+\n+    private static void hexdump(PrintStream out, long address, byte[] data) {\n+        int col = 0;\n+        for (int pos = 0; pos < data.length; pos++) {\n+            if (col % 16 == 0) {\n+                out.printf(\"0x%016x:\", address + pos);\n+            }\n+            if (col % 2 == 0) {\n+                out.print(' ');\n+            }\n+            if (pos < data.length) {\n+                byte b = data[pos];\n+                char ch = (char) ((char) b & 0xff);\n+                out.printf(\"%02X\", (int) ch);\n+            } else {\n+                out.print(\"  \");\n+            }\n+            if ((col + 1) % 16 == 0) {\n+                out.print(\"  \");\n+                for (int j = pos - 15; j <= pos; ++j) {\n+                    byte b = data[j];\n+                    char ch = (char) ((char) b & 0xff);\n+                    out.print(ch >= 32 && ch <= 126 ? ch : '.');\n+                }\n+                out.println();\n+            }\n+            col++;\n+        }\n+        out.println();\n+    }\n+\n+    @Override\n+    public void close() {\n+        for (long c = headChunk; c != 0;) {\n+            long next = getChunkNext(c);\n+            unsafe.freeMemory(c);\n+            c = next;\n+        }\n+    }\n+\n+    private void writeSites(HotSpotCompiledCode code) {\n+        Site[] sites = code.sites;\n+        for (Site site : sites) {\n+            writeInt(\"site:pcOffset\", site.pcOffset);\n+            if (site instanceof Call) {\n+                Call call = (Call) site;\n+                DebugInfo debugInfo = call.debugInfo;\n+                InvokeTarget target = call.target;\n+                if (target instanceof HotSpotForeignCallTarget) {\n+                    HotSpotForeignCallTarget foreignCall = (HotSpotForeignCallTarget) target;\n+                    writeTag(debugInfo == null ? SITE_FOREIGN_CALL_NO_DEBUG_INFO : SITE_FOREIGN_CALL);\n+                    writeLong(\"target\", foreignCall.address);\n+                    if (debugInfo != null) {\n+                        writeDebugInfo(debugInfo, true);\n+                    }\n+                } else {\n+                    if (debugInfo == null) {\n+                        throw error(\"debug info expected at call %s\", call);\n+                    }\n+                    writeTag(SITE_CALL);\n+                    ResolvedJavaMethod method = (ResolvedJavaMethod) target;\n+                    writeMethod(\"target\", method);\n+                    writeBoolean(\"direct\", call.direct);\n+                    writeDebugInfo(debugInfo, true);\n+                }\n+            } else if (site instanceof Infopoint) {\n+                Infopoint info = (Infopoint) site;\n+                InfopointReason reason = info.reason;\n+                DebugInfo debugInfo = info.debugInfo;\n+                if (debugInfo == null) {\n+                    throw error(\"debug info expected at infopoint %s\", info);\n+                }\n+                Tag tag;\n+                switch (reason) {\n+                    case SAFEPOINT:\n+                        tag = SITE_SAFEPOINT;\n+                        break;\n+                    case IMPLICIT_EXCEPTION:\n+                        tag = info instanceof ImplicitExceptionDispatch ? SITE_IMPLICIT_EXCEPTION_DISPATCH : SITE_IMPLICIT_EXCEPTION;\n+                        break;\n+                    case CALL:\n+                        throw error(\"only %s objects expected to have CALL reason: %s\", Call.class.getName(), info);\n+                    default:\n+                        tag = SITE_INFOPOINT;\n+                        break;\n+                }\n+                writeTag(tag);\n+                boolean fullInfo = reason == InfopointReason.SAFEPOINT || reason == InfopointReason.IMPLICIT_EXCEPTION;\n+                writeDebugInfo(debugInfo, fullInfo);\n+                if (tag == SITE_IMPLICIT_EXCEPTION_DISPATCH) {\n+                    int dispatchOffset = ((ImplicitExceptionDispatch) info).dispatchOffset;\n+                    writeInt(\"dispatchOffset\", dispatchOffset);\n+                }\n+\n+            } else if (site instanceof DataPatch) {\n+                writeTag(SITE_DATA_PATCH);\n+                DataPatch patch = (DataPatch) site;\n+                writeDataPatch(patch, code);\n+            } else if (site instanceof Mark) {\n+                Mark mark = (Mark) site;\n+                writeTag(SITE_MARK);\n+                writeU1(\"mark:id\", (int) mark.id);\n+            } else if (site instanceof ExceptionHandler) {\n+                ExceptionHandler handler = (ExceptionHandler) site;\n+                writeTag(SITE_EXCEPTION_HANDLER);\n+                writeInt(\"site:handlerPos\", handler.handlerPos);\n+            }\n+        }\n+    }\n+\n+    private void writeDataSectionPatches(DataPatch[] dataSectionPatches) {\n+        writeU2(\"dataSectionPatches:length\", dataSectionPatches.length);\n+        for (DataPatch dp : dataSectionPatches) {\n+            Reference ref = dp.reference;\n+            if (!(ref instanceof ConstantReference)) {\n+                throw error(\"invalid patch in data section: %s\", dp);\n+            }\n+            writeInt(\"patch:pcOffset\", dp.pcOffset);\n+            ConstantReference cref = (ConstantReference) ref;\n+            VMConstant con = cref.getConstant();\n+            if (con instanceof HotSpotMetaspaceConstantImpl) {\n+                writeMetaspaceConstantPatch((HotSpotMetaspaceConstantImpl) con);\n+            } else {\n+                if (!(con instanceof HotSpotObjectConstantImpl)) {\n+                    throw error(\"invalid constant in data section: %s\", con);\n+                }\n+                writeOopConstantPatch((HotSpotObjectConstantImpl) con);\n+            }\n+        }\n+    }\n+\n+    private void writeDataPatch(DataPatch patch, HotSpotCompiledCode code) {\n+        Reference ref = patch.reference;\n+        if (ref instanceof ConstantReference) {\n+            ConstantReference cref = (ConstantReference) ref;\n+            VMConstant con = cref.getConstant();\n+            if (con instanceof HotSpotObjectConstantImpl) {\n+                writeOopConstantPatch((HotSpotObjectConstantImpl) con);\n+            } else if (con instanceof HotSpotMetaspaceConstantImpl) {\n+                writeMetaspaceConstantPatch((HotSpotMetaspaceConstantImpl) con);\n+            } else {\n+                throw error(\"unexpected constant patch: %s\", con);\n+            }\n+        } else if (ref instanceof DataSectionReference) {\n+            DataSectionReference dsref = (DataSectionReference) ref;\n+            int dataOffset = dsref.getOffset();\n+            if (dataOffset < 0 || dataOffset >= code.dataSection.length) {\n+                throw error(\"data offset 0x%X points outside data section (size 0x%X)\", dataOffset, code.dataSection.length);\n+            }\n+            writeTag(Tag.PATCH_DATA_SECTION_REFERENCE);\n+            writeInt(\"data:offset\", dataOffset);\n+        } else {\n+            throw error(\"unexpected data reference patch: %s\", ref);\n+        }\n+    }\n+\n+    private void writeOopConstantPatch(HotSpotObjectConstantImpl con) {\n+        if (con instanceof DirectHotSpotObjectConstantImpl) {\n+            if (Services.IS_IN_NATIVE_IMAGE) {\n+                throw error(\"Direct object constant reached the backend: %s\", con);\n+            }\n+            DirectHotSpotObjectConstantImpl obj = (DirectHotSpotObjectConstantImpl) con;\n+            if (!obj.isCompressed()) {\n+                writeObjectID(obj, PATCH_OBJECT_ID, PATCH_OBJECT_ID2);\n+            } else {\n+                writeObjectID(obj, PATCH_NARROW_OBJECT_ID, PATCH_NARROW_OBJECT_ID2);\n+            }\n+        } else {\n+            IndirectHotSpotObjectConstantImpl obj = (IndirectHotSpotObjectConstantImpl) con;\n+            if (!obj.isCompressed()) {\n+                writeTag(PATCH_JOBJECT);\n+            } else {\n+                writeTag(PATCH_NARROW_JOBJECT);\n+            }\n+            writeLong(\"jobject\", obj.getHandle());\n+        }\n+    }\n+\n+    private void writeMetaspaceConstantPatch(HotSpotMetaspaceConstantImpl metaspaceCon) throws JVMCIError {\n+        if (metaspaceCon.isCompressed()) {\n+            writeTag(PATCH_NARROW_KLASS);\n+            HotSpotResolvedObjectType type = metaspaceCon.asResolvedJavaType();\n+            if (type == null) {\n+                throw error(\"unexpected compressed pointer: %s\", metaspaceCon);\n+            }\n+            writeObjectType(\"patch:klass\", type);\n+        } else {\n+            HotSpotResolvedObjectType type = metaspaceCon.asResolvedJavaType();\n+            HotSpotResolvedJavaMethod method = metaspaceCon.asResolvedJavaMethod();\n+            if (type != null) {\n+                writeTag(PATCH_KLASS);\n+                writeObjectType(\"patch:klass\", type);\n+            } else {\n+                if (method == null) {\n+                    throw error(\"unexpected metadata reference: %s\", metaspaceCon);\n+                }\n+                writeTag(PATCH_METHOD);\n+                writeMethod(\"patch:method\", method);\n+            }\n+        }\n+    }\n+\n+    private static final int MARK_INVOKEINTERFACE = c(\"INVOKEINTERFACE\");\n+    private static final int MARK_INVOKEVIRTUAL = c(\"INVOKEVIRTUAL\");\n+    private static final int MARK_INVOKESTATIC = c(\"INVOKESTATIC\");\n+    private static final int MARK_INVOKESPECIAL = c(\"INVOKESPECIAL\");\n+\n+    private static int c(String name) {\n+        return HotSpotJVMCIRuntime.runtime().config.getConstant(\"CodeInstaller::\" + name, Integer.class);\n+    }\n+\n+    private void writeStubCounts(HotSpotCompiledCode code) {\n+        int numStaticCallStubs = 0;\n+        int numTrampolineStubs = 0;\n+        for (Site site : code.sites) {\n+            if (site instanceof Mark) {\n+                Mark mark = (Mark) site;\n+                if (!(mark.id instanceof Integer)) {\n+                    error(\"Mark id must be Integer, not %s\", mark.id.getClass().getName());\n+                }\n+                int id = (Integer) mark.id;\n+                if (id == MARK_INVOKEINTERFACE || id == MARK_INVOKEVIRTUAL) {\n+                    numTrampolineStubs++;\n+                } else if (id == MARK_INVOKESTATIC || id == MARK_INVOKESPECIAL) {\n+                    numStaticCallStubs++;\n+                    numTrampolineStubs++;\n+                }\n+            }\n+        }\n+        writeU2(\"numStaticCallStubs\", numStaticCallStubs);\n+        writeU2(\"numTrampolineStubs\", numTrampolineStubs);\n+    }\n+\n+    private void writeAssumptions(Assumption[] assumptions) {\n+        writeU2(\"assumptions:length\", assumptions.length);\n+        for (Assumption a : assumptions) {\n+            if (a instanceof NoFinalizableSubclass) {\n+                writeTag(NO_FINALIZABLE_SUBCLASS);\n+                writeObjectType(\"receiverType\", ((NoFinalizableSubclass) a).receiverType);\n+            } else if (a instanceof ConcreteSubtype) {\n+                writeTag(CONCRETE_SUBTYPE);\n+                ConcreteSubtype cs = (ConcreteSubtype) a;\n+                writeObjectType(\"context\", cs.context);\n+                writeObjectType(\"subtype\", cs.subtype);\n+            } else if (a instanceof LeafType) {\n+                writeTag(LEAF_TYPE);\n+                writeObjectType(\"context\", ((LeafType) a).context);\n+            } else if (a instanceof ConcreteMethod) {\n+                writeTag(CONCRETE_METHOD);\n+                ConcreteMethod cm = (ConcreteMethod) a;\n+                writeObjectType(\"context\", cm.context);\n+                writeMethod(\"impl\", cm.impl);\n+            } else if (a instanceof CallSiteTargetValue) {\n+                writeTag(CALLSITE_TARGET_VALUE);\n+                CallSiteTargetValue cs = (CallSiteTargetValue) a;\n+                writeJavaValue(cs.callSite, JavaKind.Object);\n+                writeJavaValue(cs.methodHandle, JavaKind.Object);\n+            } else {\n+                throw error(\"unexpected assumption %s\", a);\n+            }\n+        }\n+    }\n+\n+    private void writeDebugInfo(DebugInfo debugInfo, boolean fullInfo) {\n+        ReferenceMap referenceMap = debugInfo.getReferenceMap();\n+        RegisterSaveLayout calleeSaveInfo = debugInfo.getCalleeSaveInfo();\n+        BytecodePosition bytecodePosition = debugInfo.getBytecodePosition();\n+\n+        int flags = 0;\n+        if (bytecodePosition != null) {\n+            flags |= HAS_FRAMES;\n+        }\n+        if (fullInfo) {\n+            if (referenceMap == null) {\n+                throw error(\"reference map is null\");\n+            }\n+            flags |= HAS_REFERENCE_MAP;\n+            if (calleeSaveInfo != null) {\n+                flags |= HAS_CALLEE_SAVE_INFO;\n+            }\n+        }\n+        writeU1(\"debugInfo:flags\", flags);\n+\n+        if (fullInfo) {\n+            writeReferenceMap(referenceMap);\n+            if (calleeSaveInfo != null) {\n+                writeCalleeSaveInfo(calleeSaveInfo);\n+            }\n+            writeVirtualObjects(debugInfo.getVirtualObjectMapping());\n+        }\n+        if (bytecodePosition != null) {\n+            writeFrame(bytecodePosition, fullInfo, 0);\n+        }\n+    }\n+\n+    private void writeVirtualObjects(VirtualObject[] virtualObjects) {\n+        int length = virtualObjects != null ? virtualObjects.length : 0;\n+        writeU2(\"virtualObjects:length\", length);\n+        for (int i = 0; i < length; i++) {\n+            VirtualObject vo = virtualObjects[i];\n+            writeObjectType(\"type\", vo.getType());\n+            writeBoolean(\"isAutoBox\", vo.isAutoBox());\n+        }\n+        for (int i = 0; i < length; i++) {\n+            VirtualObject vo = virtualObjects[i];\n+            int id = vo.getId();\n+            if (id != i) {\n+                throw error(\"duplicate virtual object id %d\", id);\n+            }\n+            JavaValue[] values = vo.getValues();\n+            int valuesLength = values != null ? values.length : 0;\n+            writeU2(\"values:length\", valuesLength);\n+            if (valuesLength != 0) {\n+                for (int j = 0; j < values.length; j++) {\n+                    writeBasicType(vo.getSlotKind(j));\n+                    JavaValue jv = values[j];\n+                    writeJavaValue(jv, vo.getSlotKind(j));\n+                }\n+            }\n+        }\n+    }\n+\n+    private void writeCalleeSaveInfo(RegisterSaveLayout calleeSaveInfo) {\n+        Map<Register, Integer> map = calleeSaveInfo.registersToSlots(false);\n+        writeU2(\"calleeSaveInfo:length\", map.size());\n+        for (Map.Entry<Register, Integer> e : map.entrySet()) {\n+            writeRegister(e.getKey());\n+            writeU2(\"slot\", e.getValue());\n+        }\n+    }\n+\n+    private void writeTag(Tag tag) {\n+        writeU1(\"tag\", (byte) tag.ordinal());\n+    }\n+\n+    private void writeBasicType(JavaKind kind) {\n+        writeU1(\"basicType\", (byte) kind.getBasicType());\n+    }\n+\n+    private void writeObjectType(String name, ResolvedJavaType type) {\n+        HotSpotResolvedObjectTypeImpl objType = (HotSpotResolvedObjectTypeImpl) type;\n+        writeLong(name, objType.getKlassPointer());\n+    }\n+\n+    private void writeMethod(String name, ResolvedJavaMethod method) {\n+        HotSpotResolvedJavaMethodImpl impl = (HotSpotResolvedJavaMethodImpl) method;\n+        writeLong(name, impl.getMethodPointer());\n+    }\n+\n+    private boolean isNarrowOop(Value oopValue) {\n+        return oopValue.getPlatformKind() != runtime.getHostJVMCIBackend().getTarget().arch.getWordKind();\n+    }\n+\n+    private void writeJavaValue(JavaValue value, JavaKind kind) {\n+        if (value == Value.ILLEGAL) {\n+            writeTag(ILLEGAL);\n+        } else if (value == JavaConstant.NULL_POINTER || value instanceof HotSpotCompressedNullConstant) {\n+            if (JavaKind.Object != kind) {\n+                throw error(\"object constant (%s) kind expected to be Object, got %s\", value, kind);\n+            }\n+            writeTag(NULL_CONSTANT);\n+        } else if (value instanceof RegisterValue) {\n+            RegisterValue reg = (RegisterValue) value;\n+            Tag tag = kind == JavaKind.Object ? (isNarrowOop(reg) ? REGISTER_NARROW_OOP : REGISTER_OOP) : REGISTER_PRIMITIVE;\n+            writeTag(tag);\n+            writeRegister(reg.getRegister());\n+        } else if (value instanceof StackSlot) {\n+            StackSlot slot = (StackSlot) value;\n+            Tag tag = kind == JavaKind.Object ? (isNarrowOop(slot) ? STACK_SLOT_NARROW_OOP : STACK_SLOT_OOP) : STACK_SLOT_PRIMITIVE;\n+            writeTag(tag);\n+            writeS2(\"offset\", slot.getRawOffset());\n+            writeBoolean(\"addRawFrameSize\", slot.getRawAddFrameSize());\n+        } else if (value instanceof VirtualObject) {\n+            VirtualObject vo = (VirtualObject) value;\n+            if (kind != JavaKind.Object) {\n+                throw error(\"virtual object kind must be Object, not %s\", kind);\n+            }\n+            int id = vo.getId();\n+            if (isU1(id)) {\n+                writeTag(VIRTUAL_OBJECT_ID);\n+                writeU1(\"id\", id);\n+            } else {\n+                writeTag(VIRTUAL_OBJECT_ID2);\n+                writeU2(\"id:2\", id);\n+            }\n+        } else if (value instanceof RawConstant) {\n+            RawConstant prim = (RawConstant) value;\n+            writeTag(RAW_CONSTANT);\n+            writeLong(\"primitive\", prim.getRawValue());\n+        } else if (value instanceof PrimitiveConstant) {\n+            PrimitiveConstant prim = (PrimitiveConstant) value;\n+            if (prim.getJavaKind() != kind) {\n+                throw error(\"primitive constant (%s) kind expected to be %s, got %s\", prim, kind, prim.getJavaKind());\n+            }\n+            long raw = prim.getRawValue();\n+            if (raw == 0) {\n+                writeTag(PRIMITIVE_0);\n+            } else if (raw >= Integer.MIN_VALUE && raw <= Integer.MAX_VALUE) {\n+                writeTag(PRIMITIVE4);\n+                int rawInt = (int) raw;\n+                writeInt(\"primitive4\", rawInt);\n+            } else {\n+                writeTag(PRIMITIVE8);\n+                writeLong(\"primitive8\", raw);\n+            }\n+        } else if (value instanceof IndirectHotSpotObjectConstantImpl) {\n+            if (JavaKind.Object != kind) {\n+                throw error(\"object constant (%s) kind expected to be Object, got %s\", value, kind);\n+            }\n+            IndirectHotSpotObjectConstantImpl obj = (IndirectHotSpotObjectConstantImpl) value;\n+            writeTag(JOBJECT);\n+            writeLong(\"jobject\", obj.getHandle());\n+        } else if (value instanceof DirectHotSpotObjectConstantImpl) {\n+            if (JavaKind.Object != kind) {\n+                throw error(\"object constant (%s) kind expected to be Object, got %s\", value, kind);\n+            }\n+            writeObjectID((DirectHotSpotObjectConstantImpl) value, OBJECT_ID, OBJECT_ID2);\n+        } else {\n+            throw error(\"unsupported type: \" + value.getClass());\n+        }\n+    }\n+\n+    private int writeObjectID(DirectHotSpotObjectConstantImpl value, Tag u1Tag, Tag u2Tag) {\n+        if (Services.IS_IN_NATIVE_IMAGE) {\n+            throw error(\"SVM object value cannot be installed in HotSpot code cache: %s\", value);\n+        }\n+        Object obj = value.object;\n+        if (obj == null) {\n+            throw error(\"direct object should not be null\");\n+        }\n+        IdentityBox key = new IdentityBox(obj);\n+        if (objects == null) {\n+            objects = new HashMap<>(8);\n+        }\n+        Integer idBox = objects.get(key);\n+        if (idBox == null) {\n+            idBox = objects.size();\n+            objects.put(key, idBox);\n+        }\n+        int id = idBox;\n+        if (isU1(id)) {\n+            writeTag(u1Tag);\n+            writeU1(\"id\", id);\n+        } else {\n+            writeTag(u2Tag);\n+            writeU2(\"id:2\", id);\n+        }\n+        return id;\n+    }\n+\n+    \/**\n+     * Returns {@code flag} if {@code condition == true} else {@code 0}.\n+     *\/\n+    private static int setIf(int flag, Object[] array) {\n+        return array != null && array.length > 0 ? flag : 0;\n+    }\n+\n+    \/**\n+     * Returns {@code flag} if {@code condition == true} else {@code 0}.\n+     *\/\n+    private static int setIf(int flag, boolean condition) {\n+        return condition ? flag : 0;\n+    }\n+\n+    \/**\n+     * Returns {@code flag} if {@code condition != 0} else {@code 0}.\n+     *\/\n+    private static int setIf(int flag, int condition) {\n+        return condition != 0 ? flag : 0;\n+    }\n+\n+    private static boolean isSet(int flags, int bit) {\n+        return (flags & bit) != 0;\n+    }\n+\n+    private void writeFrame(BytecodePosition pos, boolean fullInfo, int depth) {\n+        if (pos == null) {\n+            writeU2(\"depth\", depth);\n+            return;\n+        }\n+        writeFrame(pos.getCaller(), fullInfo, depth + 1);\n+        writeMethod(\"method\", pos.getMethod());\n+        writeInt(\"bci\", pos.getBCI());\n+        if (fullInfo) {\n+            BytecodeFrame f = (BytecodeFrame) pos;\n+            f.verifyInvariants();\n+            int numLocals = f.numLocals;\n+            int numStack = f.numStack;\n+            int numLocks = f.numLocks;\n+\n+            \/\/ @formatter:off\n+            int flags = setIf(HAS_LOCALS, numLocals) |\n+                        setIf(HAS_STACK, numStack) |\n+                        setIf(HAS_LOCKS, numLocks) |\n+                        setIf(DURING_CALL, f.duringCall) |\n+                        setIf(RETHROW_EXCEPTION, f.rethrowException);\n+            \/\/ @formatter:on\n+            writeU1(\"flags\", flags);\n+\n+            if (numLocals != 0) {\n+                writeU2(\"numLocals\", numLocals);\n+                for (int i = 0; i < numLocals; i++) {\n+                    JavaKind kind = f.getLocalValueKind(i);\n+                    writeBasicType(kind);\n+                    writeJavaValue(f.getLocalValue(i), kind);\n+                }\n+            }\n+            if (numStack != 0) {\n+                writeU2(\"numStack\", numStack);\n+                for (int i = 0; i < numStack; i++) {\n+                    JavaKind kind = f.getStackValueKind(i);\n+                    writeBasicType(kind);\n+                    writeJavaValue(f.getStackValue(i), kind);\n+                }\n+            }\n+            if (numLocks != 0) {\n+                writeU2(\"numLocks\", numLocks);\n+                for (int i = 0; i < numLocks; i++) {\n+                    StackLockValue lock = (StackLockValue) f.getLockValue(i);\n+                    writeBoolean(\"isEliminated\", lock.isEliminated());\n+                    writeJavaValue(lock.getOwner(), JavaKind.Object);\n+                    writeJavaValue(lock.getSlot(), JavaKind.Object);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void writeReferenceMap(ReferenceMap map) {\n+        HotSpotReferenceMap hsMap = (HotSpotReferenceMap) map;\n+        int length = hsMap.objects.length;\n+        writeU2(\"maxRegisterSize\", hsMap.maxRegisterSize);\n+        int derivedBaseLength = hsMap.derivedBase.length;\n+        int sizeInBytesLength = hsMap.sizeInBytes.length;\n+        if (derivedBaseLength != length || sizeInBytesLength != length) {\n+            throw error(\"arrays in reference map have different sizes: %d %d %d\", length, derivedBaseLength, sizeInBytesLength);\n+        }\n+        writeU2(\"referenceMap:length\", length);\n+        for (int i = 0; i < length; i++) {\n+            Location derived = hsMap.derivedBase[i];\n+            writeBoolean(\"hasDerived\", derived != null);\n+            int size = hsMap.sizeInBytes[i];\n+            if (size % 4 != 0) {\n+                throw error(\"invalid oop size in ReferenceMap: %d\", size);\n+            }\n+            writeU2(\"sizeInBytes\", size);\n+            writeLocation(hsMap.objects[i]);\n+            if (derived != null) {\n+                writeLocation(derived);\n+            }\n+        }\n+    }\n+\n+    private void writeLocation(Location loc) {\n+        writeRegister(loc.reg);\n+        writeU2(\"offset\", loc.offset);\n+    }\n+\n+    private void writeRegister(Register reg) {\n+        if (reg == null) {\n+            writeU2(\"register\", NO_REGISTER);\n+        } else {\n+            writeU2(\"register\", reg.number);\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotCompiledCodeStream.java","additions":1243,"deletions":0,"binary":false,"changes":1243,"status":"added"},{"patch":"@@ -57,4 +57,31 @@\n-    public HotSpotCompiledNmethod(String name, byte[] targetCode, int targetCodeSize, Site[] sites, Assumption[] assumptions, ResolvedJavaMethod[] methods, Comment[] comments, byte[] dataSection,\n-                    int dataSectionAlignment, DataPatch[] dataSectionPatches, boolean isImmutablePIC, int totalFrameSize, StackSlot deoptRescueSlot, HotSpotResolvedJavaMethod method, int entryBCI,\n-                    int id, long compileState, boolean hasUnsafeAccess) {\n-        super(name, targetCode, targetCodeSize, sites, assumptions, methods, comments, dataSection, dataSectionAlignment, dataSectionPatches, isImmutablePIC, totalFrameSize, deoptRescueSlot);\n+    public HotSpotCompiledNmethod(String name,\n+                    byte[] targetCode,\n+                    int targetCodeSize,\n+                    Site[] sites,\n+                    Assumption[] assumptions,\n+                    ResolvedJavaMethod[] methods,\n+                    Comment[] comments,\n+                    byte[] dataSection,\n+                    int dataSectionAlignment,\n+                    DataPatch[] dataSectionPatches,\n+                    boolean isImmutablePIC,\n+                    int totalFrameSize,\n+                    StackSlot deoptRescueSlot,\n+                    HotSpotResolvedJavaMethod method,\n+                    int entryBCI,\n+                    int id,\n+                    long compileState,\n+                    boolean hasUnsafeAccess) {\n+        super(name,\n+                        targetCode,\n+                        targetCodeSize,\n+                        sites,\n+                        assumptions,\n+                        methods,\n+                        comments,\n+                        dataSection,\n+                        dataSectionAlignment,\n+                        dataSectionPatches,\n+                        isImmutablePIC,\n+                        totalFrameSize,\n+                        deoptRescueSlot);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotCompiledNmethod.java","additions":31,"deletions":4,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.Collections;\n@@ -201,2 +200,1 @@\n-     * Handle to the {@code ConstantPool} VM object. The handle is in\n-     * {@code JVMCI::_metadata_handles}.\n+     * A {@code jmetadata} value that is a handle to {@code ConstantPool*} value.\n@@ -204,1 +202,1 @@\n-    private final long metadataHandle;\n+    private final long constantPoolHandle;\n@@ -210,1 +208,6 @@\n-     * Gets the JVMCI mirror from a HotSpot constant pool.The VM is responsible for ensuring that\n+     * Cache for {@link #getHolder()}.\n+     *\/\n+    private HotSpotResolvedObjectTypeImpl holder;\n+\n+    \/**\n+     * Gets the JVMCI mirror from a HotSpot constant pool. The VM is responsible for ensuring that\n@@ -216,2 +219,2 @@\n-     * @param metaspaceConstantPool a metaspace ConstantPool object\n-     * @return the {@link HotSpotConstantPool} corresponding to {@code metaspaceConstantPool}\n+     * @param constantPoolHandle a {@code jmetaspace} handle to a raw {@code ConstantPool*} value\n+     * @return the {@link HotSpotConstantPool} corresponding to {@code constantPoolHandle}\n@@ -221,2 +224,2 @@\n-    private static HotSpotConstantPool fromMetaspace(long metaspaceConstantPool) {\n-        return new HotSpotConstantPool(metaspaceConstantPool);\n+    private static HotSpotConstantPool fromMetaspace(long constantPoolHandle) {\n+        return new HotSpotConstantPool(constantPoolHandle);\n@@ -225,2 +228,2 @@\n-    private HotSpotConstantPool(long metadataHandle) {\n-        this.metadataHandle = metadataHandle;\n+    private HotSpotConstantPool(long constantPoolHandle) {\n+        this.constantPoolHandle = constantPoolHandle;\n@@ -228,1 +231,1 @@\n-        HandleCleaner.create(this, metadataHandle);\n+        HandleCleaner.create(this, constantPoolHandle);\n@@ -237,1 +240,4 @@\n-        return compilerToVM().getResolvedJavaType(this, config().constantPoolHolderOffset, false);\n+        if (holder == null) {\n+            holder = compilerToVM().getResolvedJavaType(this, config().constantPoolHolderOffset, false);\n+        }\n+        return holder;\n@@ -293,1 +299,4 @@\n-    long getMetaspaceConstantPool() {\n+    \/**\n+     * Gets the raw {@code ConstantPool*} value for the this constant pool.\n+     *\/\n+    long getConstantPoolPointer() {\n@@ -299,1 +308,1 @@\n-        return metadataHandle;\n+        return constantPoolHandle;\n@@ -311,1 +320,1 @@\n-        final long metaspaceConstantPoolTags = UNSAFE.getAddress(getMetaspaceConstantPool() + config.constantPoolTagsOffset);\n+        final long metaspaceConstantPoolTags = UNSAFE.getAddress(getConstantPoolPointer() + config.constantPoolTagsOffset);\n@@ -328,1 +337,1 @@\n-        return UNSAFE.getAddress(getMetaspaceConstantPool() + config().constantPoolSize + offset);\n+        return UNSAFE.getAddress(getConstantPoolPointer() + config().constantPoolSize + offset);\n@@ -340,1 +349,1 @@\n-        return UNSAFE.getInt(getMetaspaceConstantPool() + config().constantPoolSize + offset);\n+        return UNSAFE.getInt(getConstantPoolPointer() + config().constantPoolSize + offset);\n@@ -352,1 +361,1 @@\n-        return UNSAFE.getLong(getMetaspaceConstantPool() + config().constantPoolSize + offset);\n+        return UNSAFE.getLong(getConstantPoolPointer() + config().constantPoolSize + offset);\n@@ -364,1 +373,1 @@\n-        return UNSAFE.getFloat(getMetaspaceConstantPool() + config().constantPoolSize + offset);\n+        return UNSAFE.getFloat(getConstantPoolPointer() + config().constantPoolSize + offset);\n@@ -376,1 +385,1 @@\n-        return UNSAFE.getDouble(getMetaspaceConstantPool() + config().constantPoolSize + offset);\n+        return UNSAFE.getDouble(getConstantPoolPointer() + config().constantPoolSize + offset);\n@@ -388,1 +397,1 @@\n-        return UNSAFE.getInt(getMetaspaceConstantPool() + config().constantPoolSize + offset);\n+        return UNSAFE.getInt(getConstantPoolPointer() + config().constantPoolSize + offset);\n@@ -470,1 +479,1 @@\n-        final int refIndex = UNSAFE.getInt(getMetaspaceConstantPool() + config().constantPoolSize + offset);\n+        final int refIndex = UNSAFE.getInt(getConstantPoolPointer() + config().constantPoolSize + offset);\n@@ -515,1 +524,1 @@\n-        return UNSAFE.getInt(getMetaspaceConstantPool() + config().constantPoolLengthOffset);\n+        return UNSAFE.getInt(getConstantPoolPointer() + config().constantPoolLengthOffset);\n@@ -523,1 +532,1 @@\n-        return UNSAFE.getInt(getMetaspaceConstantPool() + config().constantPoolFlagsOffset);\n+        return UNSAFE.getInt(getConstantPoolPointer() + config().constantPoolFlagsOffset);\n@@ -693,2 +702,1 @@\n-                HotSpotResolvedObjectType holder = runtime().getMethodHandleClass();\n-                return new UnresolvedJavaMethod(name, signature, holder);\n+                return new UnresolvedJavaMethod(name, signature, runtime().getMethodHandleClass());\n@@ -698,2 +706,1 @@\n-                JavaType holder = getJavaType(type);\n-                return new UnresolvedJavaMethod(name, signature, holder);\n+                return new UnresolvedJavaMethod(name, signature, getJavaType(type));\n@@ -761,1 +768,1 @@\n-        JavaType holder = lookupType(holderIndex, opcode);\n+        JavaType fieldHolder = lookupType(holderIndex, opcode);\n@@ -763,1 +770,1 @@\n-        if (holder instanceof HotSpotResolvedObjectTypeImpl) {\n+        if (fieldHolder instanceof HotSpotResolvedObjectTypeImpl) {\n@@ -773,1 +780,1 @@\n-                return new UnresolvedJavaField(holder, lookupUtf8(getNameRefIndexAt(nameAndTypeIndex)), type);\n+                return new UnresolvedJavaField(fieldHolder, lookupUtf8(getNameRefIndexAt(nameAndTypeIndex)), type);\n@@ -781,1 +788,1 @@\n-            return new UnresolvedJavaField(holder, lookupUtf8(getNameRefIndexAt(nameAndTypeIndex)), type);\n+            return new UnresolvedJavaField(fieldHolder, lookupUtf8(getNameRefIndexAt(nameAndTypeIndex)), type);\n@@ -932,1 +939,1 @@\n-        final int sourceFileNameIndex = UNSAFE.getChar(getMetaspaceConstantPool() + config().constantPoolSourceFileNameIndexOffset);\n+        final int sourceFileNameIndex = UNSAFE.getChar(getConstantPoolPointer() + config().constantPoolSourceFileNameIndexOffset);\n@@ -941,2 +948,1 @@\n-        HotSpotResolvedObjectType holder = getHolder();\n-        return \"HotSpotConstantPool<\" + holder.toJavaName() + \">\";\n+        return \"HotSpotConstantPool<\" + getHolder().toJavaName() + \">\";\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotConstantPool.java","additions":42,"deletions":36,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -1,125 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.vm.ci.hotspot;\n-\n-import jdk.vm.ci.meta.JavaConstant;\n-import jdk.vm.ci.meta.JavaKind;\n-\n-\/**\n- * Represents a constant that was retrieved from a constant pool. Used to keep track of the constant\n- * pool slot for the constant.\n- *\/\n-public final class HotSpotConstantPoolObject implements JavaConstant {\n-\n-    public static JavaConstant forObject(HotSpotResolvedObjectType type, int cpi, JavaConstant object) {\n-        return new HotSpotConstantPoolObject(type, cpi, object);\n-    }\n-\n-    private final JavaConstant constant;\n-    private final HotSpotResolvedObjectType type;\n-    private final int cpi;\n-\n-    public HotSpotResolvedObjectType getCpType() {\n-        return type;\n-    }\n-\n-    public int getCpi() {\n-        return cpi;\n-    }\n-\n-    HotSpotConstantPoolObject(HotSpotResolvedObjectType type, int cpi, JavaConstant constant) {\n-        this.type = type;\n-        this.cpi = cpi;\n-        this.constant = constant;\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (o instanceof HotSpotConstantPoolObject) {\n-            HotSpotConstantPoolObject other = (HotSpotConstantPoolObject) o;\n-            return type.equals(other.type) && cpi == other.cpi && constant.equals(other.constant);\n-        }\n-        return false;\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return constant.hashCode() + cpi + type.hashCode();\n-    }\n-\n-    @Override\n-    public JavaKind getJavaKind() {\n-        return constant.getJavaKind();\n-    }\n-\n-    @Override\n-    public boolean isNull() {\n-        return constant.isNull();\n-    }\n-\n-    @Override\n-    public boolean isDefaultForKind() {\n-        return constant.isDefaultForKind();\n-    }\n-\n-    @Override\n-    public Object asBoxedPrimitive() {\n-        return constant.asBoxedPrimitive();\n-    }\n-\n-    @Override\n-    public int asInt() {\n-        return constant.asInt();\n-    }\n-\n-    @Override\n-    public boolean asBoolean() {\n-        return constant.asBoolean();\n-    }\n-\n-    @Override\n-    public long asLong() {\n-        return constant.asLong();\n-    }\n-\n-    @Override\n-    public float asFloat() {\n-        return constant.asFloat();\n-    }\n-\n-    @Override\n-    public double asDouble() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String toValueString() {\n-        return getCpType().getName() + getCpi();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return super.toString() + \"@\" + toValueString();\n-    }\n-\n-}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotConstantPoolObject.java","additions":0,"deletions":125,"binary":false,"changes":125,"status":"deleted"},{"patch":"@@ -167,4 +167,4 @@\n-            HotSpotResolvedObjectTypeImpl holder = (HotSpotResolvedObjectTypeImpl) hotspotField.getDeclaringClass();\n-            if (holder.isInitialized()) {\n-                return runtime().compilerToVm.readFieldValue(holder, (HotSpotResolvedObjectTypeImpl) hotspotField.getDeclaringClass(), hotspotField.getOffset(),\n-                                hotspotField.getType().getJavaKind());\n+            HotSpotResolvedObjectTypeImpl declaringType = (HotSpotResolvedObjectTypeImpl) hotspotField.getDeclaringClass();\n+            if (declaringType.isInitialized()) {\n+                return runtime().compilerToVm.readStaticFieldValue(declaringType, hotspotField.getOffset(),\n+                                hotspotField.getType().getJavaKind().getTypeChar());\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotConstantReflectionProvider.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -336,1 +336,0 @@\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotJDKReflection.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -267,0 +267,5 @@\n+        CodeSerializationTypeInfo(Boolean.class, false, \"Prepend the size and label of each element to the stream when \" +\n+                \"serializing HotSpotCompiledCode to verify both ends of the protocol agree on the format. \" +\n+                \"Defaults to true in non-product builds.\"),\n+        DumpSerializedCode(String.class, null, \"Dump serialized code during code installation for code whose simple \" +\n+                \"name (a stub) or fully qualified name (an nmethod) contains this option's value as a substring.\"),\n@@ -294,1 +299,1 @@\n-        private boolean isDefault = true;\n+        boolean isDefault = true;\n@@ -704,1 +709,1 @@\n-    synchronized HotSpotResolvedObjectTypeImpl fromMetaspace(long klassPointer, String signature) {\n+    synchronized HotSpotResolvedObjectTypeImpl fromMetaspace(long klassPointer) {\n@@ -715,1 +720,2 @@\n-            javaType = new HotSpotResolvedObjectTypeImpl(klassPointer, signature);\n+            String name = compilerToVm.getSignatureName(klassPointer);\n+            javaType = new HotSpotResolvedObjectTypeImpl(klassPointer, name);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIRuntime.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-            JavaConstant result = runtime().compilerToVm.readFieldValue(baseObject, null, initialDisplacement, readKind);\n+            JavaConstant result = runtime().compilerToVm.readFieldValue(baseObject, null, initialDisplacement, readKind.getTypeChar());\n@@ -112,1 +112,2 @@\n-            return runtime.getCompilerToVM().readFieldValue((HotSpotObjectConstantImpl) base, null, displacement, JavaKind.Object);\n+            HotSpotObjectConstantImpl hsBase = (HotSpotObjectConstantImpl) base;\n+            return runtime.getCompilerToVM().readFieldValue(hsBase, null, displacement, JavaKind.Object.getTypeChar());\n@@ -134,1 +135,2 @@\n-            JavaConstant res = runtime.getCompilerToVM().readFieldValue((HotSpotObjectConstantImpl) base, null, displacement, JavaKind.Object);\n+            HotSpotObjectConstantImpl hsBase = (HotSpotObjectConstantImpl) base;\n+            JavaConstant res = runtime.getCompilerToVM().readFieldValue(hsBase, null, displacement, JavaKind.Object.getTypeChar());\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotMemoryAccessProviderImpl.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-     * Reference to the C++ MethodData object.\n+     * A {@code MethodData*} value.\n@@ -167,1 +167,1 @@\n-    final long metaspaceMethodData;\n+    final long methodDataPointer;\n@@ -171,2 +171,2 @@\n-    HotSpotMethodData(long metaspaceMethodData, HotSpotResolvedJavaMethodImpl method) {\n-        this.metaspaceMethodData = metaspaceMethodData;\n+    HotSpotMethodData(long methodDataPointer, HotSpotResolvedJavaMethodImpl method) {\n+        this.methodDataPointer = methodDataPointer;\n@@ -181,1 +181,1 @@\n-        return UNSAFE.getInt(metaspaceMethodData + state.config.methodDataDataSize);\n+        return UNSAFE.getInt(methodDataPointer + state.config.methodDataDataSize);\n@@ -192,1 +192,1 @@\n-        final int extraDataLimit = UNSAFE.getInt(metaspaceMethodData + state.config.methodDataSize);\n+        final int extraDataLimit = UNSAFE.getInt(methodDataPointer + state.config.methodDataSize);\n@@ -215,1 +215,1 @@\n-        return UNSAFE.getByte(metaspaceMethodData + state.config.methodDataOopTrapHistoryOffset + reasonIndex) & 0xFF;\n+        return UNSAFE.getByte(methodDataPointer + state.config.methodDataOopTrapHistoryOffset + reasonIndex) & 0xFF;\n@@ -221,1 +221,1 @@\n-        return UNSAFE.getByte(metaspaceMethodData + state.config.methodDataOopTrapHistoryOffset + state.config.deoptReasonOSROffset + reasonIndex) & 0xFF;\n+        return UNSAFE.getByte(methodDataPointer + state.config.methodDataOopTrapHistoryOffset + state.config.deoptReasonOSROffset + reasonIndex) & 0xFF;\n@@ -225,1 +225,1 @@\n-        return UNSAFE.getInt(metaspaceMethodData + state.config.methodDataDecompiles);\n+        return UNSAFE.getInt(methodDataPointer + state.config.methodDataDecompiles);\n@@ -229,1 +229,1 @@\n-        return UNSAFE.getInt(metaspaceMethodData + state.config.methodDataOverflowRecompiles);\n+        return UNSAFE.getInt(methodDataPointer + state.config.methodDataOverflowRecompiles);\n@@ -233,1 +233,1 @@\n-        return UNSAFE.getInt(metaspaceMethodData + state.config.methodDataOverflowTraps);\n+        return UNSAFE.getInt(methodDataPointer + state.config.methodDataOverflowTraps);\n@@ -273,1 +273,1 @@\n-        return UNSAFE.getByte(metaspaceMethodData + fullOffsetInBytes) & 0xFF;\n+        return UNSAFE.getByte(methodDataPointer + fullOffsetInBytes) & 0xFF;\n@@ -278,1 +278,1 @@\n-        return UNSAFE.getShort(metaspaceMethodData + fullOffsetInBytes) & 0xFFFF;\n+        return UNSAFE.getShort(methodDataPointer + fullOffsetInBytes) & 0xFFFF;\n@@ -287,1 +287,1 @@\n-        return UNSAFE.getAddress(metaspaceMethodData + fullOffsetInBytes) & 0xFFFFFFFFL;\n+        return UNSAFE.getAddress(methodDataPointer + fullOffsetInBytes) & 0xFFFFFFFFL;\n@@ -301,1 +301,1 @@\n-        return (int) UNSAFE.getAddress(metaspaceMethodData + fullOffsetInBytes);\n+        return (int) UNSAFE.getAddress(methodDataPointer + fullOffsetInBytes);\n@@ -306,1 +306,1 @@\n-        return compilerToVM().getResolvedJavaMethod(null, metaspaceMethodData + fullOffsetInBytes);\n+        return compilerToVM().getResolvedJavaMethod(null, methodDataPointer + fullOffsetInBytes);\n@@ -311,1 +311,5 @@\n-        return compilerToVM().getResolvedJavaType(metaspaceMethodData + fullOffsetInBytes, false);\n+        long klassPointer = UNSAFE.getAddress(methodDataPointer + fullOffsetInBytes);\n+        if (klassPointer == 0) {\n+            return null;\n+        }\n+        return runtime().fromMetaspace(klassPointer);\n@@ -319,1 +323,1 @@\n-        return runtime().getCompilerToVM().isMature(metaspaceMethodData);\n+        return runtime().getCompilerToVM().isMature(methodDataPointer);\n@@ -716,1 +720,1 @@\n-            return HotSpotJVMCIRuntime.runtime().compilerToVm.methodDataProfileDataSize(data.metaspaceMethodData, position);\n+            return HotSpotJVMCIRuntime.runtime().compilerToVm.methodDataProfileDataSize(data.methodDataPointer, position);\n@@ -873,1 +877,1 @@\n-            return HotSpotJVMCIRuntime.runtime().compilerToVm.methodDataProfileDataSize(data.metaspaceMethodData, position);\n+            return HotSpotJVMCIRuntime.runtime().compilerToVm.methodDataProfileDataSize(data.methodDataPointer, position);\n@@ -884,1 +888,1 @@\n-        UNSAFE.putInt(metaspaceMethodData + state.config.methodDataIRSizeOffset, size);\n+        UNSAFE.putInt(methodDataPointer + state.config.methodDataIRSizeOffset, size);\n@@ -888,1 +892,1 @@\n-        return UNSAFE.getInt(metaspaceMethodData + state.config.methodDataIRSizeOffset);\n+        return UNSAFE.getInt(methodDataPointer + state.config.methodDataIRSizeOffset);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotMethodData.java","additions":26,"deletions":22,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-        int vmSize = HotSpotJVMCIRuntime.runtime().compilerToVm.methodDataProfileDataSize(data.metaspaceMethodData, position);\n+        int vmSize = HotSpotJVMCIRuntime.runtime().compilerToVm.methodDataProfileDataSize(data.methodDataPointer, position);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotMethodDataAccessor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -196,1 +196,3 @@\n-        return runtime().compilerToVm.readFieldValue(this, (HotSpotResolvedObjectTypeImpl) field.getDeclaringClass(), field.getOffset(), field.getType().getJavaKind());\n+        HotSpotResolvedObjectTypeImpl declaringClass = (HotSpotResolvedObjectTypeImpl) field.getDeclaringClass();\n+        char typeChar = field.getType().getJavaKind().getTypeChar();\n+        return runtime().compilerToVm.readFieldValue(this, declaringClass, field.getOffset(), typeChar);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotObjectConstantImpl.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,4 +35,4 @@\n-    private final Location[] objects;\n-    private final Location[] derivedBase;\n-    private final int[] sizeInBytes;\n-    private final int maxRegisterSize;\n+    final Location[] objects;\n+    final Location[] derivedBase;\n+    final int[] sizeInBytes;\n+    final int maxRegisterSize;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotReferenceMap.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n-            final long metaspaceAnnotations = UNSAFE.getAddress(holder.getMetaspaceKlass() + config.instanceKlassAnnotationsOffset);\n+            final long metaspaceAnnotations = UNSAFE.getAddress(holder.getKlassPointer() + config.instanceKlassAnnotationsOffset);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaFieldImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,2 +62,1 @@\n-     * Handle to the metaspace {@code Method} object. The handle is in\n-     * {@code JVMCI::_metadata_handles}.\n+     * A {@code jmetadata} value that is a handle to {@code Method*} value.\n@@ -65,1 +64,1 @@\n-    private final long metadataHandle;\n+    private final long methodHandle;\n@@ -97,3 +96,2 @@\n-        HotSpotResolvedObjectTypeImpl result = compilerToVM().getResolvedJavaType(metaspaceConstantPool + config.constantPoolHolderOffset, false);\n-        assert result != null;\n-        return result;\n+        long klassPointer = UNSAFE.getAddress(metaspaceConstantPool + config.constantPoolHolderOffset);\n+        return runtime().fromMetaspace(klassPointer);\n@@ -120,1 +118,1 @@\n-        this.metadataHandle = metaspaceHandle;\n+        this.methodHandle = metaspaceHandle;\n@@ -132,1 +130,1 @@\n-        if (metaspaceConstantPool == holder.getConstantPool().getMetaspaceConstantPool()) {\n+        if (metaspaceConstantPool == holder.getConstantPool().getConstantPoolPointer()) {\n@@ -152,1 +150,1 @@\n-        return UNSAFE.getAddress(getMetaspaceMethod() + config().methodConstMethodOffset);\n+        return UNSAFE.getAddress(getMethodPointer() + config().methodConstMethodOffset);\n@@ -171,1 +169,1 @@\n-            return that.getMetaspaceMethod() == getMetaspaceMethod();\n+            return getMethodPointer() == getMethodPointer();\n@@ -178,1 +176,1 @@\n-        return Long.hashCode(getMetaspaceMethod());\n+        return Long.hashCode(getMethodPointer());\n@@ -187,1 +185,1 @@\n-        return UNSAFE.getShort(getMetaspaceMethod() + config().methodFlagsOffset);\n+        return UNSAFE.getShort(getMethodPointer() + config().methodFlagsOffset);\n@@ -207,1 +205,1 @@\n-    public Constant getMetaspaceMethodConstant() {\n+    private Constant getMetaspaceMethodConstant() {\n@@ -211,1 +209,1 @@\n-    long getMetaspaceMethod() {\n+    long getMethodPointer() {\n@@ -221,1 +219,1 @@\n-        return metadataHandle;\n+        return methodHandle;\n@@ -234,1 +232,1 @@\n-        return UNSAFE.getInt(getMetaspaceMethod() + config().methodAccessFlagsOffset);\n+        return UNSAFE.getInt(getMethodPointer() + config().methodAccessFlagsOffset);\n@@ -427,1 +425,2 @@\n-        return compilerToVM().findUniqueConcreteMethod(((HotSpotResolvedObjectTypeImpl) receiver), this);\n+        HotSpotResolvedObjectTypeImpl hsReceiver = (HotSpotResolvedObjectTypeImpl) receiver;\n+        return compilerToVM().findUniqueConcreteMethod(hsReceiver, this);\n@@ -442,1 +441,1 @@\n-        return UNSAFE.getAddress(getMetaspaceMethod() + config.methodCodeOffset);\n+        return UNSAFE.getAddress(getMethodPointer() + config.methodCodeOffset);\n@@ -473,3 +472,3 @@\n-            long metaspaceMethodData = UNSAFE.getAddress(getMetaspaceMethod() + config().methodDataOffset);\n-            if (metaspaceMethodData != 0) {\n-                methodData = new HotSpotMethodData(metaspaceMethodData, this);\n+            long methodDataPointer = UNSAFE.getAddress(getMethodPointer() + config().methodDataOffset);\n+            if (methodDataPointer != 0) {\n+                methodData = new HotSpotMethodData(methodDataPointer, this);\n@@ -699,1 +698,1 @@\n-        int result = UNSAFE.getInt(getMetaspaceMethod() + config.methodVtableIndexOffset);\n+        int result = UNSAFE.getInt(getMethodPointer() + config.methodVtableIndexOffset);\n@@ -718,1 +717,1 @@\n-        return UNSAFE.getChar(getMetaspaceMethod() + config.methodIntrinsicIdOffset);\n+        return UNSAFE.getChar(getMethodPointer() + config.methodIntrinsicIdOffset);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethodImpl.java","additions":22,"deletions":23,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -25,2 +25,0 @@\n-import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;\n-\n@@ -48,0 +46,2 @@\n+    abstract HotSpotResolvedObjectTypeImpl getArrayType();\n+\n@@ -49,1 +49,1 @@\n-    public HotSpotResolvedObjectType getArrayClass() {\n+    public final HotSpotResolvedObjectType getArrayClass() {\n@@ -51,1 +51,1 @@\n-            arrayOfType = runtime().compilerToVm.getArrayType(this);\n+            arrayOfType = getArrayType();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaType.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-     * The Java class this type represents.\n+     * The {@code Klass*} of this type.\n@@ -71,1 +71,1 @@\n-    private final long metadataPointer;\n+    private final long klassPointer;\n@@ -80,0 +80,5 @@\n+\n+    \/**\n+     * Lazily initialized cache for {@link #getComponentType()}. Set to {@code this}, if this has no\n+     * component type (i.e., this is an non-array type).\n+     *\/\n@@ -101,2 +106,2 @@\n-    private static HotSpotResolvedObjectTypeImpl fromMetaspace(long klassPointer, String signature) {\n-        return runtime().fromMetaspace(klassPointer, signature);\n+    private static HotSpotResolvedObjectTypeImpl fromMetaspace(long klassPointer) {\n+        return runtime().fromMetaspace(klassPointer);\n@@ -112,1 +117,1 @@\n-     * @param metadataPointer the Klass* to create the mirror for\n+     * @param klass the {@code Klass*} for the type\n@@ -115,1 +120,1 @@\n-    HotSpotResolvedObjectTypeImpl(long metadataPointer, String name) {\n+    HotSpotResolvedObjectTypeImpl(long klass, String name) {\n@@ -117,2 +122,2 @@\n-        assert metadataPointer != 0;\n-        this.metadataPointer = metadataPointer;\n+        assert klass != 0;\n+        this.klassPointer = klass;\n@@ -130,1 +135,1 @@\n-     * Gets the metaspace Klass for this type.\n+     * Gets the {@code Klass*} for this type.\n@@ -132,1 +137,1 @@\n-    long getMetaspaceKlass() {\n+    long getKlassPointer() {\n@@ -142,1 +147,1 @@\n-        return metadataPointer;\n+        return klassPointer;\n@@ -156,1 +161,1 @@\n-        return UNSAFE.getInt(getMetaspaceKlass() + config.klassAccessFlagsOffset);\n+        return UNSAFE.getInt(getKlassPointer() + config.klassAccessFlagsOffset);\n@@ -219,1 +224,1 @@\n-                if (subklass == null || UNSAFE.getAddress(subklass.getMetaspaceKlass() + config.nextSiblingOffset) != 0) {\n+                if (subklass == null || UNSAFE.getAddress(subklass.getKlassPointer() + config.nextSiblingOffset) != 0) {\n@@ -251,1 +256,1 @@\n-        return UNSAFE.getLong(this.getMetaspaceKlass() + config().subklassOffset) == 0;\n+        return UNSAFE.getLong(this.getKlassPointer() + config().subklassOffset) == 0;\n@@ -393,1 +398,1 @@\n-        int miscFlags = UNSAFE.getChar(getMetaspaceKlass() + config.instanceKlassMiscFlagsOffset);\n+        int miscFlags = UNSAFE.getChar(getKlassPointer() + config.instanceKlassMiscFlagsOffset);\n@@ -400,1 +405,1 @@\n-        int miscFlags = UNSAFE.getChar(getMetaspaceKlass() + config.instanceKlassMiscFlagsOffset);\n+        int miscFlags = UNSAFE.getChar(getKlassPointer() + config.instanceKlassMiscFlagsOffset);\n@@ -412,1 +417,1 @@\n-        return UNSAFE.getByte(getMetaspaceKlass() + config().instanceKlassInitStateOffset) & 0xFF;\n+        return UNSAFE.getByte(getKlassPointer() + config().instanceKlassInitStateOffset) & 0xFF;\n@@ -486,1 +491,1 @@\n-        if (constantPool == null || !isArray() && UNSAFE.getAddress(getMetaspaceKlass() + config().instanceKlassConstantsOffset) != constantPool.getMetaspaceConstantPool()) {\n+        if (constantPool == null || !isArray() && UNSAFE.getAddress(getKlassPointer() + config().instanceKlassConstantsOffset) != constantPool.getConstantPoolPointer()) {\n@@ -524,2 +529,2 @@\n-        assert getMetaspaceKlass() != 0 : getName();\n-        return UNSAFE.getInt(getMetaspaceKlass() + config.klassLayoutHelperOffset);\n+        assert getKlassPointer() != 0 : getName();\n+        return UNSAFE.getInt(getKlassPointer() + config.klassLayoutHelperOffset);\n@@ -542,1 +547,1 @@\n-            } else if (curMethod.getMetaspaceMethod() == metaspaceMethod) {\n+            } else if (curMethod.getMethodPointer() == metaspaceMethod) {\n@@ -569,2 +574,2 @@\n-        int result = UNSAFE.getInt(getMetaspaceKlass() + config.klassVtableLengthOffset) \/ (config.vtableEntrySize \/ config.heapWordSize);\n-        assert result >= config.baseVtableLength() : UNSAFE.getInt(getMetaspaceKlass() + config.klassVtableLengthOffset) + \" \" + config.vtableEntrySize;\n+        int result = UNSAFE.getInt(getKlassPointer() + config.klassVtableLengthOffset) \/ (config.vtableEntrySize \/ config.heapWordSize);\n+        assert result >= config.baseVtableLength() : UNSAFE.getInt(getKlassPointer() + config.klassVtableLengthOffset) + \" \" + config.vtableEntrySize;\n@@ -638,1 +643,1 @@\n-        return getMetaspaceKlass() == that.getMetaspaceKlass();\n+        return getKlassPointer() == that.getKlassPointer();\n@@ -646,0 +651,5 @@\n+    @Override\n+    HotSpotResolvedObjectTypeImpl getArrayType() {\n+        return runtime().compilerToVm.getArrayType((char) 0, this);\n+    }\n+\n@@ -664,1 +674,1 @@\n-            final long metaspaceFields = UNSAFE.getAddress(getMetaspaceKlass() + config.instanceKlassFieldsOffset);\n+            final long metaspaceFields = UNSAFE.getAddress(getKlassPointer() + config.instanceKlassFieldsOffset);\n@@ -796,1 +806,1 @@\n-        final long metaspaceFields = UNSAFE.getAddress(getMetaspaceKlass() + config.instanceKlassFieldsOffset);\n+        final long metaspaceFields = UNSAFE.getAddress(getKlassPointer() + config.instanceKlassFieldsOffset);\n@@ -886,2 +896,2 @@\n-        return UnsafeAccess.UNSAFE.getAddress(getMetaspaceKlass() + config().classLoaderDataOffset) == UnsafeAccess.UNSAFE.getAddress(\n-                        otherMirror.getMetaspaceKlass() + config().classLoaderDataOffset);\n+        return UnsafeAccess.UNSAFE.getAddress(getKlassPointer() + config().classLoaderDataOffset) == UnsafeAccess.UNSAFE.getAddress(\n+                        otherMirror.getKlassPointer() + config().classLoaderDataOffset);\n@@ -915,1 +925,1 @@\n-        return UNSAFE.getInt(getMetaspaceKlass() + config.superCheckOffsetOffset);\n+        return UNSAFE.getInt(getKlassPointer() + config.superCheckOffsetOffset);\n@@ -1021,5 +1031,0 @@\n-\n-    private int getMiscFlags() {\n-        return UNSAFE.getInt(getMetaspaceKlass() + config().instanceKlassMiscFlagsOffset);\n-    }\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl.java","additions":39,"deletions":34,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;\n@@ -84,1 +85,1 @@\n-    public HotSpotResolvedObjectType getArrayClass() {\n+    HotSpotResolvedObjectTypeImpl getArrayType() {\n@@ -88,1 +89,1 @@\n-        return super.getArrayClass();\n+        return runtime().compilerToVm.getArrayType(getJavaKind().getTypeChar(), null);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedPrimitiveType.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,104 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.vm.ci.hotspot;\n-\n-import jdk.vm.ci.meta.JavaConstant;\n-import jdk.vm.ci.meta.JavaKind;\n-import jdk.vm.ci.meta.VMConstant;\n-import jdk.vm.ci.meta.Value;\n-import jdk.vm.ci.meta.ValueKind;\n-\n-public final class HotSpotSentinelConstant extends Value implements JavaConstant, VMConstant {\n-\n-    private final JavaKind javaKind;\n-\n-    public HotSpotSentinelConstant(ValueKind<?> valueKind, JavaKind javaKind) {\n-        super(valueKind);\n-        this.javaKind = javaKind;\n-    }\n-\n-    @Override\n-    public JavaKind getJavaKind() {\n-        return javaKind;\n-    }\n-\n-    @Override\n-    public boolean isNull() {\n-        return true;\n-    }\n-\n-    @Override\n-    public boolean isDefaultForKind() {\n-        return true;\n-    }\n-\n-    @Override\n-    public Object asBoxedPrimitive() {\n-        throw new IllegalArgumentException();\n-    }\n-\n-    @Override\n-    public int asInt() {\n-        throw new IllegalArgumentException();\n-    }\n-\n-    @Override\n-    public boolean asBoolean() {\n-        throw new IllegalArgumentException();\n-    }\n-\n-    @Override\n-    public long asLong() {\n-        throw new IllegalArgumentException();\n-    }\n-\n-    @Override\n-    public float asFloat() {\n-        throw new IllegalArgumentException();\n-    }\n-\n-    @Override\n-    public double asDouble() {\n-        throw new IllegalArgumentException();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return JavaConstant.toString(this);\n-    }\n-\n-    @Override\n-    public String toValueString() {\n-        return \"sentinel\";\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return 13;\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        return o instanceof HotSpotSentinelConstant;\n-    }\n-}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotSentinelConstant.java","additions":0,"deletions":104,"binary":false,"changes":104,"status":"deleted"},{"patch":"@@ -102,1 +102,1 @@\n-                    dos.writeLong(((HotSpotResolvedJavaMethodImpl) method).getMetaspaceMethod());\n+                    dos.writeLong(((HotSpotResolvedJavaMethodImpl) method).getMethodPointer());\n@@ -118,1 +118,1 @@\n-                    dos.writeLong(((HotSpotResolvedObjectTypeImpl) type).getMetaspaceKlass());\n+                    dos.writeLong(((HotSpotResolvedObjectTypeImpl) type).getKlassPointer());\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotSpeculationEncoding.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.util.Arrays;\n-import java.util.ArrayList;\n@@ -55,2 +53,2 @@\n-     * Helper methods for managing JFR CompilerPhase events.\n-     * The events are defined in {see @code src\/share\/jfr\/metadata\/metadata.xml}.\n+     * Helper methods for managing JFR CompilerPhase events. The events are defined in {see @code\n+     * src\/share\/jfr\/metadata\/metadata.xml}.\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/JFR.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * The marker interface for an object which wraps HotSpot Metadata.\n+ * The marker interface for an object which wraps a HotSpot Metaspace object.\n@@ -29,0 +29,6 @@\n+\n+    \/**\n+     * Gets the raw pointer to the {@code Metaspace} object.\n+     *\n+     * @return a {@code Klass*}, {@code Method*} or {@code ConstantPool*} value\n+     *\/\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/MetaspaceObject.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -98,0 +98,5 @@\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"AssumptionResult<%s, assumptions=%s>\", result, Arrays.toString(assumptions));\n+        }\n@@ -105,1 +110,1 @@\n-        private ResolvedJavaType receiverType;\n+        public final ResolvedJavaType receiverType;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.meta\/src\/jdk\/vm\/ci\/meta\/Assumptions.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -304,0 +304,4 @@\n+    static PrimitiveConstant forPrimitive(char typeChar, long rawValue) {\n+        return forPrimitive(JavaKind.fromPrimitiveOrVoidTypeChar(typeChar), rawValue);\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.meta\/src\/jdk\/vm\/ci\/meta\/JavaConstant.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,0 +53,4 @@\n+    public long getRawValue() {\n+        return primitive;\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.meta\/src\/jdk\/vm\/ci\/meta\/PrimitiveConstant.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-        return CTVM.installCode(target, compiledCode, code, failedSpeculationsAddress, speculations);\n+        return CTVM.installCode(compiledCode, code, failedSpeculationsAddress, speculations);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/common\/patches\/jdk.internal.vm.ci\/jdk\/vm\/ci\/hotspot\/CompilerToVMHelper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-    @Test(expected = NullPointerException.class)\n+    @Test(expected = JVMCIError.class)\n@@ -137,1 +137,1 @@\n-    @Test(expected = NullPointerException.class)\n+    @Test(expected = JVMCIError.class)\n@@ -142,1 +142,1 @@\n-    @Test(expected = NullPointerException.class)\n+    @Test(expected = JVMCIError.class)\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/errors\/TestInvalidCompilationResult.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-    @Test(expected = NullPointerException.class)\n+    @Test(expected = JVMCIError.class)\n@@ -78,1 +78,1 @@\n-    @Test(expected = JVMCIError.class)\n+    @Test(expected = ClassCastException.class)\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/errors\/TestInvalidOopMap.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}