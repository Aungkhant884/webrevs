{"files":[{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/shared\/gcLogPrecious.hpp\"\n@@ -38,0 +39,2 @@\n+    _enqueued_bytes(0),\n+    _warned_sync_unmapping(false),\n@@ -53,0 +56,1 @@\n+      _enqueued_bytes -= page->size();\n@@ -60,0 +64,36 @@\n+bool XUnmapper::try_enqueue(XPage* page) {\n+  if (ZVerifyViews) {\n+    \/\/ Asynchronous unmap and destroy is not supported with ZVerifyViews\n+    return false;\n+  }\n+\n+  \/\/ Enqueue for asynchronous unmap and destroy\n+  XLocker<XConditionLock> locker(&_lock);\n+  if (is_saturated()) {\n+    \/\/ The unmapper thread is lagging behind and is unable to unmap memory fast enough\n+    if (!_warned_sync_unmapping) {\n+      _warned_sync_unmapping = true;\n+      log_warning_p(gc)(\"WARNING: Encountered synchronous unmapping because asynchronous unmapping could not keep up\");\n+    }\n+    log_debug(gc, unmap)(\"Synchronous unmapping \" SIZE_FORMAT \"M page\", page->size() \/ M);\n+    return false;\n+  }\n+\n+  log_trace(gc, unmap)(\"Asynchronous unmapping \" SIZE_FORMAT \"M page (\" SIZE_FORMAT \"M \/ \" SIZE_FORMAT \"M enqueued)\",\n+                       page->size() \/ M, _enqueued_bytes \/ M, queue_capacity() \/ M);\n+\n+  _queue.insert_last(page);\n+  _enqueued_bytes += page->size();\n+  _lock.notify_all();\n+\n+  return true;\n+}\n+\n+size_t XUnmapper::queue_capacity() const {\n+  return align_up<size_t>(_page_allocator->max_capacity() * ZAsyncUnmappingLimit \/ 100.0, XGranuleSize);\n+}\n+\n+bool XUnmapper::is_saturated() const {\n+  return _enqueued_bytes >= queue_capacity();\n+}\n+\n@@ -73,3 +113,2 @@\n-  \/\/ Asynchronous unmap and destroy is not supported with ZVerifyViews\n-  if (ZVerifyViews) {\n-    \/\/ Immediately unmap and destroy\n+  if (!try_enqueue(page)) {\n+    \/\/ Synchronously unmap and destroy\n@@ -77,5 +116,0 @@\n-  } else {\n-    \/\/ Enqueue for asynchronous unmap and destroy\n-    XLocker<XConditionLock> locker(&_lock);\n-    _queue.insert_last(page);\n-    _lock.notify_all();\n","filename":"src\/hotspot\/share\/gc\/x\/xUnmapper.cpp","additions":42,"deletions":8,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+  size_t                _enqueued_bytes;\n+  bool                  _warned_sync_unmapping;\n@@ -42,0 +44,3 @@\n+  bool try_enqueue(XPage* page);\n+  size_t queue_capacity() const;\n+  bool is_saturated() const;\n","filename":"src\/hotspot\/share\/gc\/x\/xUnmapper.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -64,0 +64,7 @@\n+  product(double, ZAsyncUnmappingLimit, 100.0, DIAGNOSTIC,                  \\\n+          \"Specify the max amount (percentage of max heap size) of async \"  \\\n+          \"unmapping that can be in-flight before unmapping requests are \"  \\\n+          \"temporarily forced to be synchronous instead. \"                  \\\n+          \"The default means after an amount of pages proportional to the \" \\\n+          \"max capacity is enqueued, we resort to synchronous unmapping.\")  \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/z\/shared\/z_shared_globals.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/shared\/gcLogPrecious.hpp\"\n@@ -38,0 +39,2 @@\n+    _enqueued_bytes(0),\n+    _warned_sync_unmapping(false),\n@@ -53,0 +56,1 @@\n+      _enqueued_bytes -= page->size();\n@@ -60,0 +64,31 @@\n+bool ZUnmapper::try_enqueue(ZPage* page) {\n+  \/\/ Enqueue for asynchronous unmap and destroy\n+  ZLocker<ZConditionLock> locker(&_lock);\n+  if (is_saturated()) {\n+    \/\/ The unmapper thread is lagging behind and is unable to unmap memory fast enough\n+    if (!_warned_sync_unmapping) {\n+      _warned_sync_unmapping = true;\n+      log_warning_p(gc)(\"WARNING: Encountered synchronous unmapping because asynchronous unmapping could not keep up\");\n+    }\n+    log_debug(gc, unmap)(\"Synchronous unmapping \" SIZE_FORMAT \"M page\", page->size() \/ M);\n+    return false;\n+  }\n+\n+  log_trace(gc, unmap)(\"Asynchronous unmapping \" SIZE_FORMAT \"M page (\" SIZE_FORMAT \"M \/ \" SIZE_FORMAT \"M enqueued)\",\n+                       page->size() \/ M, _enqueued_bytes \/ M, queue_capacity() \/ M);\n+\n+  _queue.insert_last(page);\n+  _enqueued_bytes += page->size();\n+  _lock.notify_all();\n+\n+  return true;\n+}\n+\n+size_t ZUnmapper::queue_capacity() const {\n+  return align_up<size_t>(_page_allocator->max_capacity() * ZAsyncUnmappingLimit \/ 100.0, ZGranuleSize);\n+}\n+\n+bool ZUnmapper::is_saturated() const {\n+  return _enqueued_bytes >= queue_capacity();\n+}\n+\n@@ -73,4 +108,4 @@\n-  \/\/ Enqueue for asynchronous unmap and destroy\n-  ZLocker<ZConditionLock> locker(&_lock);\n-  _queue.insert_last(page);\n-  _lock.notify_all();\n+  if (!try_enqueue(page)) {\n+    \/\/ Synchronously unmap and destroy\n+    do_unmap_and_destroy_page(page);\n+  }\n","filename":"src\/hotspot\/share\/gc\/z\/zUnmapper.cpp","additions":39,"deletions":4,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+  size_t                _enqueued_bytes;\n+  bool                  _warned_sync_unmapping;\n@@ -42,0 +44,3 @@\n+  bool try_enqueue(ZPage* page);\n+  size_t queue_capacity() const;\n+  bool is_saturated() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zUnmapper.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -200,0 +200,1 @@\n+  LOG_TAG(unmap) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}