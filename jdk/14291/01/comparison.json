{"files":[{"patch":"@@ -757,1 +757,0 @@\n-  template(serializeSavedPropertiesToByteArray_name,   \"serializeSavedPropertiesToByteArray\")                     \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"runtime\/arguments.hpp\"\n@@ -40,0 +41,1 @@\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n@@ -48,3 +50,0 @@\n-jbyte* JVMCIEnv::_serialized_saved_properties = nullptr;\n-int JVMCIEnv::_serialized_saved_properties_len = 0;\n-\n@@ -120,17 +119,9 @@\n-jbyte* JVMCIEnv::get_serialized_saved_properties(int& props_len, TRAPS) {\n-  jbyte* props = _serialized_saved_properties;\n-  if (props == nullptr) {\n-    \/\/ load VMSupport\n-    Symbol* klass = vmSymbols::jdk_internal_vm_VMSupport();\n-    Klass* k = SystemDictionary::resolve_or_fail(klass, true, CHECK_NULL);\n-\n-    InstanceKlass* ik = InstanceKlass::cast(k);\n-    if (ik->should_be_initialized()) {\n-      ik->initialize(CHECK_NULL);\n-    }\n-\n-    \/\/ invoke the serializeSavedPropertiesToByteArray method\n-    JavaValue result(T_OBJECT);\n-    JavaCallArguments args;\n-\n-    Symbol* signature = vmSymbols::void_byte_array_signature();\n+void JVMCIEnv::init_saved_properties(JVMCI_TRAPS) {\n+  JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n+  if (is_hotspot()) {\n+    JavaCallArguments jargs;\n+    jargs.push_long((jlong) Arguments::system_properties());\n+    jargs.push_int(SystemProperty::next_offset_in_bytes());\n+    jargs.push_int(SystemProperty::key_offset_in_bytes());\n+    jargs.push_int(PathString::value_offset_in_bytes());\n+    JavaValue result(T_VOID);\n@@ -138,18 +129,3 @@\n-                           ik,\n-                           vmSymbols::serializeSavedPropertiesToByteArray_name(),\n-                           signature,\n-                           &args,\n-                           CHECK_NULL);\n-\n-    oop res = result.get_oop();\n-    assert(res->is_typeArray(), \"must be\");\n-    assert(TypeArrayKlass::cast(res->klass())->element_type() == T_BYTE, \"must be\");\n-    typeArrayOop ba = typeArrayOop(res);\n-    props_len = ba->length();\n-\n-    \/\/ Copy serialized saved properties from HotSpot object into C heap\n-    props = NEW_C_HEAP_ARRAY(jbyte, props_len, mtJVMCI);\n-    memcpy(props, ba->byte_at_addr(0), props_len);\n-\n-    _serialized_saved_properties_len = props_len;\n-    _serialized_saved_properties = props;\n+                           HotSpotJVMCI::Services::klass(),\n+                           vmSymbols::initializeSavedProperties_name(),\n+                           vmSymbols::initializeSavedProperties_signature(), &jargs, CHECK);\n@@ -157,30 +133,16 @@\n-    props_len = _serialized_saved_properties_len;\n-  }\n-  return props;\n-}\n-\n-void JVMCIEnv::copy_saved_properties(jbyte* properties, int properties_len, JVMCI_TRAPS) {\n-  assert(!is_hotspot(), \"can only copy saved properties from HotSpot to native image\");\n-  JavaThread* thread = JavaThread::current(); \/\/ For exception macros.\n-\n-  \/\/ Copy native buffer into shared library object\n-  JVMCIPrimitiveArray buf = new_byteArray(properties_len, this);\n-  if (has_pending_exception()) {\n-    _runtime->fatal_exception(JVMCIENV, \"Error in copy_saved_properties\");\n-  }\n-  copy_bytes_from(properties, buf, 0, properties_len);\n-  if (has_pending_exception()) {\n-    _runtime->fatal_exception(JVMCIENV, \"Error in copy_saved_properties\");\n-  }\n-\n-  \/\/ Initialize saved properties in shared library\n-  jclass servicesClass = JNIJVMCI::Services::clazz();\n-  jmethodID initializeSavedProperties = JNIJVMCI::Services::initializeSavedProperties_method();\n-  bool exception = false;\n-  {\n-    JNIAccessMark jni(this, thread);\n-    jni()->CallStaticVoidMethod(servicesClass, initializeSavedProperties, buf.as_jobject());\n-    exception = jni()->ExceptionCheck();\n-  }\n-  if (exception) {\n-    _runtime->fatal_exception(JVMCIENV, \"Error calling jdk.vm.ci.services.Services.initializeSavedProperties\");\n+    \/\/ Initialize saved properties in shared library\n+    jclass servicesClass = JNIJVMCI::Services::clazz();\n+    jmethodID initializeSavedProperties = JNIJVMCI::Services::initializeSavedProperties_method();\n+    bool exception = false;\n+    {\n+      JNIAccessMark jni(this, THREAD);\n+      jni()->CallStaticVoidMethod(servicesClass, initializeSavedProperties,\n+        Arguments::system_properties(),\n+        SystemProperty::next_offset_in_bytes(),\n+        SystemProperty::key_offset_in_bytes(),\n+        PathString::value_offset_in_bytes());\n+      exception = jni()->ExceptionCheck();\n+    }\n+    if (exception) {\n+      _runtime->fatal_exception(JVMCIENV, \"Error calling jdk.vm.ci.services.Services.initializeSavedProperties\");\n+    }\n@@ -1940,1 +1902,1 @@\n-#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args)\n+#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName)\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":31,"deletions":69,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -186,6 +186,0 @@\n-  \/\/ Used by copy_saved_properties() to avoid OutOfMemoryErrors when\n-  \/\/ initializing a libjvmci runtime in low HotSpot heap conditions.\n-  \/\/ Must hold JVMCI_lock when initializing.\n-  static jbyte* _serialized_saved_properties;\n-  static int _serialized_saved_properties_len;\n-\n@@ -240,7 +234,2 @@\n-  \/\/ Gets the serialized saved properties from the HotSpot heap.\n-  \/\/ The length of the returned array is saved in `len`.\n-  jbyte* get_serialized_saved_properties(int& len, TRAPS);\n-\n-  \/\/ Initializes Services.savedProperties in the shared library from the given\n-  \/\/ properties in the format produced by `get_serialized_saved_properties`.\n-  void copy_saved_properties(jbyte* properties, int properties_len, JVMCI_TRAPS);\n+  \/\/ Initializes Services.savedProperties.\n+  void init_saved_properties(JVMCI_TRAPS);\n@@ -512,1 +501,1 @@\n-#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args)\n+#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName)\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.hpp","additions":3,"deletions":14,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n-#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args)\n+#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName)\n@@ -157,1 +157,1 @@\n-#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args) \\\n+#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName) \\\n@@ -257,1 +257,1 @@\n-#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args)\n+#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName)\n@@ -396,1 +396,1 @@\n-#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args) \\\n+#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName) \\\n@@ -586,1 +586,1 @@\n-#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args)\n+#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName)\n@@ -692,1 +692,1 @@\n-#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args) \\\n+#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName) \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    jvmci_method(CallStaticVoidMethod, GetStaticMethodID, call_static, void, Services, initializeSavedProperties, byte_array_void_signature, (JVMCIObject serializedProperties)) \\\n+    jvmci_method(CallStaticVoidMethod, GetStaticMethodID, call_static, void, Services, initializeSavedProperties, initializeSavedProperties_signature) \\\n@@ -163,1 +163,1 @@\n-    jvmci_method(CallStaticObjectMethod, GetStaticMethodID, call_static, JVMCIObject, JavaConstant, forPrimitive, forPrimitive_signature, (JVMCIObject kind, jlong value, JVMCI_TRAPS)) \\\n+    jvmci_method(CallStaticObjectMethod, GetStaticMethodID, call_static, JVMCIObject, JavaConstant, forPrimitive, forPrimitive_signature) \\\n@@ -203,8 +203,8 @@\n-    jvmci_method(CallNonvirtualObjectMethod, GetMethodID, call_special, JVMCIObject, HotSpotJVMCIRuntime, compileMethod, compileMethod_signature, (JVMCIObject runtime, JVMCIObject method, int entry_bci, jlong env, int id)) \\\n-    jvmci_method(CallNonvirtualObjectMethod, GetMethodID, call_special, JVMCIObject, HotSpotJVMCIRuntime, isGCSupported, int_bool_signature, (JVMCIObject runtime, int gcIdentifier)) \\\n-    jvmci_method(CallNonvirtualVoidMethod, GetMethodID, call_special, void, HotSpotJVMCIRuntime, bootstrapFinished, void_method_signature, (JVMCIObject runtime, JVMCI_TRAPS)) \\\n-    jvmci_method(CallNonvirtualVoidMethod, GetMethodID, call_special, void, HotSpotJVMCIRuntime, shutdown, void_method_signature, (JVMCIObject runtime)) \\\n-    jvmci_method(CallStaticObjectMethod, GetStaticMethodID, call_static, JVMCIObject, HotSpotJVMCIRuntime, runtime, runtime_signature, (JVMCI_TRAPS)) \\\n-    jvmci_method(CallObjectMethod, GetMethodID, call_virtual, JVMCIObject, HotSpotJVMCIRuntime, getCompiler, getCompiler_signature, (JVMCIObject runtime, JVMCI_TRAPS)) \\\n-    jvmci_method(CallStaticObjectMethod, GetStaticMethodID, call_static, JVMCIObject, HotSpotJVMCIRuntime, exceptionToString, exceptionToString_signature, (JVMCIObject object, bool toString, bool stackTrace, JVMCI_TRAPS)) \\\n-    jvmci_method(CallStaticVoidMethod, GetStaticMethodID, call_static, void, HotSpotJVMCIRuntime, postTranslation, object_void_signature, (JVMCIObject object, JVMCI_TRAPS)) \\\n+    jvmci_method(CallNonvirtualObjectMethod, GetMethodID, call_special, JVMCIObject, HotSpotJVMCIRuntime, compileMethod, compileMethod_signature) \\\n+    jvmci_method(CallNonvirtualObjectMethod, GetMethodID, call_special, JVMCIObject, HotSpotJVMCIRuntime, isGCSupported, int_bool_signature) \\\n+    jvmci_method(CallNonvirtualVoidMethod, GetMethodID, call_special, void, HotSpotJVMCIRuntime, bootstrapFinished, void_method_signature) \\\n+    jvmci_method(CallNonvirtualVoidMethod, GetMethodID, call_special, void, HotSpotJVMCIRuntime, shutdown, void_method_signature) \\\n+    jvmci_method(CallStaticObjectMethod, GetStaticMethodID, call_static, JVMCIObject, HotSpotJVMCIRuntime, runtime, runtime_signature) \\\n+    jvmci_method(CallObjectMethod, GetMethodID, call_virtual, JVMCIObject, HotSpotJVMCIRuntime, getCompiler, getCompiler_signature) \\\n+    jvmci_method(CallStaticObjectMethod, GetStaticMethodID, call_static, JVMCIObject, HotSpotJVMCIRuntime, exceptionToString, exceptionToString_signature) \\\n+    jvmci_method(CallStaticVoidMethod, GetStaticMethodID, call_static, void, HotSpotJVMCIRuntime, postTranslation, object_void_signature) \\\n@@ -218,2 +218,2 @@\n-    jvmci_method(CallStaticObjectMethod, GetStaticMethodID, call_static, JVMCIObject, JVMCI, getRuntime, getRuntime_signature, (JVMCI_TRAPS)) \\\n-    jvmci_method(CallStaticObjectMethod, GetStaticMethodID, call_static, JVMCIObject, JVMCI, initializeRuntime, initializeRuntime_signature, (JVMCI_TRAPS)) \\\n+    jvmci_method(CallStaticObjectMethod, GetStaticMethodID, call_static, JVMCIObject, JVMCI, getRuntime, getRuntime_signature) \\\n+    jvmci_method(CallStaticObjectMethod, GetStaticMethodID, call_static, JVMCIObject, JVMCI, initializeRuntime, initializeRuntime_signature) \\\n@@ -226,1 +226,1 @@\n-    jvmci_method(CallObjectMethod, GetMethodID, call_virtual, JVMCIObject, Class, getName, void_string_signature, (JVMCI_TRAPS)) \\\n+    jvmci_method(CallObjectMethod, GetMethodID, call_virtual, JVMCIObject, Class, getName, void_string_signature) \\\n@@ -229,2 +229,2 @@\n-    jvmci_method(CallStaticIntMethod, GetStaticMethodID, call_static, int, VMSupport, encodeThrowable, encodeThrowable_signature, (JVMCIObject throwable, jlong buffer, int buffer_size)) \\\n-    jvmci_method(CallStaticVoidMethod, GetStaticMethodID, call_static, void, VMSupport, decodeAndThrowThrowable, decodeAndThrowThrowable_signature, (jlong buffer)) \\\n+    jvmci_method(CallStaticIntMethod, GetStaticMethodID, call_static, int, VMSupport, encodeThrowable, encodeThrowable_signature) \\\n+    jvmci_method(CallStaticVoidMethod, GetStaticMethodID, call_static, void, VMSupport, decodeAndThrowThrowable, decodeAndThrowThrowable_signature) \\\n@@ -345,1 +345,1 @@\n-#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, simpleClassName, methodName, signatureSymbolName, args)\n+#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, simpleClassName, methodName, signatureSymbolName)\n@@ -438,1 +438,1 @@\n-#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args) \\\n+#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName)       \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.hpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1402,3 +1402,0 @@\n-  int properties_len = 0;\n-  jbyte* properties = nullptr;\n-\n@@ -1468,9 +1465,1 @@\n-    if (!JVMCIENV->is_hotspot()) {\n-      Handle properties_exception;\n-      properties = JVMCIENV->get_serialized_saved_properties(properties_len, THREAD);\n-      if (JVMCIEnv::transfer_pending_exception_to_jni(THREAD, nullptr, JVMCIENV)) {\n-        JVMCI_event_1(\"error initializing system properties for JVMCI runtime %d\", _id);\n-        return;\n-      }\n-      JVMCIENV->copy_saved_properties(properties, properties_len, JVMCI_CHECK);\n-    }\n+    JVMCIENV->init_saved_properties(JVMCI_CHECK);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -106,0 +106,1 @@\n+  template(initializeSavedProperties_signature,                   \"(JIII)V\")                                                              \\\n","filename":"src\/hotspot\/share\/jvmci\/vmSymbols_jvmci.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -78,0 +78,3 @@\n+\n+  \/\/ for JVMCIEnv::init_saved_properties\n+  static int value_offset_in_bytes()  { return (int)offset_of(PathString, _value);  }\n@@ -139,0 +142,4 @@\n+\n+  \/\/ for JVMCIEnv::init_saved_properties\n+  static int key_offset_in_bytes()  { return (int)offset_of(SystemProperty, _key);  }\n+  static int next_offset_in_bytes() { return (int)offset_of(SystemProperty, _next); }\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -236,0 +236,2 @@\n+    \/\/ This is read directly by JVMCIEnv::get_serialized_saved_properties\n+    \/\/ which expects it to be a HashMap.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/VM.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-     * @return a Properties instance initialized with all of the properties\n+     * @return a Map instance initialized with all of the properties\n@@ -276,1 +276,1 @@\n-         * Return a Properties instance of the command line and VM options\n+         * Return a HashMap instance of the command line and VM options\n@@ -278,1 +278,1 @@\n-         * The Properties instance is sized to include the fixed properties.\n+         * The HashMap instance is sized to include the fixed properties.\n@@ -280,1 +280,1 @@\n-         * @return return a Properties instance of the command line and VM options\n+         * @return return a HashMap instance of the command line and VM options\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/SystemProps.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -104,13 +104,0 @@\n-    \/**\n-     * Serializes {@link VM#getSavedProperties()} to a byte array.\n-     *\n-     * Used by JVMCI to copy properties into libjvmci.\n-     *\/\n-    public static byte[] serializeSavedPropertiesToByteArray() throws IOException {\n-        Properties props = new Properties();\n-        for (var e : VM.getSavedProperties().entrySet()) {\n-            props.put(e.getKey(), e.getValue());\n-        }\n-        return serializePropertiesToByteArray(props);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/VMSupport.java","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -281,0 +281,1 @@\n+        jdk.internal.vm.ci,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.util.OperatingSystem;\n@@ -36,2 +37,2 @@\n-    public final boolean linuxOs = Services.getSavedProperty(\"os.name\", \"\").startsWith(\"Linux\");\n-    public final boolean macOs = Services.getSavedProperty(\"os.name\", \"\").startsWith(\"Mac\");\n+    public final boolean linuxOs = OperatingSystem.isLinux();\n+    public final boolean macOs = OperatingSystem.isMacOS();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/code\/TargetDescription.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.util.Architecture;\n@@ -46,2 +47,0 @@\n-    private final String osArch = getHostArchitectureName();\n-\n@@ -60,1 +59,1 @@\n-        String arch = Services.getSavedProperty(\"os.arch\");\n+        Architecture arch = Architecture.current();\n@@ -62,5 +61,2 @@\n-            case \"x86_64\":\n-                return \"amd64\";\n-\n-            default:\n-                return arch;\n+            case X64: return \"amd64\";\n+            default:  return arch.name().toLowerCase();\n@@ -137,1 +133,1 @@\n-    final int runtimeCallStackSize = getConstant(\"frame::arg_reg_save_area_bytes\", Integer.class, osArch.equals(\"amd64\") ? null : 0);\n+    final int runtimeCallStackSize = getConstant(\"frame::arg_reg_save_area_bytes\", Integer.class, Architecture.isX64() ? null : 0);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.util.OperatingSystem;\n@@ -38,1 +39,1 @@\n-    final boolean windowsOs = Services.getSavedProperty(\"os.name\", \"\").startsWith(\"Windows\");\n+    final boolean windowsOs = OperatingSystem.isWindows();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/amd64\/AMD64HotSpotVMConfig.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.util.OperatingSystem;\n@@ -40,1 +41,1 @@\n-    final boolean linuxOs = Services.getSavedProperty(\"os.name\", \"\").startsWith(\"Linux\");\n+    final boolean linuxOs = OperatingSystem.isLinux();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/riscv64\/RISCV64HotSpotVMConfig.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,0 +42,3 @@\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.util.Architecture;\n+import jdk.internal.util.OperatingSystem;\n@@ -74,1 +77,1 @@\n-     * In a native image, this field is initialized by {@link #initializeSavedProperties(byte[])}.\n+     * This field is initialized by {@link #initializeSavedProperties}.\n@@ -90,1 +93,6 @@\n-     * Gets an unmodifiable copy of the system properties saved when {@link System} is initialized.\n+     * Gets an unmodifiable copy of the system properties at VM startup.\n+     * This includes all properties set in {@code arguments.cpp}.\n+     * It also includes {@code java.specification.version}, {@code os.name}\n+     * and {@code os.arch}. The latter two are forced to reflect the\n+     * real OS and architecture even if they're set to some other value\n+     * on the VM command line (for example).\n@@ -94,2 +102,2 @@\n-        if (IS_IN_NATIVE_IMAGE) {\n-            if (savedProperties == null) {\n+        if (savedProperties == null) {\n+            if (IS_IN_NATIVE_IMAGE) {\n@@ -97,9 +105,6 @@\n-            }\n-        } else {\n-            if (savedProperties == null) {\n-                synchronized (Services.class) {\n-                    if (savedProperties == null) {\n-                        @SuppressWarnings(\"removal\")\n-                        SecurityManager sm = System.getSecurityManager();\n-                        if (sm != null) {\n-                            sm.checkPermission(new JVMCIPermission());\n+            } else {\n+                \/\/ Fallback to VM.getSavedProperties()\n+                if (savedProperties == null) {\n+                    synchronized (Services.class) {\n+                        if (savedProperties == null) {\n+                            savedProperties = Collections.unmodifiableMap(sanitizeOSArch(new HashMap<>(VM.getSavedProperties())));\n@@ -107,1 +112,0 @@\n-                        savedProperties = VM.getSavedProperties();\n@@ -264,0 +268,15 @@\n+    private static String toJavaString(Unsafe unsafe, long cstring) {\n+        if (cstring == 0) {\n+            return null;\n+        }\n+        int len = 0;\n+        for (long p = cstring; unsafe.getByte(p) != 0; p++) {\n+            len++;\n+        }\n+        byte[] buf = new byte[len];\n+        for (int i = 0; i < len; i++) {\n+            buf[i] = unsafe.getByte(cstring + i);\n+        }\n+        return new String(buf, java.nio.charset.StandardCharsets.UTF_8);\n+    }\n+\n@@ -265,2 +284,1 @@\n-     * Initializes {@link #savedProperties} from the byte array returned by\n-     * {@code jdk.internal.vm.VMSupport.serializeSavedPropertiesToByteArray()}.\n+     * Initializes {@link #savedProperties} from {@code Arguments::system_properties()}.\n@@ -269,3 +287,23 @@\n-    private static void initializeSavedProperties(byte[] serializedProperties) throws IOException {\n-        if (!IS_IN_NATIVE_IMAGE) {\n-            throw new InternalError(\"Can only initialize saved properties in JVMCI shared library runtime\");\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    private static void initializeSavedProperties(long system_properties, int next_offset, int key_offset, int value_offset) throws IOException {\n+        int count = 0;\n+        Unsafe unsafe = Unsafe.getUnsafe();\n+        for (long prop = system_properties; prop != 0; prop = unsafe.getLong(prop + next_offset)) {\n+            if (unsafe.getLong(prop + value_offset) != 0) {\n+              count++;\n+            } else {\n+              \/\/ ignore system properties that have a null value\n+            }\n+        }\n+        Map<String, String> props = new HashMap<>(count + 1);\n+        int i = 0;\n+        for (long prop = system_properties; prop != 0; prop = unsafe.getLong(prop + next_offset)) {\n+            String key = toJavaString(unsafe, unsafe.getLong(prop + key_offset));\n+            String value = toJavaString(unsafe, unsafe.getLong(prop + value_offset));\n+            if (value != null) {\n+              props.put(key, value);\n+              i++;\n+            }\n+        }\n+        if (i != count) {\n+            throw new InternalError(i + \" != \" + count);\n@@ -273,5 +311,2 @@\n-        Properties props = new Properties();\n-        props.load(new ByteArrayInputStream(serializedProperties));\n-        Map<String, String> map = new HashMap<>(props.size());\n-        for (var e : props.entrySet()) {\n-            map.put((String) e.getKey(), (String) e.getValue());\n+        if (!props.containsKey(\"java.specification.version\")) {\n+            props.put(\"java.specification.version\", Objects.requireNonNull(props.get(\"java.vm.specification.version\")));\n@@ -280,1 +315,44 @@\n-        savedProperties = Collections.unmodifiableMap(map);\n+        savedProperties = Collections.unmodifiableMap(sanitizeOSArch(props));\n+    }\n+\n+    \/\/ Force os.name and os.arch to reflect the actual OS and architecture.\n+    \/\/ JVMCI configures itself based on these values and needs to be isolated\n+    \/\/ from apps that set them on the command line.\n+    private static Map<String, String> sanitizeOSArch(Map<String, String> props) {\n+        props.put(\"os.arch\", realArch());\n+        props.put(\"os.name\", realOS());\n+        return props;\n+    }\n+\n+    private static String realOS() {\n+        OperatingSystem os = OperatingSystem.current();\n+        switch (os) {\n+            case LINUX: return \"Linux\";\n+            case MACOS: return \"Mac OS X\";\n+            case AIX: return \"AIX\";\n+            case WINDOWS: {\n+                String osName = System.getProperty(\"os.name\");\n+                if (osName.startsWith(\"Windows\")) {\n+                    \/\/ Use original value which is often more \"complete\"\n+                    \/\/ E.g. \"Windows Server 2012\"\n+                    return osName;\n+                }\n+                return \"Windows\";\n+            }\n+            default: throw new InternalError(\"missing case for \" + os);\n+        }\n+    }\n+\n+    private static String realArch() {\n+        Architecture arch = Architecture.current();\n+        switch (arch) {\n+            case X64: return \"x86_64\";\n+            case X86: return \"x86\";\n+            case AARCH64: return \"aarch64\";\n+            case RISCV64: return \"riscv64\";\n+            case ARM: return \"arm\";\n+            case S390: return \"s390\";\n+            case PPC64: return \"ppc64\";\n+            case OTHER: return \"other\";\n+            default: throw new InternalError(\"missing case for \" + arch);\n+        }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/services\/Services.java","additions":103,"deletions":25,"binary":false,"changes":128,"status":"modified"}]}