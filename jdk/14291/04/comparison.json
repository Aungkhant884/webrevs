{"files":[{"patch":"@@ -757,1 +757,0 @@\n-  template(serializeSavedPropertiesToByteArray_name,   \"serializeSavedPropertiesToByteArray\")                     \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n@@ -48,3 +49,0 @@\n-jbyte* JVMCIEnv::_serialized_saved_properties = nullptr;\n-int JVMCIEnv::_serialized_saved_properties_len = 0;\n-\n@@ -120,70 +118,0 @@\n-jbyte* JVMCIEnv::get_serialized_saved_properties(int& props_len, TRAPS) {\n-  jbyte* props = _serialized_saved_properties;\n-  if (props == nullptr) {\n-    \/\/ load VMSupport\n-    Symbol* klass = vmSymbols::jdk_internal_vm_VMSupport();\n-    Klass* k = SystemDictionary::resolve_or_fail(klass, true, CHECK_NULL);\n-\n-    InstanceKlass* ik = InstanceKlass::cast(k);\n-    if (ik->should_be_initialized()) {\n-      ik->initialize(CHECK_NULL);\n-    }\n-\n-    \/\/ invoke the serializeSavedPropertiesToByteArray method\n-    JavaValue result(T_OBJECT);\n-    JavaCallArguments args;\n-\n-    Symbol* signature = vmSymbols::void_byte_array_signature();\n-    JavaCalls::call_static(&result,\n-                           ik,\n-                           vmSymbols::serializeSavedPropertiesToByteArray_name(),\n-                           signature,\n-                           &args,\n-                           CHECK_NULL);\n-\n-    oop res = result.get_oop();\n-    assert(res->is_typeArray(), \"must be\");\n-    assert(TypeArrayKlass::cast(res->klass())->element_type() == T_BYTE, \"must be\");\n-    typeArrayOop ba = typeArrayOop(res);\n-    props_len = ba->length();\n-\n-    \/\/ Copy serialized saved properties from HotSpot object into C heap\n-    props = NEW_C_HEAP_ARRAY(jbyte, props_len, mtJVMCI);\n-    memcpy(props, ba->byte_at_addr(0), props_len);\n-\n-    _serialized_saved_properties_len = props_len;\n-    _serialized_saved_properties = props;\n-  } else {\n-    props_len = _serialized_saved_properties_len;\n-  }\n-  return props;\n-}\n-\n-void JVMCIEnv::copy_saved_properties(jbyte* properties, int properties_len, JVMCI_TRAPS) {\n-  assert(!is_hotspot(), \"can only copy saved properties from HotSpot to native image\");\n-  JavaThread* thread = JavaThread::current(); \/\/ For exception macros.\n-\n-  \/\/ Copy native buffer into shared library object\n-  JVMCIPrimitiveArray buf = new_byteArray(properties_len, this);\n-  if (has_pending_exception()) {\n-    _runtime->fatal_exception(JVMCIENV, \"Error in copy_saved_properties\");\n-  }\n-  copy_bytes_from(properties, buf, 0, properties_len);\n-  if (has_pending_exception()) {\n-    _runtime->fatal_exception(JVMCIENV, \"Error in copy_saved_properties\");\n-  }\n-\n-  \/\/ Initialize saved properties in shared library\n-  jclass servicesClass = JNIJVMCI::Services::clazz();\n-  jmethodID initializeSavedProperties = JNIJVMCI::Services::initializeSavedProperties_method();\n-  bool exception = false;\n-  {\n-    JNIAccessMark jni(this, thread);\n-    jni()->CallStaticVoidMethod(servicesClass, initializeSavedProperties, buf.as_jobject());\n-    exception = jni()->ExceptionCheck();\n-  }\n-  if (exception) {\n-    _runtime->fatal_exception(JVMCIENV, \"Error calling jdk.vm.ci.services.Services.initializeSavedProperties\");\n-  }\n-}\n-\n@@ -1940,1 +1868,1 @@\n-#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args)\n+#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName)\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":2,"deletions":74,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -186,6 +186,0 @@\n-  \/\/ Used by copy_saved_properties() to avoid OutOfMemoryErrors when\n-  \/\/ initializing a libjvmci runtime in low HotSpot heap conditions.\n-  \/\/ Must hold JVMCI_lock when initializing.\n-  static jbyte* _serialized_saved_properties;\n-  static int _serialized_saved_properties_len;\n-\n@@ -240,8 +234,0 @@\n-  \/\/ Gets the serialized saved properties from the HotSpot heap.\n-  \/\/ The length of the returned array is saved in `len`.\n-  jbyte* get_serialized_saved_properties(int& len, TRAPS);\n-\n-  \/\/ Initializes Services.savedProperties in the shared library from the given\n-  \/\/ properties in the format produced by `get_serialized_saved_properties`.\n-  void copy_saved_properties(jbyte* properties, int properties_len, JVMCI_TRAPS);\n-\n@@ -512,1 +498,1 @@\n-#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args)\n+#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName)\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.hpp","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n-#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args)\n+#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName)\n@@ -157,1 +157,1 @@\n-#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args) \\\n+#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName) \\\n@@ -257,1 +257,1 @@\n-#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args)\n+#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName)\n@@ -396,1 +396,1 @@\n-#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args) \\\n+#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName) \\\n@@ -409,0 +409,1 @@\n+  jlong    JNICALL JVM_ReadSystemPropertiesInfo(JNIEnv *env, jclass c, jintArray offsets_handle);\n@@ -568,1 +569,2 @@\n-    JNINativeMethod JVMCI_nmethods[] = {{ CC\"initializeRuntime\",   CC\"()Ljdk\/vm\/ci\/runtime\/JVMCIRuntime;\", FN_PTR(JVM_GetJVMCIRuntime) }};\n+    JNINativeMethod JVMCI_nmethods[] = {{ CC\"initializeRuntime\", CC\"()Ljdk\/vm\/ci\/runtime\/JVMCIRuntime;\", FN_PTR(JVM_GetJVMCIRuntime) }};\n+    JNINativeMethod Services_nmethods[] = {{ CC\"readSystemPropertiesInfo\", CC\"([I)J\", FN_PTR(JVM_ReadSystemPropertiesInfo) }};\n@@ -572,0 +574,1 @@\n+    register_natives_for_class(env, Services::clazz(), \"jdk\/vm\/ci\/services\/Services\", Services_nmethods, 1);\n@@ -586,1 +589,1 @@\n-#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args)\n+#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName)\n@@ -692,1 +695,1 @@\n-#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args) \\\n+#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName) \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.cpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -59,3 +59,0 @@\n-  start_class(Services, jdk_vm_ci_services_Services)                                                          \\\n-    jvmci_method(CallStaticVoidMethod, GetStaticMethodID, call_static, void, Services, initializeSavedProperties, byte_array_void_signature, (JVMCIObject serializedProperties)) \\\n-  end_class                                                                                                   \\\n@@ -163,1 +160,1 @@\n-    jvmci_method(CallStaticObjectMethod, GetStaticMethodID, call_static, JVMCIObject, JavaConstant, forPrimitive, forPrimitive_signature, (JVMCIObject kind, jlong value, JVMCI_TRAPS)) \\\n+    jvmci_method(CallStaticObjectMethod, GetStaticMethodID, call_static, JVMCIObject, JavaConstant, forPrimitive, forPrimitive_signature) \\\n@@ -203,8 +200,8 @@\n-    jvmci_method(CallNonvirtualObjectMethod, GetMethodID, call_special, JVMCIObject, HotSpotJVMCIRuntime, compileMethod, compileMethod_signature, (JVMCIObject runtime, JVMCIObject method, int entry_bci, jlong env, int id)) \\\n-    jvmci_method(CallNonvirtualObjectMethod, GetMethodID, call_special, JVMCIObject, HotSpotJVMCIRuntime, isGCSupported, int_bool_signature, (JVMCIObject runtime, int gcIdentifier)) \\\n-    jvmci_method(CallNonvirtualVoidMethod, GetMethodID, call_special, void, HotSpotJVMCIRuntime, bootstrapFinished, void_method_signature, (JVMCIObject runtime, JVMCI_TRAPS)) \\\n-    jvmci_method(CallNonvirtualVoidMethod, GetMethodID, call_special, void, HotSpotJVMCIRuntime, shutdown, void_method_signature, (JVMCIObject runtime)) \\\n-    jvmci_method(CallStaticObjectMethod, GetStaticMethodID, call_static, JVMCIObject, HotSpotJVMCIRuntime, runtime, runtime_signature, (JVMCI_TRAPS)) \\\n-    jvmci_method(CallObjectMethod, GetMethodID, call_virtual, JVMCIObject, HotSpotJVMCIRuntime, getCompiler, getCompiler_signature, (JVMCIObject runtime, JVMCI_TRAPS)) \\\n-    jvmci_method(CallStaticObjectMethod, GetStaticMethodID, call_static, JVMCIObject, HotSpotJVMCIRuntime, exceptionToString, exceptionToString_signature, (JVMCIObject object, bool toString, bool stackTrace, JVMCI_TRAPS)) \\\n-    jvmci_method(CallStaticVoidMethod, GetStaticMethodID, call_static, void, HotSpotJVMCIRuntime, postTranslation, object_void_signature, (JVMCIObject object, JVMCI_TRAPS)) \\\n+    jvmci_method(CallNonvirtualObjectMethod, GetMethodID, call_special, JVMCIObject, HotSpotJVMCIRuntime, compileMethod, compileMethod_signature) \\\n+    jvmci_method(CallNonvirtualObjectMethod, GetMethodID, call_special, JVMCIObject, HotSpotJVMCIRuntime, isGCSupported, int_bool_signature) \\\n+    jvmci_method(CallNonvirtualVoidMethod, GetMethodID, call_special, void, HotSpotJVMCIRuntime, bootstrapFinished, void_method_signature) \\\n+    jvmci_method(CallNonvirtualVoidMethod, GetMethodID, call_special, void, HotSpotJVMCIRuntime, shutdown, void_method_signature) \\\n+    jvmci_method(CallStaticObjectMethod, GetStaticMethodID, call_static, JVMCIObject, HotSpotJVMCIRuntime, runtime, runtime_signature) \\\n+    jvmci_method(CallObjectMethod, GetMethodID, call_virtual, JVMCIObject, HotSpotJVMCIRuntime, getCompiler, getCompiler_signature) \\\n+    jvmci_method(CallStaticObjectMethod, GetStaticMethodID, call_static, JVMCIObject, HotSpotJVMCIRuntime, exceptionToString, exceptionToString_signature) \\\n+    jvmci_method(CallStaticVoidMethod, GetStaticMethodID, call_static, void, HotSpotJVMCIRuntime, postTranslation, object_void_signature) \\\n@@ -217,0 +214,2 @@\n+  start_class(Services, jdk_vm_ci_services_Services)                                                                 \\\n+  end_class                                                                                                   \\\n@@ -218,2 +217,2 @@\n-    jvmci_method(CallStaticObjectMethod, GetStaticMethodID, call_static, JVMCIObject, JVMCI, getRuntime, getRuntime_signature, (JVMCI_TRAPS)) \\\n-    jvmci_method(CallStaticObjectMethod, GetStaticMethodID, call_static, JVMCIObject, JVMCI, initializeRuntime, initializeRuntime_signature, (JVMCI_TRAPS)) \\\n+    jvmci_method(CallStaticObjectMethod, GetStaticMethodID, call_static, JVMCIObject, JVMCI, getRuntime, getRuntime_signature) \\\n+    jvmci_method(CallStaticObjectMethod, GetStaticMethodID, call_static, JVMCIObject, JVMCI, initializeRuntime, initializeRuntime_signature) \\\n@@ -226,1 +225,1 @@\n-    jvmci_method(CallObjectMethod, GetMethodID, call_virtual, JVMCIObject, Class, getName, void_string_signature, (JVMCI_TRAPS)) \\\n+    jvmci_method(CallObjectMethod, GetMethodID, call_virtual, JVMCIObject, Class, getName, void_string_signature) \\\n@@ -229,2 +228,2 @@\n-    jvmci_method(CallStaticIntMethod, GetStaticMethodID, call_static, int, VMSupport, encodeThrowable, encodeThrowable_signature, (JVMCIObject throwable, jlong buffer, int buffer_size)) \\\n-    jvmci_method(CallStaticVoidMethod, GetStaticMethodID, call_static, void, VMSupport, decodeAndThrowThrowable, decodeAndThrowThrowable_signature, (jlong buffer)) \\\n+    jvmci_method(CallStaticIntMethod, GetStaticMethodID, call_static, int, VMSupport, encodeThrowable, encodeThrowable_signature) \\\n+    jvmci_method(CallStaticVoidMethod, GetStaticMethodID, call_static, void, VMSupport, decodeAndThrowThrowable, decodeAndThrowThrowable_signature) \\\n@@ -345,1 +344,1 @@\n-#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, simpleClassName, methodName, signatureSymbolName, args)\n+#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, simpleClassName, methodName, signatureSymbolName)\n@@ -438,1 +437,1 @@\n-#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args) \\\n+#define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName)       \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.hpp","additions":18,"deletions":19,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -757,0 +757,15 @@\n+\/\/ private static long Services.readSystemPropertiesInfo(int[] offsets)\n+JVM_ENTRY_NO_ENV(jlong, JVM_ReadSystemPropertiesInfo(JNIEnv *env, jclass c, jintArray offsets_handle))\n+  JNI_JVMCIENV(thread, env);\n+  if (!EnableJVMCI) {\n+    JVMCI_THROW_MSG_0(InternalError, \"JVMCI is not enabled\");\n+  }\n+  JVMCIPrimitiveArray offsets = JVMCIENV->wrap(offsets_handle);\n+  JVMCIENV->put_int_at(offsets, 0, SystemProperty::next_offset_in_bytes());\n+  JVMCIENV->put_int_at(offsets, 1, SystemProperty::key_offset_in_bytes());\n+  JVMCIENV->put_int_at(offsets, 2, PathString::value_offset_in_bytes());\n+\n+  return (jlong) Arguments::system_properties();\n+JVM_END\n+\n+\n@@ -1402,3 +1417,0 @@\n-  int properties_len = 0;\n-  jbyte* properties = nullptr;\n-\n@@ -1467,10 +1479,0 @@\n-\n-    if (!JVMCIENV->is_hotspot()) {\n-      Handle properties_exception;\n-      properties = JVMCIENV->get_serialized_saved_properties(properties_len, THREAD);\n-      if (JVMCIEnv::transfer_pending_exception_to_jni(THREAD, nullptr, JVMCIENV)) {\n-        JVMCI_event_1(\"error initializing system properties for JVMCI runtime %d\", _id);\n-        return;\n-      }\n-      JVMCIENV->copy_saved_properties(properties, properties_len, JVMCI_CHECK);\n-    }\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -105,1 +105,0 @@\n-  template(initializeSavedProperties_name,                        \"initializeSavedProperties\")                                            \\\n","filename":"src\/hotspot\/share\/jvmci\/vmSymbols_jvmci.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -213,0 +213,1 @@\n+  jlong    JNICALL JVM_ReadSystemPropertiesInfo(JNIEnv *env, jclass c, jintArray offsets);\n@@ -232,0 +233,1 @@\n+  { CC\"Java_jdk_vm_ci_services_Services_readSystemPropertiesInfo\", nullptr, FN_PTR(JVM_ReadSystemPropertiesInfo)    },\n","filename":"src\/hotspot\/share\/prims\/nativeLookup.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,0 +78,3 @@\n+\n+  \/\/ for JVM_ReadSystemPropertiesInfo\n+  static int value_offset_in_bytes()  { return (int)offset_of(PathString, _value);  }\n@@ -139,0 +142,4 @@\n+\n+  \/\/ for JVM_ReadSystemPropertiesInfo\n+  static int key_offset_in_bytes()  { return (int)offset_of(SystemProperty, _key);  }\n+  static int next_offset_in_bytes() { return (int)offset_of(SystemProperty, _next); }\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,13 +104,0 @@\n-    \/**\n-     * Serializes {@link VM#getSavedProperties()} to a byte array.\n-     *\n-     * Used by JVMCI to copy properties into libjvmci.\n-     *\/\n-    public static byte[] serializeSavedPropertiesToByteArray() throws IOException {\n-        Properties props = new Properties();\n-        for (var e : VM.getSavedProperties().entrySet()) {\n-            props.put(e.getKey(), e.getValue());\n-        }\n-        return serializePropertiesToByteArray(props);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/VMSupport.java","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -281,0 +281,1 @@\n+        jdk.internal.vm.ci,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import jdk.internal.util.OperatingSystem;\n@@ -36,2 +37,2 @@\n-    public final boolean linuxOs = Services.getSavedProperty(\"os.name\", \"\").startsWith(\"Linux\");\n-    public final boolean macOs = Services.getSavedProperty(\"os.name\", \"\").startsWith(\"Mac\");\n+    public final boolean linuxOs = OperatingSystem.isLinux();\n+    public final boolean macOs = OperatingSystem.isMacOS();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/code\/TargetDescription.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIRuntime.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.util.Architecture;\n@@ -46,2 +47,0 @@\n-    private final String osArch = getHostArchitectureName();\n-\n@@ -60,1 +59,1 @@\n-        String arch = Services.getSavedProperty(\"os.arch\");\n+        Architecture arch = Architecture.current();\n@@ -62,5 +61,2 @@\n-            case \"x86_64\":\n-                return \"amd64\";\n-\n-            default:\n-                return arch;\n+            case X64: return \"amd64\";\n+            default:  return arch.name().toLowerCase();\n@@ -137,1 +133,1 @@\n-    final int runtimeCallStackSize = getConstant(\"frame::arg_reg_save_area_bytes\", Integer.class, osArch.equals(\"amd64\") ? null : 0);\n+    final int runtimeCallStackSize = getConstant(\"frame::arg_reg_save_area_bytes\", Integer.class, Architecture.isX64() ? null : 0);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import jdk.internal.util.OperatingSystem;\n@@ -38,1 +39,1 @@\n-    final boolean windowsOs = Services.getSavedProperty(\"os.name\", \"\").startsWith(\"Windows\");\n+    final boolean windowsOs = OperatingSystem.isWindows();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/amd64\/AMD64HotSpotVMConfig.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import jdk.internal.util.OperatingSystem;\n@@ -40,1 +41,1 @@\n-    final boolean linuxOs = Services.getSavedProperty(\"os.name\", \"\").startsWith(\"Linux\");\n+    final boolean linuxOs = OperatingSystem.isLinux();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/riscv64\/RISCV64HotSpotVMConfig.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,2 +25,0 @@\n-import java.io.ByteArrayInputStream;\n-import java.io.IOException;\n@@ -28,1 +26,0 @@\n-import java.util.Collections;\n@@ -34,1 +31,0 @@\n-import java.util.Properties;\n@@ -42,0 +38,3 @@\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.util.Architecture;\n+import jdk.internal.util.OperatingSystem;\n@@ -74,1 +73,1 @@\n-     * In a native image, this field is initialized by {@link #initializeSavedProperties(byte[])}.\n+     * Lazily initialized in {@link #getSavedProperties}.\n@@ -90,1 +89,4 @@\n-     * Gets an unmodifiable copy of the system properties saved when {@link System} is initialized.\n+     * Gets an unmodifiable copy of the system properties parsed by {@code arguments.cpp}\n+     * plus {@code java.specification.version}, {@code os.name} and {@code os.arch}.\n+     * The latter two are forced to be the real OS and architecture. That is, values\n+     * for these two properties set on the command line are ignored.\n@@ -94,15 +96,4 @@\n-        if (IS_IN_NATIVE_IMAGE) {\n-            if (savedProperties == null) {\n-                throw new InternalError(\"Saved properties not initialized\");\n-            }\n-        } else {\n-            if (savedProperties == null) {\n-                synchronized (Services.class) {\n-                    if (savedProperties == null) {\n-                        @SuppressWarnings(\"removal\")\n-                        SecurityManager sm = System.getSecurityManager();\n-                        if (sm != null) {\n-                            sm.checkPermission(new JVMCIPermission());\n-                        }\n-                        savedProperties = VM.getSavedProperties();\n-                    }\n+        if (savedProperties == null) {\n+            synchronized (Services.class) {\n+                if (savedProperties == null) {\n+                    savedProperties = initProperties();\n@@ -264,0 +255,31 @@\n+    static String toJavaString(Unsafe unsafe, long cstring) {\n+        if (cstring == 0) {\n+            return null;\n+        }\n+        int len = 0;\n+        for (long p = cstring; unsafe.getByte(p) != 0; p++) {\n+            len++;\n+        }\n+        byte[] buf = new byte[len];\n+        for (int i = 0; i < len; i++) {\n+            buf[i] = unsafe.getByte(cstring + i);\n+        }\n+        return new String(buf, java.nio.charset.StandardCharsets.UTF_8);\n+    }\n+\n+    \/**\n+     * Gets the value of {@code Arguments::systemProperties()} and puts the offsets\n+     * of {@code SystemProperty} fields into {@code offsets}. The values returned in\n+     * {@code offsets} are:\n+     *\n+     * <pre>\n+     *     [ next,  \/\/ SystemProperty::next_offset_in_bytes()\n+     *       key,   \/\/ SystemProperty::key_offset_in_bytes()\n+     *       value  \/\/ PathString::value_offset_in_bytes()\n+     *     ]\n+     * <\/pre>\n+     *\n+     * Ideally this would be done with vmstructs but that code is in {@code jdk.vm.ci.hotspot}.\n+     *\/\n+    private static native long readSystemPropertiesInfo(int[] offsets);\n+\n@@ -265,2 +287,4 @@\n-     * Initializes {@link #savedProperties} from the byte array returned by\n-     * {@code jdk.internal.vm.VMSupport.serializeSavedPropertiesToByteArray()}.\n+     * Parses the native {@code Arguments::systemProperties()} data structure using Unsafe to\n+     * create a properties map. This parsing is safe as argument parsing in completed in\n+     * early VM start before this code can be executed, making {@code Arguments::systemProperties()}\n+     * effectively read-only by now.\n@@ -268,4 +292,29 @@\n-    @VMEntryPoint\n-    private static void initializeSavedProperties(byte[] serializedProperties) throws IOException {\n-        if (!IS_IN_NATIVE_IMAGE) {\n-            throw new InternalError(\"Can only initialize saved properties in JVMCI shared library runtime\");\n+    private static Map<String, String> initProperties() {\n+        int[] offsets = new int[3];\n+        long systemProperties = readSystemPropertiesInfo(offsets);\n+        int nextOffset = offsets[0];\n+        int keyOffset = offsets[1];\n+        int valueOffset = offsets[2];\n+\n+        int count = 0;\n+        Unsafe unsafe = Unsafe.getUnsafe();\n+        for (long prop = systemProperties; prop != 0; prop = unsafe.getLong(prop + nextOffset)) {\n+            if (unsafe.getLong(prop + valueOffset) != 0) {\n+                count++;\n+            } else {\n+                \/\/ Some internal properties (e.g. jdk.boot.class.path.append) can have a null\n+                \/\/ value and should just be ignored. Note that null is different than the empty string.\n+            }\n+        }\n+        Map<String, SystemProperties.Value> props = new HashMap<>(count + 1);\n+        int i = 0;\n+        for (long prop = systemProperties; prop != 0; prop = unsafe.getLong(prop + nextOffset)) {\n+            String key = toJavaString(unsafe, unsafe.getLong(prop + keyOffset));\n+            long valueAddress = unsafe.getLong(prop + valueOffset);\n+            if (valueAddress != 0) {\n+                props.put(key, new SystemProperties.Value(unsafe, valueAddress));\n+                i++;\n+            }\n+        }\n+        if (i != count) {\n+            throw new InternalError(i + \" != \" + count);\n@@ -273,5 +322,40 @@\n-        Properties props = new Properties();\n-        props.load(new ByteArrayInputStream(serializedProperties));\n-        Map<String, String> map = new HashMap<>(props.size());\n-        for (var e : props.entrySet()) {\n-            map.put((String) e.getKey(), (String) e.getValue());\n+        if (!props.containsKey(\"java.specification.version\")) {\n+            SystemProperties.Value v = Objects.requireNonNull(props.get(\"java.vm.specification.version\"));\n+            props.put(\"java.specification.version\", v);\n+        }\n+\n+        SystemProperties res = new SystemProperties(unsafe, sanitizeOSArch(props));\n+        if (\"true\".equals(res.get(\"debug.jvmci.PrintSavedProperties\"))) {\n+            System.out.println(\"[Saved system properties]\");\n+            for (Map.Entry<String, String> e : res.entrySet()) {\n+                System.out.printf(\"%s=%s%n\", e.getKey(), e.getValue());\n+            }\n+        }\n+        return res;\n+    }\n+\n+    \/\/ Force os.name and os.arch to reflect the actual OS and architecture.\n+    \/\/ JVMCI configures itself based on these values and needs to be isolated\n+    \/\/ from apps that set them on the command line.\n+    private static Map<String, SystemProperties.Value> sanitizeOSArch(Map<String, SystemProperties.Value> props) {\n+        props.put(\"os.arch\", new SystemProperties.Value(realArch()));\n+        props.put(\"os.name\", new SystemProperties.Value(realOS()));\n+        return props;\n+    }\n+\n+    private static String realOS() {\n+        OperatingSystem os = OperatingSystem.current();\n+        switch (os) {\n+            case LINUX: return \"Linux\";\n+            case MACOS: return \"Mac OS X\";\n+            case AIX: return \"AIX\";\n+            case WINDOWS: {\n+                String osName = System.getProperty(\"os.name\");\n+                if (osName.startsWith(\"Windows\")) {\n+                    \/\/ Use original value which is often more \"complete\"\n+                    \/\/ E.g. \"Windows Server 2012\"\n+                    return osName;\n+                }\n+                return \"Windows\";\n+            }\n+            default: throw new InternalError(\"missing case for \" + os);\n@@ -279,0 +363,1 @@\n+    }\n@@ -280,1 +365,13 @@\n-        savedProperties = Collections.unmodifiableMap(map);\n+    private static String realArch() {\n+        Architecture arch = Architecture.current();\n+        switch (arch) {\n+            case X64: return \"x86_64\";\n+            case X86: return \"x86\";\n+            case AARCH64: return \"aarch64\";\n+            case RISCV64: return \"riscv64\";\n+            case ARM: return \"arm\";\n+            case S390: return \"s390\";\n+            case PPC64: return \"ppc64\";\n+            case OTHER: return \"other\";\n+            default: throw new InternalError(\"missing case for \" + arch);\n+        }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/services\/Services.java","additions":131,"deletions":34,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -0,0 +1,180 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.services;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import jdk.internal.misc.Unsafe;\n+\n+\/**\n+ * Unmodifiable map for storing system properties read from native memory whose values have their\n+ * string representation constructed on first access.\n+ *\/\n+final class SystemProperties implements Map<String, String> {\n+\n+    private final Unsafe unsafe;\n+    private final Map<String, Value> entries;\n+    private Set<Entry<String, String>> entrySet;\n+    private Collection<String> values;\n+\n+    SystemProperties(Unsafe unsafe, Map<String, Value> entries) {\n+        this.unsafe = unsafe;\n+        this.entries = entries;\n+    }\n+\n+    @Override\n+    public int size() {\n+        return entries.size();\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        return entries.isEmpty();\n+    }\n+\n+    @Override\n+    public boolean containsKey(Object key) {\n+        return entries.containsKey(key);\n+    }\n+\n+    @Override\n+    public boolean containsValue(Object value) {\n+        for (Value v : entries.values()) {\n+            if (v.getString(unsafe).equals(value)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public String get(Object key) {\n+        Value v = entries.get(key);\n+        if (v != null) {\n+            return v.getString(unsafe);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public String put(String key, String value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public String remove(Object key) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void putAll(Map<? extends String, ? extends String> m) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Set<String> keySet() {\n+        return entries.keySet();\n+    }\n+\n+    @Override\n+    public Collection<String> values() {\n+        if (values == null) {\n+            values = entries.values().stream().map(v -> v.getString(unsafe)).collect(Collectors.toUnmodifiableList());\n+        }\n+        return values;\n+    }\n+\n+    static class Property implements Map.Entry<String, String> {\n+        private final Unsafe unsafe;\n+        private final String key;\n+        private final Value value;\n+\n+        Property(Unsafe unsafe, Map.Entry<String, Value> e) {\n+            this.unsafe = unsafe;\n+            this.key = e.getKey();\n+            this.value = e.getValue();\n+        }\n+\n+        @Override\n+        public String getKey() {\n+            return key;\n+        }\n+\n+        @Override\n+        public String getValue() {\n+            return value.getString(unsafe);\n+        }\n+\n+        @Override\n+        public String setValue(String value) {\n+            throw new UnsupportedOperationException();\n+        }\n+    };\n+\n+    @Override\n+    public Set<Entry<String, String>> entrySet() {\n+        if (entrySet == null) {\n+            entrySet = entries.entrySet().stream().map(e -> new Property(unsafe, e)).collect(Collectors.toUnmodifiableSet());\n+        }\n+        return entrySet;\n+    }\n+\n+    \/**\n+     * Represents a value in {@link SystemProperties}.\n+     *\/\n+    static class Value {\n+        private final long cstring;\n+        private volatile String string;\n+\n+        \/**\n+         * Creates a value whose string representation will be lazily constructed from {@code cstring}.\n+         *\/\n+        Value(Unsafe unsafe, long cstring) {\n+            this.cstring = cstring;\n+        }\n+\n+        \/**\n+         * Creates a value whose string representation is known at construction time.\n+         *\/\n+        Value(String string) {\n+            this.cstring = 0;\n+            this.string = string;\n+        }\n+\n+        String getString(Unsafe unsafe) {\n+            if (string == null) {\n+                \/\/ Racy but it doesn't matter.\n+                string = Services.toJavaString(unsafe, cstring);\n+            }\n+            return string;\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/services\/SystemProperties.java","additions":180,"deletions":0,"binary":false,"changes":180,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test TestJVMCISavedProperties\n+ * @bug 8309390\n+ * @summary Ensures Services.getSavedProperties() includes properties set on\n+ *          the command line as well some specified properties but not\n+ *          properties set programmatically.\n+ * @requires vm.flagless\n+ * @requires vm.jvmci\n+ * @library \/test\/lib\n+ * @run driver TestJVMCISavedProperties\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class TestJVMCISavedProperties {\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 0) {\n+            System.setProperty(\"app3.NotPresentInSavedProperties\", \"42\");\n+            System.out.println(\"DONE IN MAIN\");\n+            return;\n+        }\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:+EagerJVMCI\",\n+            \"-XX:+UseJVMCICompiler\",\n+            \"-Djvmci.Compiler=null\",\n+            \"-Ddebug.jvmci.PrintSavedProperties=true\",\n+            \"-Dapp1.propX=true\",\n+            \"-Dapp2.propY=SomeStringValue\",\n+            \"TestJVMCISavedProperties\", \"true\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.stdoutShouldContain(\"debug.jvmci.PrintSavedProperties=true\");\n+        output.stdoutShouldContain(\"jvmci.Compiler=null\");\n+        output.stdoutShouldContain(\"app1.propX=true\");\n+        output.stdoutShouldContain(\"app2.propY=SomeStringValue\");\n+        output.stdoutShouldContain(\"java.specification.version=\" + Runtime.version().feature());\n+        output.stdoutShouldContain(\"os.name=\");\n+        output.stdoutShouldContain(\"os.arch=\");\n+        output.stdoutShouldNotContain(\"NotPresentInSavedProperties\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/TestJVMCISavedProperties.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"}]}