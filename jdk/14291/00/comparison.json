{"files":[{"patch":"@@ -757,1 +757,0 @@\n-  template(serializeSavedPropertiesToByteArray_name,   \"serializeSavedPropertiesToByteArray\")                     \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n@@ -120,0 +121,61 @@\n+\/\/ Gets the `name` class, ensuring it is initialized.\n+\/\/ Throws NoClassDefFoundError if the class is not found.\n+\/\/ Throws InternalError if the class is not initialized.\n+static InstanceKlass* get_initialized_class(Symbol* name, TRAPS) {\n+    Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NULL);\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    if (ik->should_be_initialized()) {\n+      THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), err_msg(\"%s is not initialized\", ik->external_name()));\n+    }\n+    return ik;\n+}\n+\n+\/\/ Sets `fd` to the field in `ik` specified by `name` and `sig`.\n+\/\/ Throws NoSuchFieldError if the field is not found.\n+static void get_field(InstanceKlass* ik, Symbol* name, Symbol* sig, fieldDescriptor* fd, TRAPS) {\n+  Klass* declaring_klass = ik->find_field(name, sig, fd);\n+  if (declaring_klass == nullptr) {\n+    THROW_MSG(vmSymbols::java_lang_NoSuchFieldError(), err_msg(\"%s %s.%s\", sig->as_C_string(), ik->external_name(), name->as_C_string()));\n+  }\n+}\n+\n+\/\/ Checks that `obj` is not null.\n+\/\/ Throws NullPointerException if `obj` is null.\n+static oop non_null(oop obj, const char* name, TRAPS) {\n+  if (obj == nullptr) {\n+    THROW_MSG_NULL(vmSymbols::java_lang_NullPointerException(), name);\n+  }\n+  return obj;\n+}\n+\n+\/\/ Helper class for encoding system properties to a buffer.\n+class PropsEncoder : public StackObj {\n+ private:\n+  jbyte* _start;\n+  jbyte* _end;\n+  jbyte* _pos;\n+ public:\n+  PropsEncoder(jbyte* start, jbyte* end) :\n+    _start(start), _end(end), _pos(start) {}\n+\n+  int bytes_encoded() {\n+    return _pos - _start;\n+  }\n+\n+  void put_u2(int value) {\n+    *((u2*) _pos) = value;\n+    _pos += 2;\n+    assert(_pos <= _end, \"overflow\");\n+  }\n+\n+  void put_utf8(oop value) {\n+    char* buf = (char*) _pos + 2;\n+    int buflen = _end - (jbyte*) buf;\n+    int utf8_len;\n+    char* s = java_lang_String::as_utf8_string_full(value, buf, buflen, utf8_len);\n+    assert(s == buf, \"overflow\");\n+    *((u2*) _pos) = utf8_len;\n+    _pos += 2 + utf8_len;\n+  }\n+};\n+\n@@ -123,3 +185,11 @@\n-    \/\/ load VMSupport\n-    Symbol* klass = vmSymbols::jdk_internal_vm_VMSupport();\n-    Klass* k = SystemDictionary::resolve_or_fail(klass, true, CHECK_NULL);\n+    \/\/ This code is called exactly once so uses temp symbols.\n+    TempNewSymbol jdk_internal_misc_VM =                   SymbolTable::new_symbol(\"jdk\/internal\/misc\/VM\");\n+    TempNewSymbol savedProps_name =                        SymbolTable::new_symbol(\"savedProps\");\n+    TempNewSymbol java_util_Map_signature =                SymbolTable::new_symbol(\"Ljava\/util\/Map;\");\n+    TempNewSymbol java_util_HashMap_Node_signature =       SymbolTable::new_symbol(\"Ljava\/util\/HashMap$Node;\");\n+    TempNewSymbol java_util_HashMap_Node_array_signature = SymbolTable::new_symbol(\"[Ljava\/util\/HashMap$Node;\");\n+    TempNewSymbol table_name =                             SymbolTable::new_symbol(\"table\");\n+    TempNewSymbol key_name =                               SymbolTable::new_symbol(\"key\");\n+    TempNewSymbol next_name =                              SymbolTable::new_symbol(\"next\");\n+    Symbol*       value_name =                             vmSymbols::value_name();\n+    Symbol*       object_signature =                       vmSymbols::object_signature();\n@@ -127,3 +197,40 @@\n-    InstanceKlass* ik = InstanceKlass::cast(k);\n-    if (ik->should_be_initialized()) {\n-      ik->initialize(CHECK_NULL);\n+    fieldDescriptor fd;\n+    InstanceKlass* ik = get_initialized_class(jdk_internal_misc_VM, CHECK_0);\n+    get_field(ik, savedProps_name, java_util_Map_signature, &fd, CHECK_0);\n+    oop savedProps = non_null(ik->java_mirror()->obj_field(fd.offset()), \"VM.savedProps\", CHECK_0);\n+\n+    ik = InstanceKlass::cast(savedProps->klass());\n+\n+    if (!ik->name()->equals(\"java\/util\/HashMap\")) {\n+      THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), err_msg(\"VM.savedProps is a %s\", ik->external_name()));\n+    }\n+\n+    get_field(ik, table_name, java_util_HashMap_Node_array_signature, &fd, CHECK_0);\n+    oop table_obj = non_null(savedProps->obj_field(fd.offset()), \"VM.savedProps.table\", CHECK_0);\n+    objArrayOop table = objArrayOop(table_obj);\n+\n+    fieldDescriptor key_fd;\n+    fieldDescriptor value_fd;\n+    fieldDescriptor next_fd;\n+\n+    props_len = 2;\n+    int props_count = 0;\n+\n+    int table_len = table->length();\n+    for (int i = 0; i < table_len; i++) {\n+      oop node = table->obj_at(i);\n+      while (node != nullptr) {\n+        if (props_count == 0) {\n+          ik = InstanceKlass::cast(node->klass());\n+          get_field(ik, key_name, object_signature, &key_fd, CHECK_0);\n+          get_field(ik, value_name, object_signature, &value_fd, CHECK_0);\n+          get_field(ik, next_name, java_util_HashMap_Node_signature, &next_fd, CHECK_0);\n+        }\n+        oop key = node->obj_field(key_fd.offset());\n+        oop value = node->obj_field(value_fd.offset());\n+        node = node->obj_field(next_fd.offset());\n+\n+        props_len += 2 + java_lang_String::utf8_length(key);\n+        props_len += 2 + java_lang_String::utf8_length(value);\n+        props_count++;\n+      }\n@@ -132,24 +239,32 @@\n-    \/\/ invoke the serializeSavedPropertiesToByteArray method\n-    JavaValue result(T_OBJECT);\n-    JavaCallArguments args;\n-\n-    Symbol* signature = vmSymbols::void_byte_array_signature();\n-    JavaCalls::call_static(&result,\n-                           ik,\n-                           vmSymbols::serializeSavedPropertiesToByteArray_name(),\n-                           signature,\n-                           &args,\n-                           CHECK_NULL);\n-\n-    oop res = result.get_oop();\n-    assert(res->is_typeArray(), \"must be\");\n-    assert(TypeArrayKlass::cast(res->klass())->element_type() == T_BYTE, \"must be\");\n-    typeArrayOop ba = typeArrayOop(res);\n-    props_len = ba->length();\n-\n-    \/\/ Copy serialized saved properties from HotSpot object into C heap\n-    props = NEW_C_HEAP_ARRAY(jbyte, props_len, mtJVMCI);\n-    memcpy(props, ba->byte_at_addr(0), props_len);\n-\n-    _serialized_saved_properties_len = props_len;\n-    _serialized_saved_properties = props;\n+    \/\/ Need 1 extra byte for the trailing null added by java_lang_String::as_utf8_string_full below.\n+    int props_buf_len = props_len + 1;\n+    props = NEW_C_HEAP_ARRAY_RETURN_NULL(jbyte, props_buf_len, mtJVMCI);\n+    if (props == nullptr) {\n+      THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), err_msg(\"could not allocate %d bytes\", props_buf_len));\n+    }\n+\n+    PropsEncoder pe(props, props + props_buf_len);\n+    pe.put_u2(props_count);\n+    for (int i = 0; i < table_len; i++) {\n+      oop node = table->obj_at(i);\n+      while (node != nullptr) {\n+        oop key = node->obj_field(key_fd.offset());\n+        oop value = node->obj_field(value_fd.offset());\n+        node = node->obj_field(next_fd.offset());\n+\n+        pe.put_utf8(key);\n+        pe.put_utf8(value);\n+      }\n+    }\n+    assert(pe.bytes_encoded() == props_len, \"%d != %d\", pe.bytes_encoded(), props_len);\n+\n+    MutexLocker lock_jvmci(JVMCI_lock);\n+    if (_serialized_saved_properties != nullptr) {\n+      \/\/ Another thread won the race to initialize _serialized_saved_properties\n+      FREE_C_HEAP_ARRAY(jbyte, props);\n+      props = _serialized_saved_properties;\n+      props_len = _serialized_saved_properties_len;\n+    } else {\n+      _serialized_saved_properties_len = props_len;\n+      _serialized_saved_properties = props;\n+    }\n@@ -166,10 +281,0 @@\n-  \/\/ Copy native buffer into shared library object\n-  JVMCIPrimitiveArray buf = new_byteArray(properties_len, this);\n-  if (has_pending_exception()) {\n-    _runtime->fatal_exception(JVMCIENV, \"Error in copy_saved_properties\");\n-  }\n-  copy_bytes_from(properties, buf, 0, properties_len);\n-  if (has_pending_exception()) {\n-    _runtime->fatal_exception(JVMCIENV, \"Error in copy_saved_properties\");\n-  }\n-\n@@ -182,1 +287,1 @@\n-    jni()->CallStaticVoidMethod(servicesClass, initializeSavedProperties, buf.as_jobject());\n+    jni()->CallStaticVoidMethod(servicesClass, initializeSavedProperties, properties, properties + properties_len);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":146,"deletions":41,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -240,1 +240,1 @@\n-  \/\/ Gets the serialized saved properties from the HotSpot heap.\n+  \/\/ Gets the serialized VM.savedProps from the HotSpot heap.\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    jvmci_method(CallStaticVoidMethod, GetStaticMethodID, call_static, void, Services, initializeSavedProperties, byte_array_void_signature, (JVMCIObject serializedProperties)) \\\n+    jvmci_method(CallStaticVoidMethod, GetStaticMethodID, call_static, void, Services, initializeSavedProperties, long_long_void_signature, (JVMCIObject serializedProperties)) \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -236,0 +236,2 @@\n+    \/\/ This is read directly by JVMCIEnv::get_serialized_saved_properties\n+    \/\/ which expects it to be a HashMap.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/VM.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-     * @return a Properties instance initialized with all of the properties\n+     * @return a Map instance initialized with all of the properties\n@@ -276,1 +276,1 @@\n-         * Return a Properties instance of the command line and VM options\n+         * Return a HashMap instance of the command line and VM options\n@@ -278,1 +278,1 @@\n-         * The Properties instance is sized to include the fixed properties.\n+         * The HashMap instance is sized to include the fixed properties.\n@@ -280,1 +280,1 @@\n-         * @return return a Properties instance of the command line and VM options\n+         * @return return a HashMap instance of the command line and VM options\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/SystemProps.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -104,13 +104,0 @@\n-    \/**\n-     * Serializes {@link VM#getSavedProperties()} to a byte array.\n-     *\n-     * Used by JVMCI to copy properties into libjvmci.\n-     *\/\n-    public static byte[] serializeSavedPropertiesToByteArray() throws IOException {\n-        Properties props = new Properties();\n-        for (var e : VM.getSavedProperties().entrySet()) {\n-            props.put(e.getKey(), e.getValue());\n-        }\n-        return serializePropertiesToByteArray(props);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/VMSupport.java","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -264,0 +265,45 @@\n+    \/**\n+     * Helper for reading serialized properties from a native buffer.\n+     *\/\n+    static class PropsDecoder {\n+        final Unsafe unsafe = Unsafe.getUnsafe();\n+        final long bufStart;\n+        final long bufEnd;\n+        long pos;\n+\n+        PropsDecoder(long buf, long bufEnd) {\n+            this.bufStart = buf;\n+            this.bufEnd = bufEnd;\n+            this.pos = buf;\n+        }\n+\n+        private long length() {\n+            return bufEnd - bufStart;\n+        }\n+\n+        private long offset() {\n+            return pos - bufStart;\n+        }\n+\n+        private void check(int n) {\n+            if (pos + n > bufEnd) {\n+                throw new InternalError(String.format(\"out of bounds: %d > %d\", offset() + n, length()));\n+            }\n+        }\n+        int getU2() {\n+            check(2);\n+            int u2 = unsafe.getChar(pos);\n+            pos += 2;\n+            return u2;\n+        }\n+\n+        String getUtf8() {\n+            int len = getU2();\n+            check(len);\n+            byte[] utf8 = new byte[len];\n+            unsafe.copyMemory(null, pos, utf8, Unsafe.ARRAY_BYTE_BASE_OFFSET, len);\n+            pos += len;\n+            return new String(utf8, java.nio.charset.StandardCharsets.UTF_8);\n+        }\n+    }\n+\n@@ -266,1 +312,1 @@\n-     * {@code jdk.internal.vm.VMSupport.serializeSavedPropertiesToByteArray()}.\n+     * {@code JVMCIEnv::get_serialized_saved_properties}.\n@@ -269,1 +315,2 @@\n-    private static void initializeSavedProperties(byte[] serializedProperties) throws IOException {\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    private static void initializeSavedProperties(long buf, long bufEnd) throws IOException {\n@@ -273,6 +320,0 @@\n-        Properties props = new Properties();\n-        props.load(new ByteArrayInputStream(serializedProperties));\n-        Map<String, String> map = new HashMap<>(props.size());\n-        for (var e : props.entrySet()) {\n-            map.put((String) e.getKey(), (String) e.getValue());\n-        }\n@@ -280,1 +321,9 @@\n-        savedProperties = Collections.unmodifiableMap(map);\n+        PropsDecoder ps = new PropsDecoder(buf, bufEnd);\n+        int count = ps.getU2();\n+        Map.Entry[] elements = new Map.Entry[count];\n+        for (int i = 0; i < count; i++) {\n+            String key = ps.getUtf8();\n+            String value = ps.getUtf8();\n+            elements[i] = Map.entry(key, value);\n+        }\n+        savedProperties = Collections.unmodifiableMap(Map.ofEntries((Map.Entry<String, String>[])elements));\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/services\/Services.java","additions":58,"deletions":9,"binary":false,"changes":67,"status":"modified"}]}