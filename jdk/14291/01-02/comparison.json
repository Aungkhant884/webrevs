{"files":[{"patch":"@@ -39,1 +39,0 @@\n-#include \"runtime\/arguments.hpp\"\n@@ -119,33 +118,0 @@\n-void JVMCIEnv::init_saved_properties(JVMCI_TRAPS) {\n-  JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n-  if (is_hotspot()) {\n-    JavaCallArguments jargs;\n-    jargs.push_long((jlong) Arguments::system_properties());\n-    jargs.push_int(SystemProperty::next_offset_in_bytes());\n-    jargs.push_int(SystemProperty::key_offset_in_bytes());\n-    jargs.push_int(PathString::value_offset_in_bytes());\n-    JavaValue result(T_VOID);\n-    JavaCalls::call_static(&result,\n-                           HotSpotJVMCI::Services::klass(),\n-                           vmSymbols::initializeSavedProperties_name(),\n-                           vmSymbols::initializeSavedProperties_signature(), &jargs, CHECK);\n-  } else {\n-    \/\/ Initialize saved properties in shared library\n-    jclass servicesClass = JNIJVMCI::Services::clazz();\n-    jmethodID initializeSavedProperties = JNIJVMCI::Services::initializeSavedProperties_method();\n-    bool exception = false;\n-    {\n-      JNIAccessMark jni(this, THREAD);\n-      jni()->CallStaticVoidMethod(servicesClass, initializeSavedProperties,\n-        Arguments::system_properties(),\n-        SystemProperty::next_offset_in_bytes(),\n-        SystemProperty::key_offset_in_bytes(),\n-        PathString::value_offset_in_bytes());\n-      exception = jni()->ExceptionCheck();\n-    }\n-    if (exception) {\n-      _runtime->fatal_exception(JVMCIENV, \"Error calling jdk.vm.ci.services.Services.initializeSavedProperties\");\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":0,"deletions":34,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -234,3 +234,0 @@\n-  \/\/ Initializes Services.savedProperties.\n-  void init_saved_properties(JVMCI_TRAPS);\n-\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -409,0 +409,1 @@\n+  jlong    JNICALL JVM_ReadSystemPropertiesInfo(JNIEnv *env, jclass c, jintArray offsets_handle);\n@@ -568,1 +569,2 @@\n-    JNINativeMethod JVMCI_nmethods[] = {{ CC\"initializeRuntime\",   CC\"()Ljdk\/vm\/ci\/runtime\/JVMCIRuntime;\", FN_PTR(JVM_GetJVMCIRuntime) }};\n+    JNINativeMethod JVMCI_nmethods[] = {{ CC\"initializeRuntime\", CC\"()Ljdk\/vm\/ci\/runtime\/JVMCIRuntime;\", FN_PTR(JVM_GetJVMCIRuntime) }};\n+    JNINativeMethod Services_nmethods[] = {{ CC\"readSystemPropertiesInfo\", CC\"([I)J\", FN_PTR(JVM_ReadSystemPropertiesInfo) }};\n@@ -572,0 +574,1 @@\n+    register_natives_for_class(env, Services::clazz(), \"jdk\/vm\/ci\/services\/Services\", Services_nmethods, 1);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -59,3 +59,0 @@\n-  start_class(Services, jdk_vm_ci_services_Services)                                                          \\\n-    jvmci_method(CallStaticVoidMethod, GetStaticMethodID, call_static, void, Services, initializeSavedProperties, initializeSavedProperties_signature) \\\n-  end_class                                                                                                   \\\n@@ -217,0 +214,2 @@\n+  start_class(Services, jdk_vm_ci_services_Services)                                                                 \\\n+  end_class                                                                                                   \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -757,0 +757,15 @@\n+\/\/ private static long Services.readSystemPropertiesInfo(int[] offsets)\n+JVM_ENTRY_NO_ENV(jlong, JVM_ReadSystemPropertiesInfo(JNIEnv *env, jclass c, jintArray offsets_handle))\n+  JNI_JVMCIENV(thread, env);\n+  if (!EnableJVMCI) {\n+    JVMCI_THROW_MSG_0(InternalError, \"JVMCI is not enabled\");\n+  }\n+  JVMCIPrimitiveArray offsets = JVMCIENV->wrap(offsets_handle);\n+  JVMCIENV->put_int_at(offsets, 0, SystemProperty::next_offset_in_bytes());\n+  JVMCIENV->put_int_at(offsets, 1, SystemProperty::key_offset_in_bytes());\n+  JVMCIENV->put_int_at(offsets, 2, PathString::value_offset_in_bytes());\n+\n+  return (jlong) Arguments::system_properties();\n+JVM_END\n+\n+\n@@ -1464,2 +1479,0 @@\n-\n-    JVMCIENV->init_saved_properties(JVMCI_CHECK);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -105,2 +105,0 @@\n-  template(initializeSavedProperties_name,                        \"initializeSavedProperties\")                                            \\\n-  template(initializeSavedProperties_signature,                   \"(JIII)V\")                                                              \\\n","filename":"src\/hotspot\/share\/jvmci\/vmSymbols_jvmci.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -213,0 +213,1 @@\n+  jlong    JNICALL JVM_ReadSystemPropertiesInfo(JNIEnv *env, jclass c, jintArray offsets);\n@@ -232,0 +233,1 @@\n+  { CC\"Java_jdk_vm_ci_services_Services_readSystemPropertiesInfo\", nullptr, FN_PTR(JVM_ReadSystemPropertiesInfo)    },\n","filename":"src\/hotspot\/share\/prims\/nativeLookup.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -236,2 +236,0 @@\n-    \/\/ This is read directly by JVMCIEnv::get_serialized_saved_properties\n-    \/\/ which expects it to be a HashMap.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/VM.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-     * @return a Map instance initialized with all of the properties\n+     * @return a Properties instance initialized with all of the properties\n@@ -276,1 +276,1 @@\n-         * Return a HashMap instance of the command line and VM options\n+         * Return a Properties instance of the command line and VM options\n@@ -278,1 +278,1 @@\n-         * The HashMap instance is sized to include the fixed properties.\n+         * The Properties instance is sized to include the fixed properties.\n@@ -280,1 +280,1 @@\n-         * @return return a HashMap instance of the command line and VM options\n+         * @return return a Properties instance of the command line and VM options\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/SystemProps.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Comparator;\n@@ -342,0 +343,3 @@\n+            out.println(\"[Saved system properties]\");\n+            Comparator<Map.Entry<String, String>> c = Comparator.comparing(Map.Entry<String, String>::getKey);\n+            Services.getSavedProperties().entrySet().stream().sorted(c).forEach(e -> System.out.println(e));\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIRuntime.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,2 +25,0 @@\n-import java.io.ByteArrayInputStream;\n-import java.io.IOException;\n@@ -28,1 +26,0 @@\n-import java.util.Collections;\n@@ -34,1 +31,0 @@\n-import java.util.Properties;\n@@ -77,1 +73,1 @@\n-     * This field is initialized by {@link #initializeSavedProperties}.\n+     * Lazily initialized in {@link #getSavedProperties}.\n@@ -93,6 +89,4 @@\n-     * Gets an unmodifiable copy of the system properties at VM startup.\n-     * This includes all properties set in {@code arguments.cpp}.\n-     * It also includes {@code java.specification.version}, {@code os.name}\n-     * and {@code os.arch}. The latter two are forced to reflect the\n-     * real OS and architecture even if they're set to some other value\n-     * on the VM command line (for example).\n+     * Gets an unmodifiable copy of the system properties parsed by {@code arguments.cpp}\n+     * plus {@code java.specification.version}, {@code os.name} and {@code os.arch}.\n+     * The latter two are forced to be the real OS and architecture. That is, values\n+     * for these two properties set on the command line are ignored.\n@@ -103,4 +97,1 @@\n-            if (IS_IN_NATIVE_IMAGE) {\n-                throw new InternalError(\"Saved properties not initialized\");\n-            } else {\n-                \/\/ Fallback to VM.getSavedProperties()\n+            synchronized (Services.class) {\n@@ -108,5 +99,1 @@\n-                    synchronized (Services.class) {\n-                        if (savedProperties == null) {\n-                            savedProperties = Collections.unmodifiableMap(sanitizeOSArch(new HashMap<>(VM.getSavedProperties())));\n-                        }\n-                    }\n+                    savedProperties = initProperties();\n@@ -268,1 +255,1 @@\n-    private static String toJavaString(Unsafe unsafe, long cstring) {\n+    static String toJavaString(Unsafe unsafe, long cstring) {\n@@ -284,1 +271,20 @@\n-     * Initializes {@link #savedProperties} from {@code Arguments::system_properties()}.\n+     * Gets the value of {@code Arguments::systemProperties()} and puts the offsets\n+     * of {@code SystemProperty} fields into {@code offsets}. The values returned in\n+     * {@code offsets} are:\n+     *\n+     * <pre>\n+     *     [ next,  \/\/ SystemProperty::next_offset_in_bytes()\n+     *       key,   \/\/ SystemProperty::key_offset_in_bytes()\n+     *       value  \/\/ PathString::value_offset_in_bytes()\n+     *     ]\n+     * <\/pre>\n+     *\n+     * Ideally this would be done with vmstructs but that code is in {@code jdk.vm.ci.hotspot}.\n+     *\/\n+    private static native long readSystemPropertiesInfo(int[] offsets);\n+\n+    \/**\n+     * Parses the native {@code Arguments::systemProperties()} data structure using Unsafe to\n+     * create a properties map. This parsing is safe as argument parsing in completed in\n+     * early VM start before this code can be executed, making {@code Arguments::systemProperties()}\n+     * effectively read-only by now.\n@@ -286,3 +292,7 @@\n-    @VMEntryPoint\n-    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n-    private static void initializeSavedProperties(long system_properties, int next_offset, int key_offset, int value_offset) throws IOException {\n+    private static Map<String, String> initProperties() {\n+        int[] offsets = new int[3];\n+        long systemProperties = readSystemPropertiesInfo(offsets);\n+        int nextOffset = offsets[0];\n+        int keyOffset = offsets[1];\n+        int valueOffset = offsets[2];\n+\n@@ -291,3 +301,3 @@\n-        for (long prop = system_properties; prop != 0; prop = unsafe.getLong(prop + next_offset)) {\n-            if (unsafe.getLong(prop + value_offset) != 0) {\n-              count++;\n+        for (long prop = systemProperties; prop != 0; prop = unsafe.getLong(prop + nextOffset)) {\n+            if (unsafe.getLong(prop + valueOffset) != 0) {\n+                count++;\n@@ -295,1 +305,2 @@\n-              \/\/ ignore system properties that have a null value\n+                \/\/ Some internal properties (e.g. jdk.boot.class.path.append) can have a null\n+                \/\/ value and should just be ignored. Note that null is different than the empty string.\n@@ -298,1 +309,1 @@\n-        Map<String, String> props = new HashMap<>(count + 1);\n+        Map<String, SystemProperties.Value> props = new HashMap<>(count + 1);\n@@ -300,6 +311,6 @@\n-        for (long prop = system_properties; prop != 0; prop = unsafe.getLong(prop + next_offset)) {\n-            String key = toJavaString(unsafe, unsafe.getLong(prop + key_offset));\n-            String value = toJavaString(unsafe, unsafe.getLong(prop + value_offset));\n-            if (value != null) {\n-              props.put(key, value);\n-              i++;\n+        for (long prop = systemProperties; prop != 0; prop = unsafe.getLong(prop + nextOffset)) {\n+            String key = toJavaString(unsafe, unsafe.getLong(prop + keyOffset));\n+            long valueAddress = unsafe.getLong(prop + valueOffset);\n+            if (valueAddress != 0) {\n+                props.put(key, new SystemProperties.Value(unsafe, valueAddress));\n+                i++;\n@@ -312,1 +323,2 @@\n-            props.put(\"java.specification.version\", Objects.requireNonNull(props.get(\"java.vm.specification.version\")));\n+            SystemProperties.Value v = Objects.requireNonNull(props.get(\"java.vm.specification.version\"));\n+            props.put(\"java.specification.version\", v);\n@@ -315,1 +327,8 @@\n-        savedProperties = Collections.unmodifiableMap(sanitizeOSArch(props));\n+        SystemProperties res = new SystemProperties(sanitizeOSArch(props));\n+        if (\"true\".equals(res.get(\"debug.jvmci.PrintSavedProperties\"))) {\n+            System.out.println(\"[Saved system properties]\");\n+            for (Map.Entry<String, String> e : res.entrySet()) {\n+                System.out.println(e);\n+            }\n+        }\n+        return res;\n@@ -321,3 +340,3 @@\n-    private static Map<String, String> sanitizeOSArch(Map<String, String> props) {\n-        props.put(\"os.arch\", realArch());\n-        props.put(\"os.name\", realOS());\n+    private static Map<String, SystemProperties.Value> sanitizeOSArch(Map<String, SystemProperties.Value> props) {\n+        props.put(\"os.arch\", new SystemProperties.Value(realArch()));\n+        props.put(\"os.name\", new SystemProperties.Value(realOS()));\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/services\/Services.java","additions":61,"deletions":42,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -0,0 +1,307 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.services;\n+\n+import java.util.AbstractCollection;\n+import java.util.AbstractSet;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+\n+import jdk.internal.misc.Unsafe;\n+\n+\/**\n+ * Unmodifiable map for storing system properties read from native memory whose values have their\n+ * string representation constructed on first access.\n+ *\/\n+final class SystemProperties implements Map<String, String> {\n+\n+    final Map<String, Value> entries;\n+    EntrySet entrySet;\n+    Values values;\n+\n+    SystemProperties(Map<String, Value> entries) {\n+        this.entries = entries;\n+    }\n+\n+    @Override\n+    public int size() {\n+        return entries.size();\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        return entries.isEmpty();\n+    }\n+\n+    @Override\n+    public boolean containsKey(Object key) {\n+        return entries.containsKey(key);\n+    }\n+\n+    @Override\n+    public boolean containsValue(Object value) {\n+        for (Value v : entries.values()) {\n+            if (v.getString().equals(value)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public String get(Object key) {\n+        Value v = entries.get(key);\n+        if (v != null) {\n+            return v.getString();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public String put(String key, String value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public String remove(Object key) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void putAll(Map<? extends String, ? extends String> m) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Set<String> keySet() {\n+        return entries.keySet();\n+    }\n+\n+    @Override\n+    public Collection<String> values() {\n+        Values vs;\n+        return (vs = values) == null ? (values = new Values(this)) : vs;\n+    }\n+\n+    @Override\n+    public Set<Entry<String, String>> entrySet() {\n+        EntrySet es;\n+        return (es = entrySet) == null ? (entrySet = new EntrySet(this)) : es;\n+    }\n+\n+    \/**\n+     * Represents a value in {@link SystemProperties}.\n+     *\/\n+    static class Value {\n+        private final Unsafe unsafe;\n+        private final long cstring;\n+        private volatile String string;\n+\n+        \/**\n+         * Creates a value whose string representation will be lazily constructed from {@code cstring}.\n+         *\/\n+        Value(Unsafe unsafe, long cstring) {\n+            this.unsafe = unsafe;\n+            this.cstring = cstring;\n+        }\n+\n+        \/**\n+         * Creates a value whose string representation is known at construction time.\n+         *\/\n+        Value(String string) {\n+            this.unsafe = null;\n+            this.cstring = 0;\n+            this.string = string;\n+        }\n+\n+        String getString() {\n+            if (string == null) {\n+                \/\/ Racy but it doesn't matter.\n+                string = Services.toJavaString(unsafe, cstring);\n+            }\n+            return string;\n+        }\n+    }\n+\n+    static final class EntrySet extends AbstractSet<Entry<String, String>> {\n+\n+        final SystemProperties sp;\n+\n+        EntrySet(SystemProperties sp) {\n+            this.sp = sp;\n+        }\n+\n+        public final int size() {\n+            return sp.size();\n+        }\n+\n+        public final void clear() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public final Iterator<Entry<String, String>> iterator() {\n+            return new Iterator<Entry<String, String>>() {\n+                Iterator<Entry<String, Value>> entriesIter = sp.entries.entrySet().iterator();\n+\n+                @Override\n+                public boolean hasNext() {\n+                    return entriesIter.hasNext();\n+                }\n+\n+                @Override\n+                public Entry<String, String> next() {\n+                    Entry<String, Value> next = entriesIter.next();\n+                    return new Node(next.getKey(), next.getValue());\n+                }\n+            };\n+        }\n+\n+        public final boolean contains(Object o) {\n+            return sp.entries.entrySet().contains(o);\n+        }\n+\n+        public final boolean remove(Object o) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public final void forEach(Consumer<? super Entry<String, String>> action) {\n+            for (Entry<String, String> e : this) {\n+                action.accept(e);\n+            }\n+        }\n+    }\n+\n+    static class Node implements Map.Entry<String, String> {\n+        final String key;\n+        final Value value;\n+\n+        Node(String key, Value value) {\n+            this.key = key;\n+            this.value = value;\n+        }\n+\n+\n+        public final String getKey() {\n+            return key;\n+        }\n+\n+        public final String getValue() {\n+            return value.getString();\n+        }\n+\n+        public final String toString() {\n+            return key + \"=\" + getValue();\n+        }\n+\n+        public final int hashCode() {\n+            return Objects.hashCode(key) ^ Long.hashCode(value.cstring);\n+        }\n+\n+        public final String setValue(String newValue) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public final boolean equals(Object o) {\n+            if (o == this) {\n+                return true;\n+            }\n+            return o instanceof Node e\n+                    && Objects.equals(key, e.getKey())\n+                    && Objects.equals(value.getString(), e.value.getString());\n+        }\n+    }\n+\n+    static final class Values extends AbstractCollection<String> {\n+        final SystemProperties sp;\n+\n+        Values(SystemProperties sp) {\n+            this.sp = sp;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return sp.size();\n+        }\n+\n+        @Override\n+        public boolean isEmpty() {\n+            return sp.isEmpty();\n+        }\n+\n+        @Override\n+        public boolean contains(Object o) {\n+            return sp.containsValue(o);\n+        }\n+\n+        @Override\n+        public Iterator<String> iterator() {\n+            Iterator<Entry<String, Value>> entriesIter = sp.entries.entrySet().iterator();\n+            return new Iterator<String>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return entriesIter.hasNext();\n+                }\n+\n+                @Override\n+                public String next() {\n+                    Entry<String, Value> next = entriesIter.next();\n+                    return next.getValue().getString();\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public boolean remove(Object o) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public boolean addAll(Collection<? extends String> c) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public boolean removeAll(Collection<?> c) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public boolean retainAll(Collection<?> c) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public void clear() {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/services\/SystemProperties.java","additions":307,"deletions":0,"binary":false,"changes":307,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test TestJVMCISavedProperties\n+ * @bug 8309390\n+ * @summary Ensures Services.getSavedProperties() includes properties set on\n+ *          the command line as well some specified properties but not\n+ *          properties set programmatically.\n+ * @requires vm.flagless\n+ * @requires vm.jvmci\n+ * @library \/test\/lib\n+ * @run driver TestJVMCISavedProperties\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class TestJVMCISavedProperties {\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 0) {\n+            System.setProperty(\"app3.NotPresentInSavedProperties\", \"42\");\n+            System.out.println(\"DONE IN MAIN\");\n+            return;\n+        }\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:+EagerJVMCI\",\n+            \"-XX:+UseJVMCICompiler\",\n+            \"-Djvmci.Compiler=null\",\n+            \"-Ddebug.jvmci.PrintSavedProperties=true\",\n+            \"-Dapp1.propX=true\",\n+            \"-Dapp2.propY=SomeStringValue\",\n+            \"TestJVMCISavedProperties\", \"true\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.stdoutShouldContain(\"debug.jvmci.PrintSavedProperties=true\");\n+        output.stdoutShouldContain(\"jvmci.Compiler=null\");\n+        output.stdoutShouldContain(\"app1.propX=true\");\n+        output.stdoutShouldContain(\"app2.propY=SomeStringValue\");\n+        output.stdoutShouldContain(\"java.specification.version=\" + Runtime.version().feature());\n+        output.stdoutShouldContain(\"os.name=\");\n+        output.stdoutShouldContain(\"os.arch=\");\n+        output.stdoutShouldNotContain(\"NotPresentInSavedProperties\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/TestJVMCISavedProperties.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"}]}