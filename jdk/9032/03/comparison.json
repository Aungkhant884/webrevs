{"files":[{"patch":"@@ -2105,0 +2105,8 @@\n+void Assembler::evcvttps2qq(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 2 && VM_Version::supports_avx512dq(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x7A, (0xC0 | encode));\n+}\n+\n@@ -2185,0 +2193,8 @@\n+void Assembler::evpmovsqd(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 2, \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x25, (0xC0 | encode));\n+}\n+\n@@ -4296,0 +4312,10 @@\n+void Assembler::evpcmpeqq(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.reset_is_clear_context();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  int encode = vex_prefix_and_encode(kdst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x29, (0xC0 | encode));\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1172,1 +1172,1 @@\n-  \/\/ Convert vector float and int\n+  \/\/ Convert vector float to int\/long\n@@ -1175,0 +1175,1 @@\n+  void evcvttps2qq(XMMRegister dst, XMMRegister src, int vector_len);\n@@ -1192,0 +1193,3 @@\n+  \/\/ Evex casts with signed saturation\n+  void evpmovsqd(XMMRegister dst, XMMRegister src, int vector_len);\n+\n@@ -1789,0 +1793,1 @@\n+  void evpcmpeqq(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -4186,0 +4186,22 @@\n+void C2_MacroAssembler::vector_cast_float_to_long_special_cases_evex(\n+                                                             XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                             XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n+                                                             Register scratch, AddressLiteral double_sign_flip,\n+                                                             int vec_enc) {\n+  Label done;\n+  evmovdquq(xtmp1, k0, double_sign_flip, false, vec_enc, scratch);\n+  Assembler::evpcmpeqq(ktmp1, k0, xtmp1, dst, vec_enc);\n+  kortestwl(ktmp1, ktmp1);\n+  jccb(Assembler::equal, done);\n+\n+  vpxor(xtmp2, xtmp2, xtmp2, vec_enc);\n+  evcmpps(ktmp2, k0, src, src, Assembler::UNORD_Q, vec_enc);\n+  evmovdquq(dst, ktmp2, xtmp2, true, vec_enc);\n+\n+  kxorwl(ktmp1, ktmp1, ktmp2);\n+  evcmpps(ktmp1, ktmp1, src, xtmp2, Assembler::NLT_UQ, vec_enc);\n+  vpternlogq(xtmp2, 0x11, xtmp1, xtmp1, vec_enc);\n+  evmovdquq(dst, ktmp1, xtmp2, true, vec_enc);\n+  bind(done);\n+}\n+\n@@ -4244,0 +4266,7 @@\n+}\n+\n+void C2_MacroAssembler::vector_castF2L_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                            KRegister ktmp1, KRegister ktmp2, AddressLiteral double_sign_flip,\n+                                            Register scratch, int vec_enc) {\n+  evcvttps2qq(dst, src, vec_enc);\n+  vector_cast_float_to_long_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, scratch, double_sign_flip, vec_enc);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -313,0 +313,3 @@\n+  void vector_castF2L_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                           KRegister ktmp1, KRegister ktmp2, AddressLiteral double_sign_flip,\n+                           Register scratch, int vec_enc);\n@@ -329,0 +332,5 @@\n+  void vector_cast_float_to_long_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                    XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n+                                                    Register scratch, AddressLiteral double_sign_flip,\n+                                                    int vec_enc);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1871,5 +1871,9 @@\n-      if (is_subword_type(bt) || bt == T_INT) {\n-        return false;\n-      }\n-      if (bt == T_LONG && !VM_Version::supports_avx512dq()) {\n-        return false;\n+      \/\/ Conversion to integral type is only supported on AVX-512 platforms with avx512dq.\n+      \/\/ Need avx512vl for size_in_bits < 512\n+      if (is_integral_type(bt)) {\n+        if (!VM_Version::supports_avx512dq()) {\n+          return false;\n+        }\n+        if (size_in_bits < 512 && !VM_Version::supports_avx512vl()) {\n+          return false;\n+        }\n@@ -1884,2 +1888,14 @@\n-      if (is_subword_type(bt) || bt == T_LONG) {\n-        return false;\n+      \/\/ F2I is supported on all AVX and above platforms\n+      \/\/ For conversion to other integral types need AVX512:\n+      \/\/     Conversion to long in addition needs avx512dq\n+      \/\/     Need avx512vl for size_in_bits < 512\n+      if (is_integral_type(bt) && (bt != T_INT)) {\n+        if (UseAVX <= 2) {\n+          return false;\n+        }\n+        if ((bt == T_LONG) && !VM_Version::supports_avx512dq()) {\n+          return false;\n+        }\n+        if (size_in_bits < 512 && !VM_Version::supports_avx512vl()) {\n+          return false;\n+        }\n@@ -7275,0 +7291,2 @@\n+  \/\/ F2I conversion for < 64 byte vector using AVX instructions\n+  \/\/ AVX512 platforms that dont support avx512vl also use AVX instructions to support F2I\n@@ -7306,0 +7324,31 @@\n+instruct castFtoX_reg_evex(vec dst, vec src, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2, rRegP scratch, rFlagsReg cr) %{\n+  \/\/ F2X conversion for integral non T_INT target using AVX512 instructions\n+  \/\/ Platforms that dont support avx512vl can only support 64 byte vectors\n+  predicate(is_integral_type(Matcher::vector_element_basic_type(n)) &&\n+            Matcher::vector_element_basic_type(n) != T_INT);\n+  match(Set dst (VectorCastF2X src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP ktmp1, TEMP ktmp2, TEMP scratch, KILL cr);\n+  format %{ \"vector_cast_f2x $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1, $ktmp2 and $scratch as TEMP\" %}\n+  ins_encode %{\n+    BasicType to_elem_bt = Matcher::vector_element_basic_type(this);\n+    if (to_elem_bt == T_LONG) {\n+      int vlen_enc = vector_length_encoding(this);\n+      __ vector_castF2L_evex($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                             $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister,\n+                             ExternalAddress(vector_double_signflip()), $scratch$$Register, vlen_enc);\n+    } else {\n+      int vlen_enc = vector_length_encoding(this, $src);\n+      __ vector_castF2I_evex($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                             $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister,\n+                             ExternalAddress(vector_float_signflip()), $scratch$$Register, vlen_enc);\n+      if (to_elem_bt == T_SHORT) {\n+        __ evpmovdw($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+      } else {\n+        assert(to_elem_bt == T_BYTE, \"required\");\n+        __ evpmovdb($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+      }\n+    }\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -7317,2 +7366,2 @@\n-instruct castDtoL_reg_evex(vec dst, vec src, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2, rRegP scratch, rFlagsReg cr) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n+instruct castDtoX_reg_evex(vec dst, vec src, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2, rRegP scratch, rFlagsReg cr) %{\n+  predicate(is_integral_type(Matcher::vector_element_basic_type(n)));\n@@ -7321,1 +7370,1 @@\n-  format %{ \"vector_cast_d2l $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1, $ktmp2 and $scratch as TEMP\" %}\n+  format %{ \"vector_cast_d2x $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1, $ktmp2 and $scratch as TEMP\" %}\n@@ -7323,1 +7372,1 @@\n-    int vlen_enc = vector_length_encoding(this);\n+    int vlen_enc = vector_length_encoding(this, $src);\n@@ -7327,0 +7376,17 @@\n+    BasicType to_elem_bt = Matcher::vector_element_basic_type(this);\n+    if (to_elem_bt != T_LONG) {\n+      switch(to_elem_bt) {\n+        case T_INT:\n+          __ evpmovsqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+          break;\n+        case T_SHORT:\n+          __ evpmovsqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+          __ evpmovdw($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+          break;\n+        case T_BYTE:\n+          __ evpmovsqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+          __ evpmovdb($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+          break;\n+        default: assert(false, \"%s\", type2name(to_elem_bt));\n+      }\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":77,"deletions":11,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -0,0 +1,223 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8287835\n+* @summary Test float\/double to integral cast\n+* @modules jdk.incubator.vector\n+* @requires vm.compiler2.enabled\n+* @requires (os.simpleArch == \"x64\" & vm.cpu.features ~= \".*avx512dq.*\") \n+* @library \/test\/lib \/\n+* @run driver compiler.vectorapi.VectorFPtoIntCastTest\n+*\/\n+\n+package compiler.vectorapi;\n+\n+import jdk.incubator.vector.*;\n+import jdk.incubator.vector.FloatVector;\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+\n+public class VectorFPtoIntCastTest {\n+    private static final int COUNT = 16;\n+    private static final VectorSpecies<Float> fspec512 = FloatVector.SPECIES_512;\n+    private static final VectorSpecies<Double> dspec512 = DoubleVector.SPECIES_512;\n+    private static final VectorSpecies<Long> lspec512 = LongVector.SPECIES_512;\n+    private static final VectorSpecies<Integer> ispec512 = IntVector.SPECIES_512;\n+    private static final VectorSpecies<Integer> ispec256 = IntVector.SPECIES_256;\n+    private static final VectorSpecies<Short> sspec256 = ShortVector.SPECIES_256;\n+    private static final VectorSpecies<Short> sspec128 = ShortVector.SPECIES_128;\n+    private static final VectorSpecies<Byte> bspec128 = ByteVector.SPECIES_128;\n+    private static final VectorSpecies<Byte> bspec64  = ByteVector.SPECIES_64;\n+\n+    private float [] float_arr;\n+    private double [] double_arr;\n+    private long [] long_arr;\n+    private int [] int_arr;\n+    private short [] short_arr;\n+    private byte [] byte_arr;\n+\n+    private FloatVector fvec256;\n+    private FloatVector fvec512;\n+    private DoubleVector dvec512;\n+\n+    public static void main(String args[]) {\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\");\n+    }\n+\n+    public VectorFPtoIntCastTest() {\n+        float_arr = new float[COUNT];\n+        double_arr = new double[COUNT];\n+        long_arr = new long[COUNT];\n+        int_arr = new int[COUNT];\n+        short_arr = new short[COUNT];\n+        byte_arr = new byte[COUNT];\n+\n+        Random ran = new Random(0);\n+        for (int i = 0; i < COUNT; i++) {\n+            float_arr[i] = ran.nextFloat();\n+            double_arr[i] = ran.nextDouble();\n+        }\n+\n+        fvec256 = FloatVector.fromArray(FloatVector.SPECIES_256, float_arr, 0);\n+        fvec512 = FloatVector.fromArray(FloatVector.SPECIES_512, float_arr, 0);\n+        dvec512 = DoubleVector.fromArray(DoubleVector.SPECIES_512, double_arr, 0);\n+    }\n+\n+    @Test\n+    @IR(counts = {\"F2X\", \">= 1\"})\n+    public void float2int() {\n+        var cvec = (IntVector)fvec512.convertShape(VectorOperators.F2I, ispec512, 0);\n+        cvec.intoArray(int_arr, 0);\n+        checkf2int(cvec.length());\n+    }\n+\n+    public void checkf2int(int len) {\n+        for (int i = 0; i < len; i++) {\n+            int expected = (int)float_arr[i];\n+            if (int_arr[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: int_arr[\" + i + \"] = \" + int_arr[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"F2X\", \">= 1\"})\n+    public void float2long() {\n+        var cvec = (LongVector)fvec512.convertShape(VectorOperators.F2L, lspec512, 0);\n+        cvec.intoArray(long_arr, 0);\n+        checkf2long(cvec.length());\n+    }\n+\n+    public void checkf2long(int len) {\n+        for (int i = 0; i < len; i++) {\n+            long expected = (long)float_arr[i];\n+            if (long_arr[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: long_arr[\" + i + \"] = \" + long_arr[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"F2X\", \">= 1\"})\n+    public void float2short() {\n+        var cvec = (ShortVector)fvec512.convertShape(VectorOperators.F2S, sspec256, 0);\n+        cvec.intoArray(short_arr, 0);\n+        checkf2short(cvec.length());\n+    }\n+\n+    public void checkf2short(int len) {\n+        for (int i = 0; i < len; i++) {\n+            short expected = (short)float_arr[i];\n+            if (short_arr[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: short_arr[\" + i + \"] = \" + short_arr[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"F2X\", \">= 1\"})\n+    public void float2byte() {\n+        var cvec = (ByteVector)fvec512.convertShape(VectorOperators.F2B, bspec128, 0);\n+        cvec.intoArray(byte_arr, 0);\n+        checkf2byte(cvec.length());\n+    }\n+\n+    public void checkf2byte(int len) {\n+        for (int i = 0; i < len; i++) {\n+            byte expected = (byte)float_arr[i];\n+            if (byte_arr[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: byte_arr[\" + i + \"] = \" + byte_arr[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"D2X\", \">= 1\"})\n+    public void double2int() {\n+        var cvec = (IntVector)dvec512.convertShape(VectorOperators.D2I, ispec256, 0);\n+        cvec.intoArray(int_arr, 0);\n+        checkd2int(cvec.length());\n+    }\n+\n+    public void checkd2int(int len) {\n+        for (int i = 0; i < len; i++) {\n+            int expected = (int)double_arr[i];\n+            if (int_arr[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: int_arr[\" + i + \"] = \" + int_arr[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"D2X\", \">= 1\"})\n+    public void double2long() {\n+        var cvec = (LongVector)dvec512.convertShape(VectorOperators.D2L, lspec512, 0);\n+        cvec.intoArray(long_arr, 0);\n+        checkd2long(cvec.length());\n+    }\n+\n+    public void checkd2long(int len) {\n+        for (int i = 0; i < len; i++) {\n+            long expected = (long)double_arr[i];\n+            if (long_arr[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: long_arr[\" + i + \"] = \" + long_arr[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"D2X\", \">= 1\"})\n+    public void double2short() {\n+        var cvec = (ShortVector)dvec512.convertShape(VectorOperators.D2S, sspec128, 0);\n+        cvec.intoArray(short_arr, 0);\n+        checkd2short(cvec.length());\n+    }\n+\n+    public void checkd2short(int len) {\n+        for (int i = 0; i < len; i++) {\n+            short expected = (short)double_arr[i];\n+            if (short_arr[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: short_arr[\" + i + \"] = \" + short_arr[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"D2X\", \">= 1\"})\n+    public void double2byte() {\n+        var cvec = (ByteVector)dvec512.convertShape(VectorOperators.D2B, bspec64, 0);\n+        cvec.intoArray(byte_arr, 0);\n+        checkd2byte(cvec.length());\n+    }\n+\n+    public void checkd2byte(int len) {\n+        for (int i = 0; i < len; i++) {\n+            byte expected = (byte)double_arr[i];\n+            if (byte_arr[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: byte_arr[\" + i + \"] = \" + byte_arr[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorFPtoIntCastTest.java","additions":223,"deletions":0,"binary":false,"changes":223,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import jdk.incubator.vector.*;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Fork(jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class VectorFPtoIntCastOperations {\n+\n+    FloatVector fvec256;\n+    FloatVector fvec512;\n+    DoubleVector dvec512;\n+\n+    static final float [] float_arr = {\n+      1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f,\n+      9.0f, 10.0f, 11.0f, 12.0f, 13.0f, 14.0f, 15.0f, 16.0f\n+    };\n+\n+    static final double [] double_arr = {\n+      1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0,\n+      9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0\n+    };\n+\n+    @Setup(Level.Trial)\n+    public void BmSetup() {\n+        fvec256 = FloatVector.fromArray(FloatVector.SPECIES_256, float_arr, 0);\n+        fvec512 = FloatVector.fromArray(FloatVector.SPECIES_512, float_arr, 0);\n+        dvec512 = DoubleVector.fromArray(DoubleVector.SPECIES_512, double_arr, 0);\n+    }\n+\n+    @Benchmark\n+    public IntVector microFloat2Int() {\n+        return (IntVector)fvec512.convertShape(VectorOperators.F2I, IntVector.SPECIES_512, 0);\n+    }\n+\n+    @Benchmark\n+    public LongVector microFloat2Long() {\n+        return (LongVector)fvec256.convertShape(VectorOperators.F2L, LongVector.SPECIES_512, 0);\n+    }\n+\n+    @Benchmark\n+    public ShortVector microFloat2Short() {\n+        return (ShortVector)fvec512.convertShape(VectorOperators.F2S, ShortVector.SPECIES_256, 0);\n+    }\n+\n+    @Benchmark\n+    public ByteVector microFloat2Byte() {\n+        return (ByteVector)fvec512.convertShape(VectorOperators.F2B, ByteVector.SPECIES_128, 0);\n+    }\n+\n+    @Benchmark\n+    public IntVector microDouble2Int() {\n+        return (IntVector)dvec512.convertShape(VectorOperators.D2I, IntVector.SPECIES_256, 0);\n+    }\n+\n+    @Benchmark\n+    public LongVector microDouble2Long() {\n+        return (LongVector)dvec512.convertShape(VectorOperators.D2L, LongVector.SPECIES_512, 0);\n+    }\n+\n+    @Benchmark\n+    public ShortVector microDouble2Short() {\n+        return (ShortVector)dvec512.convertShape(VectorOperators.D2S, ShortVector.SPECIES_128, 0);\n+    }\n+\n+    @Benchmark\n+    public ByteVector microDouble2Byte() {\n+        return (ByteVector)dvec512.convertShape(VectorOperators.D2B, ByteVector.SPECIES_64, 0);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/VectorFPtoIntCastOperations.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"}]}