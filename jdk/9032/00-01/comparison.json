{"files":[{"patch":"@@ -2169,16 +2169,0 @@\n-void Assembler::evpmovsdw(XMMRegister dst, XMMRegister src, int vector_len) {\n-  assert(UseAVX > 2, \"\");\n-  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  attributes.set_is_evex_instruction();\n-  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes);\n-  emit_int16(0x23, (0xC0 | encode));\n-}\n-\n-void Assembler::evpmovsdb(XMMRegister dst, XMMRegister src, int vector_len) {\n-  assert(UseAVX > 2, \"\");\n-  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  attributes.set_is_evex_instruction();\n-  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes);\n-  emit_int16(0x21, (0xC0 | encode));\n-}\n-\n@@ -2217,16 +2201,0 @@\n-void Assembler::evpmovsqb(XMMRegister dst, XMMRegister src, int vector_len) {\n-  assert(UseAVX > 2, \"\");\n-  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  attributes.set_is_evex_instruction();\n-  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes);\n-  emit_int16(0x22, (0xC0 | encode));\n-}\n-\n-void Assembler::evpmovsqw(XMMRegister dst, XMMRegister src, int vector_len) {\n-  assert(UseAVX > 2, \"\");\n-  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  attributes.set_is_evex_instruction();\n-  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes);\n-  emit_int16(0x24, (0xC0 | encode));\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1194,2 +1194,0 @@\n-  void evpmovsdw(XMMRegister dst, XMMRegister src, int vector_len);\n-  void evpmovsdb(XMMRegister dst, XMMRegister src, int vector_len);\n@@ -1197,2 +1195,0 @@\n-  void evpmovsqb(XMMRegister dst, XMMRegister src, int vector_len);\n-  void evpmovsqw(XMMRegister dst, XMMRegister src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1871,6 +1871,9 @@\n-      if (((UseAVX <= 2) || (!VM_Version::supports_avx512vl())) &&\n-          (is_subword_type(bt) || bt == T_INT)) {\n-        return false;\n-      }\n-      if (is_integral_type(bt) && !VM_Version::supports_avx512dq()) {\n-        return false;\n+      \/\/ Conversion to integral type is only supported on AVX-512 platforms with avx512dq.\n+      \/\/ Need avx512vl for size_in_bits < 512\n+      if (is_integral_type(bt)) {\n+        if (!VM_Version::supports_avx512dq()) {\n+          return false;\n+        }\n+        if (size_in_bits < 512 && !VM_Version::supports_avx512vl()) {\n+          return false;\n+        }\n@@ -1885,6 +1888,14 @@\n-      if (((UseAVX <= 2) || (!VM_Version::supports_avx512vl())) &&\n-          (is_subword_type(bt) || bt == T_LONG)) {\n-        return false;\n-      }\n-      if ((bt == T_LONG) && !VM_Version::supports_avx512dq()) {\n-        return false;\n+      \/\/ F2I is supported on all AVX and above platforms\n+      \/\/ For conversion to other integral types need AVX512:\n+      \/\/     Conversion to long in addition needs avx512dq\n+      \/\/     Need avx512vl for size_in_bits < 512\n+      if (is_integral_type(bt) && (bt != T_INT)) {\n+        if (UseAVX <= 2) {\n+          return false;\n+        }\n+        if ((bt == T_LONG) && !VM_Version::supports_avx512dq()) {\n+          return false;\n+        }\n+        if (size_in_bits < 512 && !VM_Version::supports_avx512vl()) {\n+          return false;\n+        }\n@@ -7280,0 +7291,2 @@\n+  \/\/ F2I conversion for < 64 byte vector using AVX instructions\n+  \/\/ AVX512 platforms that dont support avx512vl also use AVX instructions to support F2I\n@@ -7295,0 +7308,16 @@\n+instruct castFtoI_reg_evex(vec dst, vec src, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2, rRegP scratch, rFlagsReg cr) %{\n+  predicate((VM_Version::supports_avx512vl() ||\n+             Matcher::vector_length_in_bytes(n) == 64) &&\n+             Matcher::vector_element_basic_type(n) == T_INT);\n+  match(Set dst (VectorCastF2X src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP ktmp1, TEMP ktmp2, TEMP scratch, KILL cr);\n+  format %{ \"vector_cast_f2i $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1, $ktmp2 and $scratch as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vector_castF2I_evex($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                           $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister,\n+                           ExternalAddress(vector_float_signflip()), $scratch$$Register, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -7296,3 +7325,6 @@\n-  predicate(((VM_Version::supports_avx512vl() ||\n-              Matcher::vector_length_in_bytes(n) == 64)) &&\n-             is_integral_type(Matcher::vector_element_basic_type(n)));\n+  \/\/ F2X conversion for integral non T_INT target using AVX512 instructions\n+  \/\/ Platforms that dont support avx512vl can only support 64 byte vectors\n+  predicate((VM_Version::supports_avx512vl() ||\n+             Matcher::vector_length_in_bytes(n) == 64) &&\n+            is_integral_type(Matcher::vector_element_basic_type(n)) &&\n+            Matcher::vector_element_basic_type(n) != T_INT);\n@@ -7316,1 +7348,2 @@\n-      } else if (to_elem_bt == T_BYTE){\n+      } else {\n+        assert(to_elem_bt == T_BYTE, \"required\");\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":49,"deletions":16,"binary":false,"changes":65,"status":"modified"}]}