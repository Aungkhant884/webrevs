{"files":[{"patch":"@@ -2105,0 +2105,8 @@\n+void Assembler::evcvttps2qq(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 2 && VM_Version::supports_avx512dq(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x7A, (0xC0 | encode));\n+}\n+\n@@ -2161,0 +2169,16 @@\n+void Assembler::evpmovsdw(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 2, \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x23, (0xC0 | encode));\n+}\n+\n+void Assembler::evpmovsdb(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 2, \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x21, (0xC0 | encode));\n+}\n+\n@@ -2185,0 +2209,24 @@\n+void Assembler::evpmovsqd(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 2, \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x25, (0xC0 | encode));\n+}\n+\n+void Assembler::evpmovsqb(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 2, \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x22, (0xC0 | encode));\n+}\n+\n+void Assembler::evpmovsqw(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 2, \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x24, (0xC0 | encode));\n+}\n+\n@@ -4296,0 +4344,10 @@\n+void Assembler::evpcmpeqq(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.reset_is_clear_context();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  int encode = vex_prefix_and_encode(kdst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x29, (0xC0 | encode));\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":58,"deletions":0,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -1172,1 +1172,1 @@\n-  \/\/ Convert vector float and int\n+  \/\/ Convert vector float to int\/long\n@@ -1175,0 +1175,1 @@\n+  void evcvttps2qq(XMMRegister dst, XMMRegister src, int vector_len);\n@@ -1192,0 +1193,7 @@\n+  \/\/ Evex casts with signed saturation\n+  void evpmovsdw(XMMRegister dst, XMMRegister src, int vector_len);\n+  void evpmovsdb(XMMRegister dst, XMMRegister src, int vector_len);\n+  void evpmovsqd(XMMRegister dst, XMMRegister src, int vector_len);\n+  void evpmovsqb(XMMRegister dst, XMMRegister src, int vector_len);\n+  void evpmovsqw(XMMRegister dst, XMMRegister src, int vector_len);\n+\n@@ -1789,0 +1797,1 @@\n+  void evpcmpeqq(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -4186,0 +4186,22 @@\n+void C2_MacroAssembler::vector_cast_float_to_long_special_cases_evex(\n+                                                             XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                             XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n+                                                             Register scratch, AddressLiteral double_sign_flip,\n+                                                             int vec_enc) {\n+  Label done;\n+  evmovdquq(xtmp1, k0, double_sign_flip, false, vec_enc, scratch);\n+  Assembler::evpcmpeqq(ktmp1, k0, xtmp1, dst, vec_enc);\n+  kortestwl(ktmp1, ktmp1);\n+  jccb(Assembler::equal, done);\n+\n+  vpxor(xtmp2, xtmp2, xtmp2, vec_enc);\n+  evcmpps(ktmp2, k0, src, src, Assembler::UNORD_Q, vec_enc);\n+  evmovdquq(dst, ktmp2, xtmp2, true, vec_enc);\n+\n+  kxorwl(ktmp1, ktmp1, ktmp2);\n+  evcmpps(ktmp1, ktmp1, src, xtmp2, Assembler::NLT_UQ, vec_enc);\n+  vpternlogq(xtmp2, 0x11, xtmp1, xtmp1, vec_enc);\n+  evmovdquq(dst, ktmp1, xtmp2, true, vec_enc);\n+  bind(done);\n+}\n+\n@@ -4244,0 +4266,7 @@\n+}\n+\n+void C2_MacroAssembler::vector_castF2L_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                            KRegister ktmp1, KRegister ktmp2, AddressLiteral double_sign_flip,\n+                                            Register scratch, int vec_enc) {\n+  evcvttps2qq(dst, src, vec_enc);\n+  vector_cast_float_to_long_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, scratch, double_sign_flip, vec_enc);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -313,0 +313,3 @@\n+  void vector_castF2L_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                           KRegister ktmp1, KRegister ktmp2, AddressLiteral double_sign_flip,\n+                           Register scratch, int vec_enc);\n@@ -329,0 +332,5 @@\n+  void vector_cast_float_to_long_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                    XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n+                                                    Register scratch, AddressLiteral double_sign_flip,\n+                                                    int vec_enc);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1871,1 +1871,2 @@\n-      if (is_subword_type(bt) || bt == T_INT) {\n+      if (((UseAVX <= 2) || (!VM_Version::supports_avx512vl())) &&\n+          (is_subword_type(bt) || bt == T_INT)) {\n@@ -1874,1 +1875,1 @@\n-      if (bt == T_LONG && !VM_Version::supports_avx512dq()) {\n+      if (is_integral_type(bt) && !VM_Version::supports_avx512dq()) {\n@@ -1884,1 +1885,5 @@\n-      if (is_subword_type(bt) || bt == T_LONG) {\n+      if (((UseAVX <= 2) || (!VM_Version::supports_avx512vl())) &&\n+          (is_subword_type(bt) || bt == T_LONG)) {\n+        return false;\n+      }\n+      if ((bt == T_LONG) && !VM_Version::supports_avx512dq()) {\n@@ -7290,4 +7295,4 @@\n-instruct castFtoI_reg_evex(vec dst, vec src, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2, rRegP scratch, rFlagsReg cr) %{\n-  predicate((VM_Version::supports_avx512vl() ||\n-             Matcher::vector_length_in_bytes(n) == 64) &&\n-             Matcher::vector_element_basic_type(n) == T_INT);\n+instruct castFtoX_reg_evex(vec dst, vec src, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2, rRegP scratch, rFlagsReg cr) %{\n+  predicate(((VM_Version::supports_avx512vl() ||\n+              Matcher::vector_length_in_bytes(n) == 64)) &&\n+             is_integral_type(Matcher::vector_element_basic_type(n)));\n@@ -7296,1 +7301,1 @@\n-  format %{ \"vector_cast_f2i $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1, $ktmp2 and $scratch as TEMP\" %}\n+  format %{ \"vector_cast_f2x $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1, $ktmp2 and $scratch as TEMP\" %}\n@@ -7298,4 +7303,17 @@\n-    int vlen_enc = vector_length_encoding(this);\n-    __ vector_castF2I_evex($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n-                           $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister,\n-                           ExternalAddress(vector_float_signflip()), $scratch$$Register, vlen_enc);\n+    BasicType to_elem_bt = Matcher::vector_element_basic_type(this);\n+    if (to_elem_bt == T_LONG) {\n+      int vlen_enc = vector_length_encoding(this);\n+      __ vector_castF2L_evex($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                             $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister,\n+                             ExternalAddress(vector_double_signflip()), $scratch$$Register, vlen_enc);\n+    } else {\n+      int vlen_enc = vector_length_encoding(this, $src);\n+      __ vector_castF2I_evex($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                             $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister,\n+                             ExternalAddress(vector_float_signflip()), $scratch$$Register, vlen_enc);\n+      if (to_elem_bt == T_SHORT) {\n+        __ evpmovdw($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+      } else if (to_elem_bt == T_BYTE){\n+        __ evpmovdb($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+      }\n+    }\n@@ -7317,2 +7335,2 @@\n-instruct castDtoL_reg_evex(vec dst, vec src, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2, rRegP scratch, rFlagsReg cr) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n+instruct castDtoX_reg_evex(vec dst, vec src, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2, rRegP scratch, rFlagsReg cr) %{\n+  predicate(is_integral_type(Matcher::vector_element_basic_type(n)));\n@@ -7321,1 +7339,1 @@\n-  format %{ \"vector_cast_d2l $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1, $ktmp2 and $scratch as TEMP\" %}\n+  format %{ \"vector_cast_d2x $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1, $ktmp2 and $scratch as TEMP\" %}\n@@ -7323,1 +7341,1 @@\n-    int vlen_enc = vector_length_encoding(this);\n+    int vlen_enc = vector_length_encoding(this, $src);\n@@ -7327,0 +7345,17 @@\n+    BasicType to_elem_bt = Matcher::vector_element_basic_type(this);\n+    if (to_elem_bt != T_LONG) {\n+      switch(to_elem_bt) {\n+        case T_INT:\n+          __ evpmovsqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+          break;\n+        case T_SHORT:\n+          __ evpmovsqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+          __ evpmovdw($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+          break;\n+        case T_BYTE:\n+          __ evpmovsqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+          __ evpmovdb($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+          break;\n+        default: assert(false, \"%s\", type2name(to_elem_bt));\n+      }\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":51,"deletions":16,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import jdk.incubator.vector.*;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Fork(jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class VectorFPtoIntCastOperations {\n+\n+    FloatVector fvec256;\n+    FloatVector fvec512;\n+    DoubleVector dvec512;\n+\n+    static final float [] float_arr = {\n+      1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f,\n+      9.0f, 10.0f, 11.0f, 12.0f, 13.0f, 14.0f, 15.0f, 16.0f\n+    };\n+\n+    static final double [] double_arr = {\n+      1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0,\n+      9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0\n+    };\n+\n+    @Setup(Level.Trial)\n+    public void BmSetup() {\n+        fvec256 = FloatVector.fromArray(FloatVector.SPECIES_256, float_arr, 0);\n+        fvec512 = FloatVector.fromArray(FloatVector.SPECIES_512, float_arr, 0);\n+        dvec512 = DoubleVector.fromArray(DoubleVector.SPECIES_512, double_arr, 0);\n+    }\n+\n+    @Benchmark\n+    public IntVector microFloat2Int() {\n+        return (IntVector)fvec512.convertShape(VectorOperators.F2I, IntVector.SPECIES_512, 0);\n+    }\n+\n+    @Benchmark\n+    public LongVector microFloat2Long() {\n+        return (LongVector)fvec256.convertShape(VectorOperators.F2L, LongVector.SPECIES_512, 0);\n+    }\n+\n+    @Benchmark\n+    public ShortVector microFloat2Short() {\n+        return (ShortVector)fvec512.convertShape(VectorOperators.F2S, ShortVector.SPECIES_256, 0);\n+    }\n+\n+    @Benchmark\n+    public ByteVector microFloat2Byte() {\n+        return (ByteVector)fvec512.convertShape(VectorOperators.F2B, ByteVector.SPECIES_128, 0);\n+    }\n+\n+    @Benchmark\n+    public IntVector microDouble2Int() {\n+        return (IntVector)dvec512.convertShape(VectorOperators.D2I, IntVector.SPECIES_256, 0);\n+    }\n+\n+    @Benchmark\n+    public LongVector microDouble2Long() {\n+        return (LongVector)dvec512.convertShape(VectorOperators.D2L, LongVector.SPECIES_512, 0);\n+    }\n+\n+    @Benchmark\n+    public ShortVector microDouble2Short() {\n+        return (ShortVector)dvec512.convertShape(VectorOperators.D2S, ShortVector.SPECIES_128, 0);\n+    }\n+\n+    @Benchmark\n+    public ByteVector microDouble2Byte() {\n+        return (ByteVector)dvec512.convertShape(VectorOperators.D2B, ByteVector.SPECIES_64, 0);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/VectorFPtoIntCastOperations.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"}]}