{"files":[{"patch":"@@ -90,0 +90,2 @@\n+    static final Class<?>[] EMPTY_PARAM_TYPES = new Class<?>[0];\n+\n@@ -421,1 +423,1 @@\n-                            cl, \"readObjectNoData\", null, Void.TYPE);\n+                            cl, \"readObjectNoData\", EMPTY_PARAM_TYPES, Void.TYPE);\n@@ -426,1 +428,1 @@\n-                        cl, \"writeReplace\", null, Object.class);\n+                        cl, \"writeReplace\", EMPTY_PARAM_TYPES, Object.class);\n@@ -428,1 +430,1 @@\n-                        cl, \"readResolve\", null, Object.class);\n+                        cl, \"readResolve\", EMPTY_PARAM_TYPES, Object.class);\n@@ -1479,0 +1481,38 @@\n+    \/**\n+     * {@return The field declared in {@code cls} with the specified\n+     * {@code fieldType} and {@code name}}.\n+     * @param cls the class in which the field is located\n+     * @param fieldType the field's type\n+     * @param name the field's name\n+     * @throws NoSuchFieldError if the specific field is not declared in the class\n+     *\/\n+    static Field getDeclaredField(Class<?> cls,\n+            Class<?> fieldType, String name) {\n+        for (Field f : cls.getDeclaredFields()) {\n+            if (f.getType() == fieldType && f.getName().equals(name)) {\n+                return f;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * {@return The method declared in {@code cls} with the specified\n+     * {@code returnType}, {@code name} and {@code parameterTypes}}\n+     * @param cls the class in which the method is located\n+     * @param returnType the method's return type\n+     * @param name the method's name\n+     * @param parameterTypes the method's parameter types\n+     * @throws NoSuchMethodError if the specific method is not declared in the class\n+     *\/\n+    static Method getDeclaredMethod(Class<?> cls,\n+        Class<?> returnType, String name, Class<?>... parameterTypes) {\n+        for (Method m : cls.getDeclaredMethods()) {\n+            if (m.getReturnType() == returnType && m.getName().equals(name)\n+                && Arrays.equals(m.getParameterTypes(), parameterTypes)) {\n+                return m;\n+            }\n+        }\n+        return null;\n+    }\n+\n@@ -1487,3 +1527,2 @@\n-                                               Class<?> returnType)\n-    {\n-        Method meth = null;\n+                                               Class<?> returnType) {\n+        Method meth;\n@@ -1491,3 +1530,6 @@\n-        while (defCl != null) {\n-            try {\n-                meth = defCl.getDeclaredMethod(name, argTypes);\n+        for (;;) {\n+            if (defCl == null) {\n+                return null;\n+            }\n+            meth = getDeclaredMethod(defCl, returnType, name, argTypes);\n+            if (meth != null) {\n@@ -1495,2 +1537,0 @@\n-            } catch (NoSuchMethodException ex) {\n-                defCl = defCl.getSuperclass();\n@@ -1498,4 +1538,1 @@\n-        }\n-\n-        if ((meth == null) || (meth.getReturnType() != returnType)) {\n-            return null;\n+            defCl = defCl.getSuperclass();\n@@ -1523,10 +1560,3 @@\n-                                           Class<?> returnType)\n-    {\n-        try {\n-            Method meth = cl.getDeclaredMethod(name, argTypes);\n-            meth.setAccessible(true);\n-            int mods = meth.getModifiers();\n-            return ((meth.getReturnType() == returnType) &&\n-                    ((mods & Modifier.STATIC) == 0) &&\n-                    ((mods & Modifier.PRIVATE) != 0)) ? meth : null;\n-        } catch (NoSuchMethodException ex) {\n+                                           Class<?> returnType) {\n+        Method meth = getDeclaredMethod(cl, returnType, name, argTypes);\n+        if (meth == null) {\n@@ -1535,0 +1565,4 @@\n+        meth.setAccessible(true);\n+        int mods = meth.getModifiers();\n+        return (((mods & Modifier.STATIC) == 0) &&\n+                ((mods & Modifier.PRIVATE) != 0)) ? meth : null;\n@@ -1636,1 +1670,1 @@\n-            Field f = cl.getDeclaredField(\"serialPersistentFields\");\n+            Field f = getDeclaredField(cl, ObjectStreamField[].class, \"serialPersistentFields\");\n@@ -1642,1 +1676,1 @@\n-        } catch (Exception ex) {\n+        } catch (Exception ignored) {\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":61,"deletions":27,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+JUnit.dirs=.\n","filename":"test\/jdk\/java\/io\/Serializable\/multiMagic\/TEST.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,241 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8313961\n+ * @summary Checks that the search for magic methods does not depend on the\n+ * specification of Class.getDeclared[Field|Method]() when it chooses the\n+ * reflective object to return.\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *\/\n+\n+package java.io;\n+\n+import jdk.internal.classfile.ClassBuilder;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.TypeKind;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.List;\n+\n+import static java.lang.constant.ConstantDescs.*;\n+import static java.lang.reflect.AccessFlag.PUBLIC;\n+import static jdk.internal.classfile.Classfile.*;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class MultiMagicTest {\n+\n+    \/*\n+     * This test class generated, loads, and instantiate a Serializable object\n+     * to check the fix explained in the JBS issue.\n+     *\n+     * The generated classes cannot be described in Java, because it does not\n+     * admit multiple fields with the same name but different types, nor does it\n+     * admit multiple methods with the same name and same parameter types but\n+     * different return types.\n+     * The pseudo-Java classes are the following\n+     *\n+    public class SuperMultiMagic implements Serializable {\n+        public SuperMultiMagic() {\n+        }\n+        public Integer writeReplace() {\n+            return null;\n+        }\n+        public Object writeReplace() {\n+            return null;\n+        }\n+    }\n+\n+    public class MultiMagic extends SuperMultiMagic {\n+        private static final int serialPersistentFields = 0;\n+        private static final ObjectStreamField[] serialPersistentFields =\n+            new ObjectStreamField[0];\n+\n+        public MultiMagic() {\n+        }\n+        private int writeObject(ObjectOutputStream oos) {\n+            return 0;\n+        }\n+        private void writeObject(ObjectOutputStream oos) {\n+        }\n+        public Integer writeReplace() {\n+            return null;\n+        }\n+    }\n+     *\n+     *\/\n+\n+    private static final String SUPER_MULTI_MAGIC_CLS_NAME = \"SuperMultiMagic\";\n+    private static final String MULTI_MAGIC_CLS_NAME = \"MultiMagic\";\n+\n+    private static void addSuperConstructor(ClassBuilder cb) {\n+        cb.withMethod(INIT_NAME,\n+            MTD_void,\n+            ACC_PUBLIC,\n+            mb -> mb.withCode(\n+                b -> b.aload(0)\n+                    .invokespecial(CD_Object, INIT_NAME, MTD_void)\n+                    .return_()));\n+    }\n+\n+    private static void addClassInit(ClassBuilder cb) {\n+        cb.withMethod(CLASS_INIT_NAME,\n+            MTD_void,\n+            ACC_STATIC,\n+            mb -> mb.withCode(\n+                b -> b.iconst_0()\n+                    .putstatic(cb.constantPool().fieldRefEntry(\n+                        ClassDesc.of(\"MultiMagic\"),\n+                        \"serialPersistentFields\",\n+                        CD_int))\n+\n+                    .iconst_0()\n+                    .anewarray(ClassDesc.ofDescriptor(\n+                        ObjectStreamField.class.descriptorString()))\n+                    .putstatic(cb.constantPool().fieldRefEntry(\n+                        ClassDesc.of(\"MultiMagic\"),\n+                        \"serialPersistentFields\",\n+                        ClassDesc.ofDescriptor(\n+                            ObjectStreamField[].class.descriptorString())))\n+\n+                    .return_()));\n+    }\n+\n+    private static void addConstructor(ClassBuilder cb) {\n+        cb.withMethod(INIT_NAME,\n+            MTD_void,\n+            ACC_PUBLIC,\n+            mb -> mb.withCode(\n+                b -> b.aload(0)\n+                    .invokespecial(ClassDesc.of(\n+                        SUPER_MULTI_MAGIC_CLS_NAME), INIT_NAME, MTD_void)\n+                    .return_()));\n+    }\n+\n+    private static void addOtherSerialPersistentFields(ClassBuilder cb) {\n+        cb.withField(\"serialPersistentFields\",\n+            CD_int,\n+            ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n+    }\n+\n+    private static void addMagicSerialPersistentFields(ClassBuilder cb) {\n+        cb.withField(\"serialPersistentFields\",\n+            ClassDesc.ofDescriptor(ObjectStreamField[].class.descriptorString()),\n+            ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n+    }\n+\n+    private static void addOtherWriteObject(ClassBuilder cb) {\n+        cb.withMethod(\"writeObject\",\n+            MethodTypeDesc.of(CD_int, ClassDesc.of(\n+                ObjectOutputStream.class.getName())),\n+            ACC_PRIVATE,\n+            mb -> mb.withCode(\n+                b -> b.iconst_0()\n+                    .returnInstruction(TypeKind.IntType)));\n+    }\n+\n+    private static void addMagicWriteObject(ClassBuilder cb) {\n+        cb.withMethod(\"writeObject\",\n+            MethodTypeDesc.of(CD_void, ClassDesc.of(\n+                ObjectOutputStream.class.getName())),\n+            ACC_PRIVATE,\n+            mb -> mb.withCode(CodeBuilder::return_));\n+    }\n+\n+    private static void addOtherWriteReplace(ClassBuilder cb) {\n+        cb.withMethod(\"writeReplace\",\n+            MethodTypeDesc.of(CD_Integer),\n+            ACC_PUBLIC,\n+            mb -> mb.withCode(\n+                b -> b.aconst_null()\n+                    .returnInstruction(TypeKind.ReferenceType)));\n+    }\n+\n+    private static void addMagicWriteReplace(ClassBuilder cb) {\n+        cb.withMethod(\"writeReplace\",\n+            MethodTypeDesc.of(CD_Object),\n+            ACC_PUBLIC,\n+            mb -> mb.withCode(\n+                b -> b.aconst_null()\n+                    .returnInstruction(TypeKind.ReferenceType)));\n+    }\n+\n+    private static Object generateLoadInstantiate()\n+        throws ReflectiveOperationException {\n+        byte[] superClassFile = Classfile.of()\n+            .build(ClassDesc.of(SUPER_MULTI_MAGIC_CLS_NAME),\n+            cb -> {\n+                cb.withFlags(PUBLIC)\n+                    .withInterfaceSymbols(List.of(ClassDesc.of(\n+                        Serializable.class.getName())));\n+                addSuperConstructor(cb);\n+                addOtherWriteReplace(cb);\n+                addMagicWriteReplace(cb);\n+            });\n+        byte[] classFile = Classfile.of().build(ClassDesc.of(MULTI_MAGIC_CLS_NAME),\n+            cb -> {\n+                cb.withFlags(PUBLIC)\n+                    .withSuperclass(ClassDesc.of(SUPER_MULTI_MAGIC_CLS_NAME));\n+                addOtherSerialPersistentFields(cb);\n+                addMagicSerialPersistentFields(cb);\n+                addClassInit(cb);\n+                addConstructor(cb);\n+                addOtherWriteObject(cb);\n+                addMagicWriteObject(cb);\n+                addOtherWriteReplace(cb);\n+            });\n+\n+        ClassLoader loader = new ClassLoader() {\n+            @Override\n+            protected Class<?> findClass(String name) {\n+                if (SUPER_MULTI_MAGIC_CLS_NAME.equals(name)) {\n+                    return super.defineClass(name, superClassFile, 0, superClassFile.length);\n+                }\n+                if (MULTI_MAGIC_CLS_NAME.equals(name)) {\n+                    return super.defineClass(name, classFile, 0, classFile.length);\n+                }\n+                throw new AssertionError();\n+            }\n+        };\n+        return loader.loadClass(MULTI_MAGIC_CLS_NAME)\n+            .getConstructor(new Class<?>[0])\n+            .newInstance();\n+    }\n+\n+    @Test\n+    public void test() throws ReflectiveOperationException {\n+        Object multiMagicInstance = generateLoadInstantiate();\n+        Class<?> multiMagicClass = multiMagicInstance.getClass();\n+        ObjectStreamClass osc = ObjectStreamClass.lookup(multiMagicClass);\n+\n+        assertEquals(ObjectStreamField[].class, osc.getFields().getClass());\n+        assertEquals(0, osc.getFields().length);\n+        assertTrue(osc.hasWriteObjectMethod());\n+        assertTrue(osc.hasWriteReplaceMethod());\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/io\/Serializable\/multiMagic\/java.base\/java\/io\/MultiMagicTest.java","additions":241,"deletions":0,"binary":false,"changes":241,"status":"added"}]}