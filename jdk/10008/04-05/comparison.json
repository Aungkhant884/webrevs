{"files":[{"patch":"@@ -602,3 +602,4 @@\n-        \/\/ Returns all installed providers\n-        \/\/ if the selection criteria is null.\n-        if (entries == null || entries.isEmpty() || allProviders == null) {\n+        if (allProviders == null || allProviders.length == 0) {\n+            return null;\n+        } else if (entries == null) {\n+            \/\/ return all installed providers if the selection criteria is null\n@@ -606,0 +607,4 @@\n+        } else if (entries.isEmpty()) {\n+            \/\/ return null if the selection criteria is empty; this is to match\n+            \/\/ earlier behavior\n+            return null;\n@@ -613,4 +618,3 @@\n-        Iterator<Map.Entry<String, String>> iter = entries.iterator();\n-        while (iter.hasNext()) {\n-            Map.Entry<String, String> e = iter.next();\n-            new Criteria(e.getKey(), e.getValue()).apply(candidates);\n+        for (var e : entries) {\n+            Criteria cr = new Criteria(e.getKey(), e.getValue());\n+            candidates.removeIf(p -> !cr.isCriterionSatisfied(p));\n@@ -618,2 +622,1 @@\n-                \/\/ bail; no further filtering needed\n-                break;\n+                return null;\n@@ -623,3 +626,0 @@\n-        if (candidates.isEmpty())\n-            return null;\n-\n@@ -821,4 +821,4 @@\n-        private String serviceName;\n-        private String algName;\n-        private String attrName = null;\n-        private String attrValue;\n+        private final String serviceName;\n+        private final String algName;\n+        private final String attrName;\n+        private final String attrValue;\n@@ -827,1 +827,0 @@\n-            int snEndIndex = key.indexOf('.');\n@@ -829,0 +828,1 @@\n+            int snEndIndex = key.indexOf('.');\n@@ -842,0 +842,1 @@\n+                attrName = null;\n@@ -847,1 +848,0 @@\n-\n@@ -849,1 +849,2 @@\n-                    throw new InvalidParameterException(\"Invalid filter\");\n+                    throw new InvalidParameterException\n+                            (\"Invalid filter - need algorithm name\");\n@@ -853,2 +854,4 @@\n-                if (isKnownComposite(attrName) &&\n-                        attrValue.indexOf('|') != -1) {\n+                if (attrName.isEmpty()) {\n+                    throw new InvalidParameterException\n+                            (\"Invalid filter - need attribute name\");\n+                } else if (isCompositeValue() && attrValue.indexOf('|') != -1) {\n@@ -856,1 +859,1 @@\n-                        (\"composite values unsupported for filtering\");\n+                            (\"Invalid filter - composite values unsupported\");\n@@ -859,0 +862,1 @@\n+\n@@ -860,3 +864,3 @@\n-            if (serviceName.isEmpty() || algName.isEmpty() ||\n-                    (!attrValue.isEmpty() && attrName.isEmpty())) {\n-                throw new InvalidParameterException(\"Invalid filter\");\n+            if (serviceName.isEmpty() || algName.isEmpty()) {\n+                throw new InvalidParameterException\n+                        (\"Invalid filter - need service and algorithm\");\n@@ -865,8 +869,9 @@\n-        void apply(LinkedList<Provider> candidates) {\n-            Iterator<Provider> provs = candidates.iterator();\n-            while (provs.hasNext()) {\n-                Provider p = provs.next();\n-                if (!isCriterionSatisfied(p)) {\n-                    provs.remove();\n-                }\n-            }\n+\n+        \/\/ returns true when this criteria contains a standard attribute\n+        \/\/ whose value may be composite, i.e. multiple values separated by \"|\"\n+        private boolean isCompositeValue() {\n+            return (attrName != null &&\n+                    (attrName.equalsIgnoreCase(\"SupportedKeyClasses\") ||\n+                    attrName.equalsIgnoreCase(\"SupportedPaddings\") ||\n+                    attrName.equalsIgnoreCase(\"SupportedModes\") ||\n+                    attrName.equalsIgnoreCase(\"SupportedKeyFormats\")));\n@@ -882,1 +887,1 @@\n-                    (attrName != null ? ' ' + attrName : \"\");\n+                    (attrName != null ? (' ' + attrName) : \"\");\n@@ -915,3 +920,0 @@\n-            return isConstraintSatisfied(attrName, attrValue, propValue);\n-        }\n-    }\n@@ -919,6 +921,2 @@\n-    private static boolean isKnownComposite(String attr) {\n-        return (attr.equalsIgnoreCase(\"SupportedKeyClasses\") ||\n-                attr.equalsIgnoreCase(\"SupportedPaddings\") ||\n-                attr.equalsIgnoreCase(\"SupportedModes\") ||\n-                attr.equalsIgnoreCase(\"SupportedKeyFormats\"));\n-    }\n+            \/\/ Check the \"Java Security Standard Algorithm Names\" guide for the\n+            \/\/ list of supported Service Attributes\n@@ -926,17 +924,7 @@\n-    \/*\n-     * Returns {@code true} if the requested attribute value is supported;\n-     * otherwise, returns {@code false}.\n-     *\/\n-    private static boolean isConstraintSatisfied(String attribute,\n-                                                 String value,\n-                                                 String prop) {\n-        \/\/ Check the \"Java Security Standard Algorithm Names\" guide for the\n-        \/\/ name and value format of the supported Service Attributes\n-\n-        \/\/ For KeySize, prop is the max key size the provider supports\n-        \/\/ for a specific <crypto_service>.<algorithm>.\n-        if (attribute.equalsIgnoreCase(\"KeySize\")) {\n-            int requestedSize = Integer.parseInt(value);\n-            int maxSize = Integer.parseInt(prop);\n-            return requestedSize <= maxSize;\n-        }\n+            \/\/ For KeySize, prop is the max key size the provider supports\n+            \/\/ for a specific <crypto_service>.<algorithm>.\n+            if (attrName.equalsIgnoreCase(\"KeySize\")) {\n+                int requestedSize = Integer.parseInt(attrValue);\n+                int maxSize = Integer.parseInt(propValue);\n+                return requestedSize <= maxSize;\n+            }\n@@ -944,4 +932,4 @@\n-        \/\/ Handle attributes with composite values\n-        if (isKnownComposite(attribute)) {\n-            value = value.toUpperCase();\n-            prop = prop.toUpperCase();\n+            \/\/ Handle attributes with composite values\n+            if (isCompositeValue()) {\n+                String attrValue2 = attrValue.toUpperCase(Locale.ENGLISH);\n+                propValue = propValue.toUpperCase(Locale.ENGLISH);\n@@ -949,4 +937,9 @@\n-            \/\/ match value to the property components\n-            String[] propComponents = prop.split(\"\\\\|\");\n-            for (String pc : propComponents) {\n-                if (value.equals(pc)) return true;\n+                \/\/ match value to the property components\n+                String[] propComponents = propValue.split(\"\\\\|\");\n+                for (String pc : propComponents) {\n+                    if (attrValue2.equals(pc)) return true;\n+                }\n+                return false;\n+            } else {\n+                \/\/ direct string compare (ignore case)\n+                return attrValue.equalsIgnoreCase(propValue);\n@@ -954,4 +947,0 @@\n-            return false;\n-        } else {\n-            \/\/ direct string compare (ignore case)\n-            return value.equalsIgnoreCase(prop);\n","filename":"src\/java.base\/share\/classes\/java\/security\/Security.java","additions":61,"deletions":72,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -27,1 +28,1 @@\n- * @summary Check that provider service matching\/filtering is done correctly.\n+ * @summary Check that provider service matching\/filtering is done correctly\n@@ -30,1 +31,1 @@\n-\n+import jdk.test.lib.Utils;\n@@ -36,10 +37,0 @@\n-    private static void testIPE(String s) {\n-        \/\/ check against invalid filter for InvalidParameterException\n-        try {\n-            Security.getProviders(s);\n-            throw new RuntimeException(\"Expected IPE not thrown: \" + s);\n-        } catch (InvalidParameterException ipe) {\n-            System.out.println(\"Expected IPE thrown for \" + s);\n-        }\n-    }\n-\n@@ -85,7 +76,10 @@\n-        testIPE(\"\");\n-        testIPE(\"Cipher.\");\n-        testIPE(\".RC2 \");\n-        testIPE(\"Cipher.RC2 :\");\n-        testIPE(\"Cipher.RC2 a: \");\n-        testIPE(\"Cipher.RC2 :b\");\n-        testIPE(\"Cipher.RC2 SupportedKeyClasses:a|b\");\n+        \/\/ test filter parsing\n+        String[] invalidFilters = { \"\", \"Cipher.\", \".RC2 \", \"Cipher.RC2 :\",\n+                 \"Cipher.RC2 a: \", \"Cipher.RC2 :b\",\n+                 \"Cipher.RC2 SupportedKeyClasses:a|b\"\n+        };\n+        for (String i : invalidFilters) {\n+            System.out.println(\"Testing IPE for :\" + i);\n+            Utils.runAndCheckException(()-> Security.getProviders(i),\n+                    InvalidParameterException.class);\n+        }\n@@ -108,0 +102,2 @@\n+        \/\/ current impl does matching on individual attribute value for\n+        \/\/ attributes with composite values; no partial match\n@@ -112,0 +108,2 @@\n+        \/\/ match existing behavior; return null if empty filter map\n+        doit(filters);\n@@ -145,1 +143,1 @@\n-        \/\/ should find no proviser now that TestProv is removed\n+        \/\/ should find no provider now that TestProv is removed\n","filename":"test\/jdk\/java\/security\/Security\/ProviderFiltering.java","additions":18,"deletions":20,"binary":false,"changes":38,"status":"modified"}]}