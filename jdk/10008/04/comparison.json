{"files":[{"patch":"@@ -522,0 +522,1 @@\n+\n@@ -524,2 +525,2 @@\n-        if (index == -1) {\n-            key = filter;\n+        if (index == -1) { \/\/ <crypto_service>.<algo_or_type> only\n+            key = filter.trim();\n@@ -528,2 +529,7 @@\n-            key = filter.substring(0, index);\n-            value = filter.substring(index + 1);\n+            \/\/ <crypto_service>.<algo_or_type> <attr_name>:<attr_value>\n+            key = filter.substring(0, index).trim();\n+            value = filter.substring(index + 1).trim();\n+            \/\/ ensure value is not empty here; rest will be checked in Criteria\n+            if (value.isEmpty()) {\n+                throw new InvalidParameterException(\"Invalid filter\");\n+            }\n@@ -594,2 +600,1 @@\n-        Set<String> keySet = filter.keySet();\n-        LinkedHashSet<Provider> candidates = new LinkedHashSet<>(5);\n+        Set<Map.Entry<String, String>> entries = filter.entrySet();\n@@ -599,1 +604,1 @@\n-        if ((keySet == null) || (allProviders == null)) {\n+        if (entries == null || entries.isEmpty() || allProviders == null) {\n@@ -603,1 +608,2 @@\n-        boolean firstSearch = true;\n+        LinkedList<Provider> candidates =\n+                new LinkedList<>(Arrays.asList(allProviders));\n@@ -607,17 +613,6 @@\n-        for (String key : keySet) {\n-            String value = filter.get(key);\n-\n-            LinkedHashSet<Provider> newCandidates = getAllQualifyingCandidates(key, value,\n-                                                               allProviders);\n-            if (firstSearch) {\n-                candidates = newCandidates;\n-                firstSearch = false;\n-            }\n-\n-            if (!newCandidates.isEmpty()) {\n-                \/\/ For each provider in the candidates set, if it\n-                \/\/ isn't in the newCandidate set, we should remove\n-                \/\/ it from the candidate set.\n-                candidates.removeIf(prov -> !newCandidates.contains(prov));\n-            } else {\n-                candidates = null;\n+        Iterator<Map.Entry<String, String>> iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            Map.Entry<String, String> e = iter.next();\n+            new Criteria(e.getKey(), e.getValue()).apply(candidates);\n+            if (candidates.isEmpty()) {\n+                \/\/ bail; no further filtering needed\n@@ -626,1 +621,1 @@\n-        }\n+        };\n@@ -628,1 +623,1 @@\n-        if (candidates == null || candidates.isEmpty())\n+        if (candidates.isEmpty())\n@@ -825,21 +820,8 @@\n-    \/*\n-     * Returns all providers who satisfy the specified\n-     * criterion.\n-     *\/\n-    private static LinkedHashSet<Provider> getAllQualifyingCandidates(\n-                                                String filterKey,\n-                                                String filterValue,\n-                                                Provider[] allProviders) {\n-        String[] filterComponents = getFilterComponents(filterKey,\n-                                                        filterValue);\n-\n-        \/\/ The first component is the service name.\n-        \/\/ The second is the algorithm name.\n-        \/\/ If the third isn't null, that is the attribute name.\n-        String serviceName = filterComponents[0];\n-        String algName = filterComponents[1];\n-        String attrName = filterComponents[2];\n-\n-        return getProvidersNotUsingCache(serviceName, algName, attrName,\n-                                         filterValue, allProviders);\n-    }\n+    private static class Criteria {\n+        private String serviceName;\n+        private String algName;\n+        private String attrName = null;\n+        private String attrValue;\n+\n+        Criteria(String key, String value) throws InvalidParameterException {\n+            int snEndIndex = key.indexOf('.');\n@@ -847,12 +829,4 @@\n-    private static LinkedHashSet<Provider> getProvidersNotUsingCache(\n-                                                String serviceName,\n-                                                String algName,\n-                                                String attrName,\n-                                                String filterValue,\n-                                                Provider[] allProviders) {\n-        LinkedHashSet<Provider> candidates = new LinkedHashSet<>(5);\n-        for (int i = 0; i < allProviders.length; i++) {\n-            if (isCriterionSatisfied(allProviders[i], serviceName,\n-                                     algName,\n-                                     attrName, filterValue)) {\n-                candidates.add(allProviders[i]);\n+            if (snEndIndex <= 0) {\n+                \/\/ There must be a dot in the filter, and the dot\n+                \/\/ shouldn't be at the beginning of this string.\n+                throw new InvalidParameterException(\"Invalid filter\");\n@@ -860,3 +834,0 @@\n-        }\n-        return candidates;\n-    }\n@@ -864,13 +835,29 @@\n-    \/*\n-     * Returns {@code true} if the given provider satisfies\n-     * the selection criterion key:value.\n-     *\/\n-    private static boolean isCriterionSatisfied(Provider prov,\n-                                                String serviceName,\n-                                                String algName,\n-                                                String attrName,\n-                                                String filterValue) {\n-        String key = serviceName + '.' + algName;\n-\n-        if (attrName != null) {\n-            key += ' ' + attrName;\n+            serviceName = key.substring(0, snEndIndex);\n+            attrValue = value;\n+\n+            if (value.isEmpty()) {\n+                \/\/ value is empty. So the key should be in the format of\n+                \/\/ <crypto_service>.<algorithm_or_type>.\n+                algName = key.substring(snEndIndex + 1);\n+            } else {\n+                \/\/ value is non-empty. So the key must be in the format\n+                \/\/ of <crypto_service>.<algorithm_or_type>(one or more\n+                \/\/ spaces)<attribute_name>\n+                int algEndIndex = key.indexOf(' ', snEndIndex);\n+\n+                if (algEndIndex == -1) {\n+                    throw new InvalidParameterException(\"Invalid filter\");\n+                }\n+                algName = key.substring(snEndIndex + 1, algEndIndex);\n+                attrName = key.substring(algEndIndex + 1).trim();\n+                if (isKnownComposite(attrName) &&\n+                        attrValue.indexOf('|') != -1) {\n+                    throw new InvalidParameterException\n+                        (\"composite values unsupported for filtering\");\n+                }\n+            }\n+            \/\/ check required values\n+            if (serviceName.isEmpty() || algName.isEmpty() ||\n+                    (!attrValue.isEmpty() && attrName.isEmpty())) {\n+                throw new InvalidParameterException(\"Invalid filter\");\n+            }\n@@ -878,16 +865,6 @@\n-        \/\/ Check whether the provider has a property\n-        \/\/ whose key is the same as the given key.\n-        String propValue = getProviderProperty(key, prov);\n-\n-        if (propValue == null) {\n-            \/\/ Check whether we have an alias instead\n-            \/\/ of a standard name in the key.\n-            String standardName = getProviderProperty(\"Alg.Alias.\" +\n-                                                      serviceName + \".\" +\n-                                                      algName,\n-                                                      prov);\n-            if (standardName != null) {\n-                key = serviceName + \".\" + standardName;\n-\n-                if (attrName != null) {\n-                    key += ' ' + attrName;\n+        void apply(LinkedList<Provider> candidates) {\n+            Iterator<Provider> provs = candidates.iterator();\n+            while (provs.hasNext()) {\n+                Provider p = provs.next();\n+                if (!isCriterionSatisfied(p)) {\n+                    provs.remove();\n@@ -895,2 +872,0 @@\n-\n-                propValue = getProviderProperty(key, prov);\n@@ -898,0 +873,14 @@\n+        }\n+\n+        \/*\n+         * Returns {@code true} if the given provider satisfies\n+         * the selection criterion key:value.\n+         *\/\n+        private boolean isCriterionSatisfied(Provider prov) {\n+            \/\/ Constructed key have ONLY 1 space between algName and attrName\n+            String key = serviceName + '.' + algName +\n+                    (attrName != null ? ' ' + attrName : \"\");\n+\n+            \/\/ Check whether the provider has a property\n+            \/\/ whose key is the same as the given key.\n+            String propValue = getProviderProperty(key, prov);\n@@ -900,5 +889,9 @@\n-                \/\/ The provider doesn't have the given\n-                \/\/ key in its property list.\n-                return false;\n-            }\n-        }\n+                \/\/ Check whether we have an alias instead\n+                \/\/ of a standard name in the key.\n+                String standardName = getProviderProperty(\"Alg.Alias.\" +\n+                        serviceName + \".\" + algName, prov);\n+                if (standardName != null) {\n+                    key = serviceName + \".\" + standardName +\n+                            (attrName != null ? ' ' + attrName : \"\");\n+                    propValue = getProviderProperty(key, prov);\n+                }\n@@ -906,3 +899,6 @@\n-        \/\/ If the key is in the format of:\n-        \/\/ <crypto_service>.<algorithm_or_type>,\n-        \/\/ there is no need to check the value.\n+                if (propValue == null) {\n+                    \/\/ The provider doesn't have the given\n+                    \/\/ key in its property list.\n+                    return false;\n+                }\n+            }\n@@ -910,3 +906,6 @@\n-        if (attrName == null) {\n-            return true;\n-        }\n+            \/\/ If the key is in the format of:\n+            \/\/ <crypto_service>.<algorithm_or_type>,\n+            \/\/ there is no need to check the value.\n+            if (attrName == null) {\n+                return true;\n+            }\n@@ -914,6 +913,3 @@\n-        \/\/ If we get here, the key must be in the\n-        \/\/ format of <crypto_service>.<algorithm_or_provider> <attribute_name>.\n-        if (isStandardAttr(attrName)) {\n-            return isConstraintSatisfied(attrName, filterValue, propValue);\n-        } else {\n-            return filterValue.equalsIgnoreCase(propValue);\n+            \/\/ If we get here, the key must be in the\n+            \/\/ format of <crypto_service>.<algorithm_or_type> <attribute_name>.\n+            return isConstraintSatisfied(attrName, attrValue, propValue);\n@@ -923,11 +919,5 @@\n-    \/*\n-     * Returns {@code true} if the attribute is a standard attribute;\n-     * otherwise, returns {@code false}.\n-     *\/\n-    private static boolean isStandardAttr(String attribute) {\n-        \/\/ For now, we just have two standard attributes:\n-        \/\/ KeySize and ImplementedIn.\n-        if (attribute.equalsIgnoreCase(\"KeySize\"))\n-            return true;\n-\n-        return attribute.equalsIgnoreCase(\"ImplementedIn\");\n+    private static boolean isKnownComposite(String attr) {\n+        return (attr.equalsIgnoreCase(\"SupportedKeyClasses\") ||\n+                attr.equalsIgnoreCase(\"SupportedPaddings\") ||\n+                attr.equalsIgnoreCase(\"SupportedModes\") ||\n+                attr.equalsIgnoreCase(\"SupportedKeyFormats\"));\n@@ -943,2 +933,5 @@\n-        \/\/ For KeySize, prop is the max key size the\n-        \/\/ provider supports for a specific <crypto_service>.<algorithm>.\n+        \/\/ Check the \"Java Security Standard Algorithm Names\" guide for the\n+        \/\/ name and value format of the supported Service Attributes\n+\n+        \/\/ For KeySize, prop is the max key size the provider supports\n+        \/\/ for a specific <crypto_service>.<algorithm>.\n@@ -951,11 +944,4 @@\n-        \/\/ For Type, prop is the type of the implementation\n-        \/\/ for a specific <crypto service>.<algorithm>.\n-        if (attribute.equalsIgnoreCase(\"ImplementedIn\")) {\n-            return value.equalsIgnoreCase(prop);\n-        }\n-\n-        return false;\n-    }\n-\n-    static String[] getFilterComponents(String filterKey, String filterValue) {\n-        int algIndex = filterKey.indexOf('.');\n+        \/\/ Handle attributes with composite values\n+        if (isKnownComposite(attribute)) {\n+            value = value.toUpperCase();\n+            prop = prop.toUpperCase();\n@@ -963,17 +949,4 @@\n-        if (algIndex < 0) {\n-            \/\/ There must be a dot in the filter, and the dot\n-            \/\/ shouldn't be at the beginning of this string.\n-            throw new InvalidParameterException(\"Invalid filter\");\n-        }\n-\n-        String serviceName = filterKey.substring(0, algIndex);\n-        String algName;\n-        String attrName = null;\n-\n-        if (filterValue.isEmpty()) {\n-            \/\/ The filterValue is an empty string. So the filterKey\n-            \/\/ should be in the format of <crypto_service>.<algorithm_or_type>.\n-            algName = filterKey.substring(algIndex + 1).trim();\n-            if (algName.isEmpty()) {\n-                \/\/ There must be an algorithm or type name.\n-                throw new InvalidParameterException(\"Invalid filter\");\n+            \/\/ match value to the property components\n+            String[] propComponents = prop.split(\"\\\\|\");\n+            for (String pc : propComponents) {\n+                if (value.equals(pc)) return true;\n@@ -981,0 +954,1 @@\n+            return false;\n@@ -982,23 +956,2 @@\n-            \/\/ The filterValue is a non-empty string. So the filterKey must be\n-            \/\/ in the format of\n-            \/\/ <crypto_service>.<algorithm_or_type> <attribute_name>\n-            int attrIndex = filterKey.indexOf(' ');\n-\n-            if (attrIndex == -1) {\n-                \/\/ There is no attribute name in the filter.\n-                throw new InvalidParameterException(\"Invalid filter\");\n-            } else {\n-                attrName = filterKey.substring(attrIndex + 1).trim();\n-                if (attrName.isEmpty()) {\n-                    \/\/ There is no attribute name in the filter.\n-                    throw new InvalidParameterException(\"Invalid filter\");\n-                }\n-            }\n-\n-            \/\/ There must be an algorithm name in the filter.\n-            if ((attrIndex < algIndex) ||\n-                (algIndex == attrIndex - 1)) {\n-                throw new InvalidParameterException(\"Invalid filter\");\n-            } else {\n-                algName = filterKey.substring(algIndex + 1, attrIndex);\n-            }\n+            \/\/ direct string compare (ignore case)\n+            return value.equalsIgnoreCase(prop);\n@@ -1006,7 +959,0 @@\n-\n-        String[] result = new String[3];\n-        result[0] = serviceName;\n-        result[1] = algName;\n-        result[2] = attrName;\n-\n-        return result;\n","filename":"src\/java.base\/share\/classes\/java\/security\/Security.java","additions":128,"deletions":182,"binary":false,"changes":310,"status":"modified"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6447816\n+ * @summary Check that provider service matching\/filtering is done correctly.\n+ * @run main\/othervm ProviderFiltering\n+ *\/\n+\n+import java.util.*;\n+import java.security.*;\n+\n+public class ProviderFiltering {\n+\n+    private static void testIPE(String s) {\n+        \/\/ check against invalid filter for InvalidParameterException\n+        try {\n+            Security.getProviders(s);\n+            throw new RuntimeException(\"Expected IPE not thrown: \" + s);\n+        } catch (InvalidParameterException ipe) {\n+            System.out.println(\"Expected IPE thrown for \" + s);\n+        }\n+    }\n+\n+    private static void doit(Object filter, String... expectedPNs) {\n+        System.out.println(\"Filter: \" + filter);\n+        System.out.println(\"Expected Provider(s): \" +\n+                (expectedPNs.length > 0 ? Arrays.toString(expectedPNs) :\n+                \"<NONE>\"));\n+        Provider ps[];\n+        if (filter instanceof String filterStr) {\n+            ps = Security.getProviders(filterStr);\n+        } else if (filter instanceof Map filterMap) {\n+            ps = Security.getProviders(filterMap);\n+        } else {\n+            throw new RuntimeException(\"Error: unknown input type: \" + filter);\n+        }\n+\n+        if (ps == null) {\n+            if (expectedPNs.length != 0) {\n+                throw new RuntimeException(\"Fail: expected provider(s) \" +\n+                        \"not found\");\n+            }\n+        } else {\n+            if (ps.length == expectedPNs.length) {\n+                \/\/ check the provider names\n+                for (int i = 0; i < ps.length; i++) {\n+                    if (!ps[i].getName().equals(expectedPNs[i])) {\n+                        throw new RuntimeException(\"Fail: provider name \" +\n+                                \"mismatch at index \" + i + \", got \" +\n+                                ps[i].getName());\n+                    }\n+                }\n+            } else {\n+                throw new RuntimeException(\"Fail: # of providers mismatch\");\n+            }\n+        }\n+        System.out.println(\"=> Passed\");\n+    }\n+\n+\n+    public static void main(String[] args)\n+                throws NoSuchAlgorithmException {\n+        testIPE(\"\");\n+        testIPE(\"Cipher.\");\n+        testIPE(\".RC2 \");\n+        testIPE(\"Cipher.RC2 :\");\n+        testIPE(\"Cipher.RC2 a: \");\n+        testIPE(\"Cipher.RC2 :b\");\n+        testIPE(\"Cipher.RC2 SupportedKeyClasses:a|b\");\n+\n+        String p = \"SUN\";\n+\n+        \/\/ test alias\n+        doit(\"Signature.NONEwithDSA\", p);\n+\n+        String sigService = \"Signature.SHA256withDSA\";\n+        \/\/ javadoc allows extra spaces in between\n+        String key = sigService + \"   SupportedKeyClasses\";\n+        String valComp1 = \"java.security.interfaces.DSAPublicKey\";\n+        String valComp2 = \"java.security.interfaces.DSAPrivateKey\";\n+        String valComp2CN = valComp2.substring(valComp2.lastIndexOf('.') + 1);\n+\n+        \/\/ test using String filter\n+        doit(key + \":\" + valComp1, p);\n+        doit(key + \":\" + valComp2, p);\n+        doit(key + \":\" + valComp2CN);\n+\n+        \/\/ repeat above tests using filter Map\n+        Map<String,String> filters = new HashMap<>();\n+        filters.put(key, valComp1);\n+        doit(filters, p);\n+        filters.put(key, valComp2);\n+        doit(filters, p);\n+        filters.put(key, valComp2CN);\n+        doit(filters);\n+\n+        \/\/ try non-attribute filters\n+        filters.clear();\n+        filters.put(sigService, \"\");\n+        doit(filters, p);\n+        filters.put(\"Cipher.RC2\", \"\");\n+        doit(filters);\n+\n+        \/\/ test against a custom provider and attribute\n+        filters.clear();\n+        String customKey = \"customAttr\";\n+        String customValue = \"customValue\";\n+        String pName = \"TestProv\";\n+        Provider testProv = new TestProvider(pName, sigService, customKey,\n+                customValue);\n+        Security.insertProviderAt(testProv, 1);\n+        \/\/ should find both TestProv and SUN and in this order\n+        doit(sigService, pName, \"SUN\");\n+        filters.put(sigService, \"\");\n+        doit(filters, pName, \"SUN\");\n+\n+        String specAttr = sigService + \"  \" + customKey + \":\" + customValue;\n+        \/\/ should find only TestProv\n+        doit(specAttr, pName);\n+        filters.put(sigService + \"  \" + customKey, customValue);\n+        doit(filters, pName);\n+\n+        \/\/ should find no proviser now that TestProv is removed\n+        Security.removeProvider(pName);\n+        doit(specAttr);\n+    }\n+\n+    private static class TestProvider extends Provider {\n+        TestProvider(String name, String service, String attrKey,\n+                String attrValue) {\n+            super(name, \"0.0\", \"Not for use in production systems!\");\n+            put(service, \"a.b.c\");\n+            put(service + \" \" + attrKey, attrValue);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/security\/Security\/ProviderFiltering.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"}]}