{"files":[{"patch":"@@ -524,1 +524,1 @@\n-        if (index == -1) {\n+        if (index == -1) { \/\/ <crypto_service>.<algo_or_type> only\n@@ -528,0 +528,1 @@\n+            \/\/ <crypto_service>.<algo_or_type> <attr_name>:<attr_value>\n@@ -595,1 +596,0 @@\n-        LinkedHashSet<Provider> candidates = new LinkedHashSet<>(5);\n@@ -603,1 +603,2 @@\n-        boolean firstSearch = true;\n+        LinkedList<Provider> candidates =\n+                new LinkedList<>(Arrays.asList(allProviders));\n@@ -608,16 +609,4 @@\n-            String value = filter.get(key);\n-\n-            LinkedHashSet<Provider> newCandidates = getAllQualifyingCandidates(key, value,\n-                                                               allProviders);\n-            if (firstSearch) {\n-                candidates = newCandidates;\n-                firstSearch = false;\n-            }\n-\n-            if (!newCandidates.isEmpty()) {\n-                \/\/ For each provider in the candidates set, if it\n-                \/\/ isn't in the newCandidate set, we should remove\n-                \/\/ it from the candidate set.\n-                candidates.removeIf(prov -> !newCandidates.contains(prov));\n-            } else {\n-                candidates = null;\n+            String value = filter.get(key).trim();\n+            applyFilterOnCandidates(key, value, candidates);\n+            if (candidates.isEmpty()) {\n+                \/\/ bail; no further filtering needed\n@@ -628,1 +617,1 @@\n-        if (candidates == null || candidates.isEmpty())\n+        if (candidates.isEmpty())\n@@ -826,2 +815,2 @@\n-     * Returns all providers who satisfy the specified\n-     * criterion.\n+     * Apply the specified filter on the specified Provider candidates\n+     * and remove those which do not contain a match.\n@@ -829,4 +818,3 @@\n-    private static LinkedHashSet<Provider> getAllQualifyingCandidates(\n-                                                String filterKey,\n-                                                String filterValue,\n-                                                Provider[] allProviders) {\n+    private static void applyFilterOnCandidates(String filterKey,\n+            String filterValue, LinkedList<Provider> candidates) {\n+\n@@ -843,16 +831,6 @@\n-        return getProvidersNotUsingCache(serviceName, algName, attrName,\n-                                         filterValue, allProviders);\n-    }\n-\n-    private static LinkedHashSet<Provider> getProvidersNotUsingCache(\n-                                                String serviceName,\n-                                                String algName,\n-                                                String attrName,\n-                                                String filterValue,\n-                                                Provider[] allProviders) {\n-        LinkedHashSet<Provider> candidates = new LinkedHashSet<>(5);\n-        for (int i = 0; i < allProviders.length; i++) {\n-            if (isCriterionSatisfied(allProviders[i], serviceName,\n-                                     algName,\n-                                     attrName, filterValue)) {\n-                candidates.add(allProviders[i]);\n+        Iterator<Provider> provs = candidates.iterator();\n+        while (provs.hasNext()) {\n+            Provider p = provs.next();\n+            if (!isCriterionSatisfied(p, serviceName, algName, attrName,\n+                    filterValue)) {\n+                provs.remove();\n@@ -861,1 +839,0 @@\n-        return candidates;\n@@ -878,0 +855,1 @@\n+\n@@ -909,1 +887,0 @@\n-\n@@ -915,6 +892,2 @@\n-        \/\/ format of <crypto_service>.<algorithm_or_provider> <attribute_name>.\n-        if (isStandardAttr(attrName)) {\n-            return isConstraintSatisfied(attrName, filterValue, propValue);\n-        } else {\n-            return filterValue.equalsIgnoreCase(propValue);\n-        }\n+        \/\/ format of <crypto_service>.<algorithm_or_type> <attribute_name>.\n+        return isConstraintSatisfied(attrName, filterValue, propValue);\n@@ -923,11 +896,5 @@\n-    \/*\n-     * Returns {@code true} if the attribute is a standard attribute;\n-     * otherwise, returns {@code false}.\n-     *\/\n-    private static boolean isStandardAttr(String attribute) {\n-        \/\/ For now, we just have two standard attributes:\n-        \/\/ KeySize and ImplementedIn.\n-        if (attribute.equalsIgnoreCase(\"KeySize\"))\n-            return true;\n-\n-        return attribute.equalsIgnoreCase(\"ImplementedIn\");\n+    private static boolean isKnownComposite(String attribute) {\n+        return (attribute.equalsIgnoreCase(\"SupportedKeyClasses\") ||\n+                attribute.equalsIgnoreCase(\"SupportedPaddings\") ||\n+                attribute.equalsIgnoreCase(\"SupportedModes\") ||\n+                attribute.equalsIgnoreCase(\"SupportedKeyFormats\"));\n@@ -943,2 +910,5 @@\n-        \/\/ For KeySize, prop is the max key size the\n-        \/\/ provider supports for a specific <crypto_service>.<algorithm>.\n+        \/\/ Check the \"Java Security Standard Algorithm Names\" guide for the\n+        \/\/ name and value format of the supported Service Attributes\n+\n+        \/\/ For KeySize, prop is the max key size the provider supports\n+        \/\/ for a specific <crypto_service>.<algorithm>.\n@@ -951,3 +921,19 @@\n-        \/\/ For Type, prop is the type of the implementation\n-        \/\/ for a specific <crypto service>.<algorithm>.\n-        if (attribute.equalsIgnoreCase(\"ImplementedIn\")) {\n+        \/\/ Handle attributes with composite values\n+        if (isKnownComposite(attribute)) {\n+            value = value.toUpperCase();\n+            prop = prop.toUpperCase();\n+\n+            if (value.indexOf('|') != -1) {\n+                StringTokenizer st = new StringTokenizer(value, \"| \");\n+                while (st.hasMoreTokens()) {\n+                    \/\/ check individual component for match and bail if no match\n+                    if (prop.indexOf(st.nextToken()) == -1) {\n+                        return false;\n+                    };\n+                }\n+                return true;\n+            } else {\n+                return (prop.indexOf(value) != -1);\n+            }\n+        } else {\n+            \/\/ direct string compare (ignore case)\n@@ -956,2 +942,0 @@\n-\n-        return false;\n@@ -961,0 +945,1 @@\n+\n@@ -985,1 +970,1 @@\n-            int attrIndex = filterKey.indexOf(' ');\n+            int attrIndex = filterKey.indexOf(' ', algIndex + 1);\n","filename":"src\/java.base\/share\/classes\/java\/security\/Security.java","additions":54,"deletions":69,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6447816\n+ * @summary Check that provider service matching\/filtering is done correctly.\n+ * @run main\/othervm ProviderFiltering\n+ *\/\n+\n+import java.util.*;\n+import java.security.*;\n+\n+public class ProviderFiltering {\n+\n+    private static void doit(Object filter, String... expectedPNs) {\n+        System.out.println(\"Filter: \" + filter);\n+        System.out.println(\"Expected Provider(s): \" +\n+                (expectedPNs.length > 0 ? Arrays.toString(expectedPNs) :\n+                \"<NONE>\"));\n+        Provider ps[];\n+        if (filter instanceof String filterStr) {\n+            ps = Security.getProviders(filterStr);\n+        } else if (filter instanceof Map filterMap) {\n+            ps = Security.getProviders(filterMap);\n+        } else {\n+            throw new RuntimeException(\"Error: unknown input type: \" + filter);\n+        }\n+\n+        if (ps == null) {\n+            if (expectedPNs.length != 0) {\n+                throw new RuntimeException(\"Fail: expected provider(s) \" +\n+                        \"not found\");\n+            }\n+        } else {\n+            if (ps.length == expectedPNs.length) {\n+                \/\/ check the provider names\n+                for (int i = 0; i < ps.length; i++) {\n+                    if (!ps[i].getName().equals(expectedPNs[i])) {\n+                        throw new RuntimeException(\"Fail: provider name \" +\n+                                \"mismatch at index \" + i + \", got \" +\n+                                ps[i].getName());\n+                    }\n+                }\n+            } else {\n+                throw new RuntimeException(\"Fail: # of providers mismatch\");\n+            }\n+        }\n+        System.out.println(\"=> Passed\");\n+    }\n+\n+\n+    public static void main(String[] args)\n+                throws NoSuchAlgorithmException {\n+        String p = \"SUN\";\n+        String key = \"Signature.SHA256withDSA SupportedKeyClasses\";\n+        String valComp1 = \"java.security.interfaces.DSAPublicKey\";\n+        String valComp2 = \"java.security.interfaces.DSAPrivateKey\";\n+        String valComp2CN = valComp2.substring(valComp2.lastIndexOf('.') + 1);\n+\n+        \/\/ test using String filter\n+        \/\/ 1. exact match\n+        doit(key + \":\" + valComp1 + \"|\" + valComp2, p);\n+        \/\/ 2. value w\/ space prefix\n+        doit(key + \": \" + valComp1, p);\n+        \/\/ 3. value w\/ space suffix\n+        doit(key + \":\" + valComp2 + \" \", p);\n+        \/\/ 4. partial value, e.g. class name only\n+        doit(key + \":\" + valComp2CN, p);\n+        \/\/ 5. different values ordering\n+        doit(key + \":\" + valComp2 + \"|\" + valComp1, p);\n+\n+        \/\/ repeat above tests using filter Map\n+        Map<String,String> filters = new HashMap<>();\n+        filters.put(key, valComp1 + \"|\" + valComp2);\n+        doit(filters, p);\n+        filters.put(key, \" \" + valComp1);\n+        doit(filters, p);\n+        filters.put(key, valComp2 + \" \");\n+        doit(filters, p);\n+        filters.put(key, valComp2CN);\n+        doit(filters, p);\n+        filters.put(key, valComp2 + \" | \" + valComp1);\n+        doit(filters, p);\n+\n+        \/\/ add more filters to the map\n+        filters.put(\"Signature.SHA256withDSA\", \"\");\n+        doit(filters, p);\n+        filters.put(\"Cipher.Nonexisting\", \"\");\n+        doit(filters);\n+\n+        \/\/ test against a custom provider and attribute\n+        filters.clear();\n+        String service = \"Signature.SHA256withDSA\";\n+        String customKey = \"customAttr\";\n+        String customValue = \"customValue\";\n+        String pName = \"TestProv\";\n+        Provider testProv = new TestProvider(pName, service, customKey,\n+                customValue);\n+        Security.insertProviderAt(testProv, 1);\n+        \/\/ should find both TestProv and SUN and in this order\n+        doit(service, pName, \"SUN\");\n+        filters.put(service, \"\");\n+        doit(filters, pName, \"SUN\");\n+\n+        String specAttr = service + \" \" + customKey + \":\" + customValue;\n+        \/\/ should find only TestProv\n+        doit(specAttr, pName);\n+        filters.put(service + \" \" + customKey, \" \" + customValue + \" \");\n+        doit(filters, pName);\n+\n+        \/\/ should find no proviser now that TestProv is removed\n+        Security.removeProvider(pName);\n+        doit(specAttr);\n+        doit(filters);\n+    }\n+\n+    private static class TestProvider extends Provider {\n+        TestProvider(String name, String service, String attrKey,\n+                String attrValue) {\n+            super(name, \"0.0\", \"Not for use in production systems!\");\n+            put(service, \"a.b.c\");\n+            put(service + \" \" + attrKey, attrValue);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/security\/Security\/ProviderFiltering.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"}]}