{"files":[{"patch":"@@ -522,0 +522,1 @@\n+\n@@ -524,2 +525,2 @@\n-        if (index == -1) {\n-            key = filter;\n+        if (index == -1) { \/\/ <crypto_service>.<algo_or_type> only\n+            key = filter.trim();\n@@ -528,2 +529,7 @@\n-            key = filter.substring(0, index);\n-            value = filter.substring(index + 1);\n+            \/\/ <crypto_service>.<algo_or_type> <attr_name>:<attr_value>\n+            key = filter.substring(0, index).trim();\n+            value = filter.substring(index + 1).trim();\n+            \/\/ ensure value is not empty here; rest will be checked in Criteria\n+            if (value.isEmpty()) {\n+                throw new InvalidParameterException(\"Invalid filter\");\n+            }\n@@ -594,2 +600,1 @@\n-        Set<String> keySet = filter.keySet();\n-        LinkedHashSet<Provider> candidates = new LinkedHashSet<>(5);\n+        Set<Map.Entry<String, String>> entries = filter.entrySet();\n@@ -597,3 +602,4 @@\n-        \/\/ Returns all installed providers\n-        \/\/ if the selection criteria is null.\n-        if ((keySet == null) || (allProviders == null)) {\n+        if (allProviders == null || allProviders.length == 0) {\n+            return null;\n+        } else if (entries == null) {\n+            \/\/ return all installed providers if the selection criteria is null\n@@ -601,0 +607,4 @@\n+        } else if (entries.isEmpty()) {\n+            \/\/ return null if the selection criteria is empty; this is to match\n+            \/\/ earlier behavior\n+            return null;\n@@ -603,1 +613,2 @@\n-        boolean firstSearch = true;\n+        LinkedList<Provider> candidates =\n+                new LinkedList<>(Arrays.asList(allProviders));\n@@ -607,18 +618,5 @@\n-        for (String key : keySet) {\n-            String value = filter.get(key);\n-\n-            LinkedHashSet<Provider> newCandidates = getAllQualifyingCandidates(key, value,\n-                                                               allProviders);\n-            if (firstSearch) {\n-                candidates = newCandidates;\n-                firstSearch = false;\n-            }\n-\n-            if (!newCandidates.isEmpty()) {\n-                \/\/ For each provider in the candidates set, if it\n-                \/\/ isn't in the newCandidate set, we should remove\n-                \/\/ it from the candidate set.\n-                candidates.removeIf(prov -> !newCandidates.contains(prov));\n-            } else {\n-                candidates = null;\n-                break;\n+        for (var e : entries) {\n+            Criteria cr = new Criteria(e.getKey(), e.getValue());\n+            candidates.removeIf(p -> !cr.isCriterionSatisfied(p));\n+            if (candidates.isEmpty()) {\n+                return null;\n@@ -626,4 +624,1 @@\n-        }\n-\n-        if (candidates == null || candidates.isEmpty())\n-            return null;\n+        };\n@@ -825,21 +820,5 @@\n-    \/*\n-     * Returns all providers who satisfy the specified\n-     * criterion.\n-     *\/\n-    private static LinkedHashSet<Provider> getAllQualifyingCandidates(\n-                                                String filterKey,\n-                                                String filterValue,\n-                                                Provider[] allProviders) {\n-        String[] filterComponents = getFilterComponents(filterKey,\n-                                                        filterValue);\n-\n-        \/\/ The first component is the service name.\n-        \/\/ The second is the algorithm name.\n-        \/\/ If the third isn't null, that is the attribute name.\n-        String serviceName = filterComponents[0];\n-        String algName = filterComponents[1];\n-        String attrName = filterComponents[2];\n-\n-        return getProvidersNotUsingCache(serviceName, algName, attrName,\n-                                         filterValue, allProviders);\n-    }\n+    private static class Criteria {\n+        private final String serviceName;\n+        private final String algName;\n+        private final String attrName;\n+        private final String attrValue;\n@@ -847,12 +826,7 @@\n-    private static LinkedHashSet<Provider> getProvidersNotUsingCache(\n-                                                String serviceName,\n-                                                String algName,\n-                                                String attrName,\n-                                                String filterValue,\n-                                                Provider[] allProviders) {\n-        LinkedHashSet<Provider> candidates = new LinkedHashSet<>(5);\n-        for (int i = 0; i < allProviders.length; i++) {\n-            if (isCriterionSatisfied(allProviders[i], serviceName,\n-                                     algName,\n-                                     attrName, filterValue)) {\n-                candidates.add(allProviders[i]);\n+        Criteria(String key, String value) throws InvalidParameterException {\n+\n+            int snEndIndex = key.indexOf('.');\n+            if (snEndIndex <= 0) {\n+                \/\/ There must be a dot in the filter, and the dot\n+                \/\/ shouldn't be at the beginning of this string.\n+                throw new InvalidParameterException(\"Invalid filter\");\n@@ -860,3 +834,0 @@\n-        }\n-        return candidates;\n-    }\n@@ -864,31 +835,2 @@\n-    \/*\n-     * Returns {@code true} if the given provider satisfies\n-     * the selection criterion key:value.\n-     *\/\n-    private static boolean isCriterionSatisfied(Provider prov,\n-                                                String serviceName,\n-                                                String algName,\n-                                                String attrName,\n-                                                String filterValue) {\n-        String key = serviceName + '.' + algName;\n-\n-        if (attrName != null) {\n-            key += ' ' + attrName;\n-        }\n-        \/\/ Check whether the provider has a property\n-        \/\/ whose key is the same as the given key.\n-        String propValue = getProviderProperty(key, prov);\n-\n-        if (propValue == null) {\n-            \/\/ Check whether we have an alias instead\n-            \/\/ of a standard name in the key.\n-            String standardName = getProviderProperty(\"Alg.Alias.\" +\n-                                                      serviceName + \".\" +\n-                                                      algName,\n-                                                      prov);\n-            if (standardName != null) {\n-                key = serviceName + \".\" + standardName;\n-\n-                if (attrName != null) {\n-                    key += ' ' + attrName;\n-                }\n+            serviceName = key.substring(0, snEndIndex);\n+            attrValue = value;\n@@ -896,1 +838,23 @@\n-                propValue = getProviderProperty(key, prov);\n+            if (value.isEmpty()) {\n+                \/\/ value is empty. So the key should be in the format of\n+                \/\/ <crypto_service>.<algorithm_or_type>.\n+                algName = key.substring(snEndIndex + 1);\n+                attrName = null;\n+            } else {\n+                \/\/ value is non-empty. So the key must be in the format\n+                \/\/ of <crypto_service>.<algorithm_or_type>(one or more\n+                \/\/ spaces)<attribute_name>\n+                int algEndIndex = key.indexOf(' ', snEndIndex);\n+                if (algEndIndex == -1) {\n+                    throw new InvalidParameterException\n+                            (\"Invalid filter - need algorithm name\");\n+                }\n+                algName = key.substring(snEndIndex + 1, algEndIndex);\n+                attrName = key.substring(algEndIndex + 1).trim();\n+                if (attrName.isEmpty()) {\n+                    throw new InvalidParameterException\n+                            (\"Invalid filter - need attribute name\");\n+                } else if (isCompositeValue() && attrValue.indexOf('|') != -1) {\n+                    throw new InvalidParameterException\n+                            (\"Invalid filter - composite values unsupported\");\n+                }\n@@ -899,4 +863,4 @@\n-            if (propValue == null) {\n-                \/\/ The provider doesn't have the given\n-                \/\/ key in its property list.\n-                return false;\n+            \/\/ check required values\n+            if (serviceName.isEmpty() || algName.isEmpty()) {\n+                throw new InvalidParameterException\n+                        (\"Invalid filter - need service and algorithm\");\n@@ -906,14 +870,8 @@\n-        \/\/ If the key is in the format of:\n-        \/\/ <crypto_service>.<algorithm_or_type>,\n-        \/\/ there is no need to check the value.\n-\n-        if (attrName == null) {\n-            return true;\n-        }\n-\n-        \/\/ If we get here, the key must be in the\n-        \/\/ format of <crypto_service>.<algorithm_or_provider> <attribute_name>.\n-        if (isStandardAttr(attrName)) {\n-            return isConstraintSatisfied(attrName, filterValue, propValue);\n-        } else {\n-            return filterValue.equalsIgnoreCase(propValue);\n+        \/\/ returns true when this criteria contains a standard attribute\n+        \/\/ whose value may be composite, i.e. multiple values separated by \"|\"\n+        private boolean isCompositeValue() {\n+            return (attrName != null &&\n+                    (attrName.equalsIgnoreCase(\"SupportedKeyClasses\") ||\n+                    attrName.equalsIgnoreCase(\"SupportedPaddings\") ||\n+                    attrName.equalsIgnoreCase(\"SupportedModes\") ||\n+                    attrName.equalsIgnoreCase(\"SupportedKeyFormats\")));\n@@ -921,11 +879,0 @@\n-    }\n-\n-    \/*\n-     * Returns {@code true} if the attribute is a standard attribute;\n-     * otherwise, returns {@code false}.\n-     *\/\n-    private static boolean isStandardAttr(String attribute) {\n-        \/\/ For now, we just have two standard attributes:\n-        \/\/ KeySize and ImplementedIn.\n-        if (attribute.equalsIgnoreCase(\"KeySize\"))\n-            return true;\n@@ -933,2 +880,8 @@\n-        return attribute.equalsIgnoreCase(\"ImplementedIn\");\n-    }\n+        \/*\n+         * Returns {@code true} if the given provider satisfies\n+         * the selection criterion key:value.\n+         *\/\n+        private boolean isCriterionSatisfied(Provider prov) {\n+            \/\/ Constructed key have ONLY 1 space between algName and attrName\n+            String key = serviceName + '.' + algName +\n+                    (attrName != null ? (' ' + attrName) : \"\");\n@@ -936,14 +889,3 @@\n-    \/*\n-     * Returns {@code true} if the requested attribute value is supported;\n-     * otherwise, returns {@code false}.\n-     *\/\n-    private static boolean isConstraintSatisfied(String attribute,\n-                                                 String value,\n-                                                 String prop) {\n-        \/\/ For KeySize, prop is the max key size the\n-        \/\/ provider supports for a specific <crypto_service>.<algorithm>.\n-        if (attribute.equalsIgnoreCase(\"KeySize\")) {\n-            int requestedSize = Integer.parseInt(value);\n-            int maxSize = Integer.parseInt(prop);\n-            return requestedSize <= maxSize;\n-        }\n+            \/\/ Check whether the provider has a property\n+            \/\/ whose key is the same as the given key.\n+            String propValue = getProviderProperty(key, prov);\n@@ -951,5 +893,10 @@\n-        \/\/ For Type, prop is the type of the implementation\n-        \/\/ for a specific <crypto service>.<algorithm>.\n-        if (attribute.equalsIgnoreCase(\"ImplementedIn\")) {\n-            return value.equalsIgnoreCase(prop);\n-        }\n+            if (propValue == null) {\n+                \/\/ Check whether we have an alias instead\n+                \/\/ of a standard name in the key.\n+                String standardName = getProviderProperty(\"Alg.Alias.\" +\n+                        serviceName + \".\" + algName, prov);\n+                if (standardName != null) {\n+                    key = serviceName + \".\" + standardName +\n+                            (attrName != null ? ' ' + attrName : \"\");\n+                    propValue = getProviderProperty(key, prov);\n+                }\n@@ -957,2 +904,6 @@\n-        return false;\n-    }\n+                if (propValue == null) {\n+                    \/\/ The provider doesn't have the given\n+                    \/\/ key in its property list.\n+                    return false;\n+                }\n+            }\n@@ -960,2 +911,6 @@\n-    static String[] getFilterComponents(String filterKey, String filterValue) {\n-        int algIndex = filterKey.indexOf('.');\n+            \/\/ If the key is in the format of:\n+            \/\/ <crypto_service>.<algorithm_or_type>,\n+            \/\/ there is no need to check the value.\n+            if (attrName == null) {\n+                return true;\n+            }\n@@ -963,5 +918,2 @@\n-        if (algIndex < 0) {\n-            \/\/ There must be a dot in the filter, and the dot\n-            \/\/ shouldn't be at the beginning of this string.\n-            throw new InvalidParameterException(\"Invalid filter\");\n-        }\n+            \/\/ If we get here, the key must be in the\n+            \/\/ format of <crypto_service>.<algorithm_or_type> <attribute_name>.\n@@ -969,3 +921,2 @@\n-        String serviceName = filterKey.substring(0, algIndex);\n-        String algName;\n-        String attrName = null;\n+            \/\/ Check the \"Java Security Standard Algorithm Names\" guide for the\n+            \/\/ list of supported Service Attributes\n@@ -973,7 +924,6 @@\n-        if (filterValue.isEmpty()) {\n-            \/\/ The filterValue is an empty string. So the filterKey\n-            \/\/ should be in the format of <crypto_service>.<algorithm_or_type>.\n-            algName = filterKey.substring(algIndex + 1).trim();\n-            if (algName.isEmpty()) {\n-                \/\/ There must be an algorithm or type name.\n-                throw new InvalidParameterException(\"Invalid filter\");\n+            \/\/ For KeySize, prop is the max key size the provider supports\n+            \/\/ for a specific <crypto_service>.<algorithm>.\n+            if (attrName.equalsIgnoreCase(\"KeySize\")) {\n+                int requestedSize = Integer.parseInt(attrValue);\n+                int maxSize = Integer.parseInt(propValue);\n+                return requestedSize <= maxSize;\n@@ -981,5 +931,0 @@\n-        } else {\n-            \/\/ The filterValue is a non-empty string. So the filterKey must be\n-            \/\/ in the format of\n-            \/\/ <crypto_service>.<algorithm_or_type> <attribute_name>\n-            int attrIndex = filterKey.indexOf(' ');\n@@ -987,10 +932,4 @@\n-            if (attrIndex == -1) {\n-                \/\/ There is no attribute name in the filter.\n-                throw new InvalidParameterException(\"Invalid filter\");\n-            } else {\n-                attrName = filterKey.substring(attrIndex + 1).trim();\n-                if (attrName.isEmpty()) {\n-                    \/\/ There is no attribute name in the filter.\n-                    throw new InvalidParameterException(\"Invalid filter\");\n-                }\n-            }\n+            \/\/ Handle attributes with composite values\n+            if (isCompositeValue()) {\n+                String attrValue2 = attrValue.toUpperCase(Locale.ENGLISH);\n+                propValue = propValue.toUpperCase(Locale.ENGLISH);\n@@ -998,4 +937,6 @@\n-            \/\/ There must be an algorithm name in the filter.\n-            if ((attrIndex < algIndex) ||\n-                (algIndex == attrIndex - 1)) {\n-                throw new InvalidParameterException(\"Invalid filter\");\n+                \/\/ match value to the property components\n+                String[] propComponents = propValue.split(\"\\\\|\");\n+                for (String pc : propComponents) {\n+                    if (attrValue2.equals(pc)) return true;\n+                }\n+                return false;\n@@ -1003,1 +944,2 @@\n-                algName = filterKey.substring(algIndex + 1, attrIndex);\n+                \/\/ direct string compare (ignore case)\n+                return attrValue.equalsIgnoreCase(propValue);\n@@ -1006,7 +948,0 @@\n-\n-        String[] result = new String[3];\n-        result[0] = serviceName;\n-        result[1] = algName;\n-        result[2] = attrName;\n-\n-        return result;\n","filename":"src\/java.base\/share\/classes\/java\/security\/Security.java","additions":131,"deletions":196,"binary":false,"changes":327,"status":"modified"},{"patch":"@@ -0,0 +1,156 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @bug 6447816\n+ * @summary Check that provider service matching\/filtering is done correctly\n+ * @run main\/othervm ProviderFiltering\n+ *\/\n+import jdk.test.lib.Utils;\n+import java.util.*;\n+import java.security.*;\n+\n+public class ProviderFiltering {\n+\n+    private static void doit(Object filter, String... expectedPNs) {\n+        System.out.println(\"Filter: \" + filter);\n+        System.out.println(\"Expected Provider(s): \" +\n+                (expectedPNs.length > 0 ? Arrays.toString(expectedPNs) :\n+                \"<NONE>\"));\n+        Provider ps[];\n+        if (filter instanceof String filterStr) {\n+            ps = Security.getProviders(filterStr);\n+        } else if (filter instanceof Map filterMap) {\n+            ps = Security.getProviders(filterMap);\n+        } else {\n+            throw new RuntimeException(\"Error: unknown input type: \" + filter);\n+        }\n+\n+        if (ps == null) {\n+            if (expectedPNs.length != 0) {\n+                throw new RuntimeException(\"Fail: expected provider(s) \" +\n+                        \"not found\");\n+            }\n+        } else {\n+            if (ps.length == expectedPNs.length) {\n+                \/\/ check the provider names\n+                for (int i = 0; i < ps.length; i++) {\n+                    if (!ps[i].getName().equals(expectedPNs[i])) {\n+                        throw new RuntimeException(\"Fail: provider name \" +\n+                                \"mismatch at index \" + i + \", got \" +\n+                                ps[i].getName());\n+                    }\n+                }\n+            } else {\n+                throw new RuntimeException(\"Fail: # of providers mismatch\");\n+            }\n+        }\n+        System.out.println(\"=> Passed\");\n+    }\n+\n+\n+    public static void main(String[] args)\n+                throws NoSuchAlgorithmException {\n+        \/\/ test filter parsing\n+        String[] invalidFilters = { \"\", \"Cipher.\", \".RC2 \", \"Cipher.RC2 :\",\n+                 \"Cipher.RC2 a: \", \"Cipher.RC2 :b\",\n+                 \"Cipher.RC2 SupportedKeyClasses:a|b\"\n+        };\n+        for (String i : invalidFilters) {\n+            System.out.println(\"Testing IPE for :\" + i);\n+            Utils.runAndCheckException(()-> Security.getProviders(i),\n+                    InvalidParameterException.class);\n+        }\n+\n+        String p = \"SUN\";\n+\n+        \/\/ test alias\n+        doit(\"Signature.NONEwithDSA\", p);\n+\n+        String sigService = \"Signature.SHA256withDSA\";\n+        \/\/ javadoc allows extra spaces in between\n+        String key = sigService + \"   SupportedKeyClasses\";\n+        String valComp1 = \"java.security.interfaces.DSAPublicKey\";\n+        String valComp2 = \"java.security.interfaces.DSAPrivateKey\";\n+        String valComp2CN = valComp2.substring(valComp2.lastIndexOf('.') + 1);\n+\n+        \/\/ test using String filter\n+        doit(key + \":\" + valComp1, p);\n+        doit(key + \":\" + valComp2, p);\n+        \/\/ current impl does matching on individual attribute value for\n+        \/\/ attributes with composite values; no partial match\n+        doit(key + \":\" + valComp2CN);\n+\n+        \/\/ repeat above tests using filter Map\n+        Map<String,String> filters = new HashMap<>();\n+        \/\/ match existing behavior; return null if empty filter map\n+        doit(filters);\n+        filters.put(key, valComp1);\n+        doit(filters, p);\n+        filters.put(key, valComp2);\n+        doit(filters, p);\n+        filters.put(key, valComp2CN);\n+        doit(filters);\n+\n+        \/\/ try non-attribute filters\n+        filters.clear();\n+        filters.put(sigService, \"\");\n+        doit(filters, p);\n+        filters.put(\"Cipher.RC2\", \"\");\n+        doit(filters);\n+\n+        \/\/ test against a custom provider and attribute\n+        filters.clear();\n+        String customKey = \"customAttr\";\n+        String customValue = \"customValue\";\n+        String pName = \"TestProv\";\n+        Provider testProv = new TestProvider(pName, sigService, customKey,\n+                customValue);\n+        Security.insertProviderAt(testProv, 1);\n+        \/\/ should find both TestProv and SUN and in this order\n+        doit(sigService, pName, \"SUN\");\n+        filters.put(sigService, \"\");\n+        doit(filters, pName, \"SUN\");\n+\n+        String specAttr = sigService + \"  \" + customKey + \":\" + customValue;\n+        \/\/ should find only TestProv\n+        doit(specAttr, pName);\n+        filters.put(sigService + \"  \" + customKey, customValue);\n+        doit(filters, pName);\n+\n+        \/\/ should find no provider now that TestProv is removed\n+        Security.removeProvider(pName);\n+        doit(specAttr);\n+    }\n+\n+    private static class TestProvider extends Provider {\n+        TestProvider(String name, String service, String attrKey,\n+                String attrValue) {\n+            super(name, \"0.0\", \"Not for use in production systems!\");\n+            put(service, \"a.b.c\");\n+            put(service + \" \" + attrKey, attrValue);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/security\/Security\/ProviderFiltering.java","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"}]}