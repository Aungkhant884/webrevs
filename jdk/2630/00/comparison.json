{"files":[{"patch":"@@ -1125,0 +1125,1 @@\n+      InstanceKlass* ik = InstanceKlass::cast(k);\n@@ -1127,2 +1128,2 @@\n-      Method* m = InstanceKlass::cast(k)->find_instance_method(_name, _signature, Klass::PrivateLookupMode::skip);\n-      if (!Dependencies::is_concrete_method(m, k)) {\n+      Method* m = ik->find_instance_method(_name, _signature, Klass::PrivateLookupMode::skip);\n+      if (!Dependencies::is_concrete_method(m, ik)) {\n@@ -1130,1 +1131,1 @@\n-        if (!k->is_interface() && m != NULL && m->is_abstract()) {\n+        if (!ik->is_interface() && m != NULL && m->is_abstract()) {\n@@ -1135,1 +1136,1 @@\n-          Klass* w = wf.find_witness_subtype(k);\n+          Klass* w = wf.find_witness_subtype(ik);\n@@ -1148,1 +1149,1 @@\n-        Array<Method*>* default_methods = InstanceKlass::cast(k)->default_methods();\n+        Array<Method*>* default_methods = ik->default_methods();\n@@ -1151,1 +1152,1 @@\n-        m = InstanceKlass::cast(k)->find_method(default_methods, _name, _signature);\n+        m = ik->find_method(default_methods, _name, _signature);\n@@ -1191,3 +1192,2 @@\n-  Klass* find_witness_anywhere(Klass* context_type,\n-                                 bool participants_hide_witnesses,\n-                                 bool top_level_call = true);\n+  Klass* find_witness_anywhere(InstanceKlass* context_type,\n+                               bool participants_hide_witnesses);\n@@ -1196,2 +1196,2 @@\n-                         Klass* context_type,\n-                           bool participants_hide_witnesses);\n+                         InstanceKlass* context_type,\n+                         bool participants_hide_witnesses);\n@@ -1199,1 +1199,1 @@\n-  Klass* find_witness_subtype(Klass* context_type, KlassDepChange* changes = NULL) {\n+  Klass* find_witness_subtype(Klass* k, KlassDepChange* changes = NULL) {\n@@ -1201,0 +1201,2 @@\n+    assert(k->is_instance_klass(), \"required\");\n+    InstanceKlass* context_type = InstanceKlass::cast(k);\n@@ -1212,1 +1214,1 @@\n-  Klass* find_witness_definer(Klass* context_type, KlassDepChange* changes = NULL) {\n+  Klass* find_witness_definer(Klass* k, KlassDepChange* changes = NULL) {\n@@ -1214,0 +1216,2 @@\n+    assert(k->is_instance_klass(), \"required\");\n+    InstanceKlass* context_type = InstanceKlass::cast(k);\n@@ -1274,1 +1278,1 @@\n-                                             Klass* context_type,\n+                                             InstanceKlass* context_type,\n@@ -1287,1 +1291,1 @@\n-  int nof_impls = InstanceKlass::cast(context_type)->nof_implementors();\n+  int nof_impls = context_type->nof_implementors();\n@@ -1318,1 +1322,0 @@\n-\n@@ -1320,7 +1323,1 @@\n-\/\/ Do not report participant types, and recursively walk beneath\n-\/\/ them only if participants_hide_witnesses is false.\n-\/\/ If top_level_call is false, skip testing the context type,\n-\/\/ because the caller has already considered it.\n-Klass* ClassHierarchyWalker::find_witness_anywhere(Klass* context_type,\n-                                                   bool participants_hide_witnesses,\n-                                                   bool top_level_call) {\n+Klass* ClassHierarchyWalker::find_witness_anywhere(InstanceKlass* context_type, bool participants_hide_witnesses) {\n@@ -1335,12 +1332,2 @@\n-  if (top_level_call) {\n-    if (do_counts) {\n-      NOT_PRODUCT(deps_find_witness_calls++);\n-      NOT_PRODUCT(deps_find_witness_steps++);\n-    }\n-    if (is_participant(context_type)) {\n-      if (participants_hide_witnesses)  return NULL;\n-      \/\/ else fall through to search loop...\n-    } else if (is_witness(context_type) && !ignore_witness(context_type)) {\n-      \/\/ The context is an abstract class or interface, to start with.\n-      return context_type;\n-    }\n+  if (do_counts) {\n+    NOT_PRODUCT(deps_find_witness_calls++);\n@@ -1349,16 +1336,1 @@\n-  \/\/ Now we must check each implementor and each subclass.\n-  \/\/ Use a short worklist to avoid blowing the stack.\n-  \/\/ Each worklist entry is a *chain* of subklass siblings to process.\n-  const int CHAINMAX = 100;  \/\/ >= 1 + InstanceKlass::implementors_limit\n-  Klass* chains[CHAINMAX];\n-  int    chaini = 0;  \/\/ index into worklist\n-  Klass* chain;       \/\/ scratch variable\n-#define ADD_SUBCLASS_CHAIN(k)                     {  \\\n-    assert(chaini < CHAINMAX, \"oob\");                \\\n-    chain = k->subklass();                           \\\n-    if (chain != NULL)  chains[chaini++] = chain;    }\n-\n-  \/\/ Look for non-abstract subclasses.\n-  \/\/ (Note:  Interfaces do not have subclasses.)\n-  ADD_SUBCLASS_CHAIN(context_type);\n-\n+  \/\/ (Note: Interfaces do not have subclasses.)\n@@ -1366,6 +1338,9 @@\n-  \/\/ (Their subclasses are additional indirect implementors.\n-  \/\/ See InstanceKlass::add_implementor.)\n-  \/\/ (Note:  nof_implementors is always zero for non-interfaces.)\n-  if (top_level_call) {\n-    int nof_impls = InstanceKlass::cast(context_type)->nof_implementors();\n-    if (nof_impls > 1) {\n+  \/\/ (Their subclasses are additional indirect implementors. See InstanceKlass::add_implementor().)\n+  if (context_type->is_interface()) {\n+    int nof_impls = context_type->nof_implementors();\n+    if (nof_impls == 0) {\n+      return NULL; \/\/ no implementors\n+    } else if (nof_impls == 1) { \/\/ unique implementor\n+      assert(context_type != context_type->implementor(), \"not unique\");\n+      context_type = InstanceKlass::cast(context_type->implementor());\n+    } else { \/\/ nof_impls >= 2\n@@ -1378,1 +1353,0 @@\n-      \/\/ (Old CHA had the same limitation.)\n@@ -1381,20 +1355,0 @@\n-    if (nof_impls > 0) {\n-      Klass* impl = InstanceKlass::cast(context_type)->implementor();\n-      assert(impl != NULL, \"just checking\");\n-      \/\/ If impl is the same as the context_type, then more than one\n-      \/\/ implementor has seen. No exact info in this case.\n-      if (impl == context_type) {\n-        return context_type;  \/\/ report an inexact witness to this sad affair\n-      }\n-      if (do_counts)\n-        { NOT_PRODUCT(deps_find_witness_steps++); }\n-      if (is_participant(impl)) {\n-        if (!participants_hide_witnesses) {\n-          ADD_SUBCLASS_CHAIN(impl);\n-        }\n-      } else if (is_witness(impl) && !ignore_witness(impl)) {\n-        return impl;\n-      } else {\n-        ADD_SUBCLASS_CHAIN(impl);\n-      }\n-    }\n@@ -1403,25 +1357,12 @@\n-  \/\/ Recursively process each non-trivial sibling chain.\n-  while (chaini > 0) {\n-    Klass* chain = chains[--chaini];\n-    for (Klass* sub = chain; sub != NULL; sub = sub->next_sibling()) {\n-      if (do_counts) { NOT_PRODUCT(deps_find_witness_steps++); }\n-      if (is_participant(sub)) {\n-        if (participants_hide_witnesses)  continue;\n-        \/\/ else fall through to process this guy's subclasses\n-      } else if (is_witness(sub) && !ignore_witness(sub)) {\n-        return sub;\n-      }\n-      if (chaini < (VerifyDependencies? 2: CHAINMAX)) {\n-        \/\/ Fast path.  (Partially disabled if VerifyDependencies.)\n-        ADD_SUBCLASS_CHAIN(sub);\n-      } else {\n-        \/\/ Worklist overflow.  Do a recursive call.  Should be rare.\n-        \/\/ The recursive call will have its own worklist, of course.\n-        \/\/ (Note that sub has already been tested, so that there is\n-        \/\/ no need for the recursive call to re-test.  That's handy,\n-        \/\/ since the recursive call sees sub as the context_type.)\n-        if (do_counts) { NOT_PRODUCT(deps_find_witness_recursions++); }\n-        Klass* witness = find_witness_anywhere(sub,\n-                                               participants_hide_witnesses,\n-                                               \/*top_level_call=*\/ false);\n-        if (witness != NULL)  return witness;\n+  assert(!context_type->is_interface(), \"not allowed\");\n+\n+  for (ClassHierarchyIterator iter(context_type); !iter.done(); iter.next()) {\n+    Klass* sub = iter.klass();\n+\n+    if (do_counts) { NOT_PRODUCT(deps_find_witness_steps++); }\n+\n+    \/\/ Do not report participant types.\n+    if (is_participant(sub)) {\n+      \/\/ Walk beneath a participant only when it doesn't hide witnesses.\n+      if (participants_hide_witnesses) {\n+        iter.skip_subclasses();\n@@ -1429,0 +1370,2 @@\n+    } else if (is_witness(sub) && !ignore_witness(sub)) {\n+      return sub; \/\/ found a witness\n@@ -1431,1 +1374,0 @@\n-\n@@ -1434,1 +1376,0 @@\n-#undef ADD_SUBCLASS_CHAIN\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":46,"deletions":105,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -1433,0 +1433,54 @@\n+\/\/ Iterator over class hierarchy under a particular class. Implements depth-first pre-order traversal.\n+\/\/ Usage:\n+\/\/  for (ClassHierarchyIterator iter(root_klass); !iter.done(); iter.next()) {\n+\/\/    Klass* k = iter.klass();\n+\/\/    ...\n+\/\/  }\n+class ClassHierarchyIterator : public StackObj {\n+ private:\n+  InstanceKlass* _root;\n+  Klass*         _current;\n+  bool           _visit_subclasses;\n+\n+ public:\n+  ClassHierarchyIterator(InstanceKlass* root) : _root(root), _current(root), _visit_subclasses(true) {\n+    assert(!root->is_interface(), \"no subclasses\");\n+    assert(_root == _current, \"required\"); \/\/ initial state\n+  }\n+\n+  bool done() {\n+    return (_current == NULL);\n+  }\n+\n+  \/\/ Make a step iterating over the class hierarchy under the root class.\n+  \/\/ Skips subclasses if requested.\n+  void next() {\n+    assert(_current != NULL, \"required\");\n+    if (_visit_subclasses && _current->subklass() != NULL) {\n+      _current = _current->subklass();\n+      return; \/\/ visit next subclass\n+    }\n+    _visit_subclasses = true; \/\/ reset\n+    while (_current->next_sibling() == NULL && _current != _root) {\n+      _current = _current->superklass(); \/\/ backtrack; no more sibling subclasses left\n+    }\n+    if (_current == _root) {\n+      \/\/ Iteration is over (back at root after backtracking). Invalidate the iterator.\n+      _current = NULL;\n+      return;\n+    }\n+    _current = _current->next_sibling();\n+    return; \/\/ visit next sibling subclass\n+  }\n+\n+  Klass* klass() {\n+    assert(!done(), \"sanity\");\n+    return _current;\n+  }\n+\n+  \/\/ Skip subclasses of the current class.\n+  void skip_subclasses() {\n+    _visit_subclasses = false;\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":54,"deletions":0,"binary":false,"changes":54,"status":"modified"}]}