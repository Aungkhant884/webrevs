{"files":[{"patch":"@@ -345,2 +345,1 @@\n-  predicate(UseSVE > 0 &&\n-            n->as_LoadVector()->memory_size() == MaxVectorSize);\n+  predicate(UseSVE > 0);\n@@ -359,20 +358,0 @@\n-instruct loadV_masked_partial(vReg dst, vmemA mem, pRegGov pg, pRegGov pgtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->as_LoadVector()->memory_size() < MaxVectorSize);\n-  match(Set dst (LoadVectorMasked mem pg));\n-  effect(TEMP pgtmp, KILL cr);\n-  ins_cost(6 * SVE_COST);\n-  format %{ \"sve_ldr $dst, $pg, $mem\\t# load vector predicated partial (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_ptrue_lanecnt(as_PRegister($pgtmp$$reg), __ elemType_to_regVariant(bt),\n-                         Matcher::vector_length(this));\n-    __ sve_and(as_PRegister($pgtmp$$reg), as_PRegister($pgtmp$$reg),\n-               as_PRegister($pg$$reg), as_PRegister($pg$$reg));\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, as_FloatRegister($dst$$reg),\n-                          as_PRegister($pgtmp$$reg), bt, bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -380,2 +359,1 @@\n-  predicate(UseSVE > 0 &&\n-            n->as_StoreVector()->memory_size() == MaxVectorSize);\n+  predicate(UseSVE > 0);\n@@ -394,108 +372,0 @@\n-instruct storeV_masked_partial(vReg src, vmemA mem, pRegGov pg, pRegGov pgtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->as_StoreVector()->memory_size() < MaxVectorSize);\n-  match(Set mem (StoreVectorMasked mem (Binary src pg)));\n-  effect(TEMP pgtmp, KILL cr);\n-  ins_cost(6 * SVE_COST);\n-  format %{ \"sve_str $mem, $pg, $src\\t# store vector predicated partial (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    __ sve_ptrue_lanecnt(as_PRegister($pgtmp$$reg), __ elemType_to_regVariant(bt),\n-                         Matcher::vector_length(this, $src));\n-    __ sve_and(as_PRegister($pgtmp$$reg), as_PRegister($pgtmp$$reg),\n-               as_PRegister($pg$$reg), as_PRegister($pg$$reg));\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, as_FloatRegister($src$$reg),\n-                          as_PRegister($pgtmp$$reg), bt, bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ maskAll (full or partial predicate size)\n-\n-instruct vmaskAll_immI(pRegGov dst, immI src) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (MaskAll src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_ptrue_lanecnt\/sve_pfalse $dst\\t# mask all (sve) (B\/H\/S)\" %}\n-  ins_encode %{\n-    int con = (int)$src$$constant;\n-    if (con == 0) {\n-      __ sve_pfalse(as_PRegister($dst$$reg));\n-    } else {\n-      assert(con == -1, \"invalid constant value for mask\");\n-      BasicType bt = Matcher::vector_element_basic_type(this);\n-      __ sve_ptrue_lanecnt(as_PRegister($dst$$reg), __ elemType_to_regVariant(bt),\n-                           Matcher::vector_length(this));\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmaskAllI(pRegGov dst, iRegIorL2I src, vReg tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (MaskAll src));\n-  effect(TEMP tmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_dup $tmp, $src\\n\\t\"\n-            \"sve_ptrue $dst, vector_length\\n\\t\"\n-            \"sve_cmpne $dst, $dst, $tmp, 0\\t# mask all (sve) (B\/H\/S)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n-    __ sve_dup(as_FloatRegister($tmp$$reg), size, as_Register($src$$reg));\n-    if (length_in_bytes < MaxVectorSize) {\n-      __ sve_ptrue_lanecnt(as_PRegister($dst$$reg), size, Matcher::vector_length(this));\n-      __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size,\n-                 as_PRegister($dst$$reg), as_FloatRegister($tmp$$reg), 0);\n-    } else {\n-      __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($tmp$$reg), 0);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmaskAll_immL(pRegGov dst, immL src) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (MaskAll src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_ptrue_lanecnt\/sve_pfalse $dst\\t# mask all (sve) (D)\" %}\n-  ins_encode %{\n-    long con = (long)$src$$constant;\n-    if (con == 0) {\n-      __ sve_pfalse(as_PRegister($dst$$reg));\n-    } else {\n-      assert(con == -1, \"invalid constant value for mask\");\n-      BasicType bt = Matcher::vector_element_basic_type(this);\n-      __ sve_ptrue_lanecnt(as_PRegister($dst$$reg), __ elemType_to_regVariant(bt),\n-                           Matcher::vector_length(this));\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmaskAllL(pRegGov dst, iRegL src, vReg tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (MaskAll src));\n-  effect(TEMP tmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_dup $tmp, $src\\n\\t\"\n-            \"sve_ptrue $dst, vector_length\\n\\t\"\n-            \"sve_cmpne $dst, $dst, $tmp, 0\\t# mask all (sve) (D)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n-    __ sve_dup(as_FloatRegister($tmp$$reg), size, as_Register($src$$reg));\n-    if (length_in_bytes < MaxVectorSize) {\n-      __ sve_ptrue_lanecnt(as_PRegister($dst$$reg), size, Matcher::vector_length(this));\n-      __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size,\n-                 as_PRegister($dst$$reg), as_FloatRegister($tmp$$reg), 0);\n-    } else {\n-      __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($tmp$$reg), 0);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -2061,30 +1931,0 @@\n-\/\/ vector mask compare\n-\n-instruct vmaskcmp(pRegGov dst, vReg src1, vReg src2, immI cond, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_cmp $dst, $src1, $src2\\t# vector mask cmp (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_compare(as_PRegister($dst$$reg), bt, ptrue, as_FloatRegister($src1$$reg),\n-                   as_FloatRegister($src2$$reg), (int)$cond$$constant);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmaskcmp_masked(pRegGov dst, vReg src1, vReg src2, immI cond, pRegGov pg, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) (Binary cond pg)));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_cmp $dst, $pg, $src1, $src2\\t# vector mask cmp (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_compare(as_PRegister($dst$$reg), bt, as_PRegister($pg$$reg), as_FloatRegister($src1$$reg),\n-                   as_FloatRegister($src2$$reg), (int)$cond$$constant);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -2107,31 +1947,0 @@\n-\/\/ vector load mask\n-\n-instruct vloadmaskB(pRegGov dst, vReg src, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorLoadMask src));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"vloadmaskB $dst, $src\\t# vector load mask (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ B,\n-               ptrue, as_FloatRegister($src$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vloadmask_extend(pRegGov dst, vReg src, vReg tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() != T_BYTE);\n-  match(Set dst (VectorLoadMask src));\n-  effect(TEMP tmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"vloadmask $dst, $src\\t# vector load mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_vector_extend(as_FloatRegister($tmp$$reg), size, as_FloatRegister($src$$reg), __ B);\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($tmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -2387,2 +2196,1 @@\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  predicate(UseSVE > 0);\n@@ -2403,2 +2211,1 @@\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  predicate(UseSVE > 0);\n@@ -2418,2 +2225,1 @@\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  predicate(UseSVE > 0);\n@@ -2431,2 +2237,1 @@\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  predicate(UseSVE > 0);\n@@ -2443,74 +2248,0 @@\n-instruct reduce_addI_masked_partial(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp,\n-                                  pRegGov pg, pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n-  match(Set dst (AddReductionVI (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_reduce_addI $dst, $src1, $pg, $src2\\t# addI reduction predicated partial (sve) (may extend)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), variant, Matcher::vector_length(this, $src2));\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-               as_PRegister($pg$$reg), as_PRegister($pg$$reg));\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($ptmp$$reg), as_FloatRegister($vtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_addL_masked_partial(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp,\n-                                  pRegGov pg, pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n-  match(Set dst (AddReductionVL (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_reduce_addL $dst, $src1, $pg, $src2\\t# addL reduction predicated partial (sve)\" %}\n-  ins_encode %{\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), __ D, Matcher::vector_length(this, $src2));\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-               as_PRegister($pg$$reg), as_PRegister($pg$$reg));\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($ptmp$$reg), as_FloatRegister($vtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_addF_masked_partial(vRegF src1_dst, vReg src2, pRegGov pg, pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n-  match(Set src1_dst (AddReductionVF (Binary src1_dst src2) pg));\n-  effect(TEMP ptmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_addF $src1_dst, $pg, $src2\\t# addF reduction predicated partial (sve)\" %}\n-  ins_encode %{\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), __ S, Matcher::vector_length(this, $src2));\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-               as_PRegister($pg$$reg), as_PRegister($pg$$reg));\n-    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ S,\n-                 as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_addD_masked_partial(vRegD src1_dst, vReg src2, pRegGov pg, pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n-  match(Set src1_dst (AddReductionVD (Binary src1_dst src2) pg));\n-  effect(TEMP ptmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_addD $src1_dst, $pg, $src2\\t# addD reduction predicated partial (sve)\" %}\n-  ins_encode %{\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), __ D, Matcher::vector_length(this, $src2));\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-               as_PRegister($pg$$reg), as_PRegister($pg$$reg));\n-    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ D,\n-                 as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -2594,2 +2325,1 @@\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG);\n@@ -2611,2 +2341,1 @@\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n@@ -2625,45 +2354,3 @@\n-instruct reduce_andI_masked_partial(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp,\n-                                  pRegGov pg, pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n-  match(Set dst (AndReductionV (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_reduce_andI $dst, $src1, $pg, $src2\\t# andI reduction predicated partial (sve) (may extend)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), variant, Matcher::vector_length(this, $src2));\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-               as_PRegister($pg$$reg), as_PRegister($pg$$reg));\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($ptmp$$reg), as_FloatRegister($vtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_andL_masked_partial(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp,\n-                                  pRegGov pg, pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n-  match(Set dst (AndReductionV (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_reduce_andL $dst, $src1, $pg, $src2\\t# andL reduction predicated partial (sve)\" %}\n-  ins_encode %{\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), __ D, Matcher::vector_length(this, $src2));\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-               as_PRegister($pg$$reg), as_PRegister($pg$$reg));\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($ptmp$$reg), as_FloatRegister($vtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector or reduction\n-\n-instruct reduce_orI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{\n+\/\/ vector or reduction\n+\n+instruct reduce_orI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{\n@@ -2744,2 +2431,1 @@\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG);\n@@ -2761,2 +2447,1 @@\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n@@ -2775,42 +2460,0 @@\n-instruct reduce_orI_masked_partial(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp,\n-                                  pRegGov pg, pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n-  match(Set dst (OrReductionV (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_reduce_orI $dst, $src1, $pg, $src2\\t# orI reduction predicated partial (sve) (may extend)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), variant, Matcher::vector_length(this, $src2));\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-               as_PRegister($pg$$reg), as_PRegister($pg$$reg));\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($ptmp$$reg), as_FloatRegister($vtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_orL_masked_partial(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp,\n-                                  pRegGov pg, pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n-  match(Set dst (OrReductionV (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_reduce_orL $dst, $src1, $pg, $src2\\t# orL reduction predicated partial (sve)\" %}\n-  ins_encode %{\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), __ D, Matcher::vector_length(this, $src2));\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-               as_PRegister($pg$$reg), as_PRegister($pg$$reg));\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($ptmp$$reg), as_FloatRegister($vtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -2894,2 +2537,1 @@\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG);\n@@ -2911,2 +2553,1 @@\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n@@ -2925,42 +2566,0 @@\n-instruct reduce_eorI_masked_partial(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp,\n-                                  pRegGov pg, pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n-  match(Set dst (XorReductionV (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_reduce_eorI $dst, $src1, $pg, $src2\\t# eorI reduction predicated partial (sve) (may extend)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), variant, Matcher::vector_length(this, $src2));\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-               as_PRegister($pg$$reg), as_PRegister($pg$$reg));\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($ptmp$$reg), as_FloatRegister($vtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_eorL_masked_partial(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp,\n-                                  pRegGov pg, pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n-  match(Set dst (XorReductionV (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_reduce_eorL $dst, $src1, $pg, $src2\\t# eorL reduction predicated partial (sve)\" %}\n-  ins_encode %{\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), __ D, Matcher::vector_length(this, $src2));\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-               as_PRegister($pg$$reg), as_PRegister($pg$$reg));\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($ptmp$$reg), as_FloatRegister($vtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -3111,1 +2710,0 @@\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize &&\n@@ -3130,1 +2728,0 @@\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize &&\n@@ -3144,43 +2741,0 @@\n-instruct reduce_maxI_masked_partial(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp,\n-                                  pRegGov pg, pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n-            is_integral_type(n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type()));\n-  match(Set dst (MaxReductionV (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_reduce_maxI $dst, $src1, $pg, $src2\\t# maxI reduction predicated partial (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), variant, Matcher::vector_length(this, $src2));\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-               as_PRegister($pg$$reg), as_PRegister($pg$$reg));\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($ptmp$$reg), as_FloatRegister($vtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_maxL_masked_partial(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp,\n-                                  pRegGov pg, pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (MaxReductionV (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_reduce_maxL $dst, $src1, $pg, $src2\\t# maxL reduction predicated partial (sve)\" %}\n-  ins_encode %{\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), __ D, Matcher::vector_length(this, $src2));\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-               as_PRegister($pg$$reg), as_PRegister($pg$$reg));\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($ptmp$$reg), as_FloatRegister($vtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -3189,2 +2743,1 @@\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n@@ -3204,2 +2757,1 @@\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n@@ -3217,40 +2769,0 @@\n-instruct reduce_maxF_masked_partial(vRegF dst, vRegF src1, vReg src2, pRegGov pg,\n-                                    pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n-  match(Set dst (MaxReductionV (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP ptmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_reduce_maxF $dst, $src1, $pg, $src2\\t# maxF reduction predicated partial (sve)\" %}\n-  ins_encode %{\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), __ S, Matcher::vector_length(this, $src2));\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-               as_PRegister($pg$$reg), as_PRegister($pg$$reg));\n-    __ sve_fmaxv(as_FloatRegister($dst$$reg), __ S,\n-               as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n-    __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_maxD_masked_partial(vRegD dst, vRegD src1, vReg src2, pRegGov pg,\n-                                    pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n-  match(Set dst (MaxReductionV (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP ptmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_reduce_maxD $dst, $src1, $pg, $src2\\t# maxD reduction predicated partial (sve)\" %}\n-  ins_encode %{\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), __ D, Matcher::vector_length(this, $src2));\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-               as_PRegister($pg$$reg), as_PRegister($pg$$reg));\n-    __ sve_fmaxv(as_FloatRegister($dst$$reg), __ D,\n-               as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n-    __ fmaxd(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -3401,1 +2913,0 @@\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize &&\n@@ -3420,1 +2931,0 @@\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize &&\n@@ -3434,43 +2944,0 @@\n-instruct reduce_minI_masked_partial(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp,\n-                                  pRegGov pg, pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n-            is_integral_type(n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type()));\n-  match(Set dst (MinReductionV (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_reduce_minI $dst, $src1, $pg, $src2\\t# minI reduction predicated partial (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), variant, Matcher::vector_length(this, $src2));\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-               as_PRegister($pg$$reg), as_PRegister($pg$$reg));\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($ptmp$$reg), as_FloatRegister($vtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_minL_masked_partial(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp,\n-                                  pRegGov pg, pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (MinReductionV (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_reduce_minL $dst, $src1, $pg, $src2\\t# minL reduction predicated partial (sve)\" %}\n-  ins_encode %{\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), __ D, Matcher::vector_length(this, $src2));\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-               as_PRegister($pg$$reg), as_PRegister($pg$$reg));\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($ptmp$$reg), as_FloatRegister($vtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -3479,2 +2946,1 @@\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n@@ -3494,2 +2960,1 @@\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n@@ -3507,40 +2972,0 @@\n-instruct reduce_minF_masked_partial(vRegF dst, vRegF src1, vReg src2, pRegGov pg,\n-                                    pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n-  match(Set dst (MinReductionV (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP ptmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_reduce_minF $dst, $src1, $pg, $src2\\t# minF reduction predicated partial (sve)\" %}\n-  ins_encode %{\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), __ S, Matcher::vector_length(this, $src2));\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-               as_PRegister($pg$$reg), as_PRegister($pg$$reg));\n-    __ sve_fminv(as_FloatRegister($dst$$reg), __ S,\n-               as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n-    __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_minD_masked_partial(vRegD dst, vRegD src1, vReg src2, pRegGov pg,\n-                                    pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n-  match(Set dst (MinReductionV (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP ptmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_reduce_minD $dst, $src1, $pg, $src2\\t# minD reduction predicated partial (sve)\" %}\n-  ins_encode %{\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), __ D, Matcher::vector_length(this, $src2));\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-               as_PRegister($pg$$reg), as_PRegister($pg$$reg));\n-    __ sve_fminv(as_FloatRegister($dst$$reg), __ D,\n-               as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n-    __ fmind(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -5050,1 +4475,0 @@\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize &&\n@@ -5068,1 +4492,0 @@\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize &&\n@@ -5082,41 +4505,0 @@\n-\n-instruct vtest_alltrue_partial(iRegINoSp dst, pRegGov src1, pRegGov src2, pRegGov ptmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize &&\n-            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow);\n-  match(Set dst (VectorTest src1 src2));\n-  effect(TEMP ptmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"vtest_alltrue_partial $dst, $src1, $src2\\t# VectorTest partial (sve) - alltrue\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src1);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), size, Matcher::vector_length(this, $src1));\n-    __ sve_eors(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-          as_PRegister($src1$$reg), as_PRegister($src2$$reg));\n-    __ csetw(as_Register($dst$$reg), Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vtest_anytrue_partial(iRegINoSp dst, pRegGov src1, pRegGov src2, pRegGov ptmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize &&\n-            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::ne);\n-  match(Set dst (VectorTest src1 src2));\n-  effect(TEMP ptmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"vtest_anytrue_partial $dst, $src1, $src2\\t# VectorTest partial (sve) - anytrue\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src1);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), size, Matcher::vector_length(this, $src1));\n-    __ sve_ands(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-          as_PRegister($src1$$reg), as_PRegister($src2$$reg));\n-    __ csetw(as_Register($dst$$reg), Assembler::NE);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -5379,1 +4761,0 @@\n-            n->as_LoadVector()->memory_size() == MaxVectorSize &&\n@@ -5394,1 +4775,0 @@\n-            n->as_LoadVector()->memory_size() == MaxVectorSize &&\n@@ -5408,41 +4788,0 @@\n-\/\/ ------------------------------ Vector Load Gather Predicated Partial -------------------------------\n-\n-instruct gatherI_masked_partial(vReg dst, indirect mem, vReg idx, pRegGov pg, pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->as_LoadVector()->memory_size() < MaxVectorSize &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx pg)));\n-  effect(TEMP ptmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"load_vector_gather $dst, $pg, $mem, $idx\\t# vector load gather predicated partial (S)\" %}\n-  ins_encode %{\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), __ S, Matcher::vector_length(this));\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-               as_PRegister($pg$$reg), as_PRegister($pg$$reg));\n-    __ sve_ld1w_gather(as_FloatRegister($dst$$reg), as_PRegister($ptmp$$reg),\n-                       as_Register($mem$$base), as_FloatRegister($idx$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct gatherL_masked_partial(vReg dst, indirect mem, vReg idx, pRegGov pg, pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->as_LoadVector()->memory_size() < MaxVectorSize &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx pg)));\n-  effect(TEMP ptmp, KILL cr);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"load_vector_gather $dst, $pg, $mem, $idx\\t# vector load gather predicated partial (D)\" %}\n-  ins_encode %{\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), __ D, Matcher::vector_length(this));\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-               as_PRegister($pg$$reg), as_PRegister($pg$$reg));\n-    __ sve_uunpklo(as_FloatRegister($idx$$reg), __ D, as_FloatRegister($idx$$reg));\n-    __ sve_ld1d_gather(as_FloatRegister($dst$$reg), as_PRegister($ptmp$$reg),\n-                       as_Register($mem$$base), as_FloatRegister($idx$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -5523,1 +4862,0 @@\n-            n->as_StoreVector()->memory_size() == MaxVectorSize &&\n@@ -5538,1 +4876,0 @@\n-            n->as_StoreVector()->memory_size() == MaxVectorSize &&\n@@ -5552,41 +4889,0 @@\n-\/\/ ------------------------------ Vector Store Scatter Predicated Partial -------------------------------\n-\n-instruct scatterI_masked_partial(indirect mem, vReg src, vReg idx, pRegGov pg, pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->as_StoreVector()->memory_size() < MaxVectorSize &&\n-            (n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-             n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n-  match(Set mem (StoreVectorScatterMasked mem (Binary src (Binary idx pg))));\n-  effect(TEMP ptmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"store_vector_scatter $mem, $pg, $idx, $src\\t# vector store scatter predicated partial (S)\" %}\n-  ins_encode %{\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), __ S, Matcher::vector_length(this, $src));\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-               as_PRegister($pg$$reg), as_PRegister($pg$$reg));\n-    __ sve_st1w_scatter(as_FloatRegister($src$$reg), as_PRegister($ptmp$$reg),\n-                        as_Register($mem$$base), as_FloatRegister($idx$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct scatterL_masked_partial(indirect mem, vReg src, vReg idx, pRegGov pg, pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->as_StoreVector()->memory_size() < MaxVectorSize &&\n-            (n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n-             n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n-  match(Set mem (StoreVectorScatterMasked mem (Binary src (Binary idx pg))));\n-  effect(TEMP ptmp, KILL cr);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"store_vector_scatter $mem, $pg, $idx, $src\\t# vector store scatter predicated partial (D)\" %}\n-  ins_encode %{\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), __ D, Matcher::vector_length(this, $src));\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-               as_PRegister($pg$$reg), as_PRegister($pg$$reg));\n-    __ sve_uunpklo(as_FloatRegister($idx$$reg), __ D, as_FloatRegister($idx$$reg));\n-    __ sve_st1d_scatter(as_FloatRegister($src$$reg), as_PRegister($ptmp$$reg),\n-                        as_Register($mem$$base), as_FloatRegister($idx$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -5648,2 +4944,1 @@\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  predicate(UseSVE > 0);\n@@ -5661,0 +4956,2 @@\n+\/\/ Return the index of the first mask lane that is set, or vector length if none of\n+\/\/ them are set.\n@@ -5662,2 +4959,1 @@\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  predicate(UseSVE > 0);\n@@ -5666,1 +4962,1 @@\n-  ins_cost(2 * SVE_COST);\n+  ins_cost(3 * SVE_COST);\n@@ -5669,0 +4965,1 @@\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n@@ -5671,1 +4968,8 @@\n-    __ sve_brkb(as_PRegister($ptmp$$reg), ptrue, as_PRegister($src$$reg), false);\n+    \/\/ When the input predicate is all-false, the result should be the vector length\n+    \/\/ instead of max vector register size.\n+    if (length_in_bytes == MaxVectorSize) {\n+      __ sve_brkb(as_PRegister($ptmp$$reg), ptrue, as_PRegister($src$$reg), false);\n+    } else {\n+      __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), size, Matcher::vector_length(this, $src));\n+      __ sve_brkb(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg), as_PRegister($src$$reg), false);\n+    }\n@@ -5678,2 +4982,1 @@\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  predicate(UseSVE > 0);\n@@ -5691,1 +4994,1 @@\n-instruct vmask_truecount_partial(iRegINoSp dst, pReg src, pReg ptmp, rFlagsReg cr) %{\n+instruct vmask_tolong(iRegLNoSp dst, pReg src, vReg vtmp1, vReg vtmp2, pRegGov pgtmp, rFlagsReg cr) %{\n@@ -5693,5 +4996,5 @@\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n-  match(Set dst (VectorMaskTrueCount src));\n-  effect(TEMP ptmp, KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"vmask_truecount_partial $dst, $src\\t# vector mask truecount partial (sve)\" %}\n+            n->in(1)->bottom_type()->is_vect()->length() <= 64);\n+  match(Set dst (VectorMaskToLong src));\n+  effect(TEMP vtmp1, TEMP vtmp2, TEMP pgtmp, KILL cr);\n+  ins_cost(13 * SVE_COST);\n+  format %{ \"vmask_tolong $dst, $src\\t# vector mask tolong (sve)\" %}\n@@ -5699,4 +5002,5 @@\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), size, Matcher::vector_length(this, $src));\n-    __ sve_cntp($dst$$Register, size, as_PRegister($ptmp$$reg), as_PRegister($src$$reg));\n+    __ sve_vmask_tolong(as_Register($dst$$reg), as_PRegister($src$$reg),\n+                        Matcher::vector_element_basic_type(this, $src),\n+                        Matcher::vector_length(this, $src),\n+                        as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg),\n+                        as_PRegister($pgtmp$$reg));\n@@ -5707,5 +5011,31 @@\n-instruct vmask_firsttrue_partial(iRegINoSp dst, pReg src, pReg ptmp1, pReg ptmp2, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n-  match(Set dst (VectorMaskFirstTrue src));\n-  effect(TEMP ptmp1, TEMP ptmp2, KILL cr);\n+\/\/ ---------------------------- Vector mask generation ---------------------------\n+\/\/ The rules below set predicate registers. They can guarantee the high bits of dst\n+\/\/ are cleared with zero when the vector length is less than the full size of\n+\/\/ hardware vector register width.\n+\n+\n+\/\/ maskAll (full or partial predicate size)\n+\n+instruct vmaskAll_immI(pRegGov dst, immI src) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (MaskAll src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_ptrue_lanecnt\/sve_pfalse $dst\\t# mask all (sve) (B\/H\/S)\" %}\n+  ins_encode %{\n+    int con = (int)$src$$constant;\n+    if (con == 0) {\n+      __ sve_pfalse(as_PRegister($dst$$reg));\n+    } else {\n+      assert(con == -1, \"invalid constant value for mask\");\n+      BasicType bt = Matcher::vector_element_basic_type(this);\n+      __ sve_ptrue_lanecnt(as_PRegister($dst$$reg), __ elemType_to_regVariant(bt),\n+                           Matcher::vector_length(this));\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskAllI(pRegGov dst, iRegIorL2I src, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (MaskAll src));\n+  effect(TEMP tmp, KILL cr);\n@@ -5713,1 +5043,3 @@\n-  format %{ \"vmask_firsttrue_partial $dst, $src\\t# vector mask firsttrue partial (sve)\" %}\n+  format %{ \"sve_dup $tmp, $src\\n\\t\"\n+            \"sve_ptrue $dst, vector_length\\n\\t\"\n+            \"sve_cmpne $dst, $dst, $tmp, 0\\t# mask all (sve) (B\/H\/S)\" %}\n@@ -5715,1 +5047,1 @@\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n@@ -5717,4 +5049,9 @@\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp1$$reg), size,\n-                          Matcher::vector_length(this, $src));\n-    __ sve_brkb(as_PRegister($ptmp2$$reg), as_PRegister($ptmp1$$reg), as_PRegister($src$$reg), false);\n-    __ sve_cntp($dst$$Register, size, as_PRegister($ptmp1$$reg), as_PRegister($ptmp2$$reg));\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ sve_dup(as_FloatRegister($tmp$$reg), size, as_Register($src$$reg));\n+    if (length_in_bytes < MaxVectorSize) {\n+      __ sve_ptrue_lanecnt(as_PRegister($dst$$reg), size, Matcher::vector_length(this));\n+      __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size,\n+                 as_PRegister($dst$$reg), as_FloatRegister($tmp$$reg), 0);\n+    } else {\n+      __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($tmp$$reg), 0);\n+    }\n@@ -5725,7 +5062,5 @@\n-instruct vmask_lasttrue_partial(iRegINoSp dst, pReg src, pReg ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n-  match(Set dst (VectorMaskLastTrue src));\n-  effect(TEMP ptmp, KILL cr);\n-  ins_cost(5 * SVE_COST);\n-  format %{ \"vmask_lasttrue_partial $dst, $src\\t# vector mask lasttrue partial (sve)\" %}\n+instruct vmaskAll_immL(pRegGov dst, immL src) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (MaskAll src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_ptrue_lanecnt\/sve_pfalse $dst\\t# mask all (sve) (D)\" %}\n@@ -5733,1 +5068,23 @@\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    long con = (long)$src$$constant;\n+    if (con == 0) {\n+      __ sve_pfalse(as_PRegister($dst$$reg));\n+    } else {\n+      assert(con == -1, \"invalid constant value for mask\");\n+      BasicType bt = Matcher::vector_element_basic_type(this);\n+      __ sve_ptrue_lanecnt(as_PRegister($dst$$reg), __ elemType_to_regVariant(bt),\n+                           Matcher::vector_length(this));\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskAllL(pRegGov dst, iRegL src, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (MaskAll src));\n+  effect(TEMP tmp, KILL cr);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_dup $tmp, $src\\n\\t\"\n+            \"sve_ptrue $dst, vector_length\\n\\t\"\n+            \"sve_cmpne $dst, $dst, $tmp, 0\\t# mask all (sve) (D)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n@@ -5735,3 +5092,9 @@\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), size, Matcher::vector_length(this, $src));\n-    __ sve_and(as_PRegister($ptmp$$reg), ptrue, as_PRegister($ptmp$$reg), as_PRegister($src$$reg));\n-    __ sve_vmask_lasttrue($dst$$Register, bt, as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg));\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ sve_dup(as_FloatRegister($tmp$$reg), size, as_Register($src$$reg));\n+    if (length_in_bytes < MaxVectorSize) {\n+      __ sve_ptrue_lanecnt(as_PRegister($dst$$reg), size, Matcher::vector_length(this));\n+      __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size,\n+                 as_PRegister($dst$$reg), as_FloatRegister($tmp$$reg), 0);\n+    } else {\n+      __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($tmp$$reg), 0);\n+    }\n@@ -5742,1 +5105,41 @@\n-instruct vmask_tolong(iRegLNoSp dst, pReg src, vReg vtmp1, vReg vtmp2, pRegGov pgtmp, rFlagsReg cr) %{\n+\/\/ vector mask compare\n+\n+instruct vmaskcmp(pRegGov dst, vReg src1, vReg src2, immI cond, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n+  effect(KILL cr);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_cmp $dst, $src1, $src2\\t# vector mask cmp (sve)\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (length_in_bytes == MaxVectorSize) {\n+      __ sve_compare(as_PRegister($dst$$reg), bt, ptrue, as_FloatRegister($src1$$reg),\n+                     as_FloatRegister($src2$$reg), (int)$cond$$constant);\n+    } else {\n+      __ sve_ptrue_lanecnt(as_PRegister($dst$$reg), __ elemType_to_regVariant(bt),\n+                           Matcher::vector_length(this));\n+      __ sve_compare(as_PRegister($dst$$reg), bt, as_PRegister($dst$$reg), as_FloatRegister($src1$$reg),\n+                     as_FloatRegister($src2$$reg), (int)$cond$$constant);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskcmp_masked(pRegGov dst, vReg src1, vReg src2, immI cond, pRegGov pg, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorMaskCmp (Binary src1 src2) (Binary cond pg)));\n+  effect(KILL cr);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_cmp $dst, $pg, $src1, $src2\\t# vector mask cmp (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_compare(as_PRegister($dst$$reg), bt, as_PRegister($pg$$reg), as_FloatRegister($src1$$reg),\n+                   as_FloatRegister($src2$$reg), (int)$cond$$constant);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector load mask\n+\n+instruct vloadmaskB(pRegGov dst, vReg src, rFlagsReg cr) %{\n@@ -5744,5 +5147,5 @@\n-            n->in(1)->bottom_type()->is_vect()->length() <= 64);\n-  match(Set dst (VectorMaskToLong src));\n-  effect(TEMP vtmp1, TEMP vtmp2, TEMP pgtmp, KILL cr);\n-  ins_cost(13 * SVE_COST);\n-  format %{ \"vmask_tolong $dst, $src\\t# vector mask tolong (sve)\" %}\n+            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  match(Set dst (VectorLoadMask src));\n+  effect(KILL cr);\n+  ins_cost(SVE_COST);\n+  format %{ \"vloadmaskB $dst, $src\\t# vector load mask (sve) (B)\" %}\n@@ -5750,5 +5153,2 @@\n-    __ sve_vmask_tolong(as_Register($dst$$reg), as_PRegister($src$$reg),\n-                        Matcher::vector_element_basic_type(this, $src),\n-                        Matcher::vector_length(this, $src),\n-                        as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg),\n-                        as_PRegister($pgtmp$$reg));\n+    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ B,\n+               ptrue, as_FloatRegister($src$$reg), 0);\n@@ -5758,1 +5158,16 @@\n-\/\/ ---------------------------- Vector mask generation ---------------------------\n+\n+instruct vloadmask_extend(pRegGov dst, vReg src, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() != T_BYTE);\n+  match(Set dst (VectorLoadMask src));\n+  effect(TEMP tmp, KILL cr);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"vloadmask $dst, $src\\t# vector load mask (sve) (H\/S\/D)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_vector_extend(as_FloatRegister($tmp$$reg), size, as_FloatRegister($src$$reg), __ B);\n+    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($tmp$$reg), 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":190,"deletions":775,"binary":false,"changes":965,"status":"modified"},{"patch":"@@ -282,2 +282,1 @@\n-  predicate(UseSVE > 0 &&\n-            n->as_LoadVector()->memory_size() == MaxVectorSize);\n+  predicate(UseSVE > 0);\n@@ -296,20 +295,0 @@\n-instruct loadV_masked_partial(vReg dst, vmemA mem, pRegGov pg, pRegGov pgtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->as_LoadVector()->memory_size() < MaxVectorSize);\n-  match(Set dst (LoadVectorMasked mem pg));\n-  effect(TEMP pgtmp, KILL cr);\n-  ins_cost(6 * SVE_COST);\n-  format %{ \"sve_ldr $dst, $pg, $mem\\t# load vector predicated partial (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_ptrue_lanecnt(as_PRegister($pgtmp$$reg), __ elemType_to_regVariant(bt),\n-                         Matcher::vector_length(this));\n-    __ sve_and(as_PRegister($pgtmp$$reg), as_PRegister($pgtmp$$reg),\n-               as_PRegister($pg$$reg), as_PRegister($pg$$reg));\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, as_FloatRegister($dst$$reg),\n-                          as_PRegister($pgtmp$$reg), bt, bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -317,2 +296,1 @@\n-  predicate(UseSVE > 0 &&\n-            n->as_StoreVector()->memory_size() == MaxVectorSize);\n+  predicate(UseSVE > 0);\n@@ -331,76 +309,0 @@\n-instruct storeV_masked_partial(vReg src, vmemA mem, pRegGov pg, pRegGov pgtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->as_StoreVector()->memory_size() < MaxVectorSize);\n-  match(Set mem (StoreVectorMasked mem (Binary src pg)));\n-  effect(TEMP pgtmp, KILL cr);\n-  ins_cost(6 * SVE_COST);\n-  format %{ \"sve_str $mem, $pg, $src\\t# store vector predicated partial (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    __ sve_ptrue_lanecnt(as_PRegister($pgtmp$$reg), __ elemType_to_regVariant(bt),\n-                         Matcher::vector_length(this, $src));\n-    __ sve_and(as_PRegister($pgtmp$$reg), as_PRegister($pgtmp$$reg),\n-               as_PRegister($pg$$reg), as_PRegister($pg$$reg));\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, as_FloatRegister($src$$reg),\n-                          as_PRegister($pgtmp$$reg), bt, bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-dnl\n-dnl MASKALL_IMM($1,   $2  )\n-dnl MASKALL_IMM(type, size)\n-define(`MASKALL_IMM', `\n-instruct vmaskAll_imm$1(pRegGov dst, imm$1 src) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (MaskAll src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_ptrue_lanecnt\/sve_pfalse $dst\\t# mask all (sve) ($2)\" %}\n-  ins_encode %{\n-    ifelse($1, `I', int, long) con = (ifelse($1, `I', int, long))$src$$constant;\n-    if (con == 0) {\n-      __ sve_pfalse(as_PRegister($dst$$reg));\n-    } else {\n-      assert(con == -1, \"invalid constant value for mask\");\n-      BasicType bt = Matcher::vector_element_basic_type(this);\n-      __ sve_ptrue_lanecnt(as_PRegister($dst$$reg), __ elemType_to_regVariant(bt),\n-                           Matcher::vector_length(this));\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl MASKALL($1,   $2  )\n-dnl MASKALL(type, size)\n-define(`MASKALL', `\n-instruct vmaskAll$1(pRegGov dst, ifelse($1, `I', iRegIorL2I, iRegL) src, vReg tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (MaskAll src));\n-  effect(TEMP tmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_dup $tmp, $src\\n\\t\"\n-            \"sve_ptrue $dst, vector_length\\n\\t\"\n-            \"sve_cmpne $dst, $dst, $tmp, 0\\t# mask all (sve) ($2)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n-    __ sve_dup(as_FloatRegister($tmp$$reg), size, as_Register($src$$reg));\n-    if (length_in_bytes < MaxVectorSize) {\n-      __ sve_ptrue_lanecnt(as_PRegister($dst$$reg), size, Matcher::vector_length(this));\n-      __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size,\n-                 as_PRegister($dst$$reg), as_FloatRegister($tmp$$reg), 0);\n-    } else {\n-      __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($tmp$$reg), 0);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ maskAll (full or partial predicate size)\n-MASKALL_IMM(I, B\/H\/S)\n-MASKALL(I, B\/H\/S)\n-MASKALL_IMM(L, D)\n-MASKALL(L, D)\n-\n@@ -1122,30 +1024,0 @@\n-\/\/ vector mask compare\n-\n-instruct vmaskcmp(pRegGov dst, vReg src1, vReg src2, immI cond, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_cmp $dst, $src1, $src2\\t# vector mask cmp (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_compare(as_PRegister($dst$$reg), bt, ptrue, as_FloatRegister($src1$$reg),\n-                   as_FloatRegister($src2$$reg), (int)$cond$$constant);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmaskcmp_masked(pRegGov dst, vReg src1, vReg src2, immI cond, pRegGov pg, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) (Binary cond pg)));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_cmp $dst, $pg, $src1, $src2\\t# vector mask cmp (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_compare(as_PRegister($dst$$reg), bt, as_PRegister($pg$$reg), as_FloatRegister($src1$$reg),\n-                   as_FloatRegister($src2$$reg), (int)$cond$$constant);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -1168,31 +1040,0 @@\n-\/\/ vector load mask\n-\n-instruct vloadmaskB(pRegGov dst, vReg src, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorLoadMask src));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"vloadmaskB $dst, $src\\t# vector load mask (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ B,\n-               ptrue, as_FloatRegister($src$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vloadmask_extend(pRegGov dst, vReg src, vReg tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() != T_BYTE);\n-  match(Set dst (VectorLoadMask src));\n-  effect(TEMP tmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"vloadmask $dst, $src\\t# vector load mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_vector_extend(as_FloatRegister($tmp$$reg), size, as_FloatRegister($src$$reg), __ B);\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($tmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -1457,0 +1298,1 @@\n+       `predicate(UseSVE > 0);',\n@@ -1458,4 +1300,1 @@\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);',\n-       `predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);')\n+            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG);')\n@@ -1480,0 +1319,1 @@\n+       `predicate(UseSVE > 0);',\n@@ -1481,4 +1321,1 @@\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);',\n-       `predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);')\n+            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);')\n@@ -1497,54 +1334,0 @@\n-dnl REDUCE_I_PREDICATE_PARTIAL($1,        $2     )\n-dnl REDUCE_I_PREDICATE_PARTIAL(insn_name, op_name)\n-define(`REDUCE_I_PREDICATE_PARTIAL', `\n-instruct reduce_$1I_masked_partial(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp,\n-                                  pRegGov pg, pRegGov ptmp, rFlagsReg cr) %{\n-  ifelse($2, AddReductionVI,\n-       `predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);',\n-       `predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);')\n-  match(Set dst ($2 (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_reduce_$1I $dst, $src1, $pg, $src2\\t# $1I reduction predicated partial (sve) (may extend)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), variant, Matcher::vector_length(this, $src2));\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-               as_PRegister($pg$$reg), as_PRegister($pg$$reg));\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($ptmp$$reg), as_FloatRegister($vtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl REDUCE_L_PREDICATE_PARTIAL($1,        $2    )\n-dnl REDUCE_L_PREDICATE_PARTIAL(insn_name, op_name)\n-define(`REDUCE_L_PREDICATE_PARTIAL', `\n-instruct reduce_$1L_masked_partial(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp,\n-                                  pRegGov pg, pRegGov ptmp, rFlagsReg cr) %{\n-  ifelse($2, AddReductionVL,\n-       `predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);',\n-       `predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);')\n-  match(Set dst ($2 (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_reduce_$1L $dst, $src1, $pg, $src2\\t# $1L reduction predicated partial (sve)\" %}\n-  ins_encode %{\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), __ D, Matcher::vector_length(this, $src2));\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-               as_PRegister($pg$$reg), as_PRegister($pg$$reg));\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($ptmp$$reg), as_FloatRegister($vtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n@@ -1555,2 +1338,1 @@\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  predicate(UseSVE > 0);\n@@ -1567,20 +1349,0 @@\n-dnl REDUCE_ADDF_PREDICATE_PARTIAL($1,        $2,      $3,      $4  )\n-dnl REDUCE_ADDF_PREDICATE_PARTIAL(insn_name, op_name, reg_dst, size)\n-define(`REDUCE_ADDF_PREDICATE_PARTIAL', `\n-instruct reduce_$1_masked_partial($3 src1_dst, vReg src2, pRegGov pg, pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n-  match(Set src1_dst ($2 (Binary src1_dst src2) pg));\n-  effect(TEMP ptmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_$1 $src1_dst, $pg, $src2\\t# $1 reduction predicated partial (sve)\" %}\n-  ins_encode %{\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), __ $4, Matcher::vector_length(this, $src2));\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-               as_PRegister($pg$$reg), as_PRegister($pg$$reg));\n-    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ $4,\n-                 as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n@@ -1603,4 +1365,0 @@\n-REDUCE_I_PREDICATE_PARTIAL(add, AddReductionVI)\n-REDUCE_L_PREDICATE_PARTIAL(add, AddReductionVL)\n-REDUCE_ADDF_PREDICATE_PARTIAL(addF, AddReductionVF, vRegF, S)\n-REDUCE_ADDF_PREDICATE_PARTIAL(addD, AddReductionVD, vRegD, D)\n@@ -1617,2 +1375,0 @@\n-REDUCE_I_PREDICATE_PARTIAL(and, AndReductionV)\n-REDUCE_L_PREDICATE_PARTIAL(and, AndReductionV)\n@@ -1629,2 +1385,0 @@\n-REDUCE_I_PREDICATE_PARTIAL(or, OrReductionV)\n-REDUCE_L_PREDICATE_PARTIAL(or, OrReductionV)\n@@ -1641,2 +1395,0 @@\n-REDUCE_I_PREDICATE_PARTIAL(eor, XorReductionV)\n-REDUCE_L_PREDICATE_PARTIAL(eor, XorReductionV)\n@@ -1736,1 +1488,0 @@\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize &&\n@@ -1758,1 +1509,0 @@\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize &&\n@@ -1772,49 +1522,0 @@\n-dnl REDUCE_MAXMIN_I_PREDICATE_PARTIAL($1     , $2     )\n-dnl REDUCE_MAXMIN_I_PREDICATE_PARTIAL(min_max, op_name)\n-define(`REDUCE_MAXMIN_I_PREDICATE_PARTIAL', `\n-instruct reduce_$1I_masked_partial(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp,\n-                                  pRegGov pg, pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n-            is_integral_type(n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type()));\n-  match(Set dst ($2 (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_reduce_$1I $dst, $src1, $pg, $src2\\t# $1I reduction predicated partial (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), variant, Matcher::vector_length(this, $src2));\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-               as_PRegister($pg$$reg), as_PRegister($pg$$reg));\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($ptmp$$reg), as_FloatRegister($vtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl REDUCE_MAXMIN_L_PREDICATE_PARTIAL($1     , $2     )\n-dnl REDUCE_MAXMIN_L_PREDICATE_PARTIAL(min_max, op_name)\n-define(`REDUCE_MAXMIN_L_PREDICATE_PARTIAL', `\n-instruct reduce_$1L_masked_partial(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp,\n-                                  pRegGov pg, pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst ($2 (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_reduce_$1L $dst, $src1, $pg, $src2\\t# $1L reduction predicated partial (sve)\" %}\n-  ins_encode %{\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), __ D, Matcher::vector_length(this, $src2));\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-               as_PRegister($pg$$reg), as_PRegister($pg$$reg));\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($ptmp$$reg), as_FloatRegister($vtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n@@ -1864,2 +1565,1 @@\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == $3 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == $3);\n@@ -1877,22 +1577,0 @@\n-dnl REDUCE_FMINMAX_PREDICATE_PARTIAL($1,      $2,          $3,           $4,   $5         )\n-dnl REDUCE_FMINMAX_PREDICATE_PARTIAL(min_max, name_suffix, element_type, size, reg_src_dst)\n-define(`REDUCE_FMINMAX_PREDICATE_PARTIAL', `\n-instruct reduce_$1$2_masked_partial($5 dst, $5 src1, vReg src2, pRegGov pg,\n-                                    pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == $3 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n-  match(Set dst (translit($1, `m', `M')ReductionV (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP ptmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_reduce_$1$2 $dst, $src1, $pg, $src2\\t# $1$2 reduction predicated partial (sve)\" %}\n-  ins_encode %{\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), __ $4, Matcher::vector_length(this, $src2));\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-               as_PRegister($pg$$reg), as_PRegister($pg$$reg));\n-    __ sve_f$1v(as_FloatRegister($dst$$reg), __ $4,\n-               as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n-    __ f`$1'translit($4, `SD', `sd')(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n@@ -1912,2 +1590,0 @@\n-REDUCE_MAXMIN_I_PREDICATE_PARTIAL(max, MaxReductionV)\n-REDUCE_MAXMIN_L_PREDICATE_PARTIAL(max, MaxReductionV)\n@@ -1916,2 +1592,0 @@\n-REDUCE_FMINMAX_PREDICATE_PARTIAL(max, F, T_FLOAT,  S, vRegF)\n-REDUCE_FMINMAX_PREDICATE_PARTIAL(max, D, T_DOUBLE, D, vRegD)\n@@ -1932,2 +1606,0 @@\n-REDUCE_MAXMIN_I_PREDICATE_PARTIAL(min, MinReductionV)\n-REDUCE_MAXMIN_L_PREDICATE_PARTIAL(min, MinReductionV)\n@@ -1936,2 +1608,0 @@\n-REDUCE_FMINMAX_PREDICATE_PARTIAL(min, F, T_FLOAT,  S, vRegF)\n-REDUCE_FMINMAX_PREDICATE_PARTIAL(min, D, T_DOUBLE, D, vRegD)\n@@ -2545,1 +2215,0 @@\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize &&\n@@ -2563,1 +2232,0 @@\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize &&\n@@ -2578,27 +2246,0 @@\n-dnl\n-dnl VTEST_PARTIAL($1,      $2,   $3,   $4  )\n-dnl VTEST_PARTIAL(op_name, pred, inst, cond)\n-define(`VTEST_PARTIAL', `\n-instruct vtest_$1_partial`'(iRegINoSp dst, pRegGov src1, pRegGov src2, pRegGov ptmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize &&\n-            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::$2);\n-  match(Set dst (VectorTest src1 src2));\n-  effect(TEMP ptmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"vtest_$1_partial $dst, $src1, $src2\\t# VectorTest partial (sve) - $1\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src1);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), size, Matcher::vector_length(this, $src1));\n-    __ $3(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-          as_PRegister($src1$$reg), as_PRegister($src2$$reg));\n-    __ csetw(as_Register($dst$$reg), Assembler::$4);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-VTEST_PARTIAL(alltrue, overflow, sve_eors, EQ)\n-VTEST_PARTIAL(anytrue, ne,       sve_ands, NE)\n-\n@@ -2845,1 +2486,0 @@\n-            n->as_LoadVector()->memory_size() == MaxVectorSize &&\n@@ -2860,1 +2500,0 @@\n-            n->as_LoadVector()->memory_size() == MaxVectorSize &&\n@@ -2874,41 +2513,0 @@\n-\/\/ ------------------------------ Vector Load Gather Predicated Partial -------------------------------\n-\n-instruct gatherI_masked_partial(vReg dst, indirect mem, vReg idx, pRegGov pg, pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->as_LoadVector()->memory_size() < MaxVectorSize &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx pg)));\n-  effect(TEMP ptmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"load_vector_gather $dst, $pg, $mem, $idx\\t# vector load gather predicated partial (S)\" %}\n-  ins_encode %{\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), __ S, Matcher::vector_length(this));\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-               as_PRegister($pg$$reg), as_PRegister($pg$$reg));\n-    __ sve_ld1w_gather(as_FloatRegister($dst$$reg), as_PRegister($ptmp$$reg),\n-                       as_Register($mem$$base), as_FloatRegister($idx$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct gatherL_masked_partial(vReg dst, indirect mem, vReg idx, pRegGov pg, pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->as_LoadVector()->memory_size() < MaxVectorSize &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx pg)));\n-  effect(TEMP ptmp, KILL cr);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"load_vector_gather $dst, $pg, $mem, $idx\\t# vector load gather predicated partial (D)\" %}\n-  ins_encode %{\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), __ D, Matcher::vector_length(this));\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-               as_PRegister($pg$$reg), as_PRegister($pg$$reg));\n-    __ sve_uunpklo(as_FloatRegister($idx$$reg), __ D, as_FloatRegister($idx$$reg));\n-    __ sve_ld1d_gather(as_FloatRegister($dst$$reg), as_PRegister($ptmp$$reg),\n-                       as_Register($mem$$base), as_FloatRegister($idx$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -2989,1 +2587,0 @@\n-            n->as_StoreVector()->memory_size() == MaxVectorSize &&\n@@ -3004,1 +2601,0 @@\n-            n->as_StoreVector()->memory_size() == MaxVectorSize &&\n@@ -3018,41 +2614,0 @@\n-\/\/ ------------------------------ Vector Store Scatter Predicated Partial -------------------------------\n-\n-instruct scatterI_masked_partial(indirect mem, vReg src, vReg idx, pRegGov pg, pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->as_StoreVector()->memory_size() < MaxVectorSize &&\n-            (n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-             n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n-  match(Set mem (StoreVectorScatterMasked mem (Binary src (Binary idx pg))));\n-  effect(TEMP ptmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"store_vector_scatter $mem, $pg, $idx, $src\\t# vector store scatter predicated partial (S)\" %}\n-  ins_encode %{\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), __ S, Matcher::vector_length(this, $src));\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-               as_PRegister($pg$$reg), as_PRegister($pg$$reg));\n-    __ sve_st1w_scatter(as_FloatRegister($src$$reg), as_PRegister($ptmp$$reg),\n-                        as_Register($mem$$base), as_FloatRegister($idx$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct scatterL_masked_partial(indirect mem, vReg src, vReg idx, pRegGov pg, pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->as_StoreVector()->memory_size() < MaxVectorSize &&\n-            (n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n-             n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n-  match(Set mem (StoreVectorScatterMasked mem (Binary src (Binary idx pg))));\n-  effect(TEMP ptmp, KILL cr);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"store_vector_scatter $mem, $pg, $idx, $src\\t# vector store scatter predicated partial (D)\" %}\n-  ins_encode %{\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), __ D, Matcher::vector_length(this, $src));\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-               as_PRegister($pg$$reg), as_PRegister($pg$$reg));\n-    __ sve_uunpklo(as_FloatRegister($idx$$reg), __ D, as_FloatRegister($idx$$reg));\n-    __ sve_st1d_scatter(as_FloatRegister($src$$reg), as_PRegister($ptmp$$reg),\n-                        as_Register($mem$$base), as_FloatRegister($idx$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -3100,2 +2655,1 @@\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  predicate(UseSVE > 0);\n@@ -3113,0 +2667,2 @@\n+\/\/ Return the index of the first mask lane that is set, or vector length if none of\n+\/\/ them are set.\n@@ -3114,2 +2670,1 @@\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  predicate(UseSVE > 0);\n@@ -3118,1 +2673,1 @@\n-  ins_cost(2 * SVE_COST);\n+  ins_cost(3 * SVE_COST);\n@@ -3121,0 +2676,1 @@\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n@@ -3123,1 +2679,8 @@\n-    __ sve_brkb(as_PRegister($ptmp$$reg), ptrue, as_PRegister($src$$reg), false);\n+    \/\/ When the input predicate is all-false, the result should be the vector length\n+    \/\/ instead of max vector register size.\n+    if (length_in_bytes == MaxVectorSize) {\n+      __ sve_brkb(as_PRegister($ptmp$$reg), ptrue, as_PRegister($src$$reg), false);\n+    } else {\n+      __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), size, Matcher::vector_length(this, $src));\n+      __ sve_brkb(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg), as_PRegister($src$$reg), false);\n+    }\n@@ -3130,2 +2693,1 @@\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  predicate(UseSVE > 0);\n@@ -3143,1 +2705,1 @@\n-instruct vmask_truecount_partial(iRegINoSp dst, pReg src, pReg ptmp, rFlagsReg cr) %{\n+instruct vmask_tolong(iRegLNoSp dst, pReg src, vReg vtmp1, vReg vtmp2, pRegGov pgtmp, rFlagsReg cr) %{\n@@ -3145,5 +2707,5 @@\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n-  match(Set dst (VectorMaskTrueCount src));\n-  effect(TEMP ptmp, KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"vmask_truecount_partial $dst, $src\\t# vector mask truecount partial (sve)\" %}\n+            n->in(1)->bottom_type()->is_vect()->length() <= 64);\n+  match(Set dst (VectorMaskToLong src));\n+  effect(TEMP vtmp1, TEMP vtmp2, TEMP pgtmp, KILL cr);\n+  ins_cost(13 * SVE_COST);\n+  format %{ \"vmask_tolong $dst, $src\\t# vector mask tolong (sve)\" %}\n@@ -3151,4 +2713,5 @@\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), size, Matcher::vector_length(this, $src));\n-    __ sve_cntp($dst$$Register, size, as_PRegister($ptmp$$reg), as_PRegister($src$$reg));\n+    __ sve_vmask_tolong(as_Register($dst$$reg), as_PRegister($src$$reg),\n+                        Matcher::vector_element_basic_type(this, $src),\n+                        Matcher::vector_length(this, $src),\n+                        as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg),\n+                        as_PRegister($pgtmp$$reg));\n@@ -3159,5 +2722,30 @@\n-instruct vmask_firsttrue_partial(iRegINoSp dst, pReg src, pReg ptmp1, pReg ptmp2, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n-  match(Set dst (VectorMaskFirstTrue src));\n-  effect(TEMP ptmp1, TEMP ptmp2, KILL cr);\n+\/\/ ---------------------------- Vector mask generation ---------------------------\n+\/\/ The rules below set predicate registers. They can guarantee the high bits of dst\n+\/\/ are cleared with zero when the vector length is less than the full size of\n+\/\/ hardware vector register width.\n+\n+define(`MASKALL_IMM', `\n+instruct vmaskAll_imm$1(pRegGov dst, imm$1 src) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (MaskAll src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_ptrue_lanecnt\/sve_pfalse $dst\\t# mask all (sve) ($2)\" %}\n+  ins_encode %{\n+    ifelse($1, `I', int, long) con = (ifelse($1, `I', int, long))$src$$constant;\n+    if (con == 0) {\n+      __ sve_pfalse(as_PRegister($dst$$reg));\n+    } else {\n+      assert(con == -1, \"invalid constant value for mask\");\n+      BasicType bt = Matcher::vector_element_basic_type(this);\n+      __ sve_ptrue_lanecnt(as_PRegister($dst$$reg), __ elemType_to_regVariant(bt),\n+                           Matcher::vector_length(this));\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+\n+define(`MASKALL', `\n+instruct vmaskAll$1(pRegGov dst, ifelse($1, `I', iRegIorL2I, iRegL) src, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (MaskAll src));\n+  effect(TEMP tmp, KILL cr);\n@@ -3165,1 +2753,3 @@\n-  format %{ \"vmask_firsttrue_partial $dst, $src\\t# vector mask firsttrue partial (sve)\" %}\n+  format %{ \"sve_dup $tmp, $src\\n\\t\"\n+            \"sve_ptrue $dst, vector_length\\n\\t\"\n+            \"sve_cmpne $dst, $dst, $tmp, 0\\t# mask all (sve) ($2)\" %}\n@@ -3167,1 +2757,1 @@\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n@@ -3169,4 +2759,39 @@\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp1$$reg), size,\n-                          Matcher::vector_length(this, $src));\n-    __ sve_brkb(as_PRegister($ptmp2$$reg), as_PRegister($ptmp1$$reg), as_PRegister($src$$reg), false);\n-    __ sve_cntp($dst$$Register, size, as_PRegister($ptmp1$$reg), as_PRegister($ptmp2$$reg));\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ sve_dup(as_FloatRegister($tmp$$reg), size, as_Register($src$$reg));\n+    if (length_in_bytes < MaxVectorSize) {\n+      __ sve_ptrue_lanecnt(as_PRegister($dst$$reg), size, Matcher::vector_length(this));\n+      __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size,\n+                 as_PRegister($dst$$reg), as_FloatRegister($tmp$$reg), 0);\n+    } else {\n+      __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($tmp$$reg), 0);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ maskAll (full or partial predicate size)\n+MASKALL_IMM(I, B\/H\/S)\n+MASKALL(I, B\/H\/S)\n+MASKALL_IMM(L, D)\n+MASKALL(L, D)\n+\n+\/\/ vector mask compare\n+\n+instruct vmaskcmp(pRegGov dst, vReg src1, vReg src2, immI cond, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n+  effect(KILL cr);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_cmp $dst, $src1, $src2\\t# vector mask cmp (sve)\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (length_in_bytes == MaxVectorSize) {\n+      __ sve_compare(as_PRegister($dst$$reg), bt, ptrue, as_FloatRegister($src1$$reg),\n+                     as_FloatRegister($src2$$reg), (int)$cond$$constant);\n+    } else {\n+      __ sve_ptrue_lanecnt(as_PRegister($dst$$reg), __ elemType_to_regVariant(bt),\n+                           Matcher::vector_length(this));\n+      __ sve_compare(as_PRegister($dst$$reg), bt, as_PRegister($dst$$reg), as_FloatRegister($src1$$reg),\n+                     as_FloatRegister($src2$$reg), (int)$cond$$constant);\n+    }\n@@ -3177,7 +2802,6 @@\n-instruct vmask_lasttrue_partial(iRegINoSp dst, pReg src, pReg ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n-  match(Set dst (VectorMaskLastTrue src));\n-  effect(TEMP ptmp, KILL cr);\n-  ins_cost(5 * SVE_COST);\n-  format %{ \"vmask_lasttrue_partial $dst, $src\\t# vector mask lasttrue partial (sve)\" %}\n+instruct vmaskcmp_masked(pRegGov dst, vReg src1, vReg src2, immI cond, pRegGov pg, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorMaskCmp (Binary src1 src2) (Binary cond pg)));\n+  effect(KILL cr);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_cmp $dst, $pg, $src1, $src2\\t# vector mask cmp (sve)\" %}\n@@ -3185,5 +2809,3 @@\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), size, Matcher::vector_length(this, $src));\n-    __ sve_and(as_PRegister($ptmp$$reg), ptrue, as_PRegister($ptmp$$reg), as_PRegister($src$$reg));\n-    __ sve_vmask_lasttrue($dst$$Register, bt, as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_compare(as_PRegister($dst$$reg), bt, as_PRegister($pg$$reg), as_FloatRegister($src1$$reg),\n+                   as_FloatRegister($src2$$reg), (int)$cond$$constant);\n@@ -3194,1 +2816,3 @@\n-instruct vmask_tolong(iRegLNoSp dst, pReg src, vReg vtmp1, vReg vtmp2, pRegGov pgtmp, rFlagsReg cr) %{\n+\/\/ vector load mask\n+\n+instruct vloadmaskB(pRegGov dst, vReg src, rFlagsReg cr) %{\n@@ -3196,5 +2820,5 @@\n-            n->in(1)->bottom_type()->is_vect()->length() <= 64);\n-  match(Set dst (VectorMaskToLong src));\n-  effect(TEMP vtmp1, TEMP vtmp2, TEMP pgtmp, KILL cr);\n-  ins_cost(13 * SVE_COST);\n-  format %{ \"vmask_tolong $dst, $src\\t# vector mask tolong (sve)\" %}\n+            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  match(Set dst (VectorLoadMask src));\n+  effect(KILL cr);\n+  ins_cost(SVE_COST);\n+  format %{ \"vloadmaskB $dst, $src\\t# vector load mask (sve) (B)\" %}\n@@ -3202,5 +2826,2 @@\n-    __ sve_vmask_tolong(as_Register($dst$$reg), as_PRegister($src$$reg),\n-                        Matcher::vector_element_basic_type(this, $src),\n-                        Matcher::vector_length(this, $src),\n-                        as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg),\n-                        as_PRegister($pgtmp$$reg));\n+    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ B,\n+               ptrue, as_FloatRegister($src$$reg), 0);\n@@ -3209,1 +2830,16 @@\n-%}dnl\n+%}\n+\n+instruct vloadmask_extend(pRegGov dst, vReg src, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() != T_BYTE);\n+  match(Set dst (VectorLoadMask src));\n+  effect(TEMP tmp, KILL cr);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"vloadmask $dst, $src\\t# vector load mask (sve) (H\/S\/D)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_vector_extend(as_FloatRegister($tmp$$reg), size, as_FloatRegister($src$$reg), __ B);\n+    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($tmp$$reg), 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n@@ -3211,1 +2847,0 @@\n-\/\/ ---------------------------- Vector mask generation ---------------------------\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":142,"deletions":507,"binary":false,"changes":649,"status":"modified"}]}