{"files":[{"patch":"@@ -59,0 +59,7 @@\n+    private static final int LOCATION_SST = 2;\n+\n+    public static final class SST extends CKeyStore {\n+        public SST() {\n+            super(\"SST\", LOCATION_SST);\n+        }\n+    }\n@@ -705,1 +712,1 @@\n-        if (stream != null && !keyStoreCompatibilityMode) {\n+        if (stream != null && !getRequiresKeyStoreFromStream() && !keyStoreCompatibilityMode) {\n@@ -708,0 +715,4 @@\n+        else if (stream == null && getRequiresKeyStoreFromStream())\n+        {\n+            throw new IOException(\"Keystore input stream cannot be null\");\n+        }\n@@ -728,2 +739,9 @@\n-            \/\/ Load keys and\/or certificate chains\n-            loadKeysOrCertificateChains(getName(), getLocation());\n+            if (stream != null && getRequiresKeyStoreFromStream()) {\n+                \/\/ Load keys and\/or certificate chains from input stream\n+                byte[] blob = stream.readAllBytes();\n+                loadKeysOrCertificateChainsFromMemory(blob, blob.length);\n+            }\n+            else {\n+                \/\/ Load keys and\/or certificate chains\n+                loadKeysOrCertificateChains(getName(), getLocation());\n+            }\n@@ -859,0 +877,7 @@\n+    \/**\n+     * Returns whether the keystore comes from a stream.\n+     *\/\n+    private boolean getRequiresKeyStoreFromStream() {\n+        return storeLocation == LOCATION_SST;\n+    }\n+\n@@ -868,0 +893,9 @@\n+    \/**\n+     * Load keys and\/or certificates from inmemory keystore into Collection.\n+     *\n+     * @param keystoreBlob In memory keystore.\n+     * @param keystoreBlobSize Size in bytes of in memory keystore\n+     *\/\n+    private native void loadKeysOrCertificateChainsFromMemory(byte[] keystoreBlob,\n+            int keystoreBlobSize) throws KeyStoreException;\n+\n","filename":"src\/jdk.crypto.mscapi\/windows\/classes\/sun\/security\/mscapi\/CKeyStore.java","additions":37,"deletions":3,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -102,0 +102,2 @@\n+                    } else if (algo.equals(\"Windows-SST\")) {\n+                        return new CKeyStore.SST();\n@@ -170,0 +172,9 @@\n+\n+                \/\/ experimental for now; especially as JCK expects all keystores to\n+                \/\/ load without a file, but the SST keystore MUST have a file\n+                String prop = System.getProperty(\"sun.security.mscapi.keyStoreSSTSupport\");\n+                if (\"true\".equals(prop)) {\n+                    putService(new ProviderService(p, \"KeyStore\",\n+                               \"Windows-SST\", \"sun.security.mscapi.CKeyStore$SST\"));\n+                }\n+\n","filename":"src\/jdk.crypto.mscapi\/windows\/classes\/sun\/security\/mscapi\/SunMSCAPI.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -412,2 +412,1 @@\n- * Method:    loadKeysOrCertificateChains\n- * Signature: (Ljava\/lang\/String;I)V\n+ * Method:    internal_loadKeysOrCertificateChains\n@@ -415,2 +414,2 @@\n-JNIEXPORT void JNICALL Java_sun_security_mscapi_CKeyStore_loadKeysOrCertificateChains\n-  (JNIEnv *env, jobject obj, jstring jCertStoreName, jint jCertStoreLocation)\n+void internal_loadKeysOrCertificateChains\n+  (JNIEnv *env, jobject obj, HCERTSTORE hCertStore)\n@@ -418,12 +417,0 @@\n-    \/**\n-     * Certificate in cert store has enhanced key usage extension\n-     * property (or EKU property) that is not part of the certificate itself. To determine\n-     * if the certificate should be returned, both the enhanced key usage in certificate\n-     * extension block and the extension property stored along with the certificate in\n-     * certificate store should be examined. Otherwise, we won't be able to determine\n-     * the proper key usage from the Java side because the information is not stored as\n-     * part of the encoded certificate.\n-     *\/\n-\n-    const char* pszCertStoreName = NULL;\n-    HCERTSTORE hCertStore = NULL;\n@@ -436,24 +423,0 @@\n-        \/\/ Open a system certificate store.\n-        if ((pszCertStoreName = env->GetStringUTFChars(jCertStoreName, NULL))\n-            == NULL) {\n-            __leave;\n-        }\n-\n-        if (jCertStoreLocation == KEYSTORE_LOCATION_CURRENTUSER) {\n-            hCertStore = ::CertOpenSystemStore(NULL, pszCertStoreName);\n-        }\n-        else if (jCertStoreLocation == KEYSTORE_LOCATION_LOCALMACHINE) {\n-            hCertStore = ::CertOpenStore(CERT_STORE_PROV_SYSTEM_A, 0, NULL,\n-                CERT_SYSTEM_STORE_LOCAL_MACHINE, pszCertStoreName);\n-        }\n-        else {\n-            PP(\"jCertStoreLocation is not a valid value\");\n-            __leave;\n-        }\n-\n-        if (hCertStore == NULL) {\n-\n-            ThrowException(env, KEYSTORE_EXCEPTION, GetLastError());\n-            __leave;\n-        }\n-\n@@ -730,0 +693,56 @@\n+    {\n+        if (pszNameString)\n+            delete [] pszNameString;\n+    }\n+}\n+\n+\/*\n+ * Class:     sun_security_mscapi_CKeyStore\n+ * Method:    loadKeysOrCertificateChains\n+ * Signature: (Ljava\/lang\/String;I)V\n+ *\/\n+JNIEXPORT void JNICALL Java_sun_security_mscapi_CKeyStore_loadKeysOrCertificateChains\n+  (JNIEnv *env, jobject obj, jstring jCertStoreName, jint jCertStoreLocation)\n+{\n+    \/**\n+     * Certificate in cert store has enhanced key usage extension\n+     * property (or EKU property) that is not part of the certificate itself. To determine\n+     * if the certificate should be returned, both the enhanced key usage in certificate\n+     * extension block and the extension property stored along with the certificate in\n+     * certificate store should be examined. Otherwise, we won't be able to determine\n+     * the proper key usage from the Java side because the information is not stored as\n+     * part of the encoded certificate.\n+     *\/\n+\n+    const char* pszCertStoreName = NULL;\n+    HCERTSTORE hCertStore = NULL;\n+\n+    __try\n+    {\n+        \/\/ Open a system certificate store.\n+        if ((pszCertStoreName = env->GetStringUTFChars(jCertStoreName, NULL))\n+            == NULL) {\n+            __leave;\n+        }\n+\n+        if (jCertStoreLocation == KEYSTORE_LOCATION_CURRENTUSER) {\n+            hCertStore = ::CertOpenSystemStore(NULL, pszCertStoreName);\n+        }\n+        else if (jCertStoreLocation == KEYSTORE_LOCATION_LOCALMACHINE) {\n+            hCertStore = ::CertOpenStore(CERT_STORE_PROV_SYSTEM_A, 0, NULL,\n+                CERT_SYSTEM_STORE_LOCAL_MACHINE, pszCertStoreName);\n+        }\n+        else {\n+            PP(\"jCertStoreLocation is not a valid value\");\n+            __leave;\n+        }\n+\n+        if (hCertStore == NULL) {\n+\n+            ThrowException(env, KEYSTORE_EXCEPTION, GetLastError());\n+            __leave;\n+        }\n+\n+        internal_loadKeysOrCertificateChains(env, obj, hCertStore);\n+    }\n+    __finally\n@@ -736,3 +755,0 @@\n-\n-        if (pszNameString)\n-            delete [] pszNameString;\n@@ -742,0 +758,44 @@\n+\/*\n+ * Class:     sun_security_mscapi_CKeyStore\n+ * Method:    loadKeysOrCertificateChainsFromMemory\n+ * Signature: ([BI)V\n+ *\/\n+JNIEXPORT void JNICALL Java_sun_security_mscapi_CKeyStore_loadKeysOrCertificateChainsFromMemory\n+  (JNIEnv *env, jobject obj, jbyteArray jKeyStoreBlob, jint cbKeyStoreBlob)\n+{\n+    HCERTSTORE hCertStore = NULL;\n+    jbyte* pBlobBuffer = NULL;\n+\n+    __try\n+    {\n+        \/\/ Copy SST blob from Java to native buffer\n+        pBlobBuffer = new (env) jbyte[cbKeyStoreBlob];\n+        if (pBlobBuffer == NULL) {\n+            __leave;\n+        }\n+        env->GetByteArrayRegion(jKeyStoreBlob, 0, cbKeyStoreBlob, pBlobBuffer);\n+\n+        CRYPT_DATA_BLOB blob;\n+        blob.cbData = cbKeyStoreBlob;\n+        blob.pbData = (BYTE*) pBlobBuffer;\n+\n+        hCertStore = ::CertOpenStore(CERT_STORE_PROV_SERIALIZED, 0, NULL,\n+            CERT_STORE_OPEN_EXISTING_FLAG | CERT_STORE_SHARE_CONTEXT_FLAG,\n+            &blob);\n+\n+        if (hCertStore == NULL) {\n+            ThrowException(env, KEYSTORE_EXCEPTION, GetLastError());\n+            __leave;\n+        }\n+\n+        internal_loadKeysOrCertificateChains(env, obj, hCertStore);\n+    }\n+    __finally\n+    {\n+        if (hCertStore)\n+            ::CertCloseStore(hCertStore, 0);\n+\n+        if (pBlobBuffer)\n+            delete [] pBlobBuffer;\n+    }\n+}\n","filename":"src\/jdk.crypto.mscapi\/windows\/native\/libsunmscapi\/security.cpp","additions":103,"deletions":43,"binary":false,"changes":146,"status":"modified"}]}