{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,2 @@\n-import static java.lang.Integer.reverseBytes;\n-import static java.lang.Long.reverseBytes;\n-\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n@@ -33,2 +32,0 @@\n-import jdk.internal.misc.Unsafe;\n-\n@@ -39,7 +36,0 @@\n- * Currently, it includes a default code path plus two optimized code paths.\n- * One is for little endian architectures that support full speed int\/long\n- * access at unaligned addresses (i.e. x86\/amd64). The second is for big endian\n- * architectures (that only support correctly aligned access), such as SPARC.\n- * These are the only platforms we currently support, but other optimized\n- * variants could be added as needed.\n- *\n@@ -62,19 +52,4 @@\n-    private static final Unsafe unsafe = Unsafe.getUnsafe();\n-\n-    \/\/ whether to use the optimized path for little endian platforms that\n-    \/\/ support full speed unaligned memory access.\n-    private static final boolean littleEndianUnaligned;\n-\n-    \/\/ whether to use the optimzied path for big endian platforms that\n-    \/\/ support only correctly aligned full speed memory access.\n-    \/\/ (Note that on SPARC unaligned memory access is possible, but it is\n-    \/\/ implemented using a software trap and therefore very slow)\n-    private static final boolean bigEndian;\n-\n-    private static final int byteArrayOfs = unsafe.arrayBaseOffset(byte[].class);\n-\n-    static {\n-        boolean scaleOK = ((unsafe.arrayIndexScale(byte[].class) == 1)\n-            && (unsafe.arrayIndexScale(int[].class) == 4)\n-            && (unsafe.arrayIndexScale(long[].class) == 8)\n-            && ((byteArrayOfs & 3) == 0));\n+    static final class LE {\n+        static final VarHandle INT_ARRAY\n+                = MethodHandles.byteArrayViewVarHandle(int[].class,\n+                ByteOrder.LITTLE_ENDIAN).withInvokeExactBehavior();\n@@ -82,5 +57,3 @@\n-        ByteOrder byteOrder = ByteOrder.nativeOrder();\n-        littleEndianUnaligned =\n-            scaleOK && unaligned() && (byteOrder == ByteOrder.LITTLE_ENDIAN);\n-        bigEndian =\n-            scaleOK && (byteOrder == ByteOrder.BIG_ENDIAN);\n+        static final VarHandle LONG_ARRAY\n+                = MethodHandles.byteArrayViewVarHandle(long[].class,\n+                ByteOrder.LITTLE_ENDIAN).withInvokeExactBehavior();\n@@ -89,4 +62,8 @@\n-    \/\/ Return whether this platform supports full speed int\/long memory access\n-    \/\/ at unaligned addresses.\n-    private static boolean unaligned() {\n-        return unsafe.unalignedAccess();\n+    static final class BE {\n+        static final VarHandle INT_ARRAY\n+                = MethodHandles.byteArrayViewVarHandle(int[].class,\n+                ByteOrder.BIG_ENDIAN).withInvokeExactBehavior();\n+\n+        static final VarHandle LONG_ARRAY\n+                = MethodHandles.byteArrayViewVarHandle(long[].class,\n+                ByteOrder.BIG_ENDIAN).withInvokeExactBehavior();\n@@ -99,27 +76,4 @@\n-        if ((inOfs < 0) || ((in.length - inOfs) < len) ||\n-            (outOfs < 0) || ((out.length - outOfs) < len\/4)) {\n-            throw new ArrayIndexOutOfBoundsException();\n-        }\n-        if (littleEndianUnaligned) {\n-            inOfs += byteArrayOfs;\n-            len += inOfs;\n-            while (inOfs < len) {\n-                out[outOfs++] = unsafe.getInt(in, (long)inOfs);\n-                inOfs += 4;\n-            }\n-        } else if (bigEndian && ((inOfs & 3) == 0)) {\n-            inOfs += byteArrayOfs;\n-            len += inOfs;\n-            while (inOfs < len) {\n-                out[outOfs++] = reverseBytes(unsafe.getInt(in, (long)inOfs));\n-                inOfs += 4;\n-            }\n-        } else {\n-            len += inOfs;\n-            while (inOfs < len) {\n-                out[outOfs++] = ((in[inOfs    ] & 0xff)      )\n-                              | ((in[inOfs + 1] & 0xff) <<  8)\n-                              | ((in[inOfs + 2] & 0xff) << 16)\n-                              | ((in[inOfs + 3]       ) << 24);\n-                inOfs += 4;\n-            }\n+        len += inOfs;\n+        while (inOfs < len) {\n+            out[outOfs++] = (int) LE.INT_ARRAY.get(in, inOfs);\n+            inOfs += 4;\n@@ -131,43 +85,1 @@\n-        if ((inOfs < 0) || ((in.length - inOfs) < 64) ||\n-            (out.length < 16)) {\n-            throw new ArrayIndexOutOfBoundsException();\n-        }\n-        if (littleEndianUnaligned) {\n-            inOfs += byteArrayOfs;\n-            out[ 0] = unsafe.getInt(in, (long)(inOfs     ));\n-            out[ 1] = unsafe.getInt(in, (long)(inOfs +  4));\n-            out[ 2] = unsafe.getInt(in, (long)(inOfs +  8));\n-            out[ 3] = unsafe.getInt(in, (long)(inOfs + 12));\n-            out[ 4] = unsafe.getInt(in, (long)(inOfs + 16));\n-            out[ 5] = unsafe.getInt(in, (long)(inOfs + 20));\n-            out[ 6] = unsafe.getInt(in, (long)(inOfs + 24));\n-            out[ 7] = unsafe.getInt(in, (long)(inOfs + 28));\n-            out[ 8] = unsafe.getInt(in, (long)(inOfs + 32));\n-            out[ 9] = unsafe.getInt(in, (long)(inOfs + 36));\n-            out[10] = unsafe.getInt(in, (long)(inOfs + 40));\n-            out[11] = unsafe.getInt(in, (long)(inOfs + 44));\n-            out[12] = unsafe.getInt(in, (long)(inOfs + 48));\n-            out[13] = unsafe.getInt(in, (long)(inOfs + 52));\n-            out[14] = unsafe.getInt(in, (long)(inOfs + 56));\n-            out[15] = unsafe.getInt(in, (long)(inOfs + 60));\n-        } else if (bigEndian && ((inOfs & 3) == 0)) {\n-            inOfs += byteArrayOfs;\n-            out[ 0] = reverseBytes(unsafe.getInt(in, (long)(inOfs     )));\n-            out[ 1] = reverseBytes(unsafe.getInt(in, (long)(inOfs +  4)));\n-            out[ 2] = reverseBytes(unsafe.getInt(in, (long)(inOfs +  8)));\n-            out[ 3] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 12)));\n-            out[ 4] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 16)));\n-            out[ 5] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 20)));\n-            out[ 6] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 24)));\n-            out[ 7] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 28)));\n-            out[ 8] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 32)));\n-            out[ 9] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 36)));\n-            out[10] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 40)));\n-            out[11] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 44)));\n-            out[12] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 48)));\n-            out[13] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 52)));\n-            out[14] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 56)));\n-            out[15] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 60)));\n-        } else {\n-            b2iLittle(in, inOfs, out, 0, 64);\n-        }\n+        b2iLittle(in, inOfs, out, 0, 64);\n@@ -180,27 +92,4 @@\n-        if ((inOfs < 0) || ((in.length - inOfs) < len\/4) ||\n-            (outOfs < 0) || ((out.length - outOfs) < len)) {\n-            throw new ArrayIndexOutOfBoundsException();\n-        }\n-        if (littleEndianUnaligned) {\n-            outOfs += byteArrayOfs;\n-            len += outOfs;\n-            while (outOfs < len) {\n-                unsafe.putInt(out, (long)outOfs, in[inOfs++]);\n-                outOfs += 4;\n-            }\n-        } else if (bigEndian && ((outOfs & 3) == 0)) {\n-            outOfs += byteArrayOfs;\n-            len += outOfs;\n-            while (outOfs < len) {\n-                unsafe.putInt(out, (long)outOfs, reverseBytes(in[inOfs++]));\n-                outOfs += 4;\n-            }\n-        } else {\n-            len += outOfs;\n-            while (outOfs < len) {\n-                int i = in[inOfs++];\n-                out[outOfs++] = (byte)(i      );\n-                out[outOfs++] = (byte)(i >>  8);\n-                out[outOfs++] = (byte)(i >> 16);\n-                out[outOfs++] = (byte)(i >> 24);\n-            }\n+        len += outOfs;\n+        while (outOfs < len) {\n+            LE.INT_ARRAY.set(out, outOfs, in[inOfs++]);\n+            outOfs += 4;\n@@ -212,13 +101,1 @@\n-        if ((outOfs < 0) || ((out.length - outOfs) < 4)) {\n-            throw new ArrayIndexOutOfBoundsException();\n-        }\n-        if (littleEndianUnaligned) {\n-            unsafe.putInt(out, (long)(byteArrayOfs + outOfs), val);\n-        } else if (bigEndian && ((outOfs & 3) == 0)) {\n-            unsafe.putInt(out, (long)(byteArrayOfs + outOfs), reverseBytes(val));\n-        } else {\n-            out[outOfs    ] = (byte)(val      );\n-            out[outOfs + 1] = (byte)(val >>  8);\n-            out[outOfs + 2] = (byte)(val >> 16);\n-            out[outOfs + 3] = (byte)(val >> 24);\n-        }\n+        LE.INT_ARRAY.set(out, outOfs, val);\n@@ -231,27 +108,4 @@\n-        if ((inOfs < 0) || ((in.length - inOfs) < len) ||\n-            (outOfs < 0) || ((out.length - outOfs) < len\/4)) {\n-            throw new ArrayIndexOutOfBoundsException();\n-        }\n-        if (littleEndianUnaligned) {\n-            inOfs += byteArrayOfs;\n-            len += inOfs;\n-            while (inOfs < len) {\n-                out[outOfs++] = reverseBytes(unsafe.getInt(in, (long)inOfs));\n-                inOfs += 4;\n-            }\n-        } else if (bigEndian && ((inOfs & 3) == 0)) {\n-            inOfs += byteArrayOfs;\n-            len += inOfs;\n-            while (inOfs < len) {\n-                out[outOfs++] = unsafe.getInt(in, (long)inOfs);\n-                inOfs += 4;\n-            }\n-        } else {\n-            len += inOfs;\n-            while (inOfs < len) {\n-                out[outOfs++] = ((in[inOfs + 3] & 0xff)      )\n-                              | ((in[inOfs + 2] & 0xff) <<  8)\n-                              | ((in[inOfs + 1] & 0xff) << 16)\n-                              | ((in[inOfs    ]       ) << 24);\n-                inOfs += 4;\n-            }\n+        len += inOfs;\n+        while (inOfs < len) {\n+            out[outOfs++] = (int) BE.INT_ARRAY.get(in, inOfs);\n+            inOfs += 4;\n@@ -263,43 +117,16 @@\n-        if ((inOfs < 0) || ((in.length - inOfs) < 64) ||\n-            (out.length < 16)) {\n-            throw new ArrayIndexOutOfBoundsException();\n-        }\n-        if (littleEndianUnaligned) {\n-            inOfs += byteArrayOfs;\n-            out[ 0] = reverseBytes(unsafe.getInt(in, (long)(inOfs     )));\n-            out[ 1] = reverseBytes(unsafe.getInt(in, (long)(inOfs +  4)));\n-            out[ 2] = reverseBytes(unsafe.getInt(in, (long)(inOfs +  8)));\n-            out[ 3] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 12)));\n-            out[ 4] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 16)));\n-            out[ 5] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 20)));\n-            out[ 6] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 24)));\n-            out[ 7] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 28)));\n-            out[ 8] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 32)));\n-            out[ 9] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 36)));\n-            out[10] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 40)));\n-            out[11] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 44)));\n-            out[12] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 48)));\n-            out[13] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 52)));\n-            out[14] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 56)));\n-            out[15] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 60)));\n-        } else if (bigEndian && ((inOfs & 3) == 0)) {\n-            inOfs += byteArrayOfs;\n-            out[ 0] = unsafe.getInt(in, (long)(inOfs     ));\n-            out[ 1] = unsafe.getInt(in, (long)(inOfs +  4));\n-            out[ 2] = unsafe.getInt(in, (long)(inOfs +  8));\n-            out[ 3] = unsafe.getInt(in, (long)(inOfs + 12));\n-            out[ 4] = unsafe.getInt(in, (long)(inOfs + 16));\n-            out[ 5] = unsafe.getInt(in, (long)(inOfs + 20));\n-            out[ 6] = unsafe.getInt(in, (long)(inOfs + 24));\n-            out[ 7] = unsafe.getInt(in, (long)(inOfs + 28));\n-            out[ 8] = unsafe.getInt(in, (long)(inOfs + 32));\n-            out[ 9] = unsafe.getInt(in, (long)(inOfs + 36));\n-            out[10] = unsafe.getInt(in, (long)(inOfs + 40));\n-            out[11] = unsafe.getInt(in, (long)(inOfs + 44));\n-            out[12] = unsafe.getInt(in, (long)(inOfs + 48));\n-            out[13] = unsafe.getInt(in, (long)(inOfs + 52));\n-            out[14] = unsafe.getInt(in, (long)(inOfs + 56));\n-            out[15] = unsafe.getInt(in, (long)(inOfs + 60));\n-        } else {\n-            b2iBig(in, inOfs, out, 0, 64);\n-        }\n+        out[ 0] = (int) BE.INT_ARRAY.get(in, inOfs     );\n+        out[ 1] = (int) BE.INT_ARRAY.get(in, inOfs +  4);\n+        out[ 2] = (int) BE.INT_ARRAY.get(in, inOfs +  8);\n+        out[ 3] = (int) BE.INT_ARRAY.get(in, inOfs + 12);\n+        out[ 4] = (int) BE.INT_ARRAY.get(in, inOfs + 16);\n+        out[ 5] = (int) BE.INT_ARRAY.get(in, inOfs + 20);\n+        out[ 6] = (int) BE.INT_ARRAY.get(in, inOfs + 24);\n+        out[ 7] = (int) BE.INT_ARRAY.get(in, inOfs + 28);\n+        out[ 8] = (int) BE.INT_ARRAY.get(in, inOfs + 32);\n+        out[ 9] = (int) BE.INT_ARRAY.get(in, inOfs + 36);\n+        out[10] = (int) BE.INT_ARRAY.get(in, inOfs + 40);\n+        out[11] = (int) BE.INT_ARRAY.get(in, inOfs + 44);\n+        out[12] = (int) BE.INT_ARRAY.get(in, inOfs + 48);\n+        out[13] = (int) BE.INT_ARRAY.get(in, inOfs + 52);\n+        out[14] = (int) BE.INT_ARRAY.get(in, inOfs + 56);\n+        out[15] = (int) BE.INT_ARRAY.get(in, inOfs + 60);\n@@ -312,27 +139,4 @@\n-        if ((inOfs < 0) || ((in.length - inOfs) < len\/4) ||\n-            (outOfs < 0) || ((out.length - outOfs) < len)) {\n-            throw new ArrayIndexOutOfBoundsException();\n-        }\n-        if (littleEndianUnaligned) {\n-            outOfs += byteArrayOfs;\n-            len += outOfs;\n-            while (outOfs < len) {\n-                unsafe.putInt(out, (long)outOfs, reverseBytes(in[inOfs++]));\n-                outOfs += 4;\n-            }\n-        } else if (bigEndian && ((outOfs & 3) == 0)) {\n-            outOfs += byteArrayOfs;\n-            len += outOfs;\n-            while (outOfs < len) {\n-                unsafe.putInt(out, (long)outOfs, in[inOfs++]);\n-                outOfs += 4;\n-            }\n-        } else {\n-            len += outOfs;\n-            while (outOfs < len) {\n-                int i = in[inOfs++];\n-                out[outOfs++] = (byte)(i >> 24);\n-                out[outOfs++] = (byte)(i >> 16);\n-                out[outOfs++] = (byte)(i >>  8);\n-                out[outOfs++] = (byte)(i      );\n-            }\n+        len += outOfs;\n+        while (outOfs < len) {\n+            BE.INT_ARRAY.set(out, outOfs, in[inOfs++]);\n+            outOfs += 4;\n@@ -344,13 +148,1 @@\n-        if ((outOfs < 0) || ((out.length - outOfs) < 4)) {\n-            throw new ArrayIndexOutOfBoundsException();\n-        }\n-        if (littleEndianUnaligned) {\n-            unsafe.putInt(out, (long)(byteArrayOfs + outOfs), reverseBytes(val));\n-        } else if (bigEndian && ((outOfs & 3) == 0)) {\n-            unsafe.putInt(out, (long)(byteArrayOfs + outOfs), val);\n-        } else {\n-            out[outOfs    ] = (byte)(val >> 24);\n-            out[outOfs + 1] = (byte)(val >> 16);\n-            out[outOfs + 2] = (byte)(val >>  8);\n-            out[outOfs + 3] = (byte)(val      );\n-        }\n+        BE.INT_ARRAY.set(out, outOfs, val);\n@@ -363,40 +155,4 @@\n-        if ((inOfs < 0) || ((in.length - inOfs) < len) ||\n-            (outOfs < 0) || ((out.length - outOfs) < len\/8)) {\n-            throw new ArrayIndexOutOfBoundsException();\n-        }\n-        if (littleEndianUnaligned) {\n-            inOfs += byteArrayOfs;\n-            len += inOfs;\n-            while (inOfs < len) {\n-                out[outOfs++] = reverseBytes(unsafe.getLong(in, (long)inOfs));\n-                inOfs += 8;\n-            }\n-        } else if (bigEndian && ((inOfs & 3) == 0)) {\n-            \/\/ In the current HotSpot memory layout, the first element of a\n-            \/\/ byte[] is only 32-bit aligned, not 64-bit.\n-            \/\/ That means we could use getLong() only for offset 4, 12, etc.,\n-            \/\/ which would rarely occur in practice. Instead, we use an\n-            \/\/ optimization that uses getInt() so that it works for offset 0.\n-            inOfs += byteArrayOfs;\n-            len += inOfs;\n-            while (inOfs < len) {\n-                out[outOfs++] =\n-                      ((long)unsafe.getInt(in, (long)inOfs) << 32)\n-                          | (unsafe.getInt(in, (long)(inOfs + 4)) & 0xffffffffL);\n-                inOfs += 8;\n-            }\n-        } else {\n-            len += inOfs;\n-            while (inOfs < len) {\n-                int i1 = ((in[inOfs + 3] & 0xff)      )\n-                       | ((in[inOfs + 2] & 0xff) <<  8)\n-                       | ((in[inOfs + 1] & 0xff) << 16)\n-                       | ((in[inOfs    ]       ) << 24);\n-                inOfs += 4;\n-                int i2 = ((in[inOfs + 3] & 0xff)      )\n-                       | ((in[inOfs + 2] & 0xff) <<  8)\n-                       | ((in[inOfs + 1] & 0xff) << 16)\n-                       | ((in[inOfs    ]       ) << 24);\n-                out[outOfs++] = ((long)i1 << 32) | (i2 & 0xffffffffL);\n-                inOfs += 4;\n-            }\n+        len += inOfs;\n+        while (inOfs < len) {\n+            out[outOfs++] = (long) BE.LONG_ARRAY.get(in, inOfs);\n+            inOfs += 8;\n@@ -408,26 +164,16 @@\n-        if ((inOfs < 0) || ((in.length - inOfs) < 128) ||\n-            (out.length < 16)) {\n-            throw new ArrayIndexOutOfBoundsException();\n-        }\n-        if (littleEndianUnaligned) {\n-            inOfs += byteArrayOfs;\n-            out[ 0] = reverseBytes(unsafe.getLong(in, (long)(inOfs      )));\n-            out[ 1] = reverseBytes(unsafe.getLong(in, (long)(inOfs +   8)));\n-            out[ 2] = reverseBytes(unsafe.getLong(in, (long)(inOfs +  16)));\n-            out[ 3] = reverseBytes(unsafe.getLong(in, (long)(inOfs +  24)));\n-            out[ 4] = reverseBytes(unsafe.getLong(in, (long)(inOfs +  32)));\n-            out[ 5] = reverseBytes(unsafe.getLong(in, (long)(inOfs +  40)));\n-            out[ 6] = reverseBytes(unsafe.getLong(in, (long)(inOfs +  48)));\n-            out[ 7] = reverseBytes(unsafe.getLong(in, (long)(inOfs +  56)));\n-            out[ 8] = reverseBytes(unsafe.getLong(in, (long)(inOfs +  64)));\n-            out[ 9] = reverseBytes(unsafe.getLong(in, (long)(inOfs +  72)));\n-            out[10] = reverseBytes(unsafe.getLong(in, (long)(inOfs +  80)));\n-            out[11] = reverseBytes(unsafe.getLong(in, (long)(inOfs +  88)));\n-            out[12] = reverseBytes(unsafe.getLong(in, (long)(inOfs +  96)));\n-            out[13] = reverseBytes(unsafe.getLong(in, (long)(inOfs + 104)));\n-            out[14] = reverseBytes(unsafe.getLong(in, (long)(inOfs + 112)));\n-            out[15] = reverseBytes(unsafe.getLong(in, (long)(inOfs + 120)));\n-        } else {\n-            \/\/ no optimization for big endian, see comments in b2lBig\n-            b2lBig(in, inOfs, out, 0, 128);\n-        }\n+        out[ 0] = (long) BE.LONG_ARRAY.get(in, inOfs      );\n+        out[ 1] = (long) BE.LONG_ARRAY.get(in, inOfs +   8);\n+        out[ 2] = (long) BE.LONG_ARRAY.get(in, inOfs +  16);\n+        out[ 3] = (long) BE.LONG_ARRAY.get(in, inOfs +  24);\n+        out[ 4] = (long) BE.LONG_ARRAY.get(in, inOfs +  32);\n+        out[ 5] = (long) BE.LONG_ARRAY.get(in, inOfs +  40);\n+        out[ 6] = (long) BE.LONG_ARRAY.get(in, inOfs +  48);\n+        out[ 7] = (long) BE.LONG_ARRAY.get(in, inOfs +  56);\n+        out[ 8] = (long) BE.LONG_ARRAY.get(in, inOfs +  64);\n+        out[ 9] = (long) BE.LONG_ARRAY.get(in, inOfs +  72);\n+        out[10] = (long) BE.LONG_ARRAY.get(in, inOfs +  80);\n+        out[11] = (long) BE.LONG_ARRAY.get(in, inOfs +  88);\n+        out[12] = (long) BE.LONG_ARRAY.get(in, inOfs +  96);\n+        out[13] = (long) BE.LONG_ARRAY.get(in, inOfs + 104);\n+        out[14] = (long) BE.LONG_ARRAY.get(in, inOfs + 112);\n+        out[15] = (long) BE.LONG_ARRAY.get(in, inOfs + 120);\n@@ -440,24 +186,4 @@\n-        if ((inOfs < 0) || ((in.length - inOfs) < len\/8) ||\n-            (outOfs < 0) || ((out.length - outOfs) < len)) {\n-            throw new ArrayIndexOutOfBoundsException();\n-        }\n-        if (littleEndianUnaligned) {\n-            outOfs += byteArrayOfs;\n-            len += outOfs;\n-            while (outOfs < len) {\n-                unsafe.putLong(out, (long)outOfs, reverseBytes(in[inOfs++]));\n-                outOfs += 8;\n-            }\n-        } else {\n-            len += outOfs;\n-            while (outOfs < len) {\n-                long i = in[inOfs++];\n-                out[outOfs++] = (byte)(i >> 56);\n-                out[outOfs++] = (byte)(i >> 48);\n-                out[outOfs++] = (byte)(i >> 40);\n-                out[outOfs++] = (byte)(i >> 32);\n-                out[outOfs++] = (byte)(i >> 24);\n-                out[outOfs++] = (byte)(i >> 16);\n-                out[outOfs++] = (byte)(i >>  8);\n-                out[outOfs++] = (byte)(i      );\n-            }\n+        len += outOfs;\n+        while (outOfs < len) {\n+            BE.LONG_ARRAY.set(out, outOfs, in[inOfs++]);\n+            outOfs += 8;\n@@ -471,24 +197,4 @@\n-        if ((inOfs < 0) || ((in.length - inOfs) < len) ||\n-            ((outOfs < 0) || (out.length - outOfs) < len\/8)) {\n-            throw new ArrayIndexOutOfBoundsException();\n-        }\n-        if (littleEndianUnaligned) {\n-            inOfs += byteArrayOfs;\n-            len += inOfs;\n-            while (inOfs < len) {\n-                out[outOfs++] = unsafe.getLong(in, (long)inOfs);\n-                inOfs += 8;\n-            }\n-       } else {\n-            len += inOfs;\n-            while (inOfs < len) {\n-                out[outOfs++] = ((in[inOfs    ] & 0xffL)\n-                   | ((in[inOfs + 1] & 0xffL) <<  8)\n-                   | ((in[inOfs + 2] & 0xffL) << 16)\n-                   | ((in[inOfs + 3] & 0xffL) << 24)\n-                   | ((in[inOfs + 4] & 0xffL) << 32)\n-                   | ((in[inOfs + 5] & 0xffL) << 40)\n-                   | ((in[inOfs + 6] & 0xffL) << 48)\n-                   | ((in[inOfs + 7] & 0xffL) << 56));\n-                inOfs += 8;\n-            }\n+        len += inOfs;\n+        while (inOfs < len) {\n+            out[outOfs++] = (long) LE.LONG_ARRAY.get(in, inOfs);\n+            inOfs += 8;\n@@ -503,24 +209,4 @@\n-        if ((inOfs < 0) || ((in.length - inOfs) < len\/8) ||\n-            (outOfs < 0) || ((out.length - outOfs) < len)) {\n-            throw new ArrayIndexOutOfBoundsException();\n-        }\n-        if (littleEndianUnaligned) {\n-            outOfs += byteArrayOfs;\n-            len += outOfs;\n-            while (outOfs < len) {\n-                unsafe.putLong(out, (long)outOfs, in[inOfs++]);\n-                outOfs += 8;\n-            }\n-        } else {\n-            len += outOfs;\n-            while (outOfs < len) {\n-                long i = in[inOfs++];\n-                out[outOfs++] = (byte)(i      );\n-                out[outOfs++] = (byte)(i >>  8);\n-                out[outOfs++] = (byte)(i >> 16);\n-                out[outOfs++] = (byte)(i >> 24);\n-                out[outOfs++] = (byte)(i >> 32);\n-                out[outOfs++] = (byte)(i >> 40);\n-                out[outOfs++] = (byte)(i >> 48);\n-                out[outOfs++] = (byte)(i >> 56);\n-            }\n+        len += outOfs;\n+        while (outOfs < len) {\n+            LE.LONG_ARRAY.set(out, outOfs, in[inOfs++]);\n+            outOfs += 8;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/ByteArrayAccess.java","additions":85,"deletions":399,"binary":false,"changes":484,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,2 +50,0 @@\n-    \/\/ temporary buffer, used by implCompress()\n-    private int[] x;\n@@ -96,1 +94,0 @@\n-        x = new int[16];\n@@ -104,1 +101,0 @@\n-        copy.x = new int[16];\n@@ -114,2 +110,0 @@\n-        \/\/ clear out old data\n-        Arrays.fill(x, 0);\n@@ -165,1 +159,16 @@\n-        b2iLittle64(buf, ofs, x);\n+        int x0 = (int) LE.INT_ARRAY.get(buf, ofs);\n+        int x1 = (int) LE.INT_ARRAY.get(buf, ofs + 4);\n+        int x2 = (int) LE.INT_ARRAY.get(buf, ofs + 8);\n+        int x3 = (int) LE.INT_ARRAY.get(buf, ofs + 12);\n+        int x4 = (int) LE.INT_ARRAY.get(buf, ofs + 16);\n+        int x5 = (int) LE.INT_ARRAY.get(buf, ofs + 20);\n+        int x6 = (int) LE.INT_ARRAY.get(buf, ofs + 24);\n+        int x7 = (int) LE.INT_ARRAY.get(buf, ofs + 28);\n+        int x8 = (int) LE.INT_ARRAY.get(buf, ofs + 32);\n+        int x9 = (int) LE.INT_ARRAY.get(buf, ofs + 36);\n+        int x10 = (int) LE.INT_ARRAY.get(buf, ofs + 40);\n+        int x11 = (int) LE.INT_ARRAY.get(buf, ofs + 44);\n+        int x12 = (int) LE.INT_ARRAY.get(buf, ofs + 48);\n+        int x13 = (int) LE.INT_ARRAY.get(buf, ofs + 52);\n+        int x14 = (int) LE.INT_ARRAY.get(buf, ofs + 56);\n+        int x15 = (int) LE.INT_ARRAY.get(buf, ofs + 60);\n@@ -173,16 +182,16 @@\n-        a = FF (a, b, c, d, x[ 0], S11); \/* 1 *\/\n-        d = FF (d, a, b, c, x[ 1], S12); \/* 2 *\/\n-        c = FF (c, d, a, b, x[ 2], S13); \/* 3 *\/\n-        b = FF (b, c, d, a, x[ 3], S14); \/* 4 *\/\n-        a = FF (a, b, c, d, x[ 4], S11); \/* 5 *\/\n-        d = FF (d, a, b, c, x[ 5], S12); \/* 6 *\/\n-        c = FF (c, d, a, b, x[ 6], S13); \/* 7 *\/\n-        b = FF (b, c, d, a, x[ 7], S14); \/* 8 *\/\n-        a = FF (a, b, c, d, x[ 8], S11); \/* 9 *\/\n-        d = FF (d, a, b, c, x[ 9], S12); \/* 10 *\/\n-        c = FF (c, d, a, b, x[10], S13); \/* 11 *\/\n-        b = FF (b, c, d, a, x[11], S14); \/* 12 *\/\n-        a = FF (a, b, c, d, x[12], S11); \/* 13 *\/\n-        d = FF (d, a, b, c, x[13], S12); \/* 14 *\/\n-        c = FF (c, d, a, b, x[14], S13); \/* 15 *\/\n-        b = FF (b, c, d, a, x[15], S14); \/* 16 *\/\n+        a = FF (a, b, c, d, x0,  S11); \/* 1 *\/\n+        d = FF (d, a, b, c, x1,  S12); \/* 2 *\/\n+        c = FF (c, d, a, b, x2,  S13); \/* 3 *\/\n+        b = FF (b, c, d, a, x3,  S14); \/* 4 *\/\n+        a = FF (a, b, c, d, x4,  S11); \/* 5 *\/\n+        d = FF (d, a, b, c, x5,  S12); \/* 6 *\/\n+        c = FF (c, d, a, b, x6,  S13); \/* 7 *\/\n+        b = FF (b, c, d, a, x7,  S14); \/* 8 *\/\n+        a = FF (a, b, c, d, x8,  S11); \/* 9 *\/\n+        d = FF (d, a, b, c, x9,  S12); \/* 10 *\/\n+        c = FF (c, d, a, b, x10, S13); \/* 11 *\/\n+        b = FF (b, c, d, a, x11, S14); \/* 12 *\/\n+        a = FF (a, b, c, d, x12, S11); \/* 13 *\/\n+        d = FF (d, a, b, c, x13, S12); \/* 14 *\/\n+        c = FF (c, d, a, b, x14, S13); \/* 15 *\/\n+        b = FF (b, c, d, a, x15, S14); \/* 16 *\/\n@@ -191,16 +200,16 @@\n-        a = GG (a, b, c, d, x[ 0], S21); \/* 17 *\/\n-        d = GG (d, a, b, c, x[ 4], S22); \/* 18 *\/\n-        c = GG (c, d, a, b, x[ 8], S23); \/* 19 *\/\n-        b = GG (b, c, d, a, x[12], S24); \/* 20 *\/\n-        a = GG (a, b, c, d, x[ 1], S21); \/* 21 *\/\n-        d = GG (d, a, b, c, x[ 5], S22); \/* 22 *\/\n-        c = GG (c, d, a, b, x[ 9], S23); \/* 23 *\/\n-        b = GG (b, c, d, a, x[13], S24); \/* 24 *\/\n-        a = GG (a, b, c, d, x[ 2], S21); \/* 25 *\/\n-        d = GG (d, a, b, c, x[ 6], S22); \/* 26 *\/\n-        c = GG (c, d, a, b, x[10], S23); \/* 27 *\/\n-        b = GG (b, c, d, a, x[14], S24); \/* 28 *\/\n-        a = GG (a, b, c, d, x[ 3], S21); \/* 29 *\/\n-        d = GG (d, a, b, c, x[ 7], S22); \/* 30 *\/\n-        c = GG (c, d, a, b, x[11], S23); \/* 31 *\/\n-        b = GG (b, c, d, a, x[15], S24); \/* 32 *\/\n+        a = GG (a, b, c, d, x0,  S21); \/* 17 *\/\n+        d = GG (d, a, b, c, x4,  S22); \/* 18 *\/\n+        c = GG (c, d, a, b, x8,  S23); \/* 19 *\/\n+        b = GG (b, c, d, a, x12, S24); \/* 20 *\/\n+        a = GG (a, b, c, d, x1,  S21); \/* 21 *\/\n+        d = GG (d, a, b, c, x5,  S22); \/* 22 *\/\n+        c = GG (c, d, a, b, x9,  S23); \/* 23 *\/\n+        b = GG (b, c, d, a, x13, S24); \/* 24 *\/\n+        a = GG (a, b, c, d, x2,  S21); \/* 25 *\/\n+        d = GG (d, a, b, c, x6,  S22); \/* 26 *\/\n+        c = GG (c, d, a, b, x10, S23); \/* 27 *\/\n+        b = GG (b, c, d, a, x14, S24); \/* 28 *\/\n+        a = GG (a, b, c, d, x3,  S21); \/* 29 *\/\n+        d = GG (d, a, b, c, x7,  S22); \/* 30 *\/\n+        c = GG (c, d, a, b, x11, S23); \/* 31 *\/\n+        b = GG (b, c, d, a, x15, S24); \/* 32 *\/\n@@ -209,16 +218,16 @@\n-        a = HH (a, b, c, d, x[ 0], S31); \/* 33 *\/\n-        d = HH (d, a, b, c, x[ 8], S32); \/* 34 *\/\n-        c = HH (c, d, a, b, x[ 4], S33); \/* 35 *\/\n-        b = HH (b, c, d, a, x[12], S34); \/* 36 *\/\n-        a = HH (a, b, c, d, x[ 2], S31); \/* 37 *\/\n-        d = HH (d, a, b, c, x[10], S32); \/* 38 *\/\n-        c = HH (c, d, a, b, x[ 6], S33); \/* 39 *\/\n-        b = HH (b, c, d, a, x[14], S34); \/* 40 *\/\n-        a = HH (a, b, c, d, x[ 1], S31); \/* 41 *\/\n-        d = HH (d, a, b, c, x[ 9], S32); \/* 42 *\/\n-        c = HH (c, d, a, b, x[ 5], S33); \/* 43 *\/\n-        b = HH (b, c, d, a, x[13], S34); \/* 44 *\/\n-        a = HH (a, b, c, d, x[ 3], S31); \/* 45 *\/\n-        d = HH (d, a, b, c, x[11], S32); \/* 46 *\/\n-        c = HH (c, d, a, b, x[ 7], S33); \/* 47 *\/\n-        b = HH (b, c, d, a, x[15], S34); \/* 48 *\/\n+        a = HH (a, b, c, d, x0,  S31); \/* 33 *\/\n+        d = HH (d, a, b, c, x8,  S32); \/* 34 *\/\n+        c = HH (c, d, a, b, x4,  S33); \/* 35 *\/\n+        b = HH (b, c, d, a, x12, S34); \/* 36 *\/\n+        a = HH (a, b, c, d, x2,  S31); \/* 37 *\/\n+        d = HH (d, a, b, c, x10, S32); \/* 38 *\/\n+        c = HH (c, d, a, b, x6,  S33); \/* 39 *\/\n+        b = HH (b, c, d, a, x14, S34); \/* 40 *\/\n+        a = HH (a, b, c, d, x1,  S31); \/* 41 *\/\n+        d = HH (d, a, b, c, x9,  S32); \/* 42 *\/\n+        c = HH (c, d, a, b, x5,  S33); \/* 43 *\/\n+        b = HH (b, c, d, a, x13, S34); \/* 44 *\/\n+        a = HH (a, b, c, d, x3,  S31); \/* 45 *\/\n+        d = HH (d, a, b, c, x11, S32); \/* 46 *\/\n+        c = HH (c, d, a, b, x7,  S33); \/* 47 *\/\n+        b = HH (b, c, d, a, x15, S34); \/* 48 *\/\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/MD4.java","additions":65,"deletions":56,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n@@ -47,2 +50,0 @@\n-    \/\/ temporary buffer, used by implCompress()\n-    private int[] x;\n@@ -72,2 +73,1 @@\n-        x = new int[16];\n-        resetHashes();\n+        implReset();\n@@ -80,1 +80,0 @@\n-        copy.x = new int[16];\n@@ -89,6 +88,0 @@\n-        resetHashes();\n-        \/\/ clear out old data\n-        Arrays.fill(x, 0);\n-    }\n-\n-    private void resetHashes() {\n@@ -159,2 +152,1 @@\n-        \/\/ The checks performed by the method 'b2iBig64'\n-        \/\/ are sufficient for the case when the method\n+        \/\/ These checks are sufficient for the case when the method\n@@ -163,1 +155,3 @@\n-        b2iLittle64(buf, ofs, x);\n+        if ((ofs < 0) || ((buf.length - ofs) < 64)) {\n+            throw new ArrayIndexOutOfBoundsException();\n+        }\n@@ -178,0 +172,17 @@\n+        int x0 = (int) LE.INT_ARRAY.get(buf, ofs);\n+        int x1 = (int) LE.INT_ARRAY.get(buf, ofs + 4);\n+        int x2 = (int) LE.INT_ARRAY.get(buf, ofs + 8);\n+        int x3 = (int) LE.INT_ARRAY.get(buf, ofs + 12);\n+        int x4 = (int) LE.INT_ARRAY.get(buf, ofs + 16);\n+        int x5 = (int) LE.INT_ARRAY.get(buf, ofs + 20);\n+        int x6 = (int) LE.INT_ARRAY.get(buf, ofs + 24);\n+        int x7 = (int) LE.INT_ARRAY.get(buf, ofs + 28);\n+        int x8 = (int) LE.INT_ARRAY.get(buf, ofs + 32);\n+        int x9 = (int) LE.INT_ARRAY.get(buf, ofs + 36);\n+        int x10 = (int) LE.INT_ARRAY.get(buf, ofs + 40);\n+        int x11 = (int) LE.INT_ARRAY.get(buf, ofs + 44);\n+        int x12 = (int) LE.INT_ARRAY.get(buf, ofs + 48);\n+        int x13 = (int) LE.INT_ARRAY.get(buf, ofs + 52);\n+        int x14 = (int) LE.INT_ARRAY.get(buf, ofs + 56);\n+        int x15 = (int) LE.INT_ARRAY.get(buf, ofs + 60);\n+\n@@ -179,16 +190,16 @@\n-        a = FF ( a, b, c, d, x[ 0], S11, 0xd76aa478); \/* 1 *\/\n-        d = FF ( d, a, b, c, x[ 1], S12, 0xe8c7b756); \/* 2 *\/\n-        c = FF ( c, d, a, b, x[ 2], S13, 0x242070db); \/* 3 *\/\n-        b = FF ( b, c, d, a, x[ 3], S14, 0xc1bdceee); \/* 4 *\/\n-        a = FF ( a, b, c, d, x[ 4], S11, 0xf57c0faf); \/* 5 *\/\n-        d = FF ( d, a, b, c, x[ 5], S12, 0x4787c62a); \/* 6 *\/\n-        c = FF ( c, d, a, b, x[ 6], S13, 0xa8304613); \/* 7 *\/\n-        b = FF ( b, c, d, a, x[ 7], S14, 0xfd469501); \/* 8 *\/\n-        a = FF ( a, b, c, d, x[ 8], S11, 0x698098d8); \/* 9 *\/\n-        d = FF ( d, a, b, c, x[ 9], S12, 0x8b44f7af); \/* 10 *\/\n-        c = FF ( c, d, a, b, x[10], S13, 0xffff5bb1); \/* 11 *\/\n-        b = FF ( b, c, d, a, x[11], S14, 0x895cd7be); \/* 12 *\/\n-        a = FF ( a, b, c, d, x[12], S11, 0x6b901122); \/* 13 *\/\n-        d = FF ( d, a, b, c, x[13], S12, 0xfd987193); \/* 14 *\/\n-        c = FF ( c, d, a, b, x[14], S13, 0xa679438e); \/* 15 *\/\n-        b = FF ( b, c, d, a, x[15], S14, 0x49b40821); \/* 16 *\/\n+        a = FF ( a, b, c, d, x0,  S11, 0xd76aa478); \/* 1 *\/\n+        d = FF ( d, a, b, c, x1,  S12, 0xe8c7b756); \/* 2 *\/\n+        c = FF ( c, d, a, b, x2,  S13, 0x242070db); \/* 3 *\/\n+        b = FF ( b, c, d, a, x3,  S14, 0xc1bdceee); \/* 4 *\/\n+        a = FF ( a, b, c, d, x4,  S11, 0xf57c0faf); \/* 5 *\/\n+        d = FF ( d, a, b, c, x5,  S12, 0x4787c62a); \/* 6 *\/\n+        c = FF ( c, d, a, b, x6,  S13, 0xa8304613); \/* 7 *\/\n+        b = FF ( b, c, d, a, x7,  S14, 0xfd469501); \/* 8 *\/\n+        a = FF ( a, b, c, d, x8,  S11, 0x698098d8); \/* 9 *\/\n+        d = FF ( d, a, b, c, x9,  S12, 0x8b44f7af); \/* 10 *\/\n+        c = FF ( c, d, a, b, x10, S13, 0xffff5bb1); \/* 11 *\/\n+        b = FF ( b, c, d, a, x11, S14, 0x895cd7be); \/* 12 *\/\n+        a = FF ( a, b, c, d, x12, S11, 0x6b901122); \/* 13 *\/\n+        d = FF ( d, a, b, c, x13, S12, 0xfd987193); \/* 14 *\/\n+        c = FF ( c, d, a, b, x14, S13, 0xa679438e); \/* 15 *\/\n+        b = FF ( b, c, d, a, x15, S14, 0x49b40821); \/* 16 *\/\n@@ -197,16 +208,16 @@\n-        a = GG ( a, b, c, d, x[ 1], S21, 0xf61e2562); \/* 17 *\/\n-        d = GG ( d, a, b, c, x[ 6], S22, 0xc040b340); \/* 18 *\/\n-        c = GG ( c, d, a, b, x[11], S23, 0x265e5a51); \/* 19 *\/\n-        b = GG ( b, c, d, a, x[ 0], S24, 0xe9b6c7aa); \/* 20 *\/\n-        a = GG ( a, b, c, d, x[ 5], S21, 0xd62f105d); \/* 21 *\/\n-        d = GG ( d, a, b, c, x[10], S22,  0x2441453); \/* 22 *\/\n-        c = GG ( c, d, a, b, x[15], S23, 0xd8a1e681); \/* 23 *\/\n-        b = GG ( b, c, d, a, x[ 4], S24, 0xe7d3fbc8); \/* 24 *\/\n-        a = GG ( a, b, c, d, x[ 9], S21, 0x21e1cde6); \/* 25 *\/\n-        d = GG ( d, a, b, c, x[14], S22, 0xc33707d6); \/* 26 *\/\n-        c = GG ( c, d, a, b, x[ 3], S23, 0xf4d50d87); \/* 27 *\/\n-        b = GG ( b, c, d, a, x[ 8], S24, 0x455a14ed); \/* 28 *\/\n-        a = GG ( a, b, c, d, x[13], S21, 0xa9e3e905); \/* 29 *\/\n-        d = GG ( d, a, b, c, x[ 2], S22, 0xfcefa3f8); \/* 30 *\/\n-        c = GG ( c, d, a, b, x[ 7], S23, 0x676f02d9); \/* 31 *\/\n-        b = GG ( b, c, d, a, x[12], S24, 0x8d2a4c8a); \/* 32 *\/\n+        a = GG ( a, b, c, d, x1,  S21, 0xf61e2562); \/* 17 *\/\n+        d = GG ( d, a, b, c, x6,  S22, 0xc040b340); \/* 18 *\/\n+        c = GG ( c, d, a, b, x11, S23, 0x265e5a51); \/* 19 *\/\n+        b = GG ( b, c, d, a, x0,  S24, 0xe9b6c7aa); \/* 20 *\/\n+        a = GG ( a, b, c, d, x5,  S21, 0xd62f105d); \/* 21 *\/\n+        d = GG ( d, a, b, c, x10, S22,  0x2441453); \/* 22 *\/\n+        c = GG ( c, d, a, b, x15, S23, 0xd8a1e681); \/* 23 *\/\n+        b = GG ( b, c, d, a, x4,  S24, 0xe7d3fbc8); \/* 24 *\/\n+        a = GG ( a, b, c, d, x9,  S21, 0x21e1cde6); \/* 25 *\/\n+        d = GG ( d, a, b, c, x14, S22, 0xc33707d6); \/* 26 *\/\n+        c = GG ( c, d, a, b, x3,  S23, 0xf4d50d87); \/* 27 *\/\n+        b = GG ( b, c, d, a, x8,  S24, 0x455a14ed); \/* 28 *\/\n+        a = GG ( a, b, c, d, x13, S21, 0xa9e3e905); \/* 29 *\/\n+        d = GG ( d, a, b, c, x2,  S22, 0xfcefa3f8); \/* 30 *\/\n+        c = GG ( c, d, a, b, x7,  S23, 0x676f02d9); \/* 31 *\/\n+        b = GG ( b, c, d, a, x12, S24, 0x8d2a4c8a); \/* 32 *\/\n@@ -215,16 +226,16 @@\n-        a = HH ( a, b, c, d, x[ 5], S31, 0xfffa3942); \/* 33 *\/\n-        d = HH ( d, a, b, c, x[ 8], S32, 0x8771f681); \/* 34 *\/\n-        c = HH ( c, d, a, b, x[11], S33, 0x6d9d6122); \/* 35 *\/\n-        b = HH ( b, c, d, a, x[14], S34, 0xfde5380c); \/* 36 *\/\n-        a = HH ( a, b, c, d, x[ 1], S31, 0xa4beea44); \/* 37 *\/\n-        d = HH ( d, a, b, c, x[ 4], S32, 0x4bdecfa9); \/* 38 *\/\n-        c = HH ( c, d, a, b, x[ 7], S33, 0xf6bb4b60); \/* 39 *\/\n-        b = HH ( b, c, d, a, x[10], S34, 0xbebfbc70); \/* 40 *\/\n-        a = HH ( a, b, c, d, x[13], S31, 0x289b7ec6); \/* 41 *\/\n-        d = HH ( d, a, b, c, x[ 0], S32, 0xeaa127fa); \/* 42 *\/\n-        c = HH ( c, d, a, b, x[ 3], S33, 0xd4ef3085); \/* 43 *\/\n-        b = HH ( b, c, d, a, x[ 6], S34,  0x4881d05); \/* 44 *\/\n-        a = HH ( a, b, c, d, x[ 9], S31, 0xd9d4d039); \/* 45 *\/\n-        d = HH ( d, a, b, c, x[12], S32, 0xe6db99e5); \/* 46 *\/\n-        c = HH ( c, d, a, b, x[15], S33, 0x1fa27cf8); \/* 47 *\/\n-        b = HH ( b, c, d, a, x[ 2], S34, 0xc4ac5665); \/* 48 *\/\n+        a = HH ( a, b, c, d, x5,  S31, 0xfffa3942); \/* 33 *\/\n+        d = HH ( d, a, b, c, x8,  S32, 0x8771f681); \/* 34 *\/\n+        c = HH ( c, d, a, b, x11, S33, 0x6d9d6122); \/* 35 *\/\n+        b = HH ( b, c, d, a, x14, S34, 0xfde5380c); \/* 36 *\/\n+        a = HH ( a, b, c, d, x1,  S31, 0xa4beea44); \/* 37 *\/\n+        d = HH ( d, a, b, c, x4,  S32, 0x4bdecfa9); \/* 38 *\/\n+        c = HH ( c, d, a, b, x7,  S33, 0xf6bb4b60); \/* 39 *\/\n+        b = HH ( b, c, d, a, x10, S34, 0xbebfbc70); \/* 40 *\/\n+        a = HH ( a, b, c, d, x13, S31, 0x289b7ec6); \/* 41 *\/\n+        d = HH ( d, a, b, c, x0,  S32, 0xeaa127fa); \/* 42 *\/\n+        c = HH ( c, d, a, b, x3,  S33, 0xd4ef3085); \/* 43 *\/\n+        b = HH ( b, c, d, a, x6,  S34,  0x4881d05); \/* 44 *\/\n+        a = HH ( a, b, c, d, x9,  S31, 0xd9d4d039); \/* 45 *\/\n+        d = HH ( d, a, b, c, x12, S32, 0xe6db99e5); \/* 46 *\/\n+        c = HH ( c, d, a, b, x15, S33, 0x1fa27cf8); \/* 47 *\/\n+        b = HH ( b, c, d, a, x2,  S34, 0xc4ac5665); \/* 48 *\/\n@@ -233,16 +244,16 @@\n-        a = II ( a, b, c, d, x[ 0], S41, 0xf4292244); \/* 49 *\/\n-        d = II ( d, a, b, c, x[ 7], S42, 0x432aff97); \/* 50 *\/\n-        c = II ( c, d, a, b, x[14], S43, 0xab9423a7); \/* 51 *\/\n-        b = II ( b, c, d, a, x[ 5], S44, 0xfc93a039); \/* 52 *\/\n-        a = II ( a, b, c, d, x[12], S41, 0x655b59c3); \/* 53 *\/\n-        d = II ( d, a, b, c, x[ 3], S42, 0x8f0ccc92); \/* 54 *\/\n-        c = II ( c, d, a, b, x[10], S43, 0xffeff47d); \/* 55 *\/\n-        b = II ( b, c, d, a, x[ 1], S44, 0x85845dd1); \/* 56 *\/\n-        a = II ( a, b, c, d, x[ 8], S41, 0x6fa87e4f); \/* 57 *\/\n-        d = II ( d, a, b, c, x[15], S42, 0xfe2ce6e0); \/* 58 *\/\n-        c = II ( c, d, a, b, x[ 6], S43, 0xa3014314); \/* 59 *\/\n-        b = II ( b, c, d, a, x[13], S44, 0x4e0811a1); \/* 60 *\/\n-        a = II ( a, b, c, d, x[ 4], S41, 0xf7537e82); \/* 61 *\/\n-        d = II ( d, a, b, c, x[11], S42, 0xbd3af235); \/* 62 *\/\n-        c = II ( c, d, a, b, x[ 2], S43, 0x2ad7d2bb); \/* 63 *\/\n-        b = II ( b, c, d, a, x[ 9], S44, 0xeb86d391); \/* 64 *\/\n+        a = II ( a, b, c, d, x0,  S41, 0xf4292244); \/* 49 *\/\n+        d = II ( d, a, b, c, x7,  S42, 0x432aff97); \/* 50 *\/\n+        c = II ( c, d, a, b, x14, S43, 0xab9423a7); \/* 51 *\/\n+        b = II ( b, c, d, a, x5,  S44, 0xfc93a039); \/* 52 *\/\n+        a = II ( a, b, c, d, x12, S41, 0x655b59c3); \/* 53 *\/\n+        d = II ( d, a, b, c, x3,  S42, 0x8f0ccc92); \/* 54 *\/\n+        c = II ( c, d, a, b, x10, S43, 0xffeff47d); \/* 55 *\/\n+        b = II ( b, c, d, a, x1,  S44, 0x85845dd1); \/* 56 *\/\n+        a = II ( a, b, c, d, x8,  S41, 0x6fa87e4f); \/* 57 *\/\n+        d = II ( d, a, b, c, x15, S42, 0xfe2ce6e0); \/* 58 *\/\n+        c = II ( c, d, a, b, x6,  S43, 0xa3014314); \/* 59 *\/\n+        b = II ( b, c, d, a, x13, S44, 0x4e0811a1); \/* 60 *\/\n+        a = II ( a, b, c, d, x4,  S41, 0xf7537e82); \/* 61 *\/\n+        d = II ( d, a, b, c, x11, S42, 0xbd3af235); \/* 62 *\/\n+        c = II ( c, d, a, b, x2,  S43, 0x2ad7d2bb); \/* 63 *\/\n+        b = II ( b, c, d, a, x9,  S44, 0xeb86d391); \/* 64 *\/\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/MD5.java","additions":90,"deletions":79,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,0 @@\n-        W = new int[80];\n@@ -75,1 +74,1 @@\n-        copy.W = new int[80];\n+        copy.W = null;\n@@ -86,1 +85,3 @@\n-        Arrays.fill(W, 0);\n+        if (W != null) {\n+            Arrays.fill(W, 0);\n+        }\n@@ -135,5 +136,6 @@\n-        \/\/ The checks performed by the method 'b2iBig64'\n-        \/\/ are sufficient for the case when the method\n-        \/\/ 'implCompress0' is replaced with a compiler\n-        \/\/ intrinsic.\n-        b2iBig64(buf, ofs, W);\n+        \/\/ Checks similar to those performed by the method 'b2iBig64'\n+        \/\/ are sufficient for the case when the method 'implCompress0' is\n+        \/\/ replaced with a compiler intrinsic.\n+        if (ofs < 0 || (buf.length - ofs) < 64) {\n+            throw new ArrayIndexOutOfBoundsException();\n+        }\n@@ -149,0 +151,4 @@\n+        if (W == null) {\n+            W = new int[80];\n+        }\n+        b2iBig64(buf, ofs, W);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SHA.java","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,0 @@\n-        W = new int[64];\n@@ -95,1 +94,3 @@\n-        Arrays.fill(W, 0);\n+        if (W != null) {\n+            Arrays.fill(W, 0);\n+        }\n@@ -127,5 +128,6 @@\n-        \/\/ The checks performed by the method 'b2iBig64'\n-        \/\/ are sufficient for the case when the method\n-        \/\/ 'implCompressImpl' is replaced with a compiler\n-        \/\/ intrinsic.\n-        b2iBig64(buf, ofs, W);\n+        \/\/ Checks similar to those performed by the method 'b2iBig64'\n+        \/\/ are sufficient for the case when the method 'implCompress0' is\n+        \/\/ replaced with a compiler intrinsic.\n+        if (ofs < 0 || (buf.length - ofs) < 64) {\n+            throw new ArrayIndexOutOfBoundsException();\n+        }\n@@ -141,0 +143,4 @@\n+        if (W == null) {\n+            W = new int[64];\n+        }\n+        b2iBig64(buf, ofs, W);\n@@ -223,1 +229,1 @@\n-        copy.W = new int[64];\n+        copy.W = null;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SHA2.java","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,1 +101,0 @@\n-        W = new long[80];\n@@ -107,1 +106,3 @@\n-        Arrays.fill(W, 0L);\n+        if (W != null) {\n+            Arrays.fill(W, 0L);\n+        }\n@@ -228,5 +229,6 @@\n-        \/\/ The checks performed by the method 'b2iBig128'\n-        \/\/ are sufficient for the case when the method\n-        \/\/ 'implCompressImpl' is replaced with a compiler\n-        \/\/ intrinsic.\n-        b2lBig128(buf, ofs, W);\n+        \/\/ Checks similar to those performed by the method 'b2lBig128'\n+        \/\/ are sufficient for the case when the method 'implCompress0' is\n+        \/\/ replaced with a compiler intrinsic.\n+        if (ofs < 0 || (buf.length - ofs) < 128) {\n+            throw new ArrayIndexOutOfBoundsException();\n+        }\n@@ -242,0 +244,4 @@\n+        if (W == null) {\n+            W = new long[80];\n+        }\n+        b2lBig128(buf, ofs, W);\n@@ -283,1 +289,1 @@\n-        copy.W = new long[80];\n+        copy.W = null;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SHA5.java","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,2 +48,2 @@\n-@Warmup(iterations = 5)\n-@Measurement(iterations = 10)\n+@Warmup(iterations = 10, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 10, time = 1, timeUnit = TimeUnit.SECONDS)\n@@ -80,0 +80,11 @@\n+\n+    @Benchmark\n+    public byte[] getAndDigest() throws DigestException, NoSuchAlgorithmException, NoSuchProviderException {\n+        MessageDigest md;\n+        if (\"DEFAULT\".equals(provider)) {\n+            md = MessageDigest.getInstance(digesterName);\n+        } else {\n+            md = MessageDigest.getInstance(digesterName, provider);\n+        }\n+        return md.digest(inputBytes);\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/MessageDigests.java","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,2 @@\n+    private byte[][] uuidBytes;\n+\n@@ -48,0 +50,1 @@\n+        uuidBytes = new byte[size][];\n@@ -50,0 +53,1 @@\n+        java.util.Random r = new java.util.Random(0);\n@@ -52,1 +56,2 @@\n-\n+            this.uuidBytes[i] = new byte[16];\n+            r.nextBytes(this.uuidBytes[i]);\n@@ -75,0 +80,5 @@\n+\n+    @Benchmark\n+    public UUID fromType3Bytes() {\n+        return UUID.nameUUIDFromBytes(uuidBytes[index]);\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/UUIDBench.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"}]}