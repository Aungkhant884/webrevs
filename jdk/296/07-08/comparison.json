{"files":[{"patch":"@@ -518,4 +518,0 @@\n-  } else {\n-    \/\/ The other C1 exception handler call in here before the throwing frame has\n-    \/\/ been unwound.\n-    StackWatermarkSet::before_unwind(thread);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -451,0 +451,4 @@\n+  \/\/ We get here after we have unwound from a callee throwing an exception\n+  \/\/ into the interpreter. Any deferred stack processing is notified of\n+  \/\/ the event via the StackWatermarkSet.\n+  StackWatermarkSet::after_unwind(thread);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1290,5 +1290,0 @@\n-  \/\/ We get here when we are about to throw an exception. The exception could\n-  \/\/ return into a not yet safe to use frame. We catch such conditions in the\n-  \/\/ following stack watermark barrier poll.\n-  StackWatermarkSet::before_unwind(thread);\n-\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -164,0 +164,7 @@\n+  if (exec_mode == Unpack_exception) {\n+    \/\/ When we get here, a callee has thrown an exception into a deoptimized\n+    \/\/ frame. That throw might have deferred stack watermark checking until\n+    \/\/ after unwinding. So we deal with such deferred requests here.\n+    StackWatermarkSet::after_unwind(thread);\n+  }\n+\n@@ -258,3 +265,3 @@\n-  \/\/ When we get here we are about to unwind a frame. In order to catch not yet\n-  \/\/ safe to use frames, the following stack watermark barrier poll will make\n-  \/\/ such frames safe to use.\n+  \/\/ When we get here we are about to unwind the deoptee frame. In order to\n+  \/\/ catch not yet safe to use frames, the following stack watermark barrier\n+  \/\/ poll will make such frames safe to use.\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -451,2 +451,7 @@\n-\/\/ all (callee-saved) registers. Notice: If a thread is stopped at\n-\/\/ a safepoint, all registers are saved, not only the callee-saved ones.\n+\/\/ all (callee-saved) registers iff the update flag is set. It also\n+\/\/ automatically takes care of lazily applying deferred GC processing\n+\/\/ onto exposed frames, such that all oops are valid iff the process_frames\n+\/\/ flag is set.\n+\/\/\n+\/\/ Notice: If a thread is stopped at a safepoint, all registers are saved,\n+\/\/ not only the callee-saved ones.\n@@ -456,1 +461,3 @@\n-\/\/   for(StackFrameStream fst(thread); !fst.is_done(); fst.next()) {\n+\/\/   for(StackFrameStream fst(thread, true \/* update *\/, true \/* process_frames *\/);\n+\/\/       !fst.is_done();\n+\/\/       fst.next()) {\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -139,0 +139,8 @@\n+\n+  if (_thread->has_pending_exception() && _thread->has_last_Java_frame()) {\n+    \/\/ If we get here, the Java code threw an exception that unwound a frame.\n+    \/\/ It could be that the new frame anchor has not passed through the required\n+    \/\/ StackWatermark barriers. Therefore, we process any such deferred unwind\n+    \/\/ requests here.\n+    StackWatermarkSet::after_unwind(_thread);\n+  }\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -458,0 +458,6 @@\n+  \/\/ Note: This is called when we have unwound the frame of the callee that did\n+  \/\/ throw an exception. So far, no check has been performed by the StackWatermarkSet.\n+  \/\/ Notably, the stack is not walkable at this point, and hence the check must\n+  \/\/ be deferred until later. Specifically, any of the handlers returned here in\n+  \/\/ this function, will get dispatched to, and call deferred checks to\n+  \/\/ StackWatermarkSet::after_unwind at a point where the stack is walkable.\n@@ -490,0 +496,2 @@\n+      \/\/ The deferred StackWatermarkSet::after_unwind check will be performed in\n+      \/\/ Deoptimization::fetch_unroll_info (with exec_mode == Unpack_exception)\n@@ -492,0 +500,3 @@\n+      \/\/ The deferred StackWatermarkSet::after_unwind check will be performed in\n+      \/\/ * OptoRuntime::rethrow_C for C2 code\n+      \/\/ * exception_handler_for_pc_helper via Runtime1::handle_exception_from_callee_id for C1 code\n@@ -498,0 +509,2 @@\n+    \/\/ The deferred StackWatermarkSet::after_unwind check will be performed in\n+    \/\/ JavaCallWrapper::~JavaCallWrapper\n@@ -502,0 +515,2 @@\n+    \/\/ The deferred StackWatermarkSet::after_unwind check will be performed in\n+    \/\/ InterpreterRuntime::exception_handler_for_exception\n@@ -522,4 +537,0 @@\n-  \/\/ This is called when we are about to throw an exception. We must make sure the\n-  \/\/ frame we are unwinding to is safe to be access w.r.t. concurrent stack processing.\n-  \/\/ The stack watermark code will take care of ensuring that.\n-  StackWatermarkSet::after_unwind(thread);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -83,5 +83,1 @@\n-  if (!jt->has_last_Java_frame()) {\n-    \/\/ Sometimes we throw exceptions and use native transitions on threads that\n-    \/\/ do not have any Java threads. Skip those callsites.\n-    return;\n-  }\n+  assert(jt->has_last_Java_frame(), \"must have a Java frame\");\n@@ -96,5 +92,1 @@\n-  if (!jt->has_last_Java_frame()) {\n-    \/\/ Sometimes we throw exceptions and use native transitions on threads that\n-    \/\/ do not have any Java threads. Skip those callsites.\n-    return;\n-  }\n+  assert(jt->has_last_Java_frame(), \"must have a Java frame\");\n","filename":"src\/hotspot\/share\/runtime\/stackWatermarkSet.cpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -893,0 +893,1 @@\n+      assert(_cur_thr->processed_thread() == NULL, \"nesting not supported\");\n@@ -901,0 +902,1 @@\n+      assert(_cur_thr->processed_thread() != NULL, \"nesting not supported\");\n@@ -2663,5 +2665,0 @@\n-  \/\/ After returning from native, it could be that the stack frames are not\n-  \/\/ yet safe to use. We catch such situations in the subsequent stack watermark\n-  \/\/ barrier, which will trap unsafe stack frames.\n-  StackWatermarkSet::before_unwind(thread);\n-\n@@ -2681,0 +2678,5 @@\n+  \/\/ After returning from native, it could be that the stack frames are not\n+  \/\/ yet safe to use. We catch such situations in the subsequent stack watermark\n+  \/\/ barrier, which will trap unsafe stack frames.\n+  StackWatermarkSet::before_unwind(thread);\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"}]}