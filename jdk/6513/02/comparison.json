{"files":[{"patch":"@@ -194,0 +194,3 @@\n+        this.legacyMap = new ConcurrentHashMap<>();\n+        this.prngAlgos =\n+                Collections.synchronizedSet(new LinkedHashSet<String>(6));\n@@ -232,0 +235,3 @@\n+        this.legacyMap = new ConcurrentHashMap<>();\n+        this.prngAlgos =\n+                Collections.synchronizedSet(new LinkedHashSet<String>(6));\n@@ -357,1 +363,1 @@\n-    public synchronized void clear() {\n+    public void clear() {\n@@ -374,1 +380,1 @@\n-    public synchronized void load(InputStream inStream) throws IOException {\n+    public void load(InputStream inStream) throws IOException {\n@@ -392,1 +398,1 @@\n-    public synchronized void putAll(Map<?,?> t) {\n+    public void putAll(Map<?,?> t) {\n@@ -408,1 +414,1 @@\n-    public synchronized Set<Map.Entry<Object,Object>> entrySet() {\n+    public Set<Map.Entry<Object,Object>> entrySet() {\n@@ -469,1 +475,1 @@\n-    public synchronized Object put(Object key, Object value) {\n+    public Object put(Object key, Object value) {\n@@ -496,1 +502,1 @@\n-    public synchronized Object putIfAbsent(Object key, Object value) {\n+    public Object putIfAbsent(Object key, Object value) {\n@@ -522,1 +528,1 @@\n-    public synchronized Object remove(Object key) {\n+    public Object remove(Object key) {\n@@ -547,1 +553,1 @@\n-    public synchronized boolean remove(Object key, Object value) {\n+    public boolean remove(Object key, Object value) {\n@@ -572,2 +578,1 @@\n-    public synchronized boolean replace(Object key, Object oldValue,\n-            Object newValue) {\n+    public boolean replace(Object key, Object oldValue, Object newValue) {\n@@ -575,1 +580,0 @@\n-\n@@ -599,1 +603,1 @@\n-    public synchronized Object replace(Object key, Object value) {\n+    public Object replace(Object key, Object value) {\n@@ -601,1 +605,0 @@\n-\n@@ -627,2 +630,2 @@\n-    public synchronized void replaceAll(BiFunction<? super Object,\n-            ? super Object, ? extends Object> function) {\n+    public void replaceAll(BiFunction<? super Object, ? super Object,\n+            ? extends Object> function) {\n@@ -630,1 +633,0 @@\n-\n@@ -656,1 +658,1 @@\n-    public synchronized Object compute(Object key, BiFunction<? super Object,\n+    public Object compute(Object key, BiFunction<? super Object,\n@@ -660,1 +662,0 @@\n-\n@@ -687,1 +688,1 @@\n-    public synchronized Object computeIfAbsent(Object key, Function<? super Object,\n+    public Object computeIfAbsent(Object key, Function<? super Object,\n@@ -691,1 +692,0 @@\n-\n@@ -717,1 +717,1 @@\n-    public synchronized Object computeIfPresent(Object key, BiFunction<? super Object,\n+    public Object computeIfPresent(Object key, BiFunction<? super Object,\n@@ -721,1 +721,0 @@\n-\n@@ -750,1 +749,1 @@\n-    public synchronized Object merge(Object key, Object value,  BiFunction<? super Object,\n+    public Object merge(Object key, Object value,  BiFunction<? super Object,\n@@ -754,1 +753,0 @@\n-\n@@ -771,1 +769,1 @@\n-    public synchronized Object getOrDefault(Object key, Object defaultValue) {\n+    public Object getOrDefault(Object key, Object defaultValue) {\n@@ -780,1 +778,1 @@\n-    public synchronized void forEach(BiConsumer<? super Object, ? super Object> action) {\n+    public void forEach(BiConsumer<? super Object, ? super Object> action) {\n@@ -820,2 +818,2 @@\n-    \/\/ legacy properties changed since last call to any services method?\n-    private transient boolean legacyChanged;\n+    \/\/ legacyMap changed since last call to getServices()\n+    private transient volatile boolean legacyChanged;\n@@ -825,3 +823,0 @@\n-    \/\/ Map<String,String> used to keep track of legacy registration\n-    private transient Map<String,String> legacyStrings;\n-\n@@ -835,0 +830,3 @@\n+    \/\/ NOTE: may need extra mechanism for providers to indicate their\n+    \/\/ preferred ordering of SecureRandom algorithms since registration\n+    \/\/ ordering info is lost once serialized\n@@ -843,1 +841,1 @@\n-    private transient Set<Service> serviceSet;\n+    private transient volatile Set<Service> serviceSet;\n@@ -875,0 +873,1 @@\n+\n@@ -885,0 +884,3 @@\n+        this.legacyMap = new ConcurrentHashMap<>();\n+        this.prngAlgos =\n+                Collections.synchronizedSet(new LinkedHashSet<String>(6));\n@@ -890,4 +892,5 @@\n-    \/\/ check whether to update 'legacyString' with the specified key\n-    private boolean checkLegacy(Object key) {\n-        String keyString = (String)key;\n-        if (keyString.startsWith(\"Provider.\")) {\n+    \/\/ returns false if no update necessary, i.e. key isn't String or\n+    \/\/ is String but it's provider-related (name\/version\/info\/className)\n+    private static boolean checkLegacy(Object key) {\n+        if (key instanceof String && ((String)key).startsWith(\"Provider.\")) {\n+            \/\/ ignore provider related updates\n@@ -895,0 +898,2 @@\n+        } else {\n+            return true;\n@@ -896,6 +901,0 @@\n-\n-        legacyChanged = true;\n-        if (legacyStrings == null) {\n-            legacyStrings = new LinkedHashMap<>();\n-        }\n-        return true;\n@@ -916,5 +915,5 @@\n-        if (key instanceof String) {\n-            if (!checkLegacy(key)) {\n-                return null;\n-            }\n-            legacyStrings.remove((String)key);\n+        if (!checkLegacy(key)) return null;\n+\n+        Object o = super.remove(key);\n+        if (o instanceof String so && key instanceof String sk) {\n+            parseLegacy(sk, so, OPType.REMOVE);\n@@ -922,1 +921,1 @@\n-        return super.remove(key);\n+        return o;\n@@ -926,5 +925,5 @@\n-        if (key instanceof String && value instanceof String) {\n-            if (!checkLegacy(key)) {\n-                return false;\n-            }\n-            legacyStrings.remove((String)key, (String)value);\n+        if (!checkLegacy(key)) return false;\n+\n+        boolean result = super.remove(key, value);\n+        if (result && key instanceof String sk && value instanceof String sv) {\n+            parseLegacy(sk, sv, OPType.REMOVE);\n@@ -932,1 +931,1 @@\n-        return super.remove(key, value);\n+        return result;\n@@ -936,4 +935,8 @@\n-        if ((key instanceof String) && (oldValue instanceof String) &&\n-                (newValue instanceof String)) {\n-            if (!checkLegacy(key)) {\n-                return false;\n+        if (!checkLegacy(key)) return false;\n+\n+        boolean result = super.replace(key, oldValue, newValue);\n+        if (result && key instanceof String sk) {\n+            if (newValue instanceof String sv) {\n+                parseLegacy(sk, sv, OPType.REPLACE);\n+            } else if (oldValue instanceof String sv) {\n+                parseLegacy(sk, sv, OPType.REMOVE);\n@@ -941,2 +944,0 @@\n-            legacyStrings.replace((String)key, (String)oldValue,\n-                    (String)newValue);\n@@ -944,1 +945,1 @@\n-        return super.replace(key, oldValue, newValue);\n+        return result;\n@@ -948,3 +949,10 @@\n-        if ((key instanceof String) && (value instanceof String)) {\n-            if (!checkLegacy(key)) {\n-                return null;\n+        if (!checkLegacy(key)) return null;\n+\n+        Object o = super.replace(key, value);\n+        if (key instanceof String sk) {\n+            if (o instanceof String so) {\n+                if (value instanceof String sv) {\n+                    parseLegacy(sk, sv, OPType.REPLACE);\n+                } else {\n+                    parseLegacy(sk, so, OPType.REMOVE);\n+                }\n@@ -952,1 +960,0 @@\n-            legacyStrings.replace((String)key, (String)value);\n@@ -954,1 +961,1 @@\n-        return super.replace(key, value);\n+        return o;\n@@ -960,0 +967,4 @@\n+\n+        super.replaceAll(function);\n+        \/\/ clear out all existing mappings and start fresh\n+        legacyMap.clear();\n@@ -961,5 +972,9 @@\n-        if (legacyStrings == null) {\n-            legacyStrings = new LinkedHashMap<>();\n-        } else {\n-            legacyStrings.replaceAll((BiFunction<? super String, ? super String,\n-                    ? extends String>) function);\n+        for (Map.Entry<Object, Object> entry : super.entrySet()) {\n+            Object key = entry.getKey();\n+            Object value = entry.getValue();\n+            if ((key instanceof String sk) && (value instanceof String sv)) {\n+                if (!checkLegacy(sk)) {\n+                    continue;\n+                }\n+                parseLegacy(sk, sv, OPType.ADD);\n+            }\n@@ -967,1 +982,0 @@\n-        super.replaceAll(function);\n@@ -974,3 +988,8 @@\n-        if ((key instanceof String) && (value instanceof String)) {\n-            if (!checkLegacy(key)) {\n-                return null;\n+        if (!checkLegacy(key)) return null;\n+\n+        Object o = super.merge(key, value, remappingFunction);\n+        if (key instanceof String sk) {\n+            if (o == null) {\n+                parseLegacy(sk, null, OPType.REMOVE);\n+            } else if (o instanceof String so) {\n+                parseLegacy(sk, so, OPType.REPLACE);\n@@ -978,3 +997,0 @@\n-            legacyStrings.merge((String)key, (String)value,\n-                    (BiFunction<? super String, ? super String,\n-                    ? extends String>) remappingFunction);\n@@ -982,1 +998,1 @@\n-        return super.merge(key, value, remappingFunction);\n+        return o;\n@@ -988,3 +1004,9 @@\n-        if (key instanceof String) {\n-            if (!checkLegacy(key)) {\n-                return null;\n+\n+        if (!checkLegacy(key)) return null;\n+\n+        Object o = super.compute(key, remappingFunction);\n+        if (key instanceof String sk) {\n+            if (o == null) {\n+                parseLegacy(sk, null, OPType.REMOVE);\n+            } else if (o instanceof String so) {\n+                parseLegacy(sk, so, OPType.REPLACE);\n@@ -992,3 +1014,0 @@\n-            legacyStrings.compute((String) key,\n-                    (BiFunction<? super String,? super String,\n-                    ? extends String>) remappingFunction);\n@@ -996,1 +1015,1 @@\n-        return super.compute(key, remappingFunction);\n+        return o;\n@@ -1002,7 +1021,5 @@\n-        if (key instanceof String) {\n-            if (!checkLegacy(key)) {\n-                return null;\n-            }\n-            legacyStrings.computeIfAbsent((String) key,\n-                    (Function<? super String, ? extends String>)\n-                    mappingFunction);\n+        if (!checkLegacy(key)) return null;\n+\n+        Object o = super.computeIfAbsent(key, mappingFunction);\n+        if (o instanceof String so && key instanceof String sk) {\n+            parseLegacy(sk, so, OPType.REPLACE);\n@@ -1010,1 +1027,1 @@\n-        return super.computeIfAbsent(key, mappingFunction);\n+        return o;\n@@ -1016,7 +1033,5 @@\n-        if (key instanceof String) {\n-            if (!checkLegacy(key)) {\n-                return null;\n-            }\n-            legacyStrings.computeIfPresent((String) key,\n-                    (BiFunction<? super String, ? super String,\n-                    ? extends String>) remappingFunction);\n+        if (!checkLegacy(key)) return null;\n+\n+        Object o = super.computeIfPresent(key, remappingFunction);\n+        if (o instanceof String so && key instanceof String sk) {\n+            parseLegacy(sk, so, OPType.REPLACE);\n@@ -1024,1 +1039,1 @@\n-        return super.computeIfPresent(key, remappingFunction);\n+        return o;\n@@ -1028,5 +1043,5 @@\n-        if ((key instanceof String) && (value instanceof String)) {\n-            if (!checkLegacy(key)) {\n-                return null;\n-            }\n-            legacyStrings.put((String)key, (String)value);\n+        if (!checkLegacy(key)) return null;\n+\n+        Object o = super.put(key, value);\n+        if (key instanceof String sk && value instanceof String sv) {\n+            parseLegacy(sk, sv, OPType.REPLACE);\n@@ -1034,1 +1049,1 @@\n-        return super.put(key, value);\n+        return o;\n@@ -1038,5 +1053,6 @@\n-        if ((key instanceof String) && (value instanceof String)) {\n-            if (!checkLegacy(key)) {\n-                return null;\n-            }\n-            legacyStrings.putIfAbsent((String)key, (String)value);\n+        if (!checkLegacy(key)) return null;\n+\n+        Object o = super.putIfAbsent(key, value);\n+        if (o == null && key instanceof String sk &&\n+                value instanceof String sv) {\n+            parseLegacy(sk, sv, OPType.ADD);\n@@ -1044,1 +1060,1 @@\n-        return super.putIfAbsent(key, value);\n+        return o;\n@@ -1048,6 +1064,1 @@\n-        if (legacyStrings != null) {\n-            legacyStrings.clear();\n-        }\n-        if (legacyMap != null) {\n-            legacyMap.clear();\n-        }\n+        legacyMap.clear();\n@@ -1058,1 +1069,1 @@\n-        prngAlgos = null;\n+        prngAlgos.clear();\n@@ -1088,34 +1099,2 @@\n-    }\n-\n-    \/**\n-     * Ensure all the legacy String properties are fully parsed into\n-     * service objects.\n-     *\/\n-    private void ensureLegacyParsed() {\n-        if (legacyChanged == false || (legacyStrings == null)) {\n-            return;\n-        }\n-        serviceSet = null;\n-        if (legacyMap == null) {\n-            legacyMap = new ConcurrentHashMap<>();\n-        } else {\n-            legacyMap.clear();\n-        }\n-        for (Map.Entry<String,String> entry : legacyStrings.entrySet()) {\n-            parseLegacyPut(entry.getKey(), entry.getValue());\n-        }\n-        removeInvalidServices(legacyMap);\n-        legacyChanged = false;\n-    }\n-\n-    \/**\n-     * Remove all invalid services from the Map. Invalid services can only\n-     * occur if the legacy properties are inconsistent or incomplete.\n-     *\/\n-    private void removeInvalidServices(Map<ServiceKey,Service> map) {\n-        for (Iterator<Map.Entry<ServiceKey, Service>> t =\n-                map.entrySet().iterator(); t.hasNext(); ) {\n-            Service s = t.next().getValue();\n-            if (s.isValid() == false) {\n-                t.remove();\n-            }\n+        public String toString() {\n+            return type + \".\" + algorithm;\n@@ -1139,0 +1118,5 @@\n+    \/\/ utility method for getting a String with service type and algorithm\n+    private static String getKey(Service s) {\n+        return s.getType() + \".\" + s.getAlgorithm();\n+    }\n+\n@@ -1143,1 +1127,6 @@\n-    private void parseLegacyPut(String name, String value) {\n+    private static enum OPType {\n+        ADD, REMOVE, REPLACE;\n+    }\n+\n+    private void parseLegacy(String name, String value, OPType opType) {\n+        \/\/ alias\n@@ -1147,3 +1136,2 @@\n-            String stdAlg = value;\n-            String aliasKey = name.substring(ALIAS_LENGTH);\n-            String[] typeAndAlg = getTypeAndAlgorithm(aliasKey);\n+            String aliasKeyStr = name.substring(ALIAS_LENGTH);\n+            String[] typeAndAlg = getTypeAndAlgorithm(aliasKeyStr);\n@@ -1153,0 +1141,2 @@\n+            legacyChanged = true;\n+            Objects.requireNonNull(value, \"alias value should map to an alg\");\n@@ -1155,5 +1145,28 @@\n-            ServiceKey key = new ServiceKey(type, stdAlg, true);\n-            Service s = legacyMap.get(key);\n-            if (s == null) {\n-                s = new Service(this, type, stdAlg);\n-                legacyMap.put(key, s);\n+            ServiceKey stdKey = new ServiceKey(type, value, true);\n+            Service stdService = legacyMap.get(stdKey);\n+            ServiceKey aliasKey = new ServiceKey(type, aliasAlg, true);\n+            switch (opType) {\n+                case ADD:\n+                case REPLACE:\n+                    if (opType == OPType.REPLACE) {\n+                        Service prevAliasService = legacyMap.get(aliasAlg);\n+                        if (prevAliasService != null) {\n+                            prevAliasService.removeAlias(aliasAlg);\n+                        }\n+                    }\n+                    if (stdService == null) {\n+                        \/\/ add standard mapping in order to add alias\n+                        stdService = new Service(this, type, value);\n+                        legacyMap.put(stdKey, stdService);\n+                    }\n+                    stdService.addAlias(aliasAlg);\n+                    legacyMap.put(aliasKey, stdService);\n+                    break;\n+                case REMOVE:\n+                    if (stdService != null) {\n+                        stdService.removeAlias(aliasAlg);\n+                    }\n+                    legacyMap.remove(aliasKey);\n+                    break;\n+                default:\n+                    throw new AssertionError();\n@@ -1161,2 +1174,0 @@\n-            legacyMap.put(new ServiceKey(type, aliasAlg, true), s);\n-            s.addAlias(aliasAlg);\n@@ -1168,0 +1179,1 @@\n+            legacyChanged = true;\n@@ -1169,0 +1181,1 @@\n+            \/\/ regular registration\n@@ -1173,11 +1186,34 @@\n-                String className = value;\n-                ServiceKey key = new ServiceKey(type, stdAlg, true);\n-                Service s = legacyMap.get(key);\n-                if (s == null) {\n-                    s = new Service(this, type, stdAlg);\n-                    legacyMap.put(key, s);\n-                }\n-                s.className = className;\n-\n-                if (type.equals(\"SecureRandom\")) {\n-                    updateSecureRandomEntries(true, s.algorithm);\n+                ServiceKey stdKey = new ServiceKey(type, stdAlg, true);\n+                Service stdService = legacyMap.get(stdKey);\n+                switch (opType) {\n+                    case ADD:\n+                    case REPLACE:\n+                        Objects.requireNonNull(value,\n+                                \"className can't be null\");\n+                        if (stdService == null) {\n+                            stdService = new Service(this, type, stdAlg);\n+                            legacyMap.put(stdKey, stdService);\n+                        } else if ((opType == OPType.ADD) &&\n+                                (stdService.className != null)) {\n+                            \/\/ ignore subsequent registration for ADD\n+                            return;\n+                        }\n+                        stdService.className = value;\n+                        break;\n+                    case REMOVE:\n+                        \/\/ only remove if value also matches when non-null\n+                        if (stdService != null) {\n+                            if (value == null) {\n+                                legacyMap.remove(stdKey);\n+                            } else if (stdService.className.equals(value)) {\n+                                legacyMap.remove(stdKey, stdService);\n+                            }\n+                            \/\/ remove all corresponding alias mappings\n+                            for (String alias : stdService.getAliases()) {\n+                                legacyMap.remove(new ServiceKey(type, alias,\n+                                        true), stdService);\n+                            }\n+                        }\n+                        break;\n+                    default:\n+                        throw new AssertionError();\n@@ -1185,0 +1221,2 @@\n+                checkAndUpdateSecureRandom(type, stdAlg,\n+                        (opType != OPType.REMOVE));\n@@ -1187,1 +1225,0 @@\n-                String attributeValue = value;\n@@ -1189,3 +1226,3 @@\n-                String attributeString = typeAndAlg[1];\n-                String stdAlg = attributeString.substring(0, i).intern();\n-                String attributeName = attributeString.substring(i + 1);\n+                String attrString = typeAndAlg[1];\n+                String stdAlg = attrString.substring(0, i).intern();\n+                String attrName = attrString.substring(i + 1);\n@@ -1193,2 +1230,2 @@\n-                while (attributeName.startsWith(\" \")) {\n-                    attributeName = attributeName.substring(1);\n+                while (attrName.startsWith(\" \")) {\n+                    attrName = attrName.substring(1);\n@@ -1196,6 +1233,22 @@\n-                attributeName = attributeName.intern();\n-                ServiceKey key = new ServiceKey(type, stdAlg, true);\n-                Service s = legacyMap.get(key);\n-                if (s == null) {\n-                    s = new Service(this, type, stdAlg);\n-                    legacyMap.put(key, s);\n+                attrName = attrName.intern();\n+                ServiceKey stdKey = new ServiceKey(type, stdAlg, true);\n+                Service stdService = legacyMap.get(stdKey);\n+                switch (opType) {\n+                    case ADD:\n+                    case REPLACE:\n+                        Objects.requireNonNull(value,\n+                                \"attribute value should not be null\");\n+\n+                        if (stdService == null) {\n+                            stdService = new Service(this, type, stdAlg);\n+                            legacyMap.put(stdKey, stdService);\n+                        }\n+                        stdService.addAttribute(attrName, value);\n+                        break;\n+                    case REMOVE:\n+                        if (stdService != null) {\n+                            stdService.removeAttribute(attrName, value);\n+                        }\n+                        break;\n+                default:\n+                    throw new AssertionError();\n@@ -1203,1 +1256,0 @@\n-                s.addAttribute(attributeName, attributeValue);\n@@ -1230,1 +1282,0 @@\n-\n@@ -1237,5 +1288,4 @@\n-        if (!serviceMap.isEmpty()) {\n-            Service s = serviceMap.get(key);\n-            if (s != null) {\n-                return s;\n-            }\n+\n+        Service s = serviceMap.get(key);\n+        if (s != null) {\n+            return s;\n@@ -1243,5 +1293,6 @@\n-        synchronized (this) {\n-            ensureLegacyParsed();\n-            if (legacyMap != null && !legacyMap.isEmpty()) {\n-                return legacyMap.get(key);\n-            }\n+\n+        s = legacyMap.get(key);\n+        if (s != null && !s.isValid()) {\n+            legacyMap.remove(key, s);\n+        } else {\n+            return s;\n@@ -1249,0 +1300,1 @@\n+\n@@ -1270,1 +1322,1 @@\n-    public synchronized Set<Service> getServices() {\n+    public Set<Service> getServices() {\n@@ -1272,5 +1324,1 @@\n-        if (legacyChanged || servicesChanged) {\n-            serviceSet = null;\n-        }\n-        if (serviceSet == null) {\n-            ensureLegacyParsed();\n+        if (serviceSet == null || legacyChanged || servicesChanged) {\n@@ -1281,1 +1329,1 @@\n-            if (legacyMap != null && !legacyMap.isEmpty()) {\n+            if (!legacyMap.isEmpty()) {\n@@ -1340,6 +1388,3 @@\n-        synchronized (this) {\n-            putPropertyStrings(s);\n-            if (type.equals(\"SecureRandom\")) {\n-                updateSecureRandomEntries(true, s.algorithm);\n-            }\n-        }\n+        putPropertyStrings(s);\n+\n+        checkAndUpdateSecureRandom(type, algorithm, true);\n@@ -1348,6 +1393,11 @@\n-    \/\/ keep tracks of the registered secure random algos and store them in order\n-    private void updateSecureRandomEntries(boolean doAdd, String s) {\n-        Objects.requireNonNull(s);\n-        if (doAdd) {\n-            if (prngAlgos == null) {\n-                prngAlgos = new LinkedHashSet<String>();\n+    private void checkAndUpdateSecureRandom(String type, String algo,\n+            boolean doAdd) {\n+        if (type.equalsIgnoreCase(\"SecureRandom\")) {\n+            if (doAdd) {\n+                prngAlgos.add(algo);\n+            } else {\n+                prngAlgos.remove(algo);\n+            }\n+            if (debug != null) {\n+                debug.println((doAdd? \"Add\":\"Remove\") +\n+                        \" SecureRandom algo \" + algo);\n@@ -1355,7 +1405,0 @@\n-            prngAlgos.add(s);\n-        } else {\n-            prngAlgos.remove(s);\n-        }\n-\n-        if (debug != null) {\n-            debug.println((doAdd? \"Add\":\"Remove\") + \" SecureRandom algo \" + s);\n@@ -1367,1 +1410,1 @@\n-    synchronized Service getDefaultSecureRandomService() {\n+    Service getDefaultSecureRandomService() {\n@@ -1370,6 +1413,2 @@\n-        if (legacyChanged) {\n-            prngAlgos = null;\n-            ensureLegacyParsed();\n-        }\n-\n-        if (prngAlgos != null && !prngAlgos.isEmpty()) {\n+        if (!prngAlgos.isEmpty()) {\n+            String algo = prngAlgos.iterator().next();\n@@ -1379,1 +1418,1 @@\n-            return getService(\"SecureRandom\", prngAlgos.iterator().next());\n+            return getService(\"SecureRandom\", algo);\n@@ -1476,6 +1515,3 @@\n-        synchronized (this) {\n-            removePropertyStrings(s);\n-            if (type.equals(\"SecureRandom\")) {\n-                updateSecureRandomEntries(false, s.algorithm);\n-            }\n-        }\n+\n+        removePropertyStrings(s);\n+        checkAndUpdateSecureRandom(type, algorithm, false);\n@@ -1689,0 +1725,7 @@\n+        private void removeAlias(String alias) {\n+            if (aliases.isEmpty()) {\n+                return;\n+            }\n+            aliases.remove(alias);\n+        }\n+\n@@ -1696,0 +1739,11 @@\n+        void removeAttribute(String type, String value) {\n+            if (attributes.isEmpty()) {\n+                return;\n+            }\n+            if (value == null) {\n+                attributes.remove(new UString(type));\n+            } else {\n+                attributes.remove(new UString(type), value);\n+            }\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/security\/Provider.java","additions":295,"deletions":241,"binary":false,"changes":536,"status":"modified"}]}