{"files":[{"patch":"@@ -138,2 +138,2 @@\n-  T* result = Atomic::load_acquire(&_head);\n-  if (result == NULL) {\n+  T* old_head = Atomic::load_acquire(&_head);\n+  if (old_head == NULL) {\n@@ -144,1 +144,1 @@\n-  T* next_node = Atomic::load_acquire(next_ptr(*result));\n+  T* next_node = Atomic::load_acquire(next_ptr(*old_head));\n@@ -149,1 +149,1 @@\n-    \/\/ (2) next_node is NULL, because a competing try_pop took result.\n+    \/\/ (2) next_node is NULL, because a competing try_pop took old_head.\n@@ -151,1 +151,1 @@\n-    \/\/ competing try_pop took result and put it in some other list.\n+    \/\/ competing try_pop took old_head and put it in some other list.\n@@ -153,1 +153,1 @@\n-    \/\/ Attempt to advance the list, replacing result with next_node in\n+    \/\/ Attempt to advance the list, replacing old_head with next_node in\n@@ -157,1 +157,1 @@\n-    if (result != Atomic::cmpxchg(&_head, result, next_node)) {\n+    if (old_head != Atomic::cmpxchg(&_head, old_head, next_node)) {\n@@ -160,1 +160,1 @@\n-      \/\/ the race and claimed result.  This can happen for any of the\n+      \/\/ the race and claimed old_head.  This can happen for any of the\n@@ -166,2 +166,2 @@\n-      \/\/ has already claimed result (see [Clause 2] - result was the last\n-      \/\/ entry in the list) by nulling result's next field.  The advance set\n+      \/\/ has already claimed old_head (see [Clause 2] - old_head was the last\n+      \/\/ entry in the list) by nulling old_head's next field.  The advance set\n@@ -177,2 +177,2 @@\n-      \/\/ Successfully advanced the list and claimed result.  next_node was\n-      \/\/ in the extension of the queue's list.  Return result after\n+      \/\/ Successfully advanced the list and claimed old_head.  next_node was\n+      \/\/ in the extension of the queue's list.  Return old_head after\n@@ -180,2 +180,2 @@\n-      set_next(*result, NULL);\n-      *node_ptr = result;\n+      set_next(*old_head, NULL);\n+      *node_ptr = old_head;\n@@ -185,1 +185,1 @@\n-  } else if (is_end(Atomic::cmpxchg(next_ptr(*result), next_node, (T*)NULL))) {\n+  } else if (is_end(Atomic::cmpxchg(next_ptr(*old_head), next_node, (T*)NULL))) {\n@@ -187,1 +187,1 @@\n-    \/\/ Result was the last entry and we've claimed it by setting its next\n+    \/\/ Old_head was the last entry and we've claimed it by setting its next\n@@ -197,1 +197,1 @@\n-    \/\/ Attempt to change the queue head from result to NULL.  Failure of the\n+    \/\/ Attempt to change the queue head from old_head to NULL.  Failure of the\n@@ -200,1 +200,1 @@\n-    Atomic::cmpxchg(&_head, result, (T*)NULL);\n+    Atomic::cmpxchg(&_head, old_head, (T*)NULL);\n@@ -202,1 +202,1 @@\n-    \/\/ Attempt to change the queue tail from result to NULL.  Failure of the\n+    \/\/ Attempt to change the queue tail from old_head to NULL.  Failure of the\n@@ -204,1 +204,1 @@\n-    \/\/ That operation will eventually recognize the old tail (our result) is\n+    \/\/ That operation will eventually recognize the old tail (our old_head) is\n@@ -206,1 +206,1 @@\n-    Atomic::cmpxchg(&_tail, result, (T*)NULL);\n+    Atomic::cmpxchg(&_tail, old_head, (T*)NULL);\n@@ -208,2 +208,2 @@\n-    \/\/ The queue has been restored to order, and we can return the result.\n-    *node_ptr = result;\n+    \/\/ The queue has been restored to order, and we can return old_head.\n+    *node_ptr = old_head;\n@@ -214,1 +214,1 @@\n-    \/\/ Result was the last entry in the list, but either a concurrent\n+    \/\/ Old_head was the last entry in the list, but either a concurrent\n","filename":"src\/hotspot\/share\/utilities\/nonblockingQueue.inline.hpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"}]}