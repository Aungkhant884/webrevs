{"files":[{"patch":"@@ -2318,5 +2318,5 @@\n-                                        HeapRegionClaimer* hr_claimer,\n-                                        const uint* regions,\n-                                        size_t offset,\n-                                        size_t length,\n-                                        uint worker_id) const {\n+                                                          HeapRegionClaimer* hr_claimer,\n+                                                          const uint* regions,\n+                                                          size_t offset,\n+                                                          size_t length,\n+                                                          uint worker_id) const {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1210,3 +1210,3 @@\n-  \/\/ Iterate the part of a regions array given by the offset and length applying the given\n-  \/\/ HeapRegionClosure. The worker_id will determine where in the part to start the iteration\n-  \/\/ to allow for more efficient parallel iteration.\n+  \/\/ Iterate part of an array of region indexes given by offset and length, applying\n+  \/\/ the given HeapRegionClosure on each region. The worker_id will determine where\n+  \/\/ in the part to start the iteration to allow for more efficient parallel iteration.\n@@ -1214,5 +1214,5 @@\n-                                   HeapRegionClaimer* hr_claimer,\n-                                   const uint* regions,\n-                                   size_t offset,\n-                                   size_t length,\n-                                   uint worker_id) const;\n+                                           HeapRegionClaimer* hr_claimer,\n+                                           const uint* regions,\n+                                           size_t offset,\n+                                           size_t length,\n+                                           uint worker_id) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/g1\/g1EvacFailureRegions.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -275,1 +275,1 @@\n-  \/\/ Iterates through only the regions recorded as evacuation failure.\n+  \/\/ Iterate through all regions that failed evacuation during the entire collection.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.hpp\"\n@@ -53,5 +53,5 @@\n-                                                        _hrclaimer,\n-                                                        _evac_failure_regions,\n-                                                        0,\n-                                                        Atomic::load(&_evac_failure_regions_cur_length),\n-                                                        worker_id);\n+                                                               _hrclaimer,\n+                                                               _evac_failure_regions,\n+                                                               0,\n+                                                               Atomic::load(&_evac_failure_regions_cur_length),\n+                                                               worker_id);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n-#include \"utilities\/bitMap.inline.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"utilities\/bitMap.hpp\"\n@@ -62,10 +63,1 @@\n-  bool record(uint region_idx) {\n-    assert(region_idx < _max_regions, \"must be\");\n-    bool success = _regions_failed_evacuation.par_set_bit(region_idx,\n-                                                          memory_order_relaxed);\n-    if (success) {\n-      size_t offset = Atomic::fetch_and_add(&_evac_failure_regions_cur_length, 1u);\n-      _evac_failure_regions[offset] = region_idx;\n-    }\n-    return success;\n-  }\n+  inline bool record(uint region_idx);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.hpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2021, Huawei Technologies Co. Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1EVACFAILUREREGIONS_INLINE_HPP\n+#define SHARE_GC_G1_G1EVACFAILUREREGIONS_INLINE_HPP\n+\n+#include \"gc\/g1\/g1EvacFailureRegions.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"utilities\/bitMap.inline.hpp\"\n+\n+bool G1EvacFailureRegions::record(uint region_idx) {\n+  assert(region_idx < _max_regions, \"must be\");\n+  bool success = _regions_failed_evacuation.par_set_bit(region_idx,\n+                                                        memory_order_relaxed);\n+  if (success) {\n+    size_t offset = Atomic::fetch_and_add(&_evac_failure_regions_cur_length, 1u);\n+    _evac_failure_regions[offset] = region_idx;\n+  }\n+  return success;\n+}\n+\n+#endif \/\/SHARE_GC_G1_G1EVACFAILUREREGIONS_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.inline.hpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"}]}