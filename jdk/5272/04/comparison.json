{"files":[{"patch":"@@ -1481,2 +1481,0 @@\n-  _num_regions_failed_evacuation(0),\n-  _regions_failed_evacuation(mtGC),\n@@ -1763,1 +1761,1 @@\n-  _regions_failed_evacuation.resize(max_regions());\n+  _evac_failure_regions.initialize(max_reserved_regions());\n@@ -3519,2 +3517,0 @@\n-  Atomic::store(&_num_regions_failed_evacuation, 0u);\n-\n@@ -3538,1 +3534,1 @@\n-  _regions_failed_evacuation.clear();\n+  _evac_failure_regions.reset();\n@@ -3910,1 +3906,1 @@\n-    G1PostEvacuateCollectionSetCleanupTask1 cl(per_thread_states);\n+    G1PostEvacuateCollectionSetCleanupTask1 cl(per_thread_states, &_evac_failure_regions);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"gc\/g1\/g1EvacFailureRegions.hpp\"\n@@ -874,4 +875,1 @@\n-  \/\/ Number of regions evacuation failed in the current collection.\n-  volatile uint _num_regions_failed_evacuation;\n-  \/\/ Records for every region on the heap whether evacuation failed for it.\n-  CHeapBitMap _regions_failed_evacuation;\n+  G1EvacFailureRegions _evac_failure_regions;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -199,1 +199,1 @@\n-  return _regions_failed_evacuation.par_at(region_idx, memory_order_relaxed);\n+  return _evac_failure_regions.contains(region_idx);\n@@ -203,1 +203,1 @@\n-  return Atomic::load(&_num_regions_failed_evacuation);\n+  return _evac_failure_regions.num_regions_failed_evacuation();\n@@ -207,5 +207,1 @@\n-  bool result = _regions_failed_evacuation.par_set_bit(region_idx, memory_order_relaxed);\n-  if (result) {\n-    Atomic::inc(&_num_regions_failed_evacuation, memory_order_relaxed);\n-  }\n-  return result;\n+  return _evac_failure_regions.record(region_idx);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/g1\/g1EvacFailureRegions.hpp\"\n@@ -262,1 +263,2 @@\n-G1ParRemoveSelfForwardPtrsTask::G1ParRemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs) :\n+G1ParRemoveSelfForwardPtrsTask::G1ParRemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs,\n+                                                               G1EvacFailureRegions* evac_failure_regions) :\n@@ -267,0 +269,1 @@\n+  _evac_failure_regions(evac_failure_regions),\n@@ -272,6 +275,2 @@\n-  \/\/ We need to check all collection set regions whether they need self forward\n-  \/\/ removals, not only the last collection set increment. The reason is that\n-  \/\/ reference processing (e.g. finalizers) can make it necessary to resurrect an\n-  \/\/ otherwise unreachable object at the very end of the collection. That object\n-  \/\/ might cause an evacuation failure in any region in the collection set.\n-  _g1h->collection_set_par_iterate_all(&rsfp_cl, &_hrclaimer, worker_id);\n+  \/\/ Iterates through only the regions recorded as evacuation failure.\n+  _evac_failure_regions->par_iterate(&rsfp_cl, &_hrclaimer, worker_id);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+class G1EvacFailureRegions;\n@@ -44,0 +45,1 @@\n+  G1EvacFailureRegions* _evac_failure_regions;\n@@ -47,1 +49,1 @@\n-  G1ParRemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs);\n+  G1ParRemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs, G1EvacFailureRegions* evac_failure_regions);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2021, Huawei Technologies Co. Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n+#include \"gc\/g1\/g1EvacFailureRegions.hpp\"\n+#include \"gc\/g1\/heapRegion.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+\n+\n+G1EvacFailureRegions::G1EvacFailureRegions() :\n+  _regions_failed_evacuation(mtGC) {\n+}\n+\n+G1EvacFailureRegions::~G1EvacFailureRegions() {\n+  FREE_C_HEAP_ARRAY(uint, _evac_failure_regions);\n+}\n+\n+void G1EvacFailureRegions::initialize(uint max_regions) {\n+  Atomic::store(&_evac_failure_regions_cur_length, 0u);\n+  _max_regions = max_regions;\n+  _regions_failed_evacuation.resize(_max_regions);\n+  _evac_failure_regions = NEW_C_HEAP_ARRAY(uint, _max_regions, mtGC);\n+}\n+\n+void G1EvacFailureRegions::par_iterate(HeapRegionClosure* closure,\n+                                       HeapRegionClaimer* _hrclaimer,\n+                                       uint worker_id) {\n+  assert_at_safepoint();\n+  size_t length = Atomic::load(&_evac_failure_regions_cur_length);\n+  if (length == 0) {\n+    return;\n+  }\n+\n+  uint total_workers = G1CollectedHeap::heap()->workers()->active_workers();\n+  size_t start_pos = (worker_id * length) \/ total_workers;\n+  size_t cur_pos = start_pos;\n+\n+  do {\n+    uint region_idx = _evac_failure_regions[cur_pos];\n+    if (_hrclaimer == NULL || _hrclaimer->claim_region(region_idx)) {\n+      HeapRegion* r = G1CollectedHeap::heap()->region_at(region_idx);\n+      bool result = closure->do_heap_region(r);\n+      guarantee(!result, \"Must not cancel iteration\");\n+    }\n+\n+    cur_pos++;\n+    if (cur_pos == length) {\n+      cur_pos = 0;\n+    }\n+  } while (cur_pos != start_pos);\n+}\n+\n+void G1EvacFailureRegions::reset() {\n+  Atomic::store(&_evac_failure_regions_cur_length, 0u);\n+  _regions_failed_evacuation.clear();\n+}\n+\n+bool G1EvacFailureRegions::contains(uint region_idx) const {\n+  assert(region_idx < _max_regions, \"must be\");\n+  return _regions_failed_evacuation.par_at(region_idx, memory_order_relaxed);\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.cpp","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2021, Huawei Technologies Co. Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1EVACFAILUREREGIONS_HPP\n+#define SHARE_GC_G1_G1EVACFAILUREREGIONS_HPP\n+\n+#include \"utilities\/bitMap.inline.hpp\"\n+\n+class HeapRegionClosure;\n+class HeapRegionClaimer;\n+\n+\/\/ This class records for every region on the heap whether evacuation failed for it,\n+\/\/ and records for every evacuation failure region to speed up iteration of these\n+\/\/ regions in post evacuation phase.\n+class G1EvacFailureRegions {\n+  \/\/ Records for every region on the heap whether evacuation failed for it.\n+  CHeapBitMap _regions_failed_evacuation;\n+  \/\/ Regions (index) of evacuation failed in the current collection.\n+  uint* _evac_failure_regions;\n+  \/\/ Number of regions evacuation failed in the current collection.\n+  volatile uint _evac_failure_regions_cur_length;\n+  \/\/ Maximum of regions number.\n+  uint _max_regions;\n+\n+public:\n+  G1EvacFailureRegions();\n+  ~G1EvacFailureRegions();\n+  void initialize(uint max_regions);\n+\n+  void reset();\n+\n+  bool contains(uint region_idx) const;\n+  void par_iterate(HeapRegionClosure* closure,\n+                   HeapRegionClaimer* _hrclaimer,\n+                   uint worker_id);\n+\n+  uint num_regions_failed_evacuation() const {\n+    return Atomic::load(&_evac_failure_regions_cur_length);\n+  }\n+\n+  bool record(uint region_idx) {\n+    assert(region_idx < _max_regions, \"must be\");\n+    bool success = _regions_failed_evacuation.par_set_bit(region_idx,\n+                                                          memory_order_relaxed);\n+    if (success) {\n+      size_t offset = Atomic::fetch_and_add(&_evac_failure_regions_cur_length, 1u);\n+      _evac_failure_regions[offset] = region_idx;\n+    }\n+    return success;\n+  }\n+};\n+\n+#endif \/\/SHARE_GC_G1_G1EVACFAILUREREGIONS_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.hpp","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -41,1 +41,2 @@\n-G1PostEvacuateCollectionSetCleanupTask1::G1PostEvacuateCollectionSetCleanupTask1(G1ParScanThreadStateSet* per_thread_states) :\n+G1PostEvacuateCollectionSetCleanupTask1::G1PostEvacuateCollectionSetCleanupTask1(G1ParScanThreadStateSet* per_thread_states,\n+                                                                                 G1EvacFailureRegions* evac_failure_regions) :\n@@ -50,1 +51,1 @@\n-    add_parallel_task(new RemoveSelfForwardPtrsTask(per_thread_states->rdcqs()));\n+    add_parallel_task(new RemoveSelfForwardPtrsTask(per_thread_states->rdcqs(), evac_failure_regions));\n@@ -102,2 +103,5 @@\n-G1PostEvacuateCollectionSetCleanupTask1::RemoveSelfForwardPtrsTask::RemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs) :\n-  G1AbstractSubTask(G1GCPhaseTimes::RemoveSelfForwardingPtr), _task(rdcqs) { }\n+G1PostEvacuateCollectionSetCleanupTask1::\n+    RemoveSelfForwardPtrsTask::RemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs,\n+                                                         G1EvacFailureRegions* evac_failure_regions) :\n+  G1AbstractSubTask(G1GCPhaseTimes::RemoveSelfForwardingPtr),\n+  _task(rdcqs, evac_failure_regions) { }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+class G1EvacFailureRegions;\n@@ -51,1 +52,2 @@\n-  G1PostEvacuateCollectionSetCleanupTask1(G1ParScanThreadStateSet* per_thread_states);\n+  G1PostEvacuateCollectionSetCleanupTask1(G1ParScanThreadStateSet* per_thread_states,\n+                                          G1EvacFailureRegions* evac_failure_regions);\n@@ -86,1 +88,1 @@\n-  RemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs);\n+  RemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs, G1EvacFailureRegions* evac_failure_regions);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}