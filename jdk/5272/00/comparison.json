{"files":[{"patch":"@@ -1478,2 +1478,0 @@\n-  _num_regions_failed_evacuation(0),\n-  _regions_failed_evacuation(mtGC),\n@@ -1774,1 +1772,1 @@\n-  _regions_failed_evacuation.resize(max_regions());\n+  _evac_failure_regions.initialize();\n@@ -3134,0 +3132,6 @@\n+void G1CollectedHeap::iterate_evacuation_failure_regions_par(HeapRegionClosure* closure,\n+                                                             HeapRegionClaimer* claimer,\n+                                                             uint worker_id) {\n+  _evac_failure_regions.par_iterate(closure, claimer, worker_id);\n+}\n+\n@@ -3516,2 +3520,0 @@\n-  Atomic::store(&_num_regions_failed_evacuation, 0u);\n-\n@@ -3535,1 +3537,1 @@\n-  _regions_failed_evacuation.clear();\n+  _evac_failure_regions.reset();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"gc\/g1\/g1EvacuationFailureRegions.hpp\"\n@@ -877,4 +878,1 @@\n-  \/\/ Number of regions evacuation failed in the current collection.\n-  volatile uint _num_regions_failed_evacuation;\n-  \/\/ Records for every region on the heap whether evacuation failed for it.\n-  CHeapBitMap _regions_failed_evacuation;\n+  G1EvacuationFailureRegions _evac_failure_regions;\n@@ -890,0 +888,4 @@\n+  void iterate_evacuation_failure_regions_par(HeapRegionClosure* closure,\n+                                              HeapRegionClaimer* claimer,\n+                                              uint worker_id);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -199,1 +199,1 @@\n-  return _regions_failed_evacuation.par_at(region_idx, memory_order_relaxed);\n+  return _evac_failure_regions.contains(region_idx);\n@@ -203,1 +203,1 @@\n-  return Atomic::load(&_num_regions_failed_evacuation);\n+  return _evac_failure_regions.num_regions_failed_evacuation();\n@@ -207,5 +207,1 @@\n-  bool result = _regions_failed_evacuation.par_set_bit(region_idx, memory_order_relaxed);\n-  if (result) {\n-    Atomic::inc(&_num_regions_failed_evacuation, memory_order_relaxed);\n-  }\n-  return result;\n+  return _evac_failure_regions.record(region_idx);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -277,1 +277,2 @@\n-  _g1h->collection_set_par_iterate_all(&rsfp_cl, &_hrclaimer, worker_id);\n+  \/\/ _g1h->collection_set_par_iterate_all(&rsfp_cl, &_hrclaimer, worker_id);\n+  _g1h->iterate_evacuation_failure_regions_par(&rsfp_cl, &_hrclaimer, worker_id);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2021, Huawei and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"g1EvacuationFailureRegions.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n+#include \"gc\/g1\/heapRegion.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+\n+\n+uintx G1EvacuationFailureRegions::HashTableConfig::get_hash(Value const& value, bool* is_dead) {\n+  *is_dead = false;\n+  return value;\n+}\n+\n+void* G1EvacuationFailureRegions::HashTableConfig::allocate_node(void* context, size_t size, Value const& value) {\n+  return AllocateHeap(size, mtGC);\n+}\n+\n+void G1EvacuationFailureRegions::HashTableConfig::free_node(void* context, void* memory, Value const& value) {\n+  FreeHeap(memory);\n+}\n+\n+G1EvacuationFailureRegions::G1EvacuationFailureRegions() {\n+}\n+\n+G1EvacuationFailureRegions::~G1EvacuationFailureRegions() {\n+  FREE_C_HEAP_ARRAY(uint, _evac_failure_regions);\n+  delete _table;\n+}\n+\n+void G1EvacuationFailureRegions::initialize() {\n+  Atomic::store(&_evac_failure_regions_cur_length, 0u);\n+  _table = new HashTable();\n+  _evac_failure_regions = NEW_C_HEAP_ARRAY(uint, G1CollectedHeap::heap()->max_reserved_regions(), mtGC);\n+}\n+\n+void G1EvacuationFailureRegions::par_iterate(HeapRegionClosure* closure, HeapRegionClaimer* _hrclaimer, uint worker_id) {\n+  assert_at_safepoint();\n+  size_t length = Atomic::load(&_evac_failure_regions_cur_length);\n+  if (length == 0) {\n+    return;\n+  }\n+\n+  uint total_workers = G1CollectedHeap::heap()->workers()->active_workers();\n+  size_t start_pos = (worker_id * length) \/ total_workers;\n+  size_t cur_pos = start_pos;\n+\n+  do {\n+    uint region_idx = _evac_failure_regions[cur_pos];\n+    if (_hrclaimer == NULL || _hrclaimer->claim_region(region_idx)) {\n+      HeapRegion* r = G1CollectedHeap::heap()->region_at(region_idx);\n+      bool result = closure->do_heap_region(r);\n+      guarantee(!result, \"Must not cancel iteration\");\n+    }\n+\n+    cur_pos++;\n+    if (cur_pos == length) {\n+      cur_pos = 0;\n+    }\n+  } while (cur_pos != start_pos);\n+}\n+\n+void G1EvacuationFailureRegions::reset() {\n+  Atomic::store(&_evac_failure_regions_cur_length, 0u);\n+  delete _table;\n+  _table = new HashTable();\n+}\n+\n+static void found_func(uint* region_idx) { }\n+\n+bool G1EvacuationFailureRegions::contains(uint region_idx) const {\n+  HashTableLookUp lookup(region_idx);\n+  return _table->get(Thread::current(), lookup, found_func);\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacuationFailureRegions.cpp","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2021, Huawei and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1EVACUATIONFAILUREREGIONS_HPP\n+#define SHARE_GC_G1_G1EVACUATIONFAILUREREGIONS_HPP\n+\n+#include \"utilities\/concurrentHashTable.hpp\"\n+#include \"utilities\/concurrentHashTable.inline.hpp\"\n+\n+class HeapRegionClosure;\n+class HeapRegionClaimer;\n+\n+class G1EvacuationFailureRegions {\n+\n+  class HashTableConfig : public StackObj {\n+  public:\n+    using Value = uint;\n+\n+    static uintx get_hash(Value const& value, bool* is_dead);\n+    static void* allocate_node(void* context, size_t size, Value const& value);\n+    static void free_node(void* context, void* memory, Value const& value);\n+  };\n+\n+  class HashTableLookUp : public StackObj {\n+    uint _region_idx;\n+  public:\n+    using Value = uint;\n+    explicit HashTableLookUp(uint region_idx) : _region_idx(region_idx) { }\n+\n+    \/\/ TODO: refine it?\n+    uintx get_hash() const { return _region_idx; }\n+\n+    bool equals(Value* value, bool* is_dead) {\n+      *is_dead = false;\n+      return *value == _region_idx;\n+    }\n+  };\n+\n+  typedef ConcurrentHashTable<HashTableConfig, mtSymbol> HashTable;\n+\n+  HashTable* _table;\n+  uint* _evac_failure_regions;\n+  volatile uint _evac_failure_regions_cur_length;\n+\n+public:\n+  G1EvacuationFailureRegions();\n+  ~G1EvacuationFailureRegions();\n+  void initialize();\n+\n+  bool record(uint region_idx) {\n+    HashTableLookUp lookup(region_idx);\n+    bool success = _table->insert(Thread::current(), lookup, region_idx);\n+    if (success) {\n+      size_t offset = Atomic::fetch_and_add(&_evac_failure_regions_cur_length, 1u);\n+      _evac_failure_regions[offset] = region_idx;\n+    }\n+    return success;\n+  }\n+  void par_iterate(HeapRegionClosure* closure, HeapRegionClaimer* _hrclaimer, uint worker_id);\n+  void reset();\n+  bool contains(uint region_idx) const;\n+  uint num_regions_failed_evacuation() const {\n+    return Atomic::load(&_evac_failure_regions_cur_length);\n+  }\n+};\n+\n+\n+#endif \/\/SHARE_GC_G1_G1EVACUATIONFAILUREREGIONS_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacuationFailureRegions.hpp","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"}]}