{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Huawei and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Huawei Technologies Co. Ltd. All rights reserved.\n@@ -33,14 +33,2 @@\n-uintx G1EvacuationFailureRegions::HashTableConfig::get_hash(Value const& value, bool* is_dead) {\n-  *is_dead = false;\n-  return value;\n-}\n-\n-void* G1EvacuationFailureRegions::HashTableConfig::allocate_node(void* context, size_t size, Value const& value) {\n-  return AllocateHeap(size, mtGC);\n-}\n-\n-void G1EvacuationFailureRegions::HashTableConfig::free_node(void* context, void* memory, Value const& value) {\n-  FreeHeap(memory);\n-}\n-\n-G1EvacuationFailureRegions::G1EvacuationFailureRegions() {\n+G1EvacuationFailureRegions::G1EvacuationFailureRegions() :\n+  _regions_failed_evacuation(mtGC) {\n@@ -51,1 +39,0 @@\n-  delete _table;\n@@ -56,2 +43,3 @@\n-  _table = new HashTable();\n-  _evac_failure_regions = NEW_C_HEAP_ARRAY(uint, G1CollectedHeap::heap()->max_reserved_regions(), mtGC);\n+  _max_regions = G1CollectedHeap::heap()->max_reserved_regions();\n+  _regions_failed_evacuation.resize(_max_regions);\n+  _evac_failure_regions = NEW_C_HEAP_ARRAY(uint, _max_regions, mtGC);\n@@ -60,1 +48,3 @@\n-void G1EvacuationFailureRegions::par_iterate(HeapRegionClosure* closure, HeapRegionClaimer* _hrclaimer, uint worker_id) {\n+void G1EvacuationFailureRegions::par_iterate(HeapRegionClosure* closure,\n+                                             HeapRegionClaimer* _hrclaimer,\n+                                             uint worker_id) {\n@@ -88,2 +78,1 @@\n-  delete _table;\n-  _table = new HashTable();\n+  _regions_failed_evacuation.clear();\n@@ -92,2 +81,0 @@\n-static void found_func(uint* region_idx) { }\n-\n@@ -95,3 +82,2 @@\n-  HashTableLookUp lookup(region_idx);\n-  return _table->get(Thread::current(), lookup, found_func);\n-  return false;\n+  assert(region_idx < _max_regions, \"must be\");\n+  return _regions_failed_evacuation.par_at(region_idx, memory_order_relaxed);\n@@ -99,1 +85,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacuationFailureRegions.cpp","additions":12,"deletions":27,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Huawei and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Huawei Technologies Co. Ltd. All rights reserved.\n@@ -28,3 +28,0 @@\n-#include \"utilities\/concurrentHashTable.hpp\"\n-#include \"utilities\/concurrentHashTable.inline.hpp\"\n-\n@@ -34,0 +31,4 @@\n+\/\/ This class\n+\/\/     1. records for every region on the heap whether evacuation failed for it.\n+\/\/     2. records for every evacuation failure region to speed up\n+\/\/        iteration of these regions in post evacuation phase.\n@@ -36,27 +37,2 @@\n-  class HashTableConfig : public StackObj {\n-  public:\n-    using Value = uint;\n-\n-    static uintx get_hash(Value const& value, bool* is_dead);\n-    static void* allocate_node(void* context, size_t size, Value const& value);\n-    static void free_node(void* context, void* memory, Value const& value);\n-  };\n-\n-  class HashTableLookUp : public StackObj {\n-    uint _region_idx;\n-  public:\n-    using Value = uint;\n-    explicit HashTableLookUp(uint region_idx) : _region_idx(region_idx) { }\n-\n-    \/\/ TODO: refine it?\n-    uintx get_hash() const { return _region_idx; }\n-\n-    bool equals(Value* value, bool* is_dead) {\n-      *is_dead = false;\n-      return *value == _region_idx;\n-    }\n-  };\n-\n-  typedef ConcurrentHashTable<HashTableConfig, mtSymbol> HashTable;\n-\n-  HashTable* _table;\n+private:\n+  CHeapBitMap _regions_failed_evacuation;\n@@ -65,0 +41,1 @@\n+  uint _max_regions;\n@@ -70,0 +47,9 @@\n+  void reset();\n+  bool contains(uint region_idx) const;\n+  void par_iterate(HeapRegionClosure* closure,\n+                   HeapRegionClaimer* _hrclaimer,\n+                   uint worker_id);\n+\n+  uint num_regions_failed_evacuation() const {\n+    return Atomic::load(&_evac_failure_regions_cur_length);\n+  }\n@@ -72,2 +58,3 @@\n-    HashTableLookUp lookup(region_idx);\n-    bool success = _table->insert(Thread::current(), lookup, region_idx);\n+    assert(region_idx < _max_regions, \"must be\");\n+    bool success = _regions_failed_evacuation.par_set_bit(region_idx,\n+                                                          memory_order_relaxed);\n@@ -80,6 +67,0 @@\n-  void par_iterate(HeapRegionClosure* closure, HeapRegionClaimer* _hrclaimer, uint worker_id);\n-  void reset();\n-  bool contains(uint region_idx) const;\n-  uint num_regions_failed_evacuation() const {\n-    return Atomic::load(&_evac_failure_regions_cur_length);\n-  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacuationFailureRegions.hpp","additions":20,"deletions":39,"binary":false,"changes":59,"status":"modified"}]}