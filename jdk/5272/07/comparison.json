{"files":[{"patch":"@@ -1477,2 +1477,0 @@\n-  _num_regions_failed_evacuation(0),\n-  _regions_failed_evacuation(mtGC),\n@@ -1759,1 +1757,1 @@\n-  _regions_failed_evacuation.resize(max_regions());\n+  _evac_failure_regions.initialize(max_reserved_regions());\n@@ -2320,1 +2318,1 @@\n-  _collection_set.par_iterate(cl, hr_claimer, worker_id, workers()->active_workers());\n+  _collection_set.par_iterate(cl, hr_claimer, worker_id);\n@@ -2324,1 +2322,31 @@\n-  _collection_set.iterate_incremental_part_from(cl, hr_claimer, worker_id, workers()->active_workers());\n+  _collection_set.iterate_incremental_part_from(cl, hr_claimer, worker_id);\n+}\n+\n+void G1CollectedHeap::par_iterate_regions_array_part_from(HeapRegionClosure* cl,\n+                                                          HeapRegionClaimer* hr_claimer,\n+                                                          const uint* regions,\n+                                                          size_t offset,\n+                                                          size_t length,\n+                                                          uint worker_id) const {\n+  assert_at_safepoint();\n+  if (length == 0) {\n+    return;\n+  }\n+  uint total_workers = workers()->active_workers();\n+\n+  size_t start_pos = (worker_id * length) \/ total_workers;\n+  size_t cur_pos = start_pos;\n+\n+  do {\n+    uint region_idx = regions[cur_pos + offset];\n+    if (hr_claimer == NULL || hr_claimer->claim_region(region_idx)) {\n+      HeapRegion* r = region_at(region_idx);\n+      bool result = cl->do_heap_region(r);\n+      guarantee(!result, \"Must not cancel iteration\");\n+    }\n+\n+    cur_pos++;\n+    if (cur_pos == length) {\n+      cur_pos = 0;\n+    }\n+  } while (cur_pos != start_pos);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":33,"deletions":5,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/g1\/g1EvacFailureRegions.hpp\"\n@@ -833,4 +834,1 @@\n-  \/\/ Number of regions evacuation failed in the current collection.\n-  volatile uint _num_regions_failed_evacuation;\n-  \/\/ Records for every region on the heap whether evacuation failed for it.\n-  CHeapBitMap _regions_failed_evacuation;\n+  G1EvacFailureRegions _evac_failure_regions;\n@@ -1170,0 +1168,9 @@\n+  \/\/ Iterate part of an array of region indexes given by offset and length, applying\n+  \/\/ the given HeapRegionClosure on each region. The worker_id will determine where\n+  \/\/ in the part to start the iteration to allow for more efficient parallel iteration.\n+  void par_iterate_regions_array_part_from(HeapRegionClosure* cl,\n+                                           HeapRegionClaimer* hr_claimer,\n+                                           const uint* regions,\n+                                           size_t offset,\n+                                           size_t length,\n+                                           uint worker_id) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/g1\/g1EvacFailureRegions.inline.hpp\"\n@@ -208,1 +209,1 @@\n-  return _regions_failed_evacuation.par_at(region_idx, memory_order_relaxed);\n+  return _evac_failure_regions.contains(region_idx);\n@@ -212,1 +213,1 @@\n-  return Atomic::load(&_num_regions_failed_evacuation);\n+  return _evac_failure_regions.num_regions_failed_evacuation();\n@@ -216,5 +217,1 @@\n-  bool result = _regions_failed_evacuation.par_set_bit(region_idx, memory_order_relaxed);\n-  if (result) {\n-    Atomic::inc(&_num_regions_failed_evacuation, memory_order_relaxed);\n-  }\n-  return result;\n+  return _evac_failure_regions.record(region_idx);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -210,3 +210,2 @@\n-                                  uint worker_id,\n-                                  uint total_workers) const {\n-  iterate_part_from(cl, hr_claimer, 0, cur_length(), worker_id, total_workers);\n+                                  uint worker_id) const {\n+  iterate_part_from(cl, hr_claimer, 0, cur_length(), worker_id);\n@@ -227,3 +226,2 @@\n-                                                    uint worker_id,\n-                                                    uint total_workers) const {\n-  iterate_part_from(cl, hr_claimer, _inc_part_start, increment_length(), worker_id, total_workers);\n+                                                    uint worker_id) const {\n+  iterate_part_from(cl, hr_claimer, _inc_part_start, increment_length(), worker_id);\n@@ -236,23 +234,2 @@\n-                                        uint worker_id,\n-                                        uint total_workers) const {\n-  assert_at_safepoint();\n-  if (length == 0) {\n-    return;\n-  }\n-\n-  size_t start_pos = (worker_id * length) \/ total_workers;\n-  size_t cur_pos = start_pos;\n-\n-  do {\n-    uint region_idx = _collection_set_regions[cur_pos + offset];\n-    if (hr_claimer == NULL || hr_claimer->claim_region(region_idx)) {\n-      HeapRegion* r = _g1h->region_at(region_idx);\n-      bool result = cl->do_heap_region(r);\n-      guarantee(!result, \"Must not cancel iteration\");\n-    }\n-\n-    cur_pos++;\n-    if (cur_pos == length) {\n-      cur_pos = 0;\n-    }\n-  } while (cur_pos != start_pos);\n+                                        uint worker_id) const {\n+  _g1h->par_iterate_regions_array_part_from(cl, hr_claimer, _collection_set_regions, offset, length, worker_id);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":6,"deletions":29,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -265,2 +265,1 @@\n-                         uint worker_id,\n-                         uint total_workers) const;\n+                         uint worker_id) const;\n@@ -310,1 +309,1 @@\n-  void iterate_incremental_part_from(HeapRegionClosure* cl, HeapRegionClaimer* hr_claimer, uint worker_id, uint total_workers) const;\n+  void iterate_incremental_part_from(HeapRegionClosure* cl, HeapRegionClaimer* hr_claimer, uint worker_id) const;\n@@ -322,2 +321,1 @@\n-                   uint worker_id,\n-                   uint total_workers) const;\n+                   uint worker_id) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/g1\/g1EvacFailureRegions.hpp\"\n@@ -262,1 +263,2 @@\n-G1ParRemoveSelfForwardPtrsTask::G1ParRemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs) :\n+G1ParRemoveSelfForwardPtrsTask::G1ParRemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs,\n+                                                               G1EvacFailureRegions* evac_failure_regions) :\n@@ -267,0 +269,1 @@\n+  _evac_failure_regions(evac_failure_regions),\n@@ -272,6 +275,2 @@\n-  \/\/ We need to check all collection set regions whether they need self forward\n-  \/\/ removals, not only the last collection set increment. The reason is that\n-  \/\/ reference processing (e.g. finalizers) can make it necessary to resurrect an\n-  \/\/ otherwise unreachable object at the very end of the collection. That object\n-  \/\/ might cause an evacuation failure in any region in the collection set.\n-  _g1h->collection_set_par_iterate_all(&rsfp_cl, &_hrclaimer, worker_id);\n+  \/\/ Iterate through all regions that failed evacuation during the entire collection.\n+  _evac_failure_regions->par_iterate(&rsfp_cl, &_hrclaimer, worker_id);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+class G1EvacFailureRegions;\n@@ -44,0 +45,1 @@\n+  G1EvacFailureRegions* _evac_failure_regions;\n@@ -47,1 +49,1 @@\n-  G1ParRemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs);\n+  G1ParRemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs, G1EvacFailureRegions* evac_failure_regions);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2021, Huawei Technologies Co. Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/g1\/g1CollectedHeap.hpp\"\n+#include \"gc\/g1\/g1EvacFailureRegions.hpp\"\n+#include \"gc\/g1\/heapRegion.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+\n+\n+G1EvacFailureRegions::G1EvacFailureRegions() :\n+  _regions_failed_evacuation(mtGC) {\n+}\n+\n+G1EvacFailureRegions::~G1EvacFailureRegions() {\n+  FREE_C_HEAP_ARRAY(uint, _evac_failure_regions);\n+}\n+\n+void G1EvacFailureRegions::initialize(uint max_regions) {\n+  Atomic::store(&_evac_failure_regions_cur_length, 0u);\n+  _max_regions = max_regions;\n+  _regions_failed_evacuation.resize(_max_regions);\n+  _evac_failure_regions = NEW_C_HEAP_ARRAY(uint, _max_regions, mtGC);\n+}\n+\n+void G1EvacFailureRegions::par_iterate(HeapRegionClosure* closure,\n+                                       HeapRegionClaimer* _hrclaimer,\n+                                       uint worker_id) {\n+  G1CollectedHeap::heap()->par_iterate_regions_array_part_from(closure,\n+                                                               _hrclaimer,\n+                                                               _evac_failure_regions,\n+                                                               0,\n+                                                               Atomic::load(&_evac_failure_regions_cur_length),\n+                                                               worker_id);\n+}\n+\n+void G1EvacFailureRegions::reset() {\n+  Atomic::store(&_evac_failure_regions_cur_length, 0u);\n+  _regions_failed_evacuation.clear();\n+}\n+\n+bool G1EvacFailureRegions::contains(uint region_idx) const {\n+  assert(region_idx < _max_regions, \"must be\");\n+  return _regions_failed_evacuation.par_at(region_idx, memory_order_relaxed);\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.cpp","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2021, Huawei Technologies Co. Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1EVACFAILUREREGIONS_HPP\n+#define SHARE_GC_G1_G1EVACFAILUREREGIONS_HPP\n+\n+#include \"runtime\/atomic.hpp\"\n+#include \"utilities\/bitMap.hpp\"\n+\n+class HeapRegionClosure;\n+class HeapRegionClaimer;\n+\n+\/\/ This class records for every region on the heap whether evacuation failed for it,\n+\/\/ and records for every evacuation failure region to speed up iteration of these\n+\/\/ regions in post evacuation phase.\n+class G1EvacFailureRegions {\n+  \/\/ Records for every region on the heap whether evacuation failed for it.\n+  CHeapBitMap _regions_failed_evacuation;\n+  \/\/ Regions (index) of evacuation failed in the current collection.\n+  uint* _evac_failure_regions;\n+  \/\/ Number of regions evacuation failed in the current collection.\n+  volatile uint _evac_failure_regions_cur_length;\n+  \/\/ Maximum of regions number.\n+  uint _max_regions;\n+\n+public:\n+  G1EvacFailureRegions();\n+  ~G1EvacFailureRegions();\n+  void initialize(uint max_regions);\n+\n+  void reset();\n+\n+  bool contains(uint region_idx) const;\n+  void par_iterate(HeapRegionClosure* closure,\n+                   HeapRegionClaimer* _hrclaimer,\n+                   uint worker_id);\n+\n+  uint num_regions_failed_evacuation() const {\n+    return Atomic::load(&_evac_failure_regions_cur_length);\n+  }\n+\n+  inline bool record(uint region_idx);\n+};\n+\n+#endif \/\/SHARE_GC_G1_G1EVACFAILUREREGIONS_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.hpp","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2021, Huawei Technologies Co. Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1EVACFAILUREREGIONS_INLINE_HPP\n+#define SHARE_GC_G1_G1EVACFAILUREREGIONS_INLINE_HPP\n+\n+#include \"gc\/g1\/g1EvacFailureRegions.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"utilities\/bitMap.inline.hpp\"\n+\n+bool G1EvacFailureRegions::record(uint region_idx) {\n+  assert(region_idx < _max_regions, \"must be\");\n+  bool success = _regions_failed_evacuation.par_set_bit(region_idx,\n+                                                        memory_order_relaxed);\n+  if (success) {\n+    size_t offset = Atomic::fetch_and_add(&_evac_failure_regions_cur_length, 1u);\n+    _evac_failure_regions[offset] = region_idx;\n+  }\n+  return success;\n+}\n+\n+#endif \/\/SHARE_GC_G1_G1EVACFAILUREREGIONS_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.inline.hpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -42,1 +42,2 @@\n-G1PostEvacuateCollectionSetCleanupTask1::G1PostEvacuateCollectionSetCleanupTask1(G1ParScanThreadStateSet* per_thread_states) :\n+G1PostEvacuateCollectionSetCleanupTask1::G1PostEvacuateCollectionSetCleanupTask1(G1ParScanThreadStateSet* per_thread_states,\n+                                                                                 G1EvacFailureRegions* evac_failure_regions) :\n@@ -51,1 +52,1 @@\n-    add_parallel_task(new RemoveSelfForwardPtrsTask(per_thread_states->rdcqs()));\n+    add_parallel_task(new RemoveSelfForwardPtrsTask(per_thread_states->rdcqs(), evac_failure_regions));\n@@ -103,2 +104,5 @@\n-G1PostEvacuateCollectionSetCleanupTask1::RemoveSelfForwardPtrsTask::RemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs) :\n-  G1AbstractSubTask(G1GCPhaseTimes::RemoveSelfForwardingPtr), _task(rdcqs) { }\n+G1PostEvacuateCollectionSetCleanupTask1::\n+    RemoveSelfForwardPtrsTask::RemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs,\n+                                                         G1EvacFailureRegions* evac_failure_regions) :\n+  G1AbstractSubTask(G1GCPhaseTimes::RemoveSelfForwardingPtr),\n+  _task(rdcqs, evac_failure_regions) { }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+class G1EvacFailureRegions;\n@@ -51,1 +52,2 @@\n-  G1PostEvacuateCollectionSetCleanupTask1(G1ParScanThreadStateSet* per_thread_states);\n+  G1PostEvacuateCollectionSetCleanupTask1(G1ParScanThreadStateSet* per_thread_states,\n+                                          G1EvacFailureRegions* evac_failure_regions);\n@@ -86,1 +88,1 @@\n-  RemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs);\n+  RemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs, G1EvacFailureRegions* evac_failure_regions);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}