{"files":[{"patch":"@@ -1477,2 +1477,0 @@\n-  _num_regions_failed_evacuation(0),\n-  _regions_failed_evacuation(mtGC),\n@@ -1759,1 +1757,1 @@\n-  _regions_failed_evacuation.resize(max_regions());\n+  _evac_failure_regions.initialize(max_reserved_regions());\n@@ -2319,2 +2317,4 @@\n-void G1CollectedHeap::collection_set_par_iterate_all(HeapRegionClosure* cl, HeapRegionClaimer* hr_claimer, uint worker_id) {\n-  _collection_set.par_iterate(cl, hr_claimer, worker_id, workers()->active_workers());\n+void G1CollectedHeap::collection_set_par_iterate_all(HeapRegionClosure* cl,\n+                                                     HeapRegionClaimer* hr_claimer,\n+                                                     uint worker_id) {\n+  _collection_set.par_iterate(cl, hr_claimer, worker_id);\n@@ -2323,2 +2323,34 @@\n-void G1CollectedHeap::collection_set_iterate_increment_from(HeapRegionClosure *cl, HeapRegionClaimer* hr_claimer, uint worker_id) {\n-  _collection_set.iterate_incremental_part_from(cl, hr_claimer, worker_id, workers()->active_workers());\n+void G1CollectedHeap::collection_set_iterate_increment_from(HeapRegionClosure *cl,\n+                                                            HeapRegionClaimer* hr_claimer,\n+                                                            uint worker_id) {\n+  _collection_set.iterate_incremental_part_from(cl, hr_claimer, worker_id);\n+}\n+\n+void G1CollectedHeap::par_iterate_regions_array_part_from(HeapRegionClosure* cl,\n+                                                          HeapRegionClaimer* hr_claimer,\n+                                                          const uint* regions,\n+                                                          size_t offset,\n+                                                          size_t length,\n+                                                          uint worker_id) const {\n+  assert_at_safepoint();\n+  if (length == 0) {\n+    return;\n+  }\n+  uint total_workers = workers()->active_workers();\n+\n+  size_t start_pos = (worker_id * length) \/ total_workers;\n+  size_t cur_pos = start_pos;\n+\n+  do {\n+    uint region_idx = regions[cur_pos + offset];\n+    if (hr_claimer == NULL || hr_claimer->claim_region(region_idx)) {\n+      HeapRegion* r = region_at(region_idx);\n+      bool result = cl->do_heap_region(r);\n+      guarantee(!result, \"Must not cancel iteration\");\n+    }\n+\n+    cur_pos++;\n+    if (cur_pos == length) {\n+      cur_pos = 0;\n+    }\n+  } while (cur_pos != start_pos);\n@@ -2858,1 +2890,1 @@\n-  G1YoungCollector collector(gc_cause(), target_pause_time_ms);\n+  G1YoungCollector collector(gc_cause(), target_pause_time_ms, &_evac_failure_regions);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":40,"deletions":8,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/g1\/g1EvacFailureRegions.hpp\"\n@@ -833,4 +834,1 @@\n-  \/\/ Number of regions evacuation failed in the current collection.\n-  volatile uint _num_regions_failed_evacuation;\n-  \/\/ Records for every region on the heap whether evacuation failed for it.\n-  CHeapBitMap _regions_failed_evacuation;\n+  G1EvacFailureRegions _evac_failure_regions;\n@@ -1055,1 +1053,0 @@\n-  inline void reset_evacuation_failed_data();\n@@ -1058,9 +1055,0 @@\n-  \/\/ True iff the given region encountered an evacuation failure in the most-recent\n-  \/\/ collection.\n-  inline bool evacuation_failed(uint region_idx) const;\n-\n-  inline uint num_regions_failed_evacuation() const;\n-  \/\/ Notify that the garbage collection encountered an evacuation failure in the\n-  \/\/ given region. Returns whether this has been the first occurrence of an evacuation\n-  \/\/ failure in that region.\n-  inline bool notify_region_failed_evacuation(uint const region_idx);\n@@ -1170,0 +1158,9 @@\n+  \/\/ Iterate part of an array of region indexes given by offset and length, applying\n+  \/\/ the given HeapRegionClosure on each region. The worker_id will determine where\n+  \/\/ in the part to start the iteration to allow for more efficient parallel iteration.\n+  void par_iterate_regions_array_part_from(HeapRegionClosure* cl,\n+                                           HeapRegionClaimer* hr_claimer,\n+                                           const uint* regions,\n+                                           size_t offset,\n+                                           size_t length,\n+                                           uint worker_id) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/g1\/g1EvacFailureRegions.hpp\"\n@@ -198,5 +199,0 @@\n-void G1CollectedHeap::reset_evacuation_failed_data() {\n-  Atomic::store(&_num_regions_failed_evacuation, 0u);\n-  _regions_failed_evacuation.clear();\n-}\n-\n@@ -204,17 +200,1 @@\n-  return num_regions_failed_evacuation() > 0;\n-}\n-\n-bool G1CollectedHeap::evacuation_failed(uint region_idx) const {\n-  return _regions_failed_evacuation.par_at(region_idx, memory_order_relaxed);\n-}\n-\n-uint G1CollectedHeap::num_regions_failed_evacuation() const {\n-  return Atomic::load(&_num_regions_failed_evacuation);\n-}\n-\n-bool G1CollectedHeap::notify_region_failed_evacuation(uint const region_idx) {\n-  bool result = _regions_failed_evacuation.par_set_bit(region_idx, memory_order_relaxed);\n-  if (result) {\n-    Atomic::inc(&_num_regions_failed_evacuation, memory_order_relaxed);\n-  }\n-  return result;\n+  return _evac_failure_regions.num_regions_failed_evacuation() > 0;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":2,"deletions":22,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -210,3 +210,2 @@\n-                                  uint worker_id,\n-                                  uint total_workers) const {\n-  iterate_part_from(cl, hr_claimer, 0, cur_length(), worker_id, total_workers);\n+                                  uint worker_id) const {\n+  iterate_part_from(cl, hr_claimer, 0, cur_length(), worker_id);\n@@ -227,3 +226,2 @@\n-                                                    uint worker_id,\n-                                                    uint total_workers) const {\n-  iterate_part_from(cl, hr_claimer, _inc_part_start, increment_length(), worker_id, total_workers);\n+                                                    uint worker_id) const {\n+  iterate_part_from(cl, hr_claimer, _inc_part_start, increment_length(), worker_id);\n@@ -236,23 +234,2 @@\n-                                        uint worker_id,\n-                                        uint total_workers) const {\n-  assert_at_safepoint();\n-  if (length == 0) {\n-    return;\n-  }\n-\n-  size_t start_pos = (worker_id * length) \/ total_workers;\n-  size_t cur_pos = start_pos;\n-\n-  do {\n-    uint region_idx = _collection_set_regions[cur_pos + offset];\n-    if (hr_claimer == NULL || hr_claimer->claim_region(region_idx)) {\n-      HeapRegion* r = _g1h->region_at(region_idx);\n-      bool result = cl->do_heap_region(r);\n-      guarantee(!result, \"Must not cancel iteration\");\n-    }\n-\n-    cur_pos++;\n-    if (cur_pos == length) {\n-      cur_pos = 0;\n-    }\n-  } while (cur_pos != start_pos);\n+                                        uint worker_id) const {\n+  _g1h->par_iterate_regions_array_part_from(cl, hr_claimer, _collection_set_regions, offset, length, worker_id);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":6,"deletions":29,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -265,2 +265,1 @@\n-                         uint worker_id,\n-                         uint total_workers) const;\n+                         uint worker_id) const;\n@@ -310,1 +309,1 @@\n-  void iterate_incremental_part_from(HeapRegionClosure* cl, HeapRegionClaimer* hr_claimer, uint worker_id, uint total_workers) const;\n+  void iterate_incremental_part_from(HeapRegionClosure* cl, HeapRegionClaimer* hr_claimer, uint worker_id) const;\n@@ -322,2 +321,1 @@\n-                   uint worker_id,\n-                   uint total_workers) const;\n+                   uint worker_id) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/g1\/g1EvacFailureRegions.hpp\"\n@@ -206,0 +207,1 @@\n+  G1EvacFailureRegions* _evac_failure_regions;\n@@ -208,1 +210,4 @@\n-  RemoveSelfForwardPtrHRClosure(G1RedirtyCardsQueueSet* rdcqs, uint worker_id, uint volatile* num_failed_regions) :\n+  RemoveSelfForwardPtrHRClosure(G1RedirtyCardsQueueSet* rdcqs,\n+                                uint worker_id,\n+                                uint volatile* num_failed_regions,\n+                                G1EvacFailureRegions* evac_failure_regions) :\n@@ -213,1 +218,2 @@\n-    _num_failed_regions(num_failed_regions) {\n+    _num_failed_regions(num_failed_regions),\n+    _evac_failure_regions(evac_failure_regions) {\n@@ -237,1 +243,1 @@\n-    if (_g1h->evacuation_failed(hr->hrm_index())) {\n+    if (_evac_failure_regions->contains(hr->hrm_index())) {\n@@ -262,1 +268,2 @@\n-G1ParRemoveSelfForwardPtrsTask::G1ParRemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs) :\n+G1ParRemoveSelfForwardPtrsTask::G1ParRemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs,\n+                                                               G1EvacFailureRegions* evac_failure_regions) :\n@@ -267,0 +274,1 @@\n+  _evac_failure_regions(evac_failure_regions),\n@@ -270,8 +278,4 @@\n-  RemoveSelfForwardPtrHRClosure rsfp_cl(_rdcqs, worker_id, &_num_failed_regions);\n-\n-  \/\/ We need to check all collection set regions whether they need self forward\n-  \/\/ removals, not only the last collection set increment. The reason is that\n-  \/\/ reference processing (e.g. finalizers) can make it necessary to resurrect an\n-  \/\/ otherwise unreachable object at the very end of the collection. That object\n-  \/\/ might cause an evacuation failure in any region in the collection set.\n-  _g1h->collection_set_par_iterate_all(&rsfp_cl, &_hrclaimer, worker_id);\n+  RemoveSelfForwardPtrHRClosure rsfp_cl(_rdcqs, worker_id, &_num_failed_regions, _evac_failure_regions);\n+\n+  \/\/ Iterate through all regions that failed evacuation during the entire collection.\n+  _evac_failure_regions->par_iterate(&rsfp_cl, &_hrclaimer, worker_id);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.cpp","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+class G1EvacFailureRegions;\n@@ -44,0 +45,1 @@\n+  G1EvacFailureRegions* _evac_failure_regions;\n@@ -47,1 +49,1 @@\n-  G1ParRemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs);\n+  G1ParRemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs, G1EvacFailureRegions* evac_failure_regions);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2021, Huawei Technologies Co. Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/g1\/g1CollectedHeap.hpp\"\n+#include \"gc\/g1\/g1EvacFailureRegions.hpp\"\n+#include \"gc\/g1\/heapRegion.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+\n+\n+G1EvacFailureRegions::G1EvacFailureRegions() :\n+  _regions_failed_evacuation(mtGC) {\n+}\n+\n+G1EvacFailureRegions::~G1EvacFailureRegions() {\n+  FREE_C_HEAP_ARRAY(uint, _evac_failure_regions);\n+}\n+\n+void G1EvacFailureRegions::initialize(uint max_regions) {\n+  Atomic::store(&_evac_failure_regions_cur_length, 0u);\n+  _max_regions = max_regions;\n+  _regions_failed_evacuation.resize(_max_regions);\n+  _evac_failure_regions = NEW_C_HEAP_ARRAY(uint, _max_regions, mtGC);\n+}\n+\n+void G1EvacFailureRegions::par_iterate(HeapRegionClosure* closure,\n+                                       HeapRegionClaimer* _hrclaimer,\n+                                       uint worker_id) {\n+  G1CollectedHeap::heap()->par_iterate_regions_array_part_from(closure,\n+                                                               _hrclaimer,\n+                                                               _evac_failure_regions,\n+                                                               0,\n+                                                               Atomic::load(&_evac_failure_regions_cur_length),\n+                                                               worker_id);\n+}\n+\n+void G1EvacFailureRegions::reset() {\n+  Atomic::store(&_evac_failure_regions_cur_length, 0u);\n+  _regions_failed_evacuation.clear();\n+}\n+\n+bool G1EvacFailureRegions::contains(uint region_idx) const {\n+  assert(region_idx < _max_regions, \"must be\");\n+  return _regions_failed_evacuation.par_at(region_idx, memory_order_relaxed);\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.cpp","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2021, Huawei Technologies Co. Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1EVACFAILUREREGIONS_HPP\n+#define SHARE_GC_G1_G1EVACFAILUREREGIONS_HPP\n+\n+#include \"runtime\/atomic.hpp\"\n+#include \"utilities\/bitMap.hpp\"\n+\n+class HeapRegionClosure;\n+class HeapRegionClaimer;\n+\n+\/\/ This class records for every region on the heap whether evacuation failed for it,\n+\/\/ and records for every evacuation failure region to speed up iteration of these\n+\/\/ regions in post evacuation phase.\n+class G1EvacFailureRegions {\n+  \/\/ Records for every region on the heap whether evacuation failed for it.\n+  CHeapBitMap _regions_failed_evacuation;\n+  \/\/ Regions (index) of evacuation failed in the current collection.\n+  uint* _evac_failure_regions;\n+  \/\/ Number of regions evacuation failed in the current collection.\n+  volatile uint _evac_failure_regions_cur_length;\n+  \/\/ Maximum of regions number.\n+  uint _max_regions;\n+\n+public:\n+  G1EvacFailureRegions();\n+  ~G1EvacFailureRegions();\n+  void initialize(uint max_regions);\n+\n+  void reset();\n+\n+  bool contains(uint region_idx) const;\n+  void par_iterate(HeapRegionClosure* closure,\n+                   HeapRegionClaimer* _hrclaimer,\n+                   uint worker_id);\n+\n+  uint num_regions_failed_evacuation() const {\n+    return Atomic::load(&_evac_failure_regions_cur_length);\n+  }\n+\n+  \/\/ Record that the garbage collection encountered an evacuation failure in the\n+  \/\/ given region. Returns whether this has been the first occurrence of an evacuation\n+  \/\/ failure in that region.\n+  inline bool record(uint region_idx);\n+};\n+\n+#endif \/\/SHARE_GC_G1_G1EVACFAILUREREGIONS_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.hpp","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2021, Huawei Technologies Co. Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1EVACFAILUREREGIONS_INLINE_HPP\n+#define SHARE_GC_G1_G1EVACFAILUREREGIONS_INLINE_HPP\n+\n+#include \"gc\/g1\/g1EvacFailureRegions.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"utilities\/bitMap.inline.hpp\"\n+\n+bool G1EvacFailureRegions::record(uint region_idx) {\n+  assert(region_idx < _max_regions, \"must be\");\n+  bool success = _regions_failed_evacuation.par_set_bit(region_idx,\n+                                                        memory_order_relaxed);\n+  if (success) {\n+    size_t offset = Atomic::fetch_and_add(&_evac_failure_regions_cur_length, 1u);\n+    _evac_failure_regions[offset] = region_idx;\n+  }\n+  return success;\n+}\n+\n+#endif \/\/SHARE_GC_G1_G1EVACFAILUREREGIONS_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.inline.hpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/g1\/g1EvacFailureRegions.inline.hpp\"\n@@ -61,1 +62,2 @@\n-                                           size_t optional_cset_length)\n+                                           size_t optional_cset_length,\n+                                           G1EvacFailureRegions* evac_failure_regions)\n@@ -87,1 +89,2 @@\n-    _evacuation_failed_info()\n+    _evacuation_failed_info(),\n+    _evac_failure_regions(evac_failure_regions)\n@@ -544,1 +547,2 @@\n-                               _young_cset_length, _optional_cset_length);\n+                               _young_cset_length, _optional_cset_length,\n+                               _evac_failure_regions);\n@@ -598,1 +602,1 @@\n-    if (_g1h->notify_region_failed_evacuation(r->hrm_index())) {\n+    if (_evac_failure_regions->record(r->hrm_index())) {\n@@ -652,1 +656,2 @@\n-                                                 size_t optional_cset_length) :\n+                                                 size_t optional_cset_length,\n+                                                 G1EvacFailureRegions* evac_failure_regions) :\n@@ -661,1 +666,2 @@\n-    _flushed(false) {\n+    _flushed(false),\n+    _evac_failure_regions(evac_failure_regions) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+  G1EvacFailureRegions* _evac_failure_regions;\n@@ -115,1 +116,2 @@\n-                       size_t optional_cset_length);\n+                       size_t optional_cset_length,\n+                       G1EvacFailureRegions* evac_failure_regions);\n@@ -245,0 +247,1 @@\n+  G1EvacFailureRegions* _evac_failure_regions;\n@@ -252,1 +255,2 @@\n-                          size_t optional_cset_length);\n+                          size_t optional_cset_length,\n+                          G1EvacFailureRegions* evac_failure_regions);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -501,1 +501,1 @@\n-  _g1h->reset_evacuation_failed_data();\n+  _evac_failure_regions->reset();\n@@ -958,1 +958,1 @@\n-    G1PostEvacuateCollectionSetCleanupTask1 cl(per_thread_states);\n+    G1PostEvacuateCollectionSetCleanupTask1 cl(per_thread_states, _evac_failure_regions);\n@@ -968,1 +968,1 @@\n-    G1PostEvacuateCollectionSetCleanupTask2 cl(per_thread_states, evacuation_info);\n+    G1PostEvacuateCollectionSetCleanupTask2 cl(per_thread_states, evacuation_info, _evac_failure_regions);\n@@ -1027,1 +1027,3 @@\n-G1YoungCollector::G1YoungCollector(GCCause::Cause gc_cause, double target_pause_time_ms) :\n+G1YoungCollector::G1YoungCollector(GCCause::Cause gc_cause,\n+                                   double target_pause_time_ms,\n+                                   G1EvacFailureRegions* evac_failure_regions) :\n@@ -1031,1 +1033,2 @@\n-  _concurrent_operation_is_full_mark(false)\n+  _concurrent_operation_is_full_mark(false),\n+  _evac_failure_regions(evac_failure_regions)\n@@ -1083,1 +1086,2 @@\n-                                              collection_set()->optional_region_length());\n+                                              collection_set()->optional_region_length(),\n+                                              _evac_failure_regions);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+class G1EvacFailureRegions;\n@@ -126,0 +127,1 @@\n+  G1EvacFailureRegions* _evac_failure_regions;\n@@ -136,1 +138,3 @@\n-  G1YoungCollector(GCCause::Cause gc_cause, double target_pause_time_ms);\n+  G1YoungCollector(GCCause::Cause gc_cause,\n+                   double target_pause_time_ms,\n+                   G1EvacFailureRegions* evac_failure_regions);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,1 +42,2 @@\n-G1PostEvacuateCollectionSetCleanupTask1::G1PostEvacuateCollectionSetCleanupTask1(G1ParScanThreadStateSet* per_thread_states) :\n+G1PostEvacuateCollectionSetCleanupTask1::G1PostEvacuateCollectionSetCleanupTask1(G1ParScanThreadStateSet* per_thread_states,\n+                                                                                 G1EvacFailureRegions* evac_failure_regions) :\n@@ -51,1 +52,1 @@\n-    add_parallel_task(new RemoveSelfForwardPtrsTask(per_thread_states->rdcqs()));\n+    add_parallel_task(new RemoveSelfForwardPtrsTask(per_thread_states->rdcqs(), evac_failure_regions));\n@@ -103,2 +104,6 @@\n-G1PostEvacuateCollectionSetCleanupTask1::RemoveSelfForwardPtrsTask::RemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs) :\n-  G1AbstractSubTask(G1GCPhaseTimes::RemoveSelfForwardingPtr), _task(rdcqs) { }\n+G1PostEvacuateCollectionSetCleanupTask1::\n+    RemoveSelfForwardPtrsTask::RemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs,\n+                                                         G1EvacFailureRegions* evac_failure_regions) :\n+  G1AbstractSubTask(G1GCPhaseTimes::RemoveSelfForwardingPtr),\n+  _task(rdcqs, evac_failure_regions),\n+  _evac_failure_regions(evac_failure_regions) { }\n@@ -108,1 +113,1 @@\n-  assert(_task.num_failed_regions() == g1h->num_regions_failed_evacuation(),\n+  assert(_task.num_failed_regions() == _evac_failure_regions->num_regions_failed_evacuation(),\n@@ -110,1 +115,1 @@\n-         _task.num_failed_regions(), g1h->num_regions_failed_evacuation());\n+         _task.num_failed_regions(), _evac_failure_regions->num_regions_failed_evacuation());\n@@ -115,1 +120,1 @@\n-  return G1CollectedHeap::heap()->num_regions_failed_evacuation();\n+  return _evac_failure_regions->num_regions_failed_evacuation();\n@@ -294,0 +299,1 @@\n+  G1EvacFailureRegions* _evac_failure_regions;\n@@ -302,1 +308,1 @@\n-    return _g1h->is_in_cset(hr) && !_g1h->evacuation_failed(hr->hrm_index());\n+    return _g1h->is_in_cset(hr) && !_evac_failure_regions->contains(hr->hrm_index());\n@@ -306,2 +312,6 @@\n-  RedirtyLoggedCardTableEntryClosure(G1CollectedHeap* g1h) : G1CardTableEntryClosure(),\n-    _num_dirtied(0), _g1h(g1h), _g1_ct(g1h->card_table()) { }\n+  RedirtyLoggedCardTableEntryClosure(G1CollectedHeap* g1h, G1EvacFailureRegions* evac_failure_regions) :\n+    G1CardTableEntryClosure(),\n+    _num_dirtied(0),\n+    _g1h(g1h),\n+    _g1_ct(g1h->card_table()),\n+    _evac_failure_regions(evac_failure_regions) { }\n@@ -322,1 +332,3 @@\n-G1PostEvacuateCollectionSetCleanupTask2::RedirtyLoggedCardsTask::RedirtyLoggedCardsTask(G1RedirtyCardsQueueSet* rdcqs) :\n+G1PostEvacuateCollectionSetCleanupTask2::\n+      RedirtyLoggedCardsTask::RedirtyLoggedCardsTask(G1RedirtyCardsQueueSet* rdcqs,\n+                                                     G1EvacFailureRegions* evac_failure_regions) :\n@@ -325,1 +337,2 @@\n-  _nodes(rdcqs->all_completed_buffers()) { }\n+  _nodes(rdcqs->all_completed_buffers()),\n+  _evac_failure_regions(evac_failure_regions) { }\n@@ -339,1 +352,1 @@\n-  RedirtyLoggedCardTableEntryClosure cl(G1CollectedHeap::heap());\n+  RedirtyLoggedCardTableEntryClosure cl(G1CollectedHeap::heap(), _evac_failure_regions);\n@@ -465,0 +478,1 @@\n+  G1EvacFailureRegions* _evac_failure_regions;\n@@ -507,1 +521,2 @@\n-                  FreeCSetStats* stats) :\n+                  FreeCSetStats* stats,\n+                  G1EvacFailureRegions* evac_failure_regions) :\n@@ -514,1 +529,2 @@\n-      _stats(stats) { }\n+      _stats(stats),\n+      _evac_failure_regions(evac_failure_regions) { }\n@@ -528,1 +544,1 @@\n-    if (_g1h->evacuation_failed(r->hrm_index())) {\n+    if (_evac_failure_regions->contains(r->hrm_index())) {\n@@ -562,2 +578,4 @@\n-G1PostEvacuateCollectionSetCleanupTask2::FreeCollectionSetTask::FreeCollectionSetTask(G1EvacuationInfo* evacuation_info,\n-                                                                                      const size_t* surviving_young_words) :\n+G1PostEvacuateCollectionSetCleanupTask2::\n+      FreeCollectionSetTask::FreeCollectionSetTask(G1EvacuationInfo* evacuation_info,\n+                                                   const size_t* surviving_young_words,\n+                                                   G1EvacFailureRegions* evac_failure_regions) :\n@@ -570,1 +588,2 @@\n-    _active_workers(0) {\n+    _active_workers(0),\n+    _evac_failure_regions(evac_failure_regions) {\n@@ -599,1 +618,1 @@\n-  FreeCSetClosure cl(_surviving_young_words, worker_id, worker_stats(worker_id));\n+  FreeCSetClosure cl(_surviving_young_words, worker_id, worker_stats(worker_id), _evac_failure_regions);\n@@ -606,1 +625,2 @@\n-                                                                                 G1EvacuationInfo* evacuation_info) :\n+                                                                                 G1EvacuationInfo* evacuation_info,\n+                                                                                 G1EvacFailureRegions* evac_failure_regions) :\n@@ -621,2 +641,4 @@\n-  add_parallel_task(new RedirtyLoggedCardsTask(per_thread_states->rdcqs()));\n-  add_parallel_task(new FreeCollectionSetTask(evacuation_info, per_thread_states->surviving_young_words()));\n+  add_parallel_task(new RedirtyLoggedCardsTask(per_thread_states->rdcqs(), evac_failure_regions));\n+  add_parallel_task(new FreeCollectionSetTask(evacuation_info,\n+                                                   per_thread_states->surviving_young_words(),\n+                                                   evac_failure_regions));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":45,"deletions":23,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+class G1EvacFailureRegions;\n@@ -51,1 +52,2 @@\n-  G1PostEvacuateCollectionSetCleanupTask1(G1ParScanThreadStateSet* per_thread_states);\n+  G1PostEvacuateCollectionSetCleanupTask1(G1ParScanThreadStateSet* per_thread_states,\n+                                          G1EvacFailureRegions* evac_failure_regions);\n@@ -84,0 +86,1 @@\n+  G1EvacFailureRegions* _evac_failure_regions;\n@@ -86,1 +89,1 @@\n-  RemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs);\n+  RemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs, G1EvacFailureRegions* evac_failure_regions);\n@@ -117,1 +120,2 @@\n-                                          G1EvacuationInfo* evacuation_info);\n+                                          G1EvacuationInfo* evacuation_info,\n+                                          G1EvacFailureRegions* evac_failure_regions);\n@@ -177,0 +181,1 @@\n+  G1EvacFailureRegions* _evac_failure_regions;\n@@ -179,1 +184,1 @@\n-  RedirtyLoggedCardsTask(G1RedirtyCardsQueueSet* rdcqs);\n+  RedirtyLoggedCardsTask(G1RedirtyCardsQueueSet* rdcqs, G1EvacFailureRegions* evac_failure_regions);\n@@ -193,0 +198,1 @@\n+  G1EvacFailureRegions* _evac_failure_regions;\n@@ -198,1 +204,3 @@\n-  FreeCollectionSetTask(G1EvacuationInfo* evacuation_info, const size_t* surviving_young_words);\n+  FreeCollectionSetTask(G1EvacuationInfo* evacuation_info,\n+                        const size_t* surviving_young_words,\n+                        G1EvacFailureRegions* evac_failure_regions);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.hpp","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"}]}