{"files":[{"patch":"@@ -2310,1 +2310,1 @@\n-  _collection_set.par_iterate(cl, hr_claimer, worker_id, workers()->active_workers());\n+  _collection_set.par_iterate(cl, hr_claimer, worker_id);\n@@ -2314,1 +2314,31 @@\n-  _collection_set.iterate_incremental_part_from(cl, hr_claimer, worker_id, workers()->active_workers());\n+  _collection_set.iterate_incremental_part_from(cl, hr_claimer, worker_id);\n+}\n+\n+void G1CollectedHeap::par_iterate_regions_array_part_from(HeapRegionClosure* cl,\n+                                        HeapRegionClaimer* hr_claimer,\n+                                        const uint* regions,\n+                                        size_t offset,\n+                                        size_t length,\n+                                        uint worker_id) const {\n+  assert_at_safepoint();\n+  if (length == 0) {\n+    return;\n+  }\n+  uint total_workers = workers()->active_workers();\n+\n+  size_t start_pos = (worker_id * length) \/ total_workers;\n+  size_t cur_pos = start_pos;\n+\n+  do {\n+    uint region_idx = regions[cur_pos + offset];\n+    if (hr_claimer == NULL || hr_claimer->claim_region(region_idx)) {\n+      HeapRegion* r = region_at(region_idx);\n+      bool result = cl->do_heap_region(r);\n+      guarantee(!result, \"Must not cancel iteration\");\n+    }\n+\n+    cur_pos++;\n+    if (cur_pos == length) {\n+      cur_pos = 0;\n+    }\n+  } while (cur_pos != start_pos);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":32,"deletions":2,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1210,0 +1210,9 @@\n+  \/\/ Iterate the part of a regions array given by the offset and length applying the given\n+  \/\/ HeapRegionClosure. The worker_id will determine where in the part to start the iteration\n+  \/\/ to allow for more efficient parallel iteration.\n+  void par_iterate_regions_array_part_from(HeapRegionClosure* cl,\n+                                   HeapRegionClaimer* hr_claimer,\n+                                   const uint* regions,\n+                                   size_t offset,\n+                                   size_t length,\n+                                   uint worker_id) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -210,3 +210,2 @@\n-                                  uint worker_id,\n-                                  uint total_workers) const {\n-  iterate_part_from(cl, hr_claimer, 0, cur_length(), worker_id, total_workers);\n+                                  uint worker_id) const {\n+  iterate_part_from(cl, hr_claimer, 0, cur_length(), worker_id);\n@@ -227,3 +226,2 @@\n-                                                    uint worker_id,\n-                                                    uint total_workers) const {\n-  iterate_part_from(cl, hr_claimer, _inc_part_start, increment_length(), worker_id, total_workers);\n+                                                    uint worker_id) const {\n+  iterate_part_from(cl, hr_claimer, _inc_part_start, increment_length(), worker_id);\n@@ -236,23 +234,2 @@\n-                                        uint worker_id,\n-                                        uint total_workers) const {\n-  assert_at_safepoint();\n-  if (length == 0) {\n-    return;\n-  }\n-\n-  size_t start_pos = (worker_id * length) \/ total_workers;\n-  size_t cur_pos = start_pos;\n-\n-  do {\n-    uint region_idx = _collection_set_regions[cur_pos + offset];\n-    if (hr_claimer == NULL || hr_claimer->claim_region(region_idx)) {\n-      HeapRegion* r = _g1h->region_at(region_idx);\n-      bool result = cl->do_heap_region(r);\n-      guarantee(!result, \"Must not cancel iteration\");\n-    }\n-\n-    cur_pos++;\n-    if (cur_pos == length) {\n-      cur_pos = 0;\n-    }\n-  } while (cur_pos != start_pos);\n+                                        uint worker_id) const {\n+  _g1h->par_iterate_regions_array_part_from(cl, hr_claimer, _collection_set_regions, offset, length, worker_id);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":6,"deletions":29,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -265,2 +265,1 @@\n-                         uint worker_id,\n-                         uint total_workers) const;\n+                         uint worker_id) const;\n@@ -310,1 +309,1 @@\n-  void iterate_incremental_part_from(HeapRegionClosure* cl, HeapRegionClaimer* hr_claimer, uint worker_id, uint total_workers) const;\n+  void iterate_incremental_part_from(HeapRegionClosure* cl, HeapRegionClaimer* hr_claimer, uint worker_id) const;\n@@ -322,2 +321,1 @@\n-                   uint worker_id,\n-                   uint total_workers) const;\n+                   uint worker_id) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -52,23 +52,6 @@\n-  assert_at_safepoint();\n-  size_t length = Atomic::load(&_evac_failure_regions_cur_length);\n-  if (length == 0) {\n-    return;\n-  }\n-\n-  uint total_workers = G1CollectedHeap::heap()->workers()->active_workers();\n-  size_t start_pos = (worker_id * length) \/ total_workers;\n-  size_t cur_pos = start_pos;\n-\n-  do {\n-    uint region_idx = _evac_failure_regions[cur_pos];\n-    if (_hrclaimer == NULL || _hrclaimer->claim_region(region_idx)) {\n-      HeapRegion* r = G1CollectedHeap::heap()->region_at(region_idx);\n-      bool result = closure->do_heap_region(r);\n-      guarantee(!result, \"Must not cancel iteration\");\n-    }\n-\n-    cur_pos++;\n-    if (cur_pos == length) {\n-      cur_pos = 0;\n-    }\n-  } while (cur_pos != start_pos);\n+  G1CollectedHeap::heap()->par_iterate_regions_array_part_from(closure,\n+                                                        _hrclaimer,\n+                                                        _evac_failure_regions,\n+                                                        0,\n+                                                        Atomic::load(&_evac_failure_regions_cur_length),\n+                                                        worker_id);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.cpp","additions":6,"deletions":23,"binary":false,"changes":29,"status":"modified"}]}