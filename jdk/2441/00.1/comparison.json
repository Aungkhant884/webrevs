{"files":[{"patch":"@@ -1247,0 +1247,1 @@\n+#include \"runtime\/objectMonitor.hpp\"\n@@ -1775,2 +1776,7 @@\n-  ShouldNotReachHere();\n-  return -1;\n+  \/\/ This is implemented using aarch64_enc_java_to_runtime as above.\n+  CodeBlob *cb = CodeCache::find_blob(_entry_point);\n+  if (cb) {\n+    return 1 * NativeInstruction::instruction_size;\n+  } else {\n+    return 6 * NativeInstruction::instruction_size;\n+  }\n@@ -1919,1 +1925,1 @@\n-  if (C->output()->need_stack_bang(bangsize) && UseStackBanging)\n+  if (C->output()->need_stack_bang(bangsize))\n@@ -16045,0 +16051,15 @@\n+instruct CallNativeDirect(method meth)\n+%{\n+  match(CallNative);\n+\n+  effect(USE meth);\n+\n+  ins_cost(CALL_COST);\n+\n+  format %{ \"CALL, native $meth\" %}\n+\n+  ins_encode( aarch64_enc_java_to_runtime(meth) );\n+\n+  ins_pipe(pipe_class_call);\n+%}\n+\n@@ -17091,92 +17112,0 @@\n-instruct reduce_max2F(vRegF dst, vRegF fsrc, vecD vsrc, vecD tmp) %{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (MaxReductionV fsrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"fmaxs $dst, $fsrc, $vsrc\\n\\t\"\n-            \"ins   $tmp, S, $vsrc, 0, 1\\n\\t\"\n-            \"fmaxs $dst, $dst, $tmp\\t# max reduction2F\" %}\n-  ins_encode %{\n-    __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($fsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ S, as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_max4F(vRegF dst, vRegF fsrc, vecX vsrc) %{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (MaxReductionV fsrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"fmaxv $dst, T4S, $vsrc\\n\\t\"\n-            \"fmaxs $dst, $dst, $fsrc\\t# max reduction4F\" %}\n-  ins_encode %{\n-    __ fmaxv(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($vsrc$$reg));\n-    __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($fsrc$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_max2D(vRegD dst, vRegD dsrc, vecX vsrc, vecX tmp) %{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (MaxReductionV dsrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"fmaxd $dst, $dsrc, $vsrc\\n\\t\"\n-            \"ins   $tmp, D, $vsrc, 0, 1\\n\\t\"\n-            \"fmaxd $dst, $dst, $tmp\\t# max reduction2D\" %}\n-  ins_encode %{\n-    __ fmaxd(as_FloatRegister($dst$$reg), as_FloatRegister($dsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ fmaxd(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_min2F(vRegF dst, vRegF fsrc, vecD vsrc, vecD tmp) %{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (MinReductionV fsrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"fmins $dst, $fsrc, $vsrc\\n\\t\"\n-            \"ins   $tmp, S, $vsrc, 0, 1\\n\\t\"\n-            \"fmins $dst, $dst, $tmp\\t# min reduction2F\" %}\n-  ins_encode %{\n-    __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($fsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ S, as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_min4F(vRegF dst, vRegF fsrc, vecX vsrc) %{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (MinReductionV fsrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"fminv $dst, T4S, $vsrc\\n\\t\"\n-            \"fmins $dst, $dst, $fsrc\\t# min reduction4F\" %}\n-  ins_encode %{\n-    __ fminv(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($vsrc$$reg));\n-    __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($fsrc$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_min2D(vRegD dst, vRegD dsrc, vecX vsrc, vecX tmp) %{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (MinReductionV dsrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"fmind $dst, $dsrc, $vsrc\\n\\t\"\n-            \"ins   $tmp, D, $vsrc, 0, 1\\n\\t\"\n-            \"fmind $dst, $dst, $tmp\\t# min reduction2D\" %}\n-  ins_encode %{\n-    __ fmind(as_FloatRegister($dst$$reg), as_FloatRegister($dsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ fmind(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":24,"deletions":95,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -917,1 +917,2 @@\n-  bool skeleton_predicate_has_opaque(IfNode* iff);\n+  static bool skeleton_predicate_has_opaque(IfNode* iff);\n+  static void get_skeleton_predicates(Node* predicate, Unique_Node_List& list, bool get_opaque = false);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1154,1 +1154,1 @@\n-  if (!n->is_If() || n->is_CountedLoopEnd()) {\n+  if (!n->is_If() || n->is_BaseCountedLoopEnd()) {\n@@ -1433,0 +1433,1 @@\n+          Node* outer_loop_clone = NULL;\n@@ -1480,10 +1481,19 @@\n-              if (x_head->is_Loop() && (x_head->is_OuterStripMinedLoop() || x_head->as_Loop()->is_strip_mined()) && is_dominator(n_ctrl, x_head)) {\n-                \/\/ Anti dependence analysis is sometimes too\n-                \/\/ conservative: a store in the outer strip mined loop\n-                \/\/ can prevent a load from floating out of the outer\n-                \/\/ strip mined loop but the load may not be referenced\n-                \/\/ from the safepoint: loop strip mining verification\n-                \/\/ code reports a problem in that case. Make sure the\n-                \/\/ load is not moved in the outer strip mined loop in\n-                \/\/ that case.\n-                x_ctrl = x_head->as_Loop()->skip_strip_mined()->in(LoopNode::EntryControl);\n+              if (x_head->is_Loop() && (x_head->is_OuterStripMinedLoop() || x_head->as_Loop()->is_strip_mined())) {\n+                if (is_dominator(n_ctrl, x_head)) {\n+                  \/\/ Anti dependence analysis is sometimes too\n+                  \/\/ conservative: a store in the outer strip mined loop\n+                  \/\/ can prevent a load from floating out of the outer\n+                  \/\/ strip mined loop but the load may not be referenced\n+                  \/\/ from the safepoint: loop strip mining verification\n+                  \/\/ code reports a problem in that case. Make sure the\n+                  \/\/ load is not moved in the outer strip mined loop in\n+                  \/\/ that case.\n+                  x_ctrl = x_head->as_Loop()->skip_strip_mined()->in(LoopNode::EntryControl);\n+                } else if (x_head->is_OuterStripMinedLoop()) {\n+                  \/\/ Do not add duplicate LoadNodes to the outer strip mined loop\n+                  if (outer_loop_clone != NULL) {\n+                    _igvn.replace_node(x, outer_loop_clone);\n+                    continue;\n+                  }\n+                  outer_loop_clone = x;\n+                }\n@@ -1506,2 +1516,1 @@\n-            BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n-            if (!x->is_Load() && !x->is_DecodeNarrowPtr() && !x->is_AddP() && !bs->is_gc_barrier_node(x)) {\n+            if (!x->is_Load() && !x->is_DecodeNarrowPtr()) {\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":22,"deletions":13,"binary":false,"changes":35,"status":"modified"}]}