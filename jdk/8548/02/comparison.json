{"files":[{"patch":"@@ -32,0 +32,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -1349,3 +1350,3 @@\n-     * @param value the long value\n-     * @return the argument as an int\n-     * @throws ArithmeticException if the {@code argument} overflows an int\n+     * @param value the {@code long} value\n+     * @return the argument as an {@code int}\n+     * @throws ArithmeticException if the argument overflows an {@code int}\n@@ -1354,0 +1355,1 @@\n+    @ForceInline\n@@ -1355,2 +1357,244 @@\n-        if ((int)value != value) {\n-            throw new ArithmeticException(\"integer overflow\");\n+        int result = (int) value;\n+        if ((long) result != value) {\n+            throw newArithmeticExceptionOverflow(value);\n+        }\n+        return result;\n+    }\n+\n+    \/**\n+     * Returns the value of the {@code double} argument,\n+     * throwing an exception if the conversion is inexact.\n+     * The method returns if and only if the argument and the result\n+     * are mathematically equal.\n+     *\n+     * <p>Special cases:\n+     * <ul>\n+     * <li>If the argument is {@link Double#NEGATIVE_INFINITY},\n+     * {@link Double#POSITIVE_INFINITY} or {@link Double#NaN},\n+     * the method throws.\n+     * <li>If the argument is {@code -0.0} or {@code 0.0},\n+     * the method returns {@code 0}.\n+     * <\/ul>\n+     *\n+     * @param value the {@code double} value\n+     * @return the argument as a {@code int}\n+     * @throws ArithmeticException if the conversion is inexact\n+     * @see Math#rint(double)\n+     * @see Math#round(double)\n+     * @since 19\n+     *\/\n+    @ForceInline\n+    public static int toIntExact(double value) {\n+        int result = (int) value;\n+        if ((double) result != value) {\n+            throw newArithmeticExceptionInexact(value);\n+        }\n+        return result;\n+    }\n+\n+    \/**\n+     * Returns the value of the {@code long} argument,\n+     * throwing an exception if the value overflows a {@code short}.\n+     *\n+     * @param value the {@code long} value\n+     * @return the argument as a {@code short}\n+     * @throws ArithmeticException if the argument overflows a {@code short}\n+     * @since 19\n+     *\/\n+    @ForceInline\n+    public static short toShortExact(long value) {\n+        short result = (short) value;\n+        if ((long) result != value) {\n+            throw newArithmeticExceptionOverflow(value);\n+        }\n+        return result;\n+    }\n+\n+    \/**\n+     * Returns the value of the {@code long} argument,\n+     * throwing an exception if the value overflows a {@code byte}.\n+     *\n+     * @param value the {@code long} value\n+     * @return the argument as a {@code byte}\n+     * @throws ArithmeticException if the argument overflows a {@code byte}\n+     * @since 19\n+     *\/\n+    @ForceInline\n+    public static byte toByteExact(long value) {\n+        byte result = (byte) value;\n+        if ((long) result != value) {\n+            throw newArithmeticExceptionOverflow(value);\n+        }\n+        return result;\n+    }\n+\n+    \/**\n+     * Returns the value of the {@code long} argument,\n+     * throwing an exception if the conversion is inexact.\n+     * The method returns if and only if the argument and the result\n+     * are mathematically equal.\n+     *\n+     * <p>Special case:\n+     * <ul>\n+     * <li>If the argument is {@code 0L}, the method returns {@code 0.0f}.\n+     * <\/ul>\n+     *\n+     * @param value the {@code long} value\n+     * @return the argument as a {@code float}\n+     * @throws ArithmeticException if the conversion is inexact\n+     * @since 19\n+     *\/\n+    @ForceInline\n+    public static float toFloatExact(long value) {\n+        \/*\n+         * The left-hand side of the test below correctly discriminates\n+         * inexact conversions, *except* for Long.MAX_VALUE.\n+         * Long.MAX_VALUE cannot be converted exactly,\n+         * and yet the left-hand side evaluates to false.\n+         *\/\n+        float result = (float) value;\n+        if ((long) result != value || value == Long.MAX_VALUE) {\n+            throw newArithmeticExceptionOverflow(value);\n+        }\n+        return result;\n+    }\n+\n+    \/**\n+     * Returns the value of the {@code double} argument,\n+     * throwing an exception if the conversion is inexact.\n+     * The method returns if and only if the argument and the result\n+     * are mathematically equal.\n+     *\n+     * <p>Special cases:\n+     * <ul>\n+     * <li>If the argument is {@link Double#NEGATIVE_INFINITY},\n+     * {@link Double#POSITIVE_INFINITY}, {@link Double#NaN},\n+     * {@code -0.0} or {@code 0.0},\n+     * the method returns {@link Float#NEGATIVE_INFINITY},\n+     * {@link Float#POSITIVE_INFINITY}, {@link Float#NaN},\n+     * {@code -0.0f} or {@code 0.0f}, respectively.\n+     * <\/ul>\n+     *\n+     * @param value the {@code double} value\n+     * @return the argument as a {@code float}\n+     * @throws ArithmeticException if the conversion is inexact\n+     * @since 19\n+     *\/\n+    @ForceInline\n+    public static float toFloatExact(double value) {\n+        \/*\n+         * The left-hand side of the test below correctly discriminates\n+         * inexact conversions, *except* for Double.NaN.\n+         * Double.NaN can be converted exactly,\n+         * and yet the left-hand side evaluates to true.\n+         * The right-hand side checks for non Double.NaN.\n+         *\/\n+        float result = (float) value;\n+        if ((double) result != value && value == value) {\n+            throw newArithmeticExceptionInexact(value);\n+        }\n+        return result;\n+    }\n+\n+    \/**\n+     * Returns the value of the {@code long} argument,\n+     * throwing an exception if the conversion is inexact.\n+     * The method returns if and only if the argument and the result\n+     * are mathematically equal.\n+     *\n+     * <p>Special case:\n+     * <ul>\n+     * <li>If the argument is {@code 0L}, the method returns {@code 0.0}.\n+     * <\/ul>\n+     *\n+     * @param value the {@code long} value\n+     * @return the argument as a {@code double}\n+     * @throws ArithmeticException if the conversion is inexact\n+     * @since 19\n+     *\/\n+    @ForceInline\n+    public static double toDoubleExact(long value) {\n+        \/*\n+         * The left-hand side of the test below correctly discriminates\n+         * inexact conversions, *except* for Long.MAX_VALUE.\n+         * Long.MAX_VALUE cannot be converted exactly,\n+         * and yet the left-hand side evaluates to false.\n+         *\/\n+        double result = (double) value;\n+        if ((long) result != value || value == Long.MAX_VALUE) {\n+            throw newArithmeticExceptionOverflow(value);\n+        }\n+        return result;\n+    }\n+\n+    \/**\n+     * Returns the value of the {@code double} argument,\n+     * throwing an exception if the conversion is inexact.\n+     * The method returns if and only if the argument and the result\n+     * are mathematically equal.\n+     *\n+     * <p>Special cases:\n+     * <ul>\n+     * <li>If the argument is {@link Double#NEGATIVE_INFINITY},\n+     * {@link Double#POSITIVE_INFINITY} or {@link Double#NaN},\n+     * the method throws.\n+     * <li>If the argument is {@code -0.0} or {@code 0.0},\n+     * the method returns {@code 0L}.\n+     * <\/ul>\n+     *\n+     * @param value the {@code double} value\n+     * @return the argument as a {@code long}\n+     * @throws ArithmeticException if the conversion is inexact\n+     * @see Math#rint(double)\n+     * @see Math#round(double)\n+     * @since 19\n+     *\/\n+    @ForceInline\n+    public static long toLongExact(double value) {\n+        \/*\n+         * The left-hand side of the test below correctly discriminates\n+         * inexact conversions, *except* for 0x1p63.\n+         * 0x1p63 cannot be converted exactly,\n+         * and yet the left-hand side evaluates to false.\n+         *\/\n+        long result = (long) value;\n+        if ((double) result != value || value == 0x1p63) {\n+            throw newArithmeticExceptionInexact(value);\n+        }\n+        return result;\n+    }\n+\n+    \/**\n+     * Returns the value of the {@code long} argument,\n+     * throwing an exception if the value overflows the range\n+     * [0, 2<sup>{@link Integer#SIZE}<\/sup>) an unsigned int.\n+     *\n+     * @param value the {@code long} value\n+     * @return the argument as an unsigned int\n+     * @throws ArithmeticException if the argument overflows an unsigned int\n+     * @since 19\n+     *\/\n+    @ForceInline\n+    public static long toUnsignedIntRangeExact(long value) {\n+        long result = value & 0xFFFF_FFFFL;\n+        if (result != value) {\n+            throw newArithmeticExceptionOverflow(value);\n+        }\n+        return result;\n+    }\n+\n+    \/**\n+     * Returns the value of the {@code long} argument,\n+     * throwing an exception if the value overflows the range\n+     * [0, 2<sup>{@link Short#SIZE}<\/sup>) an unsigned int.\n+     *\n+     * @param value the {@code long} value\n+     * @return the argument as an unsigned short\n+     * @throws ArithmeticException if the argument overflows an unsigned short\n+     * @since 19\n+     *\/\n+    @ForceInline\n+    public static int toUnsignedShortRangeExact(long value) {\n+        int result = (int) value & 0xFFFF;\n+        if ((long) result != value) {\n+            throw newArithmeticExceptionOverflow(value);\n@@ -1358,1 +1602,20 @@\n-        return (int)value;\n+        return result;\n+    }\n+\n+    \/**\n+     * Returns the value of the {@code long} argument,\n+     * throwing an exception if the value overflows the range\n+     * [0, 2<sup>{@link Byte#SIZE}<\/sup>) an unsigned int.\n+     *\n+     * @param value the {@code long} value\n+     * @return the argument as an unsigned byte\n+     * @throws ArithmeticException if the argument overflows an unsigned byte\n+     * @since 19\n+     *\/\n+    @ForceInline\n+    public static int toUnsignedByteRangeExact(long value) {\n+        int result = (int) value & 0xFF;\n+        if ((long) result != value) {\n+            throw newArithmeticExceptionOverflow(value);\n+        }\n+        return result;\n@@ -3252,0 +3515,9 @@\n+\n+    private static ArithmeticException newArithmeticExceptionOverflow(long value) {\n+        return new ArithmeticException(\"integer overflow on \" + value);\n+    }\n+\n+    private static ArithmeticException newArithmeticExceptionInexact(double value) {\n+        return new ArithmeticException(\"inexact conversion on \" + value);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Math.java","additions":278,"deletions":6,"binary":false,"changes":284,"status":"modified"},{"patch":"@@ -0,0 +1,337 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.math.BigDecimal;\n+import java.util.function.Function;\n+\n+import static java.lang.Math.*;\n+\n+\/**\n+ * @test\n+ * @summary Test Math to*Exact(*) methods.\n+ * @bug 8279986\n+ *\/\n+\n+\/*\n+ * To avoid a combinatorial explosion of argument and return types,\n+ * all integer types are lifted to Long and\n+ * all floating-point types are lifted to Double.\n+ * These conversions are lossless, even for special floating-point values.\n+ *\/\n+public class ToExact {\n+\n+    private static int failures;\n+    private static int errors;\n+\n+\n+    private ToExact() {\n+        throw new AssertionError();\n+    }\n+\n+    public static void main(String[] args) {\n+        failures = 0;\n+        errors = 0;\n+        testToByteExact_long();\n+        testToShortExact_long();\n+        testToIntExact_long();\n+        testToIntExact_double();\n+\n+        testToLongExact_double();\n+        testToDoubleExact_long();\n+\n+        testToFloatExact_long();\n+        testToFloatExact_double();\n+\n+        testToUnsignedIntRangeExact_long();\n+        testToUnsignedShortRangeExact_long();\n+        testToUnsignedByteRangeExact_long();\n+        if (failures > 0 || errors > 0) {\n+            throw new RuntimeException(\n+                    String.format(\"%d failures and %d errors%n\", failures, errors));\n+        }\n+    }\n+\n+    private static void testToByteExact_long() {\n+        testCommonToExact_long(\"toByteExact\", (Number v) -> toByteExact(v.longValue()));\n+        testToByteExact(Byte.MIN_VALUE - 1L, null);\n+        testToByteExact((long) Byte.MIN_VALUE, (long) Byte.MIN_VALUE);\n+        testToByteExact(Byte.MIN_VALUE + 1L, Byte.MIN_VALUE + 1L);\n+        testToByteExact(Byte.MAX_VALUE - 1L, Byte.MAX_VALUE - 1L);\n+        testToByteExact((long) Byte.MAX_VALUE, (long) Byte.MAX_VALUE);\n+        testToByteExact(Byte.MAX_VALUE + 1L, null);\n+    }\n+\n+    private static void testToShortExact_long() {\n+        testCommonToExact_long(\"toShortExact\", (Number v) -> toShortExact(v.longValue()));\n+        testToShortExact(Short.MIN_VALUE - 1, null);\n+        testToShortExact(Short.MIN_VALUE, (long) Short.MIN_VALUE);\n+        testToShortExact(Short.MIN_VALUE + 1, Short.MIN_VALUE + 1L);\n+        testToShortExact(Short.MAX_VALUE - 1, Short.MAX_VALUE - 1L);\n+        testToShortExact(Short.MAX_VALUE, (long) Short.MAX_VALUE);\n+        testToShortExact(Short.MAX_VALUE + 1, null);\n+    }\n+\n+    private static void testToIntExact_long() {\n+        testCommonToExact_long(\"toIntExact\", (Number v) -> toIntExact(v.longValue()));\n+        testToIntExact(Integer.MIN_VALUE - 1L, null);\n+        testToIntExact((long) Integer.MIN_VALUE, (long) Integer.MIN_VALUE);\n+        testToIntExact(Integer.MIN_VALUE + 1L, Integer.MIN_VALUE + 1L);\n+        testToIntExact(Integer.MAX_VALUE - 1L, Integer.MAX_VALUE - 1L);\n+        testToIntExact((long) Integer.MAX_VALUE, (long) Integer.MAX_VALUE);\n+        testToIntExact(Integer.MAX_VALUE + 1L, null);\n+    }\n+\n+    private static void testToIntExact_double() {\n+        testCommonToExact_double(\"toIntExact\", (Number v) -> toIntExact(v.doubleValue()));\n+        testToIntExact(-0x1p31 - 1, null);\n+        testToIntExact(-0x1p31, (long) Integer.MIN_VALUE);\n+        testToIntExact(-0x1p31 + 0.5, null);\n+        testToIntExact(-0x1p31 + 1, Integer.MIN_VALUE + 1L);\n+        testToIntExact(0x1p31 - 2, Integer.MAX_VALUE - 1L);\n+        testToIntExact(0x1p31 - 1, (long) Integer.MAX_VALUE);\n+        testToIntExact(0x1p31 - 0.5, null);\n+        testToIntExact(0x1p31, null);\n+    }\n+\n+    private static void testToLongExact_double() {\n+        testCommonToExact_double(\"toLongExact\", (Number v) -> toLongExact(v.doubleValue()));\n+        testToLongExact(-0x1.0p63, Long.MIN_VALUE);\n+        testToLongExact(-0x1p31 - 1, Integer.MIN_VALUE - 1L);\n+        testToLongExact(-0x1p31, (long) Integer.MIN_VALUE);\n+        testToLongExact(-0x1p31 + 0.5, null);\n+        testToLongExact(-0x1p31 + 1, Integer.MIN_VALUE + 1L);\n+        testToLongExact(0x1p31 - 2, Integer.MAX_VALUE - 1L);\n+        testToLongExact(0x1p31 - 1, (long) Integer.MAX_VALUE);\n+        testToLongExact(-0x1p31 - 0.5, null);\n+        testToLongExact(0x1p31, Integer.MAX_VALUE + 1L);\n+        testToLongExact(0x1.0p63, null);\n+    }\n+\n+    private static void testToFloatExact_long() {\n+        testCommonToExact_long(\"toFloatExact\", (Number v) -> toFloatExact(v.longValue()));\n+        testToFloatExact(Long.MIN_VALUE, (double) -0x1.0p63f);\n+        testToFloatExact(Long.MIN_VALUE + 1L, null);\n+        testToFloatExact(Integer.MIN_VALUE - 1L, null);\n+        testToFloatExact((long) Integer.MIN_VALUE, (double) -0x1p31f);\n+        testToFloatExact(Integer.MIN_VALUE + 1L, null);\n+        testToFloatExact(Integer.MAX_VALUE - 1L, null);\n+        testToFloatExact((long) Integer.MAX_VALUE, null);\n+        testToFloatExact(Integer.MAX_VALUE + 1L, (double) 0x1p31f);\n+        testToFloatExact(Long.MAX_VALUE - 1L, null);\n+        testToFloatExact(Long.MAX_VALUE, null);\n+    }\n+\n+    private static void testToFloatExact_double() {\n+        testToFloatExact(-0x1p63, (double) -0x1p63f);\n+        testToFloatExact(-0x1p31 - 1, null);\n+        testToFloatExact(-0x1p31, (double) -0x1p31f);\n+        testToFloatExact(-0x1p31 + 0.5, null);\n+        testToFloatExact(-0x1p31 + 1, null);\n+        testToFloatExact(-0x1p24 + 1, (double) (-0x1p24f + 1f));\n+        testToFloatExact(-0x1p23 + 0.5, (double) (-0x1p23f + 0.5f));\n+        testToFloatExact(0x1p23 - 0.5, (double) (0x1p23f - 0.5f));\n+        testToFloatExact(0x1p24 - 1, (double) (0x1p24f - 1f));\n+        testToFloatExact(0x1p31 - 2, null);\n+        testToFloatExact(0x1p31 - 1, null);\n+        testToFloatExact(-0x1p31 - 0.5, null);\n+        testToFloatExact(0x1p31, (double) 0x1p31f);\n+        testToFloatExact(0x1.0p63, (double) 0x1p63f);\n+\n+        testToFloatExact(Double.NEGATIVE_INFINITY, (double) Float.NEGATIVE_INFINITY);\n+        testToFloatExact(-0.0, (double) -0.0f);\n+        testToFloatExact(0.0, (double) 0.0f);\n+        testToFloatExact(Double.POSITIVE_INFINITY, (double) Float.POSITIVE_INFINITY);\n+        testToFloatExact(Double.NaN, (double) Float.NaN);\n+    }\n+\n+    private static void testToDoubleExact_long() {\n+        testCommonToExact_long(\"toDoubleExact\", (Number v) -> toDoubleExact(v.longValue()));\n+        testToDoubleExact(Long.MIN_VALUE, -0x1.0p63);\n+        testToDoubleExact(Long.MIN_VALUE + 1L, null);\n+        testToDoubleExact(Integer.MIN_VALUE - 1L, -0x1p31 - 1);\n+        testToDoubleExact((long) Integer.MIN_VALUE, -0x1p31);\n+        testToDoubleExact(Integer.MIN_VALUE + 1L, -0x1p31 + 1);\n+        testToDoubleExact(Integer.MAX_VALUE - 1L, 0x1p31 - 2);\n+        testToDoubleExact((long) Integer.MAX_VALUE, 0x1p31 - 1);\n+        testToDoubleExact(Integer.MAX_VALUE + 1L, 0x1p31);\n+        testToDoubleExact(Long.MAX_VALUE - 1L, null);\n+        testToDoubleExact(Long.MAX_VALUE, null);\n+    }\n+\n+    private static void testToUnsignedIntRangeExact_long() {\n+        testToUnsignedIntRangeExact(-1L, null);\n+        testToUnsignedIntRangeExact(0L, 0L);\n+        testToUnsignedIntRangeExact((long) Integer.MAX_VALUE, (long) Integer.MAX_VALUE);\n+        testToUnsignedIntRangeExact((1L << Integer.SIZE) - 1, (1L << Integer.SIZE) - 1);\n+        testToUnsignedIntRangeExact(1L << Integer.SIZE, null);\n+    }\n+\n+    private static void testToUnsignedShortRangeExact_long() {\n+        testToUnsignedShortRangeExact(-1L, null);\n+        testToUnsignedShortRangeExact(0L, 0L);\n+        testToUnsignedShortRangeExact((long) Short.MAX_VALUE, (long) Short.MAX_VALUE);\n+        testToUnsignedShortRangeExact((1L << Short.SIZE) - 1, (1L << Short.SIZE) - 1);\n+        testToUnsignedShortRangeExact(1L << Short.SIZE, null);\n+    }\n+\n+    private static void testToUnsignedByteRangeExact_long() {\n+        testToUnsignedByteRangeExact(-1L, null);\n+        testToUnsignedByteRangeExact(0L, 0L);\n+        testToUnsignedByteRangeExact((long) Byte.MAX_VALUE, (long) Byte.MAX_VALUE);\n+        testToUnsignedByteRangeExact((1L << Byte.SIZE) - 1, (1L << Byte.SIZE) - 1);\n+        testToUnsignedByteRangeExact(1L << Byte.SIZE, null);\n+    }\n+\n+\n+    \/*\n+     * support methods\n+     *\/\n+    private static void testToByteExact(long arg, Long expected) {\n+        testToExact(\"toByteExact\", v -> toByteExact(v.longValue()), arg, expected);\n+    }\n+\n+    private static void testToUnsignedByteRangeExact(long arg, Long expected) {\n+        testToExact(\"toUnsignedByteRangeExact\", v -> toUnsignedByteRangeExact(v.longValue()), arg, expected);\n+    }\n+\n+    private static void testToShortExact(long arg, Long expected) {\n+        testToExact(\"toShortExact\", v -> toShortExact(v.longValue()), arg, expected);\n+    }\n+\n+    private static void testToUnsignedShortRangeExact(long arg, Long expected) {\n+        testToExact(\"toUnsignedShortRangeExact\", v -> toUnsignedShortRangeExact(v.longValue()), arg, expected);\n+    }\n+\n+    private static void testToIntExact(long arg, Long expected) {\n+        testToExact(\"toIntExact\", v -> toIntExact(v.longValue()), arg, expected);\n+    }\n+\n+    private static void testToUnsignedIntRangeExact(long arg, Long expected) {\n+        testToExact(\"toUnsignedIntRangeExact\", v -> toUnsignedIntRangeExact(v.longValue()), arg, expected);\n+    }\n+\n+    private static void testToIntExact(double arg, Long expected) {\n+        testToExact(\"toIntExact\", v -> toIntExact(v.doubleValue()), arg, expected);\n+    }\n+\n+    private static void testToLongExact(double arg, Long expected) {\n+        testToExact(\"toLongExact\", v -> toLongExact(v.doubleValue()), arg, expected);\n+    }\n+\n+    private static void testToDoubleExact(long arg, Double expected) {\n+        testToExact(\"toDoubleExact\", v -> toDoubleExact(v.longValue()), arg, expected);\n+    }\n+\n+    private static void testToFloatExact(long arg, Double expected) {\n+        testToExact(\"toFloatExact\", v -> toFloatExact(v.longValue()), arg, expected);\n+    }\n+\n+    private static void testToFloatExact(double arg, Double expected) {\n+        testToExact(\"toFloatExact\", v -> toFloatExact(v.doubleValue()), arg, expected);\n+    }\n+\n+    \/*\n+     * expected is null if the underlying conversion is expected to throw.\n+     *\/\n+    private static void testToExact(String name, Function<? super Number, ? extends Number> toExact,\n+                                    Number arg, Number expected) {\n+        if (!((arg instanceof Long || arg instanceof Double) &&\n+                (expected == null || expected instanceof Long || expected instanceof Double))) {\n+            throw new AssertionError(String.format(\"arg class=%s, expected class=%s\",\n+                    arg.getClass(), expected.getClass()));\n+        }\n+        try {\n+            var result = toExact.apply(arg);\n+            if (expected == null || !isNumericallyEqual(result, expected)) {\n+                failures += 1;\n+                failure(name, arg, result);\n+            }\n+        } catch (ArithmeticException swallowed) {\n+            if (expected != null) {\n+                errors += 1;\n+                error(name, arg);\n+            }\n+        }\n+    }\n+\n+    private static void testCommonToExact_long(String name, Function<? super Number, ? extends Number> toExact) {\n+        testToExact(name, toExact, -100L, -100L);\n+        testToExact(name, toExact, -1L, -1L);\n+        testToExact(name, toExact, 0L, 0L);\n+        testToExact(name, toExact, 1L, 1L);\n+        testToExact(name, toExact, 100L, 100L);\n+    }\n+\n+    private static void testCommonToExact_double(String name, Function<? super Number, ? extends Number> toExact) {\n+        testToExact(name, toExact, -100.5, null);\n+        testToExact(name, toExact, -100.0, -100L);\n+        testToExact(name, toExact, -1.5, null);\n+        testToExact(name, toExact, -1.0, -1L);\n+        testToExact(name, toExact, -0.0, 0L);\n+        testToExact(name, toExact, 0.0, 0L);\n+        testToExact(name, toExact, 1.0, 1L);\n+        testToExact(name, toExact, 1.5, null);\n+        testToExact(name, toExact, 100.0, 100L);\n+        testToExact(name, toExact, 100.5, null);\n+\n+        testToExact(name, toExact, -Double.POSITIVE_INFINITY, null);\n+        testToExact(name, toExact, -Double.MAX_VALUE, null);\n+        testToExact(name, toExact, -Double.MIN_NORMAL, null);\n+        testToExact(name, toExact, -Double.MIN_VALUE, null);\n+        testToExact(name, toExact, Double.MIN_VALUE, null);\n+        testToExact(name, toExact, Double.MIN_NORMAL, null);\n+        testToExact(name, toExact, Double.MAX_VALUE, null);\n+        testToExact(name, toExact, Double.POSITIVE_INFINITY, null);\n+\n+        testToExact(name, toExact, Double.NaN, null);\n+    }\n+\n+    private static boolean isNumericallyEqual(Number result, Number expected) {\n+        return\n+            result instanceof Long\n+            ? expected instanceof Long\n+                ? result.longValue() == expected.longValue()\n+                : isNumericallyEqual(result.longValue(), expected.doubleValue())\n+            : expected instanceof Long\n+                ? isNumericallyEqual(expected.longValue(), result.doubleValue())\n+                : Double.compare(result.doubleValue(), expected.doubleValue()) == 0;\n+    }\n+\n+    private static boolean isNumericallyEqual(long value, double result) {\n+        return new BigDecimal(value).compareTo(new BigDecimal(result)) == 0;\n+    }\n+\n+    private static void failure(String meth, Number arg, Number result) {\n+        var as = arg instanceof Long ? \"%d\" : \"%a\";\n+        var rs = result instanceof Long ? \"%d\" : \"%a\";\n+        System.out.format(\"FAIL: \" + meth + \"(\" + as + \") returns \" + rs + \"%n\",\n+                arg.longValue(), result.longValue());\n+    }\n+\n+    private static void error(String meth, Number arg) {\n+        var as = arg instanceof Long ? \"%d\" : \"%a\";\n+        System.out.format(\"ERROR: \" + meth + \"(\" + as + \") unexpectedly throws%n\",\n+                arg.longValue());\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/Math\/ToExact.java","additions":337,"deletions":0,"binary":false,"changes":337,"status":"added"}]}