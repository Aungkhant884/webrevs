{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2013, 2022, Red Hat, Inc. All rights reserved.\n@@ -26,1 +26,1 @@\n-#include \"gc\/shenandoah\/shenandoahBarrierSet.hpp\"\n+#include \"gc\/shared\/barrierSetNMethod.hpp\"\n@@ -102,1 +102,5 @@\n-    ShenandoahThreadLocalData::set_disarmed_value(thread, ShenandoahCodeRoots::disarmed_value());\n+\n+    BarrierSetNMethod* bs_nm = barrier_set_nmethod();\n+    if (bs_nm != NULL) {\n+      thread->set_nmethod_disarm_value(bs_nm->disarmed_value());\n+    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -72,13 +72,1 @@\n-}\n-\n-int ShenandoahBarrierSetNMethod::disarmed_value() const {\n-  return ShenandoahCodeRoots::disarmed_value();\n-}\n-\n-ByteSize ShenandoahBarrierSetNMethod::thread_disarmed_offset() const {\n-  return ShenandoahThreadLocalData::disarmed_value_offset();\n-}\n-\n-int* ShenandoahBarrierSetNMethod::disarmed_value_address() const {\n-  return ShenandoahCodeRoots::disarmed_value_address();\n-}\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSetNMethod.cpp","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2019, 2022, Red Hat, Inc. All rights reserved.\n@@ -38,4 +38,0 @@\n-protected:\n-  virtual int disarmed_value() const;\n-  virtual bool nmethod_entry_barrier(nmethod* nm);\n-\n@@ -46,2 +42,1 @@\n-  virtual ByteSize thread_disarmed_offset() const;\n-  virtual int* disarmed_value_address() const;\n+  virtual bool nmethod_entry_barrier(nmethod* nm);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSetNMethod.hpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -129,11 +129,1 @@\n-  assert(SafepointSynchronize::is_at_safepoint(), \"Must be at a safepoint\");\n-  _disarmed_value ++;\n-  \/\/ 0 is reserved for new nmethod\n-  if (_disarmed_value == 0) {\n-    _disarmed_value = 1;\n-  }\n-\n-  JavaThreadIteratorWithHandle jtiwh;\n-  for (JavaThread *thr = jtiwh.next(); thr != NULL; thr = jtiwh.next()) {\n-    ShenandoahThreadLocalData::set_disarmed_value(thr, _disarmed_value);\n-  }\n+  BarrierSet::barrier_set()->barrier_set_nmethod()->arm_all_nmethods();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCodeRoots.cpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2018, 2022, Red Hat, Inc. All rights reserved.\n@@ -47,1 +47,0 @@\n-  int  _disarmed_value;\n@@ -57,1 +56,0 @@\n-    _disarmed_value(0),\n@@ -59,4 +57,0 @@\n-\n-    \/\/ At least on x86_64, nmethod entry barrier encodes _disarmed_value offset\n-    \/\/ in instruction as disp8 immed\n-    assert(in_bytes(disarmed_value_offset()) < 128, \"Offset range check\");\n@@ -132,4 +126,0 @@\n-  static void set_disarmed_value(Thread* thread, int value) {\n-    data(thread)->_disarmed_value = value;\n-  }\n-\n@@ -185,4 +175,0 @@\n-\n-  static ByteSize disarmed_value_offset() {\n-    return Thread::gc_data_offset() + byte_offset_of(ShenandoahThreadLocalData, _disarmed_value);\n-  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.hpp","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"}]}