{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-    _monitor(Mutex::nonleaf,\n+    _monitor(Mutex::leaf,\n@@ -74,1 +74,1 @@\n-void G1ServiceThread::schedule(G1ServiceTask* task, jlong delay_ms) {\n+void G1ServiceThread::schedule(G1ServiceTask* task, jlong delay_ms, bool notify) {\n@@ -82,1 +82,1 @@\n-  MutexLocker ml(&_monitor, Mutex::_no_safepoint_check_flag);\n+  MonitorLocker ml(&_monitor, Mutex::_no_safepoint_check_flag);\n@@ -84,0 +84,3 @@\n+  if (notify) {\n+    ml.notify();\n+  }\n@@ -90,17 +93,1 @@\n-  schedule(task, delay_ms);\n-  notify();\n-}\n-\n-int64_t G1ServiceThread::time_to_next_task_ms() {\n-  assert(_monitor.owned_by_self(), \"Must be owner of lock\");\n-  assert(!_task_queue.is_empty(), \"Should not be called for empty list\");\n-\n-  jlong time_diff = _task_queue.peek()->time() - os::elapsed_counter();\n-  if (time_diff < 0) {\n-    \/\/ Run without sleeping.\n-    return 0;\n-  }\n-\n-  \/\/ Return sleep time in milliseconds. Using ceil to make sure we never\n-  \/\/ schedule a task too early.\n-  return (int64_t) ceil(TimeHelper::counter_to_millis(time_diff));\n+  schedule(task, delay_ms, true \/* notify *\/);\n@@ -109,1 +96,1 @@\n-void G1ServiceThread::notify() {\n+G1ServiceTask* G1ServiceThread::wait_for_task() {\n@@ -111,16 +98,20 @@\n-  ml.notify();\n-}\n-\n-void G1ServiceThread::sleep_before_next_cycle() {\n-  MonitorLocker ml(&_monitor, Mutex::_no_safepoint_check_flag);\n-  if (should_terminate()) {\n-    return;\n-  } else if (_task_queue.is_empty()) {\n-    \/\/ Sleep until new task is registered if no tasks available.\n-    log_trace(gc, task)(\"G1 Service Thread (wait for new tasks)\");\n-    ml.wait(0);\n-  } else {\n-    int64_t sleep_ms = time_to_next_task_ms();\n-    if (sleep_ms > 0) {\n-      log_trace(gc, task)(\"G1 Service Thread (wait) %1.3fs\", sleep_ms \/ 1000.0);\n-      ml.wait(sleep_ms);\n+  while (!should_terminate()) {\n+    if (_task_queue.is_empty()) {\n+      log_trace(gc, task)(\"G1 Service Thread (wait for new tasks)\");\n+      ml.wait();\n+    } else {\n+      G1ServiceTask* task = _task_queue.front();\n+      jlong scheduled = task->time();\n+      jlong now = os::elapsed_counter();\n+      if (scheduled <= now) {\n+        _task_queue.remove_front();\n+        return task;\n+      } else {\n+        \/\/ Round up to try not to wake up early, and to avoid round down to\n+        \/\/ zero (which has special meaning of wait forever) by conversion.\n+        double delay = ceil(TimeHelper::counter_to_millis(scheduled - now));\n+        log_trace(gc, task)(\"G1 Service Thread (wait %1.3fs)\", (delay \/ 1000.0));\n+        int64_t delay_ms = static_cast<int64_t>(delay);\n+        assert(delay_ms > 0, \"invariant\");\n+        ml.wait(delay_ms);\n+      }\n@@ -129,9 +120,1 @@\n-}\n-\n-G1ServiceTask* G1ServiceThread::pop_due_task() {\n-  MutexLocker ml(&_monitor, Mutex::_no_safepoint_check_flag);\n-  if (_task_queue.is_empty() || time_to_next_task_ms() != 0) {\n-    return NULL;\n-  }\n-\n-  return _task_queue.pop();\n+  return nullptr;               \/\/ Return nullptr when terminating.\n@@ -141,1 +124,1 @@\n-  double start = os::elapsedTime();\n+  jlong start = os::elapsed_counter();\n@@ -144,1 +127,7 @@\n-  log_debug(gc, task, start)(\"G1 Service Thread (%s) (run)\", task->name());\n+  assert(task->time() <= start,\n+         \"task run early: \" JLONG_FORMAT \" > \" JLONG_FORMAT,\n+         task->time(), start);\n+  log_debug(gc, task, start)(\"G1 Service Thread (%s) (run %1.3fms after schedule)\",\n+                             task->name(),\n+                             TimeHelper::counter_to_millis(start - task->time()));\n+\n@@ -147,4 +136,4 @@\n-  double duration = os::elapsedTime() - start;\n-  double vduration = os::elapsedVTime() - vstart;\n-  log_debug(gc, task)(\"G1 Service Thread (%s) (run) %1.3fms (cpu: %1.3fms)\",\n-                      task->name(), duration * MILLIUNITS, vduration * MILLIUNITS);\n+  log_debug(gc, task)(\"G1 Service Thread (%s) (run: %1.3fms) (cpu: %1.3fms)\",\n+                      task->name(),\n+                      TimeHelper::counter_to_millis(os::elapsed_counter() - start),\n+                      (os::elapsedVTime() - vstart) * MILLIUNITS);\n@@ -154,7 +143,4 @@\n-  while (!should_terminate()) {\n-    G1ServiceTask* task = pop_due_task();\n-    if (task != NULL) {\n-      run_task(task);\n-    }\n-\n-    sleep_before_next_cycle();\n+  while (true) {\n+    G1ServiceTask* task = wait_for_task();\n+    if (task == nullptr) break;\n+    run_task(task);\n@@ -162,1 +148,1 @@\n-\n+  assert(should_terminate(), \"invariant\");\n@@ -167,1 +153,2 @@\n-  notify();\n+  MonitorLocker ml(&_monitor, Mutex::_no_safepoint_check_flag);\n+  ml.notify();\n@@ -187,1 +174,2 @@\n-  _service_thread->schedule(this, delay_ms);\n+  \/\/ No need to notify, since we *are* the service thread.\n+  _service_thread->schedule(this, delay_ms, false \/* notify *\/);\n@@ -213,1 +201,1 @@\n-G1ServiceTask* G1ServiceTaskQueue::pop() {\n+void G1ServiceTaskQueue::remove_front() {\n@@ -219,2 +207,0 @@\n-\n-  return task;\n@@ -223,1 +209,1 @@\n-G1ServiceTask* G1ServiceTaskQueue::peek() {\n+G1ServiceTask* G1ServiceTaskQueue::front() {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ServiceThread.cpp","additions":53,"deletions":67,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,2 +90,5 @@\n-  G1ServiceTask* pop();\n-  G1ServiceTask* peek();\n+\n+  \/\/ precondition: !is_empty().\n+  G1ServiceTask* front();\n+  \/\/ precondition: !is_empty().\n+  void remove_front();\n@@ -110,5 +113,3 @@\n-  \/\/ Returns the time in milliseconds until the next task is due.\n-  \/\/ Used both to determine if there are tasks ready to run and\n-  \/\/ how long to sleep when nothing is ready.\n-  int64_t time_to_next_task_ms();\n-  void sleep_before_next_cycle();\n+  \/\/ Return the next ready task, waiting until a task is ready.\n+  \/\/ Instead returns nullptr if termination requested.\n+  G1ServiceTask* wait_for_task();\n@@ -116,1 +117,0 @@\n-  G1ServiceTask* pop_due_task();\n@@ -121,5 +121,1 @@\n-  void schedule(G1ServiceTask* task, jlong delay);\n-\n-  \/\/ Notify a change to the service thread. Used to either stop\n-  \/\/ the service or to force check for new tasks.\n-  void notify();\n+  void schedule(G1ServiceTask* task, jlong delay, bool notify);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ServiceThread.hpp","additions":10,"deletions":14,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -145,2 +145,3 @@\n-    while (queue.peek()->time() < now) {\n-      TestTask* task = (TestTask*) queue.pop();\n+    while (queue.front()->time() < now) {\n+      TestTask* task = (TestTask*) queue.front();\n+      queue.remove_front();\n@@ -156,1 +157,2 @@\n-    G1ServiceTask* task = queue.pop();\n+    G1ServiceTask* task = queue.front();\n+    queue.remove_front();\n@@ -162,1 +164,1 @@\n-TEST_VM_ASSERT_MSG(G1ServiceTaskQueue, pop_empty,\n+TEST_VM_ASSERT_MSG(G1ServiceTaskQueue, remove_from_empty,\n@@ -165,1 +167,1 @@\n-  queue.pop();\n+  queue.remove_front();\n@@ -168,1 +170,1 @@\n-TEST_VM_ASSERT_MSG(G1ServiceTaskQueue, peek_empty,\n+TEST_VM_ASSERT_MSG(G1ServiceTaskQueue, get_from_empty,\n@@ -171,1 +173,1 @@\n-  queue.peek();\n+  queue.front();\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1ServiceThread.cpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"}]}