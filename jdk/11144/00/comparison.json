{"files":[{"patch":"@@ -579,0 +579,10 @@\n+C2V_VMENTRY_NULL(jobject, getUncachedStringInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index))\n+  constantPoolHandle cp(THREAD, UNPACK_PAIR(ConstantPool, cp));\n+  constantTag tag = cp->tag_at(index);\n+  if (!tag.is_string()) {\n+    JVMCI_THROW_MSG_NULL(IllegalArgumentException, err_msg(\"Unexpected constant pool tag at index %d: %d\", index, tag.value()));\n+  }\n+  oop obj = cp->uncached_string_at(index, CHECK_NULL);\n+  return JVMCIENV->get_jobject(JVMCIENV->get_object_constant(obj));\n+C2V_END\n+\n@@ -2837,0 +2847,1 @@\n+  {CC \"getUncachedStringInPool\",                      CC \"(\" HS_CONSTANT_POOL2 \"I)\" JAVACONSTANT,                                           FN_PTR(getUncachedStringInPool)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -177,0 +177,1 @@\n+  nonstatic_field(JavaThread,                  _extentLocalCache,                             OopHandle)                             \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -254,0 +254,12 @@\n+    \/**\n+     * Resolves the entry at index {@code cpi} in {@code constantPool} to an interned String object.\n+     *\n+     * The behavior of this method is undefined if {@code cpi} does not denote an\n+     * {@code JVM_CONSTANT_String}.\n+     *\/\n+    JavaConstant getUncachedStringInPool(HotSpotConstantPool constantPool, int cpi) {\n+        return getUncachedStringInPool(constantPool, constantPool.getConstantPoolPointer(), cpi);\n+    }\n+\n+    private native JavaConstant getUncachedStringInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int cpi);\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -622,0 +622,21 @@\n+    \/**\n+     * Gets the {@link JavaConstant} for the {@code ConstantValue} attribute of a field.\n+     *\/\n+    JavaConstant getStaticFieldConstantValue(int cpi) {\n+        final JvmConstant tag = getTagAt(cpi);\n+        switch (tag.name) {\n+            case \"Integer\":\n+                return JavaConstant.forInt(getIntAt(cpi));\n+            case \"Long\":\n+                return JavaConstant.forLong(getLongAt(cpi));\n+            case \"Float\":\n+                return JavaConstant.forFloat(getFloatAt(cpi));\n+            case \"Double\":\n+                return JavaConstant.forDouble(getDoubleAt(cpi));\n+            case \"String\":\n+                return compilerToVM().getUncachedStringInPool(this, cpi);\n+            default:\n+                throw new IllegalArgumentException(\"Illegal entry for a ConstantValue attribute:\" + tag);\n+        }\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotConstantPool.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -217,0 +217,5 @@\n+\n+    @Override\n+    public JavaConstant getConstantValue() {\n+        return holder.createFieldInfo(index).getConstantValue();\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaFieldImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -692,0 +692,4 @@\n+        private int getConstantValueIndex() {\n+            return readFieldSlot(config().fieldInfoConstantValueIndexOffset);\n+        }\n+\n@@ -727,0 +731,13 @@\n+        \/**\n+         * Gets the {@link JavaConstant} for the {@code ConstantValue} attribute of this field.\n+         *\n+         * @return {@code null} if this field has no {@code ConstantValue} attribute\n+         *\/\n+        public JavaConstant getConstantValue() {\n+            int cvIndex = getConstantValueIndex();\n+            if (cvIndex == 0) {\n+                return null;\n+            }\n+            return constantPool.getStaticFieldConstantValue(cvIndex);\n+        }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -122,0 +122,1 @@\n+    final int fieldInfoConstantValueIndexOffset = getConstant(\"FieldInfo::initval_index_offset\", Integer.class);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -66,0 +66,11 @@\n+\n+    \/**\n+     * Gets the value of the {@code ConstantValue} attribute ({@jvms 4.7.2}) associated with this\n+     * field.\n+     *\n+     * @return {@code null} if this field has no {@code ConstantValue} attribute\n+     * @throws UnsupportedOperationException if this operation is not supported\n+     *\/\n+    default JavaConstant getConstantValue() {\n+        throw new UnsupportedOperationException();\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.meta\/src\/jdk\/vm\/ci\/meta\/ResolvedJavaField.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @ignore 8249621\n@@ -31,0 +30,1 @@\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.common\n@@ -40,0 +40,2 @@\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNull;\n@@ -49,0 +51,1 @@\n+import java.lang.reflect.Modifier;\n@@ -57,0 +60,3 @@\n+import jdk.vm.ci.common.JVMCIError;\n+import jdk.vm.ci.meta.ConstantReflectionProvider;\n+import jdk.vm.ci.meta.JavaConstant;\n@@ -120,0 +126,48 @@\n+    @Test\n+    public void getDeclaringClassTest() {\n+        for (Map.Entry<Field, ResolvedJavaField> e : fields.entrySet()) {\n+            ResolvedJavaField field = e.getValue();\n+            ResolvedJavaType actual = field.getDeclaringClass();\n+            ResolvedJavaType expect = metaAccess.lookupJavaType(e.getKey().getDeclaringClass());\n+            assertEquals(field.toString(), expect, actual);\n+        }\n+    }\n+\n+    @Test\n+    public void getOffsetTest() {\n+        for (Map.Entry<Field, ResolvedJavaField> e : fields.entrySet()) {\n+            Field javaField = e.getKey();\n+            ResolvedJavaField field = e.getValue();\n+            int actual = field.getOffset();\n+            long expect = field.isStatic() ? unsafe.staticFieldOffset(javaField) : unsafe.objectFieldOffset(javaField);\n+            assertEquals(field.toString(), expect, actual);\n+        }\n+    }\n+\n+    @Test\n+    public void isFinalTest() {\n+        for (Map.Entry<Field, ResolvedJavaField> e : fields.entrySet()) {\n+            ResolvedJavaField field = e.getValue();\n+            boolean actual = field.isFinal();\n+            boolean expect = Modifier.isFinal(e.getKey().getModifiers());\n+            assertEquals(field.toString(), expect, actual);\n+        }\n+    }\n+\n+    @Test\n+    public void isInternalTest() {\n+        for (Class<?> c : classes) {\n+            ResolvedJavaType type = metaAccess.lookupJavaType(c);\n+            for (ResolvedJavaField field : type.getInstanceFields(false)) {\n+                if (field.isInternal()) {\n+                    try {\n+                        c.getDeclaredField(field.getName());\n+                        throw new AssertionError(\"got reflection object for internal field: \" + field);\n+                    } catch (NoSuchFieldException e) {\n+                        \/\/ expected\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n@@ -132,4 +186,0 @@\n-        \"getDeclaringClass\",\n-        \"getOffset\",\n-        \"isInternal\",\n-        \"isFinal\"\n@@ -235,0 +285,64 @@\n+\n+    @Test\n+    public void getConstantValueTest() {\n+        ConstantReflectionProvider cr = constantReflection;\n+        Map<String, JavaConstant> expects = Map.of(\n+                        \"INT\", JavaConstant.forInt(42),\n+                        \"SHORT\", JavaConstant.forInt(43),\n+                        \"CHAR\", JavaConstant.forInt(44),\n+                        \"BYTE\", JavaConstant.forInt(45),\n+                        \"FLOAT\", JavaConstant.forFloat(46.46F),\n+                        \"LONG\", JavaConstant.forLong(47L),\n+                        \"DOUBLE\", JavaConstant.forDouble(48.48D));\n+        ResolvedJavaType type = metaAccess.lookupJavaType(FieldsWithConstantValueAttributes.class);\n+        for (ResolvedJavaField field : type.getStaticFields()) {\n+            JavaConstant actual = field.getConstantValue();\n+            String name = field.getName();\n+            if (name.endsWith(\"2\")) {\n+                assertNull(field.toString(), actual);\n+            } else if (name.equals(\"STRING\")) {\n+                JavaConstant expect = cr.forString(\"STRING_VALUE\");\n+                assertEquals(field.toString(), expect, actual);\n+\n+                \/\/ String ConstantValues are interned so should not\n+                \/\/ be identical to a newly allocated String\n+                expect = cr.forString(new String(\"STRING_VALUE\"));\n+                assertNotEquals(field.toString(), expect, actual);\n+            } else {\n+                JavaConstant expect = expects.get(name);\n+                assertEquals(field.toString(), expect, actual);\n+            }\n+        }\n+    }\n+}\n+\n+class FieldsWithConstantValueAttributes {\n+    public static final String STRING = \"STRING_VALUE\";\n+    public static final int INT = 42;\n+    public static final short SHORT = 43;\n+    public static final char CHAR = 44;\n+    public static final byte BYTE = 45;\n+    public static final float FLOAT = 46.46F;\n+    public static final long LONG = 47L;\n+    public static final double DOUBLE = 48.48D;\n+\n+    public static final String STRING2;\n+    public static final int INT2;\n+    public static final short SHORT2;\n+    public static final char CHAR2;\n+    public static final byte BYTE2;\n+    public static final float FLOAT2;\n+    public static final long LONG2;\n+    public static final double DOUBLE2;\n+\n+    static {\n+        JVMCIError.shouldNotReachHere(\"should not be initialized\");\n+        STRING2 = STRING;\n+        INT2 = INT;\n+        SHORT2 = SHORT;\n+        BYTE2 = BYTE;\n+        CHAR2 = CHAR;\n+        FLOAT2 = FLOAT;\n+        LONG2 = LONG;\n+        DOUBLE2 = DOUBLE;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaField.java","additions":120,"deletions":6,"binary":false,"changes":126,"status":"modified"}]}