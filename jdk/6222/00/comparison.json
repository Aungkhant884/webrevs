{"files":[{"patch":"@@ -51,0 +51,3 @@\n+const char* C2Compiler::retry_no_iterative_escape_analysis() {\n+  return \"retry without iterative escape analysis\";\n+}\n@@ -102,0 +105,1 @@\n+  bool do_iterative_escape_analysis = DoEscapeAnalysis;\n@@ -107,1 +111,1 @@\n-    Options options(subsume_loads, do_escape_analysis, eliminate_boxing, do_locks_coarsening, install_code);\n+    Options options(subsume_loads, do_escape_analysis, do_iterative_escape_analysis, eliminate_boxing, do_locks_coarsening, install_code);\n@@ -126,0 +130,6 @@\n+        continue;  \/\/ retry\n+      }\n+      if (C.failure_reason_is(retry_no_iterative_escape_analysis())) {\n+        assert(do_iterative_escape_analysis, \"must make progress\");\n+        do_iterative_escape_analysis = false;\n+        env->report_failure(C.failure_reason());\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+  static const char* retry_no_iterative_escape_analysis();\n","filename":"src\/hotspot\/share\/opto\/c2compiler.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -502,0 +502,6 @@\n+  if (do_iterative_escape_analysis() != DoEscapeAnalysis && PrintOpto) {\n+    \/\/ Recompiling without iterative escape analysis\n+    tty->print_cr(\"*********************************************************\");\n+    tty->print_cr(\"** Bailout: Recompile without iterative escape analysis**\");\n+    tty->print_cr(\"*********************************************************\");\n+  }\n@@ -2164,7 +2170,3 @@\n-    ConnectionGraph::do_analysis(this, &igvn);\n-\n-    if (failing())  return;\n-\n-    \/\/ Optimize out fields loads from scalar replaceable allocations.\n-    igvn.optimize();\n-    print_method(PHASE_ITER_GVN_AFTER_EA, 2);\n+    bool progress;\n+    do {\n+      ConnectionGraph::do_analysis(this, &igvn);\n@@ -2172,1 +2174,1 @@\n-    if (failing())  return;\n+      if (failing())  return;\n@@ -2174,5 +2176,1 @@\n-    if (congraph() != NULL && macro_count() > 0) {\n-      TracePhase tp(\"macroEliminate\", &timers[_t_macroEliminate]);\n-      PhaseMacroExpand mexp(igvn);\n-      mexp.eliminate_macro_nodes();\n-      igvn.set_delay_transform(false);\n+      int mcount = macro_count(); \/\/ Record number of allocations and locks before IGVN\n@@ -2180,0 +2178,1 @@\n+      \/\/ Optimize out fields loads from scalar replaceable allocations.\n@@ -2181,1 +2180,1 @@\n-      print_method(PHASE_ITER_GVN_AFTER_ELIMINATION, 2);\n+      print_method(PHASE_ITER_GVN_AFTER_EA, 2);\n@@ -2184,1 +2183,18 @@\n-    }\n+\n+      if (congraph() != NULL && macro_count() > 0) {\n+        TracePhase tp(\"macroEliminate\", &timers[_t_macroEliminate]);\n+        PhaseMacroExpand mexp(igvn);\n+        mexp.eliminate_macro_nodes();\n+        igvn.set_delay_transform(false);\n+\n+        igvn.optimize();\n+        print_method(PHASE_ITER_GVN_AFTER_ELIMINATION, 2);\n+\n+        if (failing())  return;\n+      }\n+      progress = do_iterative_escape_analysis() &&\n+                 (macro_count() < mcount) &&\n+                 ConnectionGraph::has_candidates(this);\n+      \/\/ Try again if candidates exist and made progress\n+      \/\/ by removing some allocations and\/or locks.\n+    } while (progress);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":31,"deletions":15,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -171,0 +171,1 @@\n+  const bool _do_iterative_escape_analysis;  \/\/ Do iterative escape analysis.\n@@ -176,0 +177,1 @@\n+          bool do_iterative_escape_analysis,\n@@ -180,0 +182,1 @@\n+          _do_iterative_escape_analysis(do_iterative_escape_analysis),\n@@ -189,0 +192,1 @@\n+       \/* do_iterative_escape_analysis = *\/ false,\n@@ -537,0 +541,1 @@\n+  bool              do_iterative_escape_analysis() const  { return _options._do_iterative_escape_analysis; }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-ConnectionGraph::ConnectionGraph(Compile * C, PhaseIterGVN *igvn) :\n+ConnectionGraph::ConnectionGraph(Compile * C, PhaseIterGVN *igvn, int invocation) :\n@@ -52,0 +52,3 @@\n+  _invocation(invocation),\n+  _build_iterations(0),\n+  _build_time(0.),\n@@ -99,1 +102,5 @@\n-  ConnectionGraph* congraph = new(C->comp_arena()) ConnectionGraph(C, igvn);\n+  int invocation = 0;\n+  if (C->congraph() != NULL) {\n+    invocation = C->congraph()->_invocation + 1;\n+  }\n+  ConnectionGraph* congraph = new(C->comp_arena()) ConnectionGraph(C, igvn, invocation);\n@@ -1329,2 +1336,2 @@\n-    assert(ExitEscapeAnalysisOnTimeout, \"infinite EA connection graph build (%f sec, %d iterations) with %d nodes and worklist size %d\",\n-           _build_time, _build_iterations, nodes_size(), ptnodes_worklist.length());\n+    assert(ExitEscapeAnalysisOnTimeout, \"infinite EA connection graph build during invocation %d (%f sec, %d iterations) with %d nodes and worklist size %d\",\n+           _invocation, _build_time, _build_iterations, nodes_size(), ptnodes_worklist.length());\n@@ -1335,6 +1342,0 @@\n-#ifdef ASSERT\n-  if (Verbose && PrintEscapeAnalysis) {\n-    tty->print_cr(\"EA: %d iterations and %f sec to build connection graph with %d nodes and worklist size %d\",\n-                  _build_iterations, _build_time, nodes_size(), ptnodes_worklist.length());\n-  }\n-#endif\n@@ -2648,1 +2649,1 @@\n-      C->record_failure(C2Compiler::retry_no_escape_analysis());\n+      C->record_failure(_invocation > 0 ? C2Compiler::retry_no_iterative_escape_analysis() : C2Compiler::retry_no_escape_analysis());\n@@ -3219,1 +3220,1 @@\n-        _compile->record_failure(C2Compiler::retry_no_escape_analysis());\n+        _compile->record_failure(_invocation > 0 ? C2Compiler::retry_no_iterative_escape_analysis() : C2Compiler::retry_no_escape_analysis());\n@@ -3239,1 +3240,1 @@\n-        _compile->record_failure(C2Compiler::retry_no_escape_analysis());\n+        _compile->record_failure(_invocation > 0 ? C2Compiler::retry_no_iterative_escape_analysis() : C2Compiler::retry_no_escape_analysis());\n@@ -3695,0 +3696,3 @@\n+        tty->print_cr(\"invocation #%d: %d iterations and %f sec to build connection graph with %d nodes and worklist size %d\",\n+                      _invocation, _build_iterations, _build_time, nodes_size(), ptnodes_worklist.length());\n+        tty->cr();\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -343,0 +343,1 @@\n+  int              _invocation; \/\/ Current number of analysis invocation\n@@ -572,1 +573,1 @@\n-  ConnectionGraph(Compile *C, PhaseIterGVN *igvn);\n+  ConnectionGraph(Compile *C, PhaseIterGVN *igvn, int iteration);\n","filename":"src\/hotspot\/share\/opto\/escape.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8276455\n+ * @summary Test C2 iterative Escape Analysis to remove all allocations in test\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestIterativeEA\n+ *\/\n+public class TestIterativeEA {\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    static class MyClass {\n+        int val;\n+        public MyClass(int val) {\n+            this.val = val;\n+        }\n+    }\n+\n+    static class AbstractClass {\n+        final int unused;\n+        public AbstractClass() {\n+            unused = 42;\n+        }\n+    }\n+\n+    static class HolderWithSuper extends AbstractClass {\n+        final MyClass obj;\n+        public HolderWithSuper(MyClass obj) {\n+            this.obj = obj;\n+        }\n+    }\n+\n+    static class Holder {\n+        final MyClass obj;\n+        public Holder(MyClass obj) {\n+            this.obj = obj;\n+        }\n+    }\n+\n+    static class GenericHolder {\n+        final Object obj;\n+        public GenericHolder(Object obj) {\n+            this.obj = obj;\n+        }\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH })\n+    @IR(failOn = { IRNode.ALLOC })\n+    public static int testSlow(int val) {\n+        MyClass obj = new MyClass(val);\n+        HolderWithSuper h1 = new HolderWithSuper(obj);\n+        GenericHolder h2 = new GenericHolder(h1);\n+        return ((HolderWithSuper)h2.obj).obj.val;\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH })\n+    @IR(failOn = { IRNode.ALLOC })\n+    public static int testFast(int val) {\n+        MyClass obj = new MyClass(val);\n+        Holder h1 = new Holder(obj);\n+        GenericHolder h2 = new GenericHolder(h1);\n+        return ((Holder)h2.obj).obj.val;\n+    }\n+\n+    static class A {\n+        int i;\n+        public A(int i) {\n+            this.i = i;\n+        }\n+    }\n+\n+    static class B {\n+        A a;\n+        public B(A a) {\n+            this.a = a;\n+        }\n+    }\n+\n+    static class C {\n+        B b;\n+        public C(B b) {\n+            this.b = b;\n+        }\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH })\n+    @IR(failOn = { IRNode.ALLOC })\n+    static int testNested(int i) {\n+        C c = new C(new B(new A(i)));\n+        return c.b.a.i;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestIterativeEA.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8276455\n+ * @summary Test C2 iterative Escape Analysis\n+ * @library \/test\/lib \/\n+ *\n+ * @requires vm.flagless\n+ * @requires vm.compiler2.enabled & vm.debug == true\n+ *\n+ * @run driver TestIterativeEA\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class TestIterativeEA {\n+\n+  public static void main(String[] args) throws Exception {\n+    ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+                \"-server\", \"-XX:-TieredCompilation\", \"-Xbatch\", \"-XX:+PrintEliminateAllocations\",\n+                 Launcher.class.getName());\n+\n+    OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n+\n+    System.out.println(analyzer.getOutput());\n+\n+    analyzer.shouldHaveExitValue(0);\n+    analyzer.shouldContain(\"++++ Eliminated: 26 Allocate\");\n+    analyzer.shouldContain(\"++++ Eliminated: 48 Allocate\");\n+    analyzer.shouldContain(\"++++ Eliminated: 78 Allocate\");\n+  }\n+\n+  static class A {\n+    int i;\n+\n+    public A(int i) {\n+      this.i = i;\n+    }\n+  }\n+\n+  static class B {\n+    A a;\n+\n+    public B(A a) {\n+      this.a = a;\n+    }\n+  }\n+\n+  static class C {\n+    B b;\n+\n+    public C(B b) {\n+      this.b = b;\n+    }\n+  }\n+\n+  static int test(int i) {\n+    C c = new C(new B(new A(i)));\n+    return c.b.a.i;\n+  }\n+\n+  static class Launcher {\n+    public static void main(String[] args) {\n+      for (int i = 0; i < 12000; ++i) {\n+        int j = test(i);\n+      }\n+    }\n+  }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/escapeAnalysis\/TestIterativeEA.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Fork(1)\n+\n+public class IterativeEA {\n+\n+    public static int ii = 1;\n+\n+    static class A {\n+        int i;\n+\n+        public A(int i) {\n+            this.i = i;\n+        }\n+    }\n+\n+    static class B {\n+        A a;\n+\n+        public B(A a) {\n+            this.a = a;\n+        }\n+    }\n+\n+    static class C {\n+        B b;\n+\n+        public C(B b) {\n+            this.b = b;\n+        }\n+    }\n+\n+    @Benchmark\n+    public int test1() {\n+        C c = new C(new B(new A(ii)));\n+        return c.b.a.i;\n+    }\n+\n+    static class Point {\n+        int x;\n+        int y;\n+        int ax[];\n+        int ay[];\n+    }\n+\n+    @Benchmark\n+    public int test2() {\n+        Point p = new Point();\n+        p.ax = new int[2];\n+        p.ay = new int[2];\n+        int x = 3;\n+        p.ax[0] = x;\n+        p.ay[1] = 3 * x + ii;\n+        return p.ax[0] * p.ay[1];\n+    }\n+\n+    public static final Double dbc = Double.valueOf(1.);\n+\n+    @Benchmark\n+    public double test3() {\n+        Double j1 = Double.valueOf(1.);\n+        Double j2 = Double.valueOf(1.);\n+        for (int i = 0; i< 1000; i++) {\n+            j1 = j1 + 1.;\n+            j2 = j2 + 2.;\n+        }\n+        return j1 + j2;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/IterativeEA.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+  * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+  *\n+  * This code is free software; you can redistribute it and\/or modify it\n+  * under the terms of the GNU General Public License version 2 only, as\n+  * published by the Free Software Foundation.\n+  *\n+  * This code is distributed in the hope that it will be useful, but WITHOUT\n+  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+  * version 2 for more details (a copy is included in the LICENSE file that\n+  * accompanied this code).\n+  *\n+  * You should have received a copy of the GNU General Public License version\n+  * 2 along with this work; if not, write to the Free Software Foundation,\n+  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+  *\n+  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+  * or visit www.oracle.com if you need additional information or have any\n+  * questions.\n+  *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(value = 3)\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 3, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+public class PointerBenchmarkFlat {\n+\n+    static final int ELEM_SIZE = 1_000_000;\n+\n+    PointerImpl ptr_ptr;\n+    PointerImplFlat ptr_ptr_flat;\n+\n+    @Setup\n+    public void setup() {\n+        ptr_ptr = new PointerImpl(new FakeSegment(MemoryAddress.NULL, Long.MAX_VALUE));\n+        ptr_ptr_flat = new PointerImplFlat(new FakeSegmentFlat(MemoryAddress.NULL, Long.MAX_VALUE));\n+    }\n+\n+    static class MemoryAddress {\n+        private long addr;\n+\n+        public MemoryAddress(long addr) {\n+            this.addr = addr;\n+        }\n+\n+        long toRawLongValue() {\n+            return addr;\n+        }\n+\n+        private static final MemoryAddress NULL = new MemoryAddress(0);\n+\n+        static MemoryAddress ofLong(long val) {\n+            return new MemoryAddress(val);\n+        }\n+    }\n+\n+    static class PointerImpl {\n+        final FakeSegment segment;\n+\n+        public PointerImpl(FakeSegment segment) {\n+            this.segment = segment;\n+        }\n+\n+        MemoryAddress address() {\n+            return segment.address();\n+        }\n+\n+        PointerImpl get(long index) {\n+            MemoryAddress address = MemoryAddress.ofLong(index);\n+            FakeSegment holder = new FakeSegment(address, Long.MAX_VALUE);\n+            return new PointerImpl(holder);\n+        }\n+    }\n+\n+    static class PointerImplFlat {\n+        final FakeSegmentFlat segment;\n+\n+        public PointerImplFlat(FakeSegmentFlat segment) {\n+            this.segment = segment;\n+        }\n+\n+        MemoryAddress address() {\n+            return segment.address();\n+        }\n+\n+        PointerImplFlat get(long index) {\n+            MemoryAddress address = MemoryAddress.ofLong(index);\n+            FakeSegmentFlat holder = new FakeSegmentFlat(address, Long.MAX_VALUE);\n+            return new PointerImplFlat(holder);\n+        }\n+    }\n+\n+    static class AbstractFakeSegment {\n+        final long size;\n+\n+        public AbstractFakeSegment(long size) {\n+            this.size = size;\n+        }\n+    }\n+\n+    static class FakeSegment extends AbstractFakeSegment {\n+        final MemoryAddress address;\n+\n+        public FakeSegment(MemoryAddress address, long size) {\n+            super(size);\n+            this.address = address;\n+        }\n+\n+        MemoryAddress address() {\n+            return address;\n+        }\n+    }\n+\n+    static class FakeSegmentFlat {\n+        final MemoryAddress address;\n+        final long size;\n+\n+        public FakeSegmentFlat(MemoryAddress address, long size) {\n+            this.size = size;\n+            this.address = address;\n+        }\n+\n+        MemoryAddress address() {\n+            return address;\n+        }\n+    }\n+\n+    @Benchmark\n+    public int test() {\n+        int sum = 0;\n+        for (int i = 0 ; i < ELEM_SIZE ; i++) {\n+            sum += ptr_ptr.get(i).address().toRawLongValue();\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int testFlat() {\n+        int sum = 0;\n+        for (int i = 0 ; i < ELEM_SIZE ; i++) {\n+            sum += ptr_ptr_flat.get(i).address().toRawLongValue();\n+        }\n+        return sum;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/PointerBenchmarkFlat.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"}]}