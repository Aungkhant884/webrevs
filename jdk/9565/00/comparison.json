{"files":[{"patch":"@@ -1854,0 +1854,5 @@\n+  \/\/ \"(ReverseBytesV X) => X\" if the element type is T_BYTE.\n+  if (vect_type()->element_basic_type() == T_BYTE) {\n+    return in(1);\n+  }\n+\n@@ -1857,1 +1862,1 @@\n-  \/\/ ReverseBytesV (ReverseBytesV X , MASK) , MASK =>  X\n+  \/\/ (ReverseBytesV (ReverseBytesV X MASK) MASK) => X\n@@ -1862,1 +1867,1 @@\n-      \/\/ ReverseBytesV (ReverseBytesV X) =>  X\n+      \/\/ ReverseBytesV (ReverseBytesV X) => X\n@@ -1974,0 +1979,8 @@\n+Node* VectorBlendNode::Identity(PhaseGVN* phase) {\n+  \/\/ (VectorBlend X X MASK) => X\n+  if (in(1) == in(2)) {\n+    return in(1);\n+  }\n+  return this;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1452,0 +1452,1 @@\n+  virtual Node* Identity(PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -211,0 +211,2 @@\n+    public static final String VECTOR_BLEND = START + \"VectorBlend\" + MID + END;\n+    public static final String REVERSE_BYTES_V = START + \"ReverseBytesV\" + MID + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.ir_framework.*;\n+\n+import java.util.Random;\n+\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorSpecies;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+\/**\n+ * @test\n+ * @bug 8290485\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @summary [vectorapi] REVERSE_BYTES for byte type should not emit any instructions\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.simpleArch == \"x64\" & vm.cpu.features ~= \".*avx2.*\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.vector\n+ *\n+ * @run driver compiler.vectorapi.VectorReverseBytesTest\n+ *\/\n+\n+public class VectorReverseBytesTest {\n+    private static final VectorSpecies<Byte> B_SPECIES = ByteVector.SPECIES_MAX;\n+\n+    private static int LENGTH = 1024;\n+    private static final Random RD = Utils.getRandomInstance();\n+\n+    private static byte[] input;\n+    private static byte[] output;\n+    private static boolean[] m;\n+\n+    static {\n+        input = new byte[LENGTH];\n+        output = new byte[LENGTH];\n+        m = new boolean[LENGTH];\n+\n+        for (int i = 0; i < LENGTH; i++) {\n+            input[i] = (byte) RD.nextInt(25);\n+            m[i] = RD.nextBoolean();\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.REVERSE_BYTES_V)\n+    public static void testReverseBytesV() {\n+        for (int i = 0; i < LENGTH; i += B_SPECIES.length()) {\n+            ByteVector v = ByteVector.fromArray(B_SPECIES, input, i);\n+            v.lanewise(VectorOperators.REVERSE_BYTES).intoArray(output, i);\n+        }\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < LENGTH; i++) {\n+            Asserts.assertEquals(input[i], output[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.REVERSE_BYTES_V)\n+    @IR(failOn = IRNode.VECTOR_BLEND)\n+    public static void testReverseBytesVMasked() {\n+        VectorMask<Byte> mask = VectorMask.fromArray(B_SPECIES, m, 0);\n+        for (int i = 0; i < LENGTH; i += B_SPECIES.length()) {\n+            ByteVector v = ByteVector.fromArray(B_SPECIES, input, i);\n+            v.lanewise(VectorOperators.REVERSE_BYTES, mask).intoArray(output, i);\n+        }\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < LENGTH; i++) {\n+            Asserts.assertEquals(input[i], output[i]);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorReverseBytesTest.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"}]}