{"files":[{"patch":"@@ -143,8 +143,0 @@\n-    private static final byte[] UPPERCASE_DIGITS = {\n-            '0', '1', '2', '3', '4', '5', '6', '7',\n-            '8', '9', 'A', 'B', 'C', 'D', 'E', 'F',\n-    };\n-    private static final byte[] LOWERCASE_DIGITS = {\n-            '0', '1', '2', '3', '4', '5', '6', '7',\n-            '8', '9', 'a', 'b', 'c', 'd', 'e', 'f',\n-    };\n@@ -176,1 +168,4 @@\n-            new HexFormat(\"\", \"\", \"\", LOWERCASE_DIGITS);\n+            new HexFormat(\"\", \"\", \"\", Case.LOWERCASE);\n+\n+    private static final HexFormat HEX_UPPER_FORMAT =\n+            new HexFormat(\"\", \"\", \"\", Case.UPPERCASE);\n@@ -183,1 +178,6 @@\n-    private final byte[] digits;\n+    private final Case digitCase;\n+\n+    private enum Case {\n+        LOWERCASE,\n+        UPPERCASE\n+    }\n@@ -191,1 +191,1 @@\n-     * @param digits byte array of digits indexed by low nibble, non-null\n+     * @param digitCase enum indicating how to case digits\n@@ -194,1 +194,1 @@\n-    private HexFormat(String delimiter, String prefix, String suffix, byte[] digits) {\n+    private HexFormat(String delimiter, String prefix, String suffix, Case digitCase) {\n@@ -198,1 +198,1 @@\n-        this.digits = digits;\n+        this.digitCase = digitCase;\n@@ -227,1 +227,1 @@\n-        return new HexFormat(delimiter, \"\", \"\", LOWERCASE_DIGITS);\n+        return new HexFormat(delimiter, \"\", \"\", Case.LOWERCASE);\n@@ -236,1 +236,1 @@\n-        return new HexFormat(delimiter, this.prefix, this.suffix, this.digits);\n+        return new HexFormat(delimiter, this.prefix, this.suffix, this.digitCase);\n@@ -246,1 +246,1 @@\n-        return new HexFormat(this.delimiter, prefix, this.suffix, this.digits);\n+        return new HexFormat(this.delimiter, prefix, this.suffix, this.digitCase);\n@@ -256,1 +256,1 @@\n-        return new HexFormat(this.delimiter, this.prefix, suffix, this.digits);\n+        return new HexFormat(this.delimiter, this.prefix, suffix, this.digitCase);\n@@ -266,1 +266,3 @@\n-        return new HexFormat(this.delimiter, this.prefix, this.suffix, UPPERCASE_DIGITS);\n+        if (this == HEX_FORMAT)\n+            return HEX_UPPER_FORMAT;\n+        return new HexFormat(this.delimiter, this.prefix, this.suffix, Case.UPPERCASE);\n@@ -276,1 +278,1 @@\n-        return new HexFormat(this.delimiter, this.prefix, this.suffix, LOWERCASE_DIGITS);\n+        return new HexFormat(this.delimiter, this.prefix, this.suffix, Case.LOWERCASE);\n@@ -314,1 +316,1 @@\n-        return Arrays.equals(digits, UPPERCASE_DIGITS);\n+        return digitCase == Case.UPPERCASE;\n@@ -404,1 +406,0 @@\n-                String between = suffix + delimiter + prefix;\n@@ -407,1 +408,1 @@\n-                if (between.isEmpty()) {\n+                if (suffix.isEmpty() && delimiter.isEmpty() && prefix.isEmpty()) {\n@@ -413,1 +414,3 @@\n-                        out.append(between);\n+                        out.append(suffix);\n+                        out.append(delimiter);\n+                        out.append(prefix);\n@@ -634,1 +637,8 @@\n-        return (char)digits[value & 0xf];\n+        value = value & 0xf;\n+        if (value < 10) {\n+            return (char)('0' + value);\n+        }\n+        if (digitCase == Case.LOWERCASE) {\n+            return (char)('a' - 10 + value);\n+        }\n+        return (char)('A' - 10 + value);\n@@ -648,1 +658,8 @@\n-        return (char)digits[(value >> 4) & 0xf];\n+        value = (value >> 4) & 0xf;\n+        if (value < 10) {\n+            return (char)('0' + value);\n+        }\n+        if (digitCase == Case.LOWERCASE) {\n+            return (char)('a' - 10 + value);\n+        }\n+        return (char)('A' - 10 + value);\n@@ -1055,1 +1072,1 @@\n-        return Arrays.equals(digits, otherHex.digits) &&\n+        return digitCase == otherHex.digitCase &&\n@@ -1069,1 +1086,1 @@\n-        result = 31 * result + Boolean.hashCode(Arrays.equals(digits, UPPERCASE_DIGITS));\n+        result = 31 * result + Boolean.hashCode(digitCase == Case.UPPERCASE);\n@@ -1081,1 +1098,1 @@\n-        return escapeNL(\"uppercase: \" + Arrays.equals(digits, UPPERCASE_DIGITS) +\n+        return escapeNL(\"uppercase: \" + (digitCase == Case.UPPERCASE) +\n","filename":"src\/java.base\/share\/classes\/java\/util\/HexFormat.java","additions":45,"deletions":28,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.HexFormat;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Tests java.net.URLEncoder.encode and Decoder.decode.\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 3)\n+public class HexFormatBench {\n+\n+    @Param({\"512\"})\n+    public int size;\n+\n+    public byte[] bytes;\n+\n+    public StringBuilder builder = new StringBuilder(size * 2);\n+\n+    HexFormat LOWER_FORMATTER = HexFormat.of();\n+    HexFormat UPPER_FORMATTER = HexFormat.of().withUpperCase();\n+\n+    @Setup\n+    public void setupStrings() {\n+        Random random = new Random(3);\n+        bytes = new byte[size];\n+        for (int i = 0; i < size; i++) {\n+            bytes[i] = (byte)random.nextInt(16);\n+        }\n+    }\n+\n+    @Benchmark\n+    public StringBuilder appenderLower() {\n+        builder.setLength(0);\n+        return HexFormat.of().formatHex(builder, bytes);\n+    }\n+\n+    @Benchmark\n+    public StringBuilder appenderUpper() {\n+        builder.setLength(0);\n+        return HexFormat.of().withUpperCase().formatHex(builder, bytes);\n+    }\n+\n+    @Benchmark\n+    public StringBuilder appenderLowerCached() {\n+        builder.setLength(0);\n+        return LOWER_FORMATTER.formatHex(builder, bytes);\n+    }\n+\n+    @Benchmark\n+    public StringBuilder appenderUpperCached() {\n+        builder.setLength(0);\n+        return UPPER_FORMATTER.formatHex(builder, bytes);\n+    }\n+\n+\n+    @Benchmark\n+    public void toHexLower(Blackhole bh) {\n+        for (byte b : bytes) {\n+            bh.consume(HexFormat.of().toHighHexDigit(b));\n+            bh.consume(HexFormat.of().toLowHexDigit(b));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void toHexUpper(Blackhole bh) {\n+        for (byte b : bytes) {\n+            bh.consume(HexFormat.of().withUpperCase().toHighHexDigit(b));\n+            bh.consume(HexFormat.of().withUpperCase().toLowHexDigit(b));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void toHexLowerCached(Blackhole bh) {\n+        for (byte b : bytes) {\n+            bh.consume(LOWER_FORMATTER.toHighHexDigit(b));\n+            bh.consume(LOWER_FORMATTER.toLowHexDigit(b));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void toHexUpperCached(Blackhole bh) {\n+        for (byte b : bytes) {\n+            bh.consume(UPPER_FORMATTER.toHighHexDigit(b));\n+            bh.consume(UPPER_FORMATTER.toLowHexDigit(b));\n+        }\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/HexFormatBench.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"}]}