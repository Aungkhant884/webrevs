{"files":[{"patch":"@@ -76,1 +76,0 @@\n-    size_t _marked_words;\n@@ -81,4 +80,0 @@\n-    void reset_marked_words() {\n-      _marked_words = 0;\n-    }\n-\n@@ -89,6 +84,0 @@\n-    void assert_marked_words(HeapRegion* hr) {\n-      assert((_marked_words * HeapWordSize) == hr->marked_bytes(),\n-             \"Mismatch between marking and re-calculation for region %u, %zu != %zu\",\n-             hr->hrm_index(), (_marked_words * HeapWordSize), hr->marked_bytes());\n-    }\n-\n@@ -97,1 +86,0 @@\n-      _marked_words += processed;\n@@ -231,1 +219,0 @@\n-      reset_marked_words();\n@@ -243,3 +230,0 @@\n-      \/\/ Assert that the size of marked objects from the marking matches\n-      \/\/ the size of the objects which we scanned to rebuild remembered sets.\n-      assert_marked_words(hr);\n@@ -273,1 +257,0 @@\n-      reset_marked_words();\n@@ -285,7 +268,0 @@\n-      } else if (_bitmap->is_marked(humongous) && should_rebuild_or_scrub(hr)) {\n-        \/\/ Only verify that the marked size matches the rebuilt size if this object was marked\n-        \/\/ and the object should still be handled. The should_rebuild_or_scrub() state can\n-        \/\/ change during rebuild for humongous objects that are eagerly reclaimed so we need to\n-        \/\/ check this.\n-        \/\/ If the object has not been marked the size from marking will be 0.\n-        assert_marked_words(hr);\n@@ -302,1 +278,0 @@\n-      _marked_words(0),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRebuildAndScrub.cpp","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-                                  \"marked %zu \"\n@@ -76,1 +75,0 @@\n-                                  r->marked_bytes(),\n@@ -105,1 +103,1 @@\n-bool G1RemSetTrackingPolicy::update_before_rebuild(HeapRegion* r, size_t live_bytes) {\n+bool G1RemSetTrackingPolicy::update_before_rebuild(HeapRegion* r, size_t live_bytes_below_tams) {\n@@ -117,2 +115,2 @@\n-  size_t between_tams_and_top = (r->top() - r->top_at_mark_start()) * HeapWordSize;\n-  size_t total_live_bytes = live_bytes + between_tams_and_top;\n+  size_t live_bytes_above_tams = (r->top() - r->top_at_mark_start()) * HeapWordSize;\n+  size_t total_live_bytes = live_bytes_below_tams + live_bytes_above_tams;\n@@ -134,1 +132,1 @@\n-  print_before_rebuild(r, selected_for_rebuild, total_live_bytes, live_bytes);\n+  print_before_rebuild(r, selected_for_rebuild, total_live_bytes, live_bytes_below_tams);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetTrackingPolicy.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-  bool update_before_rebuild(HeapRegion* r, size_t live_bytes);\n+  bool update_before_rebuild(HeapRegion* r, size_t live_bytes_below_tams);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetTrackingPolicy.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -398,1 +398,1 @@\n-  size_t _before_used_bytes;   \/\/ Usage in regions successfully evacutate\n+  size_t _before_used_bytes;   \/\/ Usage in regions successfully evacuate\n@@ -441,1 +441,1 @@\n-    size_t used_words = r->marked_bytes() \/ HeapWordSize;\n+    size_t used_words = r->live_bytes() \/ HeapWordSize;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -241,1 +241,0 @@\n-  _marked_bytes(0),\n@@ -279,1 +278,0 @@\n-  _marked_bytes = 0;\n@@ -297,1 +295,0 @@\n-  _marked_bytes = marked_bytes;\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -262,1 +262,0 @@\n-    _marked_bytes = 0;\n@@ -347,2 +346,0 @@\n-  \/\/ The number of bytes marked live in the region in the last marking phase.\n-  size_t marked_bytes() const { return _marked_bytes; }\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -216,1 +216,0 @@\n-  _marked_bytes = used();\n@@ -329,2 +328,1 @@\n-  _marked_bytes = marked_bytes;\n-  _garbage_bytes = byte_size(bottom(), top_at_mark_start()) - _marked_bytes;\n+  _garbage_bytes = byte_size(bottom(), top_at_mark_start()) - marked_bytes;\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -607,1 +607,0 @@\n-      size_t prev_live = r->marked_bytes();\n@@ -615,3 +614,3 @@\n-        \/\/ we don't include non-full regions since they are unlikely included in mixed gc\n-        \/\/ for testing purposes it's enough to have lowest estimation of total memory that is expected to be freed\n-          _total_memory_to_free += size - prev_live;\n+          \/\/ We don't include non-full regions since they are unlikely included in mixed gc\n+          \/\/ for testing purposes it's enough to have lowest estimation of total memory that is expected to be freed\n+          _total_memory_to_free += size - live;\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"}]}