{"files":[{"patch":"@@ -57,1 +57,2 @@\n-ClassListParser::ClassListParser(const char* file, ParseMode parse_mode) : _id2klass_table(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE) {\n+ClassListParser::ClassListParser(const char* file, ParseMode parse_mode)\n+  : _reader(file), _id2klass_table(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE) {\n@@ -60,11 +61,1 @@\n-  _classlist_file = file;\n-  _file = nullptr;\n-  \/\/ Use os::open() because neither fopen() nor os::fopen()\n-  \/\/ can handle long path name on Windows.\n-  int fd = os::open(file, O_RDONLY, S_IREAD);\n-  if (fd != -1) {\n-    \/\/ Obtain a File* from the file descriptor so that fgets()\n-    \/\/ can be used in parse_one_line()\n-    _file = os::fdopen(fd, \"r\");\n-  }\n-  if (_file == nullptr) {\n+  if (!_reader.is_opened()) {\n@@ -73,1 +64,2 @@\n-    vm_exit_during_initialization(\"Loading classlist failed\", errmsg);\n+    log_error(cds)(\"Loading classlist %s failed: %s\", _reader.filename(), errmsg);\n+    MetaspaceShared::unrecoverable_writing_error();\n@@ -91,3 +83,0 @@\n-  if (_file != nullptr) {\n-    fclose(_file);\n-  }\n@@ -100,0 +89,6 @@\n+int ClassListParser::parse_classlist(const char* classlist_path, ParseMode parse_mode, TRAPS) {\n+  ResourceMark rm(THREAD);\n+  ClassListParser parser(classlist_path, parse_mode);\n+  return parser.parse(THREAD); \/\/ returns the number of classes loaded.\n+}\n+\n@@ -168,1 +163,1 @@\n-    if (fgets(_line, sizeof(_line), _file) == nullptr) {\n+    if ((_line = _reader.get_line()) == nullptr) {\n@@ -426,1 +421,1 @@\n-              _classlist_file, _line_no, (error_index + 1));\n+              _reader.filename(), _line_no, (error_index + 1));\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":13,"deletions":18,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"utilities\/lineReader.hpp\"\n@@ -98,2 +99,1 @@\n-  const char* _classlist_file;\n-  FILE* _file;\n+  LineReader _reader;\n@@ -105,2 +105,1 @@\n-  char                _line[_line_buf_size];  \/\/ The buffer that holds the current line. Some characters in\n-                                              \/\/ the buffer may be overwritten by '\\0' during parsing.\n+  char*               _line;                  \/\/ The current input line being processed\n@@ -139,5 +138,1 @@\n-  static int parse_classlist(const char* classlist_path, ParseMode parse_mode, TRAPS) {\n-    ClassListParser parser(classlist_path, parse_mode);\n-    return parser.parse(THREAD); \/\/ returns the number of classes loaded.\n-  }\n-\n+  static int parse_classlist(const char* classlist_path, ParseMode parse_mode, TRAPS);\n","filename":"src\/hotspot\/share\/cds\/classListParser.hpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+#include \"utilities\/lineReader.hpp\"\n@@ -112,0 +113,1 @@\n+\/\/ Must be used within a ResourceMark.\n@@ -114,1 +116,1 @@\n-  FILE*   _stream;\n+  LineReader _reader;\n@@ -131,3 +133,3 @@\n-  char* _bufptr;\n-  char* _buffer;\n-  int   _buffer_length;\n+  \/\/ These variables are set by get_line().\n+  char* _buffer; \/\/ The current line being processed\n+  char* _bufptr; \/\/ The position within _buffer that's being looked at\n@@ -142,1 +144,1 @@\n-  CompileReplay(const char* filename, TRAPS) {\n+  CompileReplay(const char* filename, TRAPS) : _reader(filename) {\n@@ -148,2 +150,1 @@\n-    _stream = os::fopen(filename, \"rt\");\n-    if (_stream == nullptr) {\n+    if (!_reader.is_opened()) {\n@@ -156,4 +157,0 @@\n-    _buffer_length = 32;\n-    _buffer = NEW_RESOURCE_ARRAY(char, _buffer_length);\n-    _bufptr = _buffer;\n-\n@@ -169,4 +166,0 @@\n-  ~CompileReplay() {\n-    if (_stream != nullptr) fclose(_stream);\n-  }\n-\n@@ -174,2 +167,3 @@\n-    strcpy(_buffer, \"1 2 foo 4 bar 0x9 \\\"this is it\\\"\");\n-    _bufptr = _buffer;\n+    char tmp[] = \"1 2 foo 4 bar 0x9 \\\"this is it\\\"\";\n+    _buffer = tmp;\n+    _bufptr = tmp;\n@@ -190,1 +184,1 @@\n-    return !(_stream == nullptr || had_error());\n+    return _reader.is_opened() && !had_error();\n@@ -607,21 +601,2 @@\n-  int get_line(int c) {\n-    int buffer_pos = 0;\n-    while(c != EOF) {\n-      if (buffer_pos + 1 >= _buffer_length) {\n-        int new_length = _buffer_length * 2;\n-        \/\/ Next call will throw error in case of OOM.\n-        _buffer = REALLOC_RESOURCE_ARRAY(char, _buffer, _buffer_length, new_length);\n-        _buffer_length = new_length;\n-      }\n-      if (c == '\\n') {\n-        c = getc(_stream); \/\/ get next char\n-        break;\n-      } else if (c == '\\r') {\n-        \/\/ skip LF\n-      } else {\n-        _buffer[buffer_pos++] = c;\n-      }\n-      c = getc(_stream);\n-    }\n-    \/\/ null terminate it, reset the pointer\n-    _buffer[buffer_pos] = '\\0'; \/\/ NL or EOF\n+  bool get_line() {\n+    _buffer = _reader.get_line();\n@@ -629,1 +604,1 @@\n-    return c;\n+    return (_buffer != nullptr);\n@@ -636,3 +611,1 @@\n-    int c = getc(_stream);\n-    while(c != EOF) {\n-      c = get_line(c);\n+    while (get_line()) {\n@@ -723,3 +696,1 @@\n-    int c = getc(_stream);\n-    while(c != EOF) {\n-      c = get_line(c);\n+    while (get_line()) {\n@@ -1365,0 +1336,1 @@\n+  ResourceMark rm(THREAD);\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":18,"deletions":46,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/lineReader.hpp\"\n+\n+LineReader::LineReader(const char* filename) : _filename(filename), _stream(nullptr) {\n+  \/\/ Use os::open() because neither fopen() nor os::fopen()\n+  \/\/ can handle long path name on Windows. HMM, is this still valid today???\n+  int fd = os::open(filename, O_RDONLY, S_IREAD);\n+  if (fd != -1) {\n+    \/\/ Obtain a File* from the file descriptor so that getc()\n+    \/\/ can be used in get_line().\n+    _stream = os::fdopen(fd, \"r\");\n+    if (_stream == nullptr) {\n+      ::close(fd);\n+    } else {\n+      \/\/ fd will be closed by fclose(_stream)\n+    }\n+  } else {\n+    _stream = nullptr;\n+  }\n+\n+  _buffer_length = 32;\n+  _buffer = NEW_RESOURCE_ARRAY(char, _buffer_length);\n+}\n+\n+LineReader::~LineReader() {\n+  close(); \/\/ Just in case\n+}\n+\n+void LineReader::close() {\n+  if (_stream != nullptr) {\n+    fclose(_stream);\n+    _stream = nullptr;\n+  }\n+}\n+\n+\/\/ Returns nullptr if we have reached EOF.\n+\/\/ \\n is treated as the line separator\n+\/\/ All occurrences of \\r are stripper.\n+char* LineReader::get_line() {\n+  if (_stream == nullptr) {\n+    return nullptr;\n+  }\n+  size_t buffer_pos = 0;\n+  int c;\n+  while ((c = getc(_stream)) != EOF) {\n+    if (buffer_pos + 1 >= _buffer_length) {\n+      size_t new_length = _buffer_length * 2;\n+      if (new_length < _buffer_length) {\n+        \/\/ This could happen on 32-bit. On 64-bit, the VM would have exited\n+        \/\/ due to OOM before we ever get to here.\n+        fatal(\"Cannot handle excessively long lines\");\n+      }\n+      _buffer = REALLOC_RESOURCE_ARRAY(char, _buffer, _buffer_length, new_length);\n+      assert(_buffer != nullptr, \"OOM would have exited JVM\");\n+      _buffer_length = new_length;\n+    }\n+    if (c == '\\n') {\n+      break;\n+    } else if (c == '\\r') {\n+      \/\/ skip LF\n+    } else {\n+      _buffer[buffer_pos++] = c;\n+    }\n+  }\n+\n+  \/\/ null terminate it, reset the pointer\n+  _buffer[buffer_pos] = '\\0'; \/\/ NL or EOF\n+\n+  if (buffer_pos == 0 && c == EOF) {\n+    close();\n+    return nullptr;\n+  } else {\n+    return _buffer;\n+  }\n+}\n","filename":"src\/hotspot\/share\/utilities\/lineReader.cpp","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_LINEREADER_HPP\n+#define SHARE_UTILITIES_LINEREADER_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ A simple class to read lines of arbitrary length from _filename.\n+\/\/ The _buffer is resource-allocated, so LineReader must be used within\n+\/\/ a ResourceMark.\n+class LineReader : public StackObj {\n+  const char* _filename;\n+  FILE* _stream;\n+  size_t _buffer_length;\n+  char* _buffer;\n+public:\n+  LineReader(const char* filename);\n+  ~LineReader();\n+\n+  bool is_opened() const {\n+    return _stream != nullptr;\n+  }\n+  const char* filename() const { return _filename; }\n+  char* get_line();\n+  void close();\n+};\n+\n+#endif \/\/ SHARE_UTILITIES_LINEREADER_HPP\n","filename":"src\/hotspot\/share\/utilities\/lineReader.hpp","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"}]}