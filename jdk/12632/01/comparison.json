{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -163,0 +163,20 @@\n+    \/**\n+     * Compares two latin1 code points, ignoring case considerations\n+     *\n+     * @param b1 byte representing a latin1 code point\n+     * @param b2 another byte representing a latin1 code point\n+     * @return true if the two bytes are considered equals ignoring case in latin1\n+     *\/\n+     static boolean equalsIgnoreCase(byte b1, byte b2) {\n+         if (b1 == b2) {\n+             return true;\n+         }\n+         \/\/ uppercase b1 using 'the oldest ASCII trick in the book'\n+         int U = b1 & 0xDF;\n+         if (U < 'A') {\n+             return false;  \/\/ Low ASCII\n+         }\n+         return ( U <= 'Z' \/\/ In range A-Z\n+                 || (U >= 0xC0 && U <= 0XDE && U != 0xD7)) \/\/ ..or A-grave-Thorn, excl. multiplication\n+                 && U == (b2 & 0xDF); \/\/ b2 has same uppercase\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/CharacterDataLatin1.java.template","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -387,8 +387,3 @@\n-            char c1 = (char)(value[toffset++] & 0xff);\n-            char c2 = (char)(other[ooffset++] & 0xff);\n-            if (c1 == c2) {\n-                continue;\n-            }\n-            int u1 = CharacterDataLatin1.instance.toUpperCase(c1);\n-            int u2 = CharacterDataLatin1.instance.toUpperCase(c2);\n-            if (u1 == u2) {\n+            byte b1 = value[toffset++];\n+            byte b2 = other[ooffset++];\n+            if (CharacterDataLatin1.equalsIgnoreCase(b1, b2)) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringLatin1.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n@@ -78,0 +80,25 @@\n+\n+    \/**\n+     * Exhaustively check that all latin1 code point pairs are equalsIgnoreCased\n+     * in a manner consistent with Character.toUpperCase, Character.toLowerCase\n+     *\/\n+    @Test\n+    public void checkConsistencyWithCharacterUppercaseLowerCase() {\n+        for (int ab = 0; ab < 256; ab++) {\n+            for (int bb = 0; bb < 256; bb++) {\n+                char a = (char) ab, b = (char) bb;\n+                String as = Character.toString(a);\n+                String bs = Character.toString(b);\n+\n+                int na = Character.toLowerCase(Character.toUpperCase(a));\n+                int nb = Character.toLowerCase(Character.toUpperCase(b));\n+                if (na == nb) {\n+                    assertTrue(as.equalsIgnoreCase(bs),\n+                            \"Expected %s to equalsIgnoreCase %s\".formatted(as, bs));\n+                } else {\n+                    assertFalse(as.equalsIgnoreCase(bs),\n+                            \"Expected %s to not equalsIgnoreCase %s\".formatted(as, bs));\n+                }\n+            }\n+        }\n+    }\n","filename":"test\/jdk\/java\/lang\/String\/CompactString\/EqualsIgnoreCase.java","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+\/*\n+ * This benchmark naively explores String::regionMatches, ignoring case\n+ *\/\n+\n+public class RegionMatchesIC {\n+\n+    @BenchmarkMode(Mode.AverageTime)\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    @State(Scope.Benchmark)\n+    @Warmup(iterations = 5, time = 1)\n+    @Measurement(iterations = 5, time = 1)\n+    @Fork(value = 3)\n+    public static class Latin1 {\n+\n+        @Param({\"1024\"})\n+        public int size;\n+\n+        @Param({\"ascii-match\",\n+                \"ascii-mismatch\",\n+                \"number-match\",\n+                \"number-mismatch\",\n+                \"lat1-match\",\n+                \"lat1-mismatch\"})\n+        String codePoints;\n+        private String leftString;\n+        private String rightString;\n+\n+        @Setup\n+        public void setup() {\n+\n+            switch (codePoints) {\n+                case \"ascii-match\" -> {\n+                    leftString  = \"a\".repeat(size);\n+                    rightString = \"A\".repeat(size);\n+                }\n+                case \"ascii-mismatch\" -> {\n+                    leftString  = \"a\".repeat(size);\n+                    rightString = \"b\".repeat(size);\n+                }\n+                case \"number-match\" -> {\n+                    leftString  = \"7\".repeat(size);\n+                    rightString = \"7\".repeat(size);\n+                }\n+                case \"number-mismatch\" -> {\n+                    leftString  = \"7\".repeat(size);\n+                    rightString = \"9\".repeat(size);\n+                }\n+                case \"lat1-match\" -> {\n+                    leftString  = \"\\u00e5\".repeat(size);\n+                    rightString = \"\\u00c5\".repeat(size);\n+                }\n+                case \"lat1-mismatch\" -> {\n+                    leftString  = \"\\u00e5\".repeat(size);\n+                    rightString = \"\\u00c6\".repeat(size);\n+                }\n+                default -> throw new IllegalArgumentException(\"Unsupported coding: \" + codePoints);\n+            }\n+            \/\/ Make sure strings do not String.equals by adding a prefix\n+            leftString = \"l\" + leftString;\n+            rightString = \"r\" + rightString;\n+        }\n+\n+        @Benchmark\n+        public boolean regionMatchesIC() {\n+            return leftString.regionMatches(true, 1, rightString, 1, size);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/RegionMatchesIC.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"}]}