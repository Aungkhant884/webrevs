{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -117,1 +117,8 @@\n-ifeq ($(BUILD_CDS_ARCHIVE), true)\n+# Helper function for creating the CDS archives for the JDK and JRE\n+#\n+# Param1 - VM variant (e.g., server, client, zero, ...)\n+# Param2 - _nocoops, or empty\n+define CreateCDSArchive\n+  $1_$2_DUMP_EXTRA_ARG := $(if $(filter _nocoops, $2),-XX:-UseCompressedOops,)\n+  $1_$2_DUMP_TYPE      := $(if $(filter _nocoops, $2),-NOCOOPS,)\n+\n@@ -119,2 +126,1 @@\n-    CDS_ARCHIVE := bin\/server\/classes.jsa\n-    CDS_NOCOOPS_ARCHIVE := bin\/server\/classes_nocoops.jsa\n+    $1_$2_CDS_ARCHIVE := bin\/$1\/classes$2.jsa\n@@ -122,2 +128,1 @@\n-    CDS_ARCHIVE := lib\/server\/classes.jsa\n-    CDS_NOCOOPS_ARCHIVE := lib\/server\/classes_nocoops.jsa\n+    $1_$2_CDS_ARCHIVE := lib\/$1\/classes$2.jsa\n@@ -126,8 +131,8 @@\n-  $(eval $(call SetupExecute, gen_cds_archive_jdk, \\\n-      WARN := Creating CDS archive for jdk image, \\\n-      DEPS := $(jlink_jdk), \\\n-      OUTPUT_FILE := $(JDK_IMAGE_DIR)\/$(CDS_ARCHIVE), \\\n-      SUPPORT_DIR := $(SUPPORT_OUTPUTDIR)\/images\/jdk, \\\n-      COMMAND := $(FIXPATH) $(JDK_IMAGE_DIR)\/bin\/java -Xshare:dump \\\n-          -XX:SharedArchiveFile=$(JDK_IMAGE_DIR)\/$(CDS_ARCHIVE) \\\n-          -Xmx128M -Xms128M $(LOG_INFO), \\\n+  $$(eval $$(call SetupExecute, $1_$2_gen_cds_archive_jdk, \\\n+      WARN := Creating CDS$$($1_$2_DUMP_TYPE) archive for jdk image for $1, \\\n+      DEPS := $$(jlink_jdk), \\\n+      OUTPUT_FILE := $$(JDK_IMAGE_DIR)\/$$($1_$2_CDS_ARCHIVE), \\\n+      SUPPORT_DIR := $$(SUPPORT_OUTPUTDIR)\/images\/jdk, \\\n+      COMMAND := $$(FIXPATH) $$(JDK_IMAGE_DIR)\/bin\/java -Xshare:dump \\\n+          -XX:SharedArchiveFile=$$(JDK_IMAGE_DIR)\/$$($1_$2_CDS_ARCHIVE) \\\n+          -$1 $$($1_$2_DUMP_EXTRA_ARG) -Xmx128M -Xms128M $$(LOG_INFO), \\\n@@ -136,1 +141,1 @@\n-  JDK_TARGETS += $(gen_cds_archive_jdk)\n+  JDK_TARGETS += $$($1_$2_gen_cds_archive_jdk)\n@@ -138,8 +143,8 @@\n-  $(eval $(call SetupExecute, gen_cds_archive_jre, \\\n-      WARN := Creating CDS archive for jre image, \\\n-      DEPS := $(jlink_jre), \\\n-      OUTPUT_FILE := $(JRE_IMAGE_DIR)\/$(CDS_ARCHIVE), \\\n-      SUPPORT_DIR := $(SUPPORT_OUTPUTDIR)\/images\/jre, \\\n-      COMMAND := $(FIXPATH) $(JRE_IMAGE_DIR)\/bin\/java -Xshare:dump \\\n-          -XX:SharedArchiveFile=$(JRE_IMAGE_DIR)\/$(CDS_ARCHIVE) \\\n-          -Xmx128M -Xms128M $(LOG_INFO), \\\n+  $$(eval $$(call SetupExecute, $1_$2_gen_cds_archive_jre, \\\n+      WARN := Creating CDS$$($1_$2_DUMP_TYPE) archive for jre image for $1, \\\n+      DEPS := $$(jlink_jre), \\\n+      OUTPUT_FILE := $$(JRE_IMAGE_DIR)\/$$($1_$2_CDS_ARCHIVE), \\\n+      SUPPORT_DIR := $$(SUPPORT_OUTPUTDIR)\/images\/jre, \\\n+      COMMAND := $$(FIXPATH) $$(JRE_IMAGE_DIR)\/bin\/java -Xshare:dump \\\n+          -XX:SharedArchiveFile=$$(JRE_IMAGE_DIR)\/$$($1_$2_CDS_ARCHIVE) \\\n+          -$1 $$($1_$2_DUMP_EXTRA_ARG) -Xmx128M -Xms128M $$(LOG_INFO), \\\n@@ -148,1 +153,7 @@\n-  JRE_TARGETS += $(gen_cds_archive_jre)\n+  JRE_TARGETS += $$($1_$2_gen_cds_archive_jre)\n+endef\n+\n+ifeq ($(BUILD_CDS_ARCHIVE), true)\n+  $(foreach v, $(JVM_VARIANTS), \\\n+    $(eval $(call CreateCDSArchive,$v,)) \\\n+  )\n@@ -151,25 +162,3 @@\n-    $(eval $(call SetupExecute, gen_cds_nocoops_archive_jdk, \\\n-        WARN := Creating CDS-NOCOOPS archive for jdk image, \\\n-        DEPS := $(jlink_jdk), \\\n-        OUTPUT_FILE := $(JDK_IMAGE_DIR)\/$(CDS_NOCOOPS_ARCHIVE), \\\n-        SUPPORT_DIR := $(SUPPORT_OUTPUTDIR)\/images\/jdk, \\\n-        COMMAND := $(FIXPATH) $(JDK_IMAGE_DIR)\/bin\/java -Xshare:dump \\\n-            -XX:SharedArchiveFile=$(JDK_IMAGE_DIR)\/$(CDS_NOCOOPS_ARCHIVE) \\\n-            -XX:-UseCompressedOops \\\n-            -Xmx128M -Xms128M $(LOG_INFO), \\\n-    ))\n-\n-    JDK_TARGETS += $(gen_cds_nocoops_archive_jdk)\n-\n-    $(eval $(call SetupExecute, gen_cds_nocoops_archive_jre, \\\n-        WARN := Creating CDS-NOCOOPS archive for jre image, \\\n-        DEPS := $(jlink_jre), \\\n-        OUTPUT_FILE := $(JRE_IMAGE_DIR)\/$(CDS_NOCOOPS_ARCHIVE), \\\n-        SUPPORT_DIR := $(SUPPORT_OUTPUTDIR)\/images\/jre, \\\n-        COMMAND := $(FIXPATH) $(JRE_IMAGE_DIR)\/bin\/java -Xshare:dump \\\n-            -XX:SharedArchiveFile=$(JRE_IMAGE_DIR)\/$(CDS_NOCOOPS_ARCHIVE) \\\n-            -XX:-UseCompressedOops \\\n-            -Xmx128M -Xms128M $(LOG_INFO), \\\n-    ))\n-\n-    JRE_TARGETS += $(gen_cds_nocoops_archive_jre)\n+    $(foreach v, $(JVM_VARIANTS), \\\n+      $(eval $(call CreateCDSArchive,$v,_nocoops)) \\\n+    )\n@@ -177,1 +166,0 @@\n-\n","filename":"make\/Images.gmk","additions":38,"deletions":50,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -413,1 +413,1 @@\n-    JVM_FEATURES_VARIANT_UNAVAILABLE=\"cds compiler1 compiler2 \\\n+    JVM_FEATURES_VARIANT_UNAVAILABLE=\"compiler1 compiler2 \\\n","filename":"make\/autoconf\/jvm-features.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -145,2 +145,1 @@\n-        $d\/cpu\/$(HOTSPOT_TARGET_CPU_ARCH)\/$(HOTSPOT_TARGET_CPU_ARCH)_neon.ad \\\n-        $d\/cpu\/$(HOTSPOT_TARGET_CPU_ARCH)\/$(HOTSPOT_TARGET_CPU_ARCH)_sve.ad \\\n+        $d\/cpu\/$(HOTSPOT_TARGET_CPU_ARCH)\/$(HOTSPOT_TARGET_CPU_ARCH)_vector.ad \\\n","filename":"make\/hotspot\/gensrc\/GensrcAdlc.gmk","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,3 +33,0 @@\n-import java.io.FileNotFoundException;\n-import java.io.BufferedInputStream;\n-import java.io.OutputStream;\n@@ -38,2 +35,0 @@\n-import java.util.BitSet;\n-import java.util.StringTokenizer;\n@@ -41,4 +36,0 @@\n-import java.util.Properties;\n-import java.util.zip.DeflaterOutputStream;\n-import java.util.zip.Deflater;\n-import java.net.URL;\n@@ -61,2 +52,1 @@\n-public\n-class DTDBuilder extends DTD {\n+public class DTDBuilder extends DTD {\n","filename":"make\/jdk\/src\/classes\/build\/tools\/dtdbuilder\/DTDBuilder.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -106,1 +106,0 @@\n-    java.base:include \\\n@@ -568,1 +567,0 @@\n-      java.base:include \\\n@@ -735,1 +733,0 @@\n-      java.base:include \\\n","filename":"make\/modules\/java.desktop\/lib\/Awt2dLibraries.gmk","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-            java.base:include \\\n@@ -75,2 +74,1 @@\n-            include\/bridge \\\n-            java.base:include, \\\n+            include\/bridge, \\\n","filename":"make\/modules\/jdk.accessibility\/Lib.gmk","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-   NO_FRAMEPOINTER_CFLAGS := -fomit-frame-pointer\n+  NO_FRAMEPOINTER_CFLAGS := -fomit-frame-pointer\n@@ -857,11 +857,11 @@\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LDFLAGS_libtest-rw := -z noexecstack\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LDFLAGS_libtest-rwx := -z execstack\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libstepBreakPopReturn := -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libIndyRedefineClass := -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefineClasses := -lpthread\n-    BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exeinvoke := -ljvm -lpthread\n-    BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exestack-gap := -ljvm -lpthread\n-    BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exestack-tls := -ljvm\n-    BUILD_TEST_exeinvoke_exeinvoke.c_OPTIMIZATION := NONE\n-    BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exeFPRegs := -ldl\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libAsyncGetCallTraceTest := -ldl\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LDFLAGS_libtest-rw := -z noexecstack\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LDFLAGS_libtest-rwx := -z execstack\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libstepBreakPopReturn := -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libIndyRedefineClass := -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefineClasses := -lpthread\n+  BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exeinvoke := -ljvm -lpthread\n+  BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exestack-gap := -ljvm -lpthread\n+  BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exestack-tls := -ljvm\n+  BUILD_TEST_exeinvoke_exeinvoke.c_OPTIMIZATION := NONE\n+  BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exeFPRegs := -ldl\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libAsyncGetCallTraceTest := -ldl\n@@ -876,3 +876,4 @@\n-    BUILD_HOTSPOT_JTREG_EXECUTABLES_CFLAGS_exeFPRegs := -MT\n-    BUILD_HOTSPOT_JTREG_EXCLUDE += exesigtest.c libterminatedThread.c libTestJNI.c libCompleteExit.c libTestPsig.c\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libatExit := jvm.lib\n+  BUILD_HOTSPOT_JTREG_EXECUTABLES_CFLAGS_exeFPRegs := -MT\n+  BUILD_HOTSPOT_JTREG_EXCLUDE += exesigtest.c libterminatedThread.c libTestJNI.c libCompleteExit.c libTestPsig.c\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libatExit := jvm.lib\n+  BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exedaemonDestroy := jvm.lib\n@@ -880,636 +881,637 @@\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbootclssearch_agent += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsystemclssearch_agent += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetsysprop001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetsysprop002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetlocal001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetlocal002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libGetEnv001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetvern001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetfldecl002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetfldecl004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetfldecl001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libloadedclss001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libloadedclss002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libextevents001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdatadumpreq001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtimerinfo001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrstat002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrstat005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrstat004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrstat003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrstat001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libframecnt001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libframecnt002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libframecnt003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcontmon003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcontmon002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcontmon001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrtimerinfo001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetenvstor001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetenvstor002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetenvstor003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libframeloc002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libframeloc003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libframeloc001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass009 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass031 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass030 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass008 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass015 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass012 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass024 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass023 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass022 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass025 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass013 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass014 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libstressRedefine += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass011 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass029 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass016 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass020 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass018 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass027 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass019 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass026 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass021 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass028 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass017 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass010 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetjlocfmt002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetjlocfmt001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetlocal003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetlocal004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetallstktr001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetcpool001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libextmech += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libagentthr += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libheapref += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librefignore += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libIsSyntheticIssynth001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liblinetab004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgc += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmonitor += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfollowref002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfollowref005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfollowref004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfollowref003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfollowref006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfollowref001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclsldrclss00x += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libearlyretvoid += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libearlyretlong += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libearlyretint += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libearlyretbase += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libearlyretstr += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libearlyretobj += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libearlyretfp += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetavailproc001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclstat006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclstat007 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclstat005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrinfo002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrinfo001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetthrdstor002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetthrdstor003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetthrdstor001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjsize001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libaddcaps001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libaddcaps002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libaddcaps003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclmthd007 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclmthd006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclmthd005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfieldacc003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfieldacc004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfieldacc002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfieldacc001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetsrcfn006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetsrcfn005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetsrcfn004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetthrdstor001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libintrpthrd001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libintrpthrd002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libintrpthrd003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnativemethbind002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnativemethbind004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnativemethbind003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnativemethbind001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetenvstor001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetextevent001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetpotcaps001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterobjreachobj001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterobjreachobj002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterobjreachobj005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterobjreachobj004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterobjreachobj003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclrfldw002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclrfldw001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libvminit001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsuspendthrd001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsuspendthrd002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsuspendthrd003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsuspendvthr001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdeclcls002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdeclcls003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdeclcls001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetjniftab002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetjniftab001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgeterrname002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgeterrname001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsettag001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libstopthrd007 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libstopthrd006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgenevents001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetfldmdf004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetfldmdf003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libresumethrdlst001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libresumethrdlst002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetbrk008 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetbrk007 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetbrk005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetbrk002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetbrk003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsuspendthrdlst001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsuspendthrdlst002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libIsMethodSyntheticIssynth001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libissynth002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libagentonunload001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetsysprop002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetsysprop003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libMethodBind += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libOnUnload += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libStackTrace += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefineCFLH += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libAddToBootstrapClassLoaderSearch += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libDispose += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libenvironment += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnosuspendMonitorInfo += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnosuspendStackTrace += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetNullVMInit += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtimers += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libHeap += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libHotSwap += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach046Agent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach041Agent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach015Agent01 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach015Agent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach015Target += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach012Agent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach040Agent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach014Agent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach022Agent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach038Agent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach009Agent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsimpleAgent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach037Agent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach008Agent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach039Agent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach020Agent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach042Agent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach045Agent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach045Agent03 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach045Agent02 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach045Agent01 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach002aAgent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach021Agent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach050Agent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach002Agent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgettag001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnframepop001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnframepop003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnframepop002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libvmobjalloc001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjwithtags001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnntfy004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnntfy003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnntfy002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnntfy001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmethmod001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmethmod002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmentry002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmentry001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterheap004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterheap003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterheap002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterheap005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterheap007 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterheap006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterheap001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe010 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe011 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe008 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe009 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe007 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcurthrtimerinfo001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnwait004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnwait003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnwait002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnwait005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnwait001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfldw001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfldw006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfldw003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfldw004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfldw005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfldw002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclrfmodw001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclrfmodw002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libisnative002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libisnative001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterreachobj002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterreachobj005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterreachobj004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterreachobj003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterreachobj001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liballthr001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liballthr002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjhashcode001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdyncodgen001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetnotif001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmexit001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmexit002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmethloc002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmethloc001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbreakpoint001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetcaps001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetcaps002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclsldrclss001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclsldrclss002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liblinetab001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liblinetab003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liblinetab002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmaxloc001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmaxloc002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassfloadhk002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassfloadhk005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassfloadhk004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassfloadhk003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassfloadhk008 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassfloadhk006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassfloadhk001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassfloadhk007 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassfloadhk009 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetintrf006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetintrf007 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetintrf005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libexcatch001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libresumethrd002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libresumethrd001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjfree001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjfree002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfieldmod002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfieldmod001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libextfuncs001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libSetNativeMethodPrefix002Main += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libSetNativeMethodPrefix002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libSetNativeMethodPrefix001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassprep001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetvrbflag002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetvrbflag001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmcontentered001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetevntcallb001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetevntcallb002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetevntcallb003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnntfyall002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnntfyall004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnntfyall003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnntfyall001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgcfinish001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libownmoninf002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libownmoninf003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libownmoninf001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetfldnm003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetfldnm004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetfldnm005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgf08t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgf08t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgf08t003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgf01t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgf06t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgf04t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbi02t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbi02t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbi03t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbi03t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbi04t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbi01t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbi01t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libex03t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm02t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm03t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t013 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t014 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t015 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t012 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t008 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t009 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t007 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t019 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t021 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t017 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t010 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t011 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t016 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t020 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t018 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp02t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp02t003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp02t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp05t003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp05t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp04t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp04t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp03t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp03t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp06t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp06t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp06t003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp01t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp01t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp01t003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp07t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp07t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtc04t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtc03t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtc03t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtc02t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtc05t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtc01t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma08t001a += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma08t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma01t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma01t001a += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma06t001a += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma06t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma07t001a += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma07t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma05t001a += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma05t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma02t001a += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma02t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma03t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma03t001a += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma04t003a += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma04t003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma04t002a += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma04t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma04t001a += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma04t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t003a += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t004a += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t005a += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t002a += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t007 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t007a += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t008 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t008a += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t001a += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t006a += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs103t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs104t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs104t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs301t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs301t005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs301t004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs301t003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs301t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs203t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs203t004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs203t003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs203t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs204t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs204t003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs204t004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs204t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs202t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs202t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_build += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t011 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t010 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t007 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t009 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t008 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t012 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs201t003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs201t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs201t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem06t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem01t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem01t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem07t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem07t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t008 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t009 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t007 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t012 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t010 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t011 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem05t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem05t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem04t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libji01t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libji06t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libji03t003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libji03t004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libji03t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libji03t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libji05t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap10t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap11t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap02t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap05t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap05t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap04t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap04t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap04t003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap03t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap12t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap06t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap01t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap09t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap07t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap07t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthreadstart001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthreadstart003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthreadstart002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmonenter002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmonenter003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmonenter004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmonenter001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdealloc001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libexceptionjni001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libisfldsin003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libisfldsin002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrgrpinfo001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrgrpinfo002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libAbort += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libCallbacks += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libNonConcreteKlassFilter += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libConcreteKlassFilter += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libHeapFilter += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmcontenter001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclrbrk001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclrbrk002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclrbrk005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtopthrgrp002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtopthrgrp001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libisarray004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libisarray005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbytecodes003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbytecodes002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbytecodes001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthreadend001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthreadend002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetthrdgrpchld001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmonitorwait001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liballoc001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsrcdebugex003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsrcdebugex002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsrcdebugex001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcrrawmon002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcrrawmon001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetjniftab001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetjniftab002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclsldr003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclsldr002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclsldr001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcurthrcputime001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmonexit001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmonexit002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmonexit005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmonexit003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libisobsolete001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libargsize001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libargsize002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclfld007 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclfld006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclfld005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetstacktr006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetstacktr001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetstacktr008 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetstacktr009 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetstacktr007 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetstacktr002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetstacktr005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetstacktr004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetstacktr003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liblocaltab001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liblocaltab004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liblocaltab003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liblocaltab002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liblocaltab005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassload001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libisintrf004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libisintrf005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libframepop001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libframepop002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclsig005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclsig004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclsig006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdisposeenv002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdisposeenv001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libexception001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libresexhausted += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgcstart001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgcstart002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterinstcls005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterinstcls002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterinstcls003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterinstcls004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterinstcls001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterinstcls006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterinstcls007 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmethname002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmethname003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmethname001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libforcegc001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libforcegc002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgettime001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjmonusage004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjmonusage003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjmonusage002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjmonusage005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjmonusage006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjmonusage001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libagentonload001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libagentonload002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libagentonload003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrcputime002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrcputime001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmonitorwaited001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libForceEarlyReturn001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libagentthr003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libagentthr002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libagentthr001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcompmethunload001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libretransform002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libretransform004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libretransform003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclmdf007 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclmdf006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclmdf004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclmdf005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetlocal001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetlocal004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetlocal003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetlocal002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcompmethload001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetsysprops001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetsysprops002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdrrawmon003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdrrawmon004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdrrawmon001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsinglestep001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsinglestep003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsinglestep002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librelcaps001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librelcaps002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfmodw004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfmodw003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfmodw002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfmodw005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfmodw006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfmodw001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libvmdeath001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetphase001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetphase002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libterminatedThread += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libatExit += -ljvm\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libCompleteExit += -lpthread\n+  BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exedaemonDestroy := -ljvm\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbootclssearch_agent += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsystemclssearch_agent += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetsysprop001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetsysprop002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetlocal001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetlocal002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libGetEnv001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetvern001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetfldecl002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetfldecl004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetfldecl001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libloadedclss001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libloadedclss002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libextevents001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdatadumpreq001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtimerinfo001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrstat002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrstat005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrstat004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrstat003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrstat001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libframecnt001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libframecnt002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libframecnt003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcontmon003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcontmon002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcontmon001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrtimerinfo001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetenvstor001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetenvstor002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetenvstor003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libframeloc002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libframeloc003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libframeloc001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass009 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass031 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass030 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass008 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass015 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass012 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass024 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass023 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass022 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass025 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass013 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass014 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libstressRedefine += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass011 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass029 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass016 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass020 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass018 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass027 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass019 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass026 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass021 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass028 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass017 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass010 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetjlocfmt002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetjlocfmt001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetlocal003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetlocal004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetallstktr001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetcpool001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libextmech += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libagentthr += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libheapref += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librefignore += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libIsSyntheticIssynth001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liblinetab004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgc += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmonitor += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfollowref002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfollowref005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfollowref004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfollowref003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfollowref006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfollowref001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclsldrclss00x += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libearlyretvoid += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libearlyretlong += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libearlyretint += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libearlyretbase += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libearlyretstr += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libearlyretobj += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libearlyretfp += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetavailproc001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclstat006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclstat007 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclstat005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrinfo002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrinfo001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetthrdstor002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetthrdstor003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetthrdstor001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjsize001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libaddcaps001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libaddcaps002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libaddcaps003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclmthd007 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclmthd006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclmthd005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfieldacc003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfieldacc004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfieldacc002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfieldacc001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetsrcfn006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetsrcfn005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetsrcfn004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetthrdstor001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libintrpthrd001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libintrpthrd002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libintrpthrd003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnativemethbind002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnativemethbind004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnativemethbind003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnativemethbind001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetenvstor001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetextevent001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetpotcaps001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterobjreachobj001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterobjreachobj002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterobjreachobj005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterobjreachobj004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterobjreachobj003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclrfldw002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclrfldw001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libvminit001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsuspendthrd001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsuspendthrd002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsuspendthrd003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsuspendvthr001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdeclcls002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdeclcls003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdeclcls001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetjniftab002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetjniftab001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgeterrname002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgeterrname001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsettag001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libstopthrd007 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libstopthrd006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgenevents001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetfldmdf004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetfldmdf003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libresumethrdlst001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libresumethrdlst002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetbrk008 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetbrk007 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetbrk005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetbrk002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetbrk003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsuspendthrdlst001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsuspendthrdlst002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libIsMethodSyntheticIssynth001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libissynth002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libagentonunload001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetsysprop002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetsysprop003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libMethodBind += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libOnUnload += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libStackTrace += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefineCFLH += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libAddToBootstrapClassLoaderSearch += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libDispose += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libenvironment += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnosuspendMonitorInfo += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnosuspendStackTrace += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetNullVMInit += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtimers += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libHeap += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libHotSwap += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach046Agent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach041Agent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach015Agent01 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach015Agent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach015Target += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach012Agent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach040Agent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach014Agent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach022Agent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach038Agent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach009Agent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsimpleAgent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach037Agent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach008Agent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach039Agent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach020Agent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach042Agent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach045Agent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach045Agent03 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach045Agent02 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach045Agent01 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach002aAgent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach021Agent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach050Agent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach002Agent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgettag001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnframepop001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnframepop003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnframepop002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libvmobjalloc001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjwithtags001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnntfy004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnntfy003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnntfy002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnntfy001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmethmod001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmethmod002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmentry002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmentry001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterheap004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterheap003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterheap002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterheap005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterheap007 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterheap006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterheap001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe010 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe011 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe008 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe009 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe007 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcurthrtimerinfo001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnwait004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnwait003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnwait002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnwait005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnwait001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfldw001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfldw006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfldw003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfldw004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfldw005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfldw002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclrfmodw001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclrfmodw002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libisnative002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libisnative001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterreachobj002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterreachobj005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterreachobj004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterreachobj003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterreachobj001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liballthr001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liballthr002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjhashcode001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdyncodgen001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetnotif001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmexit001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmexit002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmethloc002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmethloc001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbreakpoint001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetcaps001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetcaps002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclsldrclss001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclsldrclss002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liblinetab001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liblinetab003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liblinetab002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmaxloc001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmaxloc002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassfloadhk002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassfloadhk005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassfloadhk004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassfloadhk003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassfloadhk008 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassfloadhk006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassfloadhk001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassfloadhk007 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassfloadhk009 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetintrf006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetintrf007 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetintrf005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libexcatch001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libresumethrd002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libresumethrd001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjfree001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjfree002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfieldmod002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfieldmod001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libextfuncs001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libSetNativeMethodPrefix002Main += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libSetNativeMethodPrefix002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libSetNativeMethodPrefix001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassprep001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetvrbflag002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetvrbflag001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmcontentered001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetevntcallb001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetevntcallb002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetevntcallb003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnntfyall002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnntfyall004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnntfyall003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnntfyall001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgcfinish001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libownmoninf002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libownmoninf003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libownmoninf001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetfldnm003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetfldnm004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetfldnm005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgf08t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgf08t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgf08t003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgf01t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgf06t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgf04t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbi02t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbi02t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbi03t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbi03t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbi04t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbi01t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbi01t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libex03t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm02t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm03t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t013 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t014 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t015 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t012 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t008 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t009 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t007 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t019 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t021 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t017 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t010 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t011 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t016 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t020 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t018 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp02t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp02t003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp02t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp05t003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp05t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp04t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp04t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp03t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp03t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp06t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp06t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp06t003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp01t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp01t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp01t003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp07t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp07t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtc04t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtc03t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtc03t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtc02t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtc05t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtc01t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma08t001a += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma08t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma01t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma01t001a += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma06t001a += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma06t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma07t001a += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma07t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma05t001a += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma05t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma02t001a += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma02t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma03t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma03t001a += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma04t003a += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma04t003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma04t002a += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma04t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma04t001a += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma04t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t003a += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t004a += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t005a += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t002a += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t007 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t007a += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t008 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t008a += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t001a += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t006a += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs103t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs104t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs104t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs301t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs301t005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs301t004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs301t003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs301t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs203t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs203t004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs203t003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs203t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs204t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs204t003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs204t004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs204t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs202t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs202t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_build += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t011 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t010 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t007 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t009 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t008 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t012 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs201t003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs201t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs201t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem06t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem01t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem01t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem07t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem07t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t008 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t009 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t007 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t012 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t010 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t011 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem05t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem05t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem04t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libji01t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libji06t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libji03t003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libji03t004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libji03t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libji03t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libji05t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap10t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap11t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap02t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap05t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap05t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap04t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap04t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap04t003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap03t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap12t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap06t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap01t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap09t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap07t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap07t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthreadstart001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthreadstart003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthreadstart002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmonenter002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmonenter003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmonenter004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmonenter001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdealloc001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libexceptionjni001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libisfldsin003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libisfldsin002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrgrpinfo001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrgrpinfo002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libAbort += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libCallbacks += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libNonConcreteKlassFilter += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libConcreteKlassFilter += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libHeapFilter += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmcontenter001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclrbrk001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclrbrk002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclrbrk005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtopthrgrp002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtopthrgrp001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libisarray004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libisarray005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbytecodes003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbytecodes002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbytecodes001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthreadend001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthreadend002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetthrdgrpchld001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmonitorwait001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liballoc001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsrcdebugex003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsrcdebugex002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsrcdebugex001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcrrawmon002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcrrawmon001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetjniftab001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetjniftab002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclsldr003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclsldr002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclsldr001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcurthrcputime001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmonexit001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmonexit002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmonexit005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmonexit003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libisobsolete001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libargsize001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libargsize002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclfld007 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclfld006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclfld005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetstacktr006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetstacktr001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetstacktr008 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetstacktr009 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetstacktr007 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetstacktr002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetstacktr005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetstacktr004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetstacktr003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liblocaltab001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liblocaltab004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liblocaltab003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liblocaltab002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liblocaltab005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassload001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libisintrf004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libisintrf005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libframepop001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libframepop002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclsig005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclsig004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclsig006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdisposeenv002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdisposeenv001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libexception001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libresexhausted += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgcstart001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgcstart002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterinstcls005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterinstcls002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterinstcls003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterinstcls004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterinstcls001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterinstcls006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterinstcls007 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmethname002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmethname003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmethname001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libforcegc001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libforcegc002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgettime001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjmonusage004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjmonusage003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjmonusage002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjmonusage005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjmonusage006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjmonusage001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libagentonload001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libagentonload002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libagentonload003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrcputime002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrcputime001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmonitorwaited001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libForceEarlyReturn001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libagentthr003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libagentthr002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libagentthr001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcompmethunload001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libretransform002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libretransform004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libretransform003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclmdf007 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclmdf006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclmdf004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclmdf005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetlocal001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetlocal004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetlocal003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetlocal002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcompmethload001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetsysprops001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetsysprops002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdrrawmon003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdrrawmon004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdrrawmon001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsinglestep001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsinglestep003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsinglestep002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librelcaps001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librelcaps002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfmodw004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfmodw003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfmodw002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfmodw005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfmodw006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfmodw001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libvmdeath001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetphase001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetphase002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libterminatedThread += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libatExit += -ljvm\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libCompleteExit += -lpthread\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":653,"deletions":651,"binary":false,"changes":1304,"status":"modified"},{"patch":"@@ -182,4 +182,0 @@\n-  reg_def V0_L ( SOC, SOC, Op_RegF, 0, v0->as_VMReg()->next(4) );\n-  reg_def V0_M ( SOC, SOC, Op_RegF, 0, v0->as_VMReg()->next(5) );\n-  reg_def V0_N ( SOC, SOC, Op_RegF, 0, v0->as_VMReg()->next(6) );\n-  reg_def V0_O ( SOC, SOC, Op_RegF, 0, v0->as_VMReg()->next(7) );\n@@ -191,4 +187,0 @@\n-  reg_def V1_L ( SOC, SOC, Op_RegF, 1, v1->as_VMReg()->next(4) );\n-  reg_def V1_M ( SOC, SOC, Op_RegF, 1, v1->as_VMReg()->next(5) );\n-  reg_def V1_N ( SOC, SOC, Op_RegF, 1, v1->as_VMReg()->next(6) );\n-  reg_def V1_O ( SOC, SOC, Op_RegF, 1, v1->as_VMReg()->next(7) );\n@@ -200,4 +192,0 @@\n-  reg_def V2_L ( SOC, SOC, Op_RegF, 2, v2->as_VMReg()->next(4) );\n-  reg_def V2_M ( SOC, SOC, Op_RegF, 2, v2->as_VMReg()->next(5) );\n-  reg_def V2_N ( SOC, SOC, Op_RegF, 2, v2->as_VMReg()->next(6) );\n-  reg_def V2_O ( SOC, SOC, Op_RegF, 2, v2->as_VMReg()->next(7) );\n@@ -209,4 +197,0 @@\n-  reg_def V3_L ( SOC, SOC, Op_RegF, 3, v3->as_VMReg()->next(4) );\n-  reg_def V3_M ( SOC, SOC, Op_RegF, 3, v3->as_VMReg()->next(5) );\n-  reg_def V3_N ( SOC, SOC, Op_RegF, 3, v3->as_VMReg()->next(6) );\n-  reg_def V3_O ( SOC, SOC, Op_RegF, 3, v3->as_VMReg()->next(7) );\n@@ -218,4 +202,0 @@\n-  reg_def V4_L ( SOC, SOC, Op_RegF, 4, v4->as_VMReg()->next(4) );\n-  reg_def V4_M ( SOC, SOC, Op_RegF, 4, v4->as_VMReg()->next(5) );\n-  reg_def V4_N ( SOC, SOC, Op_RegF, 4, v4->as_VMReg()->next(6) );\n-  reg_def V4_O ( SOC, SOC, Op_RegF, 4, v4->as_VMReg()->next(7) );\n@@ -227,4 +207,0 @@\n-  reg_def V5_L ( SOC, SOC, Op_RegF, 5, v5->as_VMReg()->next(4) );\n-  reg_def V5_M ( SOC, SOC, Op_RegF, 5, v5->as_VMReg()->next(5) );\n-  reg_def V5_N ( SOC, SOC, Op_RegF, 5, v5->as_VMReg()->next(6) );\n-  reg_def V5_O ( SOC, SOC, Op_RegF, 5, v5->as_VMReg()->next(7) );\n@@ -236,4 +212,0 @@\n-  reg_def V6_L ( SOC, SOC, Op_RegF, 6, v6->as_VMReg()->next(4) );\n-  reg_def V6_M ( SOC, SOC, Op_RegF, 6, v6->as_VMReg()->next(5) );\n-  reg_def V6_N ( SOC, SOC, Op_RegF, 6, v6->as_VMReg()->next(6) );\n-  reg_def V6_O ( SOC, SOC, Op_RegF, 6, v6->as_VMReg()->next(7) );\n@@ -245,4 +217,0 @@\n-  reg_def V7_L ( SOC, SOC, Op_RegF, 7, v7->as_VMReg()->next(4) );\n-  reg_def V7_M ( SOC, SOC, Op_RegF, 7, v7->as_VMReg()->next(5) );\n-  reg_def V7_N ( SOC, SOC, Op_RegF, 7, v7->as_VMReg()->next(6) );\n-  reg_def V7_O ( SOC, SOC, Op_RegF, 7, v7->as_VMReg()->next(7) );\n@@ -254,4 +222,0 @@\n-  reg_def V8_L ( SOC, SOC, Op_RegF, 8, v8->as_VMReg()->next(4) );\n-  reg_def V8_M ( SOC, SOC, Op_RegF, 8, v8->as_VMReg()->next(5) );\n-  reg_def V8_N ( SOC, SOC, Op_RegF, 8, v8->as_VMReg()->next(6) );\n-  reg_def V8_O ( SOC, SOC, Op_RegF, 8, v8->as_VMReg()->next(7) );\n@@ -263,4 +227,0 @@\n-  reg_def V9_L ( SOC, SOC, Op_RegF, 9, v9->as_VMReg()->next(4) );\n-  reg_def V9_M ( SOC, SOC, Op_RegF, 9, v9->as_VMReg()->next(5) );\n-  reg_def V9_N ( SOC, SOC, Op_RegF, 9, v9->as_VMReg()->next(6) );\n-  reg_def V9_O ( SOC, SOC, Op_RegF, 9, v9->as_VMReg()->next(7) );\n@@ -272,4 +232,0 @@\n-  reg_def V10_L ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next(4) );\n-  reg_def V10_M ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next(5) );\n-  reg_def V10_N ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next(6) );\n-  reg_def V10_O ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next(7) );\n@@ -281,4 +237,0 @@\n-  reg_def V11_L ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next(4) );\n-  reg_def V11_M ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next(5) );\n-  reg_def V11_N ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next(6) );\n-  reg_def V11_O ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next(7) );\n@@ -290,4 +242,0 @@\n-  reg_def V12_L ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next(4) );\n-  reg_def V12_M ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next(5) );\n-  reg_def V12_N ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next(6) );\n-  reg_def V12_O ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next(7) );\n@@ -299,4 +247,0 @@\n-  reg_def V13_L ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next(4) );\n-  reg_def V13_M ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next(5) );\n-  reg_def V13_N ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next(6) );\n-  reg_def V13_O ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next(7) );\n@@ -308,4 +252,0 @@\n-  reg_def V14_L ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next(4) );\n-  reg_def V14_M ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next(5) );\n-  reg_def V14_N ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next(6) );\n-  reg_def V14_O ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next(7) );\n@@ -317,4 +257,0 @@\n-  reg_def V15_L ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next(4) );\n-  reg_def V15_M ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next(5) );\n-  reg_def V15_N ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next(6) );\n-  reg_def V15_O ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next(7) );\n@@ -326,4 +262,0 @@\n-  reg_def V16_L ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next(4) );\n-  reg_def V16_M ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next(5) );\n-  reg_def V16_N ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next(6) );\n-  reg_def V16_O ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next(7) );\n@@ -335,4 +267,0 @@\n-  reg_def V17_L ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next(4) );\n-  reg_def V17_M ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next(5) );\n-  reg_def V17_N ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next(6) );\n-  reg_def V17_O ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next(7) );\n@@ -344,4 +272,0 @@\n-  reg_def V18_L ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next(4) );\n-  reg_def V18_M ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next(5) );\n-  reg_def V18_N ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next(6) );\n-  reg_def V18_O ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next(7) );\n@@ -353,4 +277,0 @@\n-  reg_def V19_L ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next(4) );\n-  reg_def V19_M ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next(5) );\n-  reg_def V19_N ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next(6) );\n-  reg_def V19_O ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next(7) );\n@@ -362,4 +282,0 @@\n-  reg_def V20_L ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next(4) );\n-  reg_def V20_M ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next(5) );\n-  reg_def V20_N ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next(6) );\n-  reg_def V20_O ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next(7) );\n@@ -371,4 +287,0 @@\n-  reg_def V21_L ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next(4) );\n-  reg_def V21_M ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next(5) );\n-  reg_def V21_N ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next(6) );\n-  reg_def V21_O ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next(7) );\n@@ -380,4 +292,0 @@\n-  reg_def V22_L ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next(4) );\n-  reg_def V22_M ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next(5) );\n-  reg_def V22_N ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next(6) );\n-  reg_def V22_O ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next(7) );\n@@ -389,4 +297,0 @@\n-  reg_def V23_L ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next(4) );\n-  reg_def V23_M ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next(5) );\n-  reg_def V23_N ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next(6) );\n-  reg_def V23_O ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next(7) );\n@@ -398,4 +302,0 @@\n-  reg_def V24_L ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next(4) );\n-  reg_def V24_M ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next(5) );\n-  reg_def V24_N ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next(6) );\n-  reg_def V24_O ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next(7) );\n@@ -407,4 +307,0 @@\n-  reg_def V25_L ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next(4) );\n-  reg_def V25_M ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next(5) );\n-  reg_def V25_N ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next(6) );\n-  reg_def V25_O ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next(7) );\n@@ -416,4 +312,0 @@\n-  reg_def V26_L ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next(4) );\n-  reg_def V26_M ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next(5) );\n-  reg_def V26_N ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next(6) );\n-  reg_def V26_O ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next(7) );\n@@ -425,4 +317,0 @@\n-  reg_def V27_L ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next(4) );\n-  reg_def V27_M ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next(5) );\n-  reg_def V27_N ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next(6) );\n-  reg_def V27_O ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next(7) );\n@@ -434,4 +322,0 @@\n-  reg_def V28_L ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next(4) );\n-  reg_def V28_M ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next(5) );\n-  reg_def V28_N ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next(6) );\n-  reg_def V28_O ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next(7) );\n@@ -443,4 +327,0 @@\n-  reg_def V29_L ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next(4) );\n-  reg_def V29_M ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next(5) );\n-  reg_def V29_N ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next(6) );\n-  reg_def V29_O ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next(7) );\n@@ -452,4 +332,0 @@\n-  reg_def V30_L ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next(4) );\n-  reg_def V30_M ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next(5) );\n-  reg_def V30_N ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next(6) );\n-  reg_def V30_O ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next(7) );\n@@ -461,5 +337,0 @@\n-  reg_def V31_L ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next(4) );\n-  reg_def V31_M ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next(5) );\n-  reg_def V31_N ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next(6) );\n-  reg_def V31_O ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next(7) );\n-\n@@ -553,16 +424,16 @@\n-    V16, V16_H, V16_J, V16_K, V16_L, V16_M, V16_N, V16_O,\n-    V17, V17_H, V17_J, V17_K, V17_L, V17_M, V17_N, V17_O,\n-    V18, V18_H, V18_J, V18_K, V18_L, V18_M, V18_N, V18_O,\n-    V19, V19_H, V19_J, V19_K, V19_L, V19_M, V19_N, V19_O,\n-    V20, V20_H, V20_J, V20_K, V20_L, V20_M, V20_N, V20_O,\n-    V21, V21_H, V21_J, V21_K, V21_L, V21_M, V21_N, V21_O,\n-    V22, V22_H, V22_J, V22_K, V22_L, V22_M, V22_N, V22_O,\n-    V23, V23_H, V23_J, V23_K, V23_L, V23_M, V23_N, V23_O,\n-    V24, V24_H, V24_J, V24_K, V24_L, V24_M, V24_N, V24_O,\n-    V25, V25_H, V25_J, V25_K, V25_L, V25_M, V25_N, V25_O,\n-    V26, V26_H, V26_J, V26_K, V26_L, V26_M, V26_N, V26_O,\n-    V27, V27_H, V27_J, V27_K, V27_L, V27_M, V27_N, V27_O,\n-    V28, V28_H, V28_J, V28_K, V28_L, V28_M, V28_N, V28_O,\n-    V29, V29_H, V29_J, V29_K, V29_L, V29_M, V29_N, V29_O,\n-    V30, V30_H, V30_J, V30_K, V30_L, V30_M, V30_N, V30_O,\n-    V31, V31_H, V31_J, V31_K, V31_L, V31_M, V31_N, V31_O,\n+    V16, V16_H, V16_J, V16_K,\n+    V17, V17_H, V17_J, V17_K,\n+    V18, V18_H, V18_J, V18_K,\n+    V19, V19_H, V19_J, V19_K,\n+    V20, V20_H, V20_J, V20_K,\n+    V21, V21_H, V21_J, V21_K,\n+    V22, V22_H, V22_J, V22_K,\n+    V23, V23_H, V23_J, V23_K,\n+    V24, V24_H, V24_J, V24_K,\n+    V25, V25_H, V25_J, V25_K,\n+    V26, V26_H, V26_J, V26_K,\n+    V27, V27_H, V27_J, V27_K,\n+    V28, V28_H, V28_J, V28_K,\n+    V29, V29_H, V29_J, V29_K,\n+    V30, V30_H, V30_J, V30_K,\n+    V31, V31_H, V31_J, V31_K,\n@@ -571,8 +442,8 @@\n-    V0, V0_H, V0_J, V0_K, V0_L, V0_M, V0_N, V0_O,\n-    V1, V1_H, V1_J, V1_K, V1_L, V1_M, V1_N, V1_O,\n-    V2, V2_H, V2_J, V2_K, V2_L, V2_M, V2_N, V2_O,\n-    V3, V3_H, V3_J, V3_K, V3_L, V3_M, V3_N, V3_O,\n-    V4, V4_H, V4_J, V4_K, V4_L, V4_M, V4_N, V4_O,\n-    V5, V5_H, V5_J, V5_K, V5_L, V5_M, V5_N, V5_O,\n-    V6, V6_H, V6_J, V6_K, V6_L, V6_M, V6_N, V6_O,\n-    V7, V7_H, V7_J, V7_K, V7_L, V7_M, V7_N, V7_O,\n+    V0, V0_H, V0_J, V0_K,\n+    V1, V1_H, V1_J, V1_K,\n+    V2, V2_H, V2_J, V2_K,\n+    V3, V3_H, V3_J, V3_K,\n+    V4, V4_H, V4_J, V4_K,\n+    V5, V5_H, V5_J, V5_K,\n+    V6, V6_H, V6_J, V6_K,\n+    V7, V7_H, V7_J, V7_K,\n@@ -581,8 +452,8 @@\n-    V8, V8_H, V8_J, V8_K, V8_L, V8_M, V8_N, V8_O,\n-    V9, V9_H, V9_J, V9_K, V9_L, V9_M, V9_N, V9_O,\n-    V10, V10_H, V10_J, V10_K, V10_L, V10_M, V10_N, V10_O,\n-    V11, V11_H, V11_J, V11_K, V11_L, V11_M, V11_N, V11_O,\n-    V12, V12_H, V12_J, V12_K, V12_L, V12_M, V12_N, V12_O,\n-    V13, V13_H, V13_J, V13_K, V13_L, V13_M, V13_N, V13_O,\n-    V14, V14_H, V14_J, V14_K, V14_L, V14_M, V14_N, V14_O,\n-    V15, V15_H, V15_J, V15_K, V15_L, V15_M, V15_N, V15_O,\n+    V8, V8_H, V8_J, V8_K,\n+    V9, V9_H, V9_J, V9_K,\n+    V10, V10_H, V10_J, V10_K,\n+    V11, V11_H, V11_J, V11_K,\n+    V12, V12_H, V12_J, V12_K,\n+    V13, V13_H, V13_J, V13_K,\n+    V14, V14_H, V14_J, V14_K,\n+    V15, V15_H, V15_J, V15_K,\n@@ -903,32 +774,32 @@\n-    V0, V0_H, V0_J, V0_K, V0_L, V0_M, V0_N, V0_O,\n-    V1, V1_H, V1_J, V1_K, V1_L, V1_M, V1_N, V1_O,\n-    V2, V2_H, V2_J, V2_K, V2_L, V2_M, V2_N, V2_O,\n-    V3, V3_H, V3_J, V3_K, V3_L, V3_M, V3_N, V3_O,\n-    V4, V4_H, V4_J, V4_K, V4_L, V4_M, V4_N, V4_O,\n-    V5, V5_H, V5_J, V5_K, V5_L, V5_M, V5_N, V5_O,\n-    V6, V6_H, V6_J, V6_K, V6_L, V6_M, V6_N, V6_O,\n-    V7, V7_H, V7_J, V7_K, V7_L, V7_M, V7_N, V7_O,\n-    V8, V8_H, V8_J, V8_K, V8_L, V8_M, V8_N, V8_O,\n-    V9, V9_H, V9_J, V9_K, V9_L, V9_M, V9_N, V9_O,\n-    V10, V10_H, V10_J, V10_K, V10_L, V10_M, V10_N, V10_O,\n-    V11, V11_H, V11_J, V11_K, V11_L, V11_M, V11_N, V11_O,\n-    V12, V12_H, V12_J, V12_K, V12_L, V12_M, V12_N, V12_O,\n-    V13, V13_H, V13_J, V13_K, V13_L, V13_M, V13_N, V13_O,\n-    V14, V14_H, V14_J, V14_K, V14_L, V14_M, V14_N, V14_O,\n-    V15, V15_H, V15_J, V15_K, V15_L, V15_M, V15_N, V15_O,\n-    V16, V16_H, V16_J, V16_K, V16_L, V16_M, V16_N, V16_O,\n-    V17, V17_H, V17_J, V17_K, V17_L, V17_M, V17_N, V17_O,\n-    V18, V18_H, V18_J, V18_K, V18_L, V18_M, V18_N, V18_O,\n-    V19, V19_H, V19_J, V19_K, V19_L, V19_M, V19_N, V19_O,\n-    V20, V20_H, V20_J, V20_K, V20_L, V20_M, V20_N, V20_O,\n-    V21, V21_H, V21_J, V21_K, V21_L, V21_M, V21_N, V21_O,\n-    V22, V22_H, V22_J, V22_K, V22_L, V22_M, V22_N, V22_O,\n-    V23, V23_H, V23_J, V23_K, V23_L, V23_M, V23_N, V23_O,\n-    V24, V24_H, V24_J, V24_K, V24_L, V24_M, V24_N, V24_O,\n-    V25, V25_H, V25_J, V25_K, V25_L, V25_M, V25_N, V25_O,\n-    V26, V26_H, V26_J, V26_K, V26_L, V26_M, V26_N, V26_O,\n-    V27, V27_H, V27_J, V27_K, V27_L, V27_M, V27_N, V27_O,\n-    V28, V28_H, V28_J, V28_K, V28_L, V28_M, V28_N, V28_O,\n-    V29, V29_H, V29_J, V29_K, V29_L, V29_M, V29_N, V29_O,\n-    V30, V30_H, V30_J, V30_K, V30_L, V30_M, V30_N, V30_O,\n-    V31, V31_H, V31_J, V31_K, V31_L, V31_M, V31_N, V31_O,\n+    V0, V0_H, V0_J, V0_K,\n+    V1, V1_H, V1_J, V1_K,\n+    V2, V2_H, V2_J, V2_K,\n+    V3, V3_H, V3_J, V3_K,\n+    V4, V4_H, V4_J, V4_K,\n+    V5, V5_H, V5_J, V5_K,\n+    V6, V6_H, V6_J, V6_K,\n+    V7, V7_H, V7_J, V7_K,\n+    V8, V8_H, V8_J, V8_K,\n+    V9, V9_H, V9_J, V9_K,\n+    V10, V10_H, V10_J, V10_K,\n+    V11, V11_H, V11_J, V11_K,\n+    V12, V12_H, V12_J, V12_K,\n+    V13, V13_H, V13_J, V13_K,\n+    V14, V14_H, V14_J, V14_K,\n+    V15, V15_H, V15_J, V15_K,\n+    V16, V16_H, V16_J, V16_K,\n+    V17, V17_H, V17_J, V17_K,\n+    V18, V18_H, V18_J, V18_K,\n+    V19, V19_H, V19_J, V19_K,\n+    V20, V20_H, V20_J, V20_K,\n+    V21, V21_H, V21_J, V21_K,\n+    V22, V22_H, V22_J, V22_K,\n+    V23, V23_H, V23_J, V23_K,\n+    V24, V24_H, V24_J, V24_K,\n+    V25, V25_H, V25_J, V25_K,\n+    V26, V26_H, V26_J, V26_K,\n+    V27, V27_H, V27_J, V27_K,\n+    V28, V28_H, V28_J, V28_K,\n+    V29, V29_H, V29_J, V29_K,\n+    V30, V30_H, V30_J, V30_K,\n+    V31, V31_H, V31_J, V31_K,\n@@ -1317,3 +1188,0 @@\n-  \/\/ Assert that the given node is not a variable shift.\n-  bool assert_not_var_shift(const Node* n);\n-\n@@ -1734,6 +1602,0 @@\n-\/\/ Assert that the given node is not a variable shift.\n-bool assert_not_var_shift(const Node* n) {\n-  assert(!n->as_ShiftV()->is_var_shift(), \"illegal variable shift\");\n-  return true;\n-}\n-\n@@ -2435,12 +2297,0 @@\n-    case Op_LoadVectorMasked:\n-    case Op_StoreVectorMasked:\n-    case Op_LoadVectorGatherMasked:\n-    case Op_StoreVectorScatterMasked:\n-    case Op_MaskAll:\n-    case Op_AndVMask:\n-    case Op_OrVMask:\n-    case Op_XorVMask:\n-      if (UseSVE == 0) {\n-        ret_value = false;\n-      }\n-      break;\n@@ -2452,76 +2302,0 @@\n-const bool Matcher::match_rule_supported_superword(int opcode, int vlen, BasicType bt) {\n-  if (UseSVE == 0) {\n-    \/\/ ConvD2I and ConvL2F are not profitable to be vectorized on NEON, because no direct\n-    \/\/ NEON instructions support them. But the match rule support for them is profitable for\n-    \/\/ Vector API intrinsics.\n-    if ((opcode == Op_VectorCastD2X && bt == T_INT) ||\n-        (opcode == Op_VectorCastL2X && bt == T_FLOAT)) {\n-      return false;\n-    }\n-  }\n-  return match_rule_supported_vector(opcode, vlen, bt);\n-}\n-\n-\/\/ Identify extra cases that we might want to provide match rules for vector nodes and\n-\/\/ other intrinsics guarded with vector length (vlen) and element type (bt).\n-const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {\n-  if (!match_rule_supported(opcode)) {\n-    return false;\n-  }\n-  int bit_size = vlen * type2aelembytes(bt) * 8;\n-  if (UseSVE == 0 && bit_size > 128) {\n-    return false;\n-  }\n-  if (UseSVE > 0) {\n-    return op_sve_supported(opcode, vlen, bt);\n-  } else { \/\/ NEON\n-    \/\/ Special cases\n-    switch (opcode) {\n-    case Op_VectorMaskCmp:\n-      if (vlen < 2 || bit_size < 64) {\n-        return false;\n-      }\n-      break;\n-    case Op_MulAddVS2VI:\n-      if (bit_size < 128) {\n-        return false;\n-      }\n-      break;\n-    case Op_MulVL:\n-    case Op_PopulateIndex:\n-      return false;\n-    case Op_VectorLoadShuffle:\n-    case Op_VectorRearrange:\n-      if (vlen < 4) {\n-        return false;\n-      }\n-      break;\n-    case Op_VectorMaskGen:\n-    case Op_LoadVectorGather:\n-    case Op_StoreVectorScatter:\n-    case Op_CompressV:\n-    case Op_CompressM:\n-    case Op_ExpandV:\n-    case Op_VectorLongToMask:\n-      return false;\n-    default:\n-      break;\n-    }\n-  }\n-  return vector_size_supported(bt, vlen);\n-}\n-\n-const bool Matcher::match_rule_supported_vector_masked(int opcode, int vlen, BasicType bt) {\n-  \/\/ Only SVE supports masked operations.\n-  if (UseSVE == 0) {\n-    return false;\n-  }\n-  return match_rule_supported(opcode) &&\n-         masked_op_sve_supported(opcode, vlen, bt);\n-}\n-\n-const bool Matcher::vector_needs_partial_operations(Node* node, const TypeVect* vt) {\n-  \/\/ Only SVE has partial vector operations\n-  return (UseSVE > 0) && partial_op_sve_needed(node, vt);\n-}\n-\n@@ -2594,1 +2368,1 @@\n-  if (UseSVE > 0 && 2 <= len && len <= 256) {\n+  if (UseSVE > 0 && 16 < len && len <= 256) {\n@@ -2608,2 +2382,8 @@\n-MachOper* Matcher::pd_specialize_generic_vector_operand(MachOper* original_opnd, uint ideal_reg, bool is_temp) {\n-  ShouldNotReachHere(); \/\/ generic vector operands not supported\n+MachOper* Matcher::pd_specialize_generic_vector_operand(MachOper* generic_opnd, uint ideal_reg, bool is_temp) {\n+  assert(Matcher::is_generic_vector(generic_opnd), \"not generic\");\n+  switch (ideal_reg) {\n+    case Op_VecA: return new vecAOper();\n+    case Op_VecD: return new vecDOper();\n+    case Op_VecX: return new vecXOper();\n+  }\n+  ShouldNotReachHere();\n@@ -2614,1 +2394,0 @@\n-  ShouldNotReachHere();  \/\/ generic vector operands not supported\n@@ -2619,2 +2398,1 @@\n-  ShouldNotReachHere();  \/\/ generic vector operands not supported\n-  return false;\n+  return opnd->opcode() == VREG;\n@@ -3208,1 +2986,1 @@\n-  enc_class aarch64_enc_ldrvH(vecD dst, memory mem) %{\n+  enc_class aarch64_enc_ldrvH(vReg dst, memory mem) %{\n@@ -3214,1 +2992,1 @@\n-  enc_class aarch64_enc_ldrvS(vecD dst, memory mem) %{\n+  enc_class aarch64_enc_ldrvS(vReg dst, memory mem) %{\n@@ -3220,1 +2998,1 @@\n-  enc_class aarch64_enc_ldrvD(vecD dst, memory mem) %{\n+  enc_class aarch64_enc_ldrvD(vReg dst, memory mem) %{\n@@ -3226,1 +3004,1 @@\n-  enc_class aarch64_enc_ldrvQ(vecX dst, memory mem) %{\n+  enc_class aarch64_enc_ldrvQ(vReg dst, memory mem) %{\n@@ -3232,1 +3010,1 @@\n-  enc_class aarch64_enc_strvH(vecD src, memory mem) %{\n+  enc_class aarch64_enc_strvH(vReg src, memory mem) %{\n@@ -3238,1 +3016,1 @@\n-  enc_class aarch64_enc_strvS(vecD src, memory mem) %{\n+  enc_class aarch64_enc_strvS(vReg src, memory mem) %{\n@@ -3244,1 +3022,1 @@\n-  enc_class aarch64_enc_strvD(vecD src, memory mem) %{\n+  enc_class aarch64_enc_strvD(vReg src, memory mem) %{\n@@ -3250,1 +3028,1 @@\n-  enc_class aarch64_enc_strvQ(vecX src, memory mem) %{\n+  enc_class aarch64_enc_strvQ(vReg src, memory mem) %{\n@@ -4372,40 +4150,0 @@\n-operand immI_31()\n-%{\n-  predicate(n->get_int() == 31);\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immI_2()\n-%{\n-  predicate(n->get_int() == 2);\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immI_4()\n-%{\n-  predicate(n->get_int() == 4);\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immI_8()\n-%{\n-  predicate(n->get_int() == 8);\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -5460,2 +5198,1 @@\n-\/\/ all vector operands, including NEON and SVE,\n-\/\/ but currently only used for SVE VecA.\n+\/\/ all vector operands, including NEON and SVE.\n@@ -5463,0 +5200,12 @@\n+%{\n+  constraint(ALLOC_IN_RC(dynamic));\n+  match(VecA);\n+  match(VecD);\n+  match(VecX);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vecA()\n@@ -5466,0 +5215,1 @@\n+\n@@ -6770,284 +6520,0 @@\n-pipe_class vmul64(vecD dst, vecD src1, vecD src2)\n-%{\n-  single_instruction;\n-  dst    : S5(write);\n-  src1   : S1(read);\n-  src2   : S1(read);\n-  INS01  : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class vmul128(vecX dst, vecX src1, vecX src2)\n-%{\n-  single_instruction;\n-  dst    : S5(write);\n-  src1   : S1(read);\n-  src2   : S1(read);\n-  INS0   : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class vmla64(vecD dst, vecD src1, vecD src2)\n-%{\n-  single_instruction;\n-  dst    : S5(write);\n-  src1   : S1(read);\n-  src2   : S1(read);\n-  dst    : S1(read);\n-  INS01  : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class vmla128(vecX dst, vecX src1, vecX src2)\n-%{\n-  single_instruction;\n-  dst    : S5(write);\n-  src1   : S1(read);\n-  src2   : S1(read);\n-  dst    : S1(read);\n-  INS0   : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class vdop64(vecD dst, vecD src1, vecD src2)\n-%{\n-  single_instruction;\n-  dst    : S4(write);\n-  src1   : S2(read);\n-  src2   : S2(read);\n-  INS01  : ISS;\n-  NEON_FP : S4;\n-%}\n-\n-pipe_class vdop128(vecX dst, vecX src1, vecX src2)\n-%{\n-  single_instruction;\n-  dst    : S4(write);\n-  src1   : S2(read);\n-  src2   : S2(read);\n-  INS0   : ISS;\n-  NEON_FP : S4;\n-%}\n-\n-pipe_class vlogical64(vecD dst, vecD src1, vecD src2)\n-%{\n-  single_instruction;\n-  dst    : S3(write);\n-  src1   : S2(read);\n-  src2   : S2(read);\n-  INS01  : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class vlogical128(vecX dst, vecX src1, vecX src2)\n-%{\n-  single_instruction;\n-  dst    : S3(write);\n-  src1   : S2(read);\n-  src2   : S2(read);\n-  INS0   : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class vshift64(vecD dst, vecD src, vecX shift)\n-%{\n-  single_instruction;\n-  dst    : S3(write);\n-  src    : S1(read);\n-  shift  : S1(read);\n-  INS01  : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class vshift128(vecX dst, vecX src, vecX shift)\n-%{\n-  single_instruction;\n-  dst    : S3(write);\n-  src    : S1(read);\n-  shift  : S1(read);\n-  INS0   : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class vshift64_imm(vecD dst, vecD src, immI shift)\n-%{\n-  single_instruction;\n-  dst    : S3(write);\n-  src    : S1(read);\n-  INS01  : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class vshift128_imm(vecX dst, vecX src, immI shift)\n-%{\n-  single_instruction;\n-  dst    : S3(write);\n-  src    : S1(read);\n-  INS0   : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class vdop_fp64(vecD dst, vecD src1, vecD src2)\n-%{\n-  single_instruction;\n-  dst    : S5(write);\n-  src1   : S1(read);\n-  src2   : S1(read);\n-  INS01  : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class vdop_fp128(vecX dst, vecX src1, vecX src2)\n-%{\n-  single_instruction;\n-  dst    : S5(write);\n-  src1   : S1(read);\n-  src2   : S1(read);\n-  INS0   : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class vmuldiv_fp64(vecD dst, vecD src1, vecD src2)\n-%{\n-  single_instruction;\n-  dst    : S5(write);\n-  src1   : S1(read);\n-  src2   : S1(read);\n-  INS0   : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class vmuldiv_fp128(vecX dst, vecX src1, vecX src2)\n-%{\n-  single_instruction;\n-  dst    : S5(write);\n-  src1   : S1(read);\n-  src2   : S1(read);\n-  INS0   : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class vsqrt_fp128(vecX dst, vecX src)\n-%{\n-  single_instruction;\n-  dst    : S5(write);\n-  src    : S1(read);\n-  INS0   : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class vunop_fp64(vecD dst, vecD src)\n-%{\n-  single_instruction;\n-  dst    : S5(write);\n-  src    : S1(read);\n-  INS01  : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class vunop_fp128(vecX dst, vecX src)\n-%{\n-  single_instruction;\n-  dst    : S5(write);\n-  src    : S1(read);\n-  INS0   : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class vdup_reg_reg64(vecD dst, iRegI src)\n-%{\n-  single_instruction;\n-  dst    : S3(write);\n-  src    : S1(read);\n-  INS01  : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class vdup_reg_reg128(vecX dst, iRegI src)\n-%{\n-  single_instruction;\n-  dst    : S3(write);\n-  src    : S1(read);\n-  INS01  : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class vdup_reg_freg64(vecD dst, vRegF src)\n-%{\n-  single_instruction;\n-  dst    : S3(write);\n-  src    : S1(read);\n-  INS01  : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class vdup_reg_freg128(vecX dst, vRegF src)\n-%{\n-  single_instruction;\n-  dst    : S3(write);\n-  src    : S1(read);\n-  INS01  : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class vdup_reg_dreg128(vecX dst, vRegD src)\n-%{\n-  single_instruction;\n-  dst    : S3(write);\n-  src    : S1(read);\n-  INS01  : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class vmovi_reg_imm64(vecD dst)\n-%{\n-  single_instruction;\n-  dst    : S3(write);\n-  INS01  : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class vmovi_reg_imm128(vecX dst)\n-%{\n-  single_instruction;\n-  dst    : S3(write);\n-  INS0   : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class vload_reg_mem64(vecD dst, vmem8 mem)\n-%{\n-  single_instruction;\n-  dst    : S5(write);\n-  mem    : ISS(read);\n-  INS01  : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class vload_reg_mem128(vecX dst, vmem16 mem)\n-%{\n-  single_instruction;\n-  dst    : S5(write);\n-  mem    : ISS(read);\n-  INS01  : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class vstore_reg_mem64(vecD src, vmem8 mem)\n-%{\n-  single_instruction;\n-  mem    : ISS(read);\n-  src    : S2(read);\n-  INS01  : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class vstore_reg_mem128(vecD src, vmem16 mem)\n-%{\n-  single_instruction;\n-  mem    : ISS(read);\n-  src    : S2(read);\n-  INS01  : ISS;\n-  NEON_FP : S3;\n-%}\n-\n@@ -9186,22 +8652,0 @@\n-instruct castVVD(vecD dst)\n-%{\n-  match(Set dst (CastVV dst));\n-\n-  size(0);\n-  format %{ \"# castVV of $dst\" %}\n-  ins_encode(\/* empty encoding *\/);\n-  ins_cost(0);\n-  ins_pipe(pipe_class_empty);\n-%}\n-\n-instruct castVVX(vecX dst)\n-%{\n-  match(Set dst (CastVV dst));\n-\n-  size(0);\n-  format %{ \"# castVV of $dst\" %}\n-  ins_encode(\/* empty encoding *\/);\n-  ins_cost(0);\n-  ins_pipe(pipe_class_empty);\n-%}\n-\n@@ -16957,0 +16401,2 @@\n+\/\/ Intrisics for String.compareTo()\n+\n@@ -17032,0 +16478,96 @@\n+\/\/ Note that Z registers alias the corresponding NEON registers, we declare the vector operands of\n+\/\/ these string_compare variants as NEON register type for convenience so that the prototype of\n+\/\/ string_compare can be shared with all variants.\n+\n+instruct string_compareLL_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n+                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n+                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n+                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n+%{\n+  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL));\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n+         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n+  ins_encode %{\n+    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$Register, $tmp2$$Register,\n+                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n+                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n+                      StrIntrinsicNode::LL);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n+instruct string_compareLU_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n+                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n+                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n+                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n+%{\n+  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU));\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n+         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n+  ins_encode %{\n+    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$Register, $tmp2$$Register,\n+                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n+                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n+                      StrIntrinsicNode::LU);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n+instruct string_compareUL_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n+                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n+                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n+                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n+%{\n+  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL));\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n+         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n+  ins_encode %{\n+    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$Register, $tmp2$$Register,\n+                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n+                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n+                      StrIntrinsicNode::UL);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n+instruct string_compareUU_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n+                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n+                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n+                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n+%{\n+  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU));\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n+         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n+  ins_encode %{\n+    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$Register, $tmp2$$Register,\n+                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n+                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n+                      StrIntrinsicNode::UU);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n@@ -17196,0 +16738,32 @@\n+instruct stringL_indexof_char_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegI_R3 ch,\n+                                  iRegI_R0 result, vecA ztmp1, vecA ztmp2,\n+                                  pRegGov pgtmp, pReg ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && ((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::L);\n+  match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));\n+  effect(TEMP ztmp1, TEMP ztmp2, TEMP pgtmp, TEMP ptmp, KILL cr);\n+  format %{ \"StringLatin1 IndexOf char[] $str1,$cnt1,$ch -> $result # use sve\" %}\n+  ins_encode %{\n+    __ string_indexof_char_sve($str1$$Register, $cnt1$$Register, $ch$$Register,\n+                               $result$$Register, $ztmp1$$FloatRegister,\n+                               $ztmp2$$FloatRegister, $pgtmp$$PRegister,\n+                               $ptmp$$PRegister, true \/* isL *\/);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n+instruct stringU_indexof_char_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegI_R3 ch,\n+                                  iRegI_R0 result, vecA ztmp1, vecA ztmp2,\n+                                  pRegGov pgtmp, pReg ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && ((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::U);\n+  match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));\n+  effect(TEMP ztmp1, TEMP ztmp2, TEMP pgtmp, TEMP ptmp, KILL cr);\n+  format %{ \"StringUTF16 IndexOf char[] $str1,$cnt1,$ch -> $result # use sve\" %}\n+  ins_encode %{\n+    __ string_indexof_char_sve($str1$$Register, $cnt1$$Register, $ch$$Register,\n+                               $result$$Register, $ztmp1$$FloatRegister,\n+                               $ztmp2$$FloatRegister, $pgtmp$$PRegister,\n+                               $ptmp$$PRegister, false \/* isL *\/);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":226,"deletions":652,"binary":false,"changes":878,"status":"modified"},{"patch":"@@ -1,6099 +0,0 @@\n-\/\/ Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n-\/\/ Copyright (c) 2020, 2022, Arm Limited. All rights reserved.\n-\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\/\/\n-\/\/ This code is free software; you can redistribute it and\/or modify it\n-\/\/ under the terms of the GNU General Public License version 2 only, as\n-\/\/ published by the Free Software Foundation.\n-\/\/\n-\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n-\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-\/\/ version 2 for more details (a copy is included in the LICENSE file that\n-\/\/ accompanied this code).\n-\/\/\n-\/\/ You should have received a copy of the GNU General Public License version\n-\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n-\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\/\/\n-\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-\/\/ or visit www.oracle.com if you need additional information or have any\n-\/\/ questions.\n-\/\/\n-\/\/\n-\n-\/\/ This file is automatically generated by running \"m4 aarch64_neon_ad.m4\". Do not edit ----\n-\n-\/\/ AArch64 NEON Architecture Description File\n-\n-\/\/ ====================VECTOR INSTRUCTIONS==================================\n-\n-\/\/ ------------------------------ Load\/store\/reinterpret -----------------------\n-\n-\/\/ Load Vector (16 bits)\n-instruct loadV2(vecD dst, vmem2 mem)\n-%{\n-  predicate(UseSVE == 0 && n->as_LoadVector()->memory_size() == 2);\n-  match(Set dst (LoadVector mem));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"ldrh   $dst,$mem\\t# vector (16 bits)\" %}\n-  ins_encode( aarch64_enc_ldrvH(dst, mem) );\n-  ins_pipe(vload_reg_mem64);\n-%}\n-\n-\/\/ Load Vector (32 bits)\n-instruct loadV4(vecD dst, vmem4 mem)\n-%{\n-  predicate(UseSVE == 0 && n->as_LoadVector()->memory_size() == 4);\n-  match(Set dst (LoadVector mem));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"ldrs   $dst,$mem\\t# vector (32 bits)\" %}\n-  ins_encode( aarch64_enc_ldrvS(dst, mem) );\n-  ins_pipe(vload_reg_mem64);\n-%}\n-\n-\/\/ Load Vector (64 bits)\n-instruct loadV8(vecD dst, vmem8 mem)\n-%{\n-  predicate(UseSVE == 0 && n->as_LoadVector()->memory_size() == 8);\n-  match(Set dst (LoadVector mem));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"ldrd   $dst,$mem\\t# vector (64 bits)\" %}\n-  ins_encode( aarch64_enc_ldrvD(dst, mem) );\n-  ins_pipe(vload_reg_mem64);\n-%}\n-\n-\/\/ Load Vector (128 bits)\n-instruct loadV16(vecX dst, vmem16 mem)\n-%{\n-  predicate(UseSVE == 0 && n->as_LoadVector()->memory_size() == 16);\n-  match(Set dst (LoadVector mem));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"ldrq   $dst,$mem\\t# vector (128 bits)\" %}\n-  ins_encode( aarch64_enc_ldrvQ(dst, mem) );\n-  ins_pipe(vload_reg_mem128);\n-%}\n-\n-\/\/ Store Vector (16 bits)\n-instruct storeV2(vecD src, vmem2 mem)\n-%{\n-  predicate(n->as_StoreVector()->memory_size() == 2);\n-  match(Set mem (StoreVector mem src));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"strh   $mem,$src\\t# vector (16 bits)\" %}\n-  ins_encode( aarch64_enc_strvH(src, mem) );\n-  ins_pipe(vstore_reg_mem64);\n-%}\n-\n-\/\/ Store Vector (32 bits)\n-instruct storeV4(vecD src, vmem4 mem)\n-%{\n-  predicate(n->as_StoreVector()->memory_size() == 4);\n-  match(Set mem (StoreVector mem src));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"strs   $mem,$src\\t# vector (32 bits)\" %}\n-  ins_encode( aarch64_enc_strvS(src, mem) );\n-  ins_pipe(vstore_reg_mem64);\n-%}\n-\n-\/\/ Store Vector (64 bits)\n-instruct storeV8(vecD src, vmem8 mem)\n-%{\n-  predicate(n->as_StoreVector()->memory_size() == 8);\n-  match(Set mem (StoreVector mem src));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"strd   $mem,$src\\t# vector (64 bits)\" %}\n-  ins_encode( aarch64_enc_strvD(src, mem) );\n-  ins_pipe(vstore_reg_mem64);\n-%}\n-\n-\/\/ Store Vector (128 bits)\n-instruct storeV16(vecX src, vmem16 mem)\n-%{\n-  predicate(n->as_StoreVector()->memory_size() == 16);\n-  match(Set mem (StoreVector mem src));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"strq   $mem,$src\\t# vector (128 bits)\" %}\n-  ins_encode( aarch64_enc_strvQ(src, mem) );\n-  ins_pipe(vstore_reg_mem128);\n-%}\n-\n-instruct reinterpretD(vecD dst)\n-%{\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 8 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 8);\n-  match(Set dst (VectorReinterpret dst));\n-  ins_cost(0);\n-  format %{ \" # reinterpret $dst\" %}\n-  ins_encode %{\n-    \/\/ empty\n-  %}\n-  ins_pipe(pipe_class_empty);\n-%}\n-\n-instruct reinterpretX(vecX dst)\n-%{\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 16 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 16);\n-  match(Set dst (VectorReinterpret dst));\n-  ins_cost(0);\n-  format %{ \" # reinterpret $dst\" %}\n-  ins_encode %{\n-    \/\/ empty\n-  %}\n-  ins_pipe(pipe_class_empty);\n-%}\n-\n-instruct reinterpretD2X(vecX dst, vecD src)\n-%{\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 16 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 8);\n-  match(Set dst (VectorReinterpret src));\n-  ins_cost(INSN_COST);\n-  format %{ \" # reinterpret $dst,$src\\t# D to X\" %}\n-  ins_encode %{\n-    \/\/ The higher 64-bits of the \"dst\" register must be cleared to zero.\n-    __ orr(as_FloatRegister($dst$$reg), __ T8B,\n-           as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vlogical64);\n-%}\n-\n-instruct reinterpretX2D(vecD dst, vecX src)\n-%{\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 8 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 16);\n-  match(Set dst (VectorReinterpret src));\n-  ins_cost(INSN_COST);\n-  format %{ \" # reinterpret $dst,$src\\t# X to D\" %}\n-  ins_encode %{\n-    \/\/ The higher 64-bits of the \"dst\" register must be cleared to zero.\n-    __ orr(as_FloatRegister($dst$$reg), __ T8B,\n-           as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vlogical64);\n-%}\n-\n-instruct reinterpretS2X(vecX dst, vecD src)\n-%{\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 16 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 4);\n-  match(Set dst (VectorReinterpret src));\n-  ins_cost(INSN_COST);\n-  format %{ \" # reinterpret $dst,$src\\t# S to X\" %}\n-  ins_encode %{\n-    \/\/ The higher bits of the \"dst\" register must be cleared to zero.\n-    __ dup(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reinterpretX2S(vecD dst, vecX src)\n-%{\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 4 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 16);\n-  match(Set dst (VectorReinterpret src));\n-  ins_cost(INSN_COST);\n-  format %{ \" # reinterpret $dst,$src\\t# X to S\" %}\n-  ins_encode %{\n-    \/\/ The higher bits of the \"dst\" register must be cleared to zero.\n-    __ dup(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reinterpretS2D(vecD dst, vecD src)\n-%{\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 8 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 4);\n-  match(Set dst (VectorReinterpret src));\n-  ins_cost(INSN_COST);\n-  format %{ \" # reinterpret $dst,$src\\t# S to D\" %}\n-  ins_encode %{\n-    \/\/ The higher bits of the \"dst\" register must be cleared to zero.\n-    __ dup(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reinterpretD2S(vecD dst, vecD src)\n-%{\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 4 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 8);\n-  match(Set dst (VectorReinterpret src));\n-  ins_cost(INSN_COST);\n-  format %{ \" # reinterpret $dst,$src\\t# D to S\" %}\n-  ins_encode %{\n-    \/\/ The higher bits of the \"dst\" register must be cleared to zero.\n-    __ dup(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector cast -------------------------------\n-\n-instruct vcvt8Bto8S(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 8 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorCastB2X src));\n-  format %{ \"sxtl  $dst, T8H, $src, T8B\\t# convert 8B to 8S vector\" %}\n-  ins_encode %{\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vcvt4Bto4S(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorCastB2X src));\n-  format %{ \"sxtl  $dst, T8H, $src, T8B\\t# convert 4B to 4S vector\" %}\n-  ins_encode %{\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vcvt8Sto8B(vecD dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 8 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorCastS2X src));\n-  format %{ \"xtn  $dst, T8B, $src, T8H\\t# convert 8S to 8B vector\" %}\n-  ins_encode %{\n-    __ xtn(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($src$$reg), __ T8H);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vcvt4Sto4B(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorCastS2X src));\n-  format %{ \"xtn  $dst, T8B, $src, T8H\\t# convert 4S to 4B vector\" %}\n-  ins_encode %{\n-    __ xtn(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($src$$reg), __ T8H);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vcvt4Sto4I(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (VectorCastS2X src));\n-  format %{ \"sxtl  $dst, T4S, $src, T4H\\t# convert 4S to 4I vector\" %}\n-  ins_encode %{\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src$$reg), __ T4H);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vcvt4Ito4S(vecD dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorCastI2X src));\n-  format %{ \"xtn  $dst, T4H, $src, T4S\\t# convert 4I to 4S vector\" %}\n-  ins_encode %{\n-    __ xtn(as_FloatRegister($dst$$reg), __ T4H, as_FloatRegister($src$$reg), __ T4S);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vcvt2Ito2L(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorCastI2X src));\n-  format %{ \"sxtl  $dst, T2D, $src, T2S\\t# convert 2I to 2L vector\" %}\n-  ins_encode %{\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($src$$reg), __ T2S);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vcvt2Lto2I(vecD dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (VectorCastL2X src));\n-  format %{ \"xtn  $dst, T2S, $src, T2D\\t# convert 2L to 2I vector\" %}\n-  ins_encode %{\n-    __ xtn(as_FloatRegister($dst$$reg), __ T2S, as_FloatRegister($src$$reg), __ T2D);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vcvt4Ito4B(vecD dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorCastI2X src));\n-  format %{ \"xtn  $dst, T4H, $src, T4S\\n\\t\"\n-            \"xtn  $dst, T8B, $dst, T8H\\t# convert 4I to 4B vector\"\n-  %}\n-  ins_encode %{\n-    __ xtn(as_FloatRegister($dst$$reg), __ T4H, as_FloatRegister($src$$reg), __ T4S);\n-    __ xtn(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($dst$$reg), __ T8H);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vcvt4Bto4I(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (VectorCastB2X src));\n-  format %{ \"sxtl  $dst, T8H, $src, T8B\\n\\t\"\n-            \"sxtl  $dst, T4S, $dst, T4H\\t# convert 4B to 4I vector\"\n-  %}\n-  ins_encode %{\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($dst$$reg), __ T4H);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vcvt2Lto2F(vecD dst, vecX src, vRegF tmp)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorCastL2X src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   rscratch1, $src, D, 0\\n\\t\"\n-            \"scvtfs $dst, rscratch1\\n\\t\"\n-            \"umov   rscratch1, $src, D, 1\\n\\t\"\n-            \"scvtfs $tmp, rscratch1\\n\\t\"\n-            \"ins    $dst, S, $tmp, 1, 0\\t# convert 2L to 2F vector\"\n-  %}\n-  ins_encode %{\n-    __ umov(rscratch1, as_FloatRegister($src$$reg), __ D, 0);\n-    __ scvtfs(as_FloatRegister($dst$$reg), rscratch1);\n-    __ umov(rscratch1, as_FloatRegister($src$$reg), __ D, 1);\n-    __ scvtfs(as_FloatRegister($tmp$$reg), rscratch1);\n-    __ ins(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($tmp$$reg), 1, 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvt2Ito2F(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorCastI2X src));\n-  format %{ \"scvtfv  T2S, $dst, $src\\t# convert 2I to 2F vector\" %}\n-  ins_encode %{\n-    __ scvtfv(__ T2S, as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vcvt4Ito4F(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorCastI2X src));\n-  format %{ \"scvtfv  T4S, $dst, $src\\t# convert 4I to 4F vector\" %}\n-  ins_encode %{\n-    __ scvtfv(__ T4S, as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vcvt2Lto2D(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorCastL2X src));\n-  format %{ \"scvtfv  T2D, $dst, $src\\t# convert 2L to 2D vector\" %}\n-  ins_encode %{\n-    __ scvtfv(__ T2D, as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vcvt4Sto4F(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorCastS2X src));\n-  format %{ \"sxtl    $dst, T4S, $src, T4H\\n\\t\"\n-            \"scvtfv  T4S, $dst, $dst\\t# convert 4S to 4F vector\"\n-  %}\n-  ins_encode %{\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src$$reg), __ T4H);\n-    __ scvtfv(__ T4S, as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvt2Ito2D(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorCastI2X src));\n-  format %{ \"sxtl    $dst, T2D, $src, T2S\\n\\t\"\n-            \"scvtfv  T2D, $dst, $dst\\t# convert 2I to 2D vector\"\n-  %}\n-  ins_encode %{\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($src$$reg), __ T2S);\n-    __ scvtfv(__ T2D, as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvt4Bto4F(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorCastB2X src));\n-  format %{ \"sxtl    $dst, T8H, $src, T8B\\n\\t\"\n-            \"sxtl    $dst, T4S, $dst, T4H\\n\\t\"\n-            \"scvtfv  T4S, $dst, $dst\\t# convert 4B to 4F vector\"\n-  %}\n-  ins_encode %{\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($dst$$reg), __ T4H);\n-    __ scvtfv(__ T4S, as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvt2Fto2L(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorCastF2X src));\n-  format %{ \"fcvtl   $dst, T2D, $src, T2S\\n\\t\"\n-            \"fcvtzs  $dst, T2D, $dst\\t# convert 2F to 2L vector\"\n-  %}\n-  ins_encode %{\n-    __ fcvtl(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($src$$reg), __ T2S);\n-    __ fcvtzs(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvt2Fto2I(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (VectorCastF2X src));\n-  format %{ \"fcvtzs  $dst, T2S, $src\\t# convert 2F to 2I vector\" %}\n-  ins_encode %{\n-    __ fcvtzs(as_FloatRegister($dst$$reg), __ T2S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vcvt4Fto4I(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (VectorCastF2X src));\n-  format %{ \"fcvtzs  $dst, T4S, $src\\t# convert 4F to 4I vector\" %}\n-  ins_encode %{\n-    __ fcvtzs(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vcvt2Dto2L(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorCastD2X src));\n-  format %{ \"fcvtzs  $dst, T2D, $src\\t# convert 2D to 2L vector\" %}\n-  ins_encode %{\n-    __ fcvtzs(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vcvt4Fto4S(vecD dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorCastF2X src));\n-  format %{ \"fcvtzs  $dst, T4S, $src\\n\\t\"\n-            \"xtn     $dst, T4H, $dst, T4S\\t# convert 4F to 4S vector\"\n-  %}\n-  ins_encode %{\n-    __ fcvtzs(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src$$reg));\n-    __ xtn(as_FloatRegister($dst$$reg), __ T4H, as_FloatRegister($dst$$reg), __ T4S);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvt2Dto2I(vecD dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (VectorCastD2X src));\n-  effect(TEMP_DEF dst);\n-  format %{ \"ins      $dst, D, $src, 0, 1\\n\\t\"\n-            \"fcvtzdw  rscratch1, $src\\n\\t\"\n-            \"fcvtzdw  rscratch2, $dst\\n\\t\"\n-            \"fmovs    $dst, rscratch1\\n\\t\"\n-            \"mov      $dst, S, 1, rscratch2\\t#convert 2D to 2I vector\"\n-  %}\n-  ins_encode %{\n-    __ ins(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg), 0, 1);\n-    \/\/ We can't use fcvtzs(vector, integer) instruction here because we need\n-    \/\/ saturation arithmetic. See JDK-8276151.\n-    __ fcvtzdw(rscratch1, as_FloatRegister($src$$reg));\n-    __ fcvtzdw(rscratch2, as_FloatRegister($dst$$reg));\n-    __ fmovs(as_FloatRegister($dst$$reg), rscratch1);\n-    __ mov(as_FloatRegister($dst$$reg), __ S, 1, rscratch2);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvt4Fto4B(vecD dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorCastF2X src));\n-  format %{ \"fcvtzs  $dst, T4S, $src\\n\\t\"\n-            \"xtn     $dst, T4H, $dst, T4S\\n\\t\"\n-            \"xtn     $dst, T8B, $dst, T8H\\t# convert 4F to 4B vector\"\n-  %}\n-  ins_encode %{\n-    __ fcvtzs(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src$$reg));\n-    __ xtn(as_FloatRegister($dst$$reg), __ T4H, as_FloatRegister($dst$$reg), __ T4S);\n-    __ xtn(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($dst$$reg), __ T8H);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvt2Fto2D(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorCastF2X src));\n-  format %{ \"fcvtl  $dst, T2D, $src, T2S\\t# convert 2F to 2D vector\" %}\n-  ins_encode %{\n-    __ fcvtl(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($src$$reg), __ T2S);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vcvt2Dto2F(vecD dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorCastD2X src));\n-  format %{ \"fcvtn  $dst, T2S, $src, T2D\\t# convert 2D to 2F vector\" %}\n-  ins_encode %{\n-    __ fcvtn(as_FloatRegister($dst$$reg), __ T2S, as_FloatRegister($src$$reg), __ T2D);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-\n-instruct vroundvecD2Fto2I(vecD dst, vecD src, vecD tmp1, vecD tmp2, vecD tmp3)\n-%{\n-  predicate(UseSVE == 0 &&\n-            n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (RoundVF src));\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n-  format %{ \"vround  $dst, T2S, $src\\t# round vecD 2F to 2I vector\" %}\n-  ins_encode %{\n-    __ vector_round_neon(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-                         as_FloatRegister($tmp1$$reg), as_FloatRegister($tmp2$$reg),\n-                         as_FloatRegister($tmp3$$reg), __ T2S);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vroundvecX4Fto4I(vecX dst, vecX src, vecX tmp1, vecX tmp2, vecX tmp3)\n-%{\n-  predicate(UseSVE == 0 &&\n-            n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (RoundVF src));\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n-  format %{ \"vround  $dst, T4S, $src\\t# round vecX 4F to 4I vector\" %}\n-  ins_encode %{\n-    __ vector_round_neon(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-                         as_FloatRegister($tmp1$$reg), as_FloatRegister($tmp2$$reg),\n-                         as_FloatRegister($tmp3$$reg), __ T4S);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vroundvecX2Dto2L(vecX dst, vecX src, vecX tmp1, vecX tmp2, vecX tmp3)\n-%{\n-  predicate(UseSVE == 0 &&\n-            n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (RoundVD src));\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n-  format %{ \"vround  $dst, T2D, $src\\t# round vecX 2D to 2L vector\" %}\n-  ins_encode %{\n-    __ vector_round_neon(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-                         as_FloatRegister($tmp1$$reg), as_FloatRegister($tmp2$$reg),\n-                         as_FloatRegister($tmp3$$reg), __ T2D);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-\/\/ ------------------------------ Reduction -------------------------------\n-\n-instruct reduce_add8B(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (AddReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"addv  $tmp, T8B, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, B, 0\\n\\t\"\n-            \"addw  $dst, $dst, $isrc\\n\\t\"\n-            \"sxtb  $dst, $dst\\t# add reduction8B\"\n-  %}\n-  ins_encode %{\n-    __ addv(as_FloatRegister($tmp$$reg), __ T8B, as_FloatRegister($vsrc$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ addw($dst$$Register, $dst$$Register, $isrc$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_add16B(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (AddReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"addv  $tmp, T16B, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, B, 0\\n\\t\"\n-            \"addw  $dst, $dst, $isrc\\n\\t\"\n-            \"sxtb  $dst, $dst\\t# add reduction16B\"\n-  %}\n-  ins_encode %{\n-    __ addv(as_FloatRegister($tmp$$reg), __ T16B, as_FloatRegister($vsrc$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ addw($dst$$Register, $dst$$Register, $isrc$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_add4S(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (AddReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"addv  $tmp, T4H, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, H, 0\\n\\t\"\n-            \"addw  $dst, $dst, $isrc\\n\\t\"\n-            \"sxth  $dst, $dst\\t# add reduction4S\"\n-  %}\n-  ins_encode %{\n-    __ addv(as_FloatRegister($tmp$$reg), __ T4H, as_FloatRegister($vsrc$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ addw($dst$$Register, $dst$$Register, $isrc$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_add8S(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (AddReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"addv  $tmp, T8H, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, H, 0\\n\\t\"\n-            \"addw  $dst, $dst, $isrc\\n\\t\"\n-            \"sxth  $dst, $dst\\t# add reduction8S\"\n-  %}\n-  ins_encode %{\n-    __ addv(as_FloatRegister($tmp$$reg), __ T8H, as_FloatRegister($vsrc$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ addw($dst$$Register, $dst$$Register, $isrc$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_add2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, vecX tmp)\n-%{\n-  match(Set dst (AddReductionVL isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"addpd $tmp, $vsrc\\n\\t\"\n-            \"umov  $dst, $tmp, D, 0\\n\\t\"\n-            \"add   $dst, $isrc, $dst\\t# add reduction2L\"\n-  %}\n-  ins_encode %{\n-    __ addpd(as_FloatRegister($tmp$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ D, 0);\n-    __ add($dst$$Register, $isrc$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_mul8B(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD vtmp1, vecD vtmp2, iRegINoSp itmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (MulReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP itmp);\n-  format %{ \"ins   $vtmp1, S, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp1, T8B, $vtmp1, $vsrc\\n\\t\"\n-            \"ins   $vtmp2, H, $vtmp1, 0, 1\\n\\t\"\n-            \"mulv  $vtmp2, T8B, $vtmp2, $vtmp1\\n\\t\"\n-            \"umov  $itmp, $vtmp2, B, 0\\n\\t\"\n-            \"mulw  $dst, $itmp, $isrc\\n\\t\"\n-            \"sxtb  $dst, $dst\\n\\t\"\n-            \"umov  $itmp, $vtmp2, B, 1\\n\\t\"\n-            \"mulw  $dst, $itmp, $dst\\n\\t\"\n-            \"sxtb  $dst, $dst\\t# mul reduction8B\"\n-  %}\n-  ins_encode %{\n-    __ ins(as_FloatRegister($vtmp1$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp1$$reg), __ T8B,\n-            as_FloatRegister($vtmp1$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($vtmp2$$reg), __ H,\n-           as_FloatRegister($vtmp1$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp2$$reg), __ T8B,\n-            as_FloatRegister($vtmp2$$reg), as_FloatRegister($vtmp1$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ B, 0);\n-    __ mulw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ B, 1);\n-    __ mulw($dst$$Register, $itmp$$Register, $dst$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_mul16B(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp1, vecX vtmp2, iRegINoSp itmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (MulReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP itmp);\n-  format %{ \"ins   $vtmp1, D, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp1, T8B, $vtmp1, $vsrc\\n\\t\"\n-            \"ins   $vtmp2, S, $vtmp1, 0, 1\\n\\t\"\n-            \"mulv  $vtmp1, T8B, $vtmp2, $vtmp1\\n\\t\"\n-            \"ins   $vtmp2, H, $vtmp1, 0, 1\\n\\t\"\n-            \"mulv  $vtmp2, T8B, $vtmp2, $vtmp1\\n\\t\"\n-            \"umov  $itmp, $vtmp2, B, 0\\n\\t\"\n-            \"mulw  $dst, $itmp, $isrc\\n\\t\"\n-            \"sxtb  $dst, $dst\\n\\t\"\n-            \"umov  $itmp, $vtmp2, B, 1\\n\\t\"\n-            \"mulw  $dst, $itmp, $dst\\n\\t\"\n-            \"sxtb  $dst, $dst\\t# mul reduction16B\"\n-  %}\n-  ins_encode %{\n-    __ ins(as_FloatRegister($vtmp1$$reg), __ D,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp1$$reg), __ T8B,\n-            as_FloatRegister($vtmp1$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($vtmp2$$reg), __ S,\n-           as_FloatRegister($vtmp1$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp1$$reg), __ T8B,\n-            as_FloatRegister($vtmp2$$reg), as_FloatRegister($vtmp1$$reg));\n-    __ ins(as_FloatRegister($vtmp2$$reg), __ H,\n-           as_FloatRegister($vtmp1$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp2$$reg), __ T8B,\n-            as_FloatRegister($vtmp2$$reg), as_FloatRegister($vtmp1$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ B, 0);\n-    __ mulw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ B, 1);\n-    __ mulw($dst$$Register, $itmp$$Register, $dst$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_mul4S(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD vtmp, iRegINoSp itmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (MulReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP vtmp, TEMP itmp);\n-  format %{ \"ins   $vtmp, S, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp, T4H, $vtmp, $vsrc\\n\\t\"\n-            \"umov  $itmp, $vtmp, H, 0\\n\\t\"\n-            \"mulw  $dst, $itmp, $isrc\\n\\t\"\n-            \"sxth  $dst, $dst\\n\\t\"\n-            \"umov  $itmp, $vtmp, H, 1\\n\\t\"\n-            \"mulw  $dst, $itmp, $dst\\n\\t\"\n-            \"sxth  $dst, $dst\\t# mul reduction4S\"\n-  %}\n-  ins_encode %{\n-    __ ins(as_FloatRegister($vtmp$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp$$reg), __ T4H,\n-            as_FloatRegister($vtmp$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ H, 0);\n-    __ mulw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ H, 1);\n-    __ mulw($dst$$Register, $itmp$$Register, $dst$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_mul8S(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp1, vecX vtmp2, iRegINoSp itmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (MulReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP itmp);\n-  format %{ \"ins   $vtmp1, D, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp1, T4H, $vtmp1, $vsrc\\n\\t\"\n-            \"ins   $vtmp2, S, $vtmp1, 0, 1\\n\\t\"\n-            \"mulv  $vtmp2, T4H, $vtmp2, $vtmp1\\n\\t\"\n-            \"umov  $itmp, $vtmp2, H, 0\\n\\t\"\n-            \"mulw  $dst, $itmp, $isrc\\n\\t\"\n-            \"sxth  $dst, $dst\\n\\t\"\n-            \"umov  $itmp, $vtmp2, H, 1\\n\\t\"\n-            \"mulw  $dst, $itmp, $dst\\n\\t\"\n-            \"sxth  $dst, $dst\\t# mul reduction8S\"\n-  %}\n-  ins_encode %{\n-    __ ins(as_FloatRegister($vtmp1$$reg), __ D,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp1$$reg), __ T4H,\n-            as_FloatRegister($vtmp1$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($vtmp2$$reg), __ S,\n-           as_FloatRegister($vtmp1$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp2$$reg), __ T4H,\n-            as_FloatRegister($vtmp2$$reg), as_FloatRegister($vtmp1$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ H, 0);\n-    __ mulw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ H, 1);\n-    __ mulw($dst$$Register, $itmp$$Register, $dst$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_mul2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, iRegLNoSp tmp)\n-%{\n-  match(Set dst (MulReductionVL isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov  $tmp, $vsrc, D, 0\\n\\t\"\n-            \"mul   $dst, $isrc, $tmp\\n\\t\"\n-            \"umov  $tmp, $vsrc, D, 1\\n\\t\"\n-            \"mul   $dst, $dst, $tmp\\t# mul reduction2L\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ mul($dst$$Register, $isrc$$Register, $tmp$$Register);\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ mul($dst$$Register, $dst$$Register, $tmp$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_max8B(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (MaxReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"smaxv $tmp, T8B, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, B, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc GT\\t# max reduction8B\"\n-  %}\n-  ins_encode %{\n-    __ smaxv(as_FloatRegister($tmp$$reg), __ T8B, as_FloatRegister($vsrc$$reg));\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::GT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_max16B(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (MaxReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"smaxv $tmp, T16B, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, B, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc GT\\t# max reduction16B\"\n-  %}\n-  ins_encode %{\n-    __ smaxv(as_FloatRegister($tmp$$reg), __ T16B, as_FloatRegister($vsrc$$reg));\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::GT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_max4S(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (MaxReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"smaxv $tmp, T4H, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, H, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc GT\\t# max reduction4S\"\n-  %}\n-  ins_encode %{\n-    __ smaxv(as_FloatRegister($tmp$$reg), __ T4H, as_FloatRegister($vsrc$$reg));\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::GT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_max8S(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (MaxReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"smaxv $tmp, T8H, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, H, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc GT\\t# max reduction8S\"\n-  %}\n-  ins_encode %{\n-    __ smaxv(as_FloatRegister($tmp$$reg), __ T8H, as_FloatRegister($vsrc$$reg));\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::GT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_max4I(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (MaxReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"smaxv $tmp, T4S, $vsrc\\n\\t\"\n-            \"umov  $dst, $tmp, S, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc GT\\t# max reduction4I\"\n-  %}\n-  ins_encode %{\n-    __ smaxv(as_FloatRegister($tmp$$reg), __ T4S, as_FloatRegister($vsrc$$reg));\n-    __ umov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ S, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::GT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_min8B(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (MinReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"sminv $tmp, T8B, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, B, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc LT\\t# min reduction8B\"\n-  %}\n-  ins_encode %{\n-    __ sminv(as_FloatRegister($tmp$$reg), __ T8B, as_FloatRegister($vsrc$$reg));\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::LT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_min16B(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (MinReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"sminv $tmp, T16B, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, B, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc LT\\t# min reduction16B\"\n-  %}\n-  ins_encode %{\n-    __ sminv(as_FloatRegister($tmp$$reg), __ T16B, as_FloatRegister($vsrc$$reg));\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::LT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_min4S(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (MinReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"sminv $tmp, T4H, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, H, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc LT\\t# min reduction4S\"\n-  %}\n-  ins_encode %{\n-    __ sminv(as_FloatRegister($tmp$$reg), __ T4H, as_FloatRegister($vsrc$$reg));\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::LT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_min8S(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (MinReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"sminv $tmp, T8H, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, H, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc LT\\t# min reduction8S\"\n-  %}\n-  ins_encode %{\n-    __ sminv(as_FloatRegister($tmp$$reg), __ T8H, as_FloatRegister($vsrc$$reg));\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::LT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_min4I(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (MinReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"sminv $tmp, T4S, $vsrc\\n\\t\"\n-            \"umov  $dst, $tmp, S, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc LT\\t# min reduction4I\"\n-  %}\n-  ins_encode %{\n-    __ sminv(as_FloatRegister($tmp$$reg), __ T4S, as_FloatRegister($vsrc$$reg));\n-    __ umov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ S, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::LT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_max2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (MaxReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"smaxp $tmp, T2S, $vsrc, $vsrc\\n\\t\"\n-            \"umov  $dst, $tmp, S, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc GT\\t# max reduction2I\"\n-  %}\n-  ins_encode %{\n-    __ smaxp(as_FloatRegister($tmp$$reg), __ T2S, as_FloatRegister($vsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ S, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::GT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_min2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (MinReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"sminp $tmp, T2S, $vsrc, $vsrc\\n\\t\"\n-            \"umov  $dst, $tmp, S, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc LT\\t# min reduction2I\"\n-  %}\n-  ins_encode %{\n-    __ sminp(as_FloatRegister($tmp$$reg), __ T2S, as_FloatRegister($vsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ S, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::LT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_max2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, iRegLNoSp tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (MaxReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"umov  $tmp, $vsrc, D, 0\\n\\t\"\n-            \"cmp   $isrc,$tmp\\n\\t\"\n-            \"csel  $dst, $isrc, $tmp GT\\n\\t\"\n-            \"umov  $tmp, $vsrc, D, 1\\n\\t\"\n-            \"cmp   $dst, $tmp\\n\\t\"\n-            \"csel  $dst, $dst, $tmp GT\\t# max reduction2L\"\n-  %}\n-  ins_encode %{\n-    __ umov(as_Register($tmp$$reg), as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ cmp(as_Register($isrc$$reg), as_Register($tmp$$reg));\n-    __ csel(as_Register($dst$$reg), as_Register($isrc$$reg), as_Register($tmp$$reg), Assembler::GT);\n-    __ umov(as_Register($tmp$$reg), as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ cmp(as_Register($dst$$reg), as_Register($tmp$$reg));\n-    __ csel(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($tmp$$reg), Assembler::GT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_min2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, iRegLNoSp tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (MinReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"umov  $tmp, $vsrc, D, 0\\n\\t\"\n-            \"cmp   $isrc,$tmp\\n\\t\"\n-            \"csel  $dst, $isrc, $tmp LT\\n\\t\"\n-            \"umov  $tmp, $vsrc, D, 1\\n\\t\"\n-            \"cmp   $dst, $tmp\\n\\t\"\n-            \"csel  $dst, $dst, $tmp LT\\t# min reduction2L\"\n-  %}\n-  ins_encode %{\n-    __ umov(as_Register($tmp$$reg), as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ cmp(as_Register($isrc$$reg), as_Register($tmp$$reg));\n-    __ csel(as_Register($dst$$reg), as_Register($isrc$$reg), as_Register($tmp$$reg), Assembler::LT);\n-    __ umov(as_Register($tmp$$reg), as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ cmp(as_Register($dst$$reg), as_Register($tmp$$reg));\n-    __ csel(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($tmp$$reg), Assembler::LT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_max2F(vRegF dst, vRegF fsrc, vecD vsrc) %{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (MaxReductionV fsrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"fmaxp $dst, $vsrc, S\\n\\t\"\n-            \"fmaxs $dst, $dst, $fsrc\\t# max reduction2F\" %}\n-  ins_encode %{\n-    __ fmaxp(as_FloatRegister($dst$$reg), as_FloatRegister($vsrc$$reg), __ S);\n-    __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($fsrc$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_max4F(vRegF dst, vRegF fsrc, vecX vsrc) %{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (MaxReductionV fsrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"fmaxv $dst,  T4S, $vsrc\\n\\t\"\n-            \"fmaxs $dst, $dst, $fsrc\\t# max reduction4F\" %}\n-  ins_encode %{\n-    __ fmaxv(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($vsrc$$reg));\n-    __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($fsrc$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_max2D(vRegD dst, vRegD dsrc, vecX vsrc) %{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (MaxReductionV dsrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"fmaxp $dst, $vsrc, D\\n\\t\"\n-            \"fmaxd $dst, $dst, $dsrc\\t# max reduction2D\" %}\n-  ins_encode %{\n-    __ fmaxp(as_FloatRegister($dst$$reg), as_FloatRegister($vsrc$$reg), __ D);\n-    __ fmaxd(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($dsrc$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_min2F(vRegF dst, vRegF fsrc, vecD vsrc) %{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (MinReductionV fsrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"fminp $dst, $vsrc, S\\n\\t\"\n-            \"fmins $dst, $dst, $fsrc\\t# min reduction2F\" %}\n-  ins_encode %{\n-    __ fminp(as_FloatRegister($dst$$reg), as_FloatRegister($vsrc$$reg), __ S);\n-    __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($fsrc$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_min4F(vRegF dst, vRegF fsrc, vecX vsrc) %{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (MinReductionV fsrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"fminv $dst,  T4S, $vsrc\\n\\t\"\n-            \"fmins $dst, $dst, $fsrc\\t# min reduction4F\" %}\n-  ins_encode %{\n-    __ fminv(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($vsrc$$reg));\n-    __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($fsrc$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_min2D(vRegD dst, vRegD dsrc, vecX vsrc) %{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (MinReductionV dsrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"fminp $dst, $vsrc, D\\n\\t\"\n-            \"fmind $dst, $dst, $dsrc\\t# min reduction2D\" %}\n-  ins_encode %{\n-    __ fminp(as_FloatRegister($dst$$reg), as_FloatRegister($vsrc$$reg), __ D);\n-    __ fmind(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($dsrc$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_and8B(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (AndReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, S, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, S, 1\\n\\t\"\n-            \"andw   $dst, $dst, $tmp\\n\\t\"\n-            \"andw   $dst, $dst, $dst, LSR #16\\n\\t\"\n-            \"andw   $dst, $dst, $dst, LSR #8\\n\\t\"\n-            \"andw   $dst, $isrc, $dst\\n\\t\"\n-            \"sxtb   $dst, $dst\\t# and reduction8B\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);\n-    __ andw($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ andw($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 16);\n-    __ andw($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 8);\n-    __ andw($dst$$Register, $isrc$$Register, $dst$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_orr8B(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (OrReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, S, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, S, 1\\n\\t\"\n-            \"orrw   $dst, $dst, $tmp\\n\\t\"\n-            \"orrw   $dst, $dst, $dst, LSR #16\\n\\t\"\n-            \"orrw   $dst, $dst, $dst, LSR #8\\n\\t\"\n-            \"orrw   $dst, $isrc, $dst\\n\\t\"\n-            \"sxtb   $dst, $dst\\t# orr reduction8B\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);\n-    __ orrw($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ orrw($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 16);\n-    __ orrw($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 8);\n-    __ orrw($dst$$Register, $isrc$$Register, $dst$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_eor8B(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (XorReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, S, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, S, 1\\n\\t\"\n-            \"eorw   $dst, $dst, $tmp\\n\\t\"\n-            \"eorw   $dst, $dst, $dst, LSR #16\\n\\t\"\n-            \"eorw   $dst, $dst, $dst, LSR #8\\n\\t\"\n-            \"eorw   $dst, $isrc, $dst\\n\\t\"\n-            \"sxtb   $dst, $dst\\t# eor reduction8B\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);\n-    __ eorw($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ eorw($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 16);\n-    __ eorw($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 8);\n-    __ eorw($dst$$Register, $isrc$$Register, $dst$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_and16B(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (AndReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, D, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, D, 1\\n\\t\"\n-            \"andr   $dst, $dst, $tmp\\n\\t\"\n-            \"andr   $dst, $dst, $dst, LSR #32\\n\\t\"\n-            \"andw   $dst, $dst, $dst, LSR #16\\n\\t\"\n-            \"andw   $dst, $dst, $dst, LSR #8\\n\\t\"\n-            \"andw   $dst, $isrc, $dst\\n\\t\"\n-            \"sxtb   $dst, $dst\\t# and reduction16B\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ andr($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ andr($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 32);\n-    __ andw($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 16);\n-    __ andw($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 8);\n-    __ andw($dst$$Register, $isrc$$Register, $dst$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_orr16B(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (OrReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, D, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, D, 1\\n\\t\"\n-            \"orr    $dst, $dst, $tmp\\n\\t\"\n-            \"orr    $dst, $dst, $dst, LSR #32\\n\\t\"\n-            \"orrw   $dst, $dst, $dst, LSR #16\\n\\t\"\n-            \"orrw   $dst, $dst, $dst, LSR #8\\n\\t\"\n-            \"orrw   $dst, $isrc, $dst\\n\\t\"\n-            \"sxtb   $dst, $dst\\t# orr reduction16B\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ orr ($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ orr ($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 32);\n-    __ orrw($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 16);\n-    __ orrw($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 8);\n-    __ orrw($dst$$Register, $isrc$$Register, $dst$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_eor16B(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (XorReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, D, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, D, 1\\n\\t\"\n-            \"eor    $dst, $dst, $tmp\\n\\t\"\n-            \"eor    $dst, $dst, $dst, LSR #32\\n\\t\"\n-            \"eorw   $dst, $dst, $dst, LSR #16\\n\\t\"\n-            \"eorw   $dst, $dst, $dst, LSR #8\\n\\t\"\n-            \"eorw   $dst, $isrc, $dst\\n\\t\"\n-            \"sxtb   $dst, $dst\\t# eor reduction16B\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ eor ($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ eor ($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 32);\n-    __ eorw($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 16);\n-    __ eorw($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 8);\n-    __ eorw($dst$$Register, $isrc$$Register, $dst$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_and4S(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (AndReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, S, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, S, 1\\n\\t\"\n-            \"andw   $dst, $dst, $tmp\\n\\t\"\n-            \"andw   $dst, $dst, $dst, LSR #16\\n\\t\"\n-            \"andw   $dst, $isrc, $dst\\n\\t\"\n-            \"sxth   $dst, $dst\\t# and reduction4S\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);\n-    __ andw($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ andw($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 16);\n-    __ andw($dst$$Register, $isrc$$Register, $dst$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_orr4S(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (OrReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, S, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, S, 1\\n\\t\"\n-            \"orrw   $dst, $dst, $tmp\\n\\t\"\n-            \"orrw   $dst, $dst, $dst, LSR #16\\n\\t\"\n-            \"orrw   $dst, $isrc, $dst\\n\\t\"\n-            \"sxth   $dst, $dst\\t# orr reduction4S\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);\n-    __ orrw($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ orrw($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 16);\n-    __ orrw($dst$$Register, $isrc$$Register, $dst$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_eor4S(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (XorReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, S, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, S, 1\\n\\t\"\n-            \"eorw   $dst, $dst, $tmp\\n\\t\"\n-            \"eorw   $dst, $dst, $dst, LSR #16\\n\\t\"\n-            \"eorw   $dst, $isrc, $dst\\n\\t\"\n-            \"sxth   $dst, $dst\\t# eor reduction4S\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);\n-    __ eorw($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ eorw($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 16);\n-    __ eorw($dst$$Register, $isrc$$Register, $dst$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_and8S(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (AndReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, D, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, D, 1\\n\\t\"\n-            \"andr   $dst, $dst, $tmp\\n\\t\"\n-            \"andr   $dst, $dst, $dst, LSR #32\\n\\t\"\n-            \"andw   $dst, $dst, $dst, LSR #16\\n\\t\"\n-            \"andw   $dst, $isrc, $dst\\n\\t\"\n-            \"sxth   $dst, $dst\\t# and reduction8S\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ andr($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ andr($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 32);\n-    __ andw($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 16);\n-    __ andw($dst$$Register, $isrc$$Register, $dst$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_orr8S(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (OrReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, D, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, D, 1\\n\\t\"\n-            \"orr    $dst, $dst, $tmp\\n\\t\"\n-            \"orr    $dst, $dst, $dst, LSR #32\\n\\t\"\n-            \"orrw   $dst, $dst, $dst, LSR #16\\n\\t\"\n-            \"orrw   $dst, $isrc, $dst\\n\\t\"\n-            \"sxth   $dst, $dst\\t# orr reduction8S\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ orr ($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ orr ($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 32);\n-    __ orrw($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 16);\n-    __ orrw($dst$$Register, $isrc$$Register, $dst$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_eor8S(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (XorReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, D, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, D, 1\\n\\t\"\n-            \"eor    $dst, $dst, $tmp\\n\\t\"\n-            \"eor    $dst, $dst, $dst, LSR #32\\n\\t\"\n-            \"eorw   $dst, $dst, $dst, LSR #16\\n\\t\"\n-            \"eorw   $dst, $isrc, $dst\\n\\t\"\n-            \"sxth   $dst, $dst\\t# eor reduction8S\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ eor ($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ eor ($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 32);\n-    __ eorw($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 16);\n-    __ eorw($dst$$Register, $isrc$$Register, $dst$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_and2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (AndReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov  $tmp, $vsrc, S, 0\\n\\t\"\n-            \"andw  $dst, $tmp, $isrc\\n\\t\"\n-            \"umov  $tmp, $vsrc, S, 1\\n\\t\"\n-            \"andw  $dst, $tmp, $dst\\t# and reduction2I\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);\n-    __ andw($dst$$Register, $tmp$$Register, $isrc$$Register);\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);\n-    __ andw($dst$$Register, $tmp$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_orr2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (OrReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov  $tmp, $vsrc, S, 0\\n\\t\"\n-            \"orrw  $dst, $tmp, $isrc\\n\\t\"\n-            \"umov  $tmp, $vsrc, S, 1\\n\\t\"\n-            \"orrw  $dst, $tmp, $dst\\t# orr reduction2I\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);\n-    __ orrw($dst$$Register, $tmp$$Register, $isrc$$Register);\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);\n-    __ orrw($dst$$Register, $tmp$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_eor2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (XorReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov  $tmp, $vsrc, S, 0\\n\\t\"\n-            \"eorw  $dst, $tmp, $isrc\\n\\t\"\n-            \"umov  $tmp, $vsrc, S, 1\\n\\t\"\n-            \"eorw  $dst, $tmp, $dst\\t# eor reduction2I\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);\n-    __ eorw($dst$$Register, $tmp$$Register, $isrc$$Register);\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);\n-    __ eorw($dst$$Register, $tmp$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_and4I(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (AndReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, D, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, D, 1\\n\\t\"\n-            \"andr   $dst, $dst, $tmp\\n\\t\"\n-            \"andr   $dst, $dst, $dst, LSR #32\\n\\t\"\n-            \"andw   $dst, $isrc, $dst\\t# and reduction4I\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ andr($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ andr($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 32);\n-    __ andw($dst$$Register, $isrc$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_orr4I(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (OrReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, D, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, D, 1\\n\\t\"\n-            \"orr    $dst, $dst, $tmp\\n\\t\"\n-            \"orr    $dst, $dst, $dst, LSR #32\\n\\t\"\n-            \"orrw   $dst, $isrc, $dst\\t# orr reduction4I\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ orr ($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ orr ($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 32);\n-    __ orrw($dst$$Register, $isrc$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_eor4I(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (XorReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, D, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, D, 1\\n\\t\"\n-            \"eor    $dst, $dst, $tmp\\n\\t\"\n-            \"eor    $dst, $dst, $dst, LSR #32\\n\\t\"\n-            \"eorw   $dst, $isrc, $dst\\t# eor reduction4I\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ eor ($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ eor ($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 32);\n-    __ eorw($dst$$Register, $isrc$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_and2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, iRegLNoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (AndReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov  $tmp, $vsrc, D, 0\\n\\t\"\n-            \"andr  $dst, $isrc, $tmp\\n\\t\"\n-            \"umov  $tmp, $vsrc, D, 1\\n\\t\"\n-            \"andr  $dst, $dst, $tmp\\t# and reduction2L\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ andr($dst$$Register, $isrc$$Register, $tmp$$Register);\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ andr($dst$$Register, $dst$$Register, $tmp$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_orr2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, iRegLNoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (OrReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov  $tmp, $vsrc, D, 0\\n\\t\"\n-            \"orr   $dst, $isrc, $tmp\\n\\t\"\n-            \"umov  $tmp, $vsrc, D, 1\\n\\t\"\n-            \"orr   $dst, $dst, $tmp\\t# orr reduction2L\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ orr ($dst$$Register, $isrc$$Register, $tmp$$Register);\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ orr ($dst$$Register, $dst$$Register, $tmp$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_eor2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, iRegLNoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (XorReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov  $tmp, $vsrc, D, 0\\n\\t\"\n-            \"eor   $dst, $isrc, $tmp\\n\\t\"\n-            \"umov  $tmp, $vsrc, D, 1\\n\\t\"\n-            \"eor   $dst, $dst, $tmp\\t# eor reduction2L\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ eor ($dst$$Register, $isrc$$Register, $tmp$$Register);\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ eor ($dst$$Register, $dst$$Register, $tmp$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector insert ---------------------------------\n-\n-instruct insertID(vecD dst, vecD src, iRegIorL2I val, immI idx)\n-%{\n-  predicate((n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(2 * INSN_COST);\n-  format %{ \"orr    $dst, T8B, $src, $src\\n\\t\"\n-            \"mov    $dst, B\/H\/S, $idx, $val\\t# insert into vector (B\/H\/S)\" %}\n-  ins_encode %{\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ orr(as_FloatRegister($dst$$reg), __ T8B,\n-             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    }\n-    __ mov(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(Matcher::vector_element_basic_type(this)),\n-           $idx$$constant, $val$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertIX(vecX dst, vecX src, iRegIorL2I val, immI idx)\n-%{\n-  predicate((n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(2 * INSN_COST);\n-  format %{ \"orr    $dst, T16B, $src, $src\\n\\t\"\n-            \"mov    $dst, B\/H\/S, $idx, $val\\t# insert into vector (B\/H\/S)\" %}\n-  ins_encode %{\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ orr(as_FloatRegister($dst$$reg), __ T16B,\n-             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    }\n-    __ mov(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(Matcher::vector_element_basic_type(this)),\n-           $idx$$constant, $val$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insert2L(vecX dst, vecX src, iRegL val, immI idx)\n-%{\n-  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(2 * INSN_COST);\n-  format %{ \"orr    $dst, T16B, $src, $src\\n\\t\"\n-            \"mov    $dst, D, $idx, $val\\t# insert into vector (D)\" %}\n-  ins_encode %{\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ orr(as_FloatRegister($dst$$reg), __ T16B,\n-             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    }\n-    __ mov(as_FloatRegister($dst$$reg), __ D,\n-           $idx$$constant, $val$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insert2F(vecD dst, vecD src, vRegF val, immI idx)\n-%{\n-  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(2 * INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"orr    $dst, T8B, $src, $src\\n\\t\"\n-            \"ins    $dst, S, $val, $idx, 0\\t# insert into vector(2F)\" %}\n-  ins_encode %{\n-    __ orr(as_FloatRegister($dst$$reg), __ T8B,\n-           as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ ins(as_FloatRegister($dst$$reg), __ S,\n-           as_FloatRegister($val$$reg), $idx$$constant, 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insert4F(vecX dst, vecX src, vRegF val, immI idx)\n-%{\n-  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(2 * INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"orr    $dst, T16B, $src, $src\\n\\t\"\n-            \"ins    $dst, S, $val, $idx, 0\\t# insert into vector(4F)\" %}\n-  ins_encode %{\n-    __ orr(as_FloatRegister($dst$$reg), __ T16B,\n-           as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ ins(as_FloatRegister($dst$$reg), __ S,\n-           as_FloatRegister($val$$reg), $idx$$constant, 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insert2D(vecX dst, vecX src, vRegD val, immI idx)\n-%{\n-  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(2 * INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"orr    $dst, T16B, $src, $src\\n\\t\"\n-            \"ins    $dst, D, $val, $idx, 0\\t# insert into vector(2D)\" %}\n-  ins_encode %{\n-    __ orr(as_FloatRegister($dst$$reg), __ T16B,\n-           as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ ins(as_FloatRegister($dst$$reg), __ D,\n-           as_FloatRegister($val$$reg), $idx$$constant, 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector extract ---------------------------------\n-\n-instruct extract8B(iRegINoSp dst, vecD src, immI idx)\n-%{\n-  predicate(n->in(1)->bottom_type()->is_vect()->length() == 8);\n-  match(Set dst (ExtractB src idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"smov    $dst, $src, B, $idx\\t# extract from vector(8B)\" %}\n-  ins_encode %{\n-    __ smov($dst$$Register, as_FloatRegister($src$$reg), __ B, $idx$$constant);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct extract16B(iRegINoSp dst, vecX src, immI idx)\n-%{\n-  predicate(n->in(1)->bottom_type()->is_vect()->length() == 16);\n-  match(Set dst (ExtractB src idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"smov    $dst, $src, B, $idx\\t# extract from vector(16B)\" %}\n-  ins_encode %{\n-    __ smov($dst$$Register, as_FloatRegister($src$$reg), __ B, $idx$$constant);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct extract4S(iRegINoSp dst, vecD src, immI idx)\n-%{\n-  predicate(n->in(1)->bottom_type()->is_vect()->length() == 4);\n-  match(Set dst (ExtractS src idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"smov    $dst, $src, H, $idx\\t# extract from vector(4S)\" %}\n-  ins_encode %{\n-    __ smov($dst$$Register, as_FloatRegister($src$$reg), __ H, $idx$$constant);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct extract8S(iRegINoSp dst, vecX src, immI idx)\n-%{\n-  predicate(n->in(1)->bottom_type()->is_vect()->length() == 8);\n-  match(Set dst (ExtractS src idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"smov    $dst, $src, H, $idx\\t# extract from vector(8S)\" %}\n-  ins_encode %{\n-    __ smov($dst$$Register, as_FloatRegister($src$$reg), __ H, $idx$$constant);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct extract2I(iRegINoSp dst, vecD src, immI idx)\n-%{\n-  predicate(n->in(1)->bottom_type()->is_vect()->length() == 2);\n-  match(Set dst (ExtractI src idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"umov    $dst, $src, S, $idx\\t# extract from vector(2I)\" %}\n-  ins_encode %{\n-    __ umov($dst$$Register, as_FloatRegister($src$$reg), __ S, $idx$$constant);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct extract4I(iRegINoSp dst, vecX src, immI idx)\n-%{\n-  predicate(n->in(1)->bottom_type()->is_vect()->length() == 4);\n-  match(Set dst (ExtractI src idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"umov    $dst, $src, S, $idx\\t# extract from vector(4I)\" %}\n-  ins_encode %{\n-    __ umov($dst$$Register, as_FloatRegister($src$$reg), __ S, $idx$$constant);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct extract2L(iRegLNoSp dst, vecX src, immI idx)\n-%{\n-  predicate(n->in(1)->bottom_type()->is_vect()->length() == 2);\n-  match(Set dst (ExtractL src idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"umov    $dst, $src, D, $idx\\t# extract from vector(2L)\" %}\n-  ins_encode %{\n-    __ umov($dst$$Register, as_FloatRegister($src$$reg), __ D, $idx$$constant);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct extract2F(vRegF dst, vecD src, immI idx)\n-%{\n-  predicate(n->in(1)->bottom_type()->is_vect()->length() == 2);\n-  match(Set dst (ExtractF src idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"ins   $dst, S, $src, 0, $idx\\t# extract from vector(2F)\" %}\n-  ins_encode %{\n-    if ((0 == $idx$$constant) &&\n-        (as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg))) {\n-      \/* empty *\/\n-    } else if ($idx$$constant == 0) {\n-      __ fmovs(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n-    } else {\n-      __ ins(as_FloatRegister($dst$$reg), __ S,\n-             as_FloatRegister($src$$reg), 0, $idx$$constant);\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct extract4F(vRegF dst, vecX src, immI idx)\n-%{\n-  predicate(n->in(1)->bottom_type()->is_vect()->length() == 4);\n-  match(Set dst (ExtractF src idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"ins   $dst, S, $src, 0, $idx\\t# extract from vector(4F)\" %}\n-  ins_encode %{\n-    if ((0 == $idx$$constant) &&\n-        (as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg))) {\n-      \/* empty *\/\n-    } else if ($idx$$constant == 0) {\n-      __ fmovs(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n-    } else {\n-      __ ins(as_FloatRegister($dst$$reg), __ S,\n-             as_FloatRegister($src$$reg), 0, $idx$$constant);\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct extract2D(vRegD dst, vecX src, immI idx)\n-%{\n-  predicate(n->in(1)->bottom_type()->is_vect()->length() == 2);\n-  match(Set dst (ExtractD src idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"ins   $dst, D, $src, 0, $idx\\t# extract from vector(2D)\" %}\n-  ins_encode %{\n-    if ((0 == $idx$$constant) &&\n-        (as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg))) {\n-      \/* empty *\/\n-    } else if ($idx$$constant == 0) {\n-      __ fmovd(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n-    } else {\n-      __ ins(as_FloatRegister($dst$$reg), __ D,\n-             as_FloatRegister($src$$reg), 0, $idx$$constant);\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-\/\/ ------------------------------ Vector comparison ---------------------------------\n-\n-instruct vcmpD(vecD dst, vecD src1, vecD src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 8);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"vcmpD  $dst, $src1, $src2\\t# vector compare \" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    assert(type2aelembytes(bt) != 8, \"not supported\");\n-    __ neon_compare(as_FloatRegister($dst$$reg), bt, as_FloatRegister($src1$$reg),\n-                    as_FloatRegister($src2$$reg), (int)$cond$$constant, \/*isQ*\/ false);\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vcmpX(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"vcmpX  $dst, $src1, $src2\\t# vector compare \" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ neon_compare(as_FloatRegister($dst$$reg), bt, as_FloatRegister($src1$$reg),\n-                    as_FloatRegister($src2$$reg), (int)$cond$$constant, \/*isQ*\/ true);\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-\/\/ ------------------------------ Vector mul -----------------------------------\n-\n-instruct vmul2L(vecX dst, vecX src1, vecX src2, iRegLNoSp tmp1, iRegLNoSp tmp2)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (MulVL src1 src2));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp1, TEMP tmp2);\n-  format %{ \"umov   $tmp1, $src1, D, 0\\n\\t\"\n-            \"umov   $tmp2, $src2, D, 0\\n\\t\"\n-            \"mul    $tmp2, $tmp2, $tmp1\\n\\t\"\n-            \"mov    $dst,  T2D,   0, $tmp2\\t# insert into vector(2L)\\n\\t\"\n-            \"umov   $tmp1, $src1, D, 1\\n\\t\"\n-            \"umov   $tmp2, $src2, D, 1\\n\\t\"\n-            \"mul    $tmp2, $tmp2, $tmp1\\n\\t\"\n-            \"mov    $dst,  T2D,   1, $tmp2\\t# insert into vector(2L)\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp1$$Register, as_FloatRegister($src1$$reg), __ D, 0);\n-    __ umov($tmp2$$Register, as_FloatRegister($src2$$reg), __ D, 0);\n-    __ mul(as_Register($tmp2$$reg), as_Register($tmp2$$reg), as_Register($tmp1$$reg));\n-    __ mov(as_FloatRegister($dst$$reg), __ D, 0, $tmp2$$Register);\n-    __ umov($tmp1$$Register, as_FloatRegister($src1$$reg), __ D, 1);\n-    __ umov($tmp2$$Register, as_FloatRegister($src2$$reg), __ D, 1);\n-    __ mul(as_Register($tmp2$$reg), as_Register($tmp2$$reg), as_Register($tmp1$$reg));\n-    __ mov(as_FloatRegister($dst$$reg), __ D, 1, $tmp2$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ --------------------------------- Vector not --------------------------------\n-\n-instruct vnot2I(vecD dst, vecD src, immI_M1 m1)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 8);\n-  match(Set dst (XorV src (ReplicateB m1)));\n-  match(Set dst (XorV src (ReplicateS m1)));\n-  match(Set dst (XorV src (ReplicateI m1)));\n-  ins_cost(INSN_COST);\n-  format %{ \"not  $dst, T8B, $src\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ notr(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vnot4I(vecX dst, vecX src, immI_M1 m1)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (XorV src (ReplicateB m1)));\n-  match(Set dst (XorV src (ReplicateS m1)));\n-  match(Set dst (XorV src (ReplicateI m1)));\n-  ins_cost(INSN_COST);\n-  format %{ \"not  $dst, T16B, $src\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ notr(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vnot2L(vecX dst, vecX src, immL_M1 m1)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (XorV src (ReplicateL m1)));\n-  ins_cost(INSN_COST);\n-  format %{ \"not  $dst, T16B, $src\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ notr(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-\/\/ ------------------------------ Vector and_not -------------------------------\n-\n-instruct vand_not2I(vecD dst, vecD src1, vecD src2, immI_M1 m1)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 8);\n-  match(Set dst (AndV src1 (XorV src2 (ReplicateB m1))));\n-  match(Set dst (AndV src1 (XorV src2 (ReplicateS m1))));\n-  match(Set dst (AndV src1 (XorV src2 (ReplicateI m1))));\n-  ins_cost(INSN_COST);\n-  format %{ \"bic  $dst, T8B, $src1, $src2\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ bic(as_FloatRegister($dst$$reg), __ T8B,\n-           as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vand_not4I(vecX dst, vecX src1, vecX src2, immI_M1 m1)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (AndV src1 (XorV src2 (ReplicateB m1))));\n-  match(Set dst (AndV src1 (XorV src2 (ReplicateS m1))));\n-  match(Set dst (AndV src1 (XorV src2 (ReplicateI m1))));\n-  ins_cost(INSN_COST);\n-  format %{ \"bic  $dst, T16B, $src1, $src2\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ bic(as_FloatRegister($dst$$reg), __ T16B,\n-           as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vand_not2L(vecX dst, vecX src1, vecX src2, immL_M1 m1)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (AndV src1 (XorV src2 (ReplicateL m1))));\n-  ins_cost(INSN_COST);\n-  format %{ \"bic  $dst, T16B, $src1, $src2\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ bic(as_FloatRegister($dst$$reg), __ T16B,\n-           as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-\/\/ ------------------------------ Vector max\/min -------------------------------\n-\n-instruct vmax8B(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate((n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8) &&\n-             n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (MaxV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"maxv  $dst, T8B, $src1, $src2\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ maxv(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vmax16B(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 16 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (MaxV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"maxv  $dst, T16B, $src1, $src2\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ maxv(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vmax4S(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (MaxV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"maxv  $dst, T4H, $src1, $src2\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ maxv(as_FloatRegister($dst$$reg), __ T4H,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vmax8S(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 8 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (MaxV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"maxv  $dst, T8H, $src1, $src2\\t# vector (8S)\" %}\n-  ins_encode %{\n-    __ maxv(as_FloatRegister($dst$$reg), __ T8H,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vmax2I(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (MaxV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"maxv  $dst, T2S, $src1, $src2\\t# vector (2I)\" %}\n-  ins_encode %{\n-    __ maxv(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vmax4I(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (MaxV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"maxv  $dst, T4S, $src1, $src2\\t# vector (4I)\" %}\n-  ins_encode %{\n-    __ maxv(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vmin8B(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate((n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8) &&\n-             n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (MinV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"minv  $dst, T8B, $src1, $src2\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ minv(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vmin16B(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 16 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (MinV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"minv  $dst, T16B, $src1, $src2\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ minv(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vmin4S(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (MinV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"minv  $dst, T4H, $src1, $src2\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ minv(as_FloatRegister($dst$$reg), __ T4H,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vmin8S(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 8 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (MinV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"minv  $dst, T8H, $src1, $src2\\t# vector (8S)\" %}\n-  ins_encode %{\n-    __ minv(as_FloatRegister($dst$$reg), __ T8H,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vmin2I(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (MinV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"minv  $dst, T2S, $src1, $src2\\t# vector (2I)\" %}\n-  ins_encode %{\n-    __ minv(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vmin4I(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (MinV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"minv  $dst, T4S, $src1, $src2\\t# vector (4I)\" %}\n-  ins_encode %{\n-    __ minv(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-\n-instruct vmax2L(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (MaxV src1 src2));\n-  ins_cost(INSN_COST);\n-  effect(TEMP dst);\n-  format %{ \"cmgt  $dst, T2D, $src1, $src2\\t# vector (2L)\\n\\t\"\n-            \"bsl   $dst, T16B, $src1, $src2\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ cmgt(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-    __ bsl(as_FloatRegister($dst$$reg), __ T16B,\n-           as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vmin2L(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (MinV src1 src2));\n-  ins_cost(INSN_COST);\n-  effect(TEMP dst);\n-  format %{ \"cmgt  $dst, T2D, $src1, $src2\\t# vector (2L)\\n\\t\"\n-            \"bsl   $dst, T16B, $src2, $src1\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ cmgt(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-    __ bsl(as_FloatRegister($dst$$reg), __ T16B,\n-           as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-\/\/ --------------------------------- blend (bsl) ----------------------------\n-\n-instruct vbsl8B(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 8);\n-  match(Set dst (VectorBlend (Binary src1 src2) dst));\n-  ins_cost(INSN_COST);\n-  format %{ \"bsl  $dst, T8B, $src2, $src1\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ bsl(as_FloatRegister($dst$$reg), __ T8B,\n-           as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(vlogical64);\n-%}\n-\n-instruct vbsl16B(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (VectorBlend (Binary src1 src2) dst));\n-  ins_cost(INSN_COST);\n-  format %{ \"bsl  $dst, T16B, $src2, $src1\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ bsl(as_FloatRegister($dst$$reg), __ T16B,\n-           as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(vlogical128);\n-%}\n-\n-\/\/ --------------------------------- Load\/store Mask ----------------------------\n-\n-instruct loadmask8B(vecD dst, vecD src  )\n-%{\n-  predicate(n->as_Vector()->length() == 8 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorLoadMask src ));\n-  ins_cost(INSN_COST);\n-  format %{ \"negr  $dst, T8B, $src\\t# load mask (8B to 8B)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct loadmask16B(vecX dst, vecX src  )\n-%{\n-  predicate(n->as_Vector()->length() == 16 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorLoadMask src ));\n-  ins_cost(INSN_COST);\n-  format %{ \"negr  $dst, T16B, $src\\t# load mask (16B to 16B)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T16B, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct storemask8B(vecD dst, vecD src , immI_1 size)\n-%{\n-  predicate(n->as_Vector()->length() == 8);\n-  match(Set dst (VectorStoreMask src size));\n-  ins_cost(INSN_COST);\n-  format %{ \"negr  $dst, T8B, $src\\t# store mask (8B to 8B)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct storemask16B(vecX dst, vecX src , immI_1 size)\n-%{\n-  predicate(n->as_Vector()->length() == 16);\n-  match(Set dst (VectorStoreMask src size));\n-  ins_cost(INSN_COST);\n-  format %{ \"negr  $dst, T16B, $src\\t# store mask (16B to 16B)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T16B, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct loadmask4S(vecD dst, vecD src  )\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorLoadMask src ));\n-  ins_cost(INSN_COST);\n-  format %{ \"uxtl  $dst, T8H, $src, T8B\\n\\t\"\n-            \"negr  $dst, T8H, $dst\\t# load mask (4B to 4H)\" %}\n-  ins_encode %{\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-    __ negr(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct loadmask8S(vecX dst, vecD src  )\n-%{\n-  predicate(n->as_Vector()->length() == 8 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorLoadMask src ));\n-  ins_cost(INSN_COST);\n-  format %{ \"uxtl  $dst, T8H, $src, T8B\\n\\t\"\n-            \"negr  $dst, T8H, $dst\\t# load mask (8B to 8H)\" %}\n-  ins_encode %{\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-    __ negr(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct storemask4S(vecD dst, vecD src , immI_2 size)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (VectorStoreMask src size));\n-  ins_cost(INSN_COST);\n-  format %{ \"xtn  $dst, T8B, $src, T8H\\n\\t\"\n-            \"negr  $dst, T8B, $dst\\t# store mask (4H to 4B)\" %}\n-  ins_encode %{\n-    __ xtn(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($src$$reg), __ T8H);\n-    __ negr(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct storemask8S(vecD dst, vecX src , immI_2 size)\n-%{\n-  predicate(n->as_Vector()->length() == 8);\n-  match(Set dst (VectorStoreMask src size));\n-  ins_cost(INSN_COST);\n-  format %{ \"xtn  $dst, T8B, $src, T8H\\n\\t\"\n-            \"negr  $dst, T8B, $dst\\t# store mask (8H to 8B)\" %}\n-  ins_encode %{\n-    __ xtn(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($src$$reg), __ T8H);\n-    __ negr(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct loadmask2I(vecD dst, vecD src  )\n-%{\n-  predicate(n->as_Vector()->length() == 2 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n-  match(Set dst (VectorLoadMask src ));\n-  ins_cost(INSN_COST);\n-  format %{ \"uxtl  $dst, T8H, $src, T8B\\t# 2B to 2H\\n\\t\"\n-            \"uxtl  $dst, T4S, $dst, T4H\\t# 2H to 2S\\n\\t\"\n-            \"negr   $dst, T4S, $dst\\t# load mask (2B to 2S)\" %}\n-  ins_encode %{\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($dst$$reg), __ T4H);\n-    __ negr(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct loadmask4I(vecX dst, vecD src  )\n-%{\n-  predicate(n->as_Vector()->length() == 4 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n-  match(Set dst (VectorLoadMask src ));\n-  ins_cost(INSN_COST);\n-  format %{ \"uxtl  $dst, T8H, $src, T8B\\t# 4B to 4H\\n\\t\"\n-            \"uxtl  $dst, T4S, $dst, T4H\\t# 4H to 4S\\n\\t\"\n-            \"negr   $dst, T4S, $dst\\t# load mask (4B to 4S)\" %}\n-  ins_encode %{\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($dst$$reg), __ T4H);\n-    __ negr(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct storemask2I(vecD dst, vecD src , immI_4 size)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (VectorStoreMask src size));\n-  ins_cost(INSN_COST);\n-  format %{ \"xtn  $dst, T4H, $src, T4S\\t# 2S to 2H\\n\\t\"\n-            \"xtn  $dst, T8B, $dst, T8H\\t# 2H to 2B\\n\\t\"\n-            \"negr   $dst, T8B, $dst\\t# store mask (2S to 2B)\" %}\n-  ins_encode %{\n-    __ xtn(as_FloatRegister($dst$$reg), __ T4H, as_FloatRegister($src$$reg), __ T4S);\n-    __ xtn(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($dst$$reg), __ T8H);\n-    __ negr(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct storemask4I(vecD dst, vecX src , immI_4 size)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (VectorStoreMask src size));\n-  ins_cost(INSN_COST);\n-  format %{ \"xtn  $dst, T4H, $src, T4S\\t# 4S to 4H\\n\\t\"\n-            \"xtn  $dst, T8B, $dst, T8H\\t# 4H to 4B\\n\\t\"\n-            \"negr   $dst, T8B, $dst\\t# store mask (4S to 4B)\" %}\n-  ins_encode %{\n-    __ xtn(as_FloatRegister($dst$$reg), __ T4H, as_FloatRegister($src$$reg), __ T4S);\n-    __ xtn(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($dst$$reg), __ T8H);\n-    __ negr(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct loadmask2L(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n-  match(Set dst (VectorLoadMask src));\n-  ins_cost(INSN_COST);\n-  format %{ \"uxtl  $dst, T8H, $src, T8B\\t# 2B to 2S\\n\\t\"\n-            \"uxtl  $dst, T4S, $dst, T4H\\t# 2S to 2I\\n\\t\"\n-            \"uxtl  $dst, T2D, $dst, T2S\\t# 2I to 2L\\n\\t\"\n-            \"neg   $dst, T2D, $dst\\t# load mask (2B to 2L)\" %}\n-  ins_encode %{\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($dst$$reg), __ T4H);\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($dst$$reg), __ T2S);\n-    __ negr(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct storemask2L(vecD dst, vecX src, immI_8 size)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (VectorStoreMask src size));\n-  ins_cost(INSN_COST);\n-  format %{ \"xtn  $dst, T2S, $src, T2D\\t# 2L to 2I\\n\\t\"\n-            \"xtn  $dst, T4H, $dst, T4S\\t# 2I to 2S\\n\\t\"\n-            \"xtn  $dst, T8B, $dst, T8H\\t# 2S to 2B\\n\\t\"\n-            \"neg  $dst, T8B, $dst\\t# store mask (2L to 2B)\" %}\n-  ins_encode %{\n-    __ xtn(as_FloatRegister($dst$$reg), __ T2S, as_FloatRegister($src$$reg), __ T2D);\n-    __ xtn(as_FloatRegister($dst$$reg), __ T4H, as_FloatRegister($dst$$reg), __ T4S);\n-    __ xtn(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($dst$$reg), __ T8H);\n-    __ negr(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector mask cast\n-\n-instruct vmaskcastD(vecD dst)\n-%{\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 8 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 8 &&\n-            n->bottom_type()->is_vect()->length() == n->in(1)->bottom_type()->is_vect()->length());\n-  match(Set dst (VectorMaskCast dst));\n-  ins_cost(0);\n-  format %{ \"vmaskcast $dst\\t# empty\" %}\n-  ins_encode %{\n-    \/\/ empty\n-  %}\n-  ins_pipe(pipe_class_empty);\n-%}\n-\n-instruct vmaskcastX(vecX dst)\n-%{\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 16 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 16 &&\n-            n->bottom_type()->is_vect()->length() == n->in(1)->bottom_type()->is_vect()->length());\n-  match(Set dst (VectorMaskCast dst));\n-  ins_cost(0);\n-  format %{ \"vmaskcast $dst\\t# empty\" %}\n-  ins_encode %{\n-    \/\/ empty\n-  %}\n-  ins_pipe(pipe_class_empty);\n-%}\n-\n-\/\/-------------------------------- LOAD_IOTA_INDICES----------------------------------\n-\n-instruct loadcon8B(vecD dst, immI0 src)\n-%{\n-  predicate(UseSVE == 0 &&\n-           (n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4 ||\n-            n->as_Vector()->length() == 8) &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorLoadConst src));\n-  ins_cost(INSN_COST);\n-  format %{ \"ldr $dst, CONSTANT_MEMORY\\t# load iota indices\" %}\n-  ins_encode %{\n-    __ lea(rscratch1, ExternalAddress(StubRoutines::aarch64::vector_iota_indices()));\n-    __ ldrd(as_FloatRegister($dst$$reg), rscratch1);\n-  %}\n-  ins_pipe(pipe_class_memory);\n-%}\n-\n-instruct loadcon16B(vecX dst, immI0 src)\n-%{\n-  predicate(UseSVE == 0 && n->as_Vector()->length() == 16 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorLoadConst src));\n-  ins_cost(INSN_COST);\n-  format %{ \"ldr $dst, CONSTANT_MEMORY\\t# load iota indices\" %}\n-  ins_encode %{\n-    __ lea(rscratch1, ExternalAddress(StubRoutines::aarch64::vector_iota_indices()));\n-    __ ldrq(as_FloatRegister($dst$$reg), rscratch1);\n-  %}\n-  ins_pipe(pipe_class_memory);\n-%}\n-\n-\/\/-------------------------------- LOAD_SHUFFLE ----------------------------------\n-\n-instruct loadshuffle8B(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 8 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorLoadShuffle src));\n-  ins_cost(INSN_COST);\n-  format %{ \"mov  $dst, T8B, $src\\t# get 8B shuffle\" %}\n-  ins_encode %{\n-    __ orr(as_FloatRegister($dst$$reg), __ T8B,\n-           as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct loadshuffle16B(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 16 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorLoadShuffle src));\n-  ins_cost(INSN_COST);\n-  format %{ \"mov  $dst, T16B, $src\\t# get 16B shuffle\" %}\n-  ins_encode %{\n-    __ orr(as_FloatRegister($dst$$reg), __ T16B,\n-           as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct loadshuffle4S(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorLoadShuffle src));\n-  ins_cost(INSN_COST);\n-  format %{ \"uxtl  $dst, T8H, $src, T8B\\t# 4B to 4H\" %}\n-  ins_encode %{\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct loadshuffle8S(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 8 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorLoadShuffle src));\n-  ins_cost(INSN_COST);\n-  format %{ \"uxtl  $dst, T8H, $src, T8B\\t# 8B to 8H\" %}\n-  ins_encode %{\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct loadshuffle4I(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 &&\n-           (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n-  match(Set dst (VectorLoadShuffle src));\n-  ins_cost(INSN_COST);\n-  format %{ \"uxtl  $dst, T8H, $src, T8B\\t# 4B to 4H \\n\\t\"\n-            \"uxtl  $dst, T4S, $dst, T4H\\t# 4H to 4S\" %}\n-  ins_encode %{\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($dst$$reg), __ T4H);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/-------------------------------- Rearrange -------------------------------------\n-\/\/ Here is an example that rearranges a NEON vector with 4 ints:\n-\/\/ Rearrange V1 int[a0, a1, a2, a3] to V2 int[a2, a3, a0, a1]\n-\/\/   1. Get the indices of V1 and store them as Vi byte[0, 1, 2, 3].\n-\/\/   2. Convert Vi byte[0, 1, 2, 3] to the indices of V2 and also store them as Vi byte[2, 3, 0, 1].\n-\/\/   3. Unsigned extend Long Vi from byte[2, 3, 0, 1] to int[2, 3, 0, 1].\n-\/\/   4. Multiply Vi int[2, 3, 0, 1] with constant int[0x04040404, 0x04040404, 0x04040404, 0x04040404]\n-\/\/      and get tbl base Vm int[0x08080808, 0x0c0c0c0c, 0x00000000, 0x04040404].\n-\/\/   5. Add Vm with constant int[0x03020100, 0x03020100, 0x03020100, 0x03020100]\n-\/\/      and get tbl index Vm int[0x0b0a0908, 0x0f0e0d0c, 0x03020100, 0x07060504]\n-\/\/   6. Use Vm as index register, and use V1 as table register.\n-\/\/      Then get V2 as the result by tbl NEON instructions.\n-\/\/ Notes:\n-\/\/   Step 1 matches VectorLoadConst.\n-\/\/   Step 3 matches VectorLoadShuffle.\n-\/\/   Step 4, 5, 6 match VectorRearrange.\n-\/\/   For VectorRearrange short\/int, the reason why such complex calculation is\n-\/\/   required is because NEON tbl supports bytes table only, so for short\/int, we\n-\/\/   need to lookup 2\/4 bytes as a group. For VectorRearrange long, we use bsl\n-\/\/   to implement rearrange.\n-\n-instruct rearrange8B(vecD dst, vecD src, vecD shuffle)\n-%{\n-  predicate(n->as_Vector()->length() == 8 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorRearrange src shuffle));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"tbl $dst, T8B, {$dst}, $shuffle\\t# rearrange 8B\" %}\n-  ins_encode %{\n-    __ tbl(as_FloatRegister($dst$$reg), __ T8B,\n-           as_FloatRegister($src$$reg), 1, as_FloatRegister($shuffle$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct rearrange16B(vecX dst, vecX src, vecX shuffle)\n-%{\n-  predicate(n->as_Vector()->length() == 16 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorRearrange src shuffle));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"tbl $dst, T16B, {$dst}, $shuffle\\t# rearrange 16B\" %}\n-  ins_encode %{\n-    __ tbl(as_FloatRegister($dst$$reg), __ T16B,\n-           as_FloatRegister($src$$reg), 1, as_FloatRegister($shuffle$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct rearrange4S(vecD dst, vecD src, vecD shuffle, vecD tmp0, vecD tmp1)\n-%{\n-  predicate(n->as_Vector()->length() == 4 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorRearrange src shuffle));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp0, TEMP tmp1);\n-  format %{ \"mov   $tmp0, T8B, CONSTANT\\t# constant 0x0202020202020202\\n\\t\"\n-            \"mov   $tmp1, T4H, CONSTANT\\t# constant 0x0100010001000100\\n\\t\"\n-            \"mulv  $dst, T4H, T4H, $shuffle, $tmp0\\n\\t\"\n-            \"addv  $dst, T8B, T8B, $dst, $tmp1\\n\\t\"\n-            \"tbl   $dst, T8B, {$src}, 1, $dst\\t# rearrange 4S\" %}\n-  ins_encode %{\n-    __ mov(as_FloatRegister($tmp0$$reg), __ T8B, 0x02);\n-    __ mov(as_FloatRegister($tmp1$$reg), __ T4H, 0x0100);\n-    __ mulv(as_FloatRegister($dst$$reg), __ T4H,\n-            as_FloatRegister($shuffle$$reg), as_FloatRegister($tmp0$$reg));\n-    __ addv(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($dst$$reg), as_FloatRegister($tmp1$$reg));\n-    __ tbl(as_FloatRegister($dst$$reg), __ T8B,\n-           as_FloatRegister($src$$reg), 1, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct rearrange8S(vecX dst, vecX src, vecX shuffle, vecX tmp0, vecX tmp1)\n-%{\n-  predicate(n->as_Vector()->length() == 8 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorRearrange src shuffle));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp0, TEMP tmp1);\n-  format %{ \"mov   $tmp0, T16B, CONSTANT\\t# constant 0x0202020202020202\\n\\t\"\n-            \"mov   $tmp1, T8H, CONSTANT\\t# constant 0x0100010001000100\\n\\t\"\n-            \"mulv  $dst, T8H, T8H, $shuffle, $tmp0\\n\\t\"\n-            \"addv  $dst, T16B, T16B, $dst, $tmp1\\n\\t\"\n-            \"tbl   $dst, T16B, {$src}, 1, $dst\\t# rearrange 8S\" %}\n-  ins_encode %{\n-    __ mov(as_FloatRegister($tmp0$$reg), __ T16B, 0x02);\n-    __ mov(as_FloatRegister($tmp1$$reg), __ T8H, 0x0100);\n-    __ mulv(as_FloatRegister($dst$$reg), __ T8H,\n-            as_FloatRegister($shuffle$$reg), as_FloatRegister($tmp0$$reg));\n-    __ addv(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($dst$$reg), as_FloatRegister($tmp1$$reg));\n-    __ tbl(as_FloatRegister($dst$$reg), __ T16B,\n-           as_FloatRegister($src$$reg), 1, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct rearrange4I(vecX dst, vecX src, vecX shuffle, vecX tmp0, vecX tmp1)\n-%{\n-  predicate(n->as_Vector()->length() == 4 &&\n-           (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n-  match(Set dst (VectorRearrange src shuffle));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp0, TEMP tmp1);\n-  format %{ \"mov   $tmp0, T16B, CONSTANT\\t# constant 0x0404040404040404\\n\\t\"\n-            \"mov   $tmp1, T4S, CONSTANT\\t# constant 0x0302010003020100\\n\\t\"\n-            \"mulv  $dst, T4S, $shuffle, $tmp0\\n\\t\"\n-            \"addv  $dst, T16B, $dst, $tmp1\\n\\t\"\n-            \"tbl   $dst, T16B, {$src}, 1, $dst\\t# rearrange 4I\" %}\n-  ins_encode %{\n-    __ mov(as_FloatRegister($tmp0$$reg), __ T16B, 0x04);\n-    __ mov(as_FloatRegister($tmp1$$reg), __ T4S, 0x03020100);\n-    __ mulv(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($shuffle$$reg), as_FloatRegister($tmp0$$reg));\n-    __ addv(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($dst$$reg), as_FloatRegister($tmp1$$reg));\n-    __ tbl(as_FloatRegister($dst$$reg), __ T16B,\n-           as_FloatRegister($src$$reg), 1, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/-------------------------------- Anytrue\/alltrue -----------------------------\n-\n-instruct anytrue_in_mask8B(iRegINoSp dst, vecD src1, vecD src2, vecD tmp, rFlagsReg cr)\n-%{\n-  predicate(static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::ne);\n-  match(Set dst (VectorTest src1 src2 ));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp, KILL cr);\n-  format %{ \"addv  $tmp, T8B, $src1\\n\\t\"\n-            \"umov  $dst, $tmp, B, 0\\n\\t\"\n-            \"cmp   $dst, 0\\n\\t\"\n-            \"cset  $dst\\t# anytrue 8B\" %}\n-  ins_encode %{\n-    \/\/ No need to use src2.\n-    __ addv(as_FloatRegister($tmp$$reg), __ T8B, as_FloatRegister($src1$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ cmpw($dst$$Register, zr);\n-    __ csetw($dst$$Register, Assembler::NE);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct anytrue_in_mask16B(iRegINoSp dst, vecX src1, vecX src2, vecX tmp, rFlagsReg cr)\n-%{\n-  predicate(static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::ne);\n-  match(Set dst (VectorTest src1 src2 ));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp, KILL cr);\n-  format %{ \"addv  $tmp, T16B, $src1\\n\\t\"\n-            \"umov  $dst, $tmp, B, 0\\n\\t\"\n-            \"cmp   $dst, 0\\n\\t\"\n-            \"cset  $dst\\t# anytrue 16B\" %}\n-  ins_encode %{\n-    \/\/ No need to use src2.\n-    __ addv(as_FloatRegister($tmp$$reg), __ T16B, as_FloatRegister($src1$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ cmpw($dst$$Register, zr);\n-    __ csetw($dst$$Register, Assembler::NE);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct alltrue_in_mask8B(iRegINoSp dst, vecD src1, vecD src2, vecD tmp, rFlagsReg cr)\n-%{\n-  predicate(static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow);\n-  match(Set dst (VectorTest src1 src2 ));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp, KILL cr);\n-  format %{ \"uminv $tmp, T8B, $src1\\n\\t\"\n-            \"umov  $dst, $tmp, B, 0\\n\\t\"\n-            \"cmp   $dst, 0xff\\n\\t\"\n-            \"cset  $dst\\t# alltrue 8B\" %}\n-  ins_encode %{\n-    \/\/ No need to use src2.\n-    __ uminv(as_FloatRegister($tmp$$reg), __ T8B, as_FloatRegister($src1$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ cmpw($dst$$Register, 0xff);\n-    __ csetw($dst$$Register, Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct alltrue_in_mask16B(iRegINoSp dst, vecX src1, vecX src2, vecX tmp, rFlagsReg cr)\n-%{\n-  predicate(static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow);\n-  match(Set dst (VectorTest src1 src2 ));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp, KILL cr);\n-  format %{ \"uminv $tmp, T16B, $src1\\n\\t\"\n-            \"umov  $dst, $tmp, B, 0\\n\\t\"\n-            \"cmp   $dst, 0xff\\n\\t\"\n-            \"cset  $dst\\t# alltrue 16B\" %}\n-  ins_encode %{\n-    \/\/ No need to use src2.\n-    __ uminv(as_FloatRegister($tmp$$reg), __ T16B, as_FloatRegister($src1$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ cmpw($dst$$Register, 0xff);\n-    __ csetw($dst$$Register, Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ --------------------------------- ABS --------------------------------------\n-\n-instruct vabs8B(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8);\n-  match(Set dst (AbsVB src));\n-  ins_cost(INSN_COST);\n-  format %{ \"abs  $dst, T8B, $src\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ absr(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vlogical64);\n-%}\n-\n-instruct vabs16B(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 16);\n-  match(Set dst (AbsVB src));\n-  ins_cost(INSN_COST);\n-  format %{ \"abs  $dst, T16B, $src\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ absr(as_FloatRegister($dst$$reg), __ T16B, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vlogical128);\n-%}\n-\n-instruct vabs4S(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (AbsVS src));\n-  ins_cost(INSN_COST);\n-  format %{ \"abs  $dst, T4H, $src\\t# vector (4H)\" %}\n-  ins_encode %{\n-    __ absr(as_FloatRegister($dst$$reg), __ T4H, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vlogical64);\n-%}\n-\n-instruct vabs8S(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 8);\n-  match(Set dst (AbsVS src));\n-  ins_cost(INSN_COST);\n-  format %{ \"abs  $dst, T8H, $src\\t# vector (8H)\" %}\n-  ins_encode %{\n-    __ absr(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vlogical128);\n-%}\n-\n-instruct vabs2I(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (AbsVI src));\n-  ins_cost(INSN_COST);\n-  format %{ \"abs  $dst, T2S, $src\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ absr(as_FloatRegister($dst$$reg), __ T2S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vlogical64);\n-%}\n-\n-instruct vabs4I(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (AbsVI src));\n-  ins_cost(INSN_COST);\n-  format %{ \"abs  $dst, T4S, $src\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ absr(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vlogical128);\n-%}\n-\n-instruct vabs2L(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (AbsVL src));\n-  ins_cost(INSN_COST);\n-  format %{ \"abs  $dst, T2D, $src\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ absr(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vlogical128);\n-%}\n-\n-instruct vabs2F(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (AbsVF src));\n-  ins_cost(INSN_COST * 3);\n-  format %{ \"fabs  $dst, T2S, $src\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ fabs(as_FloatRegister($dst$$reg), __ T2S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vunop_fp64);\n-%}\n-\n-instruct vabs4F(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (AbsVF src));\n-  ins_cost(INSN_COST * 3);\n-  format %{ \"fabs  $dst, T4S, $src\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ fabs(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vunop_fp128);\n-%}\n-\n-instruct vabs2D(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (AbsVD src));\n-  ins_cost(INSN_COST * 3);\n-  format %{ \"fabs  $dst, T2D, $src\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ fabs(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vunop_fp128);\n-%}\n-\n-\/\/ --------------------------------- FABS DIFF --------------------------------\n-\n-instruct vabd2F(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (AbsVF (SubVF src1 src2)));\n-  ins_cost(INSN_COST * 3);\n-  format %{ \"fabd  $dst, T2S, $src1, $src2\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ fabd(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vunop_fp64);\n-%}\n-\n-instruct vabd4F(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (AbsVF (SubVF src1 src2)));\n-  ins_cost(INSN_COST * 3);\n-  format %{ \"fabd  $dst, T4S, $src1, $src2\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ fabd(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vunop_fp128);\n-%}\n-\n-instruct vabd2D(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (AbsVD (SubVD src1 src2)));\n-  ins_cost(INSN_COST * 3);\n-  format %{ \"fabd  $dst, T2D, $src1, $src2\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ fabd(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vunop_fp128);\n-%}\n-\n-instruct replicate8B(vecD dst, iRegIorL2I src)\n-%{\n-  predicate(UseSVE == 0 && (n->as_Vector()->length() == 8 ||\n-                            n->as_Vector()->length() == 4));\n-  match(Set dst (ReplicateB src));\n-  ins_cost(INSN_COST);\n-  format %{ \"dup  $dst, $src\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ dup(as_FloatRegister($dst$$reg), __ T8B, as_Register($src$$reg));\n-  %}\n-  ins_pipe(vdup_reg_reg64);\n-%}\n-\n-instruct replicate16B(vecX dst, iRegIorL2I src)\n-%{\n-  predicate(UseSVE == 0 && n->as_Vector()->length() == 16);\n-  match(Set dst (ReplicateB src));\n-  ins_cost(INSN_COST);\n-  format %{ \"dup  $dst, $src\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ dup(as_FloatRegister($dst$$reg), __ T16B, as_Register($src$$reg));\n-  %}\n-  ins_pipe(vdup_reg_reg128);\n-%}\n-\n-instruct replicate8B_imm(vecD dst, immI con)\n-%{\n-  predicate(UseSVE == 0 && (n->as_Vector()->length() == 8 ||\n-                            n->as_Vector()->length() == 4));\n-  match(Set dst (ReplicateB con));\n-  ins_cost(INSN_COST);\n-  format %{ \"movi  $dst, $con\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ mov(as_FloatRegister($dst$$reg), __ T8B, $con$$constant & 0xff);\n-  %}\n-  ins_pipe(vmovi_reg_imm64);\n-%}\n-\n-instruct replicate16B_imm(vecX dst, immI con)\n-%{\n-  predicate(UseSVE == 0 && n->as_Vector()->length() == 16);\n-  match(Set dst (ReplicateB con));\n-  ins_cost(INSN_COST);\n-  format %{ \"movi  $dst, $con\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ mov(as_FloatRegister($dst$$reg), __ T16B, $con$$constant & 0xff);\n-  %}\n-  ins_pipe(vmovi_reg_imm128);\n-%}\n-\n-instruct replicate4S(vecD dst, iRegIorL2I src)\n-%{\n-  predicate(UseSVE == 0 && (n->as_Vector()->length() == 4 ||\n-                            n->as_Vector()->length() == 2));\n-  match(Set dst (ReplicateS src));\n-  ins_cost(INSN_COST);\n-  format %{ \"dup  $dst, $src\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ dup(as_FloatRegister($dst$$reg), __ T4H, as_Register($src$$reg));\n-  %}\n-  ins_pipe(vdup_reg_reg64);\n-%}\n-\n-instruct replicate8S(vecX dst, iRegIorL2I src)\n-%{\n-  predicate(UseSVE == 0 && n->as_Vector()->length() == 8);\n-  match(Set dst (ReplicateS src));\n-  ins_cost(INSN_COST);\n-  format %{ \"dup  $dst, $src\\t# vector (8S)\" %}\n-  ins_encode %{\n-    __ dup(as_FloatRegister($dst$$reg), __ T8H, as_Register($src$$reg));\n-  %}\n-  ins_pipe(vdup_reg_reg128);\n-%}\n-\n-instruct replicate4S_imm(vecD dst, immI con)\n-%{\n-  predicate(UseSVE == 0 && (n->as_Vector()->length() == 4 ||\n-                            n->as_Vector()->length() == 2));\n-  match(Set dst (ReplicateS con));\n-  ins_cost(INSN_COST);\n-  format %{ \"movi  $dst, $con\\t# vector (4H)\" %}\n-  ins_encode %{\n-    __ mov(as_FloatRegister($dst$$reg), __ T4H, $con$$constant & 0xffff);\n-  %}\n-  ins_pipe(vmovi_reg_imm64);\n-%}\n-\n-instruct replicate8S_imm(vecX dst, immI con)\n-%{\n-  predicate(UseSVE == 0 && n->as_Vector()->length() == 8);\n-  match(Set dst (ReplicateS con));\n-  ins_cost(INSN_COST);\n-  format %{ \"movi  $dst, $con\\t# vector (8H)\" %}\n-  ins_encode %{\n-    __ mov(as_FloatRegister($dst$$reg), __ T8H, $con$$constant & 0xffff);\n-  %}\n-  ins_pipe(vmovi_reg_imm128);\n-%}\n-\n-instruct replicate2I(vecD dst, iRegIorL2I src)\n-%{\n-  predicate(UseSVE == 0 && n->as_Vector()->length() == 2);\n-  match(Set dst (ReplicateI src));\n-  ins_cost(INSN_COST);\n-  format %{ \"dup  $dst, $src\\t# vector (2I)\" %}\n-  ins_encode %{\n-    __ dup(as_FloatRegister($dst$$reg), __ T2S, as_Register($src$$reg));\n-  %}\n-  ins_pipe(vdup_reg_reg64);\n-%}\n-\n-instruct replicate4I(vecX dst, iRegIorL2I src)\n-%{\n-  predicate(UseSVE == 0 && n->as_Vector()->length() == 4);\n-  match(Set dst (ReplicateI src));\n-  ins_cost(INSN_COST);\n-  format %{ \"dup  $dst, $src\\t# vector (4I)\" %}\n-  ins_encode %{\n-    __ dup(as_FloatRegister($dst$$reg), __ T4S, as_Register($src$$reg));\n-  %}\n-  ins_pipe(vdup_reg_reg128);\n-%}\n-\n-instruct replicate2I_imm(vecD dst, immI con)\n-%{\n-  predicate(UseSVE == 0 && n->as_Vector()->length() == 2);\n-  match(Set dst (ReplicateI con));\n-  ins_cost(INSN_COST);\n-  format %{ \"movi  $dst, $con\\t# vector (2I)\" %}\n-  ins_encode %{\n-    __ mov(as_FloatRegister($dst$$reg), __ T2S, $con$$constant);\n-  %}\n-  ins_pipe(vmovi_reg_imm64);\n-%}\n-\n-instruct replicate4I_imm(vecX dst, immI con)\n-%{\n-  predicate(UseSVE == 0 && n->as_Vector()->length() == 4);\n-  match(Set dst (ReplicateI con));\n-  ins_cost(INSN_COST);\n-  format %{ \"movi  $dst, $con\\t# vector (4I)\" %}\n-  ins_encode %{\n-    __ mov(as_FloatRegister($dst$$reg), __ T4S, $con$$constant);\n-  %}\n-  ins_pipe(vmovi_reg_imm128);\n-%}\n-\n-instruct replicate2L(vecX dst, iRegL src)\n-%{\n-  predicate(UseSVE == 0 && n->as_Vector()->length() == 2);\n-  match(Set dst (ReplicateL src));\n-  ins_cost(INSN_COST);\n-  format %{ \"dup  $dst, $src\\t# vector (2L)\" %}\n-  ins_encode %{\n-    __ dup(as_FloatRegister($dst$$reg), __ T2D, as_Register($src$$reg));\n-  %}\n-  ins_pipe(vdup_reg_reg128);\n-%}\n-\n-instruct replicate2L_imm(vecX dst, immL con)\n-%{\n-  predicate(UseSVE == 0 && n->as_Vector()->length() == 2);\n-  match(Set dst (ReplicateL con));\n-  ins_cost(INSN_COST);\n-  format %{ \"movi  $dst, $con\\t# vector (2L)\" %}\n-  ins_encode %{\n-    __ mov(as_FloatRegister($dst$$reg), __ T2D, $con$$constant);\n-  %}\n-  ins_pipe(vmovi_reg_imm128);\n-%}\n-\n-instruct replicate2F(vecD dst, vRegF src)\n-%{\n-  predicate(UseSVE == 0 && n->as_Vector()->length() == 2);\n-  match(Set dst (ReplicateF src));\n-  ins_cost(INSN_COST);\n-  format %{ \"dup  $dst, $src\\t# vector (2F)\" %}\n-  ins_encode %{\n-    __ dup(as_FloatRegister($dst$$reg), __ T2S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vdup_reg_freg64);\n-%}\n-\n-instruct replicate4F(vecX dst, vRegF src)\n-%{\n-  predicate(UseSVE == 0 && n->as_Vector()->length() == 4);\n-  match(Set dst (ReplicateF src));\n-  ins_cost(INSN_COST);\n-  format %{ \"dup  $dst, $src\\t# vector (4F)\" %}\n-  ins_encode %{\n-    __ dup(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vdup_reg_freg128);\n-%}\n-\n-instruct replicate2D(vecX dst, vRegD src)\n-%{\n-  predicate(UseSVE == 0 && n->as_Vector()->length() == 2);\n-  match(Set dst (ReplicateD src));\n-  ins_cost(INSN_COST);\n-  format %{ \"dup  $dst, $src\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ dup(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vdup_reg_dreg128);\n-%}\n-\n-\/\/ ====================REDUCTION ARITHMETIC====================================\n-\n-instruct reduce_add2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD vtmp, iRegINoSp itmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (AddReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP vtmp, TEMP itmp);\n-  format %{ \"addpv  $vtmp, T2S, $vsrc, $vsrc\\n\\t\"\n-            \"umov  $itmp, $vtmp, S, 0\\n\\t\"\n-            \"addw  $dst, $itmp, $isrc\\t# add reduction2I\"\n-  %}\n-  ins_encode %{\n-    __ addpv(as_FloatRegister($vtmp$$reg), __ T2S,\n-             as_FloatRegister($vsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 0);\n-    __ addw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_add4I(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp, iRegINoSp itmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (AddReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP vtmp, TEMP itmp);\n-  format %{ \"addv  $vtmp, T4S, $vsrc\\n\\t\"\n-            \"umov  $itmp, $vtmp, S, 0\\n\\t\"\n-            \"addw  $dst, $itmp, $isrc\\t# add reduction4I\"\n-  %}\n-  ins_encode %{\n-    __ addv(as_FloatRegister($vtmp$$reg), __ T4S,\n-            as_FloatRegister($vsrc$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 0);\n-    __ addw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_mul2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (MulReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp, TEMP dst);\n-  format %{ \"umov  $tmp, $vsrc, S, 0\\n\\t\"\n-            \"mul   $dst, $tmp, $isrc\\n\\t\"\n-            \"umov  $tmp, $vsrc, S, 1\\n\\t\"\n-            \"mul   $dst, $tmp, $dst\\t# mul reduction2I\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);\n-    __ mul($dst$$Register, $tmp$$Register, $isrc$$Register);\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);\n-    __ mul($dst$$Register, $tmp$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_mul4I(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp, iRegINoSp itmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (MulReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP vtmp, TEMP itmp, TEMP dst);\n-  format %{ \"ins   $vtmp, D, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp, T2S, $vtmp, $vsrc\\n\\t\"\n-            \"umov  $itmp, $vtmp, S, 0\\n\\t\"\n-            \"mul   $dst, $itmp, $isrc\\n\\t\"\n-            \"umov  $itmp, $vtmp, S, 1\\n\\t\"\n-            \"mul   $dst, $itmp, $dst\\t# mul reduction4I\"\n-  %}\n-  ins_encode %{\n-    __ ins(as_FloatRegister($vtmp$$reg), __ D,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp$$reg), __ T2S,\n-            as_FloatRegister($vtmp$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 0);\n-    __ mul($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 1);\n-    __ mul($dst$$Register, $itmp$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_add2F(vRegF dst, vRegF fsrc, vecD vsrc, vecD tmp)\n-%{\n-  match(Set dst (AddReductionVF fsrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp, TEMP dst);\n-  format %{ \"fadds $dst, $fsrc, $vsrc\\n\\t\"\n-            \"ins   $tmp, S, $vsrc, 0, 1\\n\\t\"\n-            \"fadds $dst, $dst, $tmp\\t# add reduction2F\"\n-  %}\n-  ins_encode %{\n-    __ fadds(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($fsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ fadds(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_add4F(vRegF dst, vRegF fsrc, vecX vsrc, vecX tmp)\n-%{\n-  match(Set dst (AddReductionVF fsrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp, TEMP dst);\n-  format %{ \"fadds $dst, $fsrc, $vsrc\\n\\t\"\n-            \"ins   $tmp, S, $vsrc, 0, 1\\n\\t\"\n-            \"fadds $dst, $dst, $tmp\\n\\t\"\n-            \"ins   $tmp, S, $vsrc, 0, 2\\n\\t\"\n-            \"fadds $dst, $dst, $tmp\\n\\t\"\n-            \"ins   $tmp, S, $vsrc, 0, 3\\n\\t\"\n-            \"fadds $dst, $dst, $tmp\\t# add reduction4F\"\n-  %}\n-  ins_encode %{\n-    __ fadds(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($fsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ fadds(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 2);\n-    __ fadds(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 3);\n-    __ fadds(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_mul2F(vRegF dst, vRegF fsrc, vecD vsrc, vecD tmp)\n-%{\n-  match(Set dst (MulReductionVF fsrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp, TEMP dst);\n-  format %{ \"fmuls $dst, $fsrc, $vsrc\\n\\t\"\n-            \"ins   $tmp, S, $vsrc, 0, 1\\n\\t\"\n-            \"fmuls $dst, $dst, $tmp\\t# mul reduction2F\"\n-  %}\n-  ins_encode %{\n-    __ fmuls(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($fsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ fmuls(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_mul4F(vRegF dst, vRegF fsrc, vecX vsrc, vecX tmp)\n-%{\n-  match(Set dst (MulReductionVF fsrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp, TEMP dst);\n-  format %{ \"fmuls $dst, $fsrc, $vsrc\\n\\t\"\n-            \"ins   $tmp, S, $vsrc, 0, 1\\n\\t\"\n-            \"fmuls $dst, $dst, $tmp\\n\\t\"\n-            \"ins   $tmp, S, $vsrc, 0, 2\\n\\t\"\n-            \"fmuls $dst, $dst, $tmp\\n\\t\"\n-            \"ins   $tmp, S, $vsrc, 0, 3\\n\\t\"\n-            \"fmuls $dst, $dst, $tmp\\t# mul reduction4F\"\n-  %}\n-  ins_encode %{\n-    __ fmuls(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($fsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ fmuls(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 2);\n-    __ fmuls(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 3);\n-    __ fmuls(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_add2D(vRegD dst, vRegD dsrc, vecX vsrc, vecX tmp)\n-%{\n-  match(Set dst (AddReductionVD dsrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp, TEMP dst);\n-  format %{ \"faddd $dst, $dsrc, $vsrc\\n\\t\"\n-            \"ins   $tmp, D, $vsrc, 0, 1\\n\\t\"\n-            \"faddd $dst, $dst, $tmp\\t# add reduction2D\"\n-  %}\n-  ins_encode %{\n-    __ faddd(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ D,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ faddd(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_mul2D(vRegD dst, vRegD dsrc, vecX vsrc, vecX tmp)\n-%{\n-  match(Set dst (MulReductionVD dsrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp, TEMP dst);\n-  format %{ \"fmuld $dst, $dsrc, $vsrc\\n\\t\"\n-            \"ins   $tmp, D, $vsrc, 0, 1\\n\\t\"\n-            \"fmuld $dst, $dst, $tmp\\t# mul reduction2D\"\n-  %}\n-  ins_encode %{\n-    __ fmuld(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ D,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ fmuld(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-\/\/ ====================VECTOR ARITHMETIC=======================================\n-\n-\/\/ --------------------------------- ADD --------------------------------------\n-\n-instruct vadd8B(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 4 ||\n-            n->as_Vector()->length() == 8);\n-  match(Set dst (AddVB src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"addv  $dst,$src1,$src2\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ addv(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vadd16B(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 16);\n-  match(Set dst (AddVB src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"addv  $dst,$src1,$src2\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ addv(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vadd4S(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2 ||\n-            n->as_Vector()->length() == 4);\n-  match(Set dst (AddVS src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"addv  $dst,$src1,$src2\\t# vector (4H)\" %}\n-  ins_encode %{\n-    __ addv(as_FloatRegister($dst$$reg), __ T4H,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vadd8S(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 8);\n-  match(Set dst (AddVS src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"addv  $dst,$src1,$src2\\t# vector (8H)\" %}\n-  ins_encode %{\n-    __ addv(as_FloatRegister($dst$$reg), __ T8H,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vadd2I(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (AddVI src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"addv  $dst,$src1,$src2\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ addv(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vadd4I(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (AddVI src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"addv  $dst,$src1,$src2\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ addv(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vadd2L(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (AddVL src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"addv  $dst,$src1,$src2\\t# vector (2L)\" %}\n-  ins_encode %{\n-    __ addv(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vadd2F(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (AddVF src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"fadd  $dst,$src1,$src2\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ fadd(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop_fp64);\n-%}\n-\n-instruct vadd4F(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (AddVF src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"fadd  $dst,$src1,$src2\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ fadd(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop_fp128);\n-%}\n-\n-instruct vadd2D(vecX dst, vecX src1, vecX src2)\n-%{\n-  match(Set dst (AddVD src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"fadd  $dst,$src1,$src2\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ fadd(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop_fp128);\n-%}\n-\n-\/\/ --------------------------------- SUB --------------------------------------\n-\n-instruct vsub8B(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 4 ||\n-            n->as_Vector()->length() == 8);\n-  match(Set dst (SubVB src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"subv  $dst,$src1,$src2\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ subv(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vsub16B(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 16);\n-  match(Set dst (SubVB src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"subv  $dst,$src1,$src2\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ subv(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vsub4S(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2 ||\n-            n->as_Vector()->length() == 4);\n-  match(Set dst (SubVS src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"subv  $dst,$src1,$src2\\t# vector (4H)\" %}\n-  ins_encode %{\n-    __ subv(as_FloatRegister($dst$$reg), __ T4H,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vsub8S(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 8);\n-  match(Set dst (SubVS src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"subv  $dst,$src1,$src2\\t# vector (8H)\" %}\n-  ins_encode %{\n-    __ subv(as_FloatRegister($dst$$reg), __ T8H,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vsub2I(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (SubVI src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"subv  $dst,$src1,$src2\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ subv(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vsub4I(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (SubVI src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"subv  $dst,$src1,$src2\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ subv(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vsub2L(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (SubVL src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"subv  $dst,$src1,$src2\\t# vector (2L)\" %}\n-  ins_encode %{\n-    __ subv(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vsub2F(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (SubVF src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"fsub  $dst,$src1,$src2\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ fsub(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop_fp64);\n-%}\n-\n-instruct vsub4F(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (SubVF src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"fsub  $dst,$src1,$src2\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ fsub(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop_fp128);\n-%}\n-\n-instruct vsub2D(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (SubVD src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"fsub  $dst,$src1,$src2\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ fsub(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop_fp128);\n-%}\n-\n-\/\/ --------------------------------- MUL --------------------------------------\n-\n-instruct vmul8B(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 4 ||\n-            n->as_Vector()->length() == 8);\n-  match(Set dst (MulVB src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"mulv  $dst,$src1,$src2\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ mulv(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmul64);\n-%}\n-\n-instruct vmul16B(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 16);\n-  match(Set dst (MulVB src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"mulv  $dst,$src1,$src2\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ mulv(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmul128);\n-%}\n-\n-instruct vmul4S(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2 ||\n-            n->as_Vector()->length() == 4);\n-  match(Set dst (MulVS src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"mulv  $dst,$src1,$src2\\t# vector (4H)\" %}\n-  ins_encode %{\n-    __ mulv(as_FloatRegister($dst$$reg), __ T4H,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmul64);\n-%}\n-\n-instruct vmul8S(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 8);\n-  match(Set dst (MulVS src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"mulv  $dst,$src1,$src2\\t# vector (8H)\" %}\n-  ins_encode %{\n-    __ mulv(as_FloatRegister($dst$$reg), __ T8H,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmul128);\n-%}\n-\n-instruct vmul2I(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (MulVI src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"mulv  $dst,$src1,$src2\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ mulv(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmul64);\n-%}\n-\n-instruct vmul4I(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (MulVI src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"mulv  $dst,$src1,$src2\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ mulv(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmul128);\n-%}\n-\n-instruct vmul2F(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (MulVF src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"fmul  $dst,$src1,$src2\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ fmul(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmuldiv_fp64);\n-%}\n-\n-instruct vmul4F(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (MulVF src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"fmul  $dst,$src1,$src2\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ fmul(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmuldiv_fp128);\n-%}\n-\n-instruct vmul2D(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (MulVD src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"fmul  $dst,$src1,$src2\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ fmul(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmuldiv_fp128);\n-%}\n-\n-\/\/ --------------------------------- MLA --------------------------------------\n-\n-instruct vmla4S(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2 ||\n-            n->as_Vector()->length() == 4);\n-  match(Set dst (AddVS dst (MulVS src1 src2)));\n-  ins_cost(INSN_COST);\n-  format %{ \"mlav  $dst,$src1,$src2\\t# vector (4H)\" %}\n-  ins_encode %{\n-    __ mlav(as_FloatRegister($dst$$reg), __ T4H,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmla64);\n-%}\n-\n-instruct vmla8S(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 8);\n-  match(Set dst (AddVS dst (MulVS src1 src2)));\n-  ins_cost(INSN_COST);\n-  format %{ \"mlav  $dst,$src1,$src2\\t# vector (8H)\" %}\n-  ins_encode %{\n-    __ mlav(as_FloatRegister($dst$$reg), __ T8H,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmla128);\n-%}\n-\n-instruct vmla2I(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (AddVI dst (MulVI src1 src2)));\n-  ins_cost(INSN_COST);\n-  format %{ \"mlav  $dst,$src1,$src2\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ mlav(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmla64);\n-%}\n-\n-instruct vmla4I(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (AddVI dst (MulVI src1 src2)));\n-  ins_cost(INSN_COST);\n-  format %{ \"mlav  $dst,$src1,$src2\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ mlav(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmla128);\n-%}\n-\n-\/\/ dst + src1 * src2\n-instruct vmla2F(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(UseFMA && n->as_Vector()->length() == 2);\n-  match(Set dst (FmaVF  dst (Binary src1 src2)));\n-  ins_cost(INSN_COST);\n-  format %{ \"fmla  $dst,$src1,$src2\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ fmla(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmuldiv_fp64);\n-%}\n-\n-\/\/ dst + src1 * src2\n-instruct vmla4F(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(UseFMA && n->as_Vector()->length() == 4);\n-  match(Set dst (FmaVF  dst (Binary src1 src2)));\n-  ins_cost(INSN_COST);\n-  format %{ \"fmla  $dst,$src1,$src2\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ fmla(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmuldiv_fp128);\n-%}\n-\n-\/\/ dst + src1 * src2\n-instruct vmla2D(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(UseFMA && n->as_Vector()->length() == 2);\n-  match(Set dst (FmaVD  dst (Binary src1 src2)));\n-  ins_cost(INSN_COST);\n-  format %{ \"fmla  $dst,$src1,$src2\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ fmla(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmuldiv_fp128);\n-%}\n-\n-\/\/ --------------------------------- MLS --------------------------------------\n-\n-instruct vmls4S(vecD dst, vecD src1, vecD src2) %{\n-  predicate(n->as_Vector()->length() == 2 ||\n-            n->as_Vector()->length() == 4);\n-  match(Set dst (SubVS dst (MulVS src1 src2)));\n-  ins_cost(INSN_COST);\n-  format %{ \"mlsv  $dst,$src1,$src2\\t# vector (4H)\" %}\n-  ins_encode %{\n-    __ mlsv(as_FloatRegister($dst$$reg), __ T4H,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmla64);\n-%}\n-\n-instruct vmls8S(vecX dst, vecX src1, vecX src2) %{\n-  predicate(n->as_Vector()->length() == 8);\n-  match(Set dst (SubVS dst (MulVS src1 src2)));\n-  ins_cost(INSN_COST);\n-  format %{ \"mlsv  $dst,$src1,$src2\\t# vector (8H)\" %}\n-  ins_encode %{\n-    __ mlsv(as_FloatRegister($dst$$reg), __ T8H,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmla128);\n-%}\n-\n-instruct vmls2I(vecD dst, vecD src1, vecD src2) %{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (SubVI dst (MulVI src1 src2)));\n-  ins_cost(INSN_COST);\n-  format %{ \"mlsv  $dst,$src1,$src2\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ mlsv(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmla64);\n-%}\n-\n-instruct vmls4I(vecX dst, vecX src1, vecX src2) %{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (SubVI dst (MulVI src1 src2)));\n-  ins_cost(INSN_COST);\n-  format %{ \"mlsv  $dst,$src1,$src2\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ mlsv(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmla128);\n-%}\n-\n-\/\/ dst - src1 * src2\n-instruct vmls2F(vecD dst, vecD src1, vecD src2) %{\n-  predicate(UseFMA && n->as_Vector()->length() == 2);\n-  match(Set dst (FmaVF  dst (Binary (NegVF src1) src2)));\n-  match(Set dst (FmaVF  dst (Binary src1 (NegVF src2))));\n-  ins_cost(INSN_COST);\n-  format %{ \"fmls  $dst,$src1,$src2\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ fmls(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmuldiv_fp64);\n-%}\n-\n-\/\/ dst - src1 * src2\n-instruct vmls4F(vecX dst, vecX src1, vecX src2) %{\n-  predicate(UseFMA && n->as_Vector()->length() == 4);\n-  match(Set dst (FmaVF  dst (Binary (NegVF src1) src2)));\n-  match(Set dst (FmaVF  dst (Binary src1 (NegVF src2))));\n-  ins_cost(INSN_COST);\n-  format %{ \"fmls  $dst,$src1,$src2\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ fmls(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmuldiv_fp128);\n-%}\n-\n-\/\/ dst - src1 * src2\n-instruct vmls2D(vecX dst, vecX src1, vecX src2) %{\n-  predicate(UseFMA && n->as_Vector()->length() == 2);\n-  match(Set dst (FmaVD  dst (Binary (NegVD src1) src2)));\n-  match(Set dst (FmaVD  dst (Binary src1 (NegVD src2))));\n-  ins_cost(INSN_COST);\n-  format %{ \"fmls  $dst,$src1,$src2\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ fmls(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmuldiv_fp128);\n-%}\n-\n-\/\/ --------------- Vector Multiply-Add Shorts into Integer --------------------\n-\n-instruct vmuladdS2I(vecX dst, vecX src1, vecX src2, vecX tmp) %{\n-  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (MulAddVS2VI src1 src2));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"smullv  $tmp, $src1, $src2\\t# vector (4H)\\n\\t\"\n-            \"smullv  $dst, $src1, $src2\\t# vector (8H)\\n\\t\"\n-            \"addpv   $dst, $tmp, $dst\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ smullv(as_FloatRegister($tmp$$reg), __ T4H,\n-              as_FloatRegister($src1$$reg),\n-              as_FloatRegister($src2$$reg));\n-    __ smullv(as_FloatRegister($dst$$reg), __ T8H,\n-              as_FloatRegister($src1$$reg),\n-              as_FloatRegister($src2$$reg));\n-    __ addpv(as_FloatRegister($dst$$reg), __ T4S,\n-             as_FloatRegister($tmp$$reg),\n-             as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(vmuldiv_fp128);\n-%}\n-\n-\/\/ --------------------------------- DIV --------------------------------------\n-\n-instruct vdiv2F(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (DivVF src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"fdiv  $dst,$src1,$src2\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ fdiv(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmuldiv_fp64);\n-%}\n-\n-instruct vdiv4F(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (DivVF src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"fdiv  $dst,$src1,$src2\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ fdiv(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmuldiv_fp128);\n-%}\n-\n-instruct vdiv2D(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (DivVD src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"fdiv  $dst,$src1,$src2\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ fdiv(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmuldiv_fp128);\n-%}\n-\n-\/\/ --------------------------------- SQRT -------------------------------------\n-\n-instruct vsqrt2F(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (SqrtVF src));\n-  format %{ \"fsqrt  $dst, $src\\t# vector (2F)\" %}\n-  ins_encode %{\n-    __ fsqrt(as_FloatRegister($dst$$reg), __ T2S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vunop_fp64);\n-%}\n-\n-instruct vsqrt4F(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (SqrtVF src));\n-  format %{ \"fsqrt  $dst, $src\\t# vector (4F)\" %}\n-  ins_encode %{\n-    __ fsqrt(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vsqrt_fp128);\n-%}\n-\n-instruct vsqrt2D(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (SqrtVD src));\n-  format %{ \"fsqrt  $dst, $src\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ fsqrt(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vsqrt_fp128);\n-%}\n-\n-\/\/ --------------------------------- NEG --------------------------------------\n-\n-instruct vnegID(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() < 16);\n-  match(Set dst (NegVI src));\n-  ins_cost(INSN_COST);\n-  format %{ \"negr  $dst, $src\\t# vector (8B\/4H\/2S)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_Arrangement size = __ esize2arrangement((unsigned)type2aelembytes(bt), false);\n-    __ negr(as_FloatRegister($dst$$reg), size, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vunop_fp64);\n-%}\n-\n-instruct vnegIX(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (NegVI src));\n-  ins_cost(INSN_COST);\n-  format %{ \"negr  $dst, $src\\t# vector (16B\/8H\/4S)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_Arrangement size = __ esize2arrangement((unsigned)type2aelembytes(bt), true);\n-    __ negr(as_FloatRegister($dst$$reg), size, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vunop_fp128);\n-%}\n-\n-instruct vneg2L(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (NegVL src));\n-  ins_cost(INSN_COST);\n-  format %{ \"negr  $dst,$src\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vunop_fp128);\n-%}\n-\n-instruct vneg2F(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (NegVF src));\n-  ins_cost(INSN_COST * 3);\n-  format %{ \"fneg  $dst,$src\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ fneg(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vunop_fp64);\n-%}\n-\n-instruct vneg4F(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (NegVF src));\n-  ins_cost(INSN_COST * 3);\n-  format %{ \"fneg  $dst,$src\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ fneg(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vunop_fp128);\n-%}\n-\n-instruct vneg2D(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (NegVD src));\n-  ins_cost(INSN_COST * 3);\n-  format %{ \"fneg  $dst,$src\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ fneg(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vunop_fp128);\n-%}\n-\n-\/\/ --------------------------------- AND --------------------------------------\n-\n-instruct vand8B(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 4 ||\n-            n->as_Vector()->length_in_bytes() == 8);\n-  match(Set dst (AndV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"and  $dst,$src1,$src2\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ andr(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vlogical64);\n-%}\n-\n-instruct vand16B(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (AndV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"and  $dst,$src1,$src2\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ andr(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vlogical128);\n-%}\n-\n-\/\/ --------------------------------- OR ---------------------------------------\n-\n-instruct vor8B(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 4 ||\n-            n->as_Vector()->length_in_bytes() == 8);\n-  match(Set dst (OrV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"orr  $dst,$src1,$src2\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ orr(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vlogical64);\n-%}\n-\n-instruct vor16B(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (OrV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"orr  $dst,$src1,$src2\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ orr(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vlogical128);\n-%}\n-\n-\/\/ --------------------------------- XOR --------------------------------------\n-\n-instruct vxor8B(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 4 ||\n-            n->as_Vector()->length_in_bytes() == 8);\n-  match(Set dst (XorV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"xor  $dst,$src1,$src2\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ eor(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vlogical64);\n-%}\n-\n-instruct vxor16B(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (XorV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"xor  $dst,$src1,$src2\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ eor(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vlogical128);\n-%}\n-\n-\/\/ ------------------------------ Shift ---------------------------------------\n-\n-\/\/ Vector shift count\n-\/\/ Note-1: Low 8 bits of each element are used, so it doesn't matter if we\n-\/\/         treat it as ints or bytes here.\n-\/\/ Note-2: Shift value is negated for RShiftCntV additionally. See the comments\n-\/\/         on vsra8B rule for more details.\n-\n-instruct vslcnt8B(vecD dst, iRegIorL2I cnt) %{\n-  predicate(UseSVE == 0 && (n->as_Vector()->length_in_bytes() == 4 ||\n-                            n->as_Vector()->length_in_bytes() == 8));\n-  match(Set dst (LShiftCntV cnt));\n-  ins_cost(INSN_COST);\n-  format %{ \"dup  $dst, $cnt\\t# shift count vector (8B)\" %}\n-  ins_encode %{\n-    __ dup(as_FloatRegister($dst$$reg), __ T8B, as_Register($cnt$$reg));\n-  %}\n-  ins_pipe(vdup_reg_reg64);\n-%}\n-\n-instruct vslcnt16B(vecX dst, iRegIorL2I cnt) %{\n-  predicate(UseSVE == 0 && n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (LShiftCntV cnt));\n-  ins_cost(INSN_COST);\n-  format %{ \"dup  $dst, $cnt\\t# shift count vector (16B)\" %}\n-  ins_encode %{\n-    __ dup(as_FloatRegister($dst$$reg), __ T16B, as_Register($cnt$$reg));\n-  %}\n-  ins_pipe(vdup_reg_reg128);\n-%}\n-\n-instruct vsrcnt8B(vecD dst, iRegIorL2I cnt) %{\n-  predicate(UseSVE == 0 && (n->as_Vector()->length_in_bytes() == 4 ||\n-                            n->as_Vector()->length_in_bytes() == 8));\n-  match(Set dst (RShiftCntV cnt));\n-  ins_cost(INSN_COST * 2);\n-  format %{ \"negw  rscratch1, $cnt\\t\"\n-            \"dup   $dst, rscratch1\\t# shift count vector (8B)\" %}\n-  ins_encode %{\n-    __ negw(rscratch1, as_Register($cnt$$reg));\n-    __ dup(as_FloatRegister($dst$$reg), __ T8B, rscratch1);\n-  %}\n-  ins_pipe(vdup_reg_reg64);\n-%}\n-\n-instruct vsrcnt16B(vecX dst, iRegIorL2I cnt) %{\n-  predicate(UseSVE == 0 && n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (RShiftCntV cnt));\n-  ins_cost(INSN_COST * 2);\n-  format %{ \"negw  rscratch1, $cnt\\t\"\n-            \"dup   $dst, rscratch1\\t# shift count vector (16B)\" %}\n-  ins_encode %{\n-    __ negw(rscratch1, as_Register($cnt$$reg));\n-    __ dup(as_FloatRegister($dst$$reg), __ T16B, rscratch1);\n-  %}\n-  ins_pipe(vdup_reg_reg128);\n-%}\n-\n-instruct vsll8B(vecD dst, vecD src, vecD shift) %{\n-  predicate(n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8);\n-  match(Set dst (LShiftVB src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshl  $dst,$src,$shift\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ sshl(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift64);\n-%}\n-\n-instruct vsll16B(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 16);\n-  match(Set dst (LShiftVB src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshl  $dst,$src,$shift\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ sshl(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-\/\/ Right shifts with vector shift count on aarch64 SIMD are implemented\n-\/\/ as left shift by negative shift count.\n-\/\/ There are two cases for vector shift count.\n-\/\/\n-\/\/ Case 1: The vector shift count is from replication.\n-\/\/        |            |\n-\/\/    LoadVector  RShiftCntV\n-\/\/        |       \/\n-\/\/     RShiftVI\n-\/\/\n-\/\/ Case 2: The vector shift count is from loading.\n-\/\/ This case isn't supported by middle-end now. But it's supported by\n-\/\/ panama\/vectorIntrinsics(JEP 338: Vector API).\n-\/\/        |            |\n-\/\/    LoadVector  LoadVector\n-\/\/        |       \/\n-\/\/     RShiftVI\n-\/\/\n-\/\/ The negate is conducted in RShiftCntV rule for case 1, whereas it's done in\n-\/\/ RShiftV* rules for case 2. Because there exists an optimization opportunity\n-\/\/ for case 1, that is, multiple neg instructions in inner loop can be hoisted\n-\/\/ to outer loop and merged into one neg instruction.\n-\/\/\n-\/\/ Note that ShiftVNode::is_var_shift() indicates whether the vector shift\n-\/\/ count is a variable vector(case 2) or not(a vector generated by RShiftCntV,\n-\/\/ i.e. case 1).\n-\n-instruct vsra8B(vecD dst, vecD src, vecD shift) %{\n-  predicate((n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8) &&\n-            !n->as_ShiftV()->is_var_shift());\n-  match(Set dst (RShiftVB src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshl  $dst,$src,$shift\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ sshl(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift64);\n-%}\n-\n-instruct vsra8B_var(vecD dst, vecD src, vecD shift) %{\n-  predicate((n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8) &&\n-            n->as_ShiftV()->is_var_shift());\n-  match(Set dst (RShiftVB src shift));\n-  ins_cost(INSN_COST * 2);\n-  effect(TEMP_DEF dst);\n-  format %{ \"negr  $dst,$shift\\t\"\n-            \"sshl  $dst,$src,$dst\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($shift$$reg));\n-    __ sshl(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(vshift64);\n-%}\n-\n-instruct vsra16B(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 16 && !n->as_ShiftV()->is_var_shift());\n-  match(Set dst (RShiftVB src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshl  $dst,$src,$shift\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ sshl(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsra16B_var(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 16 && n->as_ShiftV()->is_var_shift());\n-  match(Set dst (RShiftVB src shift));\n-  ins_cost(INSN_COST * 2);\n-  effect(TEMP_DEF dst);\n-  format %{ \"negr  $dst,$shift\\t\"\n-            \"sshl  $dst,$src,$dst\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($shift$$reg));\n-    __ sshl(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsrl8B(vecD dst, vecD src, vecD shift) %{\n-  predicate((n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8) &&\n-            !n->as_ShiftV()->is_var_shift());\n-  match(Set dst (URShiftVB src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"ushl  $dst,$src,$shift\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ ushl(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift64);\n-%}\n-\n-instruct vsrl8B_var(vecD dst, vecD src, vecD shift) %{\n-  predicate((n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8) &&\n-            n->as_ShiftV()->is_var_shift());\n-  match(Set dst (URShiftVB src shift));\n-  ins_cost(INSN_COST * 2);\n-  effect(TEMP_DEF dst);\n-  format %{ \"negr  $dst,$shift\\t\"\n-            \"ushl  $dst,$src,$dst\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($shift$$reg));\n-    __ ushl(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(vshift64);\n-%}\n-\n-instruct vsrl16B(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 16 && !n->as_ShiftV()->is_var_shift());\n-  match(Set dst (URShiftVB src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"ushl  $dst,$src,$shift\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ ushl(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsrl16B_var(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 16 && n->as_ShiftV()->is_var_shift());\n-  match(Set dst (URShiftVB src shift));\n-  ins_cost(INSN_COST * 2);\n-  effect(TEMP_DEF dst);\n-  format %{ \"negr  $dst,$shift\\t\"\n-            \"ushl  $dst,$src,$dst\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($shift$$reg));\n-    __ ushl(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsll8B_imm(vecD dst, vecD src, immI shift) %{\n-  predicate((n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8) &&\n-            assert_not_var_shift(n));\n-  match(Set dst (LShiftVB src (LShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"shl  $dst, $src, $shift\\t# vector (8B)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 8) {\n-      __ eor(as_FloatRegister($dst$$reg), __ T8B,\n-             as_FloatRegister($src$$reg),\n-             as_FloatRegister($src$$reg));\n-    } else {\n-      __ shl(as_FloatRegister($dst$$reg), __ T8B,\n-             as_FloatRegister($src$$reg), sh);\n-    }\n-  %}\n-  ins_pipe(vshift64_imm);\n-%}\n-\n-instruct vsll16B_imm(vecX dst, vecX src, immI shift) %{\n-  predicate(n->as_Vector()->length() == 16 && assert_not_var_shift(n));\n-  match(Set dst (LShiftVB src (LShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"shl  $dst, $src, $shift\\t# vector (16B)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 8) {\n-      __ eor(as_FloatRegister($dst$$reg), __ T16B,\n-             as_FloatRegister($src$$reg),\n-             as_FloatRegister($src$$reg));\n-    } else {\n-      __ shl(as_FloatRegister($dst$$reg), __ T16B,\n-             as_FloatRegister($src$$reg), sh);\n-    }\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsra8B_imm(vecD dst, vecD src, immI_positive shift) %{\n-  predicate((n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8) &&\n-            assert_not_var_shift(n));\n-  match(Set dst (RShiftVB src (RShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshr  $dst, $src, $shift\\t# vector (8B)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 8) sh = 7;\n-    __ sshr(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src$$reg), sh);\n-  %}\n-  ins_pipe(vshift64_imm);\n-%}\n-\n-instruct vsra16B_imm(vecX dst, vecX src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 16 && assert_not_var_shift(n));\n-  match(Set dst (RShiftVB src (RShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshr  $dst, $src, $shift\\t# vector (16B)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 8) sh = 7;\n-    __ sshr(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src$$reg), sh);\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsrl8B_imm(vecD dst, vecD src, immI_positive shift) %{\n-  predicate((n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8) &&\n-            assert_not_var_shift(n));\n-  match(Set dst (URShiftVB src (RShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"ushr  $dst, $src, $shift\\t# vector (8B)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 8) {\n-      __ eor(as_FloatRegister($dst$$reg), __ T8B,\n-             as_FloatRegister($src$$reg),\n-             as_FloatRegister($src$$reg));\n-    } else {\n-      __ ushr(as_FloatRegister($dst$$reg), __ T8B,\n-              as_FloatRegister($src$$reg), sh);\n-    }\n-  %}\n-  ins_pipe(vshift64_imm);\n-%}\n-\n-instruct vsrl16B_imm(vecX dst, vecX src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 16 && assert_not_var_shift(n));\n-  match(Set dst (URShiftVB src (RShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"ushr  $dst, $src, $shift\\t# vector (16B)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 8) {\n-      __ eor(as_FloatRegister($dst$$reg), __ T16B,\n-             as_FloatRegister($src$$reg),\n-             as_FloatRegister($src$$reg));\n-    } else {\n-      __ ushr(as_FloatRegister($dst$$reg), __ T16B,\n-              as_FloatRegister($src$$reg), sh);\n-    }\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsll4S(vecD dst, vecD src, vecD shift) %{\n-  predicate(n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4);\n-  match(Set dst (LShiftVS src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshl  $dst,$src,$shift\\t# vector (4H)\" %}\n-  ins_encode %{\n-    __ sshl(as_FloatRegister($dst$$reg), __ T4H,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift64);\n-%}\n-\n-instruct vsll8S(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 8);\n-  match(Set dst (LShiftVS src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshl  $dst,$src,$shift\\t# vector (8H)\" %}\n-  ins_encode %{\n-    __ sshl(as_FloatRegister($dst$$reg), __ T8H,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsra4S(vecD dst, vecD src, vecD shift) %{\n-  predicate((n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4) &&\n-            !n->as_ShiftV()->is_var_shift());\n-  match(Set dst (RShiftVS src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshl  $dst,$src,$shift\\t# vector (4H)\" %}\n-  ins_encode %{\n-    __ sshl(as_FloatRegister($dst$$reg), __ T4H,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift64);\n-%}\n-\n-instruct vsra4S_var(vecD dst, vecD src, vecD shift) %{\n-  predicate((n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4) &&\n-            n->as_ShiftV()->is_var_shift());\n-  match(Set dst (RShiftVS src shift));\n-  ins_cost(INSN_COST * 2);\n-  effect(TEMP_DEF dst);\n-  format %{ \"negr  $dst,$shift\\t\"\n-            \"sshl  $dst,$src,$dst\\t# vector (4H)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($shift$$reg));\n-    __ sshl(as_FloatRegister($dst$$reg), __ T4H,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(vshift64);\n-%}\n-\n-instruct vsra8S(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 8 && !n->as_ShiftV()->is_var_shift());\n-  match(Set dst (RShiftVS src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshl  $dst,$src,$shift\\t# vector (8H)\" %}\n-  ins_encode %{\n-    __ sshl(as_FloatRegister($dst$$reg), __ T8H,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsra8S_var(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 8 && n->as_ShiftV()->is_var_shift());\n-  match(Set dst (RShiftVS src shift));\n-  ins_cost(INSN_COST * 2);\n-  effect(TEMP_DEF dst);\n-  format %{ \"negr  $dst,$shift\\t\"\n-            \"sshl  $dst,$src,$dst\\t# vector (8H)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($shift$$reg));\n-    __ sshl(as_FloatRegister($dst$$reg), __ T8H,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsrl4S(vecD dst, vecD src, vecD shift) %{\n-  predicate((n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4) &&\n-            !n->as_ShiftV()->is_var_shift());\n-  match(Set dst (URShiftVS src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"ushl  $dst,$src,$shift\\t# vector (4H)\" %}\n-  ins_encode %{\n-    __ ushl(as_FloatRegister($dst$$reg), __ T4H,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift64);\n-%}\n-\n-instruct vsrl4S_var(vecD dst, vecD src, vecD shift) %{\n-  predicate((n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4) &&\n-            n->as_ShiftV()->is_var_shift());\n-  match(Set dst (URShiftVS src shift));\n-  ins_cost(INSN_COST * 2);\n-  effect(TEMP_DEF dst);\n-  format %{ \"negr  $dst,$shift\\t\"\n-            \"ushl  $dst,$src,$dst\\t# vector (4H)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($shift$$reg));\n-    __ ushl(as_FloatRegister($dst$$reg), __ T4H,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(vshift64);\n-%}\n-\n-instruct vsrl8S(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 8 && !n->as_ShiftV()->is_var_shift());\n-  match(Set dst (URShiftVS src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"ushl  $dst,$src,$shift\\t# vector (8H)\" %}\n-  ins_encode %{\n-    __ ushl(as_FloatRegister($dst$$reg), __ T8H,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsrl8S_var(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 8 && n->as_ShiftV()->is_var_shift());\n-  match(Set dst (URShiftVS src shift));\n-  ins_cost(INSN_COST * 2);\n-  effect(TEMP_DEF dst);\n-  format %{ \"negr  $dst,$shift\\t\"\n-            \"ushl  $dst,$src,$dst\\t# vector (8H)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($shift$$reg));\n-    __ ushl(as_FloatRegister($dst$$reg), __ T8H,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsll4S_imm(vecD dst, vecD src, immI shift) %{\n-  predicate((n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4) &&\n-            assert_not_var_shift(n));\n-  match(Set dst (LShiftVS src (LShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"shl  $dst, $src, $shift\\t# vector (4H)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 16) {\n-      __ eor(as_FloatRegister($dst$$reg), __ T8B,\n-             as_FloatRegister($src$$reg),\n-             as_FloatRegister($src$$reg));\n-    } else {\n-      __ shl(as_FloatRegister($dst$$reg), __ T4H,\n-             as_FloatRegister($src$$reg), sh);\n-    }\n-  %}\n-  ins_pipe(vshift64_imm);\n-%}\n-\n-instruct vsll8S_imm(vecX dst, vecX src, immI shift) %{\n-  predicate(n->as_Vector()->length() == 8 && assert_not_var_shift(n));\n-  match(Set dst (LShiftVS src (LShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"shl  $dst, $src, $shift\\t# vector (8H)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 16) {\n-      __ eor(as_FloatRegister($dst$$reg), __ T16B,\n-             as_FloatRegister($src$$reg),\n-             as_FloatRegister($src$$reg));\n-    } else {\n-      __ shl(as_FloatRegister($dst$$reg), __ T8H,\n-             as_FloatRegister($src$$reg), sh);\n-    }\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsra4S_imm(vecD dst, vecD src, immI_positive shift) %{\n-  predicate((n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4) &&\n-            assert_not_var_shift(n));\n-  match(Set dst (RShiftVS src (RShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshr  $dst, $src, $shift\\t# vector (4H)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 16) sh = 15;\n-    __ sshr(as_FloatRegister($dst$$reg), __ T4H,\n-            as_FloatRegister($src$$reg), sh);\n-  %}\n-  ins_pipe(vshift64_imm);\n-%}\n-\n-instruct vsra8S_imm(vecX dst, vecX src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 8 && assert_not_var_shift(n));\n-  match(Set dst (RShiftVS src (RShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshr  $dst, $src, $shift\\t# vector (8H)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 16) sh = 15;\n-    __ sshr(as_FloatRegister($dst$$reg), __ T8H,\n-            as_FloatRegister($src$$reg), sh);\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsrl4S_imm(vecD dst, vecD src, immI_positive shift) %{\n-  predicate((n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4) &&\n-            assert_not_var_shift(n));\n-  match(Set dst (URShiftVS src (RShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"ushr  $dst, $src, $shift\\t# vector (4H)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 16) {\n-      __ eor(as_FloatRegister($dst$$reg), __ T8B,\n-             as_FloatRegister($src$$reg),\n-             as_FloatRegister($src$$reg));\n-    } else {\n-      __ ushr(as_FloatRegister($dst$$reg), __ T4H,\n-              as_FloatRegister($src$$reg), sh);\n-    }\n-  %}\n-  ins_pipe(vshift64_imm);\n-%}\n-\n-instruct vsrl8S_imm(vecX dst, vecX src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 8 && assert_not_var_shift(n));\n-  match(Set dst (URShiftVS src (RShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"ushr  $dst, $src, $shift\\t# vector (8H)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 16) {\n-      __ eor(as_FloatRegister($dst$$reg), __ T16B,\n-             as_FloatRegister($src$$reg),\n-             as_FloatRegister($src$$reg));\n-    } else {\n-      __ ushr(as_FloatRegister($dst$$reg), __ T8H,\n-              as_FloatRegister($src$$reg), sh);\n-    }\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsll2I(vecD dst, vecD src, vecD shift) %{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (LShiftVI src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshl  $dst,$src,$shift\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ sshl(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift64);\n-%}\n-\n-instruct vsll4I(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (LShiftVI src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshl  $dst,$src,$shift\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ sshl(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsra2I(vecD dst, vecD src, vecD shift) %{\n-  predicate(n->as_Vector()->length() == 2 && !n->as_ShiftV()->is_var_shift());\n-  match(Set dst (RShiftVI src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshl  $dst,$src,$shift\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ sshl(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift64);\n-%}\n-\n-instruct vsra2I_var(vecD dst, vecD src, vecD shift) %{\n-  predicate(n->as_Vector()->length() == 2 && n->as_ShiftV()->is_var_shift());\n-  match(Set dst (RShiftVI src shift));\n-  ins_cost(INSN_COST * 2);\n-  effect(TEMP_DEF dst);\n-  format %{ \"negr  $dst,$shift\\t\"\n-            \"sshl  $dst,$src,$dst\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($shift$$reg));\n-    __ sshl(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(vshift64);\n-%}\n-\n-instruct vsra4I(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 4 && !n->as_ShiftV()->is_var_shift());\n-  match(Set dst (RShiftVI src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshl  $dst,$src,$shift\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ sshl(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsra4I_var(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 4 && n->as_ShiftV()->is_var_shift());\n-  match(Set dst (RShiftVI src shift));\n-  ins_cost(INSN_COST * 2);\n-  effect(TEMP_DEF dst);\n-  format %{ \"negr  $dst,$shift\\t\"\n-            \"sshl  $dst,$src,$dst\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($shift$$reg));\n-    __ sshl(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsrl2I(vecD dst, vecD src, vecD shift) %{\n-  predicate(n->as_Vector()->length() == 2 && !n->as_ShiftV()->is_var_shift());\n-  match(Set dst (URShiftVI src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"ushl  $dst,$src,$shift\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ ushl(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift64);\n-%}\n-\n-instruct vsrl2I_var(vecD dst, vecD src, vecD shift) %{\n-  predicate(n->as_Vector()->length() == 2 && n->as_ShiftV()->is_var_shift());\n-  match(Set dst (URShiftVI src shift));\n-  ins_cost(INSN_COST * 2);\n-  effect(TEMP_DEF dst);\n-  format %{ \"negr  $dst,$shift\\t\"\n-            \"ushl  $dst,$src,$dst\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($shift$$reg));\n-    __ ushl(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(vshift64);\n-%}\n-\n-instruct vsrl4I(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 4 && !n->as_ShiftV()->is_var_shift());\n-  match(Set dst (URShiftVI src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"ushl  $dst,$src,$shift\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ ushl(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsrl4I_var(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 4 && n->as_ShiftV()->is_var_shift());\n-  match(Set dst (URShiftVI src shift));\n-  ins_cost(INSN_COST * 2);\n-  effect(TEMP_DEF dst);\n-  format %{ \"negr  $dst,$shift\\t\"\n-            \"ushl  $dst,$src,$dst\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($shift$$reg));\n-    __ ushl(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsll2I_imm(vecD dst, vecD src, immI shift) %{\n-  predicate(n->as_Vector()->length() == 2 && assert_not_var_shift(n));\n-  match(Set dst (LShiftVI src (LShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"shl  $dst, $src, $shift\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ shl(as_FloatRegister($dst$$reg), __ T2S,\n-           as_FloatRegister($src$$reg),\n-           (int)$shift$$constant);\n-  %}\n-  ins_pipe(vshift64_imm);\n-%}\n-\n-instruct vsll4I_imm(vecX dst, vecX src, immI shift) %{\n-  predicate(n->as_Vector()->length() == 4 && assert_not_var_shift(n));\n-  match(Set dst (LShiftVI src (LShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"shl  $dst, $src, $shift\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ shl(as_FloatRegister($dst$$reg), __ T4S,\n-           as_FloatRegister($src$$reg),\n-           (int)$shift$$constant);\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsra2I_imm(vecD dst, vecD src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 2 && assert_not_var_shift(n));\n-  match(Set dst (RShiftVI src (RShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshr  $dst, $src, $shift\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ sshr(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src$$reg),\n-            (int)$shift$$constant);\n-  %}\n-  ins_pipe(vshift64_imm);\n-%}\n-\n-instruct vsra4I_imm(vecX dst, vecX src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 4 && assert_not_var_shift(n));\n-  match(Set dst (RShiftVI src (RShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshr  $dst, $src, $shift\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ sshr(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src$$reg),\n-            (int)$shift$$constant);\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsrl2I_imm(vecD dst, vecD src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 2 && assert_not_var_shift(n));\n-  match(Set dst (URShiftVI src (RShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"ushr  $dst, $src, $shift\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ ushr(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src$$reg),\n-            (int)$shift$$constant);\n-  %}\n-  ins_pipe(vshift64_imm);\n-%}\n-\n-instruct vsrl4I_imm(vecX dst, vecX src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 4 && assert_not_var_shift(n));\n-  match(Set dst (URShiftVI src (RShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"ushr  $dst, $src, $shift\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ ushr(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src$$reg),\n-            (int)$shift$$constant);\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsll2L(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (LShiftVL src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshl  $dst,$src,$shift\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ sshl(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsra2L(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 2 && !n->as_ShiftV()->is_var_shift());\n-  match(Set dst (RShiftVL src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshl  $dst,$src,$shift\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ sshl(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsra2L_var(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 2 && n->as_ShiftV()->is_var_shift());\n-  match(Set dst (RShiftVL src shift));\n-  ins_cost(INSN_COST * 2);\n-  effect(TEMP_DEF dst);\n-  format %{ \"negr  $dst,$shift\\t\"\n-            \"sshl  $dst,$src,$dst\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($shift$$reg));\n-    __ sshl(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsrl2L(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 2 && !n->as_ShiftV()->is_var_shift());\n-  match(Set dst (URShiftVL src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"ushl  $dst,$src,$shift\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ ushl(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsrl2L_var(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 2 && n->as_ShiftV()->is_var_shift());\n-  match(Set dst (URShiftVL src shift));\n-  ins_cost(INSN_COST * 2);\n-  effect(TEMP_DEF dst);\n-  format %{ \"negr  $dst,$shift\\t\"\n-            \"ushl  $dst,$src,$dst\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($shift$$reg));\n-    __ ushl(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsll2L_imm(vecX dst, vecX src, immI shift) %{\n-  predicate(n->as_Vector()->length() == 2 && assert_not_var_shift(n));\n-  match(Set dst (LShiftVL src (LShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"shl  $dst, $src, $shift\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ shl(as_FloatRegister($dst$$reg), __ T2D,\n-           as_FloatRegister($src$$reg),\n-           (int)$shift$$constant);\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsra2L_imm(vecX dst, vecX src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 2 && assert_not_var_shift(n));\n-  match(Set dst (RShiftVL src (RShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshr  $dst, $src, $shift\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ sshr(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src$$reg),\n-            (int)$shift$$constant);\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsrl2L_imm(vecX dst, vecX src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 2 && assert_not_var_shift(n));\n-  match(Set dst (URShiftVL src (RShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"ushr  $dst, $src, $shift\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ ushr(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src$$reg),\n-            (int)$shift$$constant);\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsraa8B_imm(vecD dst, vecD src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 8);\n-  match(Set dst (AddVB dst (RShiftVB src (RShiftCntV shift))));\n-  ins_cost(INSN_COST);\n-  format %{ \"ssra  $dst, $src, $shift\\t# vector (8B)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 8) sh = 7;\n-    __ ssra(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src$$reg), sh);\n-  %}\n-  ins_pipe(vshift64_imm);\n-%}\n-\n-instruct vsraa16B_imm(vecX dst, vecX src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 16);\n-  match(Set dst (AddVB dst (RShiftVB src (RShiftCntV shift))));\n-  ins_cost(INSN_COST);\n-  format %{ \"ssra  $dst, $src, $shift\\t# vector (16B)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 8) sh = 7;\n-    __ ssra(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src$$reg), sh);\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsraa4S_imm(vecD dst, vecD src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (AddVS dst (RShiftVS src (RShiftCntV shift))));\n-  ins_cost(INSN_COST);\n-  format %{ \"ssra  $dst, $src, $shift\\t# vector (4H)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 16) sh = 15;\n-    __ ssra(as_FloatRegister($dst$$reg), __ T4H,\n-            as_FloatRegister($src$$reg), sh);\n-  %}\n-  ins_pipe(vshift64_imm);\n-%}\n-\n-instruct vsraa8S_imm(vecX dst, vecX src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 8);\n-  match(Set dst (AddVS dst (RShiftVS src (RShiftCntV shift))));\n-  ins_cost(INSN_COST);\n-  format %{ \"ssra  $dst, $src, $shift\\t# vector (8H)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 16) sh = 15;\n-    __ ssra(as_FloatRegister($dst$$reg), __ T8H,\n-            as_FloatRegister($src$$reg), sh);\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsraa2I_imm(vecD dst, vecD src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (AddVI dst (RShiftVI src (RShiftCntV shift))));\n-  ins_cost(INSN_COST);\n-  format %{ \"ssra  $dst, $src, $shift\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ ssra(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src$$reg),\n-            (int)$shift$$constant);\n-  %}\n-  ins_pipe(vshift64_imm);\n-%}\n-\n-instruct vsraa4I_imm(vecX dst, vecX src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (AddVI dst (RShiftVI src (RShiftCntV shift))));\n-  ins_cost(INSN_COST);\n-  format %{ \"ssra  $dst, $src, $shift\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ ssra(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src$$reg),\n-            (int)$shift$$constant);\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsraa2L_imm(vecX dst, vecX src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (AddVL dst (RShiftVL src (RShiftCntV shift))));\n-  ins_cost(INSN_COST);\n-  format %{ \"ssra  $dst, $src, $shift\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ ssra(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src$$reg),\n-            (int)$shift$$constant);\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsrla8B_imm(vecD dst, vecD src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 8);\n-  match(Set dst (AddVB dst (URShiftVB src (RShiftCntV shift))));\n-  ins_cost(INSN_COST);\n-  format %{ \"usra  $dst, $src, $shift\\t# vector (8B)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh < 8) {\n-      __ usra(as_FloatRegister($dst$$reg), __ T8B,\n-              as_FloatRegister($src$$reg), sh);\n-    }\n-  %}\n-  ins_pipe(vshift64_imm);\n-%}\n-\n-instruct vsrla16B_imm(vecX dst, vecX src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 16);\n-  match(Set dst (AddVB dst (URShiftVB src (RShiftCntV shift))));\n-  ins_cost(INSN_COST);\n-  format %{ \"usra  $dst, $src, $shift\\t# vector (16B)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh < 8) {\n-      __ usra(as_FloatRegister($dst$$reg), __ T16B,\n-              as_FloatRegister($src$$reg), sh);\n-    }\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsrla4S_imm(vecD dst, vecD src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (AddVS dst (URShiftVS src (RShiftCntV shift))));\n-  ins_cost(INSN_COST);\n-  format %{ \"usra  $dst, $src, $shift\\t# vector (4H)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh < 16) {\n-      __ usra(as_FloatRegister($dst$$reg), __ T4H,\n-              as_FloatRegister($src$$reg), sh);\n-    }\n-  %}\n-  ins_pipe(vshift64_imm);\n-%}\n-\n-instruct vsrla8S_imm(vecX dst, vecX src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 8);\n-  match(Set dst (AddVS dst (URShiftVS src (RShiftCntV shift))));\n-  ins_cost(INSN_COST);\n-  format %{ \"usra  $dst, $src, $shift\\t# vector (8H)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh < 16) {\n-      __ usra(as_FloatRegister($dst$$reg), __ T8H,\n-              as_FloatRegister($src$$reg), sh);\n-    }\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsrla2I_imm(vecD dst, vecD src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (AddVI dst (URShiftVI src (RShiftCntV shift))));\n-  ins_cost(INSN_COST);\n-  format %{ \"usra  $dst, $src, $shift\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ usra(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src$$reg),\n-            (int)$shift$$constant);\n-  %}\n-  ins_pipe(vshift64_imm);\n-%}\n-\n-instruct vsrla4I_imm(vecX dst, vecX src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (AddVI dst (URShiftVI src (RShiftCntV shift))));\n-  ins_cost(INSN_COST);\n-  format %{ \"usra  $dst, $src, $shift\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ usra(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src$$reg),\n-            (int)$shift$$constant);\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsrla2L_imm(vecX dst, vecX src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (AddVL dst (URShiftVL src (RShiftCntV shift))));\n-  ins_cost(INSN_COST);\n-  format %{ \"usra  $dst, $src, $shift\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ usra(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src$$reg),\n-            (int)$shift$$constant);\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vmax2F(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (MaxV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"fmax  $dst,$src1,$src2\\t# vector (2F)\" %}\n-  ins_encode %{\n-    __ fmax(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop_fp64);\n-%}\n-\n-instruct vmax4F(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (MaxV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"fmax  $dst,$src1,$src2\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ fmax(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop_fp128);\n-%}\n-\n-instruct vmax2D(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (MaxV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"fmax  $dst,$src1,$src2\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ fmax(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop_fp128);\n-%}\n-\n-instruct vmin2F(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (MinV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"fmin  $dst,$src1,$src2\\t# vector (2F)\" %}\n-  ins_encode %{\n-    __ fmin(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop_fp64);\n-%}\n-\n-instruct vmin4F(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (MinV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"fmin  $dst,$src1,$src2\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ fmin(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop_fp128);\n-%}\n-\n-instruct vmin2D(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (MinV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"fmin  $dst,$src1,$src2\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ fmin(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop_fp128);\n-%}\n-\n-instruct vround2D_reg(vecX dst, vecX src, immI rmode) %{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (RoundDoubleModeV src rmode));\n-  format %{ \"frint  $dst, $src, $rmode\" %}\n-  ins_encode %{\n-    switch ($rmode$$constant) {\n-      case RoundDoubleModeNode::rmode_rint:\n-        __ frintn(as_FloatRegister($dst$$reg), __ T2D,\n-                  as_FloatRegister($src$$reg));\n-        break;\n-      case RoundDoubleModeNode::rmode_floor:\n-        __ frintm(as_FloatRegister($dst$$reg), __ T2D,\n-                  as_FloatRegister($src$$reg));\n-        break;\n-      case RoundDoubleModeNode::rmode_ceil:\n-        __ frintp(as_FloatRegister($dst$$reg), __ T2D,\n-                  as_FloatRegister($src$$reg));\n-        break;\n-    }\n-  %}\n-  ins_pipe(vdop_fp128);\n-%}\n-\n-instruct vpopcountID(vecD dst, vecD src) %{\n-  predicate(n->as_Vector()->length_in_bytes() < 16);\n-  match(Set dst (PopCountVI src));\n-  ins_cost(3 * INSN_COST);\n-  format %{ \"vpopcountI  $dst, $src\\t# vector (8B\/4H\/2S)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ cnt(as_FloatRegister($dst$$reg), __ T8B,\n-           as_FloatRegister($src$$reg));\n-    if (bt == T_SHORT || bt == T_INT) {\n-      __ uaddlp(as_FloatRegister($dst$$reg), __ T8B,\n-                as_FloatRegister($dst$$reg));\n-      if (bt == T_INT) {\n-        __ uaddlp(as_FloatRegister($dst$$reg), __ T4H,\n-                  as_FloatRegister($dst$$reg));\n-      }\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vpopcountIX(vecX dst, vecX src) %{\n-  predicate(n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (PopCountVI src));\n-  ins_cost(3 * INSN_COST);\n-  format %{ \"vpopcountI  $dst, $src\\t# vector (16B\/8H\/4S)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ cnt(as_FloatRegister($dst$$reg), __ T16B,\n-           as_FloatRegister($src$$reg));\n-    if (bt == T_SHORT || bt == T_INT) {\n-      __ uaddlp(as_FloatRegister($dst$$reg), __ T16B,\n-                as_FloatRegister($dst$$reg));\n-      if (bt == T_INT) {\n-        __ uaddlp(as_FloatRegister($dst$$reg), __ T8H,\n-                  as_FloatRegister($dst$$reg));\n-      }\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-\/\/ If the PopCountVL is generated by auto-vectorization, the dst basic\n-\/\/ type is T_INT. And once we have unified the type definition for\n-\/\/ Vector API and auto-vectorization, this rule can be merged with\n-\/\/ \"vpopcountLX\" rule.\n-instruct vpopcountLD(vecD dst, vecX src) %{\n-  predicate(n->as_Vector()->length_in_bytes() < 16 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (PopCountVL src));\n-  ins_cost(5 * INSN_COST);\n-  format %{ \"vpopcountL  $dst, $src\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ cnt(as_FloatRegister($dst$$reg), __ T16B,\n-           as_FloatRegister($src$$reg));\n-    __ uaddlp(as_FloatRegister($dst$$reg), __ T16B,\n-              as_FloatRegister($dst$$reg));\n-    __ uaddlp(as_FloatRegister($dst$$reg), __ T8H,\n-              as_FloatRegister($dst$$reg));\n-    __ uaddlp(as_FloatRegister($dst$$reg), __ T4S,\n-              as_FloatRegister($dst$$reg));\n-    __ xtn(as_FloatRegister($dst$$reg), __ T2S,\n-           as_FloatRegister($dst$$reg), __ T2D);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vpopcountLX(vecX dst, vecX src) %{\n-  predicate(n->as_Vector()->length_in_bytes() == 16 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (PopCountVL src));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"vpopcountL  $dst, $src\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ cnt(as_FloatRegister($dst$$reg), __ T16B,\n-           as_FloatRegister($src$$reg));\n-    __ uaddlp(as_FloatRegister($dst$$reg), __ T16B,\n-              as_FloatRegister($dst$$reg));\n-    __ uaddlp(as_FloatRegister($dst$$reg), __ T8H,\n-              as_FloatRegister($dst$$reg));\n-    __ uaddlp(as_FloatRegister($dst$$reg), __ T4S,\n-              as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-\/\/ vector mask reductions\n-\n-instruct vmask_truecount8B(iRegINoSp dst, vecD src, vecD tmp) %{\n-  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n-  match(Set dst (VectorMaskTrueCount src));\n-  effect(TEMP tmp);\n-  ins_cost(2 * INSN_COST);\n-  format %{ \"addv $tmp, $src\\n\\t\"\n-            \"umov $dst, $tmp, B, 0\\t# vector (8B)\" %}\n-  ins_encode %{\n-    \/\/ Input \"src\" is a vector of boolean represented as bytes with\n-    \/\/ 0x00\/0x01 as element values.\n-    __ addv(as_FloatRegister($tmp$$reg), __ T8B, as_FloatRegister($src$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_truecount16B(iRegINoSp dst, vecX src, vecX tmp) %{\n-  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n-  match(Set dst (VectorMaskTrueCount src));\n-  effect(TEMP tmp);\n-  ins_cost(2 * INSN_COST);\n-  format %{ \"addv $tmp, $src\\n\\t\"\n-            \"umov $dst, $tmp, B, 0\\t# vector (16B)\" %}\n-  ins_encode %{\n-    \/\/ Input \"src\" is a vector of boolean represented as bytes with\n-    \/\/ 0x00\/0x01 as element values.\n-    __ addv(as_FloatRegister($tmp$$reg), __ T16B, as_FloatRegister($src$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_firsttrue_LT8B(iRegINoSp dst, vecD src, rFlagsReg cr) %{\n-  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN &&\n-            n->in(1)->bottom_type()->is_vect()->length() < 8);\n-  match(Set dst (VectorMaskFirstTrue src));\n-  effect(KILL cr);\n-  ins_cost(7 * INSN_COST);\n-  format %{ \"vmask_firsttrue $dst, $src\\t# vector (4I\/4S\/2I)\" %}\n-  ins_encode %{\n-    \/\/ Returns the index of the first active lane of the\n-    \/\/ vector mask, or VLENGTH if no lane is active.\n-    \/\/\n-    \/\/ Input \"src\" is a vector of boolean represented as\n-    \/\/ bytes with 0x00\/0x01 as element values.\n-    \/\/\n-    \/\/ Computed by reversing the bits and counting the leading\n-    \/\/ zero bytes.\n-    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n-    __ rbit($dst$$Register, $dst$$Register);\n-    __ clz($dst$$Register, $dst$$Register);\n-    __ lsrw($dst$$Register, $dst$$Register, 3);\n-    __ movw(rscratch1, Matcher::vector_length(this, $src));\n-    __ cmpw($dst$$Register, rscratch1);\n-    __ cselw($dst$$Register, rscratch1, $dst$$Register, Assembler::GE);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_firsttrue8B(iRegINoSp dst, vecD src) %{\n-  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN &&\n-            n->in(1)->bottom_type()->is_vect()->length() == 8);\n-  match(Set dst (VectorMaskFirstTrue src));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"vmask_firsttrue $dst, $src\\t# vector (8B)\" %}\n-  ins_encode %{\n-    \/\/ Returns the index of the first active lane of the\n-    \/\/ vector mask, or VLENGTH if no lane is active.\n-    \/\/\n-    \/\/ Input \"src\" is a vector of boolean represented as\n-    \/\/ bytes with 0x00\/0x01 as element values.\n-    \/\/\n-    \/\/ Computed by reversing the bits and counting the leading\n-    \/\/ zero bytes.\n-    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n-    __ rbit($dst$$Register, $dst$$Register);\n-    __ clz($dst$$Register, $dst$$Register);\n-    __ lsrw($dst$$Register, $dst$$Register, 3);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_firsttrue16B(iRegINoSp dst, vecX src) %{\n-  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n-  match(Set dst (VectorMaskFirstTrue src));\n-  ins_cost(6 * INSN_COST);\n-  format %{ \"vmask_firsttrue $dst, $src\\t# vector (16B)\" %}\n-  ins_encode %{\n-    \/\/ Returns the index of the first active lane of the\n-    \/\/ vector mask, or 16 (VLENGTH) if no lane is active.\n-    \/\/\n-    \/\/ Input \"src\" is a vector of boolean represented as\n-    \/\/ bytes with 0x00\/0x01 as element values.\n-\n-    Label FIRST_TRUE_INDEX;\n-\n-    \/\/ Try to compute the result from lower 64 bits.\n-    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n-    __ movw(rscratch1, zr);\n-    __ cbnz($dst$$Register, FIRST_TRUE_INDEX);\n-\n-    \/\/ Compute the result from the higher 64 bits.\n-    __ fmovhid($dst$$Register, as_FloatRegister($src$$reg));\n-    __ movw(rscratch1, 8);\n-\n-    \/\/ Reverse the bits and count the leading zero bytes.\n-    __ bind(FIRST_TRUE_INDEX);\n-    __ rbit($dst$$Register, $dst$$Register);\n-    __ clz($dst$$Register, $dst$$Register);\n-    __ addw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_lasttrue8B(iRegINoSp dst, vecD src) %{\n-  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n-  match(Set dst (VectorMaskLastTrue src));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"vmask_lasttrue $dst, $src\\t# vector (8B)\" %}\n-  ins_encode %{\n-    \/\/ Returns the index of the last active lane of the\n-    \/\/ vector mask, or -1 if no lane is active.\n-    \/\/\n-    \/\/ Input \"src\" is a vector of boolean represented as\n-    \/\/ bytes with 0x00\/0x01 as element values.\n-    \/\/\n-    \/\/ Computed by counting the leading zero bytes and\n-    \/\/ subtracting it by 7 (VLENGTH - 1).\n-    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n-    __ clz($dst$$Register, $dst$$Register);\n-    __ movw(rscratch1, 7);\n-    __ subw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_lasttrue16B(iRegINoSp dst, vecX src) %{\n-  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n-  match(Set dst (VectorMaskLastTrue src));\n-  ins_cost(5 * INSN_COST);\n-  format %{ \"vmask_lasttrue $dst, $src\\t# vector (16B)\" %}\n-  ins_encode %{\n-    \/\/ Returns the index of the last active lane of the\n-    \/\/ vector mask, or -1 if no lane is active.\n-    \/\/\n-    \/\/ Input \"src\" is a vector of boolean represented as\n-    \/\/ bytes with 0x00\/0x01 as element values.\n-\n-    Label LAST_TRUE_INDEX;\n-\n-    \/\/ Try to compute the result from higher 64 bits.\n-    __ fmovhid($dst$$Register, as_FloatRegister($src$$reg));\n-    __ movw(rscratch1, 16 - 1);\n-    __ cbnz($dst$$Register, LAST_TRUE_INDEX);\n-\n-    \/\/ Compute the result from the lower 64 bits.\n-    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n-    __ movw(rscratch1, 8 - 1);\n-\n-    \/\/ Count the leading zero bytes and subtract it by 15 (VLENGTH - 1).\n-    __ bind(LAST_TRUE_INDEX);\n-    __ clz($dst$$Register, $dst$$Register);\n-    __ subw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_tolong8B(iRegLNoSp dst, vecD src) %{\n-  match(Set dst (VectorMaskToLong src));\n-  ins_cost(5 * INSN_COST);\n-  format %{ \"vmask_tolong $dst, $src\\t# convert mask to long (8B)\" %}\n-  ins_encode %{\n-    \/\/ Input \"src\" is a vector of boolean represented as\n-    \/\/ bytes with 0x00\/0x01 as element values.\n-\n-    __ fmovd(as_Register($dst$$reg), as_FloatRegister($src$$reg));\n-    __ bytemask_compress(as_Register($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_tolong16B(iRegLNoSp dst, vecX src) %{\n-  match(Set dst (VectorMaskToLong src));\n-  ins_cost(11 * INSN_COST);\n-  format %{ \"vmask_tolong $dst, $src\\t# convert mask to long (16B)\" %}\n-  ins_encode %{\n-    \/\/ Input \"src\" is a vector of boolean represented as\n-    \/\/ bytes with 0x00\/0x01 as element values.\n-\n-    __ umov(as_Register($dst$$reg), as_FloatRegister($src$$reg), __ D, 0);\n-    __ umov(rscratch1, as_FloatRegister($src$$reg), __ D, 1);\n-    __ bytemask_compress(as_Register($dst$$reg));\n-    __ bytemask_compress(rscratch1);\n-    __ orr(as_Register($dst$$reg), as_Register($dst$$reg),\n-           rscratch1, Assembler::LSL, 8);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/------------------------- CountLeadingZerosV -----------------------------\n-\n-instruct countLeadingZerosVD(vecD dst, vecD src) %{\n-  predicate(n->as_Vector()->length_in_bytes() == 8);\n-  match(Set dst (CountLeadingZerosV src));\n-  ins_cost(INSN_COST);\n-  format %{ \"countLeadingZerosV $dst, $src\\t# vector (8B\/4H\/2S)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_Arrangement size = __ esize2arrangement((unsigned)type2aelembytes(bt), false);\n-    __ clz(as_FloatRegister($dst$$reg), size, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct countLeadingZerosVX(vecX dst, vecX src) %{\n-  predicate(n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (CountLeadingZerosV src));\n-  ins_cost(INSN_COST);\n-  format %{ \"countLeadingZerosV $dst, $src\\t# vector (16B\/8H\/4S\/2D)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_Arrangement size = __ esize2arrangement((unsigned)type2aelembytes(bt), true);\n-    if (bt != T_LONG) {\n-      __ clz(as_FloatRegister($dst$$reg), size, as_FloatRegister($src$$reg));\n-    } else {\n-      __ umov(rscratch1, as_FloatRegister($src$$reg), __ D, 0);\n-      __ clz(rscratch1, rscratch1);\n-      __ mov(as_FloatRegister($dst$$reg), __ D, 0, rscratch1);\n-      __ umov(rscratch1, as_FloatRegister($src$$reg), __ D, 1);\n-      __ clz(rscratch1, rscratch1);\n-      __ mov(as_FloatRegister($dst$$reg), __ D, 1, rscratch1);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/------------------------- CountTrailingZerosV ----------------------------\n-\n-instruct countTrailingZerosVD(vecD dst, vecD src) %{\n-  predicate(n->as_Vector()->length_in_bytes() == 8);\n-  match(Set dst (CountTrailingZerosV src));\n-  ins_cost(3 * INSN_COST);\n-  format %{ \"countTrailingZerosV $dst, $src\\t# vector (8B\/4H\/2S)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_Arrangement size = __ esize2arrangement((unsigned)type2aelembytes(bt), false);\n-    __ neon_reverse_bits(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), bt, false);\n-    __ clz(as_FloatRegister($dst$$reg), size, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct countTrailingZerosVX(vecX dst, vecX src) %{\n-  predicate(n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (CountTrailingZerosV src));\n-  ins_cost(3 * INSN_COST);\n-  format %{ \"countTrailingZerosV $dst, $src\\t# vector (16B\/8H\/4S\/2D)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_Arrangement size = __ esize2arrangement((unsigned)type2aelembytes(bt), true);\n-    __ neon_reverse_bits(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), bt, true);\n-    if (bt != T_LONG) {\n-      __ clz(as_FloatRegister($dst$$reg), size, as_FloatRegister($dst$$reg));\n-    } else {\n-      __ umov(rscratch1, as_FloatRegister($dst$$reg), __ D, 0);\n-      __ clz(rscratch1, rscratch1);\n-      __ mov(as_FloatRegister($dst$$reg), __ D, 0, rscratch1);\n-      __ umov(rscratch1, as_FloatRegister($dst$$reg), __ D, 1);\n-      __ clz(rscratch1, rscratch1);\n-      __ mov(as_FloatRegister($dst$$reg), __ D, 1, rscratch1);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/------------------------------ ReverseV -----------------------------------\n-\n-instruct vreverseD(vecD dst, vecD src) %{\n-  predicate(n->as_Vector()->length_in_bytes() == 8);\n-  match(Set dst (ReverseV src));\n-  ins_cost(2 * INSN_COST);\n-  format %{ \"ReverseV $dst, $src\\t# vector (D)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ neon_reverse_bits(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), bt, false);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vreverseX(vecX dst, vecX src) %{\n-  predicate(n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (ReverseV src));\n-  ins_cost(2 * INSN_COST);\n-  format %{ \"ReverseV $dst, $src\\t# vector (X)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ neon_reverse_bits(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), bt, true);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/---------------------------- ReverseBytesV --------------------------------\n-\n-instruct vreverseBytesD(vecD dst, vecD src) %{\n-  predicate(n->as_Vector()->length_in_bytes() == 8);\n-  match(Set dst (ReverseBytesV src));\n-  ins_cost(INSN_COST);\n-  format %{ \"ReverseBytesV $dst, $src\\t# vector (D)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ neon_reverse_bytes(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), bt, false);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vreverseBytesX(vecX dst, vecX src) %{\n-  predicate(n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (ReverseBytesV src));\n-  ins_cost(INSN_COST);\n-  format %{ \"ReverseBytesV $dst, $src\\t# vector (X)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ neon_reverse_bytes(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), bt, true);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon.ad","additions":0,"deletions":6099,"binary":false,"changes":6099,"status":"deleted"},{"patch":"@@ -1,2749 +0,0 @@\n-\/\/ Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n-\/\/ Copyright (c) 2020, 2022, Arm Limited. All rights reserved.\n-\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\/\/\n-\/\/ This code is free software; you can redistribute it and\/or modify it\n-\/\/ under the terms of the GNU General Public License version 2 only, as\n-\/\/ published by the Free Software Foundation.\n-\/\/\n-\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n-\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-\/\/ version 2 for more details (a copy is included in the LICENSE file that\n-\/\/ accompanied this code).\n-\/\/\n-\/\/ You should have received a copy of the GNU General Public License version\n-\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n-\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\/\/\n-\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-\/\/ or visit www.oracle.com if you need additional information or have any\n-\/\/ questions.\n-\/\/\n-\/\/\n-\n-dnl Generate the warning\n-\/\/ This file is automatically generated by running \"m4 aarch64_neon_ad.m4\". Do not edit ----\n-dnl\n-\n-\/\/ AArch64 NEON Architecture Description File\n-\n-dnl\n-define(`ORL2I', `ifelse($1,I,orL2I)')dnl\n-dnl\n-define(`error', `__program__:__file__:__line__: Invalid argument ``$1''m4exit(`1')')dnl\n-dnl\n-define(`iTYPE2SIMD',\n-`ifelse($1, `B', `B',\n-        $1, `S', `H',\n-        $1, `I', `S',\n-        $1, `L', `D',\n-        `error($1)')')dnl\n-dnl\n-define(`fTYPE2SIMD',\n-`ifelse($1, `F', `S',\n-        $1, `D', `D',\n-        `error($1)')')dnl\n-dnl\n-define(`TYPE2DATATYPE',\n-`ifelse($1, `B', `BYTE',\n-        $1, `S', `SHORT',\n-        $1, `I', `INT',\n-        $1, `L', `LONG',\n-        $1, `F', `FLOAT',\n-        $1, `D', `DOUBLE',\n-        `error($1)')')dnl\n-dnl\n-\/\/ ====================VECTOR INSTRUCTIONS==================================\n-\n-\/\/ ------------------------------ Load\/store\/reinterpret -----------------------\n-define(`VLoadStore', `\n-\/\/ ifelse(load, $3, Load, Store) Vector ($6 bits)\n-instruct $3V$4`'(vec$5 $7, vmem$4 mem)\n-%{\n-  predicate($8`n->as_'ifelse(load, $3, Load, Store)Vector()->memory_size() == $4);\n-  match(Set ifelse(load, $3, dst (LoadVector mem), mem (StoreVector mem src)));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"$1   ifelse(load, $3, `$dst,$mem', `$mem,$src')\\t# vector ($6 bits)\" %}\n-  ins_encode( `aarch64_enc_'ifelse(load, $3, ldr, str)v$2($7, mem) );\n-  ins_pipe(v$3`_reg_mem'ifelse(eval($4 * 8), 128, 128, 64));\n-%}')dnl\n-dnl        $1    $2 $3     $4  $5 $6   $7   $8\n-VLoadStore(ldrh, H, load,  2,  D, 16,  dst, UseSVE == 0 && )\n-VLoadStore(ldrs, S, load,  4,  D, 32,  dst, UseSVE == 0 && )\n-VLoadStore(ldrd, D, load,  8,  D, 64,  dst, UseSVE == 0 && )\n-VLoadStore(ldrq, Q, load, 16,  X, 128, dst, UseSVE == 0 && )\n-VLoadStore(strh, H, store, 2,  D, 16,  src, )\n-VLoadStore(strs, S, store, 4,  D, 32,  src, )\n-VLoadStore(strd, D, store, 8,  D, 64,  src, )\n-VLoadStore(strq, Q, store, 16, X, 128, src, )\n-dnl\n-define(`REINTERPRET', `\n-instruct reinterpret$1`'(vec$1 dst)\n-%{\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == $2 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == $2);\n-  match(Set dst (VectorReinterpret dst));\n-  ins_cost(0);\n-  format %{ \" # reinterpret $dst\" %}\n-  ins_encode %{\n-    \/\/ empty\n-  %}\n-  ins_pipe(pipe_class_empty);\n-%}')dnl\n-dnl         $1 $2\n-REINTERPRET(D, 8)\n-REINTERPRET(X, 16)\n-dnl\n-define(`REINTERPRET_DX', `\n-instruct reinterpret$1`'2$2`'(vec$2 dst, vec$1 src)\n-%{\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == $3 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == $4);\n-  match(Set dst (VectorReinterpret src));\n-  ins_cost(INSN_COST);\n-  format %{ \" # reinterpret $dst,$src\\t# $1 to $2\" %}\n-  ins_encode %{\n-    \/\/ The higher 64-bits of the \"dst\" register must be cleared to zero.\n-    __ orr(as_FloatRegister($dst$$reg), __ T8B,\n-           as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vlogical64);\n-%}')dnl\n-dnl            $1 $2 $3  $4\n-REINTERPRET_DX(D, X, 16, 8)\n-REINTERPRET_DX(X, D, 8,  16)\n-dnl\n-define(`REINTERPRET_SX', `\n-instruct reinterpret$1`'2$2`'(vec$3 dst, vec$4 src)\n-%{\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == $5 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == $6);\n-  match(Set dst (VectorReinterpret src));\n-  ins_cost(INSN_COST);\n-  format %{ \" # reinterpret $dst,$src\\t# $1 to $2\" %}\n-  ins_encode %{\n-    \/\/ The higher bits of the \"dst\" register must be cleared to zero.\n-    __ dup(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl            $1 $2 $3 $4 $5  $6\n-REINTERPRET_SX(S, X, X, D, 16, 4)\n-REINTERPRET_SX(X, S, D, X, 4,  16)\n-REINTERPRET_SX(S, D, D, D, 8,  4)\n-REINTERPRET_SX(D, S, D, D, 4,  8)\n-dnl\n-\n-\/\/ ------------------------------ Vector cast -------------------------------\n-dnl\n-define(`VECTOR_CAST_I2I', `\n-instruct vcvt$1$2to$1$3`'(vec$4 dst, vec$5 src)\n-%{\n-  predicate(n->as_Vector()->length() == $1 && n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($3));\n-  match(Set dst (VectorCast$2`'2X src));\n-  format %{ \"$6  $dst, T$8, $src, T$7\\t# convert $1$2 to $1$3 vector\" %}\n-  ins_encode %{\n-    __ $6(as_FloatRegister($dst$$reg), __ T$8, as_FloatRegister($src$$reg), __ T$7);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl             $1 $2 $3 $4 $5 $6    $7  $8\n-VECTOR_CAST_I2I(8, B, S, X, D, sxtl, 8B, 8H)\n-VECTOR_CAST_I2I(4, B, S, D, D, sxtl, 8B, 8H)\n-VECTOR_CAST_I2I(8, S, B, D, X, xtn,  8H, 8B)\n-VECTOR_CAST_I2I(4, S, B, D, D, xtn,  8H, 8B)\n-VECTOR_CAST_I2I(4, S, I, X, D, sxtl, 4H, 4S)\n-VECTOR_CAST_I2I(4, I, S, D, X, xtn,  4S, 4H)\n-VECTOR_CAST_I2I(2, I, L, X, D, sxtl, 2S, 2D)\n-VECTOR_CAST_I2I(2, L, I, D, X, xtn,  2D, 2S)\n-dnl\n-define(`VECTOR_CAST_I2I_L', `\n-instruct vcvt$1$2to$1$3`'(vec$4 dst, vec$5 src)\n-%{\n-  predicate(n->as_Vector()->length() == $1 && n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($3));\n-  match(Set dst (VectorCast$2`'2X src));\n-  format %{ \"$6  $dst, T$8, $src, T$7\\n\\t\"\n-            \"$6  $dst, T$10, $dst, T$9\\t# convert $1$2 to $1$3 vector\"\n-  %}\n-  ins_encode %{\n-    __ $6(as_FloatRegister($dst$$reg), __ T$8, as_FloatRegister($src$$reg), __ T$7);\n-    __ $6(as_FloatRegister($dst$$reg), __ T$10, as_FloatRegister($dst$$reg), __ T$9);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl               $1 $2 $3 $4 $5 $6    $7  $8  $9  $10\n-VECTOR_CAST_I2I_L(4, I, B, D, X, xtn,  4S, 4H, 8H, 8B)\n-VECTOR_CAST_I2I_L(4, B, I, X, D, sxtl, 8B, 8H, 4H, 4S)\n-dnl\n-\n-instruct vcvt2Lto2F(vecD dst, vecX src, vRegF tmp)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorCastL2X src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   rscratch1, $src, D, 0\\n\\t\"\n-            \"scvtfs $dst, rscratch1\\n\\t\"\n-            \"umov   rscratch1, $src, D, 1\\n\\t\"\n-            \"scvtfs $tmp, rscratch1\\n\\t\"\n-            \"ins    $dst, S, $tmp, 1, 0\\t# convert 2L to 2F vector\"\n-  %}\n-  ins_encode %{\n-    __ umov(rscratch1, as_FloatRegister($src$$reg), __ D, 0);\n-    __ scvtfs(as_FloatRegister($dst$$reg), rscratch1);\n-    __ umov(rscratch1, as_FloatRegister($src$$reg), __ D, 1);\n-    __ scvtfs(as_FloatRegister($tmp$$reg), rscratch1);\n-    __ ins(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($tmp$$reg), 1, 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-dnl\n-define(`VECTOR_CAST_I2F', `\n-instruct vcvt$1$2to$1$3`'(vec$4 dst, vec$4 src)\n-%{\n-  predicate(n->as_Vector()->length() == $1 && n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($3));\n-  match(Set dst (VectorCast$2`'2X src));\n-  format %{ \"scvtfv  T$5, $dst, $src\\t# convert $1$2 to $1$3 vector\" %}\n-  ins_encode %{\n-    __ scvtfv(__ T$5, as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl             $1 $2 $3 $4 $5\n-VECTOR_CAST_I2F(2, I, F, D, 2S)\n-VECTOR_CAST_I2F(4, I, F, X, 4S)\n-VECTOR_CAST_I2F(2, L, D, X, 2D)\n-dnl\n-define(`VECTOR_CAST_I2F_L', `\n-instruct vcvt$1$2to$1$3`'(vec$4 dst, vec$5 src)\n-%{\n-  predicate(n->as_Vector()->length() == $1 && n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($3));\n-  match(Set dst (VectorCast$2`'2X src));\n-  format %{ \"sxtl    $dst, T$7, $src, T$6\\n\\t\"\n-            \"scvtfv  T$7, $dst, $dst\\t# convert $1$2 to $1$3 vector\"\n-  %}\n-  ins_encode %{\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T$7, as_FloatRegister($src$$reg), __ T$6);\n-    __ scvtfv(__ T$7, as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl               $1 $2 $3 $4 $5 $6  $7\n-VECTOR_CAST_I2F_L(4, S, F, X, D, 4H, 4S)\n-VECTOR_CAST_I2F_L(2, I, D, X, D, 2S, 2D)\n-dnl\n-\n-instruct vcvt4Bto4F(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorCastB2X src));\n-  format %{ \"sxtl    $dst, T8H, $src, T8B\\n\\t\"\n-            \"sxtl    $dst, T4S, $dst, T4H\\n\\t\"\n-            \"scvtfv  T4S, $dst, $dst\\t# convert 4B to 4F vector\"\n-  %}\n-  ins_encode %{\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($dst$$reg), __ T4H);\n-    __ scvtfv(__ T4S, as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvt2Fto2L(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorCastF2X src));\n-  format %{ \"fcvtl   $dst, T2D, $src, T2S\\n\\t\"\n-            \"fcvtzs  $dst, T2D, $dst\\t# convert 2F to 2L vector\"\n-  %}\n-  ins_encode %{\n-    __ fcvtl(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($src$$reg), __ T2S);\n-    __ fcvtzs(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-dnl\n-define(`VECTOR_CAST_F2I', `\n-instruct vcvt$1$2to$1$3`'(vec$4 dst, vec$4 src)\n-%{\n-  predicate(n->as_Vector()->length() == $1 && n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($3));\n-  match(Set dst (VectorCast$2`'2X src));\n-  format %{ \"fcvtzs  $dst, T$5, $src\\t# convert $1$2 to $1$3 vector\" %}\n-  ins_encode %{\n-    __ fcvtzs(as_FloatRegister($dst$$reg), __ T$5, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl             $1 $2 $3 $4 $5\n-VECTOR_CAST_F2I(2, F, I, D, 2S)\n-VECTOR_CAST_F2I(4, F, I, X, 4S)\n-VECTOR_CAST_F2I(2, D, L, X, 2D)\n-\n-instruct vcvt4Fto4S(vecD dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorCastF2X src));\n-  format %{ \"fcvtzs  $dst, T4S, $src\\n\\t\"\n-            \"xtn     $dst, T4H, $dst, T4S\\t# convert 4F to 4S vector\"\n-  %}\n-  ins_encode %{\n-    __ fcvtzs(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src$$reg));\n-    __ xtn(as_FloatRegister($dst$$reg), __ T4H, as_FloatRegister($dst$$reg), __ T4S);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvt2Dto2I(vecD dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (VectorCastD2X src));\n-  effect(TEMP_DEF dst);\n-  format %{ \"ins      $dst, D, $src, 0, 1\\n\\t\"\n-            \"fcvtzdw  rscratch1, $src\\n\\t\"\n-            \"fcvtzdw  rscratch2, $dst\\n\\t\"\n-            \"fmovs    $dst, rscratch1\\n\\t\"\n-            \"mov      $dst, S, 1, rscratch2\\t#convert 2D to 2I vector\"\n-  %}\n-  ins_encode %{\n-    __ ins(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg), 0, 1);\n-    \/\/ We can't use fcvtzs(vector, integer) instruction here because we need\n-    \/\/ saturation arithmetic. See JDK-8276151.\n-    __ fcvtzdw(rscratch1, as_FloatRegister($src$$reg));\n-    __ fcvtzdw(rscratch2, as_FloatRegister($dst$$reg));\n-    __ fmovs(as_FloatRegister($dst$$reg), rscratch1);\n-    __ mov(as_FloatRegister($dst$$reg), __ S, 1, rscratch2);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvt4Fto4B(vecD dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorCastF2X src));\n-  format %{ \"fcvtzs  $dst, T4S, $src\\n\\t\"\n-            \"xtn     $dst, T4H, $dst, T4S\\n\\t\"\n-            \"xtn     $dst, T8B, $dst, T8H\\t# convert 4F to 4B vector\"\n-  %}\n-  ins_encode %{\n-    __ fcvtzs(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src$$reg));\n-    __ xtn(as_FloatRegister($dst$$reg), __ T4H, as_FloatRegister($dst$$reg), __ T4S);\n-    __ xtn(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($dst$$reg), __ T8H);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-dnl\n-define(`VECTOR_CAST_F2F', `\n-instruct vcvt2$1to2$2`'(vec$3 dst, vec$4 src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n-  match(Set dst (VectorCast$1`'2X src));\n-  format %{ \"$5  $dst, T$7, $src, T$6\\t# convert 2$1 to 2$2 vector\" %}\n-  ins_encode %{\n-    __ $5(as_FloatRegister($dst$$reg), __ T$7, as_FloatRegister($src$$reg), __ T$6);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl             $1 $2 $3 $4 $5     $6  $7\n-VECTOR_CAST_F2F(F, D, X, D, fcvtl, 2S, 2D)\n-VECTOR_CAST_F2F(D, F, D, X, fcvtn, 2D, 2S)\n-dnl\n-\n-define(`VECTOR_JAVA_FROUND', `\n-instruct vround$7$2to$5$3($7 dst, $7 src, $7 tmp1, $7 tmp2, $7 tmp3)\n-%{\n-  predicate(UseSVE == 0 &&\n-            n->as_Vector()->length() == $5 && n->bottom_type()->is_vect()->element_basic_type() == T_$6);\n-  match(Set dst (RoundV$1 src));\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n-  format %{ \"vround  $dst, $4, $src\\t# round $7 $2 to $5$3 vector\" %}\n-  ins_encode %{\n-    __ vector_round_neon(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-                         as_FloatRegister($tmp1$$reg), as_FloatRegister($tmp2$$reg),\n-                         as_FloatRegister($tmp3$$reg), __ $4);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl           $1  $2  $3   $4 $5    $6    $7\n-VECTOR_JAVA_FROUND(F, 2F,  I, T2S, 2,  INT, vecD)\n-VECTOR_JAVA_FROUND(F, 4F,  I, T4S, 4,  INT, vecX)\n-VECTOR_JAVA_FROUND(D, 2D,  L, T2D, 2, LONG, vecX)\n-\n-\/\/ ------------------------------ Reduction -------------------------------\n-dnl\n-define(`REDUCE_ADD_BORS', `\n-instruct reduce_add$1$2`'(iRegINoSp dst, iRegIorL2I isrc, vec$3 vsrc, vec$3 tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n-  match(Set dst (AddReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"addv  $tmp, T$1`'iTYPE2SIMD($2), $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, iTYPE2SIMD($2), 0\\n\\t\"\n-            \"addw  $dst, $dst, $isrc\\n\\t\"\n-            \"sxt$4  $dst, $dst\\t# add reduction$1$2\"\n-  %}\n-  ins_encode %{\n-    __ addv(as_FloatRegister($tmp$$reg), __ T$1`'iTYPE2SIMD($2), as_FloatRegister($vsrc$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ iTYPE2SIMD($2), 0);\n-    __ addw($dst$$Register, $dst$$Register, $isrc$$Register);\n-    __ sxt$4($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl             $1  $2 $3 $4\n-REDUCE_ADD_BORS(8,  B, D, b)\n-REDUCE_ADD_BORS(16, B, X, b)\n-REDUCE_ADD_BORS(4,  S, D, h)\n-REDUCE_ADD_BORS(8,  S, X, h)\n-dnl\n-\n-instruct reduce_add2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, vecX tmp)\n-%{\n-  match(Set dst (AddReductionVL isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"addpd $tmp, $vsrc\\n\\t\"\n-            \"umov  $dst, $tmp, D, 0\\n\\t\"\n-            \"add   $dst, $isrc, $dst\\t# add reduction2L\"\n-  %}\n-  ins_encode %{\n-    __ addpd(as_FloatRegister($tmp$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ D, 0);\n-    __ add($dst$$Register, $isrc$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_mul8B(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD vtmp1, vecD vtmp2, iRegINoSp itmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (MulReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP itmp);\n-  format %{ \"ins   $vtmp1, S, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp1, T8B, $vtmp1, $vsrc\\n\\t\"\n-            \"ins   $vtmp2, H, $vtmp1, 0, 1\\n\\t\"\n-            \"mulv  $vtmp2, T8B, $vtmp2, $vtmp1\\n\\t\"\n-            \"umov  $itmp, $vtmp2, B, 0\\n\\t\"\n-            \"mulw  $dst, $itmp, $isrc\\n\\t\"\n-            \"sxtb  $dst, $dst\\n\\t\"\n-            \"umov  $itmp, $vtmp2, B, 1\\n\\t\"\n-            \"mulw  $dst, $itmp, $dst\\n\\t\"\n-            \"sxtb  $dst, $dst\\t# mul reduction8B\"\n-  %}\n-  ins_encode %{\n-    __ ins(as_FloatRegister($vtmp1$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp1$$reg), __ T8B,\n-            as_FloatRegister($vtmp1$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($vtmp2$$reg), __ H,\n-           as_FloatRegister($vtmp1$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp2$$reg), __ T8B,\n-            as_FloatRegister($vtmp2$$reg), as_FloatRegister($vtmp1$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ B, 0);\n-    __ mulw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ B, 1);\n-    __ mulw($dst$$Register, $itmp$$Register, $dst$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_mul16B(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp1, vecX vtmp2, iRegINoSp itmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (MulReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP itmp);\n-  format %{ \"ins   $vtmp1, D, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp1, T8B, $vtmp1, $vsrc\\n\\t\"\n-            \"ins   $vtmp2, S, $vtmp1, 0, 1\\n\\t\"\n-            \"mulv  $vtmp1, T8B, $vtmp2, $vtmp1\\n\\t\"\n-            \"ins   $vtmp2, H, $vtmp1, 0, 1\\n\\t\"\n-            \"mulv  $vtmp2, T8B, $vtmp2, $vtmp1\\n\\t\"\n-            \"umov  $itmp, $vtmp2, B, 0\\n\\t\"\n-            \"mulw  $dst, $itmp, $isrc\\n\\t\"\n-            \"sxtb  $dst, $dst\\n\\t\"\n-            \"umov  $itmp, $vtmp2, B, 1\\n\\t\"\n-            \"mulw  $dst, $itmp, $dst\\n\\t\"\n-            \"sxtb  $dst, $dst\\t# mul reduction16B\"\n-  %}\n-  ins_encode %{\n-    __ ins(as_FloatRegister($vtmp1$$reg), __ D,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp1$$reg), __ T8B,\n-            as_FloatRegister($vtmp1$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($vtmp2$$reg), __ S,\n-           as_FloatRegister($vtmp1$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp1$$reg), __ T8B,\n-            as_FloatRegister($vtmp2$$reg), as_FloatRegister($vtmp1$$reg));\n-    __ ins(as_FloatRegister($vtmp2$$reg), __ H,\n-           as_FloatRegister($vtmp1$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp2$$reg), __ T8B,\n-            as_FloatRegister($vtmp2$$reg), as_FloatRegister($vtmp1$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ B, 0);\n-    __ mulw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ B, 1);\n-    __ mulw($dst$$Register, $itmp$$Register, $dst$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_mul4S(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD vtmp, iRegINoSp itmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (MulReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP vtmp, TEMP itmp);\n-  format %{ \"ins   $vtmp, S, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp, T4H, $vtmp, $vsrc\\n\\t\"\n-            \"umov  $itmp, $vtmp, H, 0\\n\\t\"\n-            \"mulw  $dst, $itmp, $isrc\\n\\t\"\n-            \"sxth  $dst, $dst\\n\\t\"\n-            \"umov  $itmp, $vtmp, H, 1\\n\\t\"\n-            \"mulw  $dst, $itmp, $dst\\n\\t\"\n-            \"sxth  $dst, $dst\\t# mul reduction4S\"\n-  %}\n-  ins_encode %{\n-    __ ins(as_FloatRegister($vtmp$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp$$reg), __ T4H,\n-            as_FloatRegister($vtmp$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ H, 0);\n-    __ mulw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ H, 1);\n-    __ mulw($dst$$Register, $itmp$$Register, $dst$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_mul8S(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp1, vecX vtmp2, iRegINoSp itmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (MulReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP itmp);\n-  format %{ \"ins   $vtmp1, D, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp1, T4H, $vtmp1, $vsrc\\n\\t\"\n-            \"ins   $vtmp2, S, $vtmp1, 0, 1\\n\\t\"\n-            \"mulv  $vtmp2, T4H, $vtmp2, $vtmp1\\n\\t\"\n-            \"umov  $itmp, $vtmp2, H, 0\\n\\t\"\n-            \"mulw  $dst, $itmp, $isrc\\n\\t\"\n-            \"sxth  $dst, $dst\\n\\t\"\n-            \"umov  $itmp, $vtmp2, H, 1\\n\\t\"\n-            \"mulw  $dst, $itmp, $dst\\n\\t\"\n-            \"sxth  $dst, $dst\\t# mul reduction8S\"\n-  %}\n-  ins_encode %{\n-    __ ins(as_FloatRegister($vtmp1$$reg), __ D,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp1$$reg), __ T4H,\n-            as_FloatRegister($vtmp1$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($vtmp2$$reg), __ S,\n-           as_FloatRegister($vtmp1$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp2$$reg), __ T4H,\n-            as_FloatRegister($vtmp2$$reg), as_FloatRegister($vtmp1$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ H, 0);\n-    __ mulw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ H, 1);\n-    __ mulw($dst$$Register, $itmp$$Register, $dst$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_mul2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, iRegLNoSp tmp)\n-%{\n-  match(Set dst (MulReductionVL isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov  $tmp, $vsrc, D, 0\\n\\t\"\n-            \"mul   $dst, $isrc, $tmp\\n\\t\"\n-            \"umov  $tmp, $vsrc, D, 1\\n\\t\"\n-            \"mul   $dst, $dst, $tmp\\t# mul reduction2L\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ mul($dst$$Register, $isrc$$Register, $tmp$$Register);\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ mul($dst$$Register, $dst$$Register, $tmp$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-dnl\n-define(`REDUCE_MAX_MIN_INT', `\n-instruct reduce_$1$2$3`'(iRegINoSp dst, iRegIorL2I isrc, vec$4 vsrc, vec$4 tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($3));\n-  match(Set dst ($5ReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"s$1v $tmp, T$2`'iTYPE2SIMD($3), $vsrc\\n\\t\"\n-            \"$6mov  $dst, $tmp, iTYPE2SIMD($3), 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc $7\\t# $1 reduction$2$3\"\n-  %}\n-  ins_encode %{\n-    __ s$1v(as_FloatRegister($tmp$$reg), __ T$2`'iTYPE2SIMD($3), as_FloatRegister($vsrc$$reg));\n-    __ $6mov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ iTYPE2SIMD($3), 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::$7);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl                $1   $2  $3 $4 $5   $6 $7\n-REDUCE_MAX_MIN_INT(max, 8,  B, D, Max, s, GT)\n-REDUCE_MAX_MIN_INT(max, 16, B, X, Max, s, GT)\n-REDUCE_MAX_MIN_INT(max, 4,  S, D, Max, s, GT)\n-REDUCE_MAX_MIN_INT(max, 8,  S, X, Max, s, GT)\n-REDUCE_MAX_MIN_INT(max, 4,  I, X, Max, u, GT)\n-REDUCE_MAX_MIN_INT(min, 8,  B, D, Min, s, LT)\n-REDUCE_MAX_MIN_INT(min, 16, B, X, Min, s, LT)\n-REDUCE_MAX_MIN_INT(min, 4,  S, D, Min, s, LT)\n-REDUCE_MAX_MIN_INT(min, 8,  S, X, Min, s, LT)\n-REDUCE_MAX_MIN_INT(min, 4,  I, X, Min, u, LT)\n-dnl\n-define(`REDUCE_MAX_MIN_2I', `\n-instruct reduce_$1`'2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst ($2ReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"s$1p $tmp, T2S, $vsrc, $vsrc\\n\\t\"\n-            \"umov  $dst, $tmp, S, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc $3\\t# $1 reduction2I\"\n-  %}\n-  ins_encode %{\n-    __ s$1p(as_FloatRegister($tmp$$reg), __ T2S, as_FloatRegister($vsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ S, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::$3);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl               $1   $2   $3\n-REDUCE_MAX_MIN_2I(max, Max, GT)\n-REDUCE_MAX_MIN_2I(min, Min, LT)\n-dnl\n-define(`REDUCE_MAX_MIN_2L', `\n-instruct reduce_$1`'2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, iRegLNoSp tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst ($2ReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"umov  $tmp, $vsrc, D, 0\\n\\t\"\n-            \"cmp   $isrc,$tmp\\n\\t\"\n-            \"csel  $dst, $isrc, $tmp $3\\n\\t\"\n-            \"umov  $tmp, $vsrc, D, 1\\n\\t\"\n-            \"cmp   $dst, $tmp\\n\\t\"\n-            \"csel  $dst, $dst, $tmp $3\\t# $1 reduction2L\"\n-  %}\n-  ins_encode %{\n-    __ umov(as_Register($tmp$$reg), as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ cmp(as_Register($isrc$$reg), as_Register($tmp$$reg));\n-    __ csel(as_Register($dst$$reg), as_Register($isrc$$reg), as_Register($tmp$$reg), Assembler::$3);\n-    __ umov(as_Register($tmp$$reg), as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ cmp(as_Register($dst$$reg), as_Register($tmp$$reg));\n-    __ csel(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($tmp$$reg), Assembler::$3);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl               $1   $2   $3\n-REDUCE_MAX_MIN_2L(max, Max, GT)\n-REDUCE_MAX_MIN_2L(min, Min, LT)\n-dnl\n-define(`REDUCE_MINMAX_FORD', `\n-instruct reduce_$1$4$5(vReg$5 dst, vReg$5 $6src, vec$7 vsrc) %{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_`'ifelse($5, F, FLOAT, DOUBLE));\n-  match(Set dst (ifelse($1, max, Max, Min)ReductionV $6src vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"$2 $dst, ifelse($4, 2, $vsrc`, 'ifelse($5, F, S, D), ` T4S, $vsrc')\\n\\t\"\n-            \"$3 $dst, $dst, $$6src\\t# $1 reduction$4$5\" %}\n-  ins_encode %{\n-    __ $2(as_FloatRegister($dst$$reg), ifelse($4, 4, `__ T4S, as_FloatRegister($vsrc$$reg))',\n-                                              $4$5, 2F, `as_FloatRegister($vsrc$$reg), __ S)',\n-                                              $4$5, 2D, `as_FloatRegister($vsrc$$reg), __ D)');\n-    __ $3(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($$6src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl                $1   $2     $3     $4 $5 $6 $7\n-REDUCE_MINMAX_FORD(max, fmaxp, fmaxs, 2, F, f, D)\n-REDUCE_MINMAX_FORD(max, fmaxv, fmaxs, 4, F, f, X)\n-REDUCE_MINMAX_FORD(max, fmaxp, fmaxd, 2, D, d, X)\n-REDUCE_MINMAX_FORD(min, fminp, fmins, 2, F, f, D)\n-REDUCE_MINMAX_FORD(min, fminv, fmins, 4, F, f, X)\n-REDUCE_MINMAX_FORD(min, fminp, fmind, 2, D, d, X)\n-dnl\n-define(`REDUCE_LOGIC_OP_8B', `\n-instruct reduce_$1`'8B(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst ($2ReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, S, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, S, 1\\n\\t\"\n-            \"$1w   $dst, $dst, $tmp\\n\\t\"\n-            \"$1w   $dst, $dst, $dst, LSR #16\\n\\t\"\n-            \"$1w   $dst, $dst, $dst, LSR #8\\n\\t\"\n-            \"$1w   $dst, $isrc, $dst\\n\\t\"\n-            \"sxtb   $dst, $dst\\t# $1 reduction8B\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);\n-    __ $1w($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ $1w($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 16);\n-    __ $1w($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 8);\n-    __ $1w($dst$$Register, $isrc$$Register, $dst$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl                $1   $2\n-REDUCE_LOGIC_OP_8B(and, And)\n-REDUCE_LOGIC_OP_8B(orr, Or)\n-REDUCE_LOGIC_OP_8B(eor, Xor)\n-define(`REDUCE_LOGIC_OP_16B', `\n-instruct reduce_$1`'16B(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst ($2ReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, D, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, D, 1\\n\\t\"\n-            \"$3   $dst, $dst, $tmp\\n\\t\"\n-            \"$3   $dst, $dst, $dst, LSR #32\\n\\t\"\n-            \"$1w   $dst, $dst, $dst, LSR #16\\n\\t\"\n-            \"$1w   $dst, $dst, $dst, LSR #8\\n\\t\"\n-            \"$1w   $dst, $isrc, $dst\\n\\t\"\n-            \"sxtb   $dst, $dst\\t# $1 reduction16B\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ $3($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ $3($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 32);\n-    __ $1w($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 16);\n-    __ $1w($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 8);\n-    __ $1w($dst$$Register, $isrc$$Register, $dst$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl                 $1   $2   $3\n-REDUCE_LOGIC_OP_16B(and, And, andr)\n-REDUCE_LOGIC_OP_16B(orr, Or,  orr )\n-REDUCE_LOGIC_OP_16B(eor, Xor, eor )\n-dnl\n-define(`REDUCE_LOGIC_OP_4S', `\n-instruct reduce_$1`'4S(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst ($2ReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, S, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, S, 1\\n\\t\"\n-            \"$1w   $dst, $dst, $tmp\\n\\t\"\n-            \"$1w   $dst, $dst, $dst, LSR #16\\n\\t\"\n-            \"$1w   $dst, $isrc, $dst\\n\\t\"\n-            \"sxth   $dst, $dst\\t# $1 reduction4S\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);\n-    __ $1w($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ $1w($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 16);\n-    __ $1w($dst$$Register, $isrc$$Register, $dst$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl                $1   $2\n-REDUCE_LOGIC_OP_4S(and, And)\n-REDUCE_LOGIC_OP_4S(orr, Or)\n-REDUCE_LOGIC_OP_4S(eor, Xor)\n-dnl\n-define(`REDUCE_LOGIC_OP_8S', `\n-instruct reduce_$1`'8S(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst ($2ReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, D, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, D, 1\\n\\t\"\n-            \"$3   $dst, $dst, $tmp\\n\\t\"\n-            \"$3   $dst, $dst, $dst, LSR #32\\n\\t\"\n-            \"$1w   $dst, $dst, $dst, LSR #16\\n\\t\"\n-            \"$1w   $dst, $isrc, $dst\\n\\t\"\n-            \"sxth   $dst, $dst\\t# $1 reduction8S\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ $3($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ $3($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 32);\n-    __ $1w($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 16);\n-    __ $1w($dst$$Register, $isrc$$Register, $dst$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl                $1   $2   $3\n-REDUCE_LOGIC_OP_8S(and, And, andr)\n-REDUCE_LOGIC_OP_8S(orr, Or,  orr )\n-REDUCE_LOGIC_OP_8S(eor, Xor, eor )\n-dnl\n-define(`REDUCE_LOGIC_OP_2I', `\n-instruct reduce_$1`'2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst ($2ReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov  $tmp, $vsrc, S, 0\\n\\t\"\n-            \"$1w  $dst, $tmp, $isrc\\n\\t\"\n-            \"umov  $tmp, $vsrc, S, 1\\n\\t\"\n-            \"$1w  $dst, $tmp, $dst\\t# $1 reduction2I\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);\n-    __ $1w($dst$$Register, $tmp$$Register, $isrc$$Register);\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);\n-    __ $1w($dst$$Register, $tmp$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl                $1   $2\n-REDUCE_LOGIC_OP_2I(and, And)\n-REDUCE_LOGIC_OP_2I(orr, Or)\n-REDUCE_LOGIC_OP_2I(eor, Xor)\n-dnl\n-define(`REDUCE_LOGIC_OP_4I', `\n-instruct reduce_$1`'4I(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst ($2ReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, D, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, D, 1\\n\\t\"\n-            \"$3   $dst, $dst, $tmp\\n\\t\"\n-            \"$3   $dst, $dst, $dst, LSR #32\\n\\t\"\n-            \"$1w   $dst, $isrc, $dst\\t# $1 reduction4I\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ $3($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ $3($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 32);\n-    __ $1w($dst$$Register, $isrc$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl                $1   $2   $3\n-REDUCE_LOGIC_OP_4I(and, And, andr)\n-REDUCE_LOGIC_OP_4I(orr, Or,  orr )\n-REDUCE_LOGIC_OP_4I(eor, Xor, eor )\n-dnl\n-define(`REDUCE_LOGIC_OP_2L', `\n-instruct reduce_$1`'2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, iRegLNoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst ($2ReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov  $tmp, $vsrc, D, 0\\n\\t\"\n-            \"$3  $dst, $isrc, $tmp\\n\\t\"\n-            \"umov  $tmp, $vsrc, D, 1\\n\\t\"\n-            \"$3  $dst, $dst, $tmp\\t# $1 reduction2L\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ $3($dst$$Register, $isrc$$Register, $tmp$$Register);\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ $3($dst$$Register, $dst$$Register, $tmp$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl                $1   $2   $3\n-REDUCE_LOGIC_OP_2L(and, And, andr)\n-REDUCE_LOGIC_OP_2L(orr, Or,  orr )\n-REDUCE_LOGIC_OP_2L(eor, Xor, eor )\n-dnl\n-\n-\/\/ ------------------------------ Vector insert ---------------------------------\n-dnl VECTOR_INSERT_I($1,        $2,                     $3,          $4,   $5)\n-dnl VECTOR_INSERT_I(rule_name, vector_length_in_bytes, reg_variant, vreg, ireg)\n-define(`VECTOR_INSERT_I', `\n-instruct $1($4 dst, $4 src, $5 val, immI idx)\n-%{\n-  predicate(ifelse($3, D, n->bottom_type()->is_vect()->element_basic_type() == T_LONG,\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_INT)));\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(2 * INSN_COST);\n-  format %{ \"orr    $dst, T$2B, $src, $src\\n\\t\"\n-            \"mov    $dst, $3, $idx, $val\\t`#' insert into vector ($3)\" %}\n-  ins_encode %{\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ orr(as_FloatRegister($dst$$reg), __ T$2B,\n-             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    }\n-    __ mov(as_FloatRegister($dst$$reg), __ ifelse($3, D, D, elemType_to_regVariant(Matcher::vector_element_basic_type(this))),\n-           $idx$$constant, $val$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl             $1        $2  $3     $4    $5\n-VECTOR_INSERT_I(insertID, 8,  B\/H\/S, vecD, iRegIorL2I)\n-VECTOR_INSERT_I(insertIX, 16, B\/H\/S, vecX, iRegIorL2I)\n-VECTOR_INSERT_I(insert2L, 16, D,     vecX, iRegL)\n-dnl\n-define(`VECTOR_INSERT_F', `\n-instruct insert$3`'(vec$2 dst, vec$2 src, vReg$1 val, immI idx)\n-%{\n-  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($1));\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(2 * INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"orr    $dst, ifelse($2, D, T8B, T16B), $src, $src\\n\\t\"\n-            \"ins    $dst, ifelse($1, F, S, D), $val, $idx, 0\\t# insert into vector($3)\" %}\n-  ins_encode %{\n-    __ orr(as_FloatRegister($dst$$reg), __ ifelse($2, D, T8B, T16B),\n-           as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ ins(as_FloatRegister($dst$$reg), __ ifelse($1, F, S, D),\n-           as_FloatRegister($val$$reg), $idx$$constant, 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl             $1 $2 $3\n-VECTOR_INSERT_F(F, D, 2F)\n-VECTOR_INSERT_F(F, X, 4F)\n-VECTOR_INSERT_F(D, X, 2D)\n-dnl\n-\n-\/\/ ------------------------------ Vector extract ---------------------------------\n-define(`VECTOR_EXTRACT_I', `\n-instruct extract$1$2`'(iReg$3NoSp dst, vec$4 src, immI idx)\n-%{\n-  predicate(n->in(1)->bottom_type()->is_vect()->length() == $1);\n-  match(Set dst (Extract$2 src idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"$5mov    $dst, $src, $6, $idx\\t# extract from vector($1$2)\" %}\n-  ins_encode %{\n-    __ $5mov($dst$$Register, as_FloatRegister($src$$reg), __ $6, $idx$$constant);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl             $1   $2 $3 $4 $5 $6\n-VECTOR_EXTRACT_I(8,  B, I, D, s, B)\n-VECTOR_EXTRACT_I(16, B, I, X, s, B)\n-VECTOR_EXTRACT_I(4,  S, I, D, s, H)\n-VECTOR_EXTRACT_I(8,  S, I, X, s, H)\n-VECTOR_EXTRACT_I(2,  I, I, D, u, S)\n-VECTOR_EXTRACT_I(4,  I, I, X, u, S)\n-VECTOR_EXTRACT_I(2,  L, L, X, u, D)\n-dnl\n-define(`VECTOR_EXTRACT_F', `\n-instruct extract$1$2`'(vReg$2 dst, vec$3 src, immI idx)\n-%{\n-  predicate(n->in(1)->bottom_type()->is_vect()->length() == $1);\n-  match(Set dst (Extract$2 src idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"ins   $dst, $4, $src, 0, $idx\\t# extract from vector($1$2)\" %}\n-  ins_encode %{\n-    if ((0 == $idx$$constant) &&\n-        (as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg))) {\n-      \/* empty *\/\n-    } else if ($idx$$constant == 0) {\n-      __ ifelse($2, F, fmovs, fmovd)(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n-    } else {\n-      __ ins(as_FloatRegister($dst$$reg), __ $4,\n-             as_FloatRegister($src$$reg), 0, $idx$$constant);\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl             $1  $2 $3 $4\n-VECTOR_EXTRACT_F(2, F, D, S)\n-VECTOR_EXTRACT_F(4, F, X, S)\n-VECTOR_EXTRACT_F(2, D, X, D)\n-dnl\n-\n-\/\/ ------------------------------ Vector comparison ---------------------------------\n-\n-instruct vcmpD(vecD dst, vecD src1, vecD src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 8);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"vcmpD  $dst, $src1, $src2\\t# vector compare \" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    assert(type2aelembytes(bt) != 8, \"not supported\");\n-    __ neon_compare(as_FloatRegister($dst$$reg), bt, as_FloatRegister($src1$$reg),\n-                    as_FloatRegister($src2$$reg), (int)$cond$$constant, \/*isQ*\/ false);\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vcmpX(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"vcmpX  $dst, $src1, $src2\\t# vector compare \" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ neon_compare(as_FloatRegister($dst$$reg), bt, as_FloatRegister($src1$$reg),\n-                    as_FloatRegister($src2$$reg), (int)$cond$$constant, \/*isQ*\/ true);\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-\/\/ ------------------------------ Vector mul -----------------------------------\n-\n-instruct vmul2L(vecX dst, vecX src1, vecX src2, iRegLNoSp tmp1, iRegLNoSp tmp2)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (MulVL src1 src2));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp1, TEMP tmp2);\n-  format %{ \"umov   $tmp1, $src1, D, 0\\n\\t\"\n-            \"umov   $tmp2, $src2, D, 0\\n\\t\"\n-            \"mul    $tmp2, $tmp2, $tmp1\\n\\t\"\n-            \"mov    $dst,  T2D,   0, $tmp2\\t# insert into vector(2L)\\n\\t\"\n-            \"umov   $tmp1, $src1, D, 1\\n\\t\"\n-            \"umov   $tmp2, $src2, D, 1\\n\\t\"\n-            \"mul    $tmp2, $tmp2, $tmp1\\n\\t\"\n-            \"mov    $dst,  T2D,   1, $tmp2\\t# insert into vector(2L)\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp1$$Register, as_FloatRegister($src1$$reg), __ D, 0);\n-    __ umov($tmp2$$Register, as_FloatRegister($src2$$reg), __ D, 0);\n-    __ mul(as_Register($tmp2$$reg), as_Register($tmp2$$reg), as_Register($tmp1$$reg));\n-    __ mov(as_FloatRegister($dst$$reg), __ D, 0, $tmp2$$Register);\n-    __ umov($tmp1$$Register, as_FloatRegister($src1$$reg), __ D, 1);\n-    __ umov($tmp2$$Register, as_FloatRegister($src2$$reg), __ D, 1);\n-    __ mul(as_Register($tmp2$$reg), as_Register($tmp2$$reg), as_Register($tmp1$$reg));\n-    __ mov(as_FloatRegister($dst$$reg), __ D, 1, $tmp2$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ --------------------------------- Vector not --------------------------------\n-dnl\n-define(`MATCH_RULE', `ifelse($1, I,\n-`match(Set dst (XorV src (ReplicateB m1)));\n-  match(Set dst (XorV src (ReplicateS m1)));\n-  match(Set dst (XorV src (ReplicateI m1)));',\n-`match(Set dst (XorV src (ReplicateL m1)));')')dnl\n-dnl\n-define(`VECTOR_NOT', `\n-instruct vnot$1$2`'(vec$3 dst, vec$3 src, imm$2_M1 m1)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == $4);\n-  MATCH_RULE($2)\n-  ins_cost(INSN_COST);\n-  format %{ \"not  $dst, T$5, $src\\t# vector ($5)\" %}\n-  ins_encode %{\n-    __ notr(as_FloatRegister($dst$$reg), __ T$5,\n-            as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl        $1 $2 $3 $4  $5\n-VECTOR_NOT(2, I, D, 8,  8B)\n-VECTOR_NOT(4, I, X, 16, 16B)\n-VECTOR_NOT(2, L, X, 16, 16B)\n-undefine(MATCH_RULE)\n-\/\/ ------------------------------ Vector and_not -------------------------------\n-dnl\n-define(`MATCH_RULE', `ifelse($1, I,\n-`match(Set dst (AndV src1 (XorV src2 (ReplicateB m1))));\n-  match(Set dst (AndV src1 (XorV src2 (ReplicateS m1))));\n-  match(Set dst (AndV src1 (XorV src2 (ReplicateI m1))));',\n-`match(Set dst (AndV src1 (XorV src2 (ReplicateL m1))));')')dnl\n-dnl\n-define(`VECTOR_AND_NOT', `\n-instruct vand_not$1$2`'(vec$3 dst, vec$3 src1, vec$3 src2, imm$2_M1 m1)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == $4);\n-  MATCH_RULE($2)\n-  ins_cost(INSN_COST);\n-  format %{ \"bic  $dst, T$5, $src1, $src2\\t# vector ($5)\" %}\n-  ins_encode %{\n-    __ bic(as_FloatRegister($dst$$reg), __ T$5,\n-           as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl            $1 $2 $3 $4  $5\n-VECTOR_AND_NOT(2, I, D, 8,  8B)\n-VECTOR_AND_NOT(4, I, X, 16, 16B)\n-VECTOR_AND_NOT(2, L, X, 16, 16B)\n-undefine(MATCH_RULE)\n-dnl\n-\/\/ ------------------------------ Vector max\/min -------------------------------\n-dnl\n-define(`PREDICATE', `ifelse($1, 8B,\n-`predicate((n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8) &&\n-             n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);',\n-`predicate(n->as_Vector()->length() == $2 && n->bottom_type()->is_vect()->element_basic_type() == T_$3);')')dnl\n-dnl\n-define(`VECTOR_MAX_MIN_INT', `\n-instruct v$1$2$3`'(vec$4 dst, vec$4 src1, vec$4 src2)\n-%{\n-  PREDICATE(`$2$3', $2, TYPE2DATATYPE($3))\n-  match(Set dst ($5V src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"$1v  $dst, T$2`'iTYPE2SIMD($3), $src1, $src2\\t# vector ($2$3)\" %}\n-  ins_encode %{\n-    __ $1v(as_FloatRegister($dst$$reg), __ T$2`'iTYPE2SIMD($3),\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop$6);\n-%}')dnl\n-dnl                $1   $2  $3 $4 $5   $6\n-VECTOR_MAX_MIN_INT(max, 8,  B, D, Max, 64)\n-VECTOR_MAX_MIN_INT(max, 16, B, X, Max, 128)\n-VECTOR_MAX_MIN_INT(max, 4,  S, D, Max, 64)\n-VECTOR_MAX_MIN_INT(max, 8,  S, X, Max, 128)\n-VECTOR_MAX_MIN_INT(max, 2,  I, D, Max, 64)\n-VECTOR_MAX_MIN_INT(max, 4,  I, X, Max, 128)\n-VECTOR_MAX_MIN_INT(min, 8,  B, D, Min, 64)\n-VECTOR_MAX_MIN_INT(min, 16, B, X, Min, 128)\n-VECTOR_MAX_MIN_INT(min, 4,  S, D, Min, 64)\n-VECTOR_MAX_MIN_INT(min, 8,  S, X, Min, 128)\n-VECTOR_MAX_MIN_INT(min, 2,  I, D, Min, 64)\n-VECTOR_MAX_MIN_INT(min, 4,  I, X, Min, 128)\n-undefine(PREDICATE)\n-dnl\n-define(`VECTOR_MAX_MIN_LONG', `\n-instruct v$1`'2L`'(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst ($2V src1 src2));\n-  ins_cost(INSN_COST);\n-  effect(TEMP dst);\n-  format %{ \"cmgt  $dst, T2D, $src1, $src2\\t# vector (2L)\\n\\t\"\n-            \"bsl   $dst, T16B, $$3, $$4\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ cmgt(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-    __ bsl(as_FloatRegister($dst$$reg), __ T16B,\n-           as_FloatRegister($$3$$reg), as_FloatRegister($$4$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}')dnl\n-dnl                 $1   $2   $3    $4\n-VECTOR_MAX_MIN_LONG(max, Max, src1, src2)\n-VECTOR_MAX_MIN_LONG(min, Min, src2, src1)\n-dnl\n-\n-\/\/ --------------------------------- blend (bsl) ----------------------------\n-dnl\n-define(`VECTOR_BSL', `\n-instruct vbsl$1B`'(vec$2 dst, vec$2 src1, vec$2 src2)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == $1);\n-  match(Set dst (VectorBlend (Binary src1 src2) dst));\n-  ins_cost(INSN_COST);\n-  format %{ \"bsl  $dst, T$1B, $src2, $src1\\t# vector ($1B)\" %}\n-  ins_encode %{\n-    __ bsl(as_FloatRegister($dst$$reg), __ T$1B,\n-           as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(vlogical$3);\n-%}')dnl\n-dnl        $1  $2 $3\n-VECTOR_BSL(8,  D, 64)\n-VECTOR_BSL(16, X, 128)\n-dnl\n-\n-\/\/ --------------------------------- Load\/store Mask ----------------------------\n-dnl\n-define(`PREDICATE', `ifelse($1, load,\n-`predicate(n->as_Vector()->length() == $2 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);',\n-`predicate(n->as_Vector()->length() == $2);')')dnl\n-dnl\n-define(`VECTOR_LOAD_STORE_MASK_B', `\n-instruct $1mask$2B`'(vec$3 dst, vec$3 src $5 $6)\n-%{\n-  PREDICATE($1, $2)\n-  match(Set dst (Vector$4Mask src $6));\n-  ins_cost(INSN_COST);\n-  format %{ \"negr  $dst, T$2B, $src\\t# $1 mask ($2B to $2B)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T$2B, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl                      $1     $2  $3 $4     $5      $6\n-VECTOR_LOAD_STORE_MASK_B(load,  8,  D, Load)\n-VECTOR_LOAD_STORE_MASK_B(load,  16, X, Load)\n-VECTOR_LOAD_STORE_MASK_B(store, 8,  D, Store, `, immI_1', size)\n-VECTOR_LOAD_STORE_MASK_B(store, 16, X, Store, `, immI_1', size)\n-undefine(PREDICATE)dnl\n-dnl\n-define(`PREDICATE', `ifelse($1, load,\n-`predicate(n->as_Vector()->length() == $2 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);',\n-`predicate(n->as_Vector()->length() == $2);')')dnl\n-dnl\n-define(`VECTOR_LOAD_STORE_MASK_S', `\n-instruct $1mask$2S`'(vec$3 dst, vec$4 src $9 $10)\n-%{\n-  PREDICATE($1, $2)\n-  match(Set dst (Vector$5Mask src $10));\n-  ins_cost(INSN_COST);\n-  format %{ \"$6  $dst, T8$8, $src, T8$7\\n\\t\"\n-            \"negr  $dst, T8$8, $dst\\t# $1 mask ($2$7 to $2$8)\" %}\n-  ins_encode %{\n-    __ $6(as_FloatRegister($dst$$reg), __ T8$8, as_FloatRegister($src$$reg), __ T8$7);\n-    __ negr(as_FloatRegister($dst$$reg), __ T8$8, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl                      $1     $2 $3 $4 $5     $6    $7 $8    $9       $10\n-VECTOR_LOAD_STORE_MASK_S(load,  4, D, D, Load,  uxtl, B, H)\n-VECTOR_LOAD_STORE_MASK_S(load,  8, X, D, Load,  uxtl, B, H)\n-VECTOR_LOAD_STORE_MASK_S(store, 4, D, D, Store, xtn,  H, B, `, immI_2', size)\n-VECTOR_LOAD_STORE_MASK_S(store, 8, D, X, Store, xtn,  H, B, `, immI_2', size)\n-undefine(PREDICATE)dnl\n-dnl\n-define(`PREDICATE', `ifelse($1, load,\n-`predicate(n->as_Vector()->length() == $2 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));',\n-`predicate(n->as_Vector()->length() == $2);')')dnl\n-dnl\n-define(`VECTOR_LOAD_STORE_MASK_I', `\n-instruct $1mask$2I`'(vec$3 dst, vec$4 src $12 $13)\n-%{\n-  PREDICATE($1, $2)\n-  match(Set dst (Vector$5Mask src $13));\n-  ins_cost(INSN_COST);\n-  format %{ \"$6  $dst, T$10$8, $src, T$10$7\\t# $2$7 to $2$8\\n\\t\"\n-            \"$6  $dst, T$11$9, $dst, T$11$8\\t# $2$8 to $2$9\\n\\t\"\n-            \"negr   $dst, T$11$9, $dst\\t# $1 mask ($2$7 to $2$9)\" %}\n-  ins_encode %{\n-    __ $6(as_FloatRegister($dst$$reg), __ T$10$8, as_FloatRegister($src$$reg), __ T$10$7);\n-    __ $6(as_FloatRegister($dst$$reg), __ T$11$9, as_FloatRegister($dst$$reg), __ T$11$8);\n-    __ negr(as_FloatRegister($dst$$reg), __ T$11$9, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl                      $1     $2 $3 $4 $5     $6    $7 $8 $9 $10$11   $12      $13\n-VECTOR_LOAD_STORE_MASK_I(load,  2, D, D, Load,  uxtl, B, H, S, 8, 4)\n-VECTOR_LOAD_STORE_MASK_I(load,  4, X, D, Load,  uxtl, B, H, S, 8, 4)\n-VECTOR_LOAD_STORE_MASK_I(store, 2, D, D, Store, xtn,  S, H, B, 4, 8, `, immI_4', size)\n-VECTOR_LOAD_STORE_MASK_I(store, 4, D, X, Store, xtn,  S, H, B, 4, 8, `, immI_4', size)\n-undefine(PREDICATE)\n-dnl\n-instruct loadmask2L(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n-  match(Set dst (VectorLoadMask src));\n-  ins_cost(INSN_COST);\n-  format %{ \"uxtl  $dst, T8H, $src, T8B\\t# 2B to 2S\\n\\t\"\n-            \"uxtl  $dst, T4S, $dst, T4H\\t# 2S to 2I\\n\\t\"\n-            \"uxtl  $dst, T2D, $dst, T2S\\t# 2I to 2L\\n\\t\"\n-            \"neg   $dst, T2D, $dst\\t# load mask (2B to 2L)\" %}\n-  ins_encode %{\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($dst$$reg), __ T4H);\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($dst$$reg), __ T2S);\n-    __ negr(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct storemask2L(vecD dst, vecX src, immI_8 size)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (VectorStoreMask src size));\n-  ins_cost(INSN_COST);\n-  format %{ \"xtn  $dst, T2S, $src, T2D\\t# 2L to 2I\\n\\t\"\n-            \"xtn  $dst, T4H, $dst, T4S\\t# 2I to 2S\\n\\t\"\n-            \"xtn  $dst, T8B, $dst, T8H\\t# 2S to 2B\\n\\t\"\n-            \"neg  $dst, T8B, $dst\\t# store mask (2L to 2B)\" %}\n-  ins_encode %{\n-    __ xtn(as_FloatRegister($dst$$reg), __ T2S, as_FloatRegister($src$$reg), __ T2D);\n-    __ xtn(as_FloatRegister($dst$$reg), __ T4H, as_FloatRegister($dst$$reg), __ T4S);\n-    __ xtn(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($dst$$reg), __ T8H);\n-    __ negr(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector mask cast\n-dnl\n-define(`VECTOR_MASK_CAST', `\n-instruct vmaskcast$1`'(vec$1 dst)\n-%{\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == $2 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == $2 &&\n-            n->bottom_type()->is_vect()->length() == n->in(1)->bottom_type()->is_vect()->length());\n-  match(Set dst (VectorMaskCast dst));\n-  ins_cost(0);\n-  format %{ \"vmaskcast $dst\\t# empty\" %}\n-  ins_encode %{\n-    \/\/ empty\n-  %}\n-  ins_pipe(pipe_class_empty);\n-%}')dnl\n-dnl              $1 $2\n-VECTOR_MASK_CAST(D, 8)\n-VECTOR_MASK_CAST(X, 16)\n-dnl\n-\n-\/\/-------------------------------- LOAD_IOTA_INDICES----------------------------------\n-dnl\n-define(`PREDICATE', `ifelse($1, 8,\n-`predicate(UseSVE == 0 &&\n-           (n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4 ||\n-            n->as_Vector()->length() == 8) &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);',\n-`predicate(UseSVE == 0 && n->as_Vector()->length() == 16 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);')')dnl\n-dnl\n-define(`VECTOR_LOAD_CON', `\n-instruct loadcon$1B`'(vec$2 dst, immI0 src)\n-%{\n-  PREDICATE($1)\n-  match(Set dst (VectorLoadConst src));\n-  ins_cost(INSN_COST);\n-  format %{ \"ldr $dst, CONSTANT_MEMORY\\t# load iota indices\" %}\n-  ins_encode %{\n-    __ lea(rscratch1, ExternalAddress(StubRoutines::aarch64::vector_iota_indices()));\n-    __ ldr$3(as_FloatRegister($dst$$reg), rscratch1);\n-  %}\n-  ins_pipe(pipe_class_memory);\n-%}')dnl\n-dnl             $1  $2 $3\n-VECTOR_LOAD_CON(8,  D, d)\n-VECTOR_LOAD_CON(16, X, q)\n-undefine(PREDICATE)\n-dnl\n-\/\/-------------------------------- LOAD_SHUFFLE ----------------------------------\n-dnl\n-define(`VECTOR_LOAD_SHUFFLE_B', `\n-instruct loadshuffle$1B`'(vec$2 dst, vec$2 src)\n-%{\n-  predicate(n->as_Vector()->length() == $1 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorLoadShuffle src));\n-  ins_cost(INSN_COST);\n-  format %{ \"mov  $dst, T$1B, $src\\t# get $1B shuffle\" %}\n-  ins_encode %{\n-    __ orr(as_FloatRegister($dst$$reg), __ T$1B,\n-           as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl                   $1  $2\n-VECTOR_LOAD_SHUFFLE_B(8,  D)\n-VECTOR_LOAD_SHUFFLE_B(16, X)\n-dnl\n-define(`VECTOR_LOAD_SHUFFLE_S', `\n-instruct loadshuffle$1S`'(vec$2 dst, vec$3 src)\n-%{\n-  predicate(n->as_Vector()->length() == $1 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorLoadShuffle src));\n-  ins_cost(INSN_COST);\n-  format %{ \"uxtl  $dst, T8H, $src, T8B\\t# $1B to $1H\" %}\n-  ins_encode %{\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl                   $1 $2 $3\n-VECTOR_LOAD_SHUFFLE_S(4, D, D)\n-VECTOR_LOAD_SHUFFLE_S(8, X, D)\n-dnl\n-\n-instruct loadshuffle4I(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 &&\n-           (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n-  match(Set dst (VectorLoadShuffle src));\n-  ins_cost(INSN_COST);\n-  format %{ \"uxtl  $dst, T8H, $src, T8B\\t# 4B to 4H \\n\\t\"\n-            \"uxtl  $dst, T4S, $dst, T4H\\t# 4H to 4S\" %}\n-  ins_encode %{\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($dst$$reg), __ T4H);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/-------------------------------- Rearrange -------------------------------------\n-\/\/ Here is an example that rearranges a NEON vector with 4 ints:\n-\/\/ Rearrange V1 int[a0, a1, a2, a3] to V2 int[a2, a3, a0, a1]\n-\/\/   1. Get the indices of V1 and store them as Vi byte[0, 1, 2, 3].\n-\/\/   2. Convert Vi byte[0, 1, 2, 3] to the indices of V2 and also store them as Vi byte[2, 3, 0, 1].\n-\/\/   3. Unsigned extend Long Vi from byte[2, 3, 0, 1] to int[2, 3, 0, 1].\n-\/\/   4. Multiply Vi int[2, 3, 0, 1] with constant int[0x04040404, 0x04040404, 0x04040404, 0x04040404]\n-\/\/      and get tbl base Vm int[0x08080808, 0x0c0c0c0c, 0x00000000, 0x04040404].\n-\/\/   5. Add Vm with constant int[0x03020100, 0x03020100, 0x03020100, 0x03020100]\n-\/\/      and get tbl index Vm int[0x0b0a0908, 0x0f0e0d0c, 0x03020100, 0x07060504]\n-\/\/   6. Use Vm as index register, and use V1 as table register.\n-\/\/      Then get V2 as the result by tbl NEON instructions.\n-\/\/ Notes:\n-\/\/   Step 1 matches VectorLoadConst.\n-\/\/   Step 3 matches VectorLoadShuffle.\n-\/\/   Step 4, 5, 6 match VectorRearrange.\n-\/\/   For VectorRearrange short\/int, the reason why such complex calculation is\n-\/\/   required is because NEON tbl supports bytes table only, so for short\/int, we\n-\/\/   need to lookup 2\/4 bytes as a group. For VectorRearrange long, we use bsl\n-\/\/   to implement rearrange.\n-define(`VECTOR_REARRANGE_B', `\n-instruct rearrange$1B`'(vec$2 dst, vec$2 src, vec$2 shuffle)\n-%{\n-  predicate(n->as_Vector()->length() == $1 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorRearrange src shuffle));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"tbl $dst, T$1B, {$dst}, $shuffle\\t# rearrange $1B\" %}\n-  ins_encode %{\n-    __ tbl(as_FloatRegister($dst$$reg), __ T$1B,\n-           as_FloatRegister($src$$reg), 1, as_FloatRegister($shuffle$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl                $1  $2\n-VECTOR_REARRANGE_B(8,  D)\n-VECTOR_REARRANGE_B(16, X)\n-dnl\n-define(`VECTOR_REARRANGE_S', `\n-instruct rearrange$1S`'(vec$2 dst, vec$2 src, vec$2 shuffle, vec$2 tmp0, vec$2 tmp1)\n-%{\n-  predicate(n->as_Vector()->length() == $1 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorRearrange src shuffle));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp0, TEMP tmp1);\n-  format %{ \"mov   $tmp0, T$3B, CONSTANT\\t# constant 0x0202020202020202\\n\\t\"\n-            \"mov   $tmp1, T$1H, CONSTANT\\t# constant 0x0100010001000100\\n\\t\"\n-            \"mulv  $dst, T$1H, T$1H, $shuffle, $tmp0\\n\\t\"\n-            \"addv  $dst, T$3B, T$3B, $dst, $tmp1\\n\\t\"\n-            \"tbl   $dst, T$3B, {$src}, 1, $dst\\t# rearrange $1S\" %}\n-  ins_encode %{\n-    __ mov(as_FloatRegister($tmp0$$reg), __ T$3B, 0x02);\n-    __ mov(as_FloatRegister($tmp1$$reg), __ T$1H, 0x0100);\n-    __ mulv(as_FloatRegister($dst$$reg), __ T$1H,\n-            as_FloatRegister($shuffle$$reg), as_FloatRegister($tmp0$$reg));\n-    __ addv(as_FloatRegister($dst$$reg), __ T$3B,\n-            as_FloatRegister($dst$$reg), as_FloatRegister($tmp1$$reg));\n-    __ tbl(as_FloatRegister($dst$$reg), __ T$3B,\n-           as_FloatRegister($src$$reg), 1, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl                $1 $2 $3\n-VECTOR_REARRANGE_S(4, D, 8)\n-VECTOR_REARRANGE_S(8, X, 16)\n-\n-instruct rearrange4I(vecX dst, vecX src, vecX shuffle, vecX tmp0, vecX tmp1)\n-%{\n-  predicate(n->as_Vector()->length() == 4 &&\n-           (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n-  match(Set dst (VectorRearrange src shuffle));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp0, TEMP tmp1);\n-  format %{ \"mov   $tmp0, T16B, CONSTANT\\t# constant 0x0404040404040404\\n\\t\"\n-            \"mov   $tmp1, T4S, CONSTANT\\t# constant 0x0302010003020100\\n\\t\"\n-            \"mulv  $dst, T4S, $shuffle, $tmp0\\n\\t\"\n-            \"addv  $dst, T16B, $dst, $tmp1\\n\\t\"\n-            \"tbl   $dst, T16B, {$src}, 1, $dst\\t# rearrange 4I\" %}\n-  ins_encode %{\n-    __ mov(as_FloatRegister($tmp0$$reg), __ T16B, 0x04);\n-    __ mov(as_FloatRegister($tmp1$$reg), __ T4S, 0x03020100);\n-    __ mulv(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($shuffle$$reg), as_FloatRegister($tmp0$$reg));\n-    __ addv(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($dst$$reg), as_FloatRegister($tmp1$$reg));\n-    __ tbl(as_FloatRegister($dst$$reg), __ T16B,\n-           as_FloatRegister($src$$reg), 1, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/-------------------------------- Anytrue\/alltrue -----------------------------\n-dnl\n-define(`ANYTRUE_IN_MASK', `\n-instruct anytrue_in_mask$1B`'(iRegINoSp dst, vec$2 src1, vec$2 src2, vec$2 tmp, rFlagsReg cr)\n-%{\n-  predicate(static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::ne);\n-  match(Set dst (VectorTest src1 src2 ));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp, KILL cr);\n-  format %{ \"addv  $tmp, T$1B, $src1\\n\\t\"\n-            \"umov  $dst, $tmp, B, 0\\n\\t\"\n-            \"cmp   $dst, 0\\n\\t\"\n-            \"cset  $dst\\t# anytrue $1B\" %}\n-  ins_encode %{\n-    \/\/ No need to use src2.\n-    __ addv(as_FloatRegister($tmp$$reg), __ T$1B, as_FloatRegister($src1$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ cmpw($dst$$Register, zr);\n-    __ csetw($dst$$Register, Assembler::NE);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl             $1  $2\n-ANYTRUE_IN_MASK(8,  D)\n-ANYTRUE_IN_MASK(16, X)\n-dnl\n-define(`ALLTRUE_IN_MASK', `\n-instruct alltrue_in_mask$1B`'(iRegINoSp dst, vec$2 src1, vec$2 src2, vec$2 tmp, rFlagsReg cr)\n-%{\n-  predicate(static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow);\n-  match(Set dst (VectorTest src1 src2 ));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp, KILL cr);\n-  format %{ \"uminv $tmp, T$1B, $src1\\n\\t\"\n-            \"umov  $dst, $tmp, B, 0\\n\\t\"\n-            \"cmp   $dst, 0xff\\n\\t\"\n-            \"cset  $dst\\t# alltrue $1B\" %}\n-  ins_encode %{\n-    \/\/ No need to use src2.\n-    __ uminv(as_FloatRegister($tmp$$reg), __ T$1B, as_FloatRegister($src1$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ cmpw($dst$$Register, 0xff);\n-    __ csetw($dst$$Register, Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl             $1  $2\n-ALLTRUE_IN_MASK(8,  D)\n-ALLTRUE_IN_MASK(16, X)\n-\n-\/\/ --------------------------------- ABS --------------------------------------\n-dnl\n-define(`VABS', `\n-instruct vabs$3$4`'(vec$5 dst, vec$5 src)\n-%{\n-  predicate(ifelse($3$4, 8B, n->as_Vector()->length() == 4 || )n->as_Vector()->length() == $3);\n-  match(Set dst (AbsV$4 src));\n-  ins_cost(ifelse($4, F, INSN_COST * 3, $4, D, INSN_COST * 3, INSN_COST));\n-  format %{ \"$1  $dst, T$3$6, $src\\t# vector ($3$6)\" %}\n-  ins_encode %{\n-    __ $2(as_FloatRegister($dst$$reg), __ T$3$6, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(ifelse($4, F, vunop_fp$7, $4, D, vunop_fp$7, vlogical$7));\n-%}')dnl\n-dnl  $1    $2    $3  $4 $5 $6 $7\n-VABS(abs,  absr, 8,  B, D, B, 64)\n-VABS(abs,  absr, 16, B, X, B, 128)\n-VABS(abs,  absr, 4,  S, D, H, 64)\n-VABS(abs,  absr, 8,  S, X, H, 128)\n-VABS(abs,  absr, 2,  I, D, S, 64)\n-VABS(abs,  absr, 4,  I, X, S, 128)\n-VABS(abs,  absr, 2,  L, X, D, 128)\n-VABS(fabs, fabs, 2,  F, D, S, 64)\n-VABS(fabs, fabs, 4,  F, X, S, 128)\n-VABS(fabs, fabs, 2,  D, X, D, 128)\n-\n-\/\/ --------------------------------- FABS DIFF --------------------------------\n-dnl\n-define(`VFABD', `\n-instruct vabd$3$4`'(vec$5 dst, vec$5 src1, vec$5 src2)\n-%{\n-  predicate(n->as_Vector()->length() == $3);\n-  match(Set dst (AbsV$4 (SubV$4 src1 src2)));\n-  ins_cost(INSN_COST * 3);\n-  format %{ \"$1  $dst, T$3$6, $src1, $src2\\t# vector ($3$6)\" %}\n-  ins_encode %{\n-    __ $2(as_FloatRegister($dst$$reg), __ T$3$6,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vunop_fp$7);\n-%}')dnl\n-dnl   $1    $2    $3 $4 $5 $6 $7\n-VFABD(fabd, fabd, 2, F, D, S, 64)\n-VFABD(fabd, fabd, 4, F, X, S, 128)\n-VFABD(fabd, fabd, 2, D, X, D, 128)\n-dnl\n-define(`VREPLICATE_REG', `\n-instruct replicate$2$3`'(vec$4 dst, $5 src)\n-%{\n-  predicate(UseSVE == 0 && ifelse($2$3, 8B,\n-                                  `(n->as_Vector()->length() == 8 ||\n-                            n->as_Vector()->length() == 4)',\n-                                  $2$3, 4S,\n-                                  `(n->as_Vector()->length() == 4 ||\n-                            n->as_Vector()->length() == 2)',\n-                            n->as_Vector()->length() == $2));\n-  match(Set dst (Replicate$3 src));\n-  ins_cost(INSN_COST);\n-  format %{ \"dup  $dst, $src\\t# vector ($2$3)\" %}\n-  ins_encode %{\n-    __ dup(as_FloatRegister($dst$$reg), __ T$2$1, $6($src$$reg));\n-  %}\n-  ins_pipe(ifelse($5, iRegIorL2I, vdup_reg_reg,\n-                  $5, iRegL, vdup_reg_reg,\n-                  $3, F, vdup_reg_freg, vdup_reg_dreg)`'ifelse($4, X, 128, 64));\n-%}')dnl\n-define(`VREPLICATE_IMM', `\n-instruct replicate$2$3_imm`'(vec$4 dst, $5 con)\n-%{\n-  predicate(UseSVE == 0 && ifelse($2$3, 8B,\n-                                  `(n->as_Vector()->length() == 8 ||\n-                            n->as_Vector()->length() == 4)',\n-                                  $2$3, 4S,\n-                                  `(n->as_Vector()->length() == 4 ||\n-                            n->as_Vector()->length() == 2)',\n-                            n->as_Vector()->length() == $2));\n-  match(Set dst (Replicate$3 con));\n-  ins_cost(INSN_COST);\n-  format %{ \"movi  $dst, $con\\t`#' vector ($2`'ifelse($3, S, H, $3))\" %}\n-  ins_encode %{\n-    __ mov(as_FloatRegister($dst$$reg), __ T$2`'iTYPE2SIMD($3), $con$$constant`'$6);\n-  %}\n-  ins_pipe(vmovi_reg_imm`'ifelse($4, X, 128, 64));\n-%}')dnl\n-dnl            $1 $2  $3 $4 $5          $6\n-VREPLICATE_REG(B, 8,  B, D, iRegIorL2I, as_Register)\n-VREPLICATE_REG(B, 16, B, X, iRegIorL2I, as_Register)\n-VREPLICATE_IMM(B, 8,  B, D, immI, ` & 0xff')\n-VREPLICATE_IMM(B, 16, B, X, immI, ` & 0xff')\n-VREPLICATE_REG(H, 4,  S, D, iRegIorL2I, as_Register)\n-VREPLICATE_REG(H, 8,  S, X, iRegIorL2I, as_Register)\n-VREPLICATE_IMM(H, 4,  S, D, immI, ` & 0xffff')\n-VREPLICATE_IMM(H, 8,  S, X, immI, ` & 0xffff')\n-VREPLICATE_REG(S, 2,  I, D, iRegIorL2I, as_Register)\n-VREPLICATE_REG(S, 4,  I, X, iRegIorL2I, as_Register)\n-VREPLICATE_IMM(S, 2,  I, D, immI)\n-VREPLICATE_IMM(S, 4,  I, X, immI)\n-VREPLICATE_REG(D, 2,  L, X, iRegL,      as_Register)\n-VREPLICATE_IMM(D, 2,  L, X, immL)\n-VREPLICATE_REG(S, 2,  F, D, vRegF,      as_FloatRegister)\n-VREPLICATE_REG(S, 4,  F, X, vRegF,      as_FloatRegister)\n-VREPLICATE_REG(D, 2,  D, X, vRegD,      as_FloatRegister)\n-dnl\n-\n-\/\/ ====================REDUCTION ARITHMETIC====================================\n-dnl\n-define(`REDUCE_ADD_INT', `\n-instruct reduce_add$1$2`'(iRegINoSp dst, iRegIorL2I isrc, vec$3 vsrc, vec$3 vtmp, iRegINoSp itmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (AddReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP vtmp, TEMP itmp);\n-  format %{ ifelse($1, 2, `\"addpv  $vtmp, T2S, $vsrc, $vsrc\\n\\t\"',`\"addv  $vtmp, T4S, $vsrc\\n\\t\"')\n-            \"umov  $itmp, $vtmp, S, 0\\n\\t\"\n-            \"addw  $dst, $itmp, $isrc\\t# add reduction$1I\"\n-  %}\n-  ins_encode %{\n-    ifelse($1, 2, `__ addpv(as_FloatRegister($vtmp$$reg), __ T2S,\n-             as_FloatRegister($vsrc$$reg), as_FloatRegister($vsrc$$reg));', `__ addv(as_FloatRegister($vtmp$$reg), __ T4S,\n-            as_FloatRegister($vsrc$$reg));')\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 0);\n-    __ addw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl            $1 $2 $3\n-REDUCE_ADD_INT(2, I, D)\n-REDUCE_ADD_INT(4, I, X)\n-dnl\n-define(`REDUCE_MUL_INT', `\n-instruct reduce_mul$1$2`'(iRegINoSp dst, iRegIorL2I isrc, vec$3 vsrc, ifelse($1, 2, iRegINoSp tmp`)', vecX vtmp`,' iRegINoSp itmp`)')\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (MulReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP ifelse($1, 2, tmp, vtmp), TEMP ifelse($1, 2, dst, itmp`,' TEMP dst));\n-  format %{ ifelse($1, 2, `\"umov  $tmp, $vsrc, S, 0\\n\\t\"\n-            \"mul   $dst, $tmp, $isrc\\n\\t\"\n-            \"umov  $tmp, $vsrc, S, 1\\n\\t\"\n-            \"mul   $dst, $tmp, $dst\\t# mul reduction2I\"',`\"ins   $vtmp, D, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp, T2S, $vtmp, $vsrc\\n\\t\"\n-            \"umov  $itmp, $vtmp, S, 0\\n\\t\"\n-            \"mul   $dst, $itmp, $isrc\\n\\t\"\n-            \"umov  $itmp, $vtmp, S, 1\\n\\t\"\n-            \"mul   $dst, $itmp, $dst\\t# mul reduction4I\"')\n-  %}\n-  ins_encode %{\n-    ifelse($1, 2, `__ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);\n-    __ mul($dst$$Register, $tmp$$Register, $isrc$$Register);\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);\n-    __ mul($dst$$Register, $tmp$$Register, $dst$$Register);', `__ ins(as_FloatRegister($vtmp$$reg), __ D,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp$$reg), __ T2S,\n-            as_FloatRegister($vtmp$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 0);\n-    __ mul($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 1);\n-    __ mul($dst$$Register, $itmp$$Register, $dst$$Register);')\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl            $1 $2 $3\n-REDUCE_MUL_INT(2, I, D)\n-REDUCE_MUL_INT(4, I, X)\n-dnl\n-define(`REDUCE_MULORADD_FORD', `\n-instruct reduce_$6$2$3`'(vReg$3 dst, vReg$3 $4src, vec$5 vsrc, vec$5 tmp)\n-%{\n-  match(Set dst (ifelse($6, add, Add, Mul)ReductionV$3 $4src vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp, TEMP dst);\n-  format %{ \"$1 $dst, $$4src, $vsrc\\n\\t\"\n-            \"ins   $tmp, ifelse($3, F, S, D), $vsrc, 0, 1\\n\\t\"\n-            ifelse($2, 2, `\"$1 $dst, $dst, $tmp\\t# $6 reduction$2$3\"',\n-            `\"$1 $dst, $dst, $tmp\\n\\t\"\n-            \"ins   $tmp, S, $vsrc, 0, 2\\n\\t\"\n-            \"$1 $dst, $dst, $tmp\\n\\t\"\n-            \"ins   $tmp, S, $vsrc, 0, 3\\n\\t\"\n-            \"$1 $dst, $dst, $tmp\\t# $6 reduction4F\"')\n-  %}\n-  ins_encode %{\n-    __ $1(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($$4src$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ ifelse($3, F, S, D),\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ $1(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));ifelse($2, 4, `\n-    __ ins(as_FloatRegister($tmp$$reg), __ ifelse($3, F, S, D),\n-           as_FloatRegister($vsrc$$reg), 0, 2);\n-    __ $1(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 3);\n-    __ $1(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));')\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl                  $1     $2 $3 $4 $5 $6\n-REDUCE_MULORADD_FORD(fadds, 2, F, f, D, add)\n-REDUCE_MULORADD_FORD(fadds, 4, F, f, X, add)\n-REDUCE_MULORADD_FORD(fmuls, 2, F, f, D, mul)\n-REDUCE_MULORADD_FORD(fmuls, 4, F, f, X, mul)\n-REDUCE_MULORADD_FORD(faddd, 2, D, d, X, add)\n-REDUCE_MULORADD_FORD(fmuld, 2, D, d, X, mul)\n-\n-\/\/ ====================VECTOR ARITHMETIC=======================================\n-\n-\/\/ --------------------------------- ADD --------------------------------------\n-define(`VADD', `\n-instruct vadd$2$3`'(vec$4 dst, vec$4 src1, vec$4 src2)\n-%{ifelse($2$3, 8B, `\n-  predicate(n->as_Vector()->length() == 4 ||\n-            n->as_Vector()->length() == 8);',\n-         $2$3, 4S, `\n-  predicate(n->as_Vector()->length() == 2 ||\n-            n->as_Vector()->length() == 4);',\n-         $2$5, 2D, , `\n-  predicate(n->as_Vector()->length() == $2);')\n-  match(Set dst (AddV$3 src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"$1  $dst,$src1,$src2\\t# vector ($2$5)\" %}\n-  ins_encode %{\n-    __ $1(as_FloatRegister($dst$$reg), __ T$2`'ifelse($5, L, D, $5),\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop`'ifelse($3, F, _fp, $3, D, _fp)`'ifelse($4, D, 64, 128));\n-%}')dnl\n-dnl  $1    $2  $3 $4 $5\n-VADD(addv, 8,  B, D, B)\n-VADD(addv, 16, B, X, B)\n-VADD(addv, 4,  S, D, H)\n-VADD(addv, 8,  S, X, H)\n-VADD(addv, 2,  I, D, S)\n-VADD(addv, 4,  I, X, S)\n-VADD(addv, 2,  L, X, L)\n-VADD(fadd, 2,  F, D, S)\n-VADD(fadd, 4,  F, X, S)\n-VADD(fadd, 2,  D, X, D)\n-\n-\/\/ --------------------------------- SUB --------------------------------------\n-define(`VSUB', `\n-instruct vsub$2$3`'(vec$4 dst, vec$4 src1, vec$4 src2)\n-%{ifelse($2$3, 8B, `\n-  predicate(n->as_Vector()->length() == 4 ||\n-            n->as_Vector()->length() == 8);',\n-         $2$3, 4S, `\n-  predicate(n->as_Vector()->length() == 2 ||\n-            n->as_Vector()->length() == 4);',`\n-  predicate(n->as_Vector()->length() == $2);')\n-  match(Set dst (SubV$3 src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"$1  $dst,$src1,$src2\\t# vector ($2$5)\" %}\n-  ins_encode %{\n-    __ $1(as_FloatRegister($dst$$reg), __ T$2`'ifelse($5, L, D, $5),\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop`'ifelse($3, F, _fp, $3, D, _fp)`'ifelse($4, D, 64, 128));\n-%}')dnl\n-dnl  $1    $2  $3 $4 $5\n-VSUB(subv, 8,  B, D, B)\n-VSUB(subv, 16, B, X, B)\n-VSUB(subv, 4,  S, D, H)\n-VSUB(subv, 8,  S, X, H)\n-VSUB(subv, 2,  I, D, S)\n-VSUB(subv, 4,  I, X, S)\n-VSUB(subv, 2,  L, X, L)\n-VSUB(fsub, 2,  F, D, S)\n-VSUB(fsub, 4,  F, X, S)\n-VSUB(fsub, 2,  D, X, D)\n-\n-\/\/ --------------------------------- MUL --------------------------------------\n-define(`VMUL', `\n-instruct vmul$2$3`'(vec$4 dst, vec$4 src1, vec$4 src2)\n-%{ifelse($2$3, 8B, `\n-  predicate(n->as_Vector()->length() == 4 ||\n-            n->as_Vector()->length() == 8);',\n-         $2$3, 4S, `\n-  predicate(n->as_Vector()->length() == 2 ||\n-            n->as_Vector()->length() == 4);',`\n-  predicate(n->as_Vector()->length() == $2);')\n-  match(Set dst (MulV$3 src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"$1  $dst,$src1,$src2\\t# vector ($2$5)\" %}\n-  ins_encode %{\n-    __ $1(as_FloatRegister($dst$$reg), __ T$2`'ifelse($5, L, D, $5),\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmul`'ifelse($3, F, div_fp, $3, D, div_fp)`'ifelse($4, D, 64, 128));\n-%}')dnl\n-dnl  $1    $2  $3 $4 $5\n-VMUL(mulv, 8,  B, D, B)\n-VMUL(mulv, 16, B, X, B)\n-VMUL(mulv, 4,  S, D, H)\n-VMUL(mulv, 8,  S, X, H)\n-VMUL(mulv, 2,  I, D, S)\n-VMUL(mulv, 4,  I, X, S)\n-VMUL(fmul, 2,  F, D, S)\n-VMUL(fmul, 4,  F, X, S)\n-VMUL(fmul, 2,  D, X, D)\n-\n-\/\/ --------------------------------- MLA --------------------------------------\n-define(`VMLA', `ifelse($1, fmla, `\n-\/\/ dst + src1 * src2')\n-instruct vmla$2$3`'(vec$4 dst, vec$4 src1, vec$4 src2)\n-%{ifelse($2$3, 4S, `\n-  predicate(n->as_Vector()->length() == 2 ||\n-            n->as_Vector()->length() == 4);', $1, fmla, `\n-  predicate(UseFMA && n->as_Vector()->length() == $2);', `\n-  predicate(n->as_Vector()->length() == $2);')\n-  match(Set dst (ifelse($1, mlav, `AddV'$3` dst (MulV$3 src1 src2)', FmaV$3  `dst (Binary src1 src2)')));\n-  ins_cost(INSN_COST);\n-  format %{ \"$1  $dst,$src1,$src2\\t# vector ($2$5)\" %}\n-  ins_encode %{\n-    __ $1(as_FloatRegister($dst$$reg), __ T$2`'ifelse($5, L, D, $5),\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vm`'ifelse($3, F, uldiv_fp, $3, D, uldiv_fp, la)`'ifelse($4, D, 64, 128));\n-%}')dnl\n-dnl  $1   $2  $3 $4 $5\n-VMLA(mlav, 4,  S, D, H)\n-VMLA(mlav, 8,  S, X, H)\n-VMLA(mlav, 2,  I, D, S)\n-VMLA(mlav, 4,  I, X, S)\n-VMLA(fmla, 2,  F, D, S)\n-VMLA(fmla, 4,  F, X, S)\n-VMLA(fmla, 2,  D, X, D)\n-\n-\/\/ --------------------------------- MLS --------------------------------------\n-define(`VMLS', `ifelse($1, fmls, `\n-\/\/ dst - src1 * src2')\n-instruct vmls$2$3`'(vec$4 dst, vec$4 src1, vec$4 src2) %{ifelse($2$3, 4S, `\n-  predicate(n->as_Vector()->length() == 2 ||\n-            n->as_Vector()->length() == 4);', $1, fmls, `\n-  predicate(UseFMA && n->as_Vector()->length() == $2);', `\n-  predicate(n->as_Vector()->length() == $2);')\n-  match(Set dst (ifelse($1, mlsv, `SubV'$3` dst (MulV$3 src1 src2)', FmaV$3  `dst (Binary (NegV'$3 `src1) src2)));\n-  match(Set dst (FmaV$3  dst (Binary src1 (NegV'$3 `src2))')));\n-  ins_cost(INSN_COST);\n-  format %{ \"$1  $dst,$src1,$src2\\t# vector ($2$5)\" %}\n-  ins_encode %{\n-    __ $1(as_FloatRegister($dst$$reg), __ T$2`'ifelse($5, L, D, $5),\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vm`'ifelse($3, F, uldiv_fp, $3, D, uldiv_fp, la)`'ifelse($4, D, 64, 128));\n-%}')dnl\n-dnl  $1   $2  $3 $4 $5\n-VMLS(mlsv, 4,  S, D, H)\n-VMLS(mlsv, 8,  S, X, H)\n-VMLS(mlsv, 2,  I, D, S)\n-VMLS(mlsv, 4,  I, X, S)\n-VMLS(fmls, 2,  F, D, S)\n-VMLS(fmls, 4,  F, X, S)\n-VMLS(fmls, 2,  D, X, D)\n-\n-\/\/ --------------- Vector Multiply-Add Shorts into Integer --------------------\n-\n-instruct vmuladdS2I(vecX dst, vecX src1, vecX src2, vecX tmp) %{\n-  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (MulAddVS2VI src1 src2));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"smullv  $tmp, $src1, $src2\\t# vector (4H)\\n\\t\"\n-            \"smullv  $dst, $src1, $src2\\t# vector (8H)\\n\\t\"\n-            \"addpv   $dst, $tmp, $dst\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ smullv(as_FloatRegister($tmp$$reg), __ T4H,\n-              as_FloatRegister($src1$$reg),\n-              as_FloatRegister($src2$$reg));\n-    __ smullv(as_FloatRegister($dst$$reg), __ T8H,\n-              as_FloatRegister($src1$$reg),\n-              as_FloatRegister($src2$$reg));\n-    __ addpv(as_FloatRegister($dst$$reg), __ T4S,\n-             as_FloatRegister($tmp$$reg),\n-             as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(vmuldiv_fp128);\n-%}\n-\n-\/\/ --------------------------------- DIV --------------------------------------\n-define(`VDIV', `\n-instruct vdiv$2$3`'(vec$4 dst, vec$4 src1, vec$4 src2)\n-%{\n-  predicate(n->as_Vector()->length() == $2);\n-  match(Set dst (DivV$3 src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"$1  $dst,$src1,$src2\\t# vector ($2$5)\" %}\n-  ins_encode %{\n-    __ $1(as_FloatRegister($dst$$reg), __ T$2`'ifelse($5, L, D, $5),\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmuldiv_fp`'ifelse($4, D, 64, 128));\n-%}')dnl\n-dnl  $1    $2  $3 $4 $5\n-VDIV(fdiv, 2,  F, D, S)\n-VDIV(fdiv, 4,  F, X, S)\n-VDIV(fdiv, 2,  D, X, D)\n-\n-\/\/ --------------------------------- SQRT -------------------------------------\n-define(`VSQRT', `\n-instruct vsqrt$2$3`'(vec$4 dst, vec$4 src)\n-%{\n-  predicate(n->as_Vector()->length() == $2);\n-  match(Set dst (SqrtV$3 src));\n-  format %{ \"$1  $dst, $src\\t# vector ($2$3)\" %}\n-  ins_encode %{\n-    __ $1(as_FloatRegister($dst$$reg), __ T$2$5, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(v`'ifelse($2$3, 2F, unop, sqrt)_fp`'ifelse($4, D, 64, 128));\n-%}')dnl\n-dnl   $1     $2  $3 $4 $5\n-VSQRT(fsqrt, 2,  F, D, S)\n-VSQRT(fsqrt, 4,  F, X, S)\n-VSQRT(fsqrt, 2,  D, X, D)\n-\n-\/\/ --------------------------------- NEG --------------------------------------\n-define(`VNEGI', `\n-instruct vnegI$1(vec$1 dst, vec$1 src)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() ifelse($1, D, <, ==) 16);\n-  match(Set dst (NegVI src));\n-  ins_cost(INSN_COST);\n-  format %{ \"negr  $dst, $src\\t# vector ($2)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_Arrangement size = __ esize2arrangement((unsigned)type2aelembytes(bt), ifelse($1, D, false, true));\n-    __ negr(as_FloatRegister($dst$$reg), size, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vunop_fp`'ifelse($1, D, 64, 128));\n-%}')dnl\n-dnl  $1  $2\n-VNEGI(D, 8B\/4H\/2S)\n-VNEGI(X, 16B\/8H\/4S)\n-dnl\n-define(`VNEG', `\n-instruct vneg$2$3`'(vec$4 dst, vec$4 src)\n-%{\n-  predicate(n->as_Vector()->length() == $2);\n-  match(Set dst (NegV$3 src));\n-  ins_cost(INSN_COST`'ifelse($3, L, `',` * 3'));\n-  format %{ \"$1  $dst,$src\\t# vector ($2$5)\" %}\n-  ins_encode %{\n-    __ $1(as_FloatRegister($dst$$reg), __ T$2$5,\n-            as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vunop_fp`'ifelse($4, D, 64, 128));\n-%}')dnl\n-dnl  $1    $2  $3 $4 $5\n-VNEG(negr, 2,  L, X, D)\n-VNEG(fneg, 2,  F, D, S)\n-VNEG(fneg, 4,  F, X, S)\n-VNEG(fneg, 2,  D, X, D)\n-dnl\n-define(`VLOGICAL', `\n-instruct v$3$5$6`'(vec$7 dst, vec$7 src1, vec$7 src2)\n-%{\n-  predicate(ifelse($5, 8, n->as_Vector()->length_in_bytes() == 4 ||`\n-            ')n->as_Vector()->length_in_bytes() == $5);\n-  match(Set dst ($4V src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"$1  $dst,$src1,$src2\\t# vector ($5$6)\" %}\n-  ins_encode %{\n-    __ $2(as_FloatRegister($dst$$reg), __ T$5$6,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vlogical`'ifelse($7, D, 64, 128));\n-%}')dnl\n-\n-\/\/ --------------------------------- AND --------------------------------------\n-dnl      $1   $2    $3   $4   $5  $6 $7\n-VLOGICAL(and, andr, and, And, 8,  B, D)\n-VLOGICAL(and, andr, and, And, 16, B, X)\n-\n-\/\/ --------------------------------- OR ---------------------------------------\n-VLOGICAL(orr, orr,  or,  Or,  8,  B, D)\n-VLOGICAL(orr, orr,  or,  Or,  16, B, X)\n-\n-\/\/ --------------------------------- XOR --------------------------------------\n-VLOGICAL(xor, eor,  xor, Xor, 8,  B, D)\n-VLOGICAL(xor, eor,  xor, Xor, 16, B, X)\n-\n-\/\/ ------------------------------ Shift ---------------------------------------\n-dnl\n-define(`VSLCNT', `\n-instruct vslcnt$1$2`'(vec$3 dst, iRegIorL2I cnt) %{\n-  predicate(UseSVE == 0 && ifelse($1, 8,\n-                                  (n->as_Vector()->length_in_bytes() == 4 ||`\n-                            'n->as_Vector()->length_in_bytes() == $1),\n-                                  n->as_Vector()->length_in_bytes() == $1));\n-  match(Set dst (LShiftCntV cnt));\n-  ins_cost(INSN_COST);\n-  format %{ \"dup  $dst, $cnt\\t# shift count vector ($1$2)\" %}\n-  ins_encode %{\n-    __ dup(as_FloatRegister($dst$$reg), __ T$1$2, as_Register($cnt$$reg));\n-  %}\n-  ins_pipe(vdup_reg_reg`'ifelse($3, D, 64, 128));\n-%}')dnl\n-dnl\n-define(`VSRCNT', `\n-instruct vsrcnt$1$2`'(vec$3 dst, iRegIorL2I cnt) %{\n-  predicate(UseSVE == 0 && ifelse($1, 8,\n-                                  (n->as_Vector()->length_in_bytes() == 4 ||`\n-                            'n->as_Vector()->length_in_bytes() == $1),\n-                                  n->as_Vector()->length_in_bytes() == $1));\n-  match(Set dst (RShiftCntV cnt));\n-  ins_cost(INSN_COST * 2);\n-  format %{ \"negw  rscratch1, $cnt\\t\"\n-            \"dup   $dst, rscratch1\\t# shift count vector ($1$2)\" %}\n-  ins_encode %{\n-    __ negw(rscratch1, as_Register($cnt$$reg));\n-    __ dup(as_FloatRegister($dst$$reg), __ T$1$2, rscratch1);\n-  %}\n-  ins_pipe(vdup_reg_reg`'ifelse($3, D, 64, 128));\n-%}')dnl\n-dnl\n-\n-\/\/ Vector shift count\n-\/\/ Note-1: Low 8 bits of each element are used, so it doesn't matter if we\n-\/\/         treat it as ints or bytes here.\n-\/\/ Note-2: Shift value is negated for RShiftCntV additionally. See the comments\n-\/\/         on vsra8B rule for more details.\n-dnl    $1  $2 $3\n-VSLCNT(8,  B, D)\n-VSLCNT(16, B, X)\n-VSRCNT(8,  B, D)\n-VSRCNT(16, B, X)\n-dnl\n-define(`PREDICATE',\n-`ifelse($1, 8B,\n-            ifelse($3, `', `predicate(n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8);',\n-                           `predicate((n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8) &&`\n-            '$3);'),\n-        $1, 4S,\n-            ifelse($3, `', `predicate(n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4);',\n-                           `predicate((n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4) &&`\n-            '$3);'),\n-        ifelse($3, `', `predicate(n->as_Vector()->length() == $2);',\n-                       `predicate(n->as_Vector()->length() == $2 && $3);'))')dnl\n-dnl\n-define(`VSLL', `\n-instruct vsll$1$2`'(vec$4 dst, vec$4 src, vec$4 shift) %{\n-  PREDICATE(`$1$2', $1, )\n-  match(Set dst (LShiftV$2 src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshl  $dst,$src,$shift\\t# vector ($1$3)\" %}\n-  ins_encode %{\n-    __ sshl(as_FloatRegister($dst$$reg), __ T$1$3,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift`'ifelse($4, D, 64, 128));\n-%}')dnl\n-dnl\n-define(`VSRA', `\n-instruct vsra$1$2`'(vec$4 dst, vec$4 src, vec$4 shift) %{\n-  PREDICATE(`$1$2', $1, !n->as_ShiftV()->is_var_shift())\n-  match(Set dst (RShiftV$2 src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshl  $dst,$src,$shift\\t# vector ($1$3)\" %}\n-  ins_encode %{\n-    __ sshl(as_FloatRegister($dst$$reg), __ T$1$3,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift`'ifelse($4, D, 64, 128));\n-%}')dnl\n-dnl\n-define(`VSRA_VAR', `\n-instruct vsra$1$2_var`'(vec$4 dst, vec$4 src, vec$4 shift) %{\n-  PREDICATE(`$1$2', $1, n->as_ShiftV()->is_var_shift())\n-  match(Set dst (RShiftV$2 src shift));\n-  ins_cost(INSN_COST * 2);\n-  effect(TEMP_DEF dst);\n-  format %{ \"negr  $dst,$shift\\t\"\n-            \"sshl  $dst,$src,$dst\\t# vector ($1$3)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T`'ifelse($4, D, 8B, 16B),\n-            as_FloatRegister($shift$$reg));\n-    __ sshl(as_FloatRegister($dst$$reg), __ T$1$3,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(vshift`'ifelse($4, D, 64, 128));\n-%}')dnl\n-dnl\n-define(`VSRL', `\n-instruct vsrl$1$2`'(vec$4 dst, vec$4 src, vec$4 shift) %{\n-  PREDICATE(`$1$2', $1, !n->as_ShiftV()->is_var_shift())\n-  match(Set dst (URShiftV$2 src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"ushl  $dst,$src,$shift\\t# vector ($1$3)\" %}\n-  ins_encode %{\n-    __ ushl(as_FloatRegister($dst$$reg), __ T$1$3,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift`'ifelse($4, D, 64, 128));\n-%}')dnl\n-dnl\n-define(`VSRL_VAR', `\n-instruct vsrl$1$2_var`'(vec$4 dst, vec$4 src, vec$4 shift) %{\n-  PREDICATE(`$1$2', $1, n->as_ShiftV()->is_var_shift())\n-  match(Set dst (URShiftV$2 src shift));\n-  ins_cost(INSN_COST * 2);\n-  effect(TEMP_DEF dst);\n-  format %{ \"negr  $dst,$shift\\t\"\n-            \"ushl  $dst,$src,$dst\\t# vector ($1$3)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T`'ifelse($4, D, 8B, 16B),\n-            as_FloatRegister($shift$$reg));\n-    __ ushl(as_FloatRegister($dst$$reg), __ T$1$3,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(vshift`'ifelse($4, D, 64, 128));\n-%}')dnl\n-dnl\n-define(`VSLL_IMM', `\n-instruct vsll$1$2_imm`'(vec$4 dst, vec$4 src, immI shift) %{\n-  PREDICATE(`$1$2', $1, assert_not_var_shift(n))\n-  match(Set dst (LShiftV$2 src (LShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"shl  $dst, $src, $shift\\t# vector ($1$3)\" %}\n-  ins_encode %{ifelse($2, B,`\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 8) {\n-      __ eor(as_FloatRegister($dst$$reg), __ ifelse($4, D, T8B, T16B),\n-             as_FloatRegister($src$$reg),\n-             as_FloatRegister($src$$reg));\n-    } else {\n-      __ shl(as_FloatRegister($dst$$reg), __ T$1$3,\n-             as_FloatRegister($src$$reg), sh);\n-    }', $2, S,`\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 16) {\n-      __ eor(as_FloatRegister($dst$$reg), __ ifelse($4, D, T8B, T16B),\n-             as_FloatRegister($src$$reg),\n-             as_FloatRegister($src$$reg));\n-    } else {\n-      __ shl(as_FloatRegister($dst$$reg), __ T$1$3,\n-             as_FloatRegister($src$$reg), sh);\n-    }', `\n-    __ shl(as_FloatRegister($dst$$reg), __ T$1$3,\n-           as_FloatRegister($src$$reg),\n-           (int)$shift$$constant);')\n-  %}\n-  ins_pipe(vshift`'ifelse($4, D, 64, 128)_imm);\n-%}')dnl\n-dnl\n-define(`VSRA_IMM', `\n-instruct vsra$1$2_imm`'(vec$4 dst, vec$4 src, immI_positive shift) %{\n-  PREDICATE(`$1$2', $1, assert_not_var_shift(n))\n-  match(Set dst (RShiftV$2 src (RShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshr  $dst, $src, $shift\\t# vector ($1$3)\" %}\n-  ins_encode %{ifelse($2, B,`\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 8) sh = 7;\n-    __ sshr(as_FloatRegister($dst$$reg), __ T$1$3,\n-            as_FloatRegister($src$$reg), sh);', $2, S,`\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 16) sh = 15;\n-    __ sshr(as_FloatRegister($dst$$reg), __ T$1$3,\n-            as_FloatRegister($src$$reg), sh);', `\n-    __ sshr(as_FloatRegister($dst$$reg), __ T$1$3,\n-            as_FloatRegister($src$$reg),\n-            (int)$shift$$constant);')\n-  %}\n-  ins_pipe(vshift`'ifelse($4, D, 64, 128)_imm);\n-%}')dnl\n-dnl\n-define(`VSRL_IMM', `\n-instruct vsrl$1$2_imm`'(vec$4 dst, vec$4 src, immI_positive shift) %{\n-  PREDICATE(`$1$2', $1, assert_not_var_shift(n))\n-  match(Set dst (URShiftV$2 src (RShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"ushr  $dst, $src, $shift\\t# vector ($1$3)\" %}\n-  ins_encode %{ifelse($2, B,`\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 8) {\n-      __ eor(as_FloatRegister($dst$$reg), __ ifelse($4, D, T8B, T16B),\n-             as_FloatRegister($src$$reg),\n-             as_FloatRegister($src$$reg));\n-    } else {\n-      __ ushr(as_FloatRegister($dst$$reg), __ T$1$3,\n-              as_FloatRegister($src$$reg), sh);\n-    }', $2, S,`\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 16) {\n-      __ eor(as_FloatRegister($dst$$reg), __ ifelse($4, D, T8B, T16B),\n-             as_FloatRegister($src$$reg),\n-             as_FloatRegister($src$$reg));\n-    } else {\n-      __ ushr(as_FloatRegister($dst$$reg), __ T$1$3,\n-              as_FloatRegister($src$$reg), sh);\n-    }', `\n-    __ ushr(as_FloatRegister($dst$$reg), __ T$1$3,\n-            as_FloatRegister($src$$reg),\n-            (int)$shift$$constant);')\n-  %}\n-  ins_pipe(vshift`'ifelse($4, D, 64, 128)_imm);\n-%}')dnl\n-dnl\n-define(`VSRLA_IMM', `\n-instruct vsrla$1$2_imm`'(vec$4 dst, vec$4 src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == $1);\n-  match(Set dst (AddV$2 dst (URShiftV$2 src (RShiftCntV shift))));\n-  ins_cost(INSN_COST);\n-  format %{ \"usra  $dst, $src, $shift\\t# vector ($1$3)\" %}\n-  ins_encode %{ifelse($2, B,`\n-    int sh = (int)$shift$$constant;\n-    if (sh < 8) {\n-      __ usra(as_FloatRegister($dst$$reg), __ T$1$3,\n-              as_FloatRegister($src$$reg), sh);\n-    }', $2, S,`\n-    int sh = (int)$shift$$constant;\n-    if (sh < 16) {\n-      __ usra(as_FloatRegister($dst$$reg), __ T$1$3,\n-              as_FloatRegister($src$$reg), sh);\n-    }', `\n-    __ usra(as_FloatRegister($dst$$reg), __ T$1$3,\n-            as_FloatRegister($src$$reg),\n-            (int)$shift$$constant);')\n-  %}\n-  ins_pipe(vshift`'ifelse($4, D, 64, 128)_imm);\n-%}')dnl\n-dnl\n-define(`VSRAA_IMM', `\n-instruct vsraa$1$2_imm`'(vec$4 dst, vec$4 src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == $1);\n-  match(Set dst (AddV$2 dst (RShiftV$2 src (RShiftCntV shift))));\n-  ins_cost(INSN_COST);\n-  format %{ \"ssra  $dst, $src, $shift\\t# vector ($1$3)\" %}\n-  ins_encode %{ifelse($2, B,`\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 8) sh = 7;\n-    __ ssra(as_FloatRegister($dst$$reg), __ T$1$3,\n-            as_FloatRegister($src$$reg), sh);', $2, S,`\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 16) sh = 15;\n-    __ ssra(as_FloatRegister($dst$$reg), __ T$1$3,\n-            as_FloatRegister($src$$reg), sh);', `\n-    __ ssra(as_FloatRegister($dst$$reg), __ T$1$3,\n-            as_FloatRegister($src$$reg),\n-            (int)$shift$$constant);')\n-  %}\n-  ins_pipe(vshift`'ifelse($4, D, 64, 128)_imm);\n-%}')dnl\n-dnl\n-undefine(PREDICATE)dnl\n-dnl\n-dnl  $1  $2 $3 $4\n-VSLL(8,  B, B, D)\n-VSLL(16, B, B, X)\n-\n-\/\/ Right shifts with vector shift count on aarch64 SIMD are implemented\n-\/\/ as left shift by negative shift count.\n-\/\/ There are two cases for vector shift count.\n-\/\/\n-\/\/ Case 1: The vector shift count is from replication.\n-\/\/        |            |\n-\/\/    LoadVector  RShiftCntV\n-\/\/        |       \/\n-\/\/     RShiftVI\n-\/\/\n-\/\/ Case 2: The vector shift count is from loading.\n-\/\/ This case isn't supported by middle-end now. But it's supported by\n-\/\/ panama\/vectorIntrinsics(JEP 338: Vector API).\n-\/\/        |            |\n-\/\/    LoadVector  LoadVector\n-\/\/        |       \/\n-\/\/     RShiftVI\n-\/\/\n-\/\/ The negate is conducted in RShiftCntV rule for case 1, whereas it's done in\n-\/\/ RShiftV* rules for case 2. Because there exists an optimization opportunity\n-\/\/ for case 1, that is, multiple neg instructions in inner loop can be hoisted\n-\/\/ to outer loop and merged into one neg instruction.\n-\/\/\n-\/\/ Note that ShiftVNode::is_var_shift() indicates whether the vector shift\n-\/\/ count is a variable vector(case 2) or not(a vector generated by RShiftCntV,\n-\/\/ i.e. case 1).\n-dnl  $1  $2 $3 $4\n-VSRA(8,  B, B, D)\n-VSRA_VAR(8,  B, B, D)\n-VSRA(16, B, B, X)\n-VSRA_VAR(16, B, B, X)\n-VSRL(8,  B, B, D)\n-VSRL_VAR(8,  B, B, D)\n-VSRL(16, B, B, X)\n-VSRL_VAR(16, B, B, X)\n-VSLL_IMM(8,  B, B, D)\n-VSLL_IMM(16, B, B, X)\n-VSRA_IMM(8,  B, B, D)\n-VSRA_IMM(16, B, B, X)\n-VSRL_IMM(8,  B, B, D)\n-VSRL_IMM(16, B, B, X)\n-VSLL(4,  S, H, D)\n-VSLL(8,  S, H, X)\n-VSRA(4,  S, H, D)\n-VSRA_VAR(4,  S, H, D)\n-VSRA(8,  S, H, X)\n-VSRA_VAR(8,  S, H, X)\n-VSRL(4,  S, H, D)\n-VSRL_VAR(4,  S, H, D)\n-VSRL(8,  S, H, X)\n-VSRL_VAR(8,  S, H, X)\n-VSLL_IMM(4,  S, H, D)\n-VSLL_IMM(8,  S, H, X)\n-VSRA_IMM(4,  S, H, D)\n-VSRA_IMM(8,  S, H, X)\n-VSRL_IMM(4,  S, H, D)\n-VSRL_IMM(8,  S, H, X)\n-VSLL(2,  I, S, D)\n-VSLL(4,  I, S, X)\n-VSRA(2,  I, S, D)\n-VSRA_VAR(2,  I, S, D)\n-VSRA(4,  I, S, X)\n-VSRA_VAR(4,  I, S, X)\n-VSRL(2,  I, S, D)\n-VSRL_VAR(2,  I, S, D)\n-VSRL(4,  I, S, X)\n-VSRL_VAR(4,  I, S, X)\n-VSLL_IMM(2,  I, S, D)\n-VSLL_IMM(4,  I, S, X)\n-VSRA_IMM(2,  I, S, D)\n-VSRA_IMM(4,  I, S, X)\n-VSRL_IMM(2,  I, S, D)\n-VSRL_IMM(4,  I, S, X)\n-VSLL(2,  L, D, X)\n-VSRA(2,  L, D, X)\n-VSRA_VAR(2,  L, D, X)\n-VSRL(2,  L, D, X)\n-VSRL_VAR(2,  L, D, X)\n-VSLL_IMM(2,  L, D, X)\n-VSRA_IMM(2,  L, D, X)\n-VSRL_IMM(2,  L, D, X)\n-VSRAA_IMM(8,  B, B, D)\n-VSRAA_IMM(16, B, B, X)\n-VSRAA_IMM(4,  S, H, D)\n-VSRAA_IMM(8,  S, H, X)\n-VSRAA_IMM(2,  I, S, D)\n-VSRAA_IMM(4,  I, S, X)\n-VSRAA_IMM(2,  L, D, X)\n-VSRLA_IMM(8,  B, B, D)\n-VSRLA_IMM(16, B, B, X)\n-VSRLA_IMM(4,  S, H, D)\n-VSRLA_IMM(8,  S, H, X)\n-VSRLA_IMM(2,  I, S, D)\n-VSRLA_IMM(4,  I, S, X)\n-VSRLA_IMM(2,  L, D, X)\n-dnl\n-define(`VMINMAX', `\n-instruct v$1$3`'ifelse($5, S, F, D)`'(vec$6 dst, vec$6 src1, vec$6 src2)\n-%{\n-  predicate(n->as_Vector()->length() == $3 && n->bottom_type()->is_vect()->element_basic_type() == T_`'ifelse($5, S, FLOAT, DOUBLE));\n-  match(Set dst ($2V src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"f$1  $dst,$src1,$src2\\t# vector ($3$4)\" %}\n-  ins_encode %{\n-    __ f$1(as_FloatRegister($dst$$reg), __ T$3$5,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop_fp`'ifelse($6, D, 64, 128));\n-%}')dnl\n-dnl     $1   $2   $3 $4 $5 $6\n-VMINMAX(max, Max, 2, F, S, D)\n-VMINMAX(max, Max, 4, S, S, X)\n-VMINMAX(max, Max, 2, D, D, X)\n-VMINMAX(min, Min, 2, F, S, D)\n-VMINMAX(min, Min, 4, S, S, X)\n-VMINMAX(min, Min, 2, D, D, X)\n-\n-instruct vround2D_reg(vecX dst, vecX src, immI rmode) %{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (RoundDoubleModeV src rmode));\n-  format %{ \"frint  $dst, $src, $rmode\" %}\n-  ins_encode %{\n-    switch ($rmode$$constant) {\n-      case RoundDoubleModeNode::rmode_rint:\n-        __ frintn(as_FloatRegister($dst$$reg), __ T2D,\n-                  as_FloatRegister($src$$reg));\n-        break;\n-      case RoundDoubleModeNode::rmode_floor:\n-        __ frintm(as_FloatRegister($dst$$reg), __ T2D,\n-                  as_FloatRegister($src$$reg));\n-        break;\n-      case RoundDoubleModeNode::rmode_ceil:\n-        __ frintp(as_FloatRegister($dst$$reg), __ T2D,\n-                  as_FloatRegister($src$$reg));\n-        break;\n-    }\n-  %}\n-  ins_pipe(vdop_fp128);\n-%}\n-dnl\n-define(`VPOPCOUNT', `dnl\n-ifelse($1$2, `LD', `\n-\/\/ If the PopCountVL is generated by auto-vectorization, the dst basic\n-\/\/ type is T_INT. And once we have unified the type definition for\n-\/\/ Vector API and auto-vectorization, this rule can be merged with\n-\/\/ \"vpopcountLX\" rule.', `')\n-instruct vpopcount$1$2`'(vec$2 dst, vec$3 src) %{\n-  predicate(n->as_Vector()->length_in_bytes() $4 16`'ifelse($1$2, `LD', ` &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_INT', $1$2, `LX', ` &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_LONG', `'));\n-  match(Set dst (PopCountV$1 src));\n-  ins_cost($5 * INSN_COST);\n-  format %{ \"vpopcount$1  $dst, $src\\t# vector ($6)\" %}\n-  ins_encode %{dnl\n-ifelse($1, `I', `\n-    BasicType bt = Matcher::vector_element_basic_type(this);', `')\n-    __ cnt(as_FloatRegister($dst$$reg), __ T`'ifelse($3, D, 8, 16)B,\n-           as_FloatRegister($src$$reg));dnl\n-ifelse($1, `L', `\n-    __ uaddlp(as_FloatRegister($dst$$reg), __ T16B,\n-              as_FloatRegister($dst$$reg));\n-    __ uaddlp(as_FloatRegister($dst$$reg), __ T8H,\n-              as_FloatRegister($dst$$reg));\n-    __ uaddlp(as_FloatRegister($dst$$reg), __ T4S,\n-              as_FloatRegister($dst$$reg));', `\n-    if (bt == T_SHORT || bt == T_INT) {\n-      __ uaddlp(as_FloatRegister($dst$$reg), __ T`'ifelse($2, D, 8, 16)B,\n-                as_FloatRegister($dst$$reg));\n-      if (bt == T_INT) {\n-        __ uaddlp(as_FloatRegister($dst$$reg), __ T`'ifelse($2, D, 4, 8)H,\n-                  as_FloatRegister($dst$$reg));\n-      }\n-    }')dnl\n-ifelse($1$2, `LD', `\n-    __ xtn(as_FloatRegister($dst$$reg), __ T2S,\n-           as_FloatRegister($dst$$reg), __ T2D);', `')\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl       $1 $2 $3 $4  $5 $6\n-VPOPCOUNT(I, D, D, <,  3, 8B\/4H\/2S)\n-VPOPCOUNT(I, X, X, ==, 3, 16B\/8H\/4S)\n-VPOPCOUNT(L, D, X, <,  5, 2S)\n-VPOPCOUNT(L, X, X, ==, 4, 2D)\n-dnl\n-dnl VMASK_TRUECOUNT($1,     $2 )\n-dnl VMASK_TRUECOUNT(suffix, reg)\n-define(`VMASK_TRUECOUNT', `\n-instruct vmask_truecount$1(iRegINoSp dst, $2 src, $2 tmp) %{\n-  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n-  match(Set dst (VectorMaskTrueCount src));\n-  effect(TEMP tmp);\n-  ins_cost(2 * INSN_COST);\n-  format %{ \"addv $tmp, $src\\n\\t\"\n-            \"umov $dst, $tmp, B, 0\\t# vector ($1)\" %}\n-  ins_encode %{\n-    \/\/ Input \"src\" is a vector of boolean represented as bytes with\n-    \/\/ 0x00\/0x01 as element values.\n-    __ addv(as_FloatRegister($tmp$$reg), __ T$1, as_FloatRegister($src$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl\n-define(`ARGLIST',\n-`ifelse($1, `_LT8B', `iRegINoSp dst, vecD src, rFlagsReg cr', `iRegINoSp dst, vecD src')')\n-dnl\n-dnl VMASK_FIRSTTRUE_D($1,     $2,   $3,   $4  )\n-dnl VMASK_FIRSTTRUE_D(suffix, cond, cost, size)\n-define(`VMASK_FIRSTTRUE_D', `\n-instruct vmask_firsttrue$1(ARGLIST($1)) %{\n-  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN &&\n-            n->in(1)->bottom_type()->is_vect()->length() $2 8);\n-  match(Set dst (VectorMaskFirstTrue src));dnl\n-ifelse($1, `_LT8B', `\n-  effect(KILL cr);')\n-  ins_cost($3 * INSN_COST);\n-  format %{ \"vmask_firsttrue $dst, $src\\t# vector ($4)\" %}\n-  ins_encode %{\n-    \/\/ Returns the index of the first active lane of the\n-    \/\/ vector mask, or VLENGTH if no lane is active.\n-    \/\/\n-    \/\/ Input \"src\" is a vector of boolean represented as\n-    \/\/ bytes with 0x00\/0x01 as element values.\n-    \/\/\n-    \/\/ Computed by reversing the bits and counting the leading\n-    \/\/ zero bytes.\n-    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n-    __ rbit($dst$$Register, $dst$$Register);\n-    __ clz($dst$$Register, $dst$$Register);\n-    __ lsrw($dst$$Register, $dst$$Register, 3);dnl\n-ifelse(`$1', `_LT8B', `\n-    __ movw(rscratch1, Matcher::vector_length(this, $src));\n-    __ cmpw($dst$$Register, rscratch1);\n-    __ cselw($dst$$Register, rscratch1, $dst$$Register, Assembler::GE);')\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-undefine(ARGLIST)dnl\n-dnl\n-\/\/ vector mask reductions\n-VMASK_TRUECOUNT(8B,  vecD)\n-VMASK_TRUECOUNT(16B, vecX)\n-VMASK_FIRSTTRUE_D(_LT8B, <,  7, 4I\/4S\/2I)\n-VMASK_FIRSTTRUE_D(8B,    ==, 4, 8B)\n-\n-instruct vmask_firsttrue16B(iRegINoSp dst, vecX src) %{\n-  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n-  match(Set dst (VectorMaskFirstTrue src));\n-  ins_cost(6 * INSN_COST);\n-  format %{ \"vmask_firsttrue $dst, $src\\t# vector (16B)\" %}\n-  ins_encode %{\n-    \/\/ Returns the index of the first active lane of the\n-    \/\/ vector mask, or 16 (VLENGTH) if no lane is active.\n-    \/\/\n-    \/\/ Input \"src\" is a vector of boolean represented as\n-    \/\/ bytes with 0x00\/0x01 as element values.\n-\n-    Label FIRST_TRUE_INDEX;\n-\n-    \/\/ Try to compute the result from lower 64 bits.\n-    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n-    __ movw(rscratch1, zr);\n-    __ cbnz($dst$$Register, FIRST_TRUE_INDEX);\n-\n-    \/\/ Compute the result from the higher 64 bits.\n-    __ fmovhid($dst$$Register, as_FloatRegister($src$$reg));\n-    __ movw(rscratch1, 8);\n-\n-    \/\/ Reverse the bits and count the leading zero bytes.\n-    __ bind(FIRST_TRUE_INDEX);\n-    __ rbit($dst$$Register, $dst$$Register);\n-    __ clz($dst$$Register, $dst$$Register);\n-    __ addw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_lasttrue8B(iRegINoSp dst, vecD src) %{\n-  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n-  match(Set dst (VectorMaskLastTrue src));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"vmask_lasttrue $dst, $src\\t# vector (8B)\" %}\n-  ins_encode %{\n-    \/\/ Returns the index of the last active lane of the\n-    \/\/ vector mask, or -1 if no lane is active.\n-    \/\/\n-    \/\/ Input \"src\" is a vector of boolean represented as\n-    \/\/ bytes with 0x00\/0x01 as element values.\n-    \/\/\n-    \/\/ Computed by counting the leading zero bytes and\n-    \/\/ subtracting it by 7 (VLENGTH - 1).\n-    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n-    __ clz($dst$$Register, $dst$$Register);\n-    __ movw(rscratch1, 7);\n-    __ subw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_lasttrue16B(iRegINoSp dst, vecX src) %{\n-  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n-  match(Set dst (VectorMaskLastTrue src));\n-  ins_cost(5 * INSN_COST);\n-  format %{ \"vmask_lasttrue $dst, $src\\t# vector (16B)\" %}\n-  ins_encode %{\n-    \/\/ Returns the index of the last active lane of the\n-    \/\/ vector mask, or -1 if no lane is active.\n-    \/\/\n-    \/\/ Input \"src\" is a vector of boolean represented as\n-    \/\/ bytes with 0x00\/0x01 as element values.\n-\n-    Label LAST_TRUE_INDEX;\n-\n-    \/\/ Try to compute the result from higher 64 bits.\n-    __ fmovhid($dst$$Register, as_FloatRegister($src$$reg));\n-    __ movw(rscratch1, 16 - 1);\n-    __ cbnz($dst$$Register, LAST_TRUE_INDEX);\n-\n-    \/\/ Compute the result from the lower 64 bits.\n-    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n-    __ movw(rscratch1, 8 - 1);\n-\n-    \/\/ Count the leading zero bytes and subtract it by 15 (VLENGTH - 1).\n-    __ bind(LAST_TRUE_INDEX);\n-    __ clz($dst$$Register, $dst$$Register);\n-    __ subw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_tolong8B(iRegLNoSp dst, vecD src) %{\n-  match(Set dst (VectorMaskToLong src));\n-  ins_cost(5 * INSN_COST);\n-  format %{ \"vmask_tolong $dst, $src\\t# convert mask to long (8B)\" %}\n-  ins_encode %{\n-    \/\/ Input \"src\" is a vector of boolean represented as\n-    \/\/ bytes with 0x00\/0x01 as element values.\n-\n-    __ fmovd(as_Register($dst$$reg), as_FloatRegister($src$$reg));\n-    __ bytemask_compress(as_Register($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_tolong16B(iRegLNoSp dst, vecX src) %{\n-  match(Set dst (VectorMaskToLong src));\n-  ins_cost(11 * INSN_COST);\n-  format %{ \"vmask_tolong $dst, $src\\t# convert mask to long (16B)\" %}\n-  ins_encode %{\n-    \/\/ Input \"src\" is a vector of boolean represented as\n-    \/\/ bytes with 0x00\/0x01 as element values.\n-\n-    __ umov(as_Register($dst$$reg), as_FloatRegister($src$$reg), __ D, 0);\n-    __ umov(rscratch1, as_FloatRegister($src$$reg), __ D, 1);\n-    __ bytemask_compress(as_Register($dst$$reg));\n-    __ bytemask_compress(rscratch1);\n-    __ orr(as_Register($dst$$reg), as_Register($dst$$reg),\n-           rscratch1, Assembler::LSL, 8);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-dnl\n-dnl CLTZ_D($1     )\n-dnl CLTZ_D(op_name)\n-define(`CLTZ_D', `\n-instruct count$1D(vecD dst, vecD src) %{\n-  predicate(n->as_Vector()->length_in_bytes() == 8);\n-  match(Set dst (Count$1 src));\n-  ins_cost(ifelse($1, `TrailingZerosV', `3 * ', `')INSN_COST);\n-  format %{ \"count$1 $dst, $src\\t# vector (8B\/4H\/2S)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_Arrangement size = __ esize2arrangement((unsigned)type2aelembytes(bt), false);dnl\n-ifelse($1, `TrailingZerosV', `\n-    __ neon_reverse_bits(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), bt, false);', `')\n-    __ clz(as_FloatRegister($dst$$reg), size, as_FloatRegister($ifelse($1, `TrailingZerosV', dst, src)$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl CLTZ_X($1     )\n-dnl CLTZ_X(op_name)\n-define(`CLTZ_X', `\n-instruct count$1X(vecX dst, vecX src) %{\n-  predicate(n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (Count$1 src));\n-  ins_cost(ifelse($1, `TrailingZerosV', `3 * ', `')INSN_COST);\n-  format %{ \"count$1 $dst, $src\\t# vector (16B\/8H\/4S\/2D)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_Arrangement size = __ esize2arrangement((unsigned)type2aelembytes(bt), true);dnl\n-ifelse($1, `TrailingZerosV', `\n-    __ neon_reverse_bits(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), bt, true);', `')\n-    if (bt != T_LONG) {\n-      __ clz(as_FloatRegister($dst$$reg), size, as_FloatRegister($ifelse($1, `TrailingZerosV', dst, src)$$reg));\n-    } else {\n-      __ umov(rscratch1, as_FloatRegister($ifelse($1, `TrailingZerosV', dst, src)$$reg), __ D, 0);\n-      __ clz(rscratch1, rscratch1);\n-      __ mov(as_FloatRegister($dst$$reg), __ D, 0, rscratch1);\n-      __ umov(rscratch1, as_FloatRegister($ifelse($1, `TrailingZerosV', dst, src)$$reg), __ D, 1);\n-      __ clz(rscratch1, rscratch1);\n-      __ mov(as_FloatRegister($dst$$reg), __ D, 1, rscratch1);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/------------------------- CountLeadingZerosV -----------------------------\n-CLTZ_D(LeadingZerosV)\n-CLTZ_X(LeadingZerosV)\n-\n-\/\/------------------------- CountTrailingZerosV ----------------------------\n-CLTZ_D(TrailingZerosV)\n-CLTZ_X(TrailingZerosV)\n-\n-dnl\n-dnl REVERSE($1,        $2,      $3,   $4  )\n-dnl REVERSE(insn_name, op_name, type, insn)\n-define(`REVERSE', `\n-instruct $1(vec$3 dst, vec$3 src) %{\n-  predicate(n->as_Vector()->length_in_bytes() == ifelse($3, D, 8, 16));\n-  match(Set dst ($2 src));\n-  ins_cost(ifelse($2, `ReverseV', `2 * ', `')INSN_COST);\n-  format %{ \"$2 $dst, $src\\t# vector ($3)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ $4(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), bt, ifelse($3, D, false, true));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/------------------------------ ReverseV -----------------------------------\n-REVERSE(vreverseD, ReverseV, D, neon_reverse_bits)\n-REVERSE(vreverseX, ReverseV, X, neon_reverse_bits)\n-\n-\/\/---------------------------- ReverseBytesV --------------------------------\n-REVERSE(vreverseBytesD, ReverseBytesV, D, neon_reverse_bytes)\n-REVERSE(vreverseBytesX, ReverseBytesV, X, neon_reverse_bytes)\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon_ad.m4","additions":0,"deletions":2749,"binary":false,"changes":2749,"status":"deleted"},{"patch":"@@ -1,5922 +0,0 @@\n-\/\/\n-\/\/ Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n-\/\/ Copyright (c) 2020, 2022, Arm Limited. All rights reserved.\n-\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\/\/\n-\/\/ This code is free software; you can redistribute it and\/or modify it\n-\/\/ under the terms of the GNU General Public License version 2 only, as\n-\/\/ published by the Free Software Foundation.\n-\/\/\n-\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n-\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-\/\/ version 2 for more details (a copy is included in the LICENSE file that\n-\/\/ accompanied this code).\n-\/\/\n-\/\/ You should have received a copy of the GNU General Public License version\n-\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n-\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\/\/\n-\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-\/\/ or visit www.oracle.com if you need additional information or have any\n-\/\/ questions.\n-\/\/\n-\/\/\n-\n-\/\/ This file is automatically generated by running \"m4 aarch64_sve_ad.m4\". Do not edit ----\n-\n-\/\/ AArch64 SVE Architecture Description File\n-\n-\n-\/\/ 4 bit signed offset -- for predicated load\/store\n-\n-operand vmemA_immIOffset4()\n-%{\n-  \/\/ (esize \/ msize) = 1\n-  predicate(Address::offset_ok_for_sve_immed(n->get_int(), 4,\n-            Matcher::scalable_vector_reg_size(T_BYTE)));\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand vmemA_immLOffset4()\n-%{\n-  \/\/ (esize \/ msize) = 1\n-  predicate(Address::offset_ok_for_sve_immed(n->get_long(), 4,\n-            Matcher::scalable_vector_reg_size(T_BYTE)));\n-  match(ConL);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand vmemA_indOffI4(iRegP reg, vmemA_immIOffset4 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand vmemA_indOffL4(iRegP reg, vmemA_immLOffset4 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-\/\/ The indOff of vmemA is valid only when the vector element (load to\/store from)\n-\/\/ size equals to memory element (load from\/store to) size.\n-opclass vmemA(indirect, vmemA_indOffI4, vmemA_indOffL4);\n-\n-source_hpp %{\n-  bool op_sve_supported(int opcode, int vlen, BasicType bt);\n-  bool masked_op_sve_supported(int opcode, int vlen, BasicType bt);\n-  bool partial_op_sve_needed(Node* node, const TypeVect* vt);\n-%}\n-\n-source %{\n-\n-  typedef void (C2_MacroAssembler::* sve_mem_insn_predicate)(FloatRegister Rt, Assembler::SIMD_RegVariant T,\n-                                                             PRegister Pg, const Address &adr);\n-\n-  \/\/ Predicated load\/store, with optional ptrue to all elements of given predicate register.\n-  static void loadStoreA_predicated(C2_MacroAssembler masm, bool is_store, FloatRegister reg,\n-                                    PRegister pg, BasicType mem_elem_bt, BasicType vector_elem_bt,\n-                                    int opcode, Register base, int index, int size, int disp) {\n-    sve_mem_insn_predicate insn;\n-    int mesize = type2aelembytes(mem_elem_bt);\n-    if (index == -1) {\n-      assert(size == 0, \"unsupported address mode: scale size = %d\", size);\n-      switch(mesize) {\n-      case 1:\n-        insn = is_store ? &C2_MacroAssembler::sve_st1b : &C2_MacroAssembler::sve_ld1b;\n-        break;\n-      case 2:\n-        insn = is_store ? &C2_MacroAssembler::sve_st1h : &C2_MacroAssembler::sve_ld1h;\n-        break;\n-      case 4:\n-        insn = is_store ? &C2_MacroAssembler::sve_st1w : &C2_MacroAssembler::sve_ld1w;\n-        break;\n-      case 8:\n-        insn = is_store ? &C2_MacroAssembler::sve_st1d : &C2_MacroAssembler::sve_ld1d;\n-        break;\n-      default:\n-        assert(false, \"unsupported\");\n-        ShouldNotReachHere();\n-      }\n-      int imm4 = disp \/ mesize \/ Matcher::scalable_vector_reg_size(vector_elem_bt);\n-      (masm.*insn)(reg, Assembler::elemType_to_regVariant(vector_elem_bt), pg, Address(base, imm4));\n-    } else {\n-      assert(false, \"unimplemented\");\n-      ShouldNotReachHere();\n-    }\n-  }\n-\n-  bool op_sve_supported(int opcode, int vlen, BasicType bt) {\n-    int length_in_bytes = vlen * type2aelembytes(bt);\n-    switch (opcode) {\n-      case Op_MulAddVS2VI:\n-      \/\/ No multiply reduction instructions\n-      case Op_MulReductionVD:\n-      case Op_MulReductionVF:\n-      case Op_MulReductionVI:\n-      case Op_MulReductionVL:\n-      \/\/ Others\n-      case Op_ExtractC:\n-      case Op_ExtractUB:\n-        return false;\n-      \/\/ Vector API specific\n-      case Op_VectorLoadShuffle:\n-      case Op_VectorRearrange:\n-        return vlen >= 4 && length_in_bytes <= MaxVectorSize;\n-      case Op_LoadVector:\n-      case Op_StoreVector:\n-        return Matcher::vector_size_supported(bt, vlen);\n-      case Op_ExpandV:\n-        if (UseSVE < 2 || is_subword_type(bt)) return false;\n-      case Op_VectorMaskToLong:\n-        if (vlen > 64) return false;\n-      case Op_VectorLongToMask:\n-        if (UseSVE < 2 || vlen > 64 || !VM_Version::supports_svebitperm()) return false;\n-      default:\n-        break;\n-    }\n-    \/\/ By default, we only support vector operations with no less than 8 bytes and 2 elements.\n-    return 8 <= length_in_bytes && length_in_bytes <= MaxVectorSize && vlen >= 2;\n-  }\n-\n-  bool masked_op_sve_supported(int opcode, int vlen, BasicType bt) {\n-    switch(opcode) {\n-      case Op_VectorRearrange:\n-        return false;\n-      \/\/ We use Op_LoadVectorMasked to implement the predicated Op_LoadVector.\n-      \/\/ Hence we turn to check whether Op_LoadVectorMasked is supported. The\n-      \/\/ same as vector store\/gather\/scatter.\n-      case Op_LoadVector:\n-        opcode = Op_LoadVectorMasked;\n-        break;\n-      case Op_StoreVector:\n-        opcode = Op_StoreVectorMasked;\n-        break;\n-      case Op_LoadVectorGather:\n-        opcode = Op_LoadVectorGatherMasked;\n-        break;\n-      case Op_StoreVectorScatter:\n-        opcode = Op_StoreVectorScatterMasked;\n-        break;\n-      default:\n-        break;\n-    }\n-    return op_sve_supported(opcode, vlen, bt);\n-  }\n-\n-  bool partial_op_sve_needed(Node* node, const TypeVect* vt) {\n-    switch(node->Opcode()) {\n-      case Op_VectorLoadMask:\n-      case Op_VectorMaskCmp:\n-      case Op_LoadVectorGather:\n-      case Op_StoreVectorScatter:\n-      case Op_AddReductionVI:\n-      case Op_AddReductionVL:\n-      case Op_AddReductionVF:\n-      case Op_AddReductionVD:\n-      case Op_MinReductionV:\n-      case Op_MaxReductionV:\n-      case Op_AndReductionV:\n-      case Op_OrReductionV:\n-      case Op_XorReductionV:\n-      \/\/ Mask is needed for partial Op_VectorMaskFirstTrue, because when the\n-      \/\/ input predicate is all-false, the result should be the vector length\n-      \/\/ instead of the vector register size.\n-      case Op_VectorMaskFirstTrue:\n-        return true;\n-      case Op_MaskAll:\n-        return !node->in(1)->is_Con();\n-      case Op_LoadVector:\n-      case Op_StoreVector:\n-        \/\/ We use NEON load\/store instructions if the vector length is <= 128 bits.\n-        return vt->length_in_bytes() > 16;\n-      default:\n-        \/\/ For other ops whose vector size is smaller than the max vector size, a\n-        \/\/ full-sized unpredicated operation does not impact the final vector result.\n-        return false;\n-    }\n-  }\n-%}\n-\n-definitions %{\n-  int_def SVE_COST             (200, 200);\n-%}\n-\n-\n-\/\/ All SVE instructions\n-\n-\/\/ vector load\/store\n-\n-\/\/ Unpredicated vector load\/store\n-instruct loadV(vReg dst, vmemA mem) %{\n-  predicate(UseSVE > 0 && n->as_LoadVector()->memory_size() > 16);\n-  match(Set dst (LoadVector mem));\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_ldr $dst, $mem\\t# vector (sve)\" %}\n-  ins_encode %{\n-    FloatRegister dst_reg = as_FloatRegister($dst$$reg);\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, dst_reg, ptrue,\n-                          bt, bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct storeV(vReg src, vmemA mem) %{\n-  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() > 16);\n-  match(Set mem (StoreVector mem src));\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_str $mem, $src\\t# vector (sve)\" %}\n-  ins_encode %{\n-    FloatRegister src_reg = as_FloatRegister($src$$reg);\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, src_reg, ptrue,\n-                          bt, bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Load Vector (16 bits)\n-instruct loadV2_vreg(vReg dst, vmem2 mem)\n-%{\n-  predicate(UseSVE > 0 && n->as_LoadVector()->memory_size() == 2);\n-  match(Set dst (LoadVector mem));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"ldrh   $dst,$mem\\t# vector (16 bits)\" %}\n-  ins_encode( aarch64_enc_ldrvH(dst, mem) );\n-  ins_pipe(vload_reg_mem64);\n-%}\n-\n-\/\/ Store Vector (16 bits)\n-instruct storeV2_vreg(vReg src, vmem2 mem)\n-%{\n-  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() == 2);\n-  match(Set mem (StoreVector mem src));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"strh   $mem,$src\\t# vector (16 bits)\" %}\n-  ins_encode( aarch64_enc_strvH(src, mem) );\n-  ins_pipe(vstore_reg_mem64);\n-%}\n-\n-\/\/ Load Vector (32 bits)\n-instruct loadV4_vreg(vReg dst, vmem4 mem)\n-%{\n-  predicate(UseSVE > 0 && n->as_LoadVector()->memory_size() == 4);\n-  match(Set dst (LoadVector mem));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"ldrs   $dst,$mem\\t# vector (32 bits)\" %}\n-  ins_encode( aarch64_enc_ldrvS(dst, mem) );\n-  ins_pipe(vload_reg_mem64);\n-%}\n-\n-\/\/ Store Vector (32 bits)\n-instruct storeV4_vreg(vReg src, vmem4 mem)\n-%{\n-  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() == 4);\n-  match(Set mem (StoreVector mem src));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"strs   $mem,$src\\t# vector (32 bits)\" %}\n-  ins_encode( aarch64_enc_strvS(src, mem) );\n-  ins_pipe(vstore_reg_mem64);\n-%}\n-\n-\/\/ Load Vector (64 bits)\n-instruct loadV8_vreg(vReg dst, vmem8 mem)\n-%{\n-  predicate(UseSVE > 0 && n->as_LoadVector()->memory_size() == 8);\n-  match(Set dst (LoadVector mem));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"ldrd   $dst,$mem\\t# vector (64 bits)\" %}\n-  ins_encode( aarch64_enc_ldrvD(dst, mem) );\n-  ins_pipe(vload_reg_mem64);\n-%}\n-\n-\/\/ Store Vector (64 bits)\n-instruct storeV8_vreg(vReg src, vmem8 mem)\n-%{\n-  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() == 8);\n-  match(Set mem (StoreVector mem src));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"strd   $mem,$src\\t# vector (64 bits)\" %}\n-  ins_encode( aarch64_enc_strvD(src, mem) );\n-  ins_pipe(vstore_reg_mem64);\n-%}\n-\n-\/\/ Load Vector (128 bits)\n-instruct loadV16_vreg(vReg dst, vmem16 mem)\n-%{\n-  predicate(UseSVE > 0 && n->as_LoadVector()->memory_size() == 16);\n-  match(Set dst (LoadVector mem));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"ldrq   $dst,$mem\\t# vector (128 bits)\" %}\n-  ins_encode( aarch64_enc_ldrvQ(dst, mem) );\n-  ins_pipe(vload_reg_mem128);\n-%}\n-\n-\/\/ Store Vector (128 bits)\n-instruct storeV16_vreg(vReg src, vmem16 mem)\n-%{\n-  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() == 16);\n-  match(Set mem (StoreVector mem src));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"strq   $mem,$src\\t# vector (128 bits)\" %}\n-  ins_encode( aarch64_enc_strvQ(src, mem) );\n-  ins_pipe(vstore_reg_mem128);\n-%}\n-\n-\/\/ vector load\/store - predicated\n-\n-instruct loadV_masked(vReg dst, vmemA mem, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (LoadVectorMasked mem pg));\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_ldr $dst, $pg, $mem\\t# load vector predicated (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, as_FloatRegister($dst$$reg),\n-                          as_PRegister($pg$$reg), bt, bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct storeV_masked(vReg src, vmemA mem, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set mem (StoreVectorMasked mem (Binary src pg)));\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_str $mem, $pg, $src\\t# store vector predicated (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, as_FloatRegister($src$$reg),\n-                          as_PRegister($pg$$reg), bt, bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ mask logical and\/or\/xor\n-\n-instruct vmask_and(pRegGov pd, pRegGov pn, pRegGov pm) %{\n-  predicate(UseSVE > 0);\n-  match(Set pd (AndVMask pn pm));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_and $pd, $pn, $pm\\t# predicate (sve)\" %}\n-  ins_encode %{\n-    __ sve_and(as_PRegister($pd$$reg), ptrue,\n-               as_PRegister($pn$$reg), as_PRegister($pm$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_or(pRegGov pd, pRegGov pn, pRegGov pm) %{\n-  predicate(UseSVE > 0);\n-  match(Set pd (OrVMask pn pm));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_orr $pd, $pn, $pm\\t# predicate (sve)\" %}\n-  ins_encode %{\n-    __ sve_orr(as_PRegister($pd$$reg), ptrue,\n-               as_PRegister($pn$$reg), as_PRegister($pm$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_xor(pRegGov pd, pRegGov pn, pRegGov pm) %{\n-  predicate(UseSVE > 0);\n-  match(Set pd (XorVMask pn pm));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_eor $pd, $pn, $pm\\t# predicate (sve)\" %}\n-  ins_encode %{\n-    __ sve_eor(as_PRegister($pd$$reg), ptrue,\n-               as_PRegister($pn$$reg), as_PRegister($pm$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ mask logical and_not\n-\n-instruct vmask_and_notI(pRegGov pd, pRegGov pn, pRegGov pm, immI_M1 m1) %{\n-  predicate(UseSVE > 0);\n-  match(Set pd (AndVMask pn (XorVMask pm (MaskAll m1))));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_bic $pd, $pn, $pm\\t# predciate (sve) (B\/H\/S)\" %}\n-  ins_encode %{\n-    __ sve_bic(as_PRegister($pd$$reg), ptrue,\n-               as_PRegister($pn$$reg), as_PRegister($pm$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_and_notL(pRegGov pd, pRegGov pn, pRegGov pm, immL_M1 m1) %{\n-  predicate(UseSVE > 0);\n-  match(Set pd (AndVMask pn (XorVMask pm (MaskAll m1))));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_bic $pd, $pn, $pm\\t# predciate (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_bic(as_PRegister($pd$$reg), ptrue,\n-               as_PRegister($pn$$reg), as_PRegister($pm$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector reinterpret\n-\n-instruct reinterpret(vReg dst) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() ==\n-                          n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src == dst\n-  match(Set dst (VectorReinterpret dst));\n-  ins_cost(0);\n-  format %{ \"# reinterpret $dst\\t# do nothing\" %}\n-  ins_encode %{\n-    \/\/ empty\n-  %}\n-  ins_pipe(pipe_class_empty);\n-%}\n-\n-instruct reinterpretResize(vReg dst, vReg src, pRegGov pgtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() !=\n-                          n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src != dst\n-  match(Set dst (VectorReinterpret src));\n-  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"reinterpretResize $dst, $src\\t# vector (sve)\" %}\n-  ins_encode %{\n-    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, $src);\n-    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);\n-    uint length_in_bytes_resize = length_in_bytes_src < length_in_bytes_dst ?\n-                                  length_in_bytes_src : length_in_bytes_dst;\n-    assert(length_in_bytes_src <= MaxVectorSize && length_in_bytes_dst <= MaxVectorSize,\n-           \"invalid vector length\");\n-    __ sve_gen_mask_imm(as_PRegister($pgtmp$$reg), T_BYTE, length_in_bytes_resize);\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ B, 0);\n-    __ sve_sel(as_FloatRegister($dst$$reg), __ B, as_PRegister($pgtmp$$reg),\n-               as_FloatRegister($src$$reg), as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector mask reinterpret\n-\n-instruct vmask_reinterpret_same_esize(pRegGov dst_src) %{\n-  predicate(UseSVE > 0 &&\n-            n->as_Vector()->length() == n->in(1)->bottom_type()->is_vect()->length() &&\n-            n->as_Vector()->length_in_bytes() == n->in(1)->bottom_type()->is_vect()->length_in_bytes());\n-  match(Set dst_src (VectorReinterpret dst_src));\n-  ins_cost(0);\n-  format %{ \"# vmask_reinterpret $dst_src\\t# do nothing\" %}\n-  ins_encode %{\n-    \/\/ empty\n-  %}\n-  ins_pipe(pipe_class_empty);\n-%}\n-\n-instruct vmask_reinterpret_diff_esize(pRegGov dst, pRegGov src, vReg tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->as_Vector()->length() != n->in(1)->bottom_type()->is_vect()->length() &&\n-            n->as_Vector()->length_in_bytes() == n->in(1)->bottom_type()->is_vect()->length_in_bytes());\n-  match(Set dst (VectorReinterpret src));\n-  effect(TEMP tmp, KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"# vmask_reinterpret $dst, $src\\t# vector (sve)\" %}\n-  ins_encode %{\n-    BasicType from_bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant from_size = __ elemType_to_regVariant(from_bt);\n-    BasicType to_bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n-    __ sve_cpy(as_FloatRegister($tmp$$reg), from_size, as_PRegister($src$$reg), -1, false);\n-    __ sve_cmp(Assembler::EQ, as_PRegister($dst$$reg), to_size, ptrue, as_FloatRegister($tmp$$reg), -1);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector abs\n-\n-instruct vabsB(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst (AbsVB src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_abs $dst, $src\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_abs(as_FloatRegister($dst$$reg), __ B,\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vabsS(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst (AbsVS src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_abs $dst, $src\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_abs(as_FloatRegister($dst$$reg), __ H,\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vabsI(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst (AbsVI src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_abs $dst, $src\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_abs(as_FloatRegister($dst$$reg), __ S,\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vabsL(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst (AbsVL src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_abs $dst, $src\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_abs(as_FloatRegister($dst$$reg), __ D,\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vabsF(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst (AbsVF src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fabs $dst, $src\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fabs(as_FloatRegister($dst$$reg), __ S,\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vabsD(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst (AbsVD src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fabs $dst, $src\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fabs(as_FloatRegister($dst$$reg), __ D,\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector abs - predicated\n-\n-instruct vabsB_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (AbsVB dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_abs $dst_src, $pg, $dst_src\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_abs(as_FloatRegister($dst_src$$reg), __ B,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vabsS_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (AbsVS dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_abs $dst_src, $pg, $dst_src\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_abs(as_FloatRegister($dst_src$$reg), __ H,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vabsI_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (AbsVI dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_abs $dst_src, $pg, $dst_src\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_abs(as_FloatRegister($dst_src$$reg), __ S,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vabsL_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (AbsVL dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_abs $dst_src, $pg, $dst_src\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_abs(as_FloatRegister($dst_src$$reg), __ D,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vabsF_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (AbsVF dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fabs $dst_src, $pg, $dst_src\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fabs(as_FloatRegister($dst_src$$reg), __ S,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vabsD_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (AbsVD dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fabs $dst_src, $pg, $dst_src\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fabs(as_FloatRegister($dst_src$$reg), __ D,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector add\n-\n-instruct vaddB(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (AddVB src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_add $dst, $src1, $src2\\t # vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_add(as_FloatRegister($dst$$reg), __ B,\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vaddS(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (AddVS src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_add $dst, $src1, $src2\\t # vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_add(as_FloatRegister($dst$$reg), __ H,\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vaddI(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (AddVI src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_add $dst, $src1, $src2\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_add(as_FloatRegister($dst$$reg), __ S,\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vaddL(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (AddVL src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_add $dst, $src1, $src2\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_add(as_FloatRegister($dst$$reg), __ D,\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vaddF(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (AddVF src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fadd $dst, $src1, $src2\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fadd(as_FloatRegister($dst$$reg), __ S,\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vaddD(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (AddVD src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fadd $dst, $src1, $src2\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fadd(as_FloatRegister($dst$$reg), __ D,\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector add - predicated\n-\n-instruct vaddB_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AddVB (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_add $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_add(as_FloatRegister($dst_src1$$reg), __ B,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vaddS_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AddVS (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_add $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_add(as_FloatRegister($dst_src1$$reg), __ H,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vaddI_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AddVI (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_add $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_add(as_FloatRegister($dst_src1$$reg), __ S,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vaddL_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AddVL (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_add $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_add(as_FloatRegister($dst_src1$$reg), __ D,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vaddF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AddVF (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fadd $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fadd(as_FloatRegister($dst_src1$$reg), __ S,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vaddD_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AddVD (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fadd $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fadd(as_FloatRegister($dst_src1$$reg), __ D,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector add reg imm (unpredicated)\n-\n-instruct vaddImmB(vReg dst_src, immBAddSubV con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (AddVB dst_src (ReplicateB con)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_add $dst_src, $dst_src, $con\\t # vector (sve) (B)\" %}\n-  ins_encode %{\n-    int32_t val = $con$$constant;\n-    if (val > 0){\n-      __ sve_add(as_FloatRegister($dst_src$$reg), __ B, val);\n-    } else if (val < 0){\n-      __ sve_sub(as_FloatRegister($dst_src$$reg), __ B, -val);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vaddImmS(vReg dst_src, immIAddSubV con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (AddVS dst_src (ReplicateS con)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_add $dst_src, $dst_src, $con\\t # vector (sve) (H)\" %}\n-  ins_encode %{\n-    int32_t val = $con$$constant;\n-    if (val > 0){\n-      __ sve_add(as_FloatRegister($dst_src$$reg), __ H, val);\n-    } else if (val < 0){\n-      __ sve_sub(as_FloatRegister($dst_src$$reg), __ H, -val);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vaddImmI(vReg dst_src, immIAddSubV con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (AddVI dst_src (ReplicateI con)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_add $dst_src, $dst_src, $con\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    int32_t val = $con$$constant;\n-    if (val > 0){\n-      __ sve_add(as_FloatRegister($dst_src$$reg), __ S, val);\n-    } else if (val < 0){\n-      __ sve_sub(as_FloatRegister($dst_src$$reg), __ S, -val);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vaddImmL(vReg dst_src, immLAddSubV con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (AddVL dst_src (ReplicateL con)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_add $dst_src, $dst_src, $con\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    int32_t val = $con$$constant;\n-    if (val > 0){\n-      __ sve_add(as_FloatRegister($dst_src$$reg), __ D, val);\n-    } else if (val < 0){\n-      __ sve_sub(as_FloatRegister($dst_src$$reg), __ D, -val);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector binary op reg imm (unpredicated)\n-\n-instruct vandB(vReg dst_src, immBLog con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (AndV dst_src (ReplicateB con)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_and $dst_src, $dst_src, $con\\t # vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_and(as_FloatRegister($dst_src$$reg), __ B,\n-         (uint64_t)($con$$constant));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vandH(vReg dst_src, immSLog con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (AndV dst_src (ReplicateS con)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_and $dst_src, $dst_src, $con\\t # vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_and(as_FloatRegister($dst_src$$reg), __ H,\n-         (uint64_t)($con$$constant));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vandS(vReg dst_src, immILog con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (AndV dst_src (ReplicateI con)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_and $dst_src, $dst_src, $con\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_and(as_FloatRegister($dst_src$$reg), __ S,\n-         (uint64_t)($con$$constant));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vandD(vReg dst_src, immLLog con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (AndV dst_src (ReplicateL con)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_and $dst_src, $dst_src, $con\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_and(as_FloatRegister($dst_src$$reg), __ D,\n-         (uint64_t)($con$$constant));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vorB(vReg dst_src, immBLog con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (OrV dst_src (ReplicateB con)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_orr $dst_src, $dst_src, $con\\t # vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_orr(as_FloatRegister($dst_src$$reg), __ B,\n-         (uint64_t)($con$$constant));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vorH(vReg dst_src, immSLog con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (OrV dst_src (ReplicateS con)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_orr $dst_src, $dst_src, $con\\t # vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_orr(as_FloatRegister($dst_src$$reg), __ H,\n-         (uint64_t)($con$$constant));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vorS(vReg dst_src, immILog con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (OrV dst_src (ReplicateI con)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_orr $dst_src, $dst_src, $con\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_orr(as_FloatRegister($dst_src$$reg), __ S,\n-         (uint64_t)($con$$constant));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vorD(vReg dst_src, immLLog con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (OrV dst_src (ReplicateL con)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_orr $dst_src, $dst_src, $con\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_orr(as_FloatRegister($dst_src$$reg), __ D,\n-         (uint64_t)($con$$constant));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vxorB(vReg dst_src, immBLog con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (XorV dst_src (ReplicateB con)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_eor $dst_src, $dst_src, $con\\t # vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_eor(as_FloatRegister($dst_src$$reg), __ B,\n-         (uint64_t)($con$$constant));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vxorH(vReg dst_src, immSLog con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (XorV dst_src (ReplicateS con)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_eor $dst_src, $dst_src, $con\\t # vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_eor(as_FloatRegister($dst_src$$reg), __ H,\n-         (uint64_t)($con$$constant));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vxorS(vReg dst_src, immILog con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (XorV dst_src (ReplicateI con)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_eor $dst_src, $dst_src, $con\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_eor(as_FloatRegister($dst_src$$reg), __ S,\n-         (uint64_t)($con$$constant));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vxorD(vReg dst_src, immLLog con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (XorV dst_src (ReplicateL con)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_eor $dst_src, $dst_src, $con\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_eor(as_FloatRegister($dst_src$$reg), __ D,\n-         (uint64_t)($con$$constant));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\/\/ vector and\n-\n-instruct vand(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (AndV src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_and  $dst, $src1, $src2\\t# vector (sve)\" %}\n-  ins_encode %{\n-    __ sve_and(as_FloatRegister($dst$$reg),\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector or\n-\n-instruct vor(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (OrV src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_orr  $dst, $src1, $src2\\t# vector (sve)\" %}\n-  ins_encode %{\n-    __ sve_orr(as_FloatRegister($dst$$reg),\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector xor\n-\n-instruct vxor(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (XorV src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_eor  $dst, $src1, $src2\\t# vector (sve)\" %}\n-  ins_encode %{\n-    __ sve_eor(as_FloatRegister($dst$$reg),\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector and - predicated\n-\n-instruct vand_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AndV (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_and $dst_src1, $pg, $dst_src1, $src2\\t # vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_and(as_FloatRegister($dst_src1$$reg), size,\n-          as_PRegister($pg$$reg),\n-          as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector or - predicated\n-\n-instruct vor_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (OrV (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_orr $dst_src1, $pg, $dst_src1, $src2\\t # vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_orr(as_FloatRegister($dst_src1$$reg), size,\n-          as_PRegister($pg$$reg),\n-          as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector xor - predicated\n-\n-instruct vxor_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (XorV (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_eor $dst_src1, $pg, $dst_src1, $src2\\t # vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_eor(as_FloatRegister($dst_src1$$reg), size,\n-          as_PRegister($pg$$reg),\n-          as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector not\n-\n-instruct vnotI(vReg dst, vReg src, immI_M1 m1) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (XorV src (ReplicateB m1)));\n-  match(Set dst (XorV src (ReplicateS m1)));\n-  match(Set dst (XorV src (ReplicateI m1)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_not $dst, $src\\t# vector (sve) B\/H\/S\" %}\n-  ins_encode %{\n-    __ sve_not(as_FloatRegister($dst$$reg), __ D,\n-               ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vnotL(vReg dst, vReg src, immL_M1 m1) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (XorV src (ReplicateL m1)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_not $dst, $src\\t# vector (sve) D\" %}\n-  ins_encode %{\n-    __ sve_not(as_FloatRegister($dst$$reg), __ D,\n-               ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector not - predicated\n-\n-instruct vnotI_masked(vReg dst_src, immI_M1 m1, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (XorV (Binary dst_src (ReplicateB m1)) pg));\n-  match(Set dst_src (XorV (Binary dst_src (ReplicateS m1)) pg));\n-  match(Set dst_src (XorV (Binary dst_src (ReplicateI m1)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_not $dst_src, $pg, $dst_src\\t# vector (sve) B\/H\/S\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_not(as_FloatRegister($dst_src$$reg), __ elemType_to_regVariant(bt),\n-               as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vnotL_masked(vReg dst_src, immL_M1 m1, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (XorV (Binary dst_src (ReplicateL m1)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_not $dst_src, $pg, $dst_src\\t# vector (sve) D\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_not(as_FloatRegister($dst_src$$reg), __ elemType_to_regVariant(bt),\n-               as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector and_not\n-\n-instruct vand_notI(vReg dst, vReg src1, vReg src2, immI_M1 m1) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (AndV src1 (XorV src2 (ReplicateB m1))));\n-  match(Set dst (AndV src1 (XorV src2 (ReplicateS m1))));\n-  match(Set dst (AndV src1 (XorV src2 (ReplicateI m1))));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_bic $dst, $src1, $src2\\t# vector (sve) B\/H\/S\" %}\n-  ins_encode %{\n-    __ sve_bic(as_FloatRegister($dst$$reg),\n-               as_FloatRegister($src1$$reg),\n-               as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vand_notL(vReg dst, vReg src1, vReg src2, immL_M1 m1) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (AndV src1 (XorV src2 (ReplicateL m1))));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_bic $dst, $src1, $src2\\t# vector (sve) D\" %}\n-  ins_encode %{\n-    __ sve_bic(as_FloatRegister($dst$$reg),\n-               as_FloatRegister($src1$$reg),\n-               as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector and_not - predicated\n-\n-instruct vand_notI_masked(vReg dst_src1, vReg src2, immI_M1 m1, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateB m1))) pg));\n-  match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateS m1))) pg));\n-  match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateI m1))) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_bic $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) B\/H\/S\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_bic(as_FloatRegister($dst_src1$$reg), __ elemType_to_regVariant(bt),\n-               as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vand_notL_masked(vReg dst_src1, vReg src2, immL_M1 m1, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateL m1))) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_bic $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) D\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_bic(as_FloatRegister($dst_src1$$reg), __ elemType_to_regVariant(bt),\n-               as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector float div\n-\n-instruct vdivF(vReg dst_src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (DivVF dst_src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fdiv  $dst_src1, $dst_src1, $src2\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fdiv(as_FloatRegister($dst_src1$$reg), __ S,\n-         ptrue, as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vdivD(vReg dst_src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (DivVD dst_src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fdiv  $dst_src1, $dst_src1, $src2\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fdiv(as_FloatRegister($dst_src1$$reg), __ D,\n-         ptrue, as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector float div - predicated\n-\n-instruct vfdivF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (DivVF (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fdiv $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fdiv(as_FloatRegister($dst_src1$$reg), __ S,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vfdivD_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (DivVD (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fdiv $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fdiv(as_FloatRegister($dst_src1$$reg), __ D,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector min\/max\n-\n-instruct vmin(vReg dst_src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (MinV dst_src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_min $dst_src1, $dst_src1, $src2\\t # vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    if (is_floating_point_type(bt)) {\n-      __ sve_fmin(as_FloatRegister($dst_src1$$reg), size,\n-                  ptrue, as_FloatRegister($src2$$reg));\n-    } else {\n-      assert(is_integral_type(bt), \"unsupported type\");\n-      __ sve_smin(as_FloatRegister($dst_src1$$reg), size,\n-                  ptrue, as_FloatRegister($src2$$reg));\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmax(vReg dst_src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (MaxV dst_src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_max $dst_src1, $dst_src1, $src2\\t # vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    if (is_floating_point_type(bt)) {\n-      __ sve_fmax(as_FloatRegister($dst_src1$$reg), size,\n-                  ptrue, as_FloatRegister($src2$$reg));\n-    } else {\n-      assert(is_integral_type(bt), \"unsupported type\");\n-      __ sve_smax(as_FloatRegister($dst_src1$$reg), size,\n-                  ptrue, as_FloatRegister($src2$$reg));\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector min\/max - predicated\n-\n-instruct vmin_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (MinV (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_min $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    if (is_floating_point_type(bt)) {\n-      __ sve_fmin(as_FloatRegister($dst_src1$$reg), size,\n-                  as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n-    } else {\n-      assert(is_integral_type(bt), \"unsupported type\");\n-      __ sve_smin(as_FloatRegister($dst_src1$$reg), size,\n-                  as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmax_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (MaxV (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_max $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    if (is_floating_point_type(bt)) {\n-      __ sve_fmax(as_FloatRegister($dst_src1$$reg), size,\n-                  as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n-    } else {\n-      assert(is_integral_type(bt), \"unsupported type\");\n-      __ sve_smax(as_FloatRegister($dst_src1$$reg), size,\n-                  as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector fmla\n-\n-\/\/ dst_src1 = dst_src1 + src2 * src3\n-instruct vfmlaF(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0);\n-  match(Set dst_src1 (FmaVF dst_src1 (Binary src2 src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmla $dst_src1, $src2, $src3\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fmla(as_FloatRegister($dst_src1$$reg), __ S,\n-         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 + src2 * src3\n-instruct vfmlaD(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0);\n-  match(Set dst_src1 (FmaVD dst_src1 (Binary src2 src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmla $dst_src1, $src2, $src3\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fmla(as_FloatRegister($dst_src1$$reg), __ D,\n-         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector fmad - predicated\n-\n-\/\/ dst_src1 = dst_src1 * src2 + src3\n-instruct vfmadF_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n-  predicate(UseFMA && UseSVE > 0);\n-  match(Set dst_src1 (FmaVF (Binary dst_src1 src2) (Binary src3 pg)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmad $dst_src1, $pg, $src2, $src3\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fmad(as_FloatRegister($dst_src1$$reg), __ S, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 * src2 + src3\n-instruct vfmadD_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n-  predicate(UseFMA && UseSVE > 0);\n-  match(Set dst_src1 (FmaVD (Binary dst_src1 src2) (Binary src3 pg)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmad $dst_src1, $pg, $src2, $src3\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fmad(as_FloatRegister($dst_src1$$reg), __ D, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector fmls\n-\n-\/\/ dst_src1 = dst_src1 + -src2 * src3\n-\/\/ The NegVF must not be predicated.\n-instruct vfmlsF1(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaVF dst_src1 (Binary (NegVF src2) src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmls $dst_src1, $src2, $src3\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fmls(as_FloatRegister($dst_src1$$reg), __ S,\n-         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 + src2 * -src3\n-\/\/ The NegVF must not be predicated.\n-instruct vfmlsF2(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(2)->in(2)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaVF dst_src1 (Binary src2 (NegVF src3))));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmls $dst_src1, $src2, $src3\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fmls(as_FloatRegister($dst_src1$$reg), __ S,\n-         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 + -src2 * src3\n-\/\/ The NegVD must not be predicated.\n-instruct vfmlsD1(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaVD dst_src1 (Binary (NegVD src2) src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmls $dst_src1, $src2, $src3\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fmls(as_FloatRegister($dst_src1$$reg), __ D,\n-         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 + src2 * -src3\n-\/\/ The NegVD must not be predicated.\n-instruct vfmlsD2(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(2)->in(2)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaVD dst_src1 (Binary src2 (NegVD src3))));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmls $dst_src1, $src2, $src3\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fmls(as_FloatRegister($dst_src1$$reg), __ D,\n-         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector fmsb - predicated\n-\n-\/\/ dst_src1 = dst_src1 * -src2 + src3\n-\/\/ The NegVF must not be predicated.\n-instruct vfmsbF_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(1)->in(2)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaVF (Binary dst_src1 (NegVF src2)) (Binary src3 pg)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmsb $dst_src1, $pg, $src2, $src3\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fmsb(as_FloatRegister($dst_src1$$reg), __ S, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 * -src2 + src3\n-\/\/ The NegVD must not be predicated.\n-instruct vfmsbD_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(1)->in(2)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaVD (Binary dst_src1 (NegVD src2)) (Binary src3 pg)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmsb $dst_src1, $pg, $src2, $src3\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fmsb(as_FloatRegister($dst_src1$$reg), __ D, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector fnmla\n-\n-\/\/ dst_src1 = -dst_src1 + -src2 * src3\n-\/\/ The NegVF must not be predicated.\n-instruct vfnmlaF1(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(1)->as_Vector()->is_predicated_vector() &&\n-            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaVF (NegVF dst_src1) (Binary (NegVF src2) src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fnmla $dst_src1, $src2, $src3\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fnmla(as_FloatRegister($dst_src1$$reg), __ S,\n-         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = -dst_src1 + src2 * -src3\n-\/\/ The NegVF must not be predicated.\n-instruct vfnmlaF2(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(1)->as_Vector()->is_predicated_vector() &&\n-            !n->in(2)->in(2)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaVF (NegVF dst_src1) (Binary src2 (NegVF src3))));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fnmla $dst_src1, $src2, $src3\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fnmla(as_FloatRegister($dst_src1$$reg), __ S,\n-         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = -dst_src1 + -src2 * src3\n-\/\/ The NegVD must not be predicated.\n-instruct vfnmlaD1(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(1)->as_Vector()->is_predicated_vector() &&\n-            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaVD (NegVD dst_src1) (Binary (NegVD src2) src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fnmla $dst_src1, $src2, $src3\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fnmla(as_FloatRegister($dst_src1$$reg), __ D,\n-         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = -dst_src1 + src2 * -src3\n-\/\/ The NegVD must not be predicated.\n-instruct vfnmlaD2(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(1)->as_Vector()->is_predicated_vector() &&\n-            !n->in(2)->in(2)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaVD (NegVD dst_src1) (Binary src2 (NegVD src3))));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fnmla $dst_src1, $src2, $src3\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fnmla(as_FloatRegister($dst_src1$$reg), __ D,\n-         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector fnmad - predicated\n-\n-\/\/ dst_src1 = -src3 + dst_src1 * -src2\n-\/\/ The NegVF must not be predicated.\n-instruct vfnmadF_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(1)->in(2)->as_Vector()->is_predicated_vector() &&\n-            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaVF (Binary dst_src1 (NegVF src2)) (Binary (NegVF src3) pg)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fnmad $dst_src1, $pg, $src2, $src3\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fnmad(as_FloatRegister($dst_src1$$reg), __ S, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = -src3 + dst_src1 * -src2\n-\/\/ The NegVD must not be predicated.\n-instruct vfnmadD_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(1)->in(2)->as_Vector()->is_predicated_vector() &&\n-            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaVD (Binary dst_src1 (NegVD src2)) (Binary (NegVD src3) pg)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fnmad $dst_src1, $pg, $src2, $src3\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fnmad(as_FloatRegister($dst_src1$$reg), __ D, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector fnmls\n-\n-\/\/ dst_src1 = -dst_src1 + src2 * src3\n-\/\/ The NegVF must not be predicated.\n-instruct vfnmlsF(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(1)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaVF (NegVF dst_src1) (Binary src2 src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fnmls $dst_src1, $src2, $src3\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fnmls(as_FloatRegister($dst_src1$$reg), __ S,\n-         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = -dst_src1 + src2 * src3\n-\/\/ The NegVD must not be predicated.\n-instruct vfnmlsD(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(1)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaVD (NegVD dst_src1) (Binary src2 src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fnmls $dst_src1, $src2, $src3\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fnmls(as_FloatRegister($dst_src1$$reg), __ D,\n-         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector fnmsb - predicated\n-\n-\/\/ dst_src1 = -src3 + dst_src1 * src2\n-\/\/ The NegVF must not be predicated.\n-instruct vfnmsbF_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaVF (Binary dst_src1 src2) (Binary (NegVF src3) pg)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fnmsb $dst_src1, $pg, $src2, $src3\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fnmsb(as_FloatRegister($dst_src1$$reg), __ S, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = -src3 + dst_src1 * src2\n-\/\/ The NegVD must not be predicated.\n-instruct vfnmsbD_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaVD (Binary dst_src1 src2) (Binary (NegVD src3) pg)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fnmsb $dst_src1, $pg, $src2, $src3\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fnmsb(as_FloatRegister($dst_src1$$reg), __ D, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector mla\n-\n-\/\/ dst_src1 = dst_src1 + src2 * src3\n-instruct vmlaB(vReg dst_src1, vReg src2, vReg src3)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AddVB dst_src1 (MulVB src2 src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mla $dst_src1, src2, src3\\t # vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ B,\n-      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 + src2 * src3\n-instruct vmlaS(vReg dst_src1, vReg src2, vReg src3)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AddVS dst_src1 (MulVS src2 src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mla $dst_src1, src2, src3\\t # vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ H,\n-      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 + src2 * src3\n-instruct vmlaI(vReg dst_src1, vReg src2, vReg src3)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AddVI dst_src1 (MulVI src2 src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mla $dst_src1, src2, src3\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ S,\n-      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 + src2 * src3\n-instruct vmlaL(vReg dst_src1, vReg src2, vReg src3)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AddVL dst_src1 (MulVL src2 src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mla $dst_src1, src2, src3\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ D,\n-      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector mla - predicated\n-\n-\/\/ dst_src1 = dst_src1 + src2 * src3\n-instruct vmlaB_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AddVB (Binary dst_src1 (MulVB src2 src3)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mla $dst_src1, $pg, src2, src3\\t # vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ B, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 + src2 * src3\n-instruct vmlaS_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AddVS (Binary dst_src1 (MulVS src2 src3)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mla $dst_src1, $pg, src2, src3\\t # vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ H, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 + src2 * src3\n-instruct vmlaI_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AddVI (Binary dst_src1 (MulVI src2 src3)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mla $dst_src1, $pg, src2, src3\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ S, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 + src2 * src3\n-instruct vmlaL_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AddVL (Binary dst_src1 (MulVL src2 src3)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mla $dst_src1, $pg, src2, src3\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ D, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector mls\n-\n-\/\/ dst_src1 = dst_src1 - src2 * src3\n-instruct vmlsB(vReg dst_src1, vReg src2, vReg src3)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (SubVB dst_src1 (MulVB src2 src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mls $dst_src1, src2, src3\\t # vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ B,\n-      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 - src2 * src3\n-instruct vmlsS(vReg dst_src1, vReg src2, vReg src3)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (SubVS dst_src1 (MulVS src2 src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mls $dst_src1, src2, src3\\t # vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ H,\n-      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 - src2 * src3\n-instruct vmlsI(vReg dst_src1, vReg src2, vReg src3)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (SubVI dst_src1 (MulVI src2 src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mls $dst_src1, src2, src3\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ S,\n-      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 - src2 * src3\n-instruct vmlsL(vReg dst_src1, vReg src2, vReg src3)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (SubVL dst_src1 (MulVL src2 src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mls $dst_src1, src2, src3\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ D,\n-      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector mls - predicated\n-\n-\/\/ dst_src1 = dst_src1 - src2 * src3\n-instruct vmlsB_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (SubVB (Binary dst_src1 (MulVB src2 src3)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mls $dst_src1, $pg, src2, src3\\t # vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ B, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 - src2 * src3\n-instruct vmlsS_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (SubVS (Binary dst_src1 (MulVS src2 src3)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mls $dst_src1, $pg, src2, src3\\t # vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ H, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 - src2 * src3\n-instruct vmlsI_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (SubVI (Binary dst_src1 (MulVI src2 src3)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mls $dst_src1, $pg, src2, src3\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ S, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 - src2 * src3\n-instruct vmlsL_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (SubVL (Binary dst_src1 (MulVL src2 src3)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mls $dst_src1, $pg, src2, src3\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ D, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector mul\n-\n-instruct vmulB(vReg dst_src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (MulVB dst_src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mul $dst_src1, $dst_src1, $src2\\t # vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_mul(as_FloatRegister($dst_src1$$reg), __ B,\n-         ptrue, as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmulS(vReg dst_src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (MulVS dst_src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mul $dst_src1, $dst_src1, $src2\\t # vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_mul(as_FloatRegister($dst_src1$$reg), __ H,\n-         ptrue, as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmulI(vReg dst_src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (MulVI dst_src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mul $dst_src1, $dst_src1, $src2\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_mul(as_FloatRegister($dst_src1$$reg), __ S,\n-         ptrue, as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmulL(vReg dst_src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (MulVL dst_src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mul $dst_src1, $dst_src1, $src2\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_mul(as_FloatRegister($dst_src1$$reg), __ D,\n-         ptrue, as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmulF(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (MulVF src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmul $dst, $src1, $src2\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fmul(as_FloatRegister($dst$$reg), __ S,\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmulD(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (MulVD src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmul $dst, $src1, $src2\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fmul(as_FloatRegister($dst$$reg), __ D,\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector mul - predicated\n-\n-instruct vmulB_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (MulVB (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mul $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_mul(as_FloatRegister($dst_src1$$reg), __ B,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmulS_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (MulVS (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mul $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_mul(as_FloatRegister($dst_src1$$reg), __ H,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmulI_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (MulVI (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mul $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_mul(as_FloatRegister($dst_src1$$reg), __ S,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmulL_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (MulVL (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mul $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_mul(as_FloatRegister($dst_src1$$reg), __ D,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmulF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (MulVF (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmul $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fmul(as_FloatRegister($dst_src1$$reg), __ S,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmulD_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (MulVD (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmul $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fmul(as_FloatRegister($dst_src1$$reg), __ D,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector neg\n-\n-instruct vnegI(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst (NegVI src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_neg $dst, $src\\t# vector (sve) (B\/H\/S)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_neg(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(bt),\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vnegL(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst (NegVL src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_neg $dst, $src\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_neg(as_FloatRegister($dst$$reg), __ D,\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vnegF(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst (NegVF src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fneg $dst, $src\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fneg(as_FloatRegister($dst$$reg), __ S,\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vnegD(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst (NegVD src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fneg $dst, $src\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fneg(as_FloatRegister($dst$$reg), __ D,\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector neg - predicated\n-\n-instruct vnegI_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (NegVI dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_neg $dst_src, $pg, $dst_src\\t# vector (sve) (B\/H\/S)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_neg(as_FloatRegister($dst_src$$reg), __ elemType_to_regVariant(bt),\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vnegL_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (NegVL dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_neg $dst_src, $pg, $dst_src\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_neg(as_FloatRegister($dst_src$$reg), __ D,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vnegF_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (NegVF dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fneg $dst_src, $pg, $dst_src\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fneg(as_FloatRegister($dst_src$$reg), __ S,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vnegD_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (NegVD dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fneg $dst_src, $pg, $dst_src\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fneg(as_FloatRegister($dst_src$$reg), __ D,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector popcount\n-\n-instruct vpopcountI(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst (PopCountVI src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_cnt $dst, $src\\t# vector (sve) (B\/H\/S)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_cnt(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(bt),\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vpopcountL(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector() &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (PopCountVL src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_cnt $dst, $src\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_cnt(as_FloatRegister($dst$$reg), __ D,\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ If the PopCountVL is generated by auto-vectorization, the dst basic\n-\/\/ type is T_INT. And once we have unified the type definition for\n-\/\/ Vector API and auto-vectorization, this rule can be merged with\n-\/\/ \"vpopcountL\" rule.\n-instruct vpopcountLI(vReg dst, vReg src, vReg vtmp) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector() &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (PopCountVL src));\n-  effect(TEMP_DEF dst, TEMP vtmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_cnt $dst, $src\\n\\t\"\n-            \"sve_dup $vtmp, #0\\n\\t\"\n-            \"sve_uzp1 $dst, $dst, $vtmp\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_cnt(as_FloatRegister($dst$$reg), __ D,\n-         ptrue, as_FloatRegister($src$$reg));\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ S,\n-         as_FloatRegister($dst$$reg), __ D, as_FloatRegister($vtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector popcount - predicated\n-\n-instruct vpopcountI_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (PopCountVI dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_cnt $dst_src, $pg, $dst_src\\t# vector (sve) (B\/H\/S)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_cnt(as_FloatRegister($dst_src$$reg), __ elemType_to_regVariant(bt),\n-         as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vpopcountL_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst_src (PopCountVL dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_cnt $dst_src, $pg, $dst_src\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_cnt(as_FloatRegister($dst_src$$reg), __ D,\n-         as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector blend\n-\n-instruct vblend(vReg dst, vReg src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorBlend (Binary src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_sel $dst, $pg, $src2, $src1\\t# vector blend (sve)\" %}\n-  ins_encode %{\n-    Assembler::SIMD_RegVariant size =\n-               __ elemType_to_regVariant(Matcher::vector_element_basic_type(this));\n-    __ sve_sel(as_FloatRegister($dst$$reg), size, as_PRegister($pg$$reg),\n-               as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector store mask\n-\n-instruct vstoremaskB(vReg dst, pRegGov src, immI_1 size) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorStoreMask src size));\n-  ins_cost(SVE_COST);\n-  format %{ \"vstoremask $dst, $src\\t# vector store mask (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ B, as_PRegister($src$$reg), 1, false);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vstoremask_narrow(vReg dst, pRegGov src, vReg tmp, immI_gt_1 size) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorStoreMask src size));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"vstoremask $dst, $src\\t# vector store mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    Assembler::SIMD_RegVariant size = __ elemBytes_to_regVariant((int)$size$$constant);\n-    __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($src$$reg), 1, false);\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ B,\n-                         as_FloatRegister($dst$$reg), size, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Combined rules for vector mask load when the vector element type is not T_BYTE\n-\n-\/\/ VectorLoadMask+LoadVector, and the VectorLoadMask is unpredicated.\n-instruct vloadmask_loadV(pRegGov dst, indirect mem, vReg vtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && !n->is_predicated_vector() &&\n-            type2aelembytes(n->bottom_type()->is_vect()->element_basic_type()) > 1);\n-  match(Set dst (VectorLoadMask (LoadVector mem)));\n-  effect(TEMP vtmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_ld1b $vtmp, $mem\\n\\t\"\n-            \"sve_cmpne $dst, $vtmp, 0\\t# load vector mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    \/\/ Load mask values which are boolean type, and extend them to the\n-    \/\/ defined vector element type. Convert the vector to predicate.\n-    assert(Matcher::vector_length_in_bytes(this) == MaxVectorSize, \"invalid vector length\");\n-    BasicType to_vect_bt = Matcher::vector_element_basic_type(this);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, as_FloatRegister($vtmp$$reg),\n-                          ptrue, T_BOOLEAN, to_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ elemType_to_regVariant(to_vect_bt),\n-               ptrue, as_FloatRegister($vtmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ VectorLoadMask+LoadVector, and the VectorLoadMask is predicated.\n-instruct vloadmask_loadV_masked(pRegGov dst, indirect mem, pRegGov pg, vReg vtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            type2aelembytes(n->bottom_type()->is_vect()->element_basic_type()) > 1);\n-  match(Set dst (VectorLoadMask (LoadVector mem) pg));\n-  effect(TEMP vtmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_ld1b $vtmp, $pg, $mem\\n\\t\"\n-            \"sve_cmpne $dst, $pg, $vtmp, 0\\t# load vector mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    \/\/ Load valid mask values which are boolean type, and extend them to the\n-    \/\/ defined vector element type. Convert the vector to predicate.\n-    BasicType to_vect_bt = Matcher::vector_element_basic_type(this);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, as_FloatRegister($vtmp$$reg),\n-                          as_PRegister($pg$$reg), T_BOOLEAN, to_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ elemType_to_regVariant(to_vect_bt),\n-               as_PRegister($pg$$reg), as_FloatRegister($vtmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ VectorLoadMask+LoadVectorMasked, and the VectorLoadMask is unpredicated.\n-instruct vloadmask_loadVMasked(pRegGov dst, vmemA mem, pRegGov pg, vReg vtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && !n->is_predicated_vector() &&\n-            type2aelembytes(n->bottom_type()->is_vect()->element_basic_type()) > 1);\n-  match(Set dst (VectorLoadMask (LoadVectorMasked mem pg)));\n-  effect(TEMP vtmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_ld1b $vtmp, $mem\\n\\t\"\n-            \"sve_cmpne $dst, $vtmp, 0\\t# load vector mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    \/\/ Load mask values which are boolean type, and extend them to the\n-    \/\/ defined vector element type. Convert the vector to predicate.\n-    \/\/\n-    \/\/ Note that we cannot use \"pg\" here, since it is the predicate used\n-    \/\/ for the vector load with boolean type. But the predicate used in\n-    \/\/ the extending \"sve_ld1b\" is based on the final extended vector type,\n-    \/\/ which is the full-sized predicate (ptrue) used in VectorLoadMask.\n-    assert(Matcher::vector_length_in_bytes(this) == MaxVectorSize, \"invalid vector length\");\n-    BasicType to_vect_bt = Matcher::vector_element_basic_type(this);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, as_FloatRegister($vtmp$$reg),\n-                          ptrue, T_BOOLEAN, to_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ elemType_to_regVariant(to_vect_bt),\n-               ptrue, as_FloatRegister($vtmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ VectorLoadMask+LoadVectorMasked, and the VectorLoadMask is predicated.\n-instruct vloadmask_loadVMasked_masked(pRegGov dst, vmemA mem, pRegGov pg1, pRegGov pg2,\n-                                      vReg vtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            type2aelembytes(n->bottom_type()->is_vect()->element_basic_type()) > 1);\n-  match(Set dst (VectorLoadMask (LoadVectorMasked mem pg1) pg2));\n-  effect(TEMP vtmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_ld1b $vtmp, $pg2, $mem\\n\\t\"\n-            \"sve_cmpne $dst, $pg2, $vtmp, 0\\t# load vector mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    \/\/ Load valid mask values which are boolean type, and extend them to the\n-    \/\/ defined vector element type. Convert the vector to predicate.\n-    \/\/\n-    \/\/ Note that we cannot use \"pg1\" here, since it is the predicate used\n-    \/\/ for the vector load with boolean type. But the predicate used in\n-    \/\/ the extending \"sve_ld1b\" is based on the final extended vector type,\n-    \/\/ which is the \"pg2\" used in VectorLoadMask.\n-    BasicType to_vect_bt = Matcher::vector_element_basic_type(this);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, as_FloatRegister($vtmp$$reg),\n-                          as_PRegister($pg2$$reg), T_BOOLEAN, to_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ elemType_to_regVariant(to_vect_bt),\n-               as_PRegister($pg2$$reg), as_FloatRegister($vtmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Combined rules for vector mask store when the vector element type is not T_BYTE\n-\n-\/\/ StoreVector+VectorStoreMask, and the vector size of \"src\" is equal to the MaxVectorSize.\n-instruct storeV_vstoremask(indirect mem, pRegGov src, vReg vtmp, immI_gt_1 esize) %{\n-  predicate(UseSVE > 0 &&\n-            Matcher::vector_length_in_bytes(n->as_StoreVector()->in(MemNode::ValueIn)->in(1)) == MaxVectorSize);\n-  match(Set mem (StoreVector mem (VectorStoreMask src esize)));\n-  effect(TEMP vtmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_cpy $vtmp, $src, 1\\n\\t\"\n-            \"sve_st1b $vtmp, $mem\\t# store vector mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    \/\/ Convert the valid src predicate to vector, and store the vector elements\n-    \/\/ as boolean values.\n-    BasicType from_vect_bt = Matcher::vector_element_basic_type(this, $src);\n-    assert(type2aelembytes(from_vect_bt) == (int)$esize$$constant, \"unsupported type.\");\n-    Assembler::SIMD_RegVariant size = __ elemBytes_to_regVariant($esize$$constant);\n-    __ sve_cpy(as_FloatRegister($vtmp$$reg), size, as_PRegister($src$$reg), 1, false);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, as_FloatRegister($vtmp$$reg),\n-                          ptrue, T_BOOLEAN, from_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ StoreVector+VectorStoreMask, and the vector size of \"src\" is lower than the MaxVectorSize.\n-instruct storeV_vstoremask_masked(indirect mem, pRegGov src, vReg vtmp,\n-                                  immI_gt_1 esize, pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            Matcher::vector_length_in_bytes(n->as_StoreVector()->in(MemNode::ValueIn)->in(1)) < MaxVectorSize);\n-  match(Set mem (StoreVector mem (VectorStoreMask src esize)));\n-  effect(TEMP vtmp, TEMP ptmp, KILL cr);\n-  format %{ \"sve_cpy $vtmp, $src, 1\\n\\t\"\n-            \"sve_ptrue $ptmp, vector_length\\n\\t\"\n-            \"sve_st1b $vtmp, $ptmp, $mem\\t# store vector mask (sve) (H\/S\/D)\" %}\n-  ins_cost(3 * SVE_COST);\n-  ins_encode %{\n-    \/\/ Convert the valid src predicate to vector, and store the vector elements\n-    \/\/ as boolean values.\n-    BasicType from_vect_bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(from_vect_bt);\n-    __ sve_cpy(as_FloatRegister($vtmp$$reg), size, as_PRegister($src$$reg), 1, false);\n-    __ sve_gen_mask_imm(as_PRegister($ptmp$$reg), from_vect_bt, Matcher::vector_length(this, $src));\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, as_FloatRegister($vtmp$$reg),\n-                          as_PRegister($ptmp$$reg), T_BOOLEAN, from_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ StoreVectorMasked+VectorStoreMask, and the vector size of \"src\" is equal to the MaxVectorSize.\n-instruct storeVMasked_vstoremask(vmemA mem, pRegGov src, pRegGov pg, vReg vtmp, immI_gt_1 esize) %{\n-  predicate(UseSVE > 0 &&\n-            Matcher::vector_length_in_bytes(n->as_StoreVector()->in(MemNode::ValueIn)->in(1)) == MaxVectorSize);\n-  match(Set mem (StoreVectorMasked mem (Binary (VectorStoreMask src esize) pg)));\n-  effect(TEMP vtmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_cpy $vtmp, $src, 1\\n\\t\"\n-            \"sve_st1b $vtmp, $mem\\t# store vector mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    \/\/ Convert the valid src predicate to vector, and store the vector elements\n-    \/\/ as boolean values.\n-    \/\/\n-    \/\/ Note that we cannot use \"pg\" here, since it is the predicate used\n-    \/\/ for the vector store with boolean type. But the predicate used in\n-    \/\/ the narrowing \"sve_st1b\" is based on the \"src\" vector type, which\n-    \/\/ is the full-sized predicate (ptrue) here.\n-    BasicType from_vect_bt = Matcher::vector_element_basic_type(this, $src);\n-    assert(type2aelembytes(from_vect_bt) == (int)$esize$$constant, \"unsupported type.\");\n-    Assembler::SIMD_RegVariant size = __ elemBytes_to_regVariant($esize$$constant);\n-    __ sve_cpy(as_FloatRegister($vtmp$$reg), size, as_PRegister($src$$reg), 1, false);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, as_FloatRegister($vtmp$$reg),\n-                          ptrue, T_BOOLEAN, from_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ StoreVectorMasked+VectorStoreMask, and the vector size of \"src\" is lower than the MaxVectorSize.\n-instruct storeVMasked_vstoremask_masked(vmemA mem, pRegGov src, pRegGov pg, vReg vtmp,\n-                                        immI_gt_1 esize, pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            Matcher::vector_length_in_bytes(n->as_StoreVector()->in(MemNode::ValueIn)->in(1)) < MaxVectorSize);\n-  match(Set mem (StoreVectorMasked mem (Binary (VectorStoreMask src esize) pg)));\n-  effect(TEMP vtmp, TEMP ptmp, KILL cr);\n-  format %{ \"sve_cpy $vtmp, $src, 1\\n\\t\"\n-            \"sve_ptrue $ptmp, vector_length\\n\\t\"\n-            \"sve_st1b $vtmp, $ptmp, $mem\\t# store vector mask (sve) (H\/S\/D)\" %}\n-  ins_cost(3 * SVE_COST);\n-  ins_encode %{\n-    \/\/ Convert the valid src predicate to vector, and store the vector elements\n-    \/\/ as boolean values.\n-    \/\/\n-    \/\/ Note that we cannot use \"pg\" here, since it is the predicate used for the\n-    \/\/ vector store with boolean type. But the predicate used in the narrowing\n-    \/\/ \"sve_st1b\" is based on the \"src\" vector type, which needed to be generated\n-    \/\/ here.\n-    BasicType from_vect_bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(from_vect_bt);\n-    __ sve_cpy(as_FloatRegister($vtmp$$reg), size, as_PRegister($src$$reg), 1, false);\n-    __ sve_gen_mask_imm(as_PRegister($ptmp$$reg), from_vect_bt, Matcher::vector_length(this, $src));\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, as_FloatRegister($vtmp$$reg),\n-                          as_PRegister($ptmp$$reg), T_BOOLEAN, from_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector add reduction\n-\n-instruct reduce_addI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (AddReductionVI src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_addI $dst, $src1, $src2\\t# addI reduction (sve) (may extend)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           ptrue, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_addL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (AddReductionVL src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_addL $dst, $src1, $src2\\t# addL reduction (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           ptrue, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_addF(vRegF src1_dst, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set src1_dst (AddReductionVF src1_dst src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fadda $src1_dst, $src1_dst, $src2\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ S,\n-         ptrue, as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_addD(vRegD src1_dst, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set src1_dst (AddReductionVD src1_dst src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fadda $src1_dst, $src1_dst, $src2\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ D,\n-         ptrue, as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector add reduction - predicated\n-\n-instruct reduce_addI_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (AddReductionVI (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_addI $dst, $src1, $pg, $src2\\t# addI reduction predicated (sve) (may extend)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_addL_masked(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (AddReductionVL (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_addL $dst, $src1, $pg, $src2\\t# addL reduction predicated (sve)\" %}\n-  ins_encode %{\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_addF_masked(vRegF src1_dst, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set src1_dst (AddReductionVF (Binary src1_dst src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_addF $src1_dst, $pg, $src2\\t# addF reduction predicated (sve)\" %}\n-  ins_encode %{\n-    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ S,\n-                 as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_addD_masked(vRegD src1_dst, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set src1_dst (AddReductionVD (Binary src1_dst src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_addD $src1_dst, $pg, $src2\\t# addD reduction predicated (sve)\" %}\n-  ins_encode %{\n-    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ D,\n-                 as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector and reduction\n-\n-instruct reduce_andI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG);\n-  match(Set dst (AndReductionV src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_andI $dst, $src1, $src2\\t# andI reduction (sve) (may extend)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           ptrue, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_andL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (AndReductionV src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_andL $dst, $src1, $src2\\t# andL reduction (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           ptrue, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector and reduction - predicated\n-\n-instruct reduce_andI_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG);\n-  match(Set dst (AndReductionV (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_andI $dst, $src1, $pg, $src2\\t# andI reduction predicated (sve) (may extend)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_andL_masked(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (AndReductionV (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_andL $dst, $src1, $pg, $src2\\t# andL reduction predicated (sve)\" %}\n-  ins_encode %{\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector or reduction\n-\n-instruct reduce_orI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG);\n-  match(Set dst (OrReductionV src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_orI $dst, $src1, $src2\\t# orI reduction (sve) (may extend)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           ptrue, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_orL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (OrReductionV src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_orL $dst, $src1, $src2\\t# orL reduction (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           ptrue, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector or reduction - predicated\n-\n-instruct reduce_orI_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG);\n-  match(Set dst (OrReductionV (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_orI $dst, $src1, $pg, $src2\\t# orI reduction predicated (sve) (may extend)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_orL_masked(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (OrReductionV (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_orL $dst, $src1, $pg, $src2\\t# orL reduction predicated (sve)\" %}\n-  ins_encode %{\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector xor reduction\n-\n-instruct reduce_eorI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG);\n-  match(Set dst (XorReductionV src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_eorI $dst, $src1, $src2\\t# eorI reduction (sve) (may extend)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           ptrue, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_eorL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (XorReductionV src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_eorL $dst, $src1, $src2\\t# eorL reduction (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           ptrue, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector xor reduction - predicated\n-\n-instruct reduce_eorI_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG);\n-  match(Set dst (XorReductionV (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_eorI $dst, $src1, $pg, $src2\\t# eorI reduction predicated (sve) (may extend)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_eorL_masked(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (XorReductionV (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_eorL $dst, $src1, $pg, $src2\\t# eorL reduction predicated (sve)\" %}\n-  ins_encode %{\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector max reduction\n-\n-instruct reduce_maxI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n-            is_integral_type(n->in(2)->bottom_type()->is_vect()->element_basic_type()));\n-  match(Set dst (MaxReductionV src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_maxI $dst, $src1, $src2\\t# maxI reduction (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           ptrue, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_maxL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (MaxReductionV src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_maxL $dst, $src1, $src2\\t# maxL reduction (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           ptrue, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_maxF(vRegF dst, vRegF src1, vReg src2) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (MaxReductionV src1 src2));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"sve_reduce_maxF $dst, $src1, $src2\\t# maxF reduction (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_fmaxv(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src2$$reg));\n-    __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_maxD(vRegD dst, vRegD src1, vReg src2) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (MaxReductionV src1 src2));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"sve_reduce_maxD $dst, $src1, $src2\\t# maxD reduction (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_fmaxv(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($src2$$reg));\n-    __ fmaxd(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector max reduction - predicated\n-\n-instruct reduce_maxI_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp,\n-                           pRegGov pg, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n-            is_integral_type(n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type()));\n-  match(Set dst (MaxReductionV (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_maxI $dst, $src1, $pg, $src2\\t# maxI reduction predicated (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_maxL_masked(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp,\n-                          pRegGov pg, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (MaxReductionV (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_maxL $dst, $src1, $pg, $src2\\t# maxL reduction predicated (sve)\" %}\n-  ins_encode %{\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_maxF_masked(vRegF dst, vRegF src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (MaxReductionV (Binary src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"sve_reduce_maxF $dst, $src1, $pg, $src2\\t# maxF reduction predicated (sve)\" %}\n-  ins_encode %{\n-    __ sve_fmaxv(as_FloatRegister($dst$$reg), __ S, as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n-    __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_maxD_masked(vRegD dst, vRegD src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (MaxReductionV (Binary src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"sve_reduce_maxD $dst, $src1, $pg, $src2\\t# maxD reduction predicated (sve)\" %}\n-  ins_encode %{\n-    __ sve_fmaxv(as_FloatRegister($dst$$reg), __ D, as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n-    __ fmaxd(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector min reduction\n-\n-instruct reduce_minI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n-            is_integral_type(n->in(2)->bottom_type()->is_vect()->element_basic_type()));\n-  match(Set dst (MinReductionV src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_minI $dst, $src1, $src2\\t# minI reduction (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           ptrue, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_minL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (MinReductionV src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_minL $dst, $src1, $src2\\t# minL reduction (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           ptrue, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_minF(vRegF dst, vRegF src1, vReg src2) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (MinReductionV src1 src2));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"sve_reduce_minF $dst, $src1, $src2\\t# minF reduction (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_fminv(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src2$$reg));\n-    __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_minD(vRegD dst, vRegD src1, vReg src2) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (MinReductionV src1 src2));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"sve_reduce_minD $dst, $src1, $src2\\t# minD reduction (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_fminv(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($src2$$reg));\n-    __ fmind(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector min reduction - predicated\n-\n-instruct reduce_minI_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp,\n-                           pRegGov pg, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n-            is_integral_type(n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type()));\n-  match(Set dst (MinReductionV (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_minI $dst, $src1, $pg, $src2\\t# minI reduction predicated (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_minL_masked(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp,\n-                          pRegGov pg, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (MinReductionV (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_minL $dst, $src1, $pg, $src2\\t# minL reduction predicated (sve)\" %}\n-  ins_encode %{\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_minF_masked(vRegF dst, vRegF src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (MinReductionV (Binary src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"sve_reduce_minF $dst, $src1, $pg, $src2\\t# minF reduction predicated (sve)\" %}\n-  ins_encode %{\n-    __ sve_fminv(as_FloatRegister($dst$$reg), __ S, as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n-    __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_minD_masked(vRegD dst, vRegD src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (MinReductionV (Binary src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"sve_reduce_minD $dst, $src1, $pg, $src2\\t# minD reduction predicated (sve)\" %}\n-  ins_encode %{\n-    __ sve_fminv(as_FloatRegister($dst$$reg), __ D, as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n-    __ fmind(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector Math.rint, floor, ceil\n-\n-instruct vroundD(vReg dst, vReg src, immI rmode) %{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (RoundDoubleModeV src rmode));\n-  format %{ \"sve_frint $dst, $src, $rmode\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    switch ($rmode$$constant) {\n-      case RoundDoubleModeNode::rmode_rint:\n-        __ sve_frintn(as_FloatRegister($dst$$reg), __ D,\n-             ptrue, as_FloatRegister($src$$reg));\n-        break;\n-      case RoundDoubleModeNode::rmode_floor:\n-        __ sve_frintm(as_FloatRegister($dst$$reg), __ D,\n-             ptrue, as_FloatRegister($src$$reg));\n-        break;\n-      case RoundDoubleModeNode::rmode_ceil:\n-        __ sve_frintp(as_FloatRegister($dst$$reg), __ D,\n-             ptrue, as_FloatRegister($src$$reg));\n-        break;\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vroundFtoI(vReg dst, vReg src, vReg tmp1, vReg tmp2, vReg tmp3, pRegGov ptmp)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst (RoundVF src));\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP ptmp);\n-  format %{ \"sve_vround  $dst, S, $src\\t# round F to I vector\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    int vlen = Matcher::vector_length_in_bytes(this);\n-    if (vlen > 16) {\n-      __ vector_round_sve(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-                          as_FloatRegister($tmp1$$reg), as_FloatRegister($tmp2$$reg),\n-                          as_PRegister($ptmp$$reg), __ S);\n-    } else {\n-      __ vector_round_neon(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-                           as_FloatRegister($tmp1$$reg), as_FloatRegister($tmp2$$reg),\n-                           as_FloatRegister($tmp3$$reg),\n-                           __ esize2arrangement(type2aelembytes(bt),\n-                              \/*isQ*\/ vlen == 16));\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vroundDtoL(vReg dst, vReg src, vReg tmp1, vReg tmp2, vReg tmp3, pRegGov ptmp)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst (RoundVD src));\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP ptmp);\n-  format %{ \"sve_vround  $dst, D, $src\\t# round D to L vector\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    int vlen = Matcher::vector_length_in_bytes(this);\n-    if (vlen > 16) {\n-      __ vector_round_sve(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-                          as_FloatRegister($tmp1$$reg), as_FloatRegister($tmp2$$reg),\n-                          as_PRegister($ptmp$$reg), __ D);\n-    } else {\n-      __ vector_round_neon(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-                           as_FloatRegister($tmp1$$reg), as_FloatRegister($tmp2$$reg),\n-                           as_FloatRegister($tmp3$$reg),\n-                           __ esize2arrangement(type2aelembytes(bt),\n-                              \/*isQ*\/ vlen == 16));\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-\/\/ vector replicate\n-\n-instruct replicateB(vReg dst, iRegIorL2I src) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (ReplicateB src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_dup  $dst, $src\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ B, as_Register($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct replicateS(vReg dst, iRegIorL2I src) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (ReplicateS src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_dup  $dst, $src\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ H, as_Register($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct replicateI(vReg dst, iRegIorL2I src) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (ReplicateI src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_dup  $dst, $src\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ S, as_Register($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct replicateL(vReg dst, iRegL src) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (ReplicateL src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_dup  $dst, $src\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ D, as_Register($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct replicateB_imm8(vReg dst, immI8 con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (ReplicateB con));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_dup  $dst, $con\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ B, $con$$constant);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct replicateS_imm8(vReg dst, immI8_shift8 con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (ReplicateS con));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_dup  $dst, $con\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ H, $con$$constant);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct replicateI_imm8(vReg dst, immI8_shift8 con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (ReplicateI con));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_dup  $dst, $con\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ S, $con$$constant);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct replicateL_imm8(vReg dst, immL8_shift8 con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (ReplicateL con));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_dup  $dst, $con\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ D, $con$$constant);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct replicateF(vReg dst, vRegF src) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (ReplicateF src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_cpy  $dst, $src\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ S,\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct replicateD(vReg dst, vRegD src) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (ReplicateD src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_cpy  $dst, $src\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ D,\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector shift\n-\n-instruct vasrB(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (RShiftVB dst shift));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_asr $dst, $dst, $shift\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_asr(as_FloatRegister($dst$$reg), __ B,\n-         ptrue, as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vasrS(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (RShiftVS dst shift));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_asr $dst, $dst, $shift\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_asr(as_FloatRegister($dst$$reg), __ H,\n-         ptrue, as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vasrI(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (RShiftVI dst shift));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_asr $dst, $dst, $shift\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_asr(as_FloatRegister($dst$$reg), __ S,\n-         ptrue, as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vasrL(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (RShiftVL dst shift));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_asr $dst, $dst, $shift\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_asr(as_FloatRegister($dst$$reg), __ D,\n-         ptrue, as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlslB(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (LShiftVB dst shift));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsl $dst, $dst, $shift\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_lsl(as_FloatRegister($dst$$reg), __ B,\n-         ptrue, as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlslS(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (LShiftVS dst shift));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsl $dst, $dst, $shift\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_lsl(as_FloatRegister($dst$$reg), __ H,\n-         ptrue, as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlslI(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (LShiftVI dst shift));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsl $dst, $dst, $shift\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_lsl(as_FloatRegister($dst$$reg), __ S,\n-         ptrue, as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlslL(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (LShiftVL dst shift));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsl $dst, $dst, $shift\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_lsl(as_FloatRegister($dst$$reg), __ D,\n-         ptrue, as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlsrB(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (URShiftVB dst shift));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsr $dst, $dst, $shift\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_lsr(as_FloatRegister($dst$$reg), __ B,\n-         ptrue, as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlsrS(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (URShiftVS dst shift));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsr $dst, $dst, $shift\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_lsr(as_FloatRegister($dst$$reg), __ H,\n-         ptrue, as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlsrI(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (URShiftVI dst shift));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsr $dst, $dst, $shift\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_lsr(as_FloatRegister($dst$$reg), __ S,\n-         ptrue, as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlsrL(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (URShiftVL dst shift));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsr $dst, $dst, $shift\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_lsr(as_FloatRegister($dst$$reg), __ D,\n-         ptrue, as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vasrB_imm(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (RShiftVB src (RShiftCntV shift)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_asr $dst, $src, $shift\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    if (con == 0) {\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }\n-    if (con >= 8) con = 7;\n-    __ sve_asr(as_FloatRegister($dst$$reg), __ B,\n-         as_FloatRegister($src$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vasrS_imm(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (RShiftVS src (RShiftCntV shift)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_asr $dst, $src, $shift\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    if (con == 0) {\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }\n-    if (con >= 16) con = 15;\n-    __ sve_asr(as_FloatRegister($dst$$reg), __ H,\n-         as_FloatRegister($src$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vasrI_imm(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (RShiftVI src (RShiftCntV shift)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_asr $dst, $src, $shift\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    if (con == 0) {\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }\n-    __ sve_asr(as_FloatRegister($dst$$reg), __ S,\n-         as_FloatRegister($src$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vasrL_imm(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (RShiftVL src (RShiftCntV shift)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_asr $dst, $src, $shift\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    if (con == 0) {\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }\n-    __ sve_asr(as_FloatRegister($dst$$reg), __ D,\n-         as_FloatRegister($src$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlsrB_imm(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (URShiftVB src (RShiftCntV shift)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsr $dst, $src, $shift\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    if (con == 0) {\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }\n-    if (con >= 8) {\n-      __ sve_eor(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }\n-    __ sve_lsr(as_FloatRegister($dst$$reg), __ B,\n-         as_FloatRegister($src$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlsrS_imm(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (URShiftVS src (RShiftCntV shift)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsr $dst, $src, $shift\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    if (con == 0) {\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }\n-    if (con >= 16) {\n-      __ sve_eor(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }\n-    __ sve_lsr(as_FloatRegister($dst$$reg), __ H,\n-         as_FloatRegister($src$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlsrI_imm(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (URShiftVI src (RShiftCntV shift)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsr $dst, $src, $shift\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    if (con == 0) {\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }\n-    __ sve_lsr(as_FloatRegister($dst$$reg), __ S,\n-         as_FloatRegister($src$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlsrL_imm(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (URShiftVL src (RShiftCntV shift)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsr $dst, $src, $shift\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    if (con == 0) {\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }\n-    __ sve_lsr(as_FloatRegister($dst$$reg), __ D,\n-         as_FloatRegister($src$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlslB_imm(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (LShiftVB src (LShiftCntV shift)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsl $dst, $src, $shift\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    if (con >= 8) {\n-      __ sve_eor(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }\n-    __ sve_lsl(as_FloatRegister($dst$$reg), __ B,\n-         as_FloatRegister($src$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlslS_imm(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (LShiftVS src (LShiftCntV shift)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsl $dst, $src, $shift\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    if (con >= 16) {\n-      __ sve_eor(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }\n-    __ sve_lsl(as_FloatRegister($dst$$reg), __ H,\n-         as_FloatRegister($src$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlslI_imm(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (LShiftVI src (LShiftCntV shift)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsl $dst, $src, $shift\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    __ sve_lsl(as_FloatRegister($dst$$reg), __ S,\n-         as_FloatRegister($src$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlslL_imm(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (LShiftVL src (LShiftCntV shift)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsl $dst, $src, $shift\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    __ sve_lsl(as_FloatRegister($dst$$reg), __ D,\n-         as_FloatRegister($src$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vshiftcntB(vReg dst, iRegIorL2I cnt) %{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE));\n-  match(Set dst (LShiftCntV cnt));\n-  match(Set dst (RShiftCntV cnt));\n-  format %{ \"sve_dup $dst, $cnt\\t# vector shift count (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ B, as_Register($cnt$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vshiftcntS(vReg dst, iRegIorL2I cnt) %{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_CHAR)));\n-  match(Set dst (LShiftCntV cnt));\n-  match(Set dst (RShiftCntV cnt));\n-  format %{ \"sve_dup $dst, $cnt\\t# vector shift count (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ H, as_Register($cnt$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vshiftcntI(vReg dst, iRegIorL2I cnt) %{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n-  match(Set dst (LShiftCntV cnt));\n-  match(Set dst (RShiftCntV cnt));\n-  format %{ \"sve_dup $dst, $cnt\\t# vector shift count (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ S, as_Register($cnt$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vshiftcntL(vReg dst, iRegIorL2I cnt) %{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_LONG));\n-  match(Set dst (LShiftCntV cnt));\n-  match(Set dst (RShiftCntV cnt));\n-  format %{ \"sve_dup $dst, $cnt\\t# vector shift count (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ D, as_Register($cnt$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector shift - predicated\n-\n-instruct vasrB_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (RShiftVB (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_asr $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_asr(as_FloatRegister($dst_src1$$reg), __ B,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vasrS_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (RShiftVS (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_asr $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_asr(as_FloatRegister($dst_src1$$reg), __ H,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vasrI_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (RShiftVI (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_asr $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_asr(as_FloatRegister($dst_src1$$reg), __ S,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vasrL_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (RShiftVL (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_asr $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_asr(as_FloatRegister($dst_src1$$reg), __ D,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlslB_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (LShiftVB (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsl $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_lsl(as_FloatRegister($dst_src1$$reg), __ B,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlslS_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (LShiftVS (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsl $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_lsl(as_FloatRegister($dst_src1$$reg), __ H,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlslI_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (LShiftVI (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsl $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_lsl(as_FloatRegister($dst_src1$$reg), __ S,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlslL_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (LShiftVL (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsl $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_lsl(as_FloatRegister($dst_src1$$reg), __ D,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlsrB_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (URShiftVB (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsr $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_lsr(as_FloatRegister($dst_src1$$reg), __ B,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlsrS_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (URShiftVS (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsr $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_lsr(as_FloatRegister($dst_src1$$reg), __ H,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlsrI_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (URShiftVI (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsr $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_lsr(as_FloatRegister($dst_src1$$reg), __ S,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlsrL_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (URShiftVL (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsr $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_lsr(as_FloatRegister($dst_src1$$reg), __ D,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vasrB_imm_masked(vReg dst_src, immI shift, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (RShiftVB (Binary dst_src (RShiftCntV shift)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_asr $dst_src, $pg, $dst_src, $shift\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    assert(con > 0 && con < 8, \"invalid shift immediate\");\n-    __ sve_asr(as_FloatRegister($dst_src$$reg), __ B, as_PRegister($pg$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vasrS_imm_masked(vReg dst_src, immI shift, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (RShiftVS (Binary dst_src (RShiftCntV shift)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_asr $dst_src, $pg, $dst_src, $shift\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    assert(con > 0 && con < 16, \"invalid shift immediate\");\n-    __ sve_asr(as_FloatRegister($dst_src$$reg), __ H, as_PRegister($pg$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vasrI_imm_masked(vReg dst_src, immI shift, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (RShiftVI (Binary dst_src (RShiftCntV shift)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_asr $dst_src, $pg, $dst_src, $shift\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    assert(con > 0 && con < 32, \"invalid shift immediate\");\n-    __ sve_asr(as_FloatRegister($dst_src$$reg), __ S, as_PRegister($pg$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vasrL_imm_masked(vReg dst_src, immI shift, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (RShiftVL (Binary dst_src (RShiftCntV shift)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_asr $dst_src, $pg, $dst_src, $shift\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    assert(con > 0 && con < 64, \"invalid shift immediate\");\n-    __ sve_asr(as_FloatRegister($dst_src$$reg), __ D, as_PRegister($pg$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlsrB_imm_masked(vReg dst_src, immI shift, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (URShiftVB (Binary dst_src (RShiftCntV shift)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsr $dst_src, $pg, $dst_src, $shift\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    assert(con > 0 && con < 8, \"invalid shift immediate\");\n-    __ sve_lsr(as_FloatRegister($dst_src$$reg), __ B, as_PRegister($pg$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlsrS_imm_masked(vReg dst_src, immI shift, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (URShiftVS (Binary dst_src (RShiftCntV shift)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsr $dst_src, $pg, $dst_src, $shift\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    assert(con > 0 && con < 16, \"invalid shift immediate\");\n-    __ sve_lsr(as_FloatRegister($dst_src$$reg), __ H, as_PRegister($pg$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlsrI_imm_masked(vReg dst_src, immI shift, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (URShiftVI (Binary dst_src (RShiftCntV shift)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsr $dst_src, $pg, $dst_src, $shift\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    assert(con > 0 && con < 32, \"invalid shift immediate\");\n-    __ sve_lsr(as_FloatRegister($dst_src$$reg), __ S, as_PRegister($pg$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlsrL_imm_masked(vReg dst_src, immI shift, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (URShiftVL (Binary dst_src (RShiftCntV shift)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsr $dst_src, $pg, $dst_src, $shift\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    assert(con > 0 && con < 64, \"invalid shift immediate\");\n-    __ sve_lsr(as_FloatRegister($dst_src$$reg), __ D, as_PRegister($pg$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlslB_imm_masked(vReg dst_src, immI shift, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (LShiftVB (Binary dst_src (LShiftCntV shift)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsl $dst_src, $pg, $dst_src, $shift\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    assert(con >= 0 && con < 8, \"invalid shift immediate\");\n-    __ sve_lsl(as_FloatRegister($dst_src$$reg), __ B, as_PRegister($pg$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlslS_imm_masked(vReg dst_src, immI shift, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (LShiftVS (Binary dst_src (LShiftCntV shift)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsl $dst_src, $pg, $dst_src, $shift\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    assert(con >= 0 && con < 16, \"invalid shift immediate\");\n-    __ sve_lsl(as_FloatRegister($dst_src$$reg), __ H, as_PRegister($pg$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlslI_imm_masked(vReg dst_src, immI shift, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (LShiftVI (Binary dst_src (LShiftCntV shift)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsl $dst_src, $pg, $dst_src, $shift\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    assert(con >= 0 && con < 32, \"invalid shift immediate\");\n-    __ sve_lsl(as_FloatRegister($dst_src$$reg), __ S, as_PRegister($pg$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlslL_imm_masked(vReg dst_src, immI shift, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (LShiftVL (Binary dst_src (LShiftCntV shift)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsl $dst_src, $pg, $dst_src, $shift\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    assert(con >= 0 && con < 64, \"invalid shift immediate\");\n-    __ sve_lsl(as_FloatRegister($dst_src$$reg), __ D, as_PRegister($pg$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector sqrt\n-\n-instruct vsqrtF(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst (SqrtVF src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fsqrt $dst, $src\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fsqrt(as_FloatRegister($dst$$reg), __ S,\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vsqrtD(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst (SqrtVD src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fsqrt $dst, $src\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fsqrt(as_FloatRegister($dst$$reg), __ D,\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector sqrt - predicated\n-\n-instruct vsqrtF_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (SqrtVF dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fsqrt $dst_src, $pg, $dst_src\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fsqrt(as_FloatRegister($dst_src$$reg), __ S,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vsqrtD_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (SqrtVD dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fsqrt $dst_src, $pg, $dst_src\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fsqrt(as_FloatRegister($dst_src$$reg), __ D,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector sub\n-\n-instruct vsubB(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (SubVB src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_sub $dst, $src1, $src2\\t # vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_sub(as_FloatRegister($dst$$reg), __ B,\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vsubS(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (SubVS src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_sub $dst, $src1, $src2\\t # vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_sub(as_FloatRegister($dst$$reg), __ H,\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vsubI(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (SubVI src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_sub $dst, $src1, $src2\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_sub(as_FloatRegister($dst$$reg), __ S,\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vsubL(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (SubVL src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_sub $dst, $src1, $src2\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_sub(as_FloatRegister($dst$$reg), __ D,\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vsubF(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (SubVF src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fsub $dst, $src1, $src2\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fsub(as_FloatRegister($dst$$reg), __ S,\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vsubD(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (SubVD src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fsub $dst, $src1, $src2\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fsub(as_FloatRegister($dst$$reg), __ D,\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector sub - predicated\n-\n-instruct vsubB_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (SubVB (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_sub $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_sub(as_FloatRegister($dst_src1$$reg), __ B,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vsubS_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (SubVS (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_sub $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_sub(as_FloatRegister($dst_src1$$reg), __ H,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vsubI_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (SubVI (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_sub $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_sub(as_FloatRegister($dst_src1$$reg), __ S,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vsubL_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (SubVL (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_sub $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_sub(as_FloatRegister($dst_src1$$reg), __ D,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vsubF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (SubVF (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fsub $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fsub(as_FloatRegister($dst_src1$$reg), __ S,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vsubD_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (SubVD (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fsub $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fsub(as_FloatRegister($dst_src1$$reg), __ D,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector mask cast --------------------------\n-\n-instruct vmaskcast(pRegGov dst_src) %{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->length() == n->in(1)->bottom_type()->is_vect()->length() &&\n-            n->bottom_type()->is_vect()->length_in_bytes() == n->in(1)->bottom_type()->is_vect()->length_in_bytes());\n-  match(Set dst_src (VectorMaskCast dst_src));\n-  ins_cost(0);\n-  format %{ \"vmaskcast $dst_src\\t# empty (sve)\" %}\n-  ins_encode %{\n-    \/\/ empty\n-  %}\n-  ins_pipe(pipe_class_empty);\n-%}\n-\n-instruct vmaskcast_extend(pRegGov dst, pReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            (Matcher::vector_length_in_bytes(n) == 2 * Matcher::vector_length_in_bytes(n->in(1)) ||\n-             Matcher::vector_length_in_bytes(n) == 4 * Matcher::vector_length_in_bytes(n->in(1)) ||\n-             Matcher::vector_length_in_bytes(n) == 8 * Matcher::vector_length_in_bytes(n->in(1))));\n-  match(Set dst (VectorMaskCast src));\n-  ins_cost(SVE_COST * 3);\n-  format %{ \"sve_vmaskcast_extend  $dst, $src\\t# extend predicate $src\" %}\n-  ins_encode %{\n-    __ sve_vmaskcast_extend(as_PRegister($dst$$reg), as_PRegister($src$$reg),\n-                            Matcher::vector_length_in_bytes(this), Matcher::vector_length_in_bytes(this, $src));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmaskcast_narrow(pRegGov dst, pReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            (Matcher::vector_length_in_bytes(n) * 2 == Matcher::vector_length_in_bytes(n->in(1)) ||\n-             Matcher::vector_length_in_bytes(n) * 4 == Matcher::vector_length_in_bytes(n->in(1)) ||\n-             Matcher::vector_length_in_bytes(n) * 8 == Matcher::vector_length_in_bytes(n->in(1))));\n-  match(Set dst (VectorMaskCast src));\n-  ins_cost(SVE_COST * 3);\n-  format %{ \"sve_vmaskcast_narrow  $dst, $src\\t# narrow predicate $src\" %}\n-  ins_encode %{\n-    __ sve_vmaskcast_narrow(as_PRegister($dst$$reg), as_PRegister($src$$reg),\n-                            Matcher::vector_length_in_bytes(this), Matcher::vector_length_in_bytes(this, $src));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector cast -------------------------------\n-\n-instruct vcvtBtoX_extend(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorCastB2X src));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_vectorcast_b2x  $dst, $src\\t# convert B to X vector (extend)\" %}\n-  ins_encode %{\n-    BasicType to_bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n-    __ sve_vector_extend(as_FloatRegister($dst$$reg), to_size, as_FloatRegister($src$$reg), __ B);\n-    if (to_bt == T_FLOAT || to_bt == T_DOUBLE) {\n-      __ sve_scvtf(as_FloatRegister($dst$$reg), to_size, ptrue, as_FloatRegister($dst$$reg), to_size);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtStoB(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorCastS2X src));\n-  effect(TEMP tmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_vectorcast_s2b  $dst, $src\\t# convert H to B vector\" %}\n-  ins_encode %{\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ B,\n-                         as_FloatRegister($src$$reg), __ H, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtStoX_extend(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            type2aelembytes(Matcher::vector_element_basic_type(n)) > 2);\n-  match(Set dst (VectorCastS2X src));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_vectorcast_s2x  $dst, $src\\t# convert H to X vector (extend)\" %}\n-  ins_encode %{\n-    BasicType to_bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n-    __ sve_vector_extend(as_FloatRegister($dst$$reg), to_size, as_FloatRegister($src$$reg), __ H);\n-    if (to_bt == T_FLOAT || to_bt == T_DOUBLE) {\n-      __ sve_scvtf(as_FloatRegister($dst$$reg), to_size, ptrue, as_FloatRegister($dst$$reg), to_size);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtItoB(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorCastI2X src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_vectorcast_i2b  $dst, $src\\t# convert I to B vector\" %}\n-  ins_encode %{\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ B,\n-                         as_FloatRegister($src$$reg), __ S, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtItoS(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorCastI2X src));\n-  effect(TEMP tmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_vectorcast_i2s $dst, $src\\t# convert I to H vector\" %}\n-  ins_encode %{\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ H,\n-                         as_FloatRegister($src$$reg), __ S, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtItoL(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorCastI2X src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_vectorcast_i2l  $dst, $src\\t# convert I to L vector\" %}\n-  ins_encode %{\n-    __ sve_vector_extend(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg), __ S);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtItoF(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorCastI2X src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_vectorcast_i2f  $dst, $src\\t# convert I to F vector\" %}\n-  ins_encode %{\n-    __ sve_scvtf(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ S);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtItoD(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorCastI2X src));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_vectorcast_i2d  $dst, $src\\t# convert I to D vector\" %}\n-  ins_encode %{\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg));\n-    __ sve_scvtf(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($dst$$reg), __ D);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtLtoX_narrow(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 && is_integral_type(Matcher::vector_element_basic_type(n)));\n-  match(Set dst (VectorCastL2X src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_vectorcast_l2x  $dst, $src\\t# convert L to B\/H\/S vector (narrow)\" %}\n-  ins_encode %{\n-    BasicType to_bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), to_size,\n-                         as_FloatRegister($src$$reg), __ D, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtLtoF(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorCastL2X src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_vectorcast_l2f  $dst, $src\\t# convert L to F vector\" %}\n-  ins_encode %{\n-    __ sve_scvtf(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ D);\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ S,\n-                         as_FloatRegister($dst$$reg), __ D, as_FloatRegister($tmp$$reg));\n-\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtLtoD(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorCastL2X src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_vectorcast_l2d  $dst, $src\\t# convert L to D vector\" %}\n-  ins_encode %{\n-    __ sve_scvtf(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($src$$reg), __ D);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtFtoX_narrow(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT));\n-  match(Set dst (VectorCastF2X src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_vectorcast_f2x  $dst, $src\\t# convert F to B\/H vector\" %}\n-  ins_encode %{\n-    BasicType to_bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n-    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ S);\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), to_size,\n-                         as_FloatRegister($dst$$reg), __ S, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtFtoI(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n-  match(Set dst (VectorCastF2X src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_vectorcast_f2x  $dst, $src\\t# convert F to I vector\" %}\n-  ins_encode %{\n-    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ S);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtFtoL(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_LONG));\n-  match(Set dst (VectorCastF2X src));\n-  ins_cost(SVE_COST * 2);\n-  format %{ \"sve_vectorcast_f2x  $dst, $src\\t# convert F to L vector\" %}\n-  ins_encode %{\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg));\n-    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($dst$$reg), __ S);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtFtoD(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorCastF2X src));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_vectorcast_f2d  $dst, $dst\\t# convert F to D vector\" %}\n-  ins_encode %{\n-    __ sve_vector_extend(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg), __ S);\n-    __ sve_fcvt(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($dst$$reg), __ S);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtDtoX_narrow(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n-  match(Set dst (VectorCastD2X src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_vectorcast_d2x  $dst, $src\\t# convert D to X vector (narrow)\" %}\n-  ins_encode %{\n-    BasicType to_bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n-    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ D);\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), to_size,\n-                         as_FloatRegister($dst$$reg), __ D, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtDtoL(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorCastD2X src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_vectorcast_d2l  $dst, $src\\t# convert D to L vector\" %}\n-  ins_encode %{\n-    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($src$$reg), __ D);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtDtoF(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorCastD2X src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_vectorcast_d2f  $dst, S, $dst\\t# convert D to F vector\" %}\n-  ins_encode %{\n-    __ sve_fcvt(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ D);\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ S,\n-                         as_FloatRegister($dst$$reg), __ D, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector extract ---------------------------------\n-\n-instruct extractB(iRegINoSp dst, vReg src, immI idx, vReg vtmp)\n-%{\n-  predicate(UseSVE > 0 && n->in(2)->get_int() >= 16);\n-  match(Set dst (ExtractB src idx));\n-  effect(TEMP vtmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_extract_integral $dst, B, $src, $idx\\t# extract from vector(B)\" %}\n-  ins_encode %{\n-    __ sve_extract_integral(as_Register($dst$$reg), __ B, as_FloatRegister($src$$reg),\n-                            (int)($idx$$constant), \/* is_signed *\/ true, as_FloatRegister($vtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct extractS(iRegINoSp dst, vReg src, immI idx, vReg vtmp)\n-%{\n-  predicate(UseSVE > 0 && n->in(2)->get_int() >= 8);\n-  match(Set dst (ExtractS src idx));\n-  effect(TEMP vtmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_extract_integral $dst, H, $src, $idx\\t# extract from vector(S)\" %}\n-  ins_encode %{\n-    __ sve_extract_integral(as_Register($dst$$reg), __ H, as_FloatRegister($src$$reg),\n-                            (int)($idx$$constant), \/* is_signed *\/ true, as_FloatRegister($vtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct extractI(iRegINoSp dst, vReg src, immI idx, vReg vtmp)\n-%{\n-  predicate(UseSVE > 0 && n->in(2)->get_int() >= 4);\n-  match(Set dst (ExtractI src idx));\n-  effect(TEMP vtmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_extract_integral $dst, S, $src, $idx\\t# extract from vector(I)\" %}\n-  ins_encode %{\n-    __ sve_extract_integral(as_Register($dst$$reg), __ S, as_FloatRegister($src$$reg),\n-                            (int)($idx$$constant), \/* is_signed *\/ true, as_FloatRegister($vtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct extractL(iRegLNoSp dst, vReg src, immI idx, vReg vtmp)\n-%{\n-  predicate(UseSVE > 0 && n->in(2)->get_int() >= 2);\n-  match(Set dst (ExtractL src idx));\n-  effect(TEMP vtmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_extract_integral $dst, D, $src, $idx\\t# extract from vector(L)\" %}\n-  ins_encode %{\n-    __ sve_extract_integral(as_Register($dst$$reg), __ D, as_FloatRegister($src$$reg),\n-                            (int)($idx$$constant), \/* is_signed *\/ false, as_FloatRegister($vtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct extractB_LT16(iRegINoSp dst, vReg src, immI idx)\n-%{\n-  predicate(UseSVE > 0 && n->in(2)->get_int() < 16);\n-  match(Set dst (ExtractB src idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"smov $dst, B, $src, $idx\\t# extract from vector(B)\" %}\n-  ins_encode %{\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($src$$reg), __ B, $idx$$constant);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct extractS_LT8(iRegINoSp dst, vReg src, immI idx)\n-%{\n-  predicate(UseSVE > 0 && n->in(2)->get_int() < 8);\n-  match(Set dst (ExtractS src idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"smov $dst, H, $src, $idx\\t# extract from vector(S)\" %}\n-  ins_encode %{\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($src$$reg), __ H, $idx$$constant);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct extractI_LT4(iRegINoSp dst, vReg src, immI idx)\n-%{\n-  predicate(UseSVE > 0 && n->in(2)->get_int() < 4);\n-  match(Set dst (ExtractI src idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"smov $dst, S, $src, $idx\\t# extract from vector(I)\" %}\n-  ins_encode %{\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($src$$reg), __ S, $idx$$constant);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct extractL_LT2(iRegLNoSp dst, vReg src, immI idx)\n-%{\n-  predicate(UseSVE > 0 && n->in(2)->get_int() < 2);\n-  match(Set dst (ExtractL src idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"umov $dst, D, $src, $idx\\t# extract from vector(L)\" %}\n-  ins_encode %{\n-    __ umov(as_Register($dst$$reg), as_FloatRegister($src$$reg), __ D, $idx$$constant);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct extractF(vRegF dst, vReg src, immI idx)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst (ExtractF src idx));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_extract_f $dst, S, $src, $idx\\t# extract from vector(F)\" %}\n-  ins_encode %{\n-    if ((as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg)) && ($idx$$constant == 0)) {\n-      \/* empty *\/\n-    } else if ($idx$$constant == 0) {\n-      __ fmovs(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n-    } else if ($idx$$constant < 4) {\n-      __ ins(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg), 0, (int)($idx$$constant));\n-    } else {\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-      __ sve_ext(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), $idx$$constant << 2);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct extractD(vRegD dst, vReg src, immI idx)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst (ExtractD src idx));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_extract_d $dst, D, $src, $idx\\t# extract from vector(D)\" %}\n-  ins_encode %{\n-    if ((as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg)) && ($idx$$constant == 0)) {\n-      \/* empty *\/\n-    } else if ($idx$$constant == 0) {\n-      __ fmovd(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n-    } else if ($idx$$constant == 1) {\n-      __ ins(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg), 0, 1);\n-    } else {\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-      __ sve_ext(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), $idx$$constant << 3);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------- VectorTest ----------------------------------\n-\n-instruct vtest_alltrue(iRegINoSp dst, pRegGov src1, pRegGov src2, pReg ptmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 &&\n-            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow);\n-  match(Set dst (VectorTest src1 src2));\n-  effect(TEMP ptmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_eors $ptmp, $src1, $src2\\t# $src2 is all true mask\\n\"\n-            \"csetw $dst, EQ\\t# VectorTest (sve) - alltrue\" %}\n-  ins_encode %{\n-    __ sve_eors(as_PRegister($ptmp$$reg), ptrue,\n-                as_PRegister($src1$$reg), as_PRegister($src2$$reg));\n-    __ csetw(as_Register($dst$$reg), Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vtest_anytrue(iRegINoSp dst, pRegGov src1, pRegGov src2, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 &&\n-            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::ne);\n-  match(Set dst (VectorTest src1 src2));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_ptest $src1\\n\\t\"\n-            \"csetw $dst, NE\\t# VectorTest (sve) - anytrue\" %}\n-  ins_encode %{\n-    \/\/ \"src2\" is not used for sve.\n-    __ sve_ptest(ptrue, as_PRegister($src1$$reg));\n-    __ csetw(as_Register($dst$$reg), Assembler::NE);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\/\/ ------------------------------ Vector insert ---------------------------------\n-\n-instruct insertI_le128bits(vReg dst, vReg src, iRegIorL2I val, immI idx) %{\n-  predicate(UseSVE > 0 &&\n-            (Matcher::vector_length_in_bytes(n) == 8 || Matcher::vector_length_in_bytes(n) == 16) &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(2 * INSN_COST);\n-  format %{ \"orr    $dst, T8\/16B, $src, $src\\n\\t\"\n-            \"mov    $dst, B\/H\/S, $idx, $val\\t# insertI into vector(64\/128bits)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ orr(as_FloatRegister($dst$$reg), Matcher::vector_length_in_bytes(this) == 8 ? __ T8B : __ T16B,\n-             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    }\n-    __ mov(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(Matcher::vector_element_basic_type(this)),\n-           $idx$$constant, $val$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertI_small_index(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg vtmp, pRegGov pgtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->in(2)->get_int() < 32 &&\n-            Matcher::vector_length_in_bytes(n) > 16 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  effect(TEMP vtmp, TEMP pgtmp, KILL cr);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_index $vtmp, -16, 1\\t# (B\/H\/S)\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $vtmp, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n-            \"sve_orr $dst, $src, $src\\n\\t\"\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (B\/H\/S)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ block_comment(\"insert into vector (B\/H\/S) {\");\n-      __ sve_index(as_FloatRegister($vtmp$$reg), size, -16, 1);\n-      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), size, ptrue,\n-                 as_FloatRegister($vtmp$$reg), (int)($idx$$constant) - 16);\n-      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-      }\n-      __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pgtmp$$reg), $val$$Register);\n-    __ block_comment(\"} insert into vector (B\/H\/S)\");\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertI(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg vtmp1, vReg vtmp2, pRegGov pgtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->in(2)->get_int() >= 32 &&\n-            Matcher::vector_length_in_bytes(n) > 16 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  effect(TEMP vtmp1, TEMP vtmp2, TEMP pgtmp, KILL cr);\n-  ins_cost(5 * SVE_COST);\n-  format %{ \"sve_index $vtmp1, 0, 1\\t# (B\/H\/S)\\n\\t\"\n-            \"sve_dup $vtmp2, $idx\\t# (B\/H\/S)\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $vtmp1, $vtmp2\\n\\t\"\n-            \"sve_orr $dst, $src, $src\\n\\t\"\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (B\/H\/S)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ block_comment(\"insert into vector (B\/H\/S) {\");\n-      __ sve_index(as_FloatRegister($vtmp1$$reg), size, 0, 1);\n-      __ sve_dup(as_FloatRegister($vtmp2$$reg), size, (int)($idx$$constant));\n-      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), size, ptrue,\n-                 as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n-      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-      }\n-      __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pgtmp$$reg), $val$$Register);\n-    __ block_comment(\"} insert into vector (B\/H\/S)\");\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertL_128bits(vReg dst, vReg src, iRegL val, immI idx) %{\n-  predicate(UseSVE > 0 && Matcher::vector_length_in_bytes(n) == 16 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(2 * INSN_COST);\n-  format %{ \"orr    $dst, T16B, $src, $src\\n\\t\"\n-            \"mov    $dst, D, $idx, $val\\t# insertL into vector(128bits)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ orr(as_FloatRegister($dst$$reg), __ T16B,\n-             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    }\n-    __ mov(as_FloatRegister($dst$$reg), __ D, $idx$$constant, $val$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertL(vReg dst, vReg src, iRegL val, immI idx, vReg vtmp, pRegGov pgtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            Matcher::vector_length_in_bytes(n) > 16 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  effect(TEMP vtmp, TEMP pgtmp, KILL cr);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_index $vtmp, D, -16, 1\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $vtmp, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n-            \"sve_orr $dst, $src, $src\\n\\t\"\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (L)\" %}\n-  ins_encode %{\n-    __ block_comment(\"insert into vector (L) {\");\n-      __ sve_index(as_FloatRegister($vtmp$$reg), __ D, -16, 1);\n-      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ D, ptrue,\n-                 as_FloatRegister($vtmp$$reg), (int)($idx$$constant) - 16);\n-      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-      }\n-      __ sve_cpy(as_FloatRegister($dst$$reg), __ D,\n-                 as_PRegister($pgtmp$$reg), $val$$Register);\n-    __ block_comment(\"} insert into vector (L)\");\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertF_le128bits(vReg dst, vReg src, vRegF val, immI idx) %{\n-  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT &&\n-            (Matcher::vector_length_in_bytes(n) == 8 || Matcher::vector_length_in_bytes(n) == 16));\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(2 * INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"orr    $dst, T8\/16B, $src, $src\\n\\t\"\n-            \"ins    $dst, S, $val, $idx, 0\\t# insertF into vector(64\/128bits)\" %}\n-  ins_encode %{\n-    __ orr(as_FloatRegister($dst$$reg), Matcher::vector_length_in_bytes(this) == 8 ? __ T8B : __ T16B,\n-           as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ ins(as_FloatRegister($dst$$reg), __ S,\n-           as_FloatRegister($val$$reg), $idx$$constant, 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertF_small_index(vReg dst, vReg src, vRegF val, immI idx, pRegGov pgtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->in(2)->get_int() < 32 &&\n-            Matcher::vector_length_in_bytes(n) > 16 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_index $dst, S, -16, 1\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n-            \"sve_orr $dst, $src, $src\\n\\t\"\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (F)\" %}\n-  ins_encode %{\n-    __ block_comment(\"insert into vector (F) {\");\n-      __ sve_index(as_FloatRegister($dst$$reg), __ S, -16, 1);\n-      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ S, ptrue,\n-                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-      __ sve_cpy(as_FloatRegister($dst$$reg), __ S, as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n-    __ block_comment(\"} insert into vector (F)\");\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertF(vReg dst, vReg src, vRegF val, immI idx, vReg tmp1, pRegGov pgtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->in(2)->get_int() >= 32 &&\n-            Matcher::vector_length_in_bytes(n) > 16 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP pgtmp, KILL cr);\n-  ins_cost(5 * SVE_COST);\n-  format %{ \"sve_index $tmp1, S, 0, 1\\n\\t\"\n-            \"sve_dup $dst, S, $idx\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $tmp1, $dst\\n\\t\"\n-            \"sve_orr $dst, $src, $src\\n\\t\"\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (F)\" %}\n-  ins_encode %{\n-    __ block_comment(\"insert into vector (F) {\");\n-      __ sve_index(as_FloatRegister($tmp1$$reg), __ S, 0, 1);\n-      __ sve_dup(as_FloatRegister($dst$$reg), __ S, (int)($idx$$constant));\n-      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ S, ptrue,\n-                 as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-                 as_FloatRegister($src$$reg));\n-      __ sve_cpy(as_FloatRegister($dst$$reg), __ S,\n-                 as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n-    __ block_comment(\"} insert into vector (F)\");\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertD_128bits(vReg dst, vReg src, vRegD val, immI idx) %{\n-  predicate(UseSVE > 0 && Matcher::vector_length_in_bytes(n) == 16 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(2 * INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"orr    $dst, T16B, $src, $src\\n\\t\"\n-            \"ins    $dst, D, $val, $idx, 0\\t# insertD into vector(128bits)\" %}\n-  ins_encode %{\n-    __ orr(as_FloatRegister($dst$$reg), __ T16B,\n-           as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ ins(as_FloatRegister($dst$$reg), __ D,\n-           as_FloatRegister($val$$reg), $idx$$constant, 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertD(vReg dst, vReg src, vRegD val, immI idx, pRegGov pgtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            Matcher::vector_length_in_bytes(n) > 16 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_index $dst, D, -16, 1\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n-            \"sve_orr $dst, $src, $src\\n\\t\"\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (D)\" %}\n-  ins_encode %{\n-    __ block_comment(\"insert into vector (D) {\");\n-      __ sve_index(as_FloatRegister($dst$$reg), __ D, -16, 1);\n-      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ D, ptrue,\n-                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-                 as_FloatRegister($src$$reg));\n-      __ sve_cpy(as_FloatRegister($dst$$reg), __ D,\n-                 as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n-    __ block_comment(\"} insert into vector (D)\");\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector shuffle -------------------------------\n-\n-instruct loadshuffle(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorLoadShuffle src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_loadshuffle $dst, $src\\t# vector load shuffle (B\/H\/S\/D)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    if (bt == T_BYTE) {\n-      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-                   as_FloatRegister($src$$reg));\n-      }\n-    } else {\n-      __ sve_vector_extend(as_FloatRegister($dst$$reg),  __ elemType_to_regVariant(bt),\n-                           as_FloatRegister($src$$reg), __ B);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector rearrange -------------------------------\n-\n-instruct rearrange(vReg dst, vReg src, vReg shuffle)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorRearrange src shuffle));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_tbl $dst, $src, $shuffle\\t# vector rearrange\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_tbl(as_FloatRegister($dst$$reg), size,\n-               as_FloatRegister($src$$reg), as_FloatRegister($shuffle$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector Load Gather ---------------------------------\n-\n-instruct gatherI(vReg dst, indirect mem, vReg idx) %{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n-  match(Set dst (LoadVectorGather mem idx));\n-  ins_cost(SVE_COST);\n-  format %{ \"load_vector_gather $dst, $mem, $idx\\t# vector load gather (S)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_ld1w_gather(as_FloatRegister($dst$$reg), ptrue,\n-                       as_Register($mem$$base), as_FloatRegister($idx$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct gatherL(vReg dst, indirect mem, vReg idx, vReg tmp) %{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n-  match(Set dst (LoadVectorGather mem idx));\n-  effect(TEMP tmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"load_vector_gather $dst, $mem, $idx\\t# vector load gather (D)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_uunpklo(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($idx$$reg));\n-    __ sve_ld1d_gather(as_FloatRegister($dst$$reg), ptrue, as_Register($mem$$base),\n-                       as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector Load Gather Predicated -------------------------------\n-\n-instruct gatherI_masked(vReg dst, indirect mem, vReg idx, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx pg)));\n-  ins_cost(SVE_COST);\n-  format %{ \"load_vector_gather $dst, $pg, $mem, $idx\\t# vector load gather predicated (S)\" %}\n-  ins_encode %{\n-    __ sve_ld1w_gather(as_FloatRegister($dst$$reg), as_PRegister($pg$$reg),\n-                       as_Register($mem$$base), as_FloatRegister($idx$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct gatherL_masked(vReg dst, indirect mem, vReg idx, pRegGov pg, vReg tmp) %{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx pg)));\n-  effect(TEMP tmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"load_vector_gather $dst, $pg, $mem, $idx\\t# vector load gather predicated (D)\" %}\n-  ins_encode %{\n-    __ sve_uunpklo(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($idx$$reg));\n-    __ sve_ld1d_gather(as_FloatRegister($dst$$reg), as_PRegister($pg$$reg),\n-                       as_Register($mem$$base), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector Store Scatter -------------------------------\n-\n-instruct scatterI(indirect mem, vReg src, vReg idx) %{\n-  predicate(UseSVE > 0 &&\n-            (n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-             n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n-  match(Set mem (StoreVectorScatter mem (Binary src idx)));\n-  ins_cost(SVE_COST);\n-  format %{ \"store_vector_scatter $mem, $idx, $src\\t# vector store scatter (S)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_st1w_scatter(as_FloatRegister($src$$reg), ptrue,\n-                        as_Register($mem$$base), as_FloatRegister($idx$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct scatterL(indirect mem, vReg src, vReg idx, vReg tmp) %{\n-  predicate(UseSVE > 0 &&\n-            (n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n-             n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n-  match(Set mem (StoreVectorScatter mem (Binary src idx)));\n-  effect(TEMP tmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"store_vector_scatter $mem, $idx, $src\\t# vector store scatter (D)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_uunpklo(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($idx$$reg));\n-    __ sve_st1d_scatter(as_FloatRegister($src$$reg), ptrue,\n-                        as_Register($mem$$base), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector Store Scatter Predicated -------------------------------\n-\n-instruct scatterI_masked(indirect mem, vReg src, vReg idx, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            (n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-             n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n-  match(Set mem (StoreVectorScatterMasked mem (Binary src (Binary idx pg))));\n-  ins_cost(SVE_COST);\n-  format %{ \"store_vector_scatter $mem, $pg, $idx, $src\\t# vector store scatter predicate (S)\" %}\n-  ins_encode %{\n-    __ sve_st1w_scatter(as_FloatRegister($src$$reg), as_PRegister($pg$$reg),\n-                        as_Register($mem$$base), as_FloatRegister($idx$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct scatterL_masked(indirect mem, vReg src, vReg idx, pRegGov pg, vReg tmp) %{\n-  predicate(UseSVE > 0 &&\n-            (n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n-             n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n-  match(Set mem (StoreVectorScatterMasked mem (Binary src (Binary idx pg))));\n-  effect(TEMP tmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"store_vector_scatter $mem, $pg, $idx, $src\\t# vector store scatter predicated (D)\" %}\n-  ins_encode %{\n-    __ sve_uunpklo(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($idx$$reg));\n-    __ sve_st1d_scatter(as_FloatRegister($src$$reg), as_PRegister($pg$$reg),\n-                        as_Register($mem$$base), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector Load Const -------------------------------\n-\n-instruct loadconB(vReg dst, immI0 src) %{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorLoadConst src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_index $dst, 0, 1\\t# generate iota indices\" %}\n-  ins_encode %{\n-    __ sve_index(as_FloatRegister($dst$$reg), __ B, 0, 1);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ -------------------------- Populate Index to a Vector --------------------------\n-\n-instruct populateindex(vReg dst, iRegIorL2I src1, immI src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (PopulateIndex src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_index $dst, $src1, $src2\\t # populate index (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_index(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(bt),\n-                 as_Register($src1$$reg), $src2$$constant);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ----------------------------- String Intrinsics -------------------------------\n-\n-\/\/ Intrisics for String.indexOf(char)\n-\n-\n-instruct stringL_indexof_char_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegI_R3 ch,\n-                                  iRegI_R0 result, vReg ztmp1, vReg ztmp2,\n-                                  pRegGov pgtmp, pReg ptmp, rFlagsReg cr)\n-%{\n-  match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));\n-  predicate((UseSVE > 0) && (((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::L));\n-  effect(TEMP ztmp1, TEMP ztmp2, TEMP pgtmp, TEMP ptmp, KILL cr);\n-\n-  format %{ \"StringLatin1 IndexOf char[] $str1,$cnt1,$ch -> $result # use sve\" %}\n-\n-  ins_encode %{\n-    __ string_indexof_char_sve($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,\n-                               as_FloatRegister($ztmp1$$reg), as_FloatRegister($ztmp2$$reg),\n-                               as_PRegister($pgtmp$$reg), as_PRegister($ptmp$$reg), true \/* isL *\/);\n-  %}\n-  ins_pipe(pipe_class_memory);\n-%}\n-\n-instruct stringU_indexof_char_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegI_R3 ch,\n-                                  iRegI_R0 result, vReg ztmp1, vReg ztmp2,\n-                                  pRegGov pgtmp, pReg ptmp, rFlagsReg cr)\n-%{\n-  match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));\n-  predicate((UseSVE > 0) && (((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::U));\n-  effect(TEMP ztmp1, TEMP ztmp2, TEMP pgtmp, TEMP ptmp, KILL cr);\n-\n-  format %{ \"StringUTF16 IndexOf char[] $str1,$cnt1,$ch -> $result # use sve\" %}\n-\n-  ins_encode %{\n-    __ string_indexof_char_sve($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,\n-                               as_FloatRegister($ztmp1$$reg), as_FloatRegister($ztmp2$$reg),\n-                               as_PRegister($pgtmp$$reg), as_PRegister($ptmp$$reg), false \/* isL *\/);\n-  %}\n-  ins_pipe(pipe_class_memory);\n-%}\n-\n-\/\/ Intrisics for String.compareTo()\n-\n-\/\/ Note that Z registers alias the corresponding NEON registers, we declare the vector operands of\n-\/\/ these string_compare variants as NEON register type for convenience so that the prototype of\n-\/\/ string_compare can be shared with all variants.\n-\n-\n-instruct string_compareLL_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n-                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n-                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n-                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n-%{\n-  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL));\n-  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n-  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n-         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n-\n-  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n-  ins_encode %{\n-    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n-    __ string_compare($str1$$Register, $str2$$Register,\n-                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n-                      $tmp1$$Register, $tmp2$$Register,\n-                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n-                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n-                      StrIntrinsicNode::LL);\n-  %}\n-  ins_pipe(pipe_class_memory);\n-%}\n-\n-instruct string_compareLU_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n-                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n-                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n-                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n-%{\n-  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU));\n-  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n-  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n-         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n-\n-  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n-  ins_encode %{\n-    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n-    __ string_compare($str1$$Register, $str2$$Register,\n-                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n-                      $tmp1$$Register, $tmp2$$Register,\n-                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n-                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n-                      StrIntrinsicNode::LU);\n-  %}\n-  ins_pipe(pipe_class_memory);\n-%}\n-\n-instruct string_compareUL_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n-                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n-                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n-                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n-%{\n-  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL));\n-  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n-  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n-         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n-\n-  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n-  ins_encode %{\n-    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n-    __ string_compare($str1$$Register, $str2$$Register,\n-                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n-                      $tmp1$$Register, $tmp2$$Register,\n-                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n-                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n-                      StrIntrinsicNode::UL);\n-  %}\n-  ins_pipe(pipe_class_memory);\n-%}\n-\n-instruct string_compareUU_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n-                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n-                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n-                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n-%{\n-  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU));\n-  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n-  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n-         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n-\n-  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n-  ins_encode %{\n-    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n-    __ string_compare($str1$$Register, $str2$$Register,\n-                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n-                      $tmp1$$Register, $tmp2$$Register,\n-                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n-                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n-                      StrIntrinsicNode::UU);\n-  %}\n-  ins_pipe(pipe_class_memory);\n-%}\n-\n-\/\/ ---------------------------- Vector mask reductions ---------------------------\n-instruct vmask_truecount(iRegINoSp dst, pReg src) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorMaskTrueCount src));\n-  ins_cost(SVE_COST);\n-  format %{ \"vmask_truecount $dst, $src\\t# vector mask truecount (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_cntp($dst$$Register, size, ptrue, as_PRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Return the index of the first mask lane that is set, or vector length if none of\n-\/\/ them are set.\n-instruct vmask_firsttrue(iRegINoSp dst, pReg src, pReg ptmp) %{\n-  predicate(UseSVE > 0 && !n->is_predicated_vector());\n-  match(Set dst (VectorMaskFirstTrue src));\n-  effect(TEMP ptmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"vmask_firsttrue $dst, $src\\t# vector mask firsttrue (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src) == MaxVectorSize, \"invalid vector length\");\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_brkb(as_PRegister($ptmp$$reg), ptrue, as_PRegister($src$$reg), false);\n-    __ sve_cntp($dst$$Register, size, ptrue, as_PRegister($ptmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_firsttrue_masked(iRegINoSp dst, pReg src, pRegGov pg, pReg ptmp) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorMaskFirstTrue src pg));\n-  effect(TEMP ptmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"vmask_firsttrue $dst, $pg, $src\\t# vector mask firsttrue (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_brkb(as_PRegister($ptmp$$reg), as_PRegister($pg$$reg), as_PRegister($src$$reg), false);\n-    __ sve_cntp($dst$$Register, size, ptrue, as_PRegister($ptmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_lasttrue(iRegINoSp dst, pReg src, pReg ptmp) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorMaskLastTrue src));\n-  effect(TEMP ptmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"vmask_lasttrue $dst, $src\\t# vector mask lasttrue (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    __ sve_vmask_lasttrue($dst$$Register, bt, as_PRegister($src$$reg), as_PRegister($ptmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_tolong(iRegLNoSp dst, pReg src, vReg vtmp1, vReg vtmp2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorMaskToLong src));\n-  effect(TEMP vtmp1, TEMP vtmp2);\n-  ins_cost(13 * SVE_COST);\n-  format %{ \"vmask_tolong $dst, $src\\t# vector mask tolong (sve)\" %}\n-  ins_encode %{\n-    __ sve_vmask_tolong(as_Register($dst$$reg), as_PRegister($src$$reg),\n-                        Matcher::vector_element_basic_type(this, $src),\n-                        Matcher::vector_length(this, $src),\n-                        as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_fromlong(pRegGov dst, iRegL src, vReg vtmp1, vReg vtmp2) %{\n-  match(Set dst (VectorLongToMask src));\n-  effect(TEMP vtmp1, TEMP vtmp2);\n-  ins_cost(10 * SVE_COST);\n-  format %{ \"vmask_fromlong $dst, $src\\t# vector mask fromlong (sve2)\" %}\n-  ins_encode %{\n-    __ sve_vmask_fromlong(as_PRegister($dst$$reg), as_Register($src$$reg),\n-                          Matcher::vector_element_basic_type(this),\n-                          Matcher::vector_length(this),\n-                          as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ---------------------------- Vector mask generation ---------------------------\n-\/\/ The rules below set predicate registers. They can guarantee the high bits of dst\n-\/\/ are cleared with zero when the vector length is less than the full size of\n-\/\/ hardware vector register width.\n-\n-\n-\/\/ maskAll\n-\n-instruct vmaskAll_immI(pRegGov dst, immI src, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (MaskAll src));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_ptrue\/sve_pfalse $dst\\t# mask all (sve) (B\/H\/S)\" %}\n-  ins_encode %{\n-    int con = (int)$src$$constant;\n-    if (con == 0) {\n-      __ sve_pfalse(as_PRegister($dst$$reg));\n-    } else {\n-      assert(con == -1, \"invalid constant value for mask\");\n-      BasicType bt = Matcher::vector_element_basic_type(this);\n-      __ sve_gen_mask_imm(as_PRegister($dst$$reg), bt, Matcher::vector_length(this));\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vmaskAllI(pRegGov dst, iRegIorL2I src, vReg tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && !n->is_predicated_vector());\n-  match(Set dst (MaskAll src));\n-  effect(TEMP tmp, KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_dup $tmp, $src\\n\\t\"\n-            \"sve_cmpne $dst, $dst, $tmp, 0\\t# mask all (sve) (B\/H\/S)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this) == MaxVectorSize, \"invalid vector length\");\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_dup(as_FloatRegister($tmp$$reg), size, as_Register($src$$reg));\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($tmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmaskAll_immL(pRegGov dst, immL src, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (MaskAll src));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_ptrue\/sve_pfalse $dst\\t# mask all (sve) (D)\" %}\n-  ins_encode %{\n-    long con = (long)$src$$constant;\n-    if (con == 0) {\n-      __ sve_pfalse(as_PRegister($dst$$reg));\n-    } else {\n-      assert(con == -1, \"invalid constant value for mask\");\n-      BasicType bt = Matcher::vector_element_basic_type(this);\n-      __ sve_gen_mask_imm(as_PRegister($dst$$reg), bt, Matcher::vector_length(this));\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vmaskAllL(pRegGov dst, iRegL src, vReg tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && !n->is_predicated_vector());\n-  match(Set dst (MaskAll src));\n-  effect(TEMP tmp, KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_dup $tmp, $src\\n\\t\"\n-            \"sve_cmpne $dst, $dst, $tmp, 0\\t# mask all (sve) (D)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this) == MaxVectorSize, \"invalid vector length\");\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_dup(as_FloatRegister($tmp$$reg), size, as_Register($src$$reg));\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($tmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ maskAll - predicated\n-\n-instruct vmaskAllI_masked(pRegGov dst, iRegIorL2I src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (MaskAll src pg));\n-  effect(TEMP tmp, KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_dup $tmp, $src\\n\\t\"\n-            \"sve_cmpne $dst, $pg, $dst, $tmp, 0\\t# mask all (sve) (B\/H\/S)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_dup(as_FloatRegister($tmp$$reg), size, as_Register($src$$reg));\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size,\n-               as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmaskAllL_masked(pRegGov dst, iRegL src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (MaskAll src pg));\n-  effect(TEMP tmp, KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_dup $tmp, $src\\n\\t\"\n-            \"sve_cmpne $dst, $pg, $dst, $tmp, 0\\t# mask all (sve) (D)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_dup(as_FloatRegister($tmp$$reg), size, as_Register($src$$reg));\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size,\n-               as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector mask compare\n-\n-instruct vmaskcmp(pRegGov dst, vReg src1, vReg src2, immI cond, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_cmp $dst, $src1, $src2\\t# vector mask cmp (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this) == MaxVectorSize, \"invalid vector length\");\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_compare(as_PRegister($dst$$reg), bt, ptrue, as_FloatRegister($src1$$reg),\n-                   as_FloatRegister($src2$$reg), (int)$cond$$constant);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmaskcmp_masked(pRegGov dst, vReg src1, vReg src2, immI cond, pRegGov pg, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) (Binary cond pg)));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_cmp $dst, $pg, $src1, $src2\\t# vector mask cmp (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_compare(as_PRegister($dst$$reg), bt, as_PRegister($pg$$reg), as_FloatRegister($src1$$reg),\n-                   as_FloatRegister($src2$$reg), (int)$cond$$constant);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector load mask\n-\n-instruct vloadmaskB(pRegGov dst, vReg src, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && !n->is_predicated_vector() &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorLoadMask src));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"vloadmaskB $dst, $src\\t# vector load mask (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ B,\n-               ptrue, as_FloatRegister($src$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vloadmask_extend(pRegGov dst, vReg src, vReg tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && !n->is_predicated_vector() &&\n-            n->bottom_type()->is_vect()->element_basic_type() != T_BYTE);\n-  match(Set dst (VectorLoadMask src));\n-  effect(TEMP tmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"vloadmask $dst, $src\\t# vector load mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_vector_extend(as_FloatRegister($tmp$$reg), size, as_FloatRegister($src$$reg), __ B);\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($tmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vloadmaskB_masked(pRegGov dst, vReg src, pRegGov pg, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorLoadMask src pg));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"vloadmaskB $dst, $pg, $src\\t# vector load mask (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ B,\n-               as_PRegister($pg$$reg), as_FloatRegister($src$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vloadmask_extend_masked(pRegGov dst, vReg src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() != T_BYTE);\n-  match(Set dst (VectorLoadMask src pg));\n-  effect(TEMP tmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"vloadmask $dst, $pg, $src\\t# vector load mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_vector_extend(as_FloatRegister($tmp$$reg), size, as_FloatRegister($src$$reg), __ B);\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size,\n-               as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector mask gen\n-\n-instruct vmask_gen_I(pRegGov pd, iRegIorL2I src, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set pd (VectorMaskGen (ConvI2L src)));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_whilelow $pd, zr, $src\\t# vector mask gen (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_whilelow(as_PRegister($pd$$reg), size, zr, as_Register($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vmask_gen_L(pRegGov pd, iRegL src, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set pd (VectorMaskGen src));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_whilelo $pd, zr, $src\\t# vector mask gen (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_whilelo(as_PRegister($pd$$reg), size, zr, as_Register($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vmask_gen_imm(pRegGov pd, immL src, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set pd (VectorMaskGen src));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"vmask_gen_imm $pd, $src\\t# vector mask gen with imm (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_gen_mask_imm(as_PRegister($pd$$reg), bt, (uint) $src$$constant);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-\/\/ ---------------------------- Compress\/Expand Operations ---------------------------\n-\n-instruct mcompress(pReg dst, pReg pg, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (CompressM pg));\n-  effect(KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_cntp rscratch1, $pg\\n\\t\"\n-            \"sve_whilelo $dst, zr, rscratch1\\t# mask compress (B\/H\/S\/D)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_cntp(rscratch1, size, ptrue, as_PRegister($pg$$reg));\n-    __ sve_whilelo(as_PRegister($dst$$reg), size, zr, rscratch1);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcompress(vReg dst, vReg src, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n-  match(Set dst (CompressV src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_compact $dst, $src, $pg\\t# vector compress (S\/D)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_compact(as_FloatRegister($dst$$reg), size, as_FloatRegister($src$$reg), as_PRegister($pg$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcompressB(vReg dst, vReg src, pReg pg, vReg vtmp1, vReg vtmp2, vReg vtmp3, vReg vtmp4,\n-                    pReg ptmp, pRegGov pgtmp) %{\n-  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP vtmp3, TEMP vtmp4, TEMP ptmp, TEMP pgtmp);\n-  match(Set dst (CompressV src pg));\n-  ins_cost(13 * SVE_COST);\n-  format %{ \"sve_compact $dst, $src, $pg\\t# vector compress (B)\" %}\n-  ins_encode %{\n-    __ sve_compress_byte(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_PRegister($pg$$reg),\n-                         as_FloatRegister($vtmp1$$reg),as_FloatRegister($vtmp2$$reg),\n-                         as_FloatRegister($vtmp3$$reg),as_FloatRegister($vtmp4$$reg),\n-                         as_PRegister($ptmp$$reg), as_PRegister($pgtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcompressS(vReg dst, vReg src, pReg pg, vReg vtmp1, vReg vtmp2, pRegGov pgtmp) %{\n-  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp);\n-  match(Set dst (CompressV src pg));\n-  ins_cost(38 * SVE_COST);\n-  format %{ \"sve_compact $dst, $src, $pg\\t# vector compress (H)\" %}\n-  ins_encode %{\n-    __ sve_compress_short(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_PRegister($pg$$reg),\n-                          as_FloatRegister($vtmp1$$reg),as_FloatRegister($vtmp2$$reg), as_PRegister($pgtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vexpand(vReg dst, vReg src, pRegGov pg) %{\n-  match(Set dst (ExpandV src pg));\n-  effect(TEMP_DEF dst);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_dup $dst, S\/D, 0\\n\\t\"\n-            \"sve_histcnt $dst, S\/D, $pg, $dst, $dst\\n\\t\"\n-            \"sve_sub $dst, S\/D, 1\\n\\t\"\n-            \"sve_tbl $dst, S\/D, $src, $dst\\t# vector expand (S\/D)\" %}\n-  ins_encode %{\n-    \/\/ Example input:   src   = 1 2 3 4 5 6 7 8\n-    \/\/                  pg    = 1 0 0 1 1 0 1 1\n-    \/\/ Expected result: dst   = 4 0 0 5 6 0 7 8\n-\n-    \/\/ The basic idea is to use TBL which can shuffle the elements in the given\n-    \/\/ vector flexibly. HISTCNT + SUB is used to generate the second source input\n-    \/\/ for TBL whose value is used to select the indexed element from src vector.\n-\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    assert(UseSVE == 2 && !is_subword_type(bt), \"unsupported\");\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    \/\/ dst = 0 0 0 0 0 0 0 0\n-    __ sve_dup(as_FloatRegister($dst$$reg), size, 0);\n-    \/\/ dst = 5 0 0 4 3 0 2 1\n-    __ sve_histcnt(as_FloatRegister($dst$$reg), size, as_PRegister($pg$$reg),\n-                   as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg));\n-    \/\/ dst = 4 -1 -1 3 2 -1 1 0\n-    __ sve_sub(as_FloatRegister($dst$$reg), size, 1);\n-    \/\/ dst = 4 0 0 5 6 0 7 8\n-    __ sve_tbl(as_FloatRegister($dst$$reg), size, as_FloatRegister($src$$reg),\n-               as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ CountLeadingZerosV ------------------------------\n-\n-instruct vcountLeadingZeros(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst (CountLeadingZerosV src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_clz $dst, $src\\t# vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_clz(as_FloatRegister($dst$$reg), size, ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ The dst and src should use the same register to make sure the\n-\/\/ inactive lanes in dst save the same elements as src.\n-instruct vcountLeadingZeros_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (CountLeadingZerosV dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_clz $dst_src, $pg, $dst_src\\t# vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_clz(as_FloatRegister($dst_src$$reg), size,\n-        as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ CountTrailingZerosV -----------------------------\n-\n-instruct vcountTrailingZeros(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst (CountTrailingZerosV src));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_rbit $dst, $src\\n\\t\"\n-            \"sve_clz  $dst, $dst\\t# vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_rbit(as_FloatRegister($dst$$reg), size, ptrue, as_FloatRegister($src$$reg));\n-    __ sve_clz(as_FloatRegister($dst$$reg), size, ptrue, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ The dst and src should use the same register to make sure the\n-\/\/ inactive lanes in dst save the same elements as src.\n-instruct vcountTrailingZeros_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (CountTrailingZerosV dst_src pg));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_rbit $dst_src, $pg, $dst_src\\n\\t\"\n-            \"sve_clz  $dst_src, $pg, $dst_src\\t# vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_rbit(as_FloatRegister($dst_src$$reg), size,\n-        as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n-    __ sve_clz(as_FloatRegister($dst_src$$reg), size,\n-        as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ---------------------------------- ReverseV ------------------------------------\n-\n-instruct vreverse(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst (ReverseV src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_rbit $dst, $src\\t# vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_rbit(as_FloatRegister($dst$$reg), size, ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ The dst and src should use the same register to make sure the\n-\/\/ inactive lanes in dst save the same elements as src.\n-instruct vreverse_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (ReverseV dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_rbit $dst_src, $pg, $dst_src\\t# vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_rbit(as_FloatRegister($dst_src$$reg), size,\n-        as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ -------------------------------- ReverseBytesV ---------------------------------\n-\n-instruct vreverseBytes(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst (ReverseBytesV src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_revb $dst, $src\\t# vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    if (bt == T_BYTE) {\n-      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-      }\n-    } else {\n-      __ sve_revb(as_FloatRegister($dst$$reg), size, ptrue, as_FloatRegister($src$$reg));\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ The dst and src should use the same register to make sure the\n-\/\/ inactive lanes in dst save the same elements as src.\n-instruct vreverseBytes_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (ReverseBytesV dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_revb $dst_src, $pg, $dst_src\\t# vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    if (bt == T_BYTE) {\n-      \/\/ do nothing\n-    } else {\n-      __ sve_revb(as_FloatRegister($dst_src$$reg), size,\n-          as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":0,"deletions":5922,"binary":false,"changes":5922,"status":"deleted"},{"patch":"@@ -1,3470 +0,0 @@\n-\/\/\n-\/\/ Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n-\/\/ Copyright (c) 2020, 2022, Arm Limited. All rights reserved.\n-\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\/\/\n-\/\/ This code is free software; you can redistribute it and\/or modify it\n-\/\/ under the terms of the GNU General Public License version 2 only, as\n-\/\/ published by the Free Software Foundation.\n-\/\/\n-\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n-\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-\/\/ version 2 for more details (a copy is included in the LICENSE file that\n-\/\/ accompanied this code).\n-\/\/\n-\/\/ You should have received a copy of the GNU General Public License version\n-\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n-\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\/\/\n-\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-\/\/ or visit www.oracle.com if you need additional information or have any\n-\/\/ questions.\n-\/\/\n-\/\/\n-\n-dnl Generate the warning\n-\/\/ This file is automatically generated by running \"m4 aarch64_sve_ad.m4\". Do not edit ----\n-dnl\n-\n-\/\/ AArch64 SVE Architecture Description File\n-\n-dnl\n-define(`TYPE2DATATYPE',\n-`ifelse($1, `B', `BYTE',\n-        $1, `S', `SHORT',\n-        $1, `I', `INT',\n-        $1, `L', `LONG',\n-        $1, `F', `FLOAT',\n-        $1, `D', `DOUBLE',\n-        `error($1)')')dnl\n-dnl\n-dnl OPERAND_VMEMORYA_IMMEDIATE_OFFSET($1,            $2,       $3       $4   )\n-dnl OPERAND_VMEMORYA_IMMEDIATE_OFFSET(imm_type_abbr, imm_type, imm_len, scale)\n-define(`OPERAND_VMEMORYA_IMMEDIATE_OFFSET', `\n-operand vmemA_imm$1Offset$3()\n-%{\n-  \/\/ (esize \/ msize) = $4\n-  predicate(Address::offset_ok_for_sve_immed(n->get_$2(), $3,\n-            Matcher::scalable_vector_reg_size(T_BYTE)ifelse($4, `1', `', ` \/ $4')));\n-  match(Con$1);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}')dnl\n-\n-\/\/ 4 bit signed offset -- for predicated load\/store\n-OPERAND_VMEMORYA_IMMEDIATE_OFFSET(I, int,  4, 1)\n-OPERAND_VMEMORYA_IMMEDIATE_OFFSET(L, long, 4, 1)\n-dnl\n-dnl OPERAND_VMEMORYA_INDIRECT_OFFSET($1,            $2     )\n-dnl OPERAND_VMEMORYA_INDIRECT_OFFSET(imm_type_abbr, imm_len)\n-define(`OPERAND_VMEMORYA_INDIRECT_OFFSET', `\n-operand vmemA_indOff$1$2$3(iRegP reg, vmemA_imm$1Offset$2 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    `index'(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}')dnl\n-OPERAND_VMEMORYA_INDIRECT_OFFSET(I, 4)\n-OPERAND_VMEMORYA_INDIRECT_OFFSET(L, 4)\n-\n-\/\/ The indOff of vmemA is valid only when the vector element (load to\/store from)\n-\/\/ size equals to memory element (load from\/store to) size.\n-opclass vmemA(indirect, vmemA_indOffI4, vmemA_indOffL4);\n-\n-source_hpp %{\n-  bool op_sve_supported(int opcode, int vlen, BasicType bt);\n-  bool masked_op_sve_supported(int opcode, int vlen, BasicType bt);\n-  bool partial_op_sve_needed(Node* node, const TypeVect* vt);\n-%}\n-\n-source %{\n-\n-  typedef void (C2_MacroAssembler::* sve_mem_insn_predicate)(FloatRegister Rt, Assembler::SIMD_RegVariant T,\n-                                                             PRegister Pg, const Address &adr);\n-\n-  \/\/ Predicated load\/store, with optional ptrue to all elements of given predicate register.\n-  static void loadStoreA_predicated(C2_MacroAssembler masm, bool is_store, FloatRegister reg,\n-                                    PRegister pg, BasicType mem_elem_bt, BasicType vector_elem_bt,\n-                                    int opcode, Register base, int index, int size, int disp) {\n-    sve_mem_insn_predicate insn;\n-    int mesize = type2aelembytes(mem_elem_bt);\n-    if (index == -1) {\n-      assert(size == 0, \"unsupported address mode: scale size = %d\", size);\n-      switch(mesize) {\n-      case 1:\n-        insn = is_store ? &C2_MacroAssembler::sve_st1b : &C2_MacroAssembler::sve_ld1b;\n-        break;\n-      case 2:\n-        insn = is_store ? &C2_MacroAssembler::sve_st1h : &C2_MacroAssembler::sve_ld1h;\n-        break;\n-      case 4:\n-        insn = is_store ? &C2_MacroAssembler::sve_st1w : &C2_MacroAssembler::sve_ld1w;\n-        break;\n-      case 8:\n-        insn = is_store ? &C2_MacroAssembler::sve_st1d : &C2_MacroAssembler::sve_ld1d;\n-        break;\n-      default:\n-        assert(false, \"unsupported\");\n-        ShouldNotReachHere();\n-      }\n-      int imm4 = disp \/ mesize \/ Matcher::scalable_vector_reg_size(vector_elem_bt);\n-      (masm.*insn)(reg, Assembler::elemType_to_regVariant(vector_elem_bt), pg, Address(base, imm4));\n-    } else {\n-      assert(false, \"unimplemented\");\n-      ShouldNotReachHere();\n-    }\n-  }\n-\n-  bool op_sve_supported(int opcode, int vlen, BasicType bt) {\n-    int length_in_bytes = vlen * type2aelembytes(bt);\n-    switch (opcode) {\n-      case Op_MulAddVS2VI:\n-      \/\/ No multiply reduction instructions\n-      case Op_MulReductionVD:\n-      case Op_MulReductionVF:\n-      case Op_MulReductionVI:\n-      case Op_MulReductionVL:\n-      \/\/ Others\n-      case Op_ExtractC:\n-      case Op_ExtractUB:\n-        return false;\n-      \/\/ Vector API specific\n-      case Op_VectorLoadShuffle:\n-      case Op_VectorRearrange:\n-        return vlen >= 4 && length_in_bytes <= MaxVectorSize;\n-      case Op_LoadVector:\n-      case Op_StoreVector:\n-        return Matcher::vector_size_supported(bt, vlen);\n-      case Op_ExpandV:\n-        if (UseSVE < 2 || is_subword_type(bt)) return false;\n-      case Op_VectorMaskToLong:\n-        if (vlen > 64) return false;\n-      case Op_VectorLongToMask:\n-        if (UseSVE < 2 || vlen > 64 || !VM_Version::supports_svebitperm()) return false;\n-      default:\n-        break;\n-    }\n-    \/\/ By default, we only support vector operations with no less than 8 bytes and 2 elements.\n-    return 8 <= length_in_bytes && length_in_bytes <= MaxVectorSize && vlen >= 2;\n-  }\n-\n-  bool masked_op_sve_supported(int opcode, int vlen, BasicType bt) {\n-    switch(opcode) {\n-      case Op_VectorRearrange:\n-        return false;\n-      \/\/ We use Op_LoadVectorMasked to implement the predicated Op_LoadVector.\n-      \/\/ Hence we turn to check whether Op_LoadVectorMasked is supported. The\n-      \/\/ same as vector store\/gather\/scatter.\n-      case Op_LoadVector:\n-        opcode = Op_LoadVectorMasked;\n-        break;\n-      case Op_StoreVector:\n-        opcode = Op_StoreVectorMasked;\n-        break;\n-      case Op_LoadVectorGather:\n-        opcode = Op_LoadVectorGatherMasked;\n-        break;\n-      case Op_StoreVectorScatter:\n-        opcode = Op_StoreVectorScatterMasked;\n-        break;\n-      default:\n-        break;\n-    }\n-    return op_sve_supported(opcode, vlen, bt);\n-  }\n-\n-  bool partial_op_sve_needed(Node* node, const TypeVect* vt) {\n-    switch(node->Opcode()) {\n-      case Op_VectorLoadMask:\n-      case Op_VectorMaskCmp:\n-      case Op_LoadVectorGather:\n-      case Op_StoreVectorScatter:\n-      case Op_AddReductionVI:\n-      case Op_AddReductionVL:\n-      case Op_AddReductionVF:\n-      case Op_AddReductionVD:\n-      case Op_MinReductionV:\n-      case Op_MaxReductionV:\n-      case Op_AndReductionV:\n-      case Op_OrReductionV:\n-      case Op_XorReductionV:\n-      \/\/ Mask is needed for partial Op_VectorMaskFirstTrue, because when the\n-      \/\/ input predicate is all-false, the result should be the vector length\n-      \/\/ instead of the vector register size.\n-      case Op_VectorMaskFirstTrue:\n-        return true;\n-      case Op_MaskAll:\n-        return !node->in(1)->is_Con();\n-      case Op_LoadVector:\n-      case Op_StoreVector:\n-        \/\/ We use NEON load\/store instructions if the vector length is <= 128 bits.\n-        return vt->length_in_bytes() > 16;\n-      default:\n-        \/\/ For other ops whose vector size is smaller than the max vector size, a\n-        \/\/ full-sized unpredicated operation does not impact the final vector result.\n-        return false;\n-    }\n-  }\n-%}\n-\n-definitions %{\n-  int_def SVE_COST             (200, 200);\n-%}\n-\n-dnl\n-dnl ELEMENT_SHORT_CHART($1, $2)\n-dnl ELEMENT_SHORT_CHART(etype, node)\n-define(`ELEMENT_SHORT_CHAR',`ifelse(`$1', `T_SHORT',\n-  `($2->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n-            ($2->bottom_type()->is_vect()->element_basic_type() == T_CHAR))',\n-   `($2->bottom_type()->is_vect()->element_basic_type() == $1)')')dnl\n-dnl\n-\n-\/\/ All SVE instructions\n-\n-\/\/ vector load\/store\n-\n-\/\/ Unpredicated vector load\/store\n-instruct loadV(vReg dst, vmemA mem) %{\n-  predicate(UseSVE > 0 && n->as_LoadVector()->memory_size() > 16);\n-  match(Set dst (LoadVector mem));\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_ldr $dst, $mem\\t# vector (sve)\" %}\n-  ins_encode %{\n-    FloatRegister dst_reg = as_FloatRegister($dst$$reg);\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, dst_reg, ptrue,\n-                          bt, bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct storeV(vReg src, vmemA mem) %{\n-  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() > 16);\n-  match(Set mem (StoreVector mem src));\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_str $mem, $src\\t# vector (sve)\" %}\n-  ins_encode %{\n-    FloatRegister src_reg = as_FloatRegister($src$$reg);\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, src_reg, ptrue,\n-                          bt, bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}dnl\n-\n-dnl\n-define(`VLoadStore', `\n-\/\/ ifelse(load, $3, Load, Store) Vector ($6 bits)\n-instruct $3V$4_vreg`'(vReg $7, vmem$4 mem)\n-%{\n-  predicate(UseSVE > 0 && `n->as_'ifelse(load, $3, Load, Store)Vector()->memory_size() == $4);\n-  match(Set ifelse(load, $3, dst (LoadVector mem), mem (StoreVector mem src)));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"$1   ifelse(load, $3, `$dst,$mem', `$mem,$src')\\t# vector ($6 bits)\" %}\n-  ins_encode( `aarch64_enc_'ifelse(load, $3, ldr, str)v$2($7, mem) );\n-  ins_pipe(v$3`_reg_mem'ifelse(eval($4 * 8), 128, 128, 64));\n-%}')dnl\n-dnl        $1    $2 $3     $4  $5 $6   $7\n-VLoadStore(ldrh, H, load,  2,  D, 16,  dst)\n-VLoadStore(strh, H, store, 2,  D, 16,  src)\n-VLoadStore(ldrs, S, load,  4,  D, 32,  dst)\n-VLoadStore(strs, S, store, 4,  D, 32,  src)\n-VLoadStore(ldrd, D, load,  8,  D, 64,  dst)\n-VLoadStore(strd, D, store, 8,  D, 64,  src)\n-VLoadStore(ldrq, Q, load, 16,  X, 128, dst)\n-VLoadStore(strq, Q, store, 16, X, 128, src)\n-\n-\/\/ vector load\/store - predicated\n-\n-instruct loadV_masked(vReg dst, vmemA mem, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (LoadVectorMasked mem pg));\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_ldr $dst, $pg, $mem\\t# load vector predicated (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, as_FloatRegister($dst$$reg),\n-                          as_PRegister($pg$$reg), bt, bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct storeV_masked(vReg src, vmemA mem, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set mem (StoreVectorMasked mem (Binary src pg)));\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_str $mem, $pg, $src\\t# store vector predicated (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, as_FloatRegister($src$$reg),\n-                          as_PRegister($pg$$reg), bt, bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-dnl\n-dnl MASK_LOGICAL_OP($1,        $2,      $3  )\n-dnl MASK_LOGICAL_OP(insn_name, op_name, insn)\n-define(`MASK_LOGICAL_OP', `\n-instruct vmask_$1(pRegGov pd, pRegGov pn, pRegGov pm) %{\n-  predicate(UseSVE > 0);\n-  match(Set pd ($2 pn pm));\n-  ins_cost(SVE_COST);\n-  format %{ \"$3 $pd, $pn, $pm\\t# predicate (sve)\" %}\n-  ins_encode %{\n-    __ $3(as_PRegister($pd$$reg), ptrue,\n-               as_PRegister($pn$$reg), as_PRegister($pm$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ mask logical and\/or\/xor\n-MASK_LOGICAL_OP(and, AndVMask, sve_and)\n-MASK_LOGICAL_OP(or, OrVMask, sve_orr)\n-MASK_LOGICAL_OP(xor, XorVMask, sve_eor)\n-\n-dnl\n-dnl MASK_LOGICAL_AND_NOT($1,   $2  )\n-dnl MASK_LOGICAL_AND_NOT(type, size)\n-define(`MASK_LOGICAL_AND_NOT', `\n-instruct vmask_and_not$1(pRegGov pd, pRegGov pn, pRegGov pm, imm$1_M1 m1) %{\n-  predicate(UseSVE > 0);\n-  match(Set pd (AndVMask pn (XorVMask pm (MaskAll m1))));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_bic $pd, $pn, $pm\\t# predciate (sve) ($2)\" %}\n-  ins_encode %{\n-    __ sve_bic(as_PRegister($pd$$reg), ptrue,\n-               as_PRegister($pn$$reg), as_PRegister($pm$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ mask logical and_not\n-MASK_LOGICAL_AND_NOT(I, B\/H\/S)\n-MASK_LOGICAL_AND_NOT(L, D)\n-\n-\/\/ vector reinterpret\n-\n-instruct reinterpret(vReg dst) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() ==\n-                          n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src == dst\n-  match(Set dst (VectorReinterpret dst));\n-  ins_cost(0);\n-  format %{ \"# reinterpret $dst\\t# do nothing\" %}\n-  ins_encode %{\n-    \/\/ empty\n-  %}\n-  ins_pipe(pipe_class_empty);\n-%}\n-\n-instruct reinterpretResize(vReg dst, vReg src, pRegGov pgtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() !=\n-                          n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src != dst\n-  match(Set dst (VectorReinterpret src));\n-  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"reinterpretResize $dst, $src\\t# vector (sve)\" %}\n-  ins_encode %{\n-    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, $src);\n-    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);\n-    uint length_in_bytes_resize = length_in_bytes_src < length_in_bytes_dst ?\n-                                  length_in_bytes_src : length_in_bytes_dst;\n-    assert(length_in_bytes_src <= MaxVectorSize && length_in_bytes_dst <= MaxVectorSize,\n-           \"invalid vector length\");\n-    __ sve_gen_mask_imm(as_PRegister($pgtmp$$reg), T_BYTE, length_in_bytes_resize);\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ B, 0);\n-    __ sve_sel(as_FloatRegister($dst$$reg), __ B, as_PRegister($pgtmp$$reg),\n-               as_FloatRegister($src$$reg), as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector mask reinterpret\n-\n-instruct vmask_reinterpret_same_esize(pRegGov dst_src) %{\n-  predicate(UseSVE > 0 &&\n-            n->as_Vector()->length() == n->in(1)->bottom_type()->is_vect()->length() &&\n-            n->as_Vector()->length_in_bytes() == n->in(1)->bottom_type()->is_vect()->length_in_bytes());\n-  match(Set dst_src (VectorReinterpret dst_src));\n-  ins_cost(0);\n-  format %{ \"# vmask_reinterpret $dst_src\\t# do nothing\" %}\n-  ins_encode %{\n-    \/\/ empty\n-  %}\n-  ins_pipe(pipe_class_empty);\n-%}\n-\n-instruct vmask_reinterpret_diff_esize(pRegGov dst, pRegGov src, vReg tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->as_Vector()->length() != n->in(1)->bottom_type()->is_vect()->length() &&\n-            n->as_Vector()->length_in_bytes() == n->in(1)->bottom_type()->is_vect()->length_in_bytes());\n-  match(Set dst (VectorReinterpret src));\n-  effect(TEMP tmp, KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"# vmask_reinterpret $dst, $src\\t# vector (sve)\" %}\n-  ins_encode %{\n-    BasicType from_bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant from_size = __ elemType_to_regVariant(from_bt);\n-    BasicType to_bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n-    __ sve_cpy(as_FloatRegister($tmp$$reg), from_size, as_PRegister($src$$reg), -1, false);\n-    __ sve_cmp(Assembler::EQ, as_PRegister($dst$$reg), to_size, ptrue, as_FloatRegister($tmp$$reg), -1);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-dnl\n-dnl UNARY_OP_TRUE_PREDICATE($1,        $2,      $3,   $4  )\n-dnl UNARY_OP_TRUE_PREDICATE(insn_name, op_name, size, insn)\n-define(`UNARY_OP_TRUE_PREDICATE', `\n-instruct $1(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst ($2 src));\n-  ins_cost(SVE_COST);\n-  format %{ \"$4 $dst, $src\\t# vector (sve) ($3)\" %}\n-  ins_encode %{dnl\n-ifelse($1, `vnegI', `\n-    BasicType bt = Matcher::vector_element_basic_type(this);', `')\n-    __ $4(as_FloatRegister($dst$$reg), ifelse($1, `vnegI', `__ elemType_to_regVariant(bt)', `__ $3'),\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\n-\/\/ vector abs\n-UNARY_OP_TRUE_PREDICATE(vabsB, AbsVB, B, sve_abs)\n-UNARY_OP_TRUE_PREDICATE(vabsS, AbsVS, H, sve_abs)\n-UNARY_OP_TRUE_PREDICATE(vabsI, AbsVI, S, sve_abs)\n-UNARY_OP_TRUE_PREDICATE(vabsL, AbsVL, D, sve_abs)\n-UNARY_OP_TRUE_PREDICATE(vabsF, AbsVF, S, sve_fabs)\n-UNARY_OP_TRUE_PREDICATE(vabsD, AbsVD, D, sve_fabs)\n-\n-dnl UNARY_OP_PREDICATE($1,        $2,      $3,   $4  )\n-dnl UNARY_OP_PREDICATE(insn_name, op_name, size, insn)\n-define(`UNARY_OP_PREDICATE', `\n-instruct $1_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src ($2 dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"$4 $dst_src, $pg, $dst_src\\t# vector (sve) ($3)\" %}\n-  ins_encode %{dnl\n-ifelse($1, `vnegI', `\n-    BasicType bt = Matcher::vector_element_basic_type(this);', `')\n-    __ $4(as_FloatRegister($dst_src$$reg), ifelse($1, `vnegI', `__ elemType_to_regVariant(bt)', `__ $3'),\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-\/\/ vector abs - predicated\n-UNARY_OP_PREDICATE(vabsB, AbsVB, B, sve_abs)\n-UNARY_OP_PREDICATE(vabsS, AbsVS, H, sve_abs)\n-UNARY_OP_PREDICATE(vabsI, AbsVI, S, sve_abs)\n-UNARY_OP_PREDICATE(vabsL, AbsVL, D, sve_abs)\n-UNARY_OP_PREDICATE(vabsF, AbsVF, S, sve_fabs)\n-UNARY_OP_PREDICATE(vabsD, AbsVD, D, sve_fabs)\n-\n-dnl\n-dnl BINARY_OP_UNPREDICATE($1,        $2       $3,   $4           $5  )\n-dnl BINARY_OP_UNPREDICATE(insn_name, op_name, size, min_vec_len, insn)\n-define(`BINARY_OP_UNPREDICATE', `\n-instruct $1(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst ($2 src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"$5 $dst, $src1, $src2\\t # vector (sve) ($3)\" %}\n-  ins_encode %{\n-    __ $5(as_FloatRegister($dst$$reg), __ $3,\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl\n-dnl BINARY_OP_PREDICATE($1,        $2,      $3,   $4  )\n-dnl BINARY_OP_PREDICATE(insn_name, op_name, size, insn)\n-define(`BINARY_OP_PREDICATE', `\n-instruct $1_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 ($2 (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"$4 $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) ($3)\" %}\n-  ins_encode %{\n-    __ $4(as_FloatRegister($dst_src1$$reg), __ $3,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector add\n-BINARY_OP_UNPREDICATE(vaddB, AddVB, B, 16, sve_add)\n-BINARY_OP_UNPREDICATE(vaddS, AddVS, H, 8,  sve_add)\n-BINARY_OP_UNPREDICATE(vaddI, AddVI, S, 4,  sve_add)\n-BINARY_OP_UNPREDICATE(vaddL, AddVL, D, 2,  sve_add)\n-BINARY_OP_UNPREDICATE(vaddF, AddVF, S, 4,  sve_fadd)\n-BINARY_OP_UNPREDICATE(vaddD, AddVD, D, 2,  sve_fadd)\n-\n-\/\/ vector add - predicated\n-BINARY_OP_PREDICATE(vaddB, AddVB, B, sve_add)\n-BINARY_OP_PREDICATE(vaddS, AddVS, H, sve_add)\n-BINARY_OP_PREDICATE(vaddI, AddVI, S, sve_add)\n-BINARY_OP_PREDICATE(vaddL, AddVL, D, sve_add)\n-BINARY_OP_PREDICATE(vaddF, AddVF, S, sve_fadd)\n-BINARY_OP_PREDICATE(vaddD, AddVD, D, sve_fadd)\n-dnl\n-dnl ADD_IMM($1,          $2,   $3      )\n-dnl ADD_IMM(name_suffix, size, imm_type)\n-define(`ADD_IMM', `\n-instruct vaddImm$1(vReg dst_src, $3 con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (AddV$1 dst_src (Replicate$1 con)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_add $dst_src, $dst_src, $con\\t # vector (sve) ($2)\" %}\n-  ins_encode %{\n-    int32_t val = $con$$constant;\n-    if (val > 0){\n-      __ sve_add(as_FloatRegister($dst_src$$reg), __ $2, val);\n-    } else if (val < 0){\n-      __ sve_sub(as_FloatRegister($dst_src$$reg), __ $2, -val);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-\n-\/\/ vector add reg imm (unpredicated)\n-ADD_IMM(B, B, immBAddSubV)\n-ADD_IMM(S, H, immIAddSubV)\n-ADD_IMM(I, S, immIAddSubV)\n-ADD_IMM(L, D, immLAddSubV)\n-dnl\n-dnl BITWISE_OP_IMM($1,        $2        $3,   $4    $5      )\n-dnl BITWISE_OP_IMM(insn_name, op_name1, size, type, op_name2)\n-define(`BITWISE_OP_IMM', `\n-instruct $1(vReg dst_src, imm$4Log con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src ($2 dst_src (Replicate$4 con)));\n-  ins_cost(SVE_COST);\n-  format %{ \"$5 $dst_src, $dst_src, $con\\t # vector (sve) ($3)\" %}\n-  ins_encode %{\n-    __ $5(as_FloatRegister($dst_src$$reg), __ $3,\n-         (uint64_t)($con$$constant));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-\n-\/\/ vector binary op reg imm (unpredicated)\n-BITWISE_OP_IMM(vandB, AndV, B, B, sve_and)\n-BITWISE_OP_IMM(vandH, AndV, H, S, sve_and)\n-BITWISE_OP_IMM(vandS, AndV, S, I, sve_and)\n-BITWISE_OP_IMM(vandD, AndV, D, L, sve_and)\n-BITWISE_OP_IMM(vorB,  OrV,  B, B, sve_orr)\n-BITWISE_OP_IMM(vorH,  OrV,  H, S, sve_orr)\n-BITWISE_OP_IMM(vorS,  OrV,  S, I, sve_orr)\n-BITWISE_OP_IMM(vorD,  OrV,  D, L, sve_orr)\n-BITWISE_OP_IMM(vxorB, XorV, B, B, sve_eor)\n-BITWISE_OP_IMM(vxorH, XorV, H, S, sve_eor)\n-BITWISE_OP_IMM(vxorS, XorV, S, I, sve_eor)\n-BITWISE_OP_IMM(vxorD, XorV, D, L, sve_eor)\n-dnl\n-dnl\n-dnl BINARY_OP_UNSIZED($1,        $2,      $3  )\n-dnl BINARY_OP_UNSIZED(insn_name, op_name, insn)\n-define(`BINARY_OP_UNSIZED', `\n-instruct $1(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst ($2 src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"$3  $dst, $src1, $src2\\t# vector (sve)\" %}\n-  ins_encode %{\n-    __ $3(as_FloatRegister($dst$$reg),\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector and\n-BINARY_OP_UNSIZED(vand, AndV, sve_and)\n-\n-\/\/ vector or\n-BINARY_OP_UNSIZED(vor, OrV, sve_orr)\n-\n-\/\/ vector xor\n-BINARY_OP_UNSIZED(vxor, XorV, sve_eor)\n-\n-dnl BINARY_LOGIC_OP_PREDICATE($1,        $2,      $3  )\n-dnl BINARY_LOGIC_OP_PREDICATE(insn_name, op_name, insn)\n-define(`BINARY_LOGIC_OP_PREDICATE', `\n-instruct $1_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 ($2 (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"$3 $dst_src1, $pg, $dst_src1, $src2\\t # vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ $3(as_FloatRegister($dst_src1$$reg), size,\n-          as_PRegister($pg$$reg),\n-          as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector and - predicated\n-BINARY_LOGIC_OP_PREDICATE(vand, AndV, sve_and)\n-\n-\/\/ vector or - predicated\n-BINARY_LOGIC_OP_PREDICATE(vor, OrV, sve_orr)\n-\n-\/\/ vector xor - predicated\n-BINARY_LOGIC_OP_PREDICATE(vxor, XorV, sve_eor)\n-\n-\/\/ vector not\n-dnl\n-define(`MATCH_RULE', `ifelse($1, I,\n-`match(Set dst (XorV src (ReplicateB m1)));\n-  match(Set dst (XorV src (ReplicateS m1)));\n-  match(Set dst (XorV src (ReplicateI m1)));',\n-`match(Set dst (XorV src (ReplicateL m1)));')')dnl\n-dnl\n-define(`VECTOR_NOT', `\n-instruct vnot$1`'(vReg dst, vReg src, imm$1_M1 m1) %{\n-  predicate(UseSVE > 0);\n-  MATCH_RULE($1)\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_not $dst, $src\\t# vector (sve) $2\" %}\n-  ins_encode %{\n-    __ sve_not(as_FloatRegister($dst$$reg), __ D,\n-               ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl        $1,$2\n-VECTOR_NOT(I, B\/H\/S)\n-VECTOR_NOT(L, D)\n-undefine(MATCH_RULE)\n-dnl\n-\/\/ vector not - predicated\n-dnl\n-define(`MATCH_RULE', `ifelse($1, I,\n-`match(Set dst_src (XorV (Binary dst_src (ReplicateB m1)) pg));\n-  match(Set dst_src (XorV (Binary dst_src (ReplicateS m1)) pg));\n-  match(Set dst_src (XorV (Binary dst_src (ReplicateI m1)) pg));',\n-`match(Set dst_src (XorV (Binary dst_src (ReplicateL m1)) pg));')')dnl\n-dnl\n-define(`VECTOR_NOT_PREDICATE', `\n-instruct vnot$1_masked`'(vReg dst_src, imm$1_M1 m1, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  MATCH_RULE($1)\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_not $dst_src, $pg, $dst_src\\t# vector (sve) $2\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_not(as_FloatRegister($dst_src$$reg), __ elemType_to_regVariant(bt),\n-               as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl                 $1, $2\n-VECTOR_NOT_PREDICATE(I, B\/H\/S)\n-VECTOR_NOT_PREDICATE(L, D)\n-undefine(MATCH_RULE)\n-dnl\n-\/\/ vector and_not\n-dnl\n-define(`MATCH_RULE', `ifelse($1, I,\n-`match(Set dst (AndV src1 (XorV src2 (ReplicateB m1))));\n-  match(Set dst (AndV src1 (XorV src2 (ReplicateS m1))));\n-  match(Set dst (AndV src1 (XorV src2 (ReplicateI m1))));',\n-`match(Set dst (AndV src1 (XorV src2 (ReplicateL m1))));')')dnl\n-dnl\n-define(`VECTOR_AND_NOT', `\n-instruct vand_not$1`'(vReg dst, vReg src1, vReg src2, imm$1_M1 m1) %{\n-  predicate(UseSVE > 0);\n-  MATCH_RULE($1)\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_bic $dst, $src1, $src2\\t# vector (sve) $2\" %}\n-  ins_encode %{\n-    __ sve_bic(as_FloatRegister($dst$$reg),\n-               as_FloatRegister($src1$$reg),\n-               as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl            $1,$2\n-VECTOR_AND_NOT(I, B\/H\/S)\n-VECTOR_AND_NOT(L, D)\n-undefine(MATCH_RULE)\n-dnl\n-\/\/ vector and_not - predicated\n-dnl\n-define(`MATCH_RULE', `ifelse($1, I,\n-`match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateB m1))) pg));\n-  match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateS m1))) pg));\n-  match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateI m1))) pg));',\n-`match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateL m1))) pg));')')dnl\n-dnl\n-define(`VECTOR_AND_NOT_PREDICATE', `\n-instruct vand_not$1_masked`'(vReg dst_src1, vReg src2, imm$1_M1 m1, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  MATCH_RULE($1)\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_bic $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) $2\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_bic(as_FloatRegister($dst_src1$$reg), __ elemType_to_regVariant(bt),\n-               as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl                     $1, $2\n-VECTOR_AND_NOT_PREDICATE(I, B\/H\/S)\n-VECTOR_AND_NOT_PREDICATE(L, D)\n-undefine(MATCH_RULE)\n-dnl\n-dnl VDIVF($1,          $2  , $3         )\n-dnl VDIVF(name_suffix, size, min_vec_len)\n-define(`VDIVF', `\n-instruct vdiv$1(vReg dst_src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (DivV$1 dst_src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fdiv  $dst_src1, $dst_src1, $src2\\t# vector (sve) ($2)\" %}\n-  ins_encode %{\n-    __ sve_fdiv(as_FloatRegister($dst_src1$$reg), __ $2,\n-         ptrue, as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector float div\n-VDIVF(F, S, 4)\n-VDIVF(D, D, 2)\n-\n-\/\/ vector float div - predicated\n-BINARY_OP_PREDICATE(vfdivF, DivVF, S, sve_fdiv)\n-BINARY_OP_PREDICATE(vfdivD, DivVD, D, sve_fdiv)\n-\n-dnl\n-dnl VMINMAX($1     , $2, $3   , $4  )\n-dnl VMINMAX(op_name, op, finsn, insn)\n-define(`VMINMAX', `\n-instruct v$1(vReg dst_src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 ($2 dst_src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_$1 $dst_src1, $dst_src1, $src2\\t # vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    if (is_floating_point_type(bt)) {\n-      __ $3(as_FloatRegister($dst_src1$$reg), size,\n-                  ptrue, as_FloatRegister($src2$$reg));\n-    } else {\n-      assert(is_integral_type(bt), \"unsupported type\");\n-      __ $4(as_FloatRegister($dst_src1$$reg), size,\n-                  ptrue, as_FloatRegister($src2$$reg));\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector min\/max\n-VMINMAX(min, MinV, sve_fmin, sve_smin)\n-VMINMAX(max, MaxV, sve_fmax, sve_smax)\n-\n-dnl\n-dnl VMINMAX_PREDICATE($1     , $2, $3   , $4  )\n-dnl VMINMAX_PREDICATE(op_name, op, finsn, insn)\n-define(`VMINMAX_PREDICATE', `\n-instruct v$1_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 ($2 (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_$1 $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    if (is_floating_point_type(bt)) {\n-      __ $3(as_FloatRegister($dst_src1$$reg), size,\n-                  as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n-    } else {\n-      assert(is_integral_type(bt), \"unsupported type\");\n-      __ $4(as_FloatRegister($dst_src1$$reg), size,\n-                  as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector min\/max - predicated\n-VMINMAX_PREDICATE(min, MinV, sve_fmin, sve_smin)\n-VMINMAX_PREDICATE(max, MaxV, sve_fmax, sve_smax)\n-\n-dnl\n-dnl VFMLA($1           $2  )\n-dnl VFMLA(name_suffix, size)\n-define(`VFMLA', `\n-\/\/ dst_src1 = dst_src1 + src2 * src3\n-instruct vfmla$1(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0);\n-  match(Set dst_src1 (FmaV$1 dst_src1 (Binary src2 src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmla $dst_src1, $src2, $src3\\t # vector (sve) ($2)\" %}\n-  ins_encode %{\n-    __ sve_fmla(as_FloatRegister($dst_src1$$reg), __ $2,\n-         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector fmla\n-VFMLA(F, S)\n-VFMLA(D, D)\n-\n-dnl\n-dnl VFMAD_PREDICATE($1           $2  )\n-dnl VFMAD_PREDICATE(name_suffix, size)\n-define(`VFMAD_PREDICATE', `\n-\/\/ dst_src1 = dst_src1 * src2 + src3\n-instruct vfmad$1_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n-  predicate(UseFMA && UseSVE > 0);\n-  match(Set dst_src1 (FmaV$1 (Binary dst_src1 src2) (Binary src3 pg)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmad $dst_src1, $pg, $src2, $src3\\t# vector (sve) ($2)\" %}\n-  ins_encode %{\n-    __ sve_fmad(as_FloatRegister($dst_src1$$reg), __ $2, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector fmad - predicated\n-VFMAD_PREDICATE(F, S)\n-VFMAD_PREDICATE(D, D)\n-\n-dnl\n-dnl VFMLS1($1           $2  )\n-dnl VFMLS1(name_suffix, size)\n-define(`VFMLS1', `\n-\/\/ dst_src1 = dst_src1 + -src2 * src3\n-\/\/ The NegV$1 must not be predicated.\n-instruct vfmls`$1'1(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaV$1 dst_src1 (Binary (NegV$1 src2) src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmls $dst_src1, $src2, $src3\\t # vector (sve) ($2)\" %}\n-  ins_encode %{\n-    __ sve_fmls(as_FloatRegister($dst_src1$$reg), __ $2,\n-         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl VFMLS2($1           $2  )\n-dnl VFMLS2(name_suffix, size)\n-define(`VFMLS2', `\n-\/\/ dst_src1 = dst_src1 + src2 * -src3\n-\/\/ The NegV$1 must not be predicated.\n-instruct vfmls`$1'2(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(2)->in(2)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaV$1 dst_src1 (Binary src2 (NegV$1 src3))));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmls $dst_src1, $src2, $src3\\t # vector (sve) ($2)\" %}\n-  ins_encode %{\n-    __ sve_fmls(as_FloatRegister($dst_src1$$reg), __ $2,\n-         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector fmls\n-VFMLS1(F, S)\n-VFMLS2(F, S)\n-VFMLS1(D, D)\n-VFMLS2(D, D)\n-\n-dnl\n-dnl VFMSB_PREDICATE($1           $2  )\n-dnl VFMSB_PREDICATE(name_suffix, size)\n-define(`VFMSB_PREDICATE', `\n-\/\/ dst_src1 = dst_src1 * -src2 + src3\n-\/\/ The NegV$1 must not be predicated.\n-instruct vfmsb$1_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(1)->in(2)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaV$1 (Binary dst_src1 (NegV$1 src2)) (Binary src3 pg)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmsb $dst_src1, $pg, $src2, $src3\\t # vector (sve) ($2)\" %}\n-  ins_encode %{\n-    __ sve_fmsb(as_FloatRegister($dst_src1$$reg), __ $2, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector fmsb - predicated\n-VFMSB_PREDICATE(F, S)\n-VFMSB_PREDICATE(D, D)\n-\n-dnl\n-dnl VFNMLA1($1           $2  )\n-dnl VFNMLA1(name_suffix, size)\n-define(`VFNMLA1', `\n-\/\/ dst_src1 = -dst_src1 + -src2 * src3\n-\/\/ The NegV$1 must not be predicated.\n-instruct vfnmla`$1'1(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(1)->as_Vector()->is_predicated_vector() &&\n-            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaV$1 (NegV$1 dst_src1) (Binary (NegV$1 src2) src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fnmla $dst_src1, $src2, $src3\\t # vector (sve) ($2)\" %}\n-  ins_encode %{\n-    __ sve_fnmla(as_FloatRegister($dst_src1$$reg), __ $2,\n-         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl VFNMLA2($1           $2  )\n-dnl VFNMLA2(name_suffix, size)\n-define(`VFNMLA2', `\n-\/\/ dst_src1 = -dst_src1 + src2 * -src3\n-\/\/ The NegV$1 must not be predicated.\n-instruct vfnmla`$1'2(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(1)->as_Vector()->is_predicated_vector() &&\n-            !n->in(2)->in(2)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaV$1 (NegV$1 dst_src1) (Binary src2 (NegV$1 src3))));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fnmla $dst_src1, $src2, $src3\\t # vector (sve) ($2)\" %}\n-  ins_encode %{\n-    __ sve_fnmla(as_FloatRegister($dst_src1$$reg), __ $2,\n-         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector fnmla\n-VFNMLA1(F, S)\n-VFNMLA2(F, S)\n-VFNMLA1(D, D)\n-VFNMLA2(D, D)\n-\n-dnl\n-dnl VFNMAD_PREDICATE($1           $2  )\n-dnl VFNMAD_PREDICATE(name_suffix, size)\n-define(`VFNMAD_PREDICATE', `\n-\/\/ dst_src1 = -src3 + dst_src1 * -src2\n-\/\/ The NegV$1 must not be predicated.\n-instruct vfnmad$1_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(1)->in(2)->as_Vector()->is_predicated_vector() &&\n-            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaV$1 (Binary dst_src1 (NegV$1 src2)) (Binary (NegV$1 src3) pg)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fnmad $dst_src1, $pg, $src2, $src3\\t # vector (sve) ($2)\" %}\n-  ins_encode %{\n-    __ sve_fnmad(as_FloatRegister($dst_src1$$reg), __ $2, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector fnmad - predicated\n-VFNMAD_PREDICATE(F, S)\n-VFNMAD_PREDICATE(D, D)\n-\n-dnl\n-dnl VFNMLS($1           $2  )\n-dnl VFNMLS(name_suffix, size)\n-define(`VFNMLS', `\n-\/\/ dst_src1 = -dst_src1 + src2 * src3\n-\/\/ The NegV$1 must not be predicated.\n-instruct vfnmls$1(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(1)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaV$1 (NegV$1 dst_src1) (Binary src2 src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fnmls $dst_src1, $src2, $src3\\t # vector (sve) ($2)\" %}\n-  ins_encode %{\n-    __ sve_fnmls(as_FloatRegister($dst_src1$$reg), __ $2,\n-         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector fnmls\n-VFNMLS(F, S)\n-VFNMLS(D, D)\n-\n-dnl\n-dnl VFNMSB_PREDICATE($1           $2  )\n-dnl VFNMSB_PREDICATE(name_suffix, size)\n-define(`VFNMSB_PREDICATE', `\n-\/\/ dst_src1 = -src3 + dst_src1 * src2\n-\/\/ The NegV$1 must not be predicated.\n-instruct vfnmsb$1_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaV$1 (Binary dst_src1 src2) (Binary (NegV$1 src3) pg)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fnmsb $dst_src1, $pg, $src2, $src3\\t # vector (sve) ($2)\" %}\n-  ins_encode %{\n-    __ sve_fnmsb(as_FloatRegister($dst_src1$$reg), __ $2, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector fnmsb - predicated\n-VFNMSB_PREDICATE(F, S)\n-VFNMSB_PREDICATE(D, D)\n-\n-dnl\n-dnl VMLA($1           $2  )\n-dnl VMLA(name_suffix, size)\n-define(`VMLA', `\n-\/\/ dst_src1 = dst_src1 + src2 * src3\n-instruct vmla$1(vReg dst_src1, vReg src2, vReg src3)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AddV$1 dst_src1 (MulV$1 src2 src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mla $dst_src1, src2, src3\\t # vector (sve) ($2)\" %}\n-  ins_encode %{\n-    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ $2,\n-      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector mla\n-VMLA(B, B)\n-VMLA(S, H)\n-VMLA(I, S)\n-VMLA(L, D)\n-\n-dnl\n-dnl VMLA_PREDICATE($1           $2  )\n-dnl VMLA_PREDICATE(name_suffix, size)\n-define(`VMLA_PREDICATE', `\n-\/\/ dst_src1 = dst_src1 + src2 * src3\n-instruct vmla$1_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AddV$1 (Binary dst_src1 (MulV$1 src2 src3)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mla $dst_src1, $pg, src2, src3\\t # vector (sve) ($2)\" %}\n-  ins_encode %{\n-    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ $2, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector mla - predicated\n-VMLA_PREDICATE(B, B)\n-VMLA_PREDICATE(S, H)\n-VMLA_PREDICATE(I, S)\n-VMLA_PREDICATE(L, D)\n-\n-dnl\n-dnl VMLS($1           $2  )\n-dnl VMLS(name_suffix, size)\n-define(`VMLS', `\n-\/\/ dst_src1 = dst_src1 - src2 * src3\n-instruct vmls$1(vReg dst_src1, vReg src2, vReg src3)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (SubV$1 dst_src1 (MulV$1 src2 src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mls $dst_src1, src2, src3\\t # vector (sve) ($2)\" %}\n-  ins_encode %{\n-    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ $2,\n-      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector mls\n-VMLS(B, B)\n-VMLS(S, H)\n-VMLS(I, S)\n-VMLS(L, D)\n-\n-dnl\n-dnl VMLS_PREDICATE($1           $2  )\n-dnl VMLS_PREDICATE(name_suffix, size)\n-define(`VMLS_PREDICATE', `\n-\/\/ dst_src1 = dst_src1 - src2 * src3\n-instruct vmls$1_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (SubV$1 (Binary dst_src1 (MulV$1 src2 src3)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mls $dst_src1, $pg, src2, src3\\t # vector (sve) ($2)\" %}\n-  ins_encode %{\n-    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ $2, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector mls - predicated\n-VMLS_PREDICATE(B, B)\n-VMLS_PREDICATE(S, H)\n-VMLS_PREDICATE(I, S)\n-VMLS_PREDICATE(L, D)\n-\n-dnl\n-dnl BINARY_OP_TRUE_PREDICATE($1,        $2,      $3,   $4,          $5  )\n-dnl BINARY_OP_TRUE_PREDICATE(insn_name, op_name, size, min_vec_len, insn)\n-define(`BINARY_OP_TRUE_PREDICATE', `\n-instruct $1(vReg dst_src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 ($2 dst_src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"$5 $dst_src1, $dst_src1, $src2\\t # vector (sve) ($3)\" %}\n-  ins_encode %{\n-    __ $5(as_FloatRegister($dst_src1$$reg), __ $3,\n-         ptrue, as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector mul\n-BINARY_OP_TRUE_PREDICATE(vmulB, MulVB, B, 16, sve_mul)\n-BINARY_OP_TRUE_PREDICATE(vmulS, MulVS, H, 8,  sve_mul)\n-BINARY_OP_TRUE_PREDICATE(vmulI, MulVI, S, 4,  sve_mul)\n-BINARY_OP_TRUE_PREDICATE(vmulL, MulVL, D, 2,  sve_mul)\n-BINARY_OP_UNPREDICATE(vmulF, MulVF, S, 4, sve_fmul)\n-BINARY_OP_UNPREDICATE(vmulD, MulVD, D, 2, sve_fmul)\n-\n-\/\/ vector mul - predicated\n-BINARY_OP_PREDICATE(vmulB, MulVB, B, sve_mul)\n-BINARY_OP_PREDICATE(vmulS, MulVS, H, sve_mul)\n-BINARY_OP_PREDICATE(vmulI, MulVI, S, sve_mul)\n-BINARY_OP_PREDICATE(vmulL, MulVL, D, sve_mul)\n-BINARY_OP_PREDICATE(vmulF, MulVF, S, sve_fmul)\n-BINARY_OP_PREDICATE(vmulD, MulVD, D, sve_fmul)\n-\n-\/\/ vector neg\n-UNARY_OP_TRUE_PREDICATE(vnegI, NegVI, B\/H\/S, sve_neg)\n-UNARY_OP_TRUE_PREDICATE(vnegL, NegVL, D, sve_neg)\n-UNARY_OP_TRUE_PREDICATE(vnegF, NegVF, S, sve_fneg)\n-UNARY_OP_TRUE_PREDICATE(vnegD, NegVD, D, sve_fneg)\n-\n-\/\/ vector neg - predicated\n-UNARY_OP_PREDICATE(vnegI, NegVI, B\/H\/S, sve_neg)\n-UNARY_OP_PREDICATE(vnegL, NegVL, D, sve_neg)\n-UNARY_OP_PREDICATE(vnegF, NegVF, S, sve_fneg)\n-UNARY_OP_PREDICATE(vnegD, NegVD, D, sve_fneg)\n-\n-dnl\n-dnl VPOPCOUNT($1,          $2  )\n-dnl VPOPCOUNT(name_suffix, size)\n-define(`VPOPCOUNT', `\n-instruct vpopcount$1(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector()`'ifelse($1, `L', ` &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_LONG', `'));\n-  match(Set dst (PopCountV$1 src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_cnt $dst, $src\\t# vector (sve) ($2)\" %}\n-  ins_encode %{dnl\n-ifelse($1, `I', `\n-    BasicType bt = Matcher::vector_element_basic_type(this);', `')\n-    __ sve_cnt(as_FloatRegister($dst$$reg), ifelse($1, `I', `__ elemType_to_regVariant(bt)', `__ D'),\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector popcount\n-VPOPCOUNT(I, B\/H\/S)\n-VPOPCOUNT(L, D)\n-\n-\/\/ If the PopCountVL is generated by auto-vectorization, the dst basic\n-\/\/ type is T_INT. And once we have unified the type definition for\n-\/\/ Vector API and auto-vectorization, this rule can be merged with\n-\/\/ \"vpopcountL\" rule.\n-instruct vpopcountLI(vReg dst, vReg src, vReg vtmp) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector() &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (PopCountVL src));\n-  effect(TEMP_DEF dst, TEMP vtmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_cnt $dst, $src\\n\\t\"\n-            \"sve_dup $vtmp, #0\\n\\t\"\n-            \"sve_uzp1 $dst, $dst, $vtmp\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_cnt(as_FloatRegister($dst$$reg), __ D,\n-         ptrue, as_FloatRegister($src$$reg));\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ S,\n-         as_FloatRegister($dst$$reg), __ D, as_FloatRegister($vtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-dnl\n-dnl VPOPCOUNT_PREDICATE($1,          $2  )\n-dnl VPOPCOUNT_PREDICATE(name_suffix, size)\n-define(`VPOPCOUNT_PREDICATE', `\n-instruct vpopcount$1_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0`'ifelse($1, `L', ` &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_LONG', `'));\n-  match(Set dst_src (PopCountV$1 dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_cnt $dst_src, $pg, $dst_src\\t# vector (sve) ($2)\" %}\n-  ins_encode %{dnl\n-ifelse($1, `I', `\n-    BasicType bt = Matcher::vector_element_basic_type(this);', `')\n-    __ sve_cnt(as_FloatRegister($dst_src$$reg), ifelse($1, `I', `__ elemType_to_regVariant(bt)', `__ D'),\n-         as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-\/\/ vector popcount - predicated\n-VPOPCOUNT_PREDICATE(I, B\/H\/S)\n-VPOPCOUNT_PREDICATE(L, D)\n-\n-\/\/ vector blend\n-\n-instruct vblend(vReg dst, vReg src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorBlend (Binary src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_sel $dst, $pg, $src2, $src1\\t# vector blend (sve)\" %}\n-  ins_encode %{\n-    Assembler::SIMD_RegVariant size =\n-               __ elemType_to_regVariant(Matcher::vector_element_basic_type(this));\n-    __ sve_sel(as_FloatRegister($dst$$reg), size, as_PRegister($pg$$reg),\n-               as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector store mask\n-\n-instruct vstoremaskB(vReg dst, pRegGov src, immI_1 size) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorStoreMask src size));\n-  ins_cost(SVE_COST);\n-  format %{ \"vstoremask $dst, $src\\t# vector store mask (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ B, as_PRegister($src$$reg), 1, false);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vstoremask_narrow(vReg dst, pRegGov src, vReg tmp, immI_gt_1 size) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorStoreMask src size));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"vstoremask $dst, $src\\t# vector store mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    Assembler::SIMD_RegVariant size = __ elemBytes_to_regVariant((int)$size$$constant);\n-    __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($src$$reg), 1, false);\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ B,\n-                         as_FloatRegister($dst$$reg), size, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Combined rules for vector mask load when the vector element type is not T_BYTE\n-\n-\/\/ VectorLoadMask+LoadVector, and the VectorLoadMask is unpredicated.\n-instruct vloadmask_loadV(pRegGov dst, indirect mem, vReg vtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && !n->is_predicated_vector() &&\n-            type2aelembytes(n->bottom_type()->is_vect()->element_basic_type()) > 1);\n-  match(Set dst (VectorLoadMask (LoadVector mem)));\n-  effect(TEMP vtmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_ld1b $vtmp, $mem\\n\\t\"\n-            \"sve_cmpne $dst, $vtmp, 0\\t# load vector mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    \/\/ Load mask values which are boolean type, and extend them to the\n-    \/\/ defined vector element type. Convert the vector to predicate.\n-    assert(Matcher::vector_length_in_bytes(this) == MaxVectorSize, \"invalid vector length\");\n-    BasicType to_vect_bt = Matcher::vector_element_basic_type(this);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, as_FloatRegister($vtmp$$reg),\n-                          ptrue, T_BOOLEAN, to_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ elemType_to_regVariant(to_vect_bt),\n-               ptrue, as_FloatRegister($vtmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ VectorLoadMask+LoadVector, and the VectorLoadMask is predicated.\n-instruct vloadmask_loadV_masked(pRegGov dst, indirect mem, pRegGov pg, vReg vtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            type2aelembytes(n->bottom_type()->is_vect()->element_basic_type()) > 1);\n-  match(Set dst (VectorLoadMask (LoadVector mem) pg));\n-  effect(TEMP vtmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_ld1b $vtmp, $pg, $mem\\n\\t\"\n-            \"sve_cmpne $dst, $pg, $vtmp, 0\\t# load vector mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    \/\/ Load valid mask values which are boolean type, and extend them to the\n-    \/\/ defined vector element type. Convert the vector to predicate.\n-    BasicType to_vect_bt = Matcher::vector_element_basic_type(this);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, as_FloatRegister($vtmp$$reg),\n-                          as_PRegister($pg$$reg), T_BOOLEAN, to_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ elemType_to_regVariant(to_vect_bt),\n-               as_PRegister($pg$$reg), as_FloatRegister($vtmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ VectorLoadMask+LoadVectorMasked, and the VectorLoadMask is unpredicated.\n-instruct vloadmask_loadVMasked(pRegGov dst, vmemA mem, pRegGov pg, vReg vtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && !n->is_predicated_vector() &&\n-            type2aelembytes(n->bottom_type()->is_vect()->element_basic_type()) > 1);\n-  match(Set dst (VectorLoadMask (LoadVectorMasked mem pg)));\n-  effect(TEMP vtmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_ld1b $vtmp, $mem\\n\\t\"\n-            \"sve_cmpne $dst, $vtmp, 0\\t# load vector mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    \/\/ Load mask values which are boolean type, and extend them to the\n-    \/\/ defined vector element type. Convert the vector to predicate.\n-    \/\/\n-    \/\/ Note that we cannot use \"pg\" here, since it is the predicate used\n-    \/\/ for the vector load with boolean type. But the predicate used in\n-    \/\/ the extending \"sve_ld1b\" is based on the final extended vector type,\n-    \/\/ which is the full-sized predicate (ptrue) used in VectorLoadMask.\n-    assert(Matcher::vector_length_in_bytes(this) == MaxVectorSize, \"invalid vector length\");\n-    BasicType to_vect_bt = Matcher::vector_element_basic_type(this);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, as_FloatRegister($vtmp$$reg),\n-                          ptrue, T_BOOLEAN, to_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ elemType_to_regVariant(to_vect_bt),\n-               ptrue, as_FloatRegister($vtmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ VectorLoadMask+LoadVectorMasked, and the VectorLoadMask is predicated.\n-instruct vloadmask_loadVMasked_masked(pRegGov dst, vmemA mem, pRegGov pg1, pRegGov pg2,\n-                                      vReg vtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            type2aelembytes(n->bottom_type()->is_vect()->element_basic_type()) > 1);\n-  match(Set dst (VectorLoadMask (LoadVectorMasked mem pg1) pg2));\n-  effect(TEMP vtmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_ld1b $vtmp, $pg2, $mem\\n\\t\"\n-            \"sve_cmpne $dst, $pg2, $vtmp, 0\\t# load vector mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    \/\/ Load valid mask values which are boolean type, and extend them to the\n-    \/\/ defined vector element type. Convert the vector to predicate.\n-    \/\/\n-    \/\/ Note that we cannot use \"pg1\" here, since it is the predicate used\n-    \/\/ for the vector load with boolean type. But the predicate used in\n-    \/\/ the extending \"sve_ld1b\" is based on the final extended vector type,\n-    \/\/ which is the \"pg2\" used in VectorLoadMask.\n-    BasicType to_vect_bt = Matcher::vector_element_basic_type(this);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, as_FloatRegister($vtmp$$reg),\n-                          as_PRegister($pg2$$reg), T_BOOLEAN, to_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ elemType_to_regVariant(to_vect_bt),\n-               as_PRegister($pg2$$reg), as_FloatRegister($vtmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Combined rules for vector mask store when the vector element type is not T_BYTE\n-\n-\/\/ StoreVector+VectorStoreMask, and the vector size of \"src\" is equal to the MaxVectorSize.\n-instruct storeV_vstoremask(indirect mem, pRegGov src, vReg vtmp, immI_gt_1 esize) %{\n-  predicate(UseSVE > 0 &&\n-            Matcher::vector_length_in_bytes(n->as_StoreVector()->in(MemNode::ValueIn)->in(1)) == MaxVectorSize);\n-  match(Set mem (StoreVector mem (VectorStoreMask src esize)));\n-  effect(TEMP vtmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_cpy $vtmp, $src, 1\\n\\t\"\n-            \"sve_st1b $vtmp, $mem\\t# store vector mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    \/\/ Convert the valid src predicate to vector, and store the vector elements\n-    \/\/ as boolean values.\n-    BasicType from_vect_bt = Matcher::vector_element_basic_type(this, $src);\n-    assert(type2aelembytes(from_vect_bt) == (int)$esize$$constant, \"unsupported type.\");\n-    Assembler::SIMD_RegVariant size = __ elemBytes_to_regVariant($esize$$constant);\n-    __ sve_cpy(as_FloatRegister($vtmp$$reg), size, as_PRegister($src$$reg), 1, false);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, as_FloatRegister($vtmp$$reg),\n-                          ptrue, T_BOOLEAN, from_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ StoreVector+VectorStoreMask, and the vector size of \"src\" is lower than the MaxVectorSize.\n-instruct storeV_vstoremask_masked(indirect mem, pRegGov src, vReg vtmp,\n-                                  immI_gt_1 esize, pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            Matcher::vector_length_in_bytes(n->as_StoreVector()->in(MemNode::ValueIn)->in(1)) < MaxVectorSize);\n-  match(Set mem (StoreVector mem (VectorStoreMask src esize)));\n-  effect(TEMP vtmp, TEMP ptmp, KILL cr);\n-  format %{ \"sve_cpy $vtmp, $src, 1\\n\\t\"\n-            \"sve_ptrue $ptmp, vector_length\\n\\t\"\n-            \"sve_st1b $vtmp, $ptmp, $mem\\t# store vector mask (sve) (H\/S\/D)\" %}\n-  ins_cost(3 * SVE_COST);\n-  ins_encode %{\n-    \/\/ Convert the valid src predicate to vector, and store the vector elements\n-    \/\/ as boolean values.\n-    BasicType from_vect_bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(from_vect_bt);\n-    __ sve_cpy(as_FloatRegister($vtmp$$reg), size, as_PRegister($src$$reg), 1, false);\n-    __ sve_gen_mask_imm(as_PRegister($ptmp$$reg), from_vect_bt, Matcher::vector_length(this, $src));\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, as_FloatRegister($vtmp$$reg),\n-                          as_PRegister($ptmp$$reg), T_BOOLEAN, from_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ StoreVectorMasked+VectorStoreMask, and the vector size of \"src\" is equal to the MaxVectorSize.\n-instruct storeVMasked_vstoremask(vmemA mem, pRegGov src, pRegGov pg, vReg vtmp, immI_gt_1 esize) %{\n-  predicate(UseSVE > 0 &&\n-            Matcher::vector_length_in_bytes(n->as_StoreVector()->in(MemNode::ValueIn)->in(1)) == MaxVectorSize);\n-  match(Set mem (StoreVectorMasked mem (Binary (VectorStoreMask src esize) pg)));\n-  effect(TEMP vtmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_cpy $vtmp, $src, 1\\n\\t\"\n-            \"sve_st1b $vtmp, $mem\\t# store vector mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    \/\/ Convert the valid src predicate to vector, and store the vector elements\n-    \/\/ as boolean values.\n-    \/\/\n-    \/\/ Note that we cannot use \"pg\" here, since it is the predicate used\n-    \/\/ for the vector store with boolean type. But the predicate used in\n-    \/\/ the narrowing \"sve_st1b\" is based on the \"src\" vector type, which\n-    \/\/ is the full-sized predicate (ptrue) here.\n-    BasicType from_vect_bt = Matcher::vector_element_basic_type(this, $src);\n-    assert(type2aelembytes(from_vect_bt) == (int)$esize$$constant, \"unsupported type.\");\n-    Assembler::SIMD_RegVariant size = __ elemBytes_to_regVariant($esize$$constant);\n-    __ sve_cpy(as_FloatRegister($vtmp$$reg), size, as_PRegister($src$$reg), 1, false);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, as_FloatRegister($vtmp$$reg),\n-                          ptrue, T_BOOLEAN, from_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ StoreVectorMasked+VectorStoreMask, and the vector size of \"src\" is lower than the MaxVectorSize.\n-instruct storeVMasked_vstoremask_masked(vmemA mem, pRegGov src, pRegGov pg, vReg vtmp,\n-                                        immI_gt_1 esize, pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            Matcher::vector_length_in_bytes(n->as_StoreVector()->in(MemNode::ValueIn)->in(1)) < MaxVectorSize);\n-  match(Set mem (StoreVectorMasked mem (Binary (VectorStoreMask src esize) pg)));\n-  effect(TEMP vtmp, TEMP ptmp, KILL cr);\n-  format %{ \"sve_cpy $vtmp, $src, 1\\n\\t\"\n-            \"sve_ptrue $ptmp, vector_length\\n\\t\"\n-            \"sve_st1b $vtmp, $ptmp, $mem\\t# store vector mask (sve) (H\/S\/D)\" %}\n-  ins_cost(3 * SVE_COST);\n-  ins_encode %{\n-    \/\/ Convert the valid src predicate to vector, and store the vector elements\n-    \/\/ as boolean values.\n-    \/\/\n-    \/\/ Note that we cannot use \"pg\" here, since it is the predicate used for the\n-    \/\/ vector store with boolean type. But the predicate used in the narrowing\n-    \/\/ \"sve_st1b\" is based on the \"src\" vector type, which needed to be generated\n-    \/\/ here.\n-    BasicType from_vect_bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(from_vect_bt);\n-    __ sve_cpy(as_FloatRegister($vtmp$$reg), size, as_PRegister($src$$reg), 1, false);\n-    __ sve_gen_mask_imm(as_PRegister($ptmp$$reg), from_vect_bt, Matcher::vector_length(this, $src));\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, as_FloatRegister($vtmp$$reg),\n-                          as_PRegister($ptmp$$reg), T_BOOLEAN, from_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-dnl\n-dnl REDUCE_I($1,        $2     )\n-dnl REDUCE_I(insn_name, op_name)\n-define(`REDUCE_I', `\n-instruct reduce_$1I(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{\n-  ifelse($2, AddReductionVI,\n-       `predicate(UseSVE > 0);',\n-       `predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG);')\n-  match(Set dst ($2 src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_$1I $dst, $src1, $src2\\t# $1I reduction (sve) (may extend)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           ptrue, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl\n-dnl REDUCE_L($1,        $2    )\n-dnl REDUCE_L(insn_name, op_name)\n-define(`REDUCE_L', `\n-instruct reduce_$1L(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp) %{\n-  ifelse($2, AddReductionVL,\n-       `predicate(UseSVE > 0);',\n-       `predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);')\n-  match(Set dst ($2 src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_$1L $dst, $src1, $src2\\t# $1L reduction (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           ptrue, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl\n-dnl REDUCE_ADDF($1,        $2,      $3,      $4  )\n-dnl REDUCE_ADDF(insn_name, op_name, reg_dst, size)\n-define(`REDUCE_ADDF', `\n-instruct reduce_$1($3 src1_dst, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set src1_dst ($2 src1_dst src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fadda $src1_dst, $src1_dst, $src2\\t# vector (sve) ($4)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ $4,\n-         ptrue, as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl\n-dnl REDUCE_I_PREDICATE($1,        $2     )\n-dnl REDUCE_I_PREDICATE(insn_name, op_name)\n-define(`REDUCE_I_PREDICATE', `\n-instruct reduce_$1I_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp, pRegGov pg) %{\n-  ifelse($2, AddReductionVI,\n-       `predicate(UseSVE > 0);',\n-       `predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG);')\n-  match(Set dst ($2 (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_$1I $dst, $src1, $pg, $src2\\t# $1I reduction predicated (sve) (may extend)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl REDUCE_L_PREDICATE($1,        $2    )\n-dnl REDUCE_L_PREDICATE(insn_name, op_name)\n-define(`REDUCE_L_PREDICATE', `\n-instruct reduce_$1L_masked(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp, pRegGov pg) %{\n-  ifelse($2, AddReductionVL,\n-       `predicate(UseSVE > 0);',\n-       `predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);')\n-  match(Set dst ($2 (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_$1L $dst, $src1, $pg, $src2\\t# $1L reduction predicated (sve)\" %}\n-  ins_encode %{\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl REDUCE_ADDF_PREDICATE($1,        $2,      $3,      $4  )\n-dnl REDUCE_ADDF_PREDICATE(insn_name, op_name, reg_dst, size)\n-define(`REDUCE_ADDF_PREDICATE', `\n-instruct reduce_$1_masked($3 src1_dst, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set src1_dst ($2 (Binary src1_dst src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_$1 $src1_dst, $pg, $src2\\t# $1 reduction predicated (sve)\" %}\n-  ins_encode %{\n-    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ $4,\n-                 as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl\n-\/\/ vector add reduction\n-REDUCE_I(add, AddReductionVI)\n-REDUCE_L(add, AddReductionVL)\n-REDUCE_ADDF(addF, AddReductionVF, vRegF, S)\n-REDUCE_ADDF(addD, AddReductionVD, vRegD, D)\n-\n-\/\/ vector add reduction - predicated\n-REDUCE_I_PREDICATE(add, AddReductionVI)\n-REDUCE_L_PREDICATE(add, AddReductionVL)\n-REDUCE_ADDF_PREDICATE(addF, AddReductionVF, vRegF, S)\n-REDUCE_ADDF_PREDICATE(addD, AddReductionVD, vRegD, D)\n-\n-\/\/ vector and reduction\n-REDUCE_I(and, AndReductionV)\n-REDUCE_L(and, AndReductionV)\n-\n-\/\/ vector and reduction - predicated\n-REDUCE_I_PREDICATE(and, AndReductionV)\n-REDUCE_L_PREDICATE(and, AndReductionV)\n-\n-\/\/ vector or reduction\n-REDUCE_I(or, OrReductionV)\n-REDUCE_L(or, OrReductionV)\n-\n-\/\/ vector or reduction - predicated\n-REDUCE_I_PREDICATE(or, OrReductionV)\n-REDUCE_L_PREDICATE(or, OrReductionV)\n-\n-\/\/ vector xor reduction\n-REDUCE_I(eor, XorReductionV)\n-REDUCE_L(eor, XorReductionV)\n-\n-\/\/ vector xor reduction - predicated\n-REDUCE_I_PREDICATE(eor, XorReductionV)\n-REDUCE_L_PREDICATE(eor, XorReductionV)\n-\n-dnl\n-dnl REDUCE_MAXMIN_I($1,        $2     )\n-dnl REDUCE_MAXMIN_I(insn_name, op_name)\n-define(`REDUCE_MAXMIN_I', `\n-instruct reduce_$1I(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n-            is_integral_type(n->in(2)->bottom_type()->is_vect()->element_basic_type()));\n-  match(Set dst ($2 src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_$1I $dst, $src1, $src2\\t# $1I reduction (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           ptrue, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl REDUCE_MAXMIN_L($1,        $2     )\n-dnl REDUCE_MAXMIN_L(insn_name, op_name)\n-define(`REDUCE_MAXMIN_L', `\n-instruct reduce_$1L(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst ($2 src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_$1L $dst, $src1, $src2\\t# $1L reduction (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           ptrue, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl REDUCE_MAXMIN_I_PREDICATE($1     , $2     )\n-dnl REDUCE_MAXMIN_I_PREDICATE(min_max, op_name)\n-define(`REDUCE_MAXMIN_I_PREDICATE', `\n-instruct reduce_$1I_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp,\n-                           pRegGov pg, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n-            is_integral_type(n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type()));\n-  match(Set dst ($2 (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_$1I $dst, $src1, $pg, $src2\\t# $1I reduction predicated (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl REDUCE_MAXMIN_L_PREDICATE($1     , $2     )\n-dnl REDUCE_MAXMIN_L_PREDICATE(min_max, op_name)\n-define(`REDUCE_MAXMIN_L_PREDICATE', `\n-instruct reduce_$1L_masked(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp,\n-                          pRegGov pg, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst ($2 (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_$1L $dst, $src1, $pg, $src2\\t# $1L reduction predicated (sve)\" %}\n-  ins_encode %{\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl REDUCE_FMINMAX($1,      $2,          $3,           $4,   $5         )\n-dnl REDUCE_FMINMAX(min_max, name_suffix, element_type, size, reg_src_dst)\n-define(`REDUCE_FMINMAX', `\n-instruct reduce_$1$2($5 dst, $5 src1, vReg src2) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == $3);\n-  match(Set dst (translit($1, `m', `M')ReductionV src1 src2));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"sve_reduce_$1$2 $dst, $src1, $src2\\t# $1$2 reduction (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_f$1v(as_FloatRegister($dst$$reg), __ $4, ptrue, as_FloatRegister($src2$$reg));\n-    __ f`$1'translit($4, `SD', `sd')(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl REDUCE_FMINMAX_PREDICATE($1,      $2,          $3,           $4,   $5         )\n-dnl REDUCE_FMINMAX_PREDICATE(min_max, name_suffix, element_type, size, reg_src_dst)\n-define(`REDUCE_FMINMAX_PREDICATE', `\n-instruct reduce_$1$2_masked($5 dst, $5 src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == $3);\n-  match(Set dst (translit($1, `m', `M')ReductionV (Binary src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"sve_reduce_$1$2 $dst, $src1, $pg, $src2\\t# $1$2 reduction predicated (sve)\" %}\n-  ins_encode %{\n-    __ sve_f$1v(as_FloatRegister($dst$$reg), __ $4, as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n-    __ f`$1'translit($4, `SD', `sd')(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector max reduction\n-REDUCE_MAXMIN_I(max, MaxReductionV)\n-REDUCE_MAXMIN_L(max, MaxReductionV)\n-REDUCE_FMINMAX(max, F, T_FLOAT,  S, vRegF)\n-REDUCE_FMINMAX(max, D, T_DOUBLE, D, vRegD)\n-\n-\/\/ vector max reduction - predicated\n-REDUCE_MAXMIN_I_PREDICATE(max, MaxReductionV)\n-REDUCE_MAXMIN_L_PREDICATE(max, MaxReductionV)\n-REDUCE_FMINMAX_PREDICATE(max, F, T_FLOAT,  S, vRegF)\n-REDUCE_FMINMAX_PREDICATE(max, D, T_DOUBLE, D, vRegD)\n-\n-\/\/ vector min reduction\n-REDUCE_MAXMIN_I(min, MinReductionV)\n-REDUCE_MAXMIN_L(min, MinReductionV)\n-REDUCE_FMINMAX(min, F, T_FLOAT,  S, vRegF)\n-REDUCE_FMINMAX(min, D, T_DOUBLE, D, vRegD)\n-\n-\/\/ vector min reduction - predicated\n-REDUCE_MAXMIN_I_PREDICATE(min, MinReductionV)\n-REDUCE_MAXMIN_L_PREDICATE(min, MinReductionV)\n-REDUCE_FMINMAX_PREDICATE(min, F, T_FLOAT,  S, vRegF)\n-REDUCE_FMINMAX_PREDICATE(min, D, T_DOUBLE, D, vRegD)\n-\n-\/\/ vector Math.rint, floor, ceil\n-\n-instruct vroundD(vReg dst, vReg src, immI rmode) %{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (RoundDoubleModeV src rmode));\n-  format %{ \"sve_frint $dst, $src, $rmode\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    switch ($rmode$$constant) {\n-      case RoundDoubleModeNode::rmode_rint:\n-        __ sve_frintn(as_FloatRegister($dst$$reg), __ D,\n-             ptrue, as_FloatRegister($src$$reg));\n-        break;\n-      case RoundDoubleModeNode::rmode_floor:\n-        __ sve_frintm(as_FloatRegister($dst$$reg), __ D,\n-             ptrue, as_FloatRegister($src$$reg));\n-        break;\n-      case RoundDoubleModeNode::rmode_ceil:\n-        __ sve_frintp(as_FloatRegister($dst$$reg), __ D,\n-             ptrue, as_FloatRegister($src$$reg));\n-        break;\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-define(`VECTOR_JAVA_FROUND', `\n-instruct vround$1to$3($7 dst, $7 src, $7 tmp1, $7 tmp2, $7 tmp3, pRegGov ptmp)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst (RoundV$1 src));\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP ptmp);\n-  format %{ \"sve_vround  $dst, $4, $src\\t# round $1 to $3 vector\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    int vlen = Matcher::vector_length_in_bytes(this);\n-    if (vlen > 16) {\n-      __ vector_round_sve(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-                          as_FloatRegister($tmp1$$reg), as_FloatRegister($tmp2$$reg),\n-                          as_PRegister($ptmp$$reg), __ $4);\n-    } else {\n-      __ vector_round_neon(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-                           as_FloatRegister($tmp1$$reg), as_FloatRegister($tmp2$$reg),\n-                           as_FloatRegister($tmp3$$reg),\n-                           __ esize2arrangement(type2aelembytes(bt),\n-                              \/*isQ*\/ vlen == 16));\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl           $1  $2  $3 $4 $5    $6    $7\n-VECTOR_JAVA_FROUND(F, 8F,  I, S, 8,  INT, vReg)\n-VECTOR_JAVA_FROUND(D, 4D,  L, D, 4, LONG, vReg)\n-dnl\n-dnl REPLICATE($1,        $2,      $3,      $4,   $5         )\n-dnl REPLICATE(insn_name, op_name, reg_src, size, min_vec_len)\n-define(`REPLICATE', `\n-instruct $1(vReg dst, $3 src) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst ($2 src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_dup  $dst, $src\\t# vector (sve) ($4)\" %}\n-  ins_encode %{\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ $4, as_Register($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl REPLICATE_IMM8($1,        $2,      $3,       $4,   $5         )\n-dnl REPLICATE_IMM8(insn_name, op_name, imm_type, size, min_vec_len)\n-define(`REPLICATE_IMM8', `\n-instruct $1(vReg dst, $3 con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst ($2 con));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_dup  $dst, $con\\t# vector (sve) ($4)\" %}\n-  ins_encode %{\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ $4, $con$$constant);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl FREPLICATE($1,        $2,      $3,        $4)\n-dnl FREPLICATE(insn_name, op_name, reg_src, size)\n-define(`FREPLICATE', `\n-instruct $1(vReg dst, $3 src) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst ($2 src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_cpy  $dst, $src\\t# vector (sve) ($4)\" %}\n-  ins_encode %{\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ $4,\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-\n-\/\/ vector replicate\n-REPLICATE(replicateB, ReplicateB, iRegIorL2I, B, 16)\n-REPLICATE(replicateS, ReplicateS, iRegIorL2I, H, 8)\n-REPLICATE(replicateI, ReplicateI, iRegIorL2I, S, 4)\n-REPLICATE(replicateL, ReplicateL, iRegL,      D, 2)\n-REPLICATE_IMM8(replicateB_imm8, ReplicateB, immI8,        B, 16)\n-REPLICATE_IMM8(replicateS_imm8, ReplicateS, immI8_shift8, H, 8)\n-REPLICATE_IMM8(replicateI_imm8, ReplicateI, immI8_shift8, S, 4)\n-REPLICATE_IMM8(replicateL_imm8, ReplicateL, immL8_shift8, D, 2)\n-FREPLICATE(replicateF, ReplicateF, vRegF, S, 4)\n-FREPLICATE(replicateD, ReplicateD, vRegD, D, 2)\n-dnl\n-dnl VSHIFT_TRUE_PREDICATE($1,        $2,      $3,   $4,          $5  )\n-dnl VSHIFT_TRUE_PREDICATE(insn_name, op_name, size, min_vec_len, insn)\n-define(`VSHIFT_TRUE_PREDICATE', `\n-instruct $1(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst ($2 dst shift));\n-  ins_cost(SVE_COST);\n-  format %{ \"$5 $dst, $dst, $shift\\t# vector (sve) ($3)\" %}\n-  ins_encode %{\n-    __ $5(as_FloatRegister($dst$$reg), __ $3,\n-         ptrue, as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl VSHIFT_IMM_UNPREDICATED($1,        $2,      $3,       $4,   $5,          $6  )\n-dnl VSHIFT_IMM_UNPREDICATED(insn_name, op_name, op_name2, size, min_vec_len, insn)\n-define(`VSHIFT_IMM_UNPREDICATED', `\n-instruct $1(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst ($2 src ($3 shift)));\n-  ins_cost(SVE_COST);\n-  format %{ \"$6 $dst, $src, $shift\\t# vector (sve) ($4)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;dnl\n-ifelse(eval(index(`$1', `vasr') == 0 || index(`$1', `vlsr') == 0), 1, `\n-    if (con == 0) {\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }')dnl\n-ifelse(eval(index(`$1', `vasr') == 0), 1, `ifelse(eval(index(`$4', `B') == 0), 1, `\n-    if (con >= 8) con = 7;')ifelse(eval(index(`$4', `H') == 0), 1, `\n-    if (con >= 16) con = 15;')')dnl\n-ifelse(eval(index(`$1', `vlsl') == 0  || index(`$1', `vlsr') == 0), 1, `ifelse(eval(index(`$4', `B') == 0), 1, `\n-    if (con >= 8) {\n-      __ sve_eor(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }')ifelse(eval(index(`$4', `H') == 0), 1, `\n-    if (con >= 16) {\n-      __ sve_eor(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }')')\n-    __ $6(as_FloatRegister($dst$$reg), __ $4,\n-         as_FloatRegister($src$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl VSHIFT_COUNT($1,        $2,   $3,          $4  )\n-dnl VSHIFT_COUNT(insn_name, size, min_vec_len, type)\n-define(`VSHIFT_COUNT', `\n-instruct $1(vReg dst, iRegIorL2I cnt) %{\n-  predicate(UseSVE > 0 &&\n-            ELEMENT_SHORT_CHAR($4, n));\n-  match(Set dst (LShiftCntV cnt));\n-  match(Set dst (RShiftCntV cnt));\n-  format %{ \"sve_dup $dst, $cnt\\t# vector shift count (sve) ($2)\" %}\n-  ins_encode %{\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ $2, as_Register($cnt$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-\n-\/\/ vector shift\n-VSHIFT_TRUE_PREDICATE(vasrB, RShiftVB,  B, 16, sve_asr)\n-VSHIFT_TRUE_PREDICATE(vasrS, RShiftVS,  H,  8, sve_asr)\n-VSHIFT_TRUE_PREDICATE(vasrI, RShiftVI,  S,  4, sve_asr)\n-VSHIFT_TRUE_PREDICATE(vasrL, RShiftVL,  D,  2, sve_asr)\n-VSHIFT_TRUE_PREDICATE(vlslB, LShiftVB,  B, 16, sve_lsl)\n-VSHIFT_TRUE_PREDICATE(vlslS, LShiftVS,  H,  8, sve_lsl)\n-VSHIFT_TRUE_PREDICATE(vlslI, LShiftVI,  S,  4, sve_lsl)\n-VSHIFT_TRUE_PREDICATE(vlslL, LShiftVL,  D,  2, sve_lsl)\n-VSHIFT_TRUE_PREDICATE(vlsrB, URShiftVB, B, 16, sve_lsr)\n-VSHIFT_TRUE_PREDICATE(vlsrS, URShiftVS, H,  8, sve_lsr)\n-VSHIFT_TRUE_PREDICATE(vlsrI, URShiftVI, S,  4, sve_lsr)\n-VSHIFT_TRUE_PREDICATE(vlsrL, URShiftVL, D,  2, sve_lsr)\n-VSHIFT_IMM_UNPREDICATED(vasrB_imm, RShiftVB,  RShiftCntV, B, 16, sve_asr)\n-VSHIFT_IMM_UNPREDICATED(vasrS_imm, RShiftVS,  RShiftCntV, H,  8, sve_asr)\n-VSHIFT_IMM_UNPREDICATED(vasrI_imm, RShiftVI,  RShiftCntV, S,  4, sve_asr)\n-VSHIFT_IMM_UNPREDICATED(vasrL_imm, RShiftVL,  RShiftCntV, D,  2, sve_asr)\n-VSHIFT_IMM_UNPREDICATED(vlsrB_imm, URShiftVB, RShiftCntV, B, 16, sve_lsr)\n-VSHIFT_IMM_UNPREDICATED(vlsrS_imm, URShiftVS, RShiftCntV, H,  8, sve_lsr)\n-VSHIFT_IMM_UNPREDICATED(vlsrI_imm, URShiftVI, RShiftCntV, S,  4, sve_lsr)\n-VSHIFT_IMM_UNPREDICATED(vlsrL_imm, URShiftVL, RShiftCntV, D,  2, sve_lsr)\n-VSHIFT_IMM_UNPREDICATED(vlslB_imm, LShiftVB,  LShiftCntV, B, 16, sve_lsl)\n-VSHIFT_IMM_UNPREDICATED(vlslS_imm, LShiftVS,  LShiftCntV, H,  8, sve_lsl)\n-VSHIFT_IMM_UNPREDICATED(vlslI_imm, LShiftVI,  LShiftCntV, S,  4, sve_lsl)\n-VSHIFT_IMM_UNPREDICATED(vlslL_imm, LShiftVL,  LShiftCntV, D,  2, sve_lsl)\n-VSHIFT_COUNT(vshiftcntB, B, 16, T_BYTE)\n-VSHIFT_COUNT(vshiftcntS, H,  8, T_SHORT)\n-VSHIFT_COUNT(vshiftcntI, S,  4, T_INT)\n-VSHIFT_COUNT(vshiftcntL, D,  2, T_LONG)\n-\n-\/\/ vector shift - predicated\n-BINARY_OP_PREDICATE(vasrB, RShiftVB,  B, sve_asr)\n-BINARY_OP_PREDICATE(vasrS, RShiftVS,  H, sve_asr)\n-BINARY_OP_PREDICATE(vasrI, RShiftVI,  S, sve_asr)\n-BINARY_OP_PREDICATE(vasrL, RShiftVL,  D, sve_asr)\n-BINARY_OP_PREDICATE(vlslB, LShiftVB,  B, sve_lsl)\n-BINARY_OP_PREDICATE(vlslS, LShiftVS,  H, sve_lsl)\n-BINARY_OP_PREDICATE(vlslI, LShiftVI,  S, sve_lsl)\n-BINARY_OP_PREDICATE(vlslL, LShiftVL,  D, sve_lsl)\n-BINARY_OP_PREDICATE(vlsrB, URShiftVB, B, sve_lsr)\n-BINARY_OP_PREDICATE(vlsrS, URShiftVS, H, sve_lsr)\n-BINARY_OP_PREDICATE(vlsrI, URShiftVI, S, sve_lsr)\n-BINARY_OP_PREDICATE(vlsrL, URShiftVL, D, sve_lsr)\n-dnl\n-dnl VSHIFT_IMM_PREDICATED($1,        $2,      $3,       $4,   $5,   $6  )\n-dnl VSHIFT_IMM_PREDICATED(insn_name, op_name, op_name2, type, size, insn)\n-define(`VSHIFT_IMM_PREDICATED', `\n-instruct $1_imm_masked(vReg dst_src, immI shift, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src ($2 (Binary dst_src ($3 shift)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"$6 $dst_src, $pg, $dst_src, $shift\\t# vector (sve) ($4)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    assert(con ifelse(index(`$1', `vlsl'), 0, `>=', `>') 0 && con < $5, \"invalid shift immediate\");\n-    __ $6(as_FloatRegister($dst_src$$reg), __ $4, as_PRegister($pg$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-VSHIFT_IMM_PREDICATED(vasrB, RShiftVB,  RShiftCntV, B, 8,  sve_asr)\n-VSHIFT_IMM_PREDICATED(vasrS, RShiftVS,  RShiftCntV, H, 16, sve_asr)\n-VSHIFT_IMM_PREDICATED(vasrI, RShiftVI,  RShiftCntV, S, 32, sve_asr)\n-VSHIFT_IMM_PREDICATED(vasrL, RShiftVL,  RShiftCntV, D, 64, sve_asr)\n-VSHIFT_IMM_PREDICATED(vlsrB, URShiftVB, RShiftCntV, B, 8,  sve_lsr)\n-VSHIFT_IMM_PREDICATED(vlsrS, URShiftVS, RShiftCntV, H, 16, sve_lsr)\n-VSHIFT_IMM_PREDICATED(vlsrI, URShiftVI, RShiftCntV, S, 32, sve_lsr)\n-VSHIFT_IMM_PREDICATED(vlsrL, URShiftVL, RShiftCntV, D, 64, sve_lsr)\n-VSHIFT_IMM_PREDICATED(vlslB, LShiftVB,  LShiftCntV, B, 8,  sve_lsl)\n-VSHIFT_IMM_PREDICATED(vlslS, LShiftVS,  LShiftCntV, H, 16, sve_lsl)\n-VSHIFT_IMM_PREDICATED(vlslI, LShiftVI,  LShiftCntV, S, 32, sve_lsl)\n-VSHIFT_IMM_PREDICATED(vlslL, LShiftVL,  LShiftCntV, D, 64, sve_lsl)\n-\n-\/\/ vector sqrt\n-UNARY_OP_TRUE_PREDICATE(vsqrtF, SqrtVF, S, sve_fsqrt)\n-UNARY_OP_TRUE_PREDICATE(vsqrtD, SqrtVD, D, sve_fsqrt)\n-\n-\/\/ vector sqrt - predicated\n-UNARY_OP_PREDICATE(vsqrtF, SqrtVF, S, sve_fsqrt)\n-UNARY_OP_PREDICATE(vsqrtD, SqrtVD, D, sve_fsqrt)\n-\n-\/\/ vector sub\n-BINARY_OP_UNPREDICATE(vsubB, SubVB, B, 16, sve_sub)\n-BINARY_OP_UNPREDICATE(vsubS, SubVS, H, 8, sve_sub)\n-BINARY_OP_UNPREDICATE(vsubI, SubVI, S, 4, sve_sub)\n-BINARY_OP_UNPREDICATE(vsubL, SubVL, D, 2, sve_sub)\n-BINARY_OP_UNPREDICATE(vsubF, SubVF, S, 4, sve_fsub)\n-BINARY_OP_UNPREDICATE(vsubD, SubVD, D, 2, sve_fsub)\n-\n-\/\/ vector sub - predicated\n-BINARY_OP_PREDICATE(vsubB, SubVB, B, sve_sub)\n-BINARY_OP_PREDICATE(vsubS, SubVS, H, sve_sub)\n-BINARY_OP_PREDICATE(vsubI, SubVI, S, sve_sub)\n-BINARY_OP_PREDICATE(vsubL, SubVL, D, sve_sub)\n-BINARY_OP_PREDICATE(vsubF, SubVF, S, sve_fsub)\n-BINARY_OP_PREDICATE(vsubD, SubVD, D, sve_fsub)\n-\n-\/\/ ------------------------------ Vector mask cast --------------------------\n-\n-instruct vmaskcast(pRegGov dst_src) %{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->length() == n->in(1)->bottom_type()->is_vect()->length() &&\n-            n->bottom_type()->is_vect()->length_in_bytes() == n->in(1)->bottom_type()->is_vect()->length_in_bytes());\n-  match(Set dst_src (VectorMaskCast dst_src));\n-  ins_cost(0);\n-  format %{ \"vmaskcast $dst_src\\t# empty (sve)\" %}\n-  ins_encode %{\n-    \/\/ empty\n-  %}\n-  ins_pipe(pipe_class_empty);\n-%}\n-\n-instruct vmaskcast_extend(pRegGov dst, pReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            (Matcher::vector_length_in_bytes(n) == 2 * Matcher::vector_length_in_bytes(n->in(1)) ||\n-             Matcher::vector_length_in_bytes(n) == 4 * Matcher::vector_length_in_bytes(n->in(1)) ||\n-             Matcher::vector_length_in_bytes(n) == 8 * Matcher::vector_length_in_bytes(n->in(1))));\n-  match(Set dst (VectorMaskCast src));\n-  ins_cost(SVE_COST * 3);\n-  format %{ \"sve_vmaskcast_extend  $dst, $src\\t# extend predicate $src\" %}\n-  ins_encode %{\n-    __ sve_vmaskcast_extend(as_PRegister($dst$$reg), as_PRegister($src$$reg),\n-                            Matcher::vector_length_in_bytes(this), Matcher::vector_length_in_bytes(this, $src));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmaskcast_narrow(pRegGov dst, pReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            (Matcher::vector_length_in_bytes(n) * 2 == Matcher::vector_length_in_bytes(n->in(1)) ||\n-             Matcher::vector_length_in_bytes(n) * 4 == Matcher::vector_length_in_bytes(n->in(1)) ||\n-             Matcher::vector_length_in_bytes(n) * 8 == Matcher::vector_length_in_bytes(n->in(1))));\n-  match(Set dst (VectorMaskCast src));\n-  ins_cost(SVE_COST * 3);\n-  format %{ \"sve_vmaskcast_narrow  $dst, $src\\t# narrow predicate $src\" %}\n-  ins_encode %{\n-    __ sve_vmaskcast_narrow(as_PRegister($dst$$reg), as_PRegister($src$$reg),\n-                            Matcher::vector_length_in_bytes(this), Matcher::vector_length_in_bytes(this, $src));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-dnl\n-\n-\/\/ ------------------------------ Vector cast -------------------------------\n-dnl\n-dnl\n-define(`VECTOR_CAST_X2X', `\n-instruct vcvt$1to$2`'(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n-  match(Set dst (VectorCast$1`'2X src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_vectorcast_$5  $dst, $src\\t# convert $1 to $2 vector\" %}\n-  ins_encode %{\n-    __ sve_$3(as_FloatRegister($dst$$reg), __ $4, ptrue, as_FloatRegister($src$$reg), __ $4);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-\n-dnl\n-dnl Start of vector cast rules\n-dnl\n-instruct vcvtBtoX_extend(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorCastB2X src));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_vectorcast_b2x  $dst, $src\\t# convert B to X vector (extend)\" %}\n-  ins_encode %{\n-    BasicType to_bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n-    __ sve_vector_extend(as_FloatRegister($dst$$reg), to_size, as_FloatRegister($src$$reg), __ B);\n-    if (to_bt == T_FLOAT || to_bt == T_DOUBLE) {\n-      __ sve_scvtf(as_FloatRegister($dst$$reg), to_size, ptrue, as_FloatRegister($dst$$reg), to_size);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtStoB(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorCastS2X src));\n-  effect(TEMP tmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_vectorcast_s2b  $dst, $src\\t# convert H to B vector\" %}\n-  ins_encode %{\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ B,\n-                         as_FloatRegister($src$$reg), __ H, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtStoX_extend(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            type2aelembytes(Matcher::vector_element_basic_type(n)) > 2);\n-  match(Set dst (VectorCastS2X src));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_vectorcast_s2x  $dst, $src\\t# convert H to X vector (extend)\" %}\n-  ins_encode %{\n-    BasicType to_bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n-    __ sve_vector_extend(as_FloatRegister($dst$$reg), to_size, as_FloatRegister($src$$reg), __ H);\n-    if (to_bt == T_FLOAT || to_bt == T_DOUBLE) {\n-      __ sve_scvtf(as_FloatRegister($dst$$reg), to_size, ptrue, as_FloatRegister($dst$$reg), to_size);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtItoB(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorCastI2X src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_vectorcast_i2b  $dst, $src\\t# convert I to B vector\" %}\n-  ins_encode %{\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ B,\n-                         as_FloatRegister($src$$reg), __ S, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtItoS(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorCastI2X src));\n-  effect(TEMP tmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_vectorcast_i2s $dst, $src\\t# convert I to H vector\" %}\n-  ins_encode %{\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ H,\n-                         as_FloatRegister($src$$reg), __ S, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtItoL(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorCastI2X src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_vectorcast_i2l  $dst, $src\\t# convert I to L vector\" %}\n-  ins_encode %{\n-    __ sve_vector_extend(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg), __ S);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-dnl\n-dnl vcvtItoF\n-VECTOR_CAST_X2X(I, F, scvtf, S, i2f)\n-\n-instruct vcvtItoD(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorCastI2X src));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_vectorcast_i2d  $dst, $src\\t# convert I to D vector\" %}\n-  ins_encode %{\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg));\n-    __ sve_scvtf(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($dst$$reg), __ D);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtLtoX_narrow(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 && is_integral_type(Matcher::vector_element_basic_type(n)));\n-  match(Set dst (VectorCastL2X src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_vectorcast_l2x  $dst, $src\\t# convert L to B\/H\/S vector (narrow)\" %}\n-  ins_encode %{\n-    BasicType to_bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), to_size,\n-                         as_FloatRegister($src$$reg), __ D, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtLtoF(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorCastL2X src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_vectorcast_l2f  $dst, $src\\t# convert L to F vector\" %}\n-  ins_encode %{\n-    __ sve_scvtf(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ D);\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ S,\n-                         as_FloatRegister($dst$$reg), __ D, as_FloatRegister($tmp$$reg));\n-\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-dnl\n-dnl vcvtLtoD\n-VECTOR_CAST_X2X(L, D, scvtf, D, l2d)\n-\n-instruct vcvtFtoX_narrow(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT));\n-  match(Set dst (VectorCastF2X src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_vectorcast_f2x  $dst, $src\\t# convert F to B\/H vector\" %}\n-  ins_encode %{\n-    BasicType to_bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n-    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ S);\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), to_size,\n-                         as_FloatRegister($dst$$reg), __ S, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtFtoI(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n-  match(Set dst (VectorCastF2X src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_vectorcast_f2x  $dst, $src\\t# convert F to I vector\" %}\n-  ins_encode %{\n-    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ S);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtFtoL(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_LONG));\n-  match(Set dst (VectorCastF2X src));\n-  ins_cost(SVE_COST * 2);\n-  format %{ \"sve_vectorcast_f2x  $dst, $src\\t# convert F to L vector\" %}\n-  ins_encode %{\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg));\n-    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($dst$$reg), __ S);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtFtoD(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorCastF2X src));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_vectorcast_f2d  $dst, $dst\\t# convert F to D vector\" %}\n-  ins_encode %{\n-    __ sve_vector_extend(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg), __ S);\n-    __ sve_fcvt(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($dst$$reg), __ S);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtDtoX_narrow(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n-  match(Set dst (VectorCastD2X src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_vectorcast_d2x  $dst, $src\\t# convert D to X vector (narrow)\" %}\n-  ins_encode %{\n-    BasicType to_bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n-    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ D);\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), to_size,\n-                         as_FloatRegister($dst$$reg), __ D, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-dnl\n-dnl vcvtDtoL\n-VECTOR_CAST_X2X(D, L, fcvtzs, D, d2l)\n-\n-instruct vcvtDtoF(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorCastD2X src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_vectorcast_d2f  $dst, S, $dst\\t# convert D to F vector\" %}\n-  ins_encode %{\n-    __ sve_fcvt(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ D);\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ S,\n-                         as_FloatRegister($dst$$reg), __ D, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-dnl\n-dnl\n-\/\/ ------------------------------ Vector extract ---------------------------------\n-dnl\n-define(`VECTOR_EXTRACT_I', `\n-instruct extract$1`'($3 dst, vReg src, immI idx, vReg vtmp)\n-%{\n-  predicate(UseSVE > 0 && n->in(2)->get_int() >= $2);\n-  match(Set dst (Extract$1 src idx));\n-  effect(TEMP vtmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_extract_integral $dst, $4, $src, $idx\\t# extract from vector($1)\" %}\n-  ins_encode %{\n-    __ sve_extract_integral(as_Register($dst$$reg), __ $4, as_FloatRegister($src$$reg),\n-                            (int)($idx$$constant), \/* is_signed *\/ ifelse($1, L, false, true), as_FloatRegister($vtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl              $1 $2  $3         $4\n-VECTOR_EXTRACT_I(B, 16, iRegINoSp, B)\n-VECTOR_EXTRACT_I(S, 8,  iRegINoSp, H)\n-VECTOR_EXTRACT_I(I, 4,  iRegINoSp, S)\n-VECTOR_EXTRACT_I(L, 2,  iRegLNoSp, D)\n-dnl\n-define(`VECTOR_EXTRACT_I_LT', `\n-instruct extract$1_LT$2`'($3 dst, vReg src, immI idx)\n-%{\n-  predicate(UseSVE > 0 && n->in(2)->get_int() < $2);\n-  match(Set dst (Extract$1 src idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"ifelse($4, D, umov, smov) $dst, $4, $src, $idx\\t# extract from vector($1)\" %}\n-  ins_encode %{\n-    __ ifelse($4, D, umov, smov)(as_Register($dst$$reg), as_FloatRegister($src$$reg), __ $4, $idx$$constant);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl                 $1  $2  $3         $4\n-VECTOR_EXTRACT_I_LT(B,  16, iRegINoSp, B)\n-VECTOR_EXTRACT_I_LT(S,  8,  iRegINoSp, H)\n-VECTOR_EXTRACT_I_LT(I,  4,  iRegINoSp, S)\n-VECTOR_EXTRACT_I_LT(L,  2,  iRegLNoSp, D)\n-\n-instruct extractF(vRegF dst, vReg src, immI idx)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst (ExtractF src idx));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_extract_f $dst, S, $src, $idx\\t# extract from vector(F)\" %}\n-  ins_encode %{\n-    if ((as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg)) && ($idx$$constant == 0)) {\n-      \/* empty *\/\n-    } else if ($idx$$constant == 0) {\n-      __ fmovs(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n-    } else if ($idx$$constant < 4) {\n-      __ ins(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg), 0, (int)($idx$$constant));\n-    } else {\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-      __ sve_ext(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), $idx$$constant << 2);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct extractD(vRegD dst, vReg src, immI idx)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst (ExtractD src idx));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_extract_d $dst, D, $src, $idx\\t# extract from vector(D)\" %}\n-  ins_encode %{\n-    if ((as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg)) && ($idx$$constant == 0)) {\n-      \/* empty *\/\n-    } else if ($idx$$constant == 0) {\n-      __ fmovd(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n-    } else if ($idx$$constant == 1) {\n-      __ ins(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg), 0, 1);\n-    } else {\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-      __ sve_ext(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), $idx$$constant << 3);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------- VectorTest ----------------------------------\n-\n-instruct vtest_alltrue(iRegINoSp dst, pRegGov src1, pRegGov src2, pReg ptmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 &&\n-            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow);\n-  match(Set dst (VectorTest src1 src2));\n-  effect(TEMP ptmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_eors $ptmp, $src1, $src2\\t# $src2 is all true mask\\n\"\n-            \"csetw $dst, EQ\\t# VectorTest (sve) - alltrue\" %}\n-  ins_encode %{\n-    __ sve_eors(as_PRegister($ptmp$$reg), ptrue,\n-                as_PRegister($src1$$reg), as_PRegister($src2$$reg));\n-    __ csetw(as_Register($dst$$reg), Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vtest_anytrue(iRegINoSp dst, pRegGov src1, pRegGov src2, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 &&\n-            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::ne);\n-  match(Set dst (VectorTest src1 src2));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_ptest $src1\\n\\t\"\n-            \"csetw $dst, NE\\t# VectorTest (sve) - anytrue\" %}\n-  ins_encode %{\n-    \/\/ \"src2\" is not used for sve.\n-    __ sve_ptest(ptrue, as_PRegister($src1$$reg));\n-    __ csetw(as_Register($dst$$reg), Assembler::NE);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-dnl\n-\/\/ ------------------------------ Vector insert ---------------------------------\n-\n-instruct insertI_le128bits(vReg dst, vReg src, iRegIorL2I val, immI idx) %{\n-  predicate(UseSVE > 0 &&\n-            (Matcher::vector_length_in_bytes(n) == 8 || Matcher::vector_length_in_bytes(n) == 16) &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(2 * INSN_COST);\n-  format %{ \"orr    $dst, T8\/16B, $src, $src\\n\\t\"\n-            \"mov    $dst, B\/H\/S, $idx, $val\\t# insertI into vector(64\/128bits)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ orr(as_FloatRegister($dst$$reg), Matcher::vector_length_in_bytes(this) == 8 ? __ T8B : __ T16B,\n-             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    }\n-    __ mov(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(Matcher::vector_element_basic_type(this)),\n-           $idx$$constant, $val$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertI_small_index(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg vtmp, pRegGov pgtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->in(2)->get_int() < 32 &&\n-            Matcher::vector_length_in_bytes(n) > 16 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  effect(TEMP vtmp, TEMP pgtmp, KILL cr);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_index $vtmp, -16, 1\\t# (B\/H\/S)\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $vtmp, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n-            \"sve_orr $dst, $src, $src\\n\\t\"\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (B\/H\/S)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ block_comment(\"insert into vector (B\/H\/S) {\");\n-      __ sve_index(as_FloatRegister($vtmp$$reg), size, -16, 1);\n-      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), size, ptrue,\n-                 as_FloatRegister($vtmp$$reg), (int)($idx$$constant) - 16);\n-      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-      }\n-      __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pgtmp$$reg), $val$$Register);\n-    __ block_comment(\"} insert into vector (B\/H\/S)\");\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertI(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg vtmp1, vReg vtmp2, pRegGov pgtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->in(2)->get_int() >= 32 &&\n-            Matcher::vector_length_in_bytes(n) > 16 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  effect(TEMP vtmp1, TEMP vtmp2, TEMP pgtmp, KILL cr);\n-  ins_cost(5 * SVE_COST);\n-  format %{ \"sve_index $vtmp1, 0, 1\\t# (B\/H\/S)\\n\\t\"\n-            \"sve_dup $vtmp2, $idx\\t# (B\/H\/S)\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $vtmp1, $vtmp2\\n\\t\"\n-            \"sve_orr $dst, $src, $src\\n\\t\"\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (B\/H\/S)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ block_comment(\"insert into vector (B\/H\/S) {\");\n-      __ sve_index(as_FloatRegister($vtmp1$$reg), size, 0, 1);\n-      __ sve_dup(as_FloatRegister($vtmp2$$reg), size, (int)($idx$$constant));\n-      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), size, ptrue,\n-                 as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n-      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-      }\n-      __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pgtmp$$reg), $val$$Register);\n-    __ block_comment(\"} insert into vector (B\/H\/S)\");\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertL_128bits(vReg dst, vReg src, iRegL val, immI idx) %{\n-  predicate(UseSVE > 0 && Matcher::vector_length_in_bytes(n) == 16 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(2 * INSN_COST);\n-  format %{ \"orr    $dst, T16B, $src, $src\\n\\t\"\n-            \"mov    $dst, D, $idx, $val\\t# insertL into vector(128bits)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ orr(as_FloatRegister($dst$$reg), __ T16B,\n-             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    }\n-    __ mov(as_FloatRegister($dst$$reg), __ D, $idx$$constant, $val$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertL(vReg dst, vReg src, iRegL val, immI idx, vReg vtmp, pRegGov pgtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            Matcher::vector_length_in_bytes(n) > 16 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  effect(TEMP vtmp, TEMP pgtmp, KILL cr);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_index $vtmp, D, -16, 1\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $vtmp, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n-            \"sve_orr $dst, $src, $src\\n\\t\"\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (L)\" %}\n-  ins_encode %{\n-    __ block_comment(\"insert into vector (L) {\");\n-      __ sve_index(as_FloatRegister($vtmp$$reg), __ D, -16, 1);\n-      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ D, ptrue,\n-                 as_FloatRegister($vtmp$$reg), (int)($idx$$constant) - 16);\n-      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-      }\n-      __ sve_cpy(as_FloatRegister($dst$$reg), __ D,\n-                 as_PRegister($pgtmp$$reg), $val$$Register);\n-    __ block_comment(\"} insert into vector (L)\");\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertF_le128bits(vReg dst, vReg src, vRegF val, immI idx) %{\n-  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT &&\n-            (Matcher::vector_length_in_bytes(n) == 8 || Matcher::vector_length_in_bytes(n) == 16));\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(2 * INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"orr    $dst, T8\/16B, $src, $src\\n\\t\"\n-            \"ins    $dst, S, $val, $idx, 0\\t# insertF into vector(64\/128bits)\" %}\n-  ins_encode %{\n-    __ orr(as_FloatRegister($dst$$reg), Matcher::vector_length_in_bytes(this) == 8 ? __ T8B : __ T16B,\n-           as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ ins(as_FloatRegister($dst$$reg), __ S,\n-           as_FloatRegister($val$$reg), $idx$$constant, 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertF_small_index(vReg dst, vReg src, vRegF val, immI idx, pRegGov pgtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->in(2)->get_int() < 32 &&\n-            Matcher::vector_length_in_bytes(n) > 16 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_index $dst, S, -16, 1\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n-            \"sve_orr $dst, $src, $src\\n\\t\"\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (F)\" %}\n-  ins_encode %{\n-    __ block_comment(\"insert into vector (F) {\");\n-      __ sve_index(as_FloatRegister($dst$$reg), __ S, -16, 1);\n-      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ S, ptrue,\n-                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-      __ sve_cpy(as_FloatRegister($dst$$reg), __ S, as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n-    __ block_comment(\"} insert into vector (F)\");\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertF(vReg dst, vReg src, vRegF val, immI idx, vReg tmp1, pRegGov pgtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->in(2)->get_int() >= 32 &&\n-            Matcher::vector_length_in_bytes(n) > 16 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP pgtmp, KILL cr);\n-  ins_cost(5 * SVE_COST);\n-  format %{ \"sve_index $tmp1, S, 0, 1\\n\\t\"\n-            \"sve_dup $dst, S, $idx\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $tmp1, $dst\\n\\t\"\n-            \"sve_orr $dst, $src, $src\\n\\t\"\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (F)\" %}\n-  ins_encode %{\n-    __ block_comment(\"insert into vector (F) {\");\n-      __ sve_index(as_FloatRegister($tmp1$$reg), __ S, 0, 1);\n-      __ sve_dup(as_FloatRegister($dst$$reg), __ S, (int)($idx$$constant));\n-      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ S, ptrue,\n-                 as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-                 as_FloatRegister($src$$reg));\n-      __ sve_cpy(as_FloatRegister($dst$$reg), __ S,\n-                 as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n-    __ block_comment(\"} insert into vector (F)\");\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertD_128bits(vReg dst, vReg src, vRegD val, immI idx) %{\n-  predicate(UseSVE > 0 && Matcher::vector_length_in_bytes(n) == 16 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(2 * INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"orr    $dst, T16B, $src, $src\\n\\t\"\n-            \"ins    $dst, D, $val, $idx, 0\\t# insertD into vector(128bits)\" %}\n-  ins_encode %{\n-    __ orr(as_FloatRegister($dst$$reg), __ T16B,\n-           as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ ins(as_FloatRegister($dst$$reg), __ D,\n-           as_FloatRegister($val$$reg), $idx$$constant, 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertD(vReg dst, vReg src, vRegD val, immI idx, pRegGov pgtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            Matcher::vector_length_in_bytes(n) > 16 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_index $dst, D, -16, 1\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n-            \"sve_orr $dst, $src, $src\\n\\t\"\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (D)\" %}\n-  ins_encode %{\n-    __ block_comment(\"insert into vector (D) {\");\n-      __ sve_index(as_FloatRegister($dst$$reg), __ D, -16, 1);\n-      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ D, ptrue,\n-                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-                 as_FloatRegister($src$$reg));\n-      __ sve_cpy(as_FloatRegister($dst$$reg), __ D,\n-                 as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n-    __ block_comment(\"} insert into vector (D)\");\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector shuffle -------------------------------\n-\n-instruct loadshuffle(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorLoadShuffle src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_loadshuffle $dst, $src\\t# vector load shuffle (B\/H\/S\/D)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    if (bt == T_BYTE) {\n-      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-                   as_FloatRegister($src$$reg));\n-      }\n-    } else {\n-      __ sve_vector_extend(as_FloatRegister($dst$$reg),  __ elemType_to_regVariant(bt),\n-                           as_FloatRegister($src$$reg), __ B);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector rearrange -------------------------------\n-\n-instruct rearrange(vReg dst, vReg src, vReg shuffle)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorRearrange src shuffle));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_tbl $dst, $src, $shuffle\\t# vector rearrange\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_tbl(as_FloatRegister($dst$$reg), size,\n-               as_FloatRegister($src$$reg), as_FloatRegister($shuffle$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector Load Gather ---------------------------------\n-\n-instruct gatherI(vReg dst, indirect mem, vReg idx) %{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n-  match(Set dst (LoadVectorGather mem idx));\n-  ins_cost(SVE_COST);\n-  format %{ \"load_vector_gather $dst, $mem, $idx\\t# vector load gather (S)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_ld1w_gather(as_FloatRegister($dst$$reg), ptrue,\n-                       as_Register($mem$$base), as_FloatRegister($idx$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct gatherL(vReg dst, indirect mem, vReg idx, vReg tmp) %{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n-  match(Set dst (LoadVectorGather mem idx));\n-  effect(TEMP tmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"load_vector_gather $dst, $mem, $idx\\t# vector load gather (D)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_uunpklo(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($idx$$reg));\n-    __ sve_ld1d_gather(as_FloatRegister($dst$$reg), ptrue, as_Register($mem$$base),\n-                       as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector Load Gather Predicated -------------------------------\n-\n-instruct gatherI_masked(vReg dst, indirect mem, vReg idx, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx pg)));\n-  ins_cost(SVE_COST);\n-  format %{ \"load_vector_gather $dst, $pg, $mem, $idx\\t# vector load gather predicated (S)\" %}\n-  ins_encode %{\n-    __ sve_ld1w_gather(as_FloatRegister($dst$$reg), as_PRegister($pg$$reg),\n-                       as_Register($mem$$base), as_FloatRegister($idx$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct gatherL_masked(vReg dst, indirect mem, vReg idx, pRegGov pg, vReg tmp) %{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx pg)));\n-  effect(TEMP tmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"load_vector_gather $dst, $pg, $mem, $idx\\t# vector load gather predicated (D)\" %}\n-  ins_encode %{\n-    __ sve_uunpklo(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($idx$$reg));\n-    __ sve_ld1d_gather(as_FloatRegister($dst$$reg), as_PRegister($pg$$reg),\n-                       as_Register($mem$$base), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector Store Scatter -------------------------------\n-\n-instruct scatterI(indirect mem, vReg src, vReg idx) %{\n-  predicate(UseSVE > 0 &&\n-            (n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-             n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n-  match(Set mem (StoreVectorScatter mem (Binary src idx)));\n-  ins_cost(SVE_COST);\n-  format %{ \"store_vector_scatter $mem, $idx, $src\\t# vector store scatter (S)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_st1w_scatter(as_FloatRegister($src$$reg), ptrue,\n-                        as_Register($mem$$base), as_FloatRegister($idx$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct scatterL(indirect mem, vReg src, vReg idx, vReg tmp) %{\n-  predicate(UseSVE > 0 &&\n-            (n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n-             n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n-  match(Set mem (StoreVectorScatter mem (Binary src idx)));\n-  effect(TEMP tmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"store_vector_scatter $mem, $idx, $src\\t# vector store scatter (D)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_uunpklo(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($idx$$reg));\n-    __ sve_st1d_scatter(as_FloatRegister($src$$reg), ptrue,\n-                        as_Register($mem$$base), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector Store Scatter Predicated -------------------------------\n-\n-instruct scatterI_masked(indirect mem, vReg src, vReg idx, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            (n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-             n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n-  match(Set mem (StoreVectorScatterMasked mem (Binary src (Binary idx pg))));\n-  ins_cost(SVE_COST);\n-  format %{ \"store_vector_scatter $mem, $pg, $idx, $src\\t# vector store scatter predicate (S)\" %}\n-  ins_encode %{\n-    __ sve_st1w_scatter(as_FloatRegister($src$$reg), as_PRegister($pg$$reg),\n-                        as_Register($mem$$base), as_FloatRegister($idx$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct scatterL_masked(indirect mem, vReg src, vReg idx, pRegGov pg, vReg tmp) %{\n-  predicate(UseSVE > 0 &&\n-            (n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n-             n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n-  match(Set mem (StoreVectorScatterMasked mem (Binary src (Binary idx pg))));\n-  effect(TEMP tmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"store_vector_scatter $mem, $pg, $idx, $src\\t# vector store scatter predicated (D)\" %}\n-  ins_encode %{\n-    __ sve_uunpklo(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($idx$$reg));\n-    __ sve_st1d_scatter(as_FloatRegister($src$$reg), as_PRegister($pg$$reg),\n-                        as_Register($mem$$base), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector Load Const -------------------------------\n-\n-instruct loadconB(vReg dst, immI0 src) %{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorLoadConst src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_index $dst, 0, 1\\t# generate iota indices\" %}\n-  ins_encode %{\n-    __ sve_index(as_FloatRegister($dst$$reg), __ B, 0, 1);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ -------------------------- Populate Index to a Vector --------------------------\n-\n-instruct populateindex(vReg dst, iRegIorL2I src1, immI src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (PopulateIndex src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_index $dst, $src1, $src2\\t # populate index (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_index(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(bt),\n-                 as_Register($src1$$reg), $src2$$constant);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ----------------------------- String Intrinsics -------------------------------\n-\n-\/\/ Intrisics for String.indexOf(char)\n-\n-dnl\n-define(`STRING_INDEXOF_CHAR', `\n-instruct string$1_indexof_char_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegI_R3 ch,\n-                                  iRegI_R0 result, vReg ztmp1, vReg ztmp2,\n-                                  pRegGov pgtmp, pReg ptmp, rFlagsReg cr)\n-%{\n-  match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));\n-  predicate((UseSVE > 0) && (((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::$1));\n-  effect(TEMP ztmp1, TEMP ztmp2, TEMP pgtmp, TEMP ptmp, KILL cr);\n-\n-  format %{ \"String$2 IndexOf char[] $str1,$cnt1,$ch -> $result # use sve\" %}\n-\n-  ins_encode %{\n-    __ string_indexof_char_sve($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,\n-                               as_FloatRegister($ztmp1$$reg), as_FloatRegister($ztmp2$$reg),\n-                               as_PRegister($pgtmp$$reg), as_PRegister($ptmp$$reg), $3 \/* isL *\/);\n-  %}\n-  ins_pipe(pipe_class_memory);\n-%}')dnl\n-dnl                 $1 $2      $3\n-STRING_INDEXOF_CHAR(L, Latin1, true)\n-STRING_INDEXOF_CHAR(U, UTF16,  false)\n-\n-\/\/ Intrisics for String.compareTo()\n-\n-\/\/ Note that Z registers alias the corresponding NEON registers, we declare the vector operands of\n-\/\/ these string_compare variants as NEON register type for convenience so that the prototype of\n-\/\/ string_compare can be shared with all variants.\n-\n-dnl\n-define(`STRING_COMPARETO', `\n-instruct string_compare$1_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n-                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n-                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n-                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n-%{\n-  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::$1));\n-  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n-  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n-         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n-\n-  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n-  ins_encode %{\n-    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n-    __ string_compare($str1$$Register, $str2$$Register,\n-                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n-                      $tmp1$$Register, $tmp2$$Register,\n-                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n-                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n-                      StrIntrinsicNode::$1);\n-  %}\n-  ins_pipe(pipe_class_memory);\n-%}')dnl\n-dnl              $1\n-STRING_COMPARETO(LL)\n-STRING_COMPARETO(LU)\n-STRING_COMPARETO(UL)\n-STRING_COMPARETO(UU)\n-\n-\/\/ ---------------------------- Vector mask reductions ---------------------------\n-instruct vmask_truecount(iRegINoSp dst, pReg src) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorMaskTrueCount src));\n-  ins_cost(SVE_COST);\n-  format %{ \"vmask_truecount $dst, $src\\t# vector mask truecount (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_cntp($dst$$Register, size, ptrue, as_PRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Return the index of the first mask lane that is set, or vector length if none of\n-\/\/ them are set.\n-instruct vmask_firsttrue(iRegINoSp dst, pReg src, pReg ptmp) %{\n-  predicate(UseSVE > 0 && !n->is_predicated_vector());\n-  match(Set dst (VectorMaskFirstTrue src));\n-  effect(TEMP ptmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"vmask_firsttrue $dst, $src\\t# vector mask firsttrue (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src) == MaxVectorSize, \"invalid vector length\");\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_brkb(as_PRegister($ptmp$$reg), ptrue, as_PRegister($src$$reg), false);\n-    __ sve_cntp($dst$$Register, size, ptrue, as_PRegister($ptmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_firsttrue_masked(iRegINoSp dst, pReg src, pRegGov pg, pReg ptmp) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorMaskFirstTrue src pg));\n-  effect(TEMP ptmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"vmask_firsttrue $dst, $pg, $src\\t# vector mask firsttrue (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_brkb(as_PRegister($ptmp$$reg), as_PRegister($pg$$reg), as_PRegister($src$$reg), false);\n-    __ sve_cntp($dst$$Register, size, ptrue, as_PRegister($ptmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_lasttrue(iRegINoSp dst, pReg src, pReg ptmp) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorMaskLastTrue src));\n-  effect(TEMP ptmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"vmask_lasttrue $dst, $src\\t# vector mask lasttrue (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    __ sve_vmask_lasttrue($dst$$Register, bt, as_PRegister($src$$reg), as_PRegister($ptmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_tolong(iRegLNoSp dst, pReg src, vReg vtmp1, vReg vtmp2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorMaskToLong src));\n-  effect(TEMP vtmp1, TEMP vtmp2);\n-  ins_cost(13 * SVE_COST);\n-  format %{ \"vmask_tolong $dst, $src\\t# vector mask tolong (sve)\" %}\n-  ins_encode %{\n-    __ sve_vmask_tolong(as_Register($dst$$reg), as_PRegister($src$$reg),\n-                        Matcher::vector_element_basic_type(this, $src),\n-                        Matcher::vector_length(this, $src),\n-                        as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_fromlong(pRegGov dst, iRegL src, vReg vtmp1, vReg vtmp2) %{\n-  match(Set dst (VectorLongToMask src));\n-  effect(TEMP vtmp1, TEMP vtmp2);\n-  ins_cost(10 * SVE_COST);\n-  format %{ \"vmask_fromlong $dst, $src\\t# vector mask fromlong (sve2)\" %}\n-  ins_encode %{\n-    __ sve_vmask_fromlong(as_PRegister($dst$$reg), as_Register($src$$reg),\n-                          Matcher::vector_element_basic_type(this),\n-                          Matcher::vector_length(this),\n-                          as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ---------------------------- Vector mask generation ---------------------------\n-\/\/ The rules below set predicate registers. They can guarantee the high bits of dst\n-\/\/ are cleared with zero when the vector length is less than the full size of\n-\/\/ hardware vector register width.\n-\n-define(`MASKALL_IMM', `\n-instruct vmaskAll_imm$1(pRegGov dst, imm$1 src, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (MaskAll src));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_ptrue\/sve_pfalse $dst\\t# mask all (sve) ($2)\" %}\n-  ins_encode %{\n-    ifelse($1, `I', int, long) con = (ifelse($1, `I', int, long))$src$$constant;\n-    if (con == 0) {\n-      __ sve_pfalse(as_PRegister($dst$$reg));\n-    } else {\n-      assert(con == -1, \"invalid constant value for mask\");\n-      BasicType bt = Matcher::vector_element_basic_type(this);\n-      __ sve_gen_mask_imm(as_PRegister($dst$$reg), bt, Matcher::vector_length(this));\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl\n-define(`MASKALL', `\n-instruct vmaskAll$1(pRegGov dst, ifelse($1, `I', iRegIorL2I, iRegL) src, vReg tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && !n->is_predicated_vector());\n-  match(Set dst (MaskAll src));\n-  effect(TEMP tmp, KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_dup $tmp, $src\\n\\t\"\n-            \"sve_cmpne $dst, $dst, $tmp, 0\\t# mask all (sve) ($2)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this) == MaxVectorSize, \"invalid vector length\");\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_dup(as_FloatRegister($tmp$$reg), size, as_Register($src$$reg));\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($tmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl\n-define(`MASKALL_PREDICATE', `\n-instruct vmaskAll$1_masked(pRegGov dst, ifelse($1, `I', iRegIorL2I, iRegL) src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (MaskAll src pg));\n-  effect(TEMP tmp, KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_dup $tmp, $src\\n\\t\"\n-            \"sve_cmpne $dst, $pg, $dst, $tmp, 0\\t# mask all (sve) ($2)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_dup(as_FloatRegister($tmp$$reg), size, as_Register($src$$reg));\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size,\n-               as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\n-\/\/ maskAll\n-MASKALL_IMM(I, B\/H\/S)\n-MASKALL(I, B\/H\/S)\n-MASKALL_IMM(L, D)\n-MASKALL(L, D)\n-\n-\/\/ maskAll - predicated\n-MASKALL_PREDICATE(I, B\/H\/S)\n-MASKALL_PREDICATE(L, D)\n-\n-\/\/ vector mask compare\n-\n-instruct vmaskcmp(pRegGov dst, vReg src1, vReg src2, immI cond, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_cmp $dst, $src1, $src2\\t# vector mask cmp (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this) == MaxVectorSize, \"invalid vector length\");\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_compare(as_PRegister($dst$$reg), bt, ptrue, as_FloatRegister($src1$$reg),\n-                   as_FloatRegister($src2$$reg), (int)$cond$$constant);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmaskcmp_masked(pRegGov dst, vReg src1, vReg src2, immI cond, pRegGov pg, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) (Binary cond pg)));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_cmp $dst, $pg, $src1, $src2\\t# vector mask cmp (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_compare(as_PRegister($dst$$reg), bt, as_PRegister($pg$$reg), as_FloatRegister($src1$$reg),\n-                   as_FloatRegister($src2$$reg), (int)$cond$$constant);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector load mask\n-\n-instruct vloadmaskB(pRegGov dst, vReg src, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && !n->is_predicated_vector() &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorLoadMask src));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"vloadmaskB $dst, $src\\t# vector load mask (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ B,\n-               ptrue, as_FloatRegister($src$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vloadmask_extend(pRegGov dst, vReg src, vReg tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && !n->is_predicated_vector() &&\n-            n->bottom_type()->is_vect()->element_basic_type() != T_BYTE);\n-  match(Set dst (VectorLoadMask src));\n-  effect(TEMP tmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"vloadmask $dst, $src\\t# vector load mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_vector_extend(as_FloatRegister($tmp$$reg), size, as_FloatRegister($src$$reg), __ B);\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($tmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vloadmaskB_masked(pRegGov dst, vReg src, pRegGov pg, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorLoadMask src pg));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"vloadmaskB $dst, $pg, $src\\t# vector load mask (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ B,\n-               as_PRegister($pg$$reg), as_FloatRegister($src$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vloadmask_extend_masked(pRegGov dst, vReg src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() != T_BYTE);\n-  match(Set dst (VectorLoadMask src pg));\n-  effect(TEMP tmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"vloadmask $dst, $pg, $src\\t# vector load mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_vector_extend(as_FloatRegister($tmp$$reg), size, as_FloatRegister($src$$reg), __ B);\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size,\n-               as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-dnl\n-dnl VMASK_GEN($1,        $2,       $3,        $4  )\n-dnl VMASK_GEN(insn_name, src_type, src_match, insn)\n-define(`VMASK_GEN', `\n-instruct $1(pRegGov pd, $2 src, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set pd (VectorMaskGen $3));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"$4 $pd, zr, $src\\t# vector mask gen (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ $4(as_PRegister($pd$$reg), size, zr, as_Register($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl\n-\/\/ vector mask gen\n-VMASK_GEN(vmask_gen_I, iRegIorL2I, (ConvI2L src), sve_whilelow)\n-VMASK_GEN(vmask_gen_L, iRegL, src, sve_whilelo)\n-\n-instruct vmask_gen_imm(pRegGov pd, immL src, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set pd (VectorMaskGen src));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"vmask_gen_imm $pd, $src\\t# vector mask gen with imm (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_gen_mask_imm(as_PRegister($pd$$reg), bt, (uint) $src$$constant);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-\/\/ ---------------------------- Compress\/Expand Operations ---------------------------\n-\n-instruct mcompress(pReg dst, pReg pg, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (CompressM pg));\n-  effect(KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_cntp rscratch1, $pg\\n\\t\"\n-            \"sve_whilelo $dst, zr, rscratch1\\t# mask compress (B\/H\/S\/D)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_cntp(rscratch1, size, ptrue, as_PRegister($pg$$reg));\n-    __ sve_whilelo(as_PRegister($dst$$reg), size, zr, rscratch1);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcompress(vReg dst, vReg src, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n-  match(Set dst (CompressV src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_compact $dst, $src, $pg\\t# vector compress (S\/D)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_compact(as_FloatRegister($dst$$reg), size, as_FloatRegister($src$$reg), as_PRegister($pg$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcompressB(vReg dst, vReg src, pReg pg, vReg vtmp1, vReg vtmp2, vReg vtmp3, vReg vtmp4,\n-                    pReg ptmp, pRegGov pgtmp) %{\n-  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP vtmp3, TEMP vtmp4, TEMP ptmp, TEMP pgtmp);\n-  match(Set dst (CompressV src pg));\n-  ins_cost(13 * SVE_COST);\n-  format %{ \"sve_compact $dst, $src, $pg\\t# vector compress (B)\" %}\n-  ins_encode %{\n-    __ sve_compress_byte(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_PRegister($pg$$reg),\n-                         as_FloatRegister($vtmp1$$reg),as_FloatRegister($vtmp2$$reg),\n-                         as_FloatRegister($vtmp3$$reg),as_FloatRegister($vtmp4$$reg),\n-                         as_PRegister($ptmp$$reg), as_PRegister($pgtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcompressS(vReg dst, vReg src, pReg pg, vReg vtmp1, vReg vtmp2, pRegGov pgtmp) %{\n-  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp);\n-  match(Set dst (CompressV src pg));\n-  ins_cost(38 * SVE_COST);\n-  format %{ \"sve_compact $dst, $src, $pg\\t# vector compress (H)\" %}\n-  ins_encode %{\n-    __ sve_compress_short(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_PRegister($pg$$reg),\n-                          as_FloatRegister($vtmp1$$reg),as_FloatRegister($vtmp2$$reg), as_PRegister($pgtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vexpand(vReg dst, vReg src, pRegGov pg) %{\n-  match(Set dst (ExpandV src pg));\n-  effect(TEMP_DEF dst);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_dup $dst, S\/D, 0\\n\\t\"\n-            \"sve_histcnt $dst, S\/D, $pg, $dst, $dst\\n\\t\"\n-            \"sve_sub $dst, S\/D, 1\\n\\t\"\n-            \"sve_tbl $dst, S\/D, $src, $dst\\t# vector expand (S\/D)\" %}\n-  ins_encode %{\n-    \/\/ Example input:   src   = 1 2 3 4 5 6 7 8\n-    \/\/                  pg    = 1 0 0 1 1 0 1 1\n-    \/\/ Expected result: dst   = 4 0 0 5 6 0 7 8\n-\n-    \/\/ The basic idea is to use TBL which can shuffle the elements in the given\n-    \/\/ vector flexibly. HISTCNT + SUB is used to generate the second source input\n-    \/\/ for TBL whose value is used to select the indexed element from src vector.\n-\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    assert(UseSVE == 2 && !is_subword_type(bt), \"unsupported\");\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    \/\/ dst = 0 0 0 0 0 0 0 0\n-    __ sve_dup(as_FloatRegister($dst$$reg), size, 0);\n-    \/\/ dst = 5 0 0 4 3 0 2 1\n-    __ sve_histcnt(as_FloatRegister($dst$$reg), size, as_PRegister($pg$$reg),\n-                   as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg));\n-    \/\/ dst = 4 -1 -1 3 2 -1 1 0\n-    __ sve_sub(as_FloatRegister($dst$$reg), size, 1);\n-    \/\/ dst = 4 0 0 5 6 0 7 8\n-    __ sve_tbl(as_FloatRegister($dst$$reg), size, as_FloatRegister($src$$reg),\n-               as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-dnl\n-dnl BITWISE_UNARY($1,        $2,      $3  )\n-dnl BITWISE_UNARY(insn_name, op_name, insn)\n-define(`BITWISE_UNARY', `\n-instruct $1(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst ($2 src));\n-  ins_cost(ifelse($2, `CountTrailingZerosV', `2 * ', `')SVE_COST);\n-  format %{ ifelse($2, `CountTrailingZerosV', `\"sve_rbit $dst, $src\\n\\t\"\n-            \"$3  $dst, $dst', `\"$3 $dst, $src')\\t# vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);dnl\n-ifelse($2, `CountTrailingZerosV', `\n-    __ sve_rbit(as_FloatRegister($dst$$reg), size, ptrue, as_FloatRegister($src$$reg));', `')dnl\n-ifelse($2, `ReverseBytesV', `\n-    if (bt == T_BYTE) {\n-      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-      }\n-    } else {\n-      __ $3(as_FloatRegister($dst$$reg), size, ptrue, as_FloatRegister($src$$reg));\n-    }', `\n-    __ $3(as_FloatRegister($dst$$reg), size, ptrue, as_FloatRegister($ifelse($2, `CountTrailingZerosV', dst, src)$$reg));')\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl BITWISE_UNARY_PREDICATE($1,        $2,      $3  )\n-dnl BITWISE_UNARY_PREDICATE(insn_name, op_name, insn)\n-define(`BITWISE_UNARY_PREDICATE', `\n-\/\/ The dst and src should use the same register to make sure the\n-\/\/ inactive lanes in dst save the same elements as src.\n-instruct $1_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src ($2 dst_src pg));\n-  ins_cost(ifelse($2, `CountTrailingZerosV', `2 * ', `')SVE_COST);\n-  format %{ ifelse($2, `CountTrailingZerosV', `\"sve_rbit $dst_src, $pg, $dst_src\\n\\t\"\n-            \"$3  $dst_src, $pg, $dst_src', `\"$3 $dst_src, $pg, $dst_src')\\t# vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);dnl\n-ifelse($2, `CountTrailingZerosV', `\n-    __ sve_rbit(as_FloatRegister($dst_src$$reg), size,\n-        as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));', `')dnl\n-ifelse($2, `ReverseBytesV', `\n-    if (bt == T_BYTE) {\n-      \/\/ do nothing\n-    } else {\n-      __ $3(as_FloatRegister($dst_src$$reg), size,\n-          as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n-    }', `\n-    __ $3(as_FloatRegister($dst_src$$reg), size,\n-        as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));')\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ ------------------------------ CountLeadingZerosV ------------------------------\n-BITWISE_UNARY(vcountLeadingZeros, CountLeadingZerosV, sve_clz)\n-BITWISE_UNARY_PREDICATE(vcountLeadingZeros, CountLeadingZerosV, sve_clz)\n-\n-\/\/ ------------------------------ CountTrailingZerosV -----------------------------\n-BITWISE_UNARY(vcountTrailingZeros, CountTrailingZerosV, sve_clz)\n-BITWISE_UNARY_PREDICATE(vcountTrailingZeros, CountTrailingZerosV, sve_clz)\n-\n-\/\/ ---------------------------------- ReverseV ------------------------------------\n-BITWISE_UNARY(vreverse, ReverseV, sve_rbit)\n-BITWISE_UNARY_PREDICATE(vreverse, ReverseV, sve_rbit)\n-\n-\/\/ -------------------------------- ReverseBytesV ---------------------------------\n-BITWISE_UNARY(vreverseBytes, ReverseBytesV, sve_revb)\n-BITWISE_UNARY_PREDICATE(vreverseBytes, ReverseBytesV, sve_revb)\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":0,"deletions":3470,"binary":false,"changes":3470,"status":"deleted"},{"patch":"@@ -0,0 +1,6394 @@\n+\/\/\n+\/\/ Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2020, 2022, Arm Limited. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\/\/\n+\n+\/\/ This file is automatically generated by running \"m4 aarch64_vector_ad.m4\". Do not edit!\n+\n+\/\/ AArch64 VECTOR Architecture Description File\n+\n+\n+\/\/ 4 bit signed offset -- for predicated load\/store\n+\n+operand vmemA_immIOffset4() %{\n+  \/\/ (esize \/ msize) = 1\n+  predicate(Address::offset_ok_for_sve_immed(n->get_int(), 4,\n+            Matcher::scalable_vector_reg_size(T_BYTE)));\n+  match(ConI);\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand vmemA_immLOffset4() %{\n+  \/\/ (esize \/ msize) = 1\n+  predicate(Address::offset_ok_for_sve_immed(n->get_long(), 4,\n+            Matcher::scalable_vector_reg_size(T_BYTE)));\n+  match(ConL);\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand vmemA_indOffI4(iRegP reg, vmemA_immIOffset4 off) %{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP reg off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+operand vmemA_indOffL4(iRegP reg, vmemA_immLOffset4 off) %{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP reg off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+\/\/ The indOff of vmemA is valid only when the vector element (load to\/store from)\n+\/\/ size equals to memory element (load from\/store to) size.\n+opclass vmemA(indirect, vmemA_indOffI4, vmemA_indOffL4);\n+\n+source_hpp %{\n+  \/\/ Assert that the given node is not a variable shift.\n+  bool assert_not_var_shift(const Node* n);\n+\n+  Assembler::SIMD_Arrangement get_arrangement(const Node* n);\n+%}\n+\n+source %{\n+\n+  typedef void (C2_MacroAssembler::* sve_mem_insn_predicate)(FloatRegister Rt, Assembler::SIMD_RegVariant T,\n+                                                             PRegister Pg, const Address &adr);\n+\n+  \/\/ Predicated load\/store, with optional ptrue to all elements of given predicate register.\n+  static void loadStoreA_predicated(C2_MacroAssembler masm, bool is_store, FloatRegister reg,\n+                                    PRegister pg, BasicType mem_elem_bt, BasicType vector_elem_bt,\n+                                    int opcode, Register base, int index, int size, int disp) {\n+    sve_mem_insn_predicate insn;\n+    int mesize = type2aelembytes(mem_elem_bt);\n+    if (index == -1) {\n+      assert(size == 0, \"unsupported address mode: scale size = %d\", size);\n+      switch(mesize) {\n+      case 1:\n+        insn = is_store ? &C2_MacroAssembler::sve_st1b : &C2_MacroAssembler::sve_ld1b;\n+        break;\n+      case 2:\n+        insn = is_store ? &C2_MacroAssembler::sve_st1h : &C2_MacroAssembler::sve_ld1h;\n+        break;\n+      case 4:\n+        insn = is_store ? &C2_MacroAssembler::sve_st1w : &C2_MacroAssembler::sve_ld1w;\n+        break;\n+      case 8:\n+        insn = is_store ? &C2_MacroAssembler::sve_st1d : &C2_MacroAssembler::sve_ld1d;\n+        break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+      }\n+      int imm4 = disp \/ mesize \/ Matcher::scalable_vector_reg_size(vector_elem_bt);\n+      (masm.*insn)(reg, Assembler::elemType_to_regVariant(vector_elem_bt), pg, Address(base, imm4));\n+    } else {\n+      assert(false, \"unimplemented\");\n+      ShouldNotReachHere();\n+    }\n+  }\n+\n+  const bool Matcher::match_rule_supported_superword(int opcode, int vlen, BasicType bt) {\n+    if (UseSVE == 0) {\n+      \/\/ ConvD2I and ConvL2F are not profitable to be vectorized on NEON, because no direct\n+      \/\/ NEON instructions support them. But the match rule support for them is profitable for\n+      \/\/ Vector API intrinsics.\n+      if ((opcode == Op_VectorCastD2X && bt == T_INT) ||\n+          (opcode == Op_VectorCastL2X && bt == T_FLOAT)) {\n+        return false;\n+      }\n+    }\n+    return match_rule_supported_vector(opcode, vlen, bt);\n+  }\n+\n+  \/\/ Identify extra cases that we might want to provide match rules for vector nodes and\n+  \/\/ other intrinsics guarded with vector length (vlen) and element type (bt).\n+  const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {\n+    if (!match_rule_supported(opcode)) {\n+      return false;\n+    }\n+\n+    int length_in_bytes = vlen * type2aelembytes(bt);\n+    if (UseSVE == 0 && length_in_bytes > 16) {\n+      return false;\n+    }\n+\n+    \/\/ Check whether specific Op is supported.\n+    \/\/ Fail fast, otherwise fall through to common vector_size_supported() check.\n+    switch (opcode) {\n+      case Op_MulVL:\n+      case Op_AndVMask:\n+      case Op_OrVMask:\n+      case Op_XorVMask:\n+      case Op_MaskAll:\n+      case Op_VectorMaskGen:\n+      case Op_LoadVectorMasked:\n+      case Op_StoreVectorMasked:\n+      case Op_LoadVectorGather:\n+      case Op_StoreVectorScatter:\n+      case Op_LoadVectorGatherMasked:\n+      case Op_StoreVectorScatterMasked:\n+      case Op_PopulateIndex:\n+      case Op_CompressM:\n+      case Op_CompressV:\n+        if (UseSVE == 0) {\n+          return false;\n+        }\n+        break;\n+      case Op_MulAddVS2VI:\n+        if (length_in_bytes != 16) {\n+          return false;\n+        }\n+        break;\n+      case Op_MulReductionVD:\n+      case Op_MulReductionVF:\n+      case Op_MulReductionVI:\n+      case Op_MulReductionVL:\n+        \/\/ No vector multiply reduction instructions, but we do\n+        \/\/ emit scalar instructions for 64\/128-bit vectors.\n+        if (length_in_bytes != 8 && length_in_bytes != 16) {\n+          return false;\n+        }\n+        break;\n+      case Op_VectorMaskCmp:\n+        if (length_in_bytes < 8) {\n+          return false;\n+        }\n+        break;\n+      case Op_VectorLoadShuffle:\n+      case Op_VectorRearrange:\n+        if (vlen < 4) {\n+          return false;\n+        }\n+        break;\n+      case Op_ExpandV:\n+        if (UseSVE < 2 || is_subword_type(bt)) {\n+          return false;\n+        }\n+        break;\n+      case Op_VectorMaskToLong:\n+        if (UseSVE > 0 && vlen > 64) {\n+          return false;\n+        }\n+        break;\n+      case Op_VectorLongToMask:\n+        if (UseSVE < 2 || vlen > 64 || !VM_Version::supports_svebitperm()) {\n+          return false;\n+        }\n+        break;\n+      default:\n+        break;\n+    }\n+    return vector_size_supported(bt, vlen);\n+  }\n+\n+  const bool Matcher::match_rule_supported_vector_masked(int opcode, int vlen, BasicType bt) {\n+    \/\/ Only SVE supports masked operations.\n+    if (UseSVE == 0) {\n+      return false;\n+    }\n+\n+    \/\/ If an opcode does not support the masked version,\n+    \/\/ unpredicated node with VectorBlend node will be used instead.\n+    switch(opcode) {\n+      case Op_VectorRearrange:\n+      case Op_MulReductionVD:\n+      case Op_MulReductionVF:\n+      case Op_MulReductionVI:\n+      case Op_MulReductionVL:\n+        return false;\n+      \/\/ We use Op_LoadVectorMasked to implement the predicated Op_LoadVector.\n+      \/\/ Hence we turn to check whether Op_LoadVectorMasked is supported. The\n+      \/\/ same as vector store\/gather\/scatter.\n+      case Op_LoadVector:\n+        opcode = Op_LoadVectorMasked;\n+        break;\n+      case Op_StoreVector:\n+        opcode = Op_StoreVectorMasked;\n+        break;\n+      case Op_LoadVectorGather:\n+        opcode = Op_LoadVectorGatherMasked;\n+        break;\n+      case Op_StoreVectorScatter:\n+        opcode = Op_StoreVectorScatterMasked;\n+        break;\n+      default:\n+        break;\n+    }\n+\n+    return match_rule_supported_vector(opcode, vlen, bt);\n+  }\n+\n+  const bool Matcher::vector_needs_partial_operations(Node* node, const TypeVect* vt) {\n+    \/\/ Only SVE has partial vector operations\n+    if (UseSVE == 0) {\n+      return false;\n+    }\n+\n+    switch(node->Opcode()) {\n+      case Op_VectorLoadMask:\n+      case Op_VectorMaskCmp:\n+      case Op_LoadVectorGather:\n+      case Op_StoreVectorScatter:\n+      case Op_AddReductionVF:\n+      case Op_AddReductionVD:\n+      case Op_AndReductionV:\n+      case Op_OrReductionV:\n+      case Op_XorReductionV:\n+      \/\/ Mask is needed for partial Op_VectorMaskFirstTrue, because when the\n+      \/\/ input predicate is all-false, the result should be the vector length\n+      \/\/ instead of the vector register size.\n+      case Op_VectorMaskFirstTrue:\n+        return true;\n+      case Op_MaskAll:\n+        return !node->in(1)->is_Con();\n+      case Op_LoadVector:\n+      case Op_StoreVector:\n+        \/\/ We use NEON load\/store instructions if the vector length is <= 128 bits.\n+        return vt->length_in_bytes() > 16;\n+      case Op_AddReductionVI:\n+      case Op_AddReductionVL:\n+        \/\/ We may prefer using NEON instructions rather than SVE partial operations.\n+        return !VM_Version::use_neon_for_vector(vt->length_in_bytes());\n+      case Op_MinReductionV:\n+      case Op_MaxReductionV:\n+        \/\/ For BYTE\/SHORT\/INT\/FLOAT\/DOUBLE types, we may prefer using NEON\n+        \/\/ instructions rather than SVE partial operations.\n+        return vt->element_basic_type() == T_LONG ||\n+               !VM_Version::use_neon_for_vector(vt->length_in_bytes());\n+      default:\n+        \/\/ For other ops whose vector size is smaller than the max vector size, a\n+        \/\/ full-sized unpredicated operation does not impact the final vector result.\n+        return false;\n+    }\n+  }\n+\n+  \/\/ Assert that the given node is not a variable shift.\n+  bool assert_not_var_shift(const Node* n) {\n+    assert(!n->as_ShiftV()->is_var_shift(), \"illegal variable shift\");\n+    return true;\n+  }\n+\n+  Assembler::SIMD_Arrangement get_arrangement(const Node* n) {\n+    BasicType bt = Matcher::vector_element_basic_type(n);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(n);\n+    return Assembler::esize2arrangement((uint)type2aelembytes(bt),\n+                                        \/* isQ *\/ length_in_bytes == 16);\n+  }\n+%}\n+\n+\n+\/\/ All VECTOR instructions\n+\n+\/\/ ------------------------------ Vector load\/store ----------------------------\n+\n+\/\/ Load Vector (16 bits)\n+instruct loadV2(vReg dst, vmem2 mem) %{\n+  predicate(n->as_LoadVector()->memory_size() == 2);\n+  match(Set dst (LoadVector mem));\n+  format %{ \"loadV2 $dst, $mem\\t# vector (16 bits)\" %}\n+  ins_encode( aarch64_enc_ldrvH(dst, mem) );\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Store Vector (16 bits)\n+instruct storeV2(vReg src, vmem2 mem) %{\n+  predicate(n->as_StoreVector()->memory_size() == 2);\n+  match(Set mem (StoreVector mem src));\n+  format %{ \"storeV2 $mem, $src\\t# vector (16 bits)\" %}\n+  ins_encode( aarch64_enc_strvH(src, mem) );\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Load Vector (32 bits)\n+instruct loadV4(vReg dst, vmem4 mem) %{\n+  predicate(n->as_LoadVector()->memory_size() == 4);\n+  match(Set dst (LoadVector mem));\n+  format %{ \"loadV4 $dst, $mem\\t# vector (32 bits)\" %}\n+  ins_encode( aarch64_enc_ldrvS(dst, mem) );\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Store Vector (32 bits)\n+instruct storeV4(vReg src, vmem4 mem) %{\n+  predicate(n->as_StoreVector()->memory_size() == 4);\n+  match(Set mem (StoreVector mem src));\n+  format %{ \"storeV4 $mem, $src\\t# vector (32 bits)\" %}\n+  ins_encode( aarch64_enc_strvS(src, mem) );\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Load Vector (64 bits)\n+instruct loadV8(vReg dst, vmem8 mem) %{\n+  predicate(n->as_LoadVector()->memory_size() == 8);\n+  match(Set dst (LoadVector mem));\n+  format %{ \"loadV8 $dst, $mem\\t# vector (64 bits)\" %}\n+  ins_encode( aarch64_enc_ldrvD(dst, mem) );\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Store Vector (64 bits)\n+instruct storeV8(vReg src, vmem8 mem) %{\n+  predicate(n->as_StoreVector()->memory_size() == 8);\n+  match(Set mem (StoreVector mem src));\n+  format %{ \"storeV8 $mem, $src\\t# vector (64 bits)\" %}\n+  ins_encode( aarch64_enc_strvD(src, mem) );\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Load Vector (128 bits)\n+instruct loadV16(vReg dst, vmem16 mem) %{\n+  predicate(n->as_LoadVector()->memory_size() == 16);\n+  match(Set dst (LoadVector mem));\n+  format %{ \"loadV16 $dst, $mem\\t# vector (128 bits)\" %}\n+  ins_encode( aarch64_enc_ldrvQ(dst, mem) );\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Store Vector (128 bits)\n+instruct storeV16(vReg src, vmem16 mem) %{\n+  predicate(n->as_StoreVector()->memory_size() == 16);\n+  match(Set mem (StoreVector mem src));\n+  format %{ \"storeV16 $mem, $src\\t# vector (128 bits)\" %}\n+  ins_encode( aarch64_enc_strvQ(src, mem) );\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Load Vector (> 128 bits)\n+instruct loadV(vReg dst, vmemA mem) %{\n+  predicate(n->as_LoadVector()->memory_size() > 16);\n+  match(Set dst (LoadVector mem));\n+  format %{ \"loadV $dst, $mem\\t# vector (sve)\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), \/* is_store *\/ false,\n+                          $dst$$FloatRegister, ptrue, bt, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Store Vector (> 128 bits)\n+instruct storeV(vReg src, vmemA mem) %{\n+  predicate(n->as_StoreVector()->memory_size() > 16);\n+  match(Set mem (StoreVector mem src));\n+  format %{ \"storeV $mem, $src\\t# vector (sve)\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), \/* is_store *\/ true,\n+                          $src$$FloatRegister, ptrue, bt, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector load\/store - predicated\n+\n+instruct loadV_masked(vReg dst, vmemA mem, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (LoadVectorMasked mem pg));\n+  format %{ \"loadV_masked $dst, $pg, $mem\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), \/* is_store *\/ false, $dst$$FloatRegister,\n+                          $pg$$PRegister, bt, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct storeV_masked(vReg src, vmemA mem, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set mem (StoreVectorMasked mem (Binary src pg)));\n+  format %{ \"storeV_masked $mem, $pg, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), \/* is_store *\/ true, $src$$FloatRegister,\n+                          $pg$$PRegister, bt, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector load const\n+\n+instruct vloadconB(vReg dst, immI0 src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE);\n+  match(Set dst (VectorLoadConst src));\n+  format %{ \"vloadconB $dst, $src\\t# load\/generate iota indices\" %}\n+  ins_encode %{\n+    if (UseSVE == 0) {\n+      uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+      assert(length_in_bytes <= 16, \"must be\");\n+      __ lea(rscratch1, ExternalAddress(StubRoutines::aarch64::vector_iota_indices()));\n+      if (length_in_bytes == 16) {\n+        __ ldrq($dst$$FloatRegister, rscratch1);\n+      } else {\n+        __ ldrd($dst$$FloatRegister, rscratch1);\n+      }\n+    } else {\n+      __ sve_index($dst$$FloatRegister, __ B, 0, 1);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector add -----------------------------------\n+\n+\/\/ vector add\n+\n+instruct vaddB(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (AddVB src1 src2));\n+  format %{ \"vaddB $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ addv($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_add($dst$$FloatRegister, __ B, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddS(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (AddVS src1 src2));\n+  format %{ \"vaddS $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ addv($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_add($dst$$FloatRegister, __ H, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddI(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (AddVI src1 src2));\n+  format %{ \"vaddI $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ addv($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_add($dst$$FloatRegister, __ S, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddL(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (AddVL src1 src2));\n+  format %{ \"vaddL $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ addv($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_add($dst$$FloatRegister, __ D, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddF(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (AddVF src1 src2));\n+  format %{ \"vaddF $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fadd($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fadd($dst$$FloatRegister, __ S, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddD(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (AddVD src1 src2));\n+  format %{ \"vaddD $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fadd($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fadd($dst$$FloatRegister, __ D, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector add - predicated\n+\n+instruct vaddB_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddVB (Binary dst_src1 src2) pg));\n+  format %{ \"vaddB_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_add($dst_src1$$FloatRegister, __ B, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddS_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddVS (Binary dst_src1 src2) pg));\n+  format %{ \"vaddS_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_add($dst_src1$$FloatRegister, __ H, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddI_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddVI (Binary dst_src1 src2) pg));\n+  format %{ \"vaddI_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_add($dst_src1$$FloatRegister, __ S, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddL_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddVL (Binary dst_src1 src2) pg));\n+  format %{ \"vaddL_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_add($dst_src1$$FloatRegister, __ D, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddVF (Binary dst_src1 src2) pg));\n+  format %{ \"vaddF_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fadd($dst_src1$$FloatRegister, __ S, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddD_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddVD (Binary dst_src1 src2) pg));\n+  format %{ \"vaddD_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fadd($dst_src1$$FloatRegister, __ D, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector add reg imm (unpredicated)\n+\n+instruct vaddImmB(vReg dst_src, immBAddSubV con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AddVB dst_src (ReplicateB con)));\n+  format %{ \"vaddImmB $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    int val = (int)$con$$constant;\n+    if (val > 0) {\n+      __ sve_add($dst_src$$FloatRegister, __ B, val);\n+    } else {\n+      __ sve_sub($dst_src$$FloatRegister, __ B, -val);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddImmS(vReg dst_src, immIAddSubV con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AddVS dst_src (ReplicateS con)));\n+  format %{ \"vaddImmS $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    int val = (int)$con$$constant;\n+    if (val > 0) {\n+      __ sve_add($dst_src$$FloatRegister, __ H, val);\n+    } else {\n+      __ sve_sub($dst_src$$FloatRegister, __ H, -val);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddImmI(vReg dst_src, immIAddSubV con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AddVI dst_src (ReplicateI con)));\n+  format %{ \"vaddImmI $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    int val = (int)$con$$constant;\n+    if (val > 0) {\n+      __ sve_add($dst_src$$FloatRegister, __ S, val);\n+    } else {\n+      __ sve_sub($dst_src$$FloatRegister, __ S, -val);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddImmL(vReg dst_src, immLAddSubV con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AddVL dst_src (ReplicateL con)));\n+  format %{ \"vaddImmL $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    int val = (int)$con$$constant;\n+    if (val > 0) {\n+      __ sve_add($dst_src$$FloatRegister, __ D, val);\n+    } else {\n+      __ sve_sub($dst_src$$FloatRegister, __ D, -val);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector sub -----------------------------------\n+\n+\/\/ vector sub\n+\n+instruct vsubB(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (SubVB src1 src2));\n+  format %{ \"vsubB $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ subv($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_sub($dst$$FloatRegister, __ B, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsubS(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (SubVS src1 src2));\n+  format %{ \"vsubS $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ subv($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_sub($dst$$FloatRegister, __ H, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsubI(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (SubVI src1 src2));\n+  format %{ \"vsubI $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ subv($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_sub($dst$$FloatRegister, __ S, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsubL(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (SubVL src1 src2));\n+  format %{ \"vsubL $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ subv($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_sub($dst$$FloatRegister, __ D, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsubF(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (SubVF src1 src2));\n+  format %{ \"vsubF $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fsub($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fsub($dst$$FloatRegister, __ S, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsubD(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (SubVD src1 src2));\n+  format %{ \"vsubD $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fsub($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fsub($dst$$FloatRegister, __ D, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector sub - predicated\n+\n+instruct vsubB_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (SubVB (Binary dst_src1 src2) pg));\n+  format %{ \"vsubB_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_sub($dst_src1$$FloatRegister, __ B, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsubS_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (SubVS (Binary dst_src1 src2) pg));\n+  format %{ \"vsubS_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_sub($dst_src1$$FloatRegister, __ H, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsubI_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (SubVI (Binary dst_src1 src2) pg));\n+  format %{ \"vsubI_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_sub($dst_src1$$FloatRegister, __ S, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsubL_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (SubVL (Binary dst_src1 src2) pg));\n+  format %{ \"vsubL_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_sub($dst_src1$$FloatRegister, __ D, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsubF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (SubVF (Binary dst_src1 src2) pg));\n+  format %{ \"vsubF_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fsub($dst_src1$$FloatRegister, __ S, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsubD_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (SubVD (Binary dst_src1 src2) pg));\n+  format %{ \"vsubD_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fsub($dst_src1$$FloatRegister, __ D, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector mul -----------------------------------\n+\n+\/\/ vector mul - BYTE, CHAR, SHORT, INT\n+\n+instruct vmulB_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (MulVB src1 src2));\n+  format %{ \"vmulB_neon $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ mulv($dst$$FloatRegister, get_arrangement(this),\n+            $src1$$FloatRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmulB_sve(vReg dst_src1, vReg src2) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 (MulVB dst_src1 src2));\n+  format %{ \"vmulB_sve $dst_src1, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_mul($dst_src1$$FloatRegister, __ B, ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmulS_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (MulVS src1 src2));\n+  format %{ \"vmulS_neon $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ mulv($dst$$FloatRegister, get_arrangement(this),\n+            $src1$$FloatRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmulS_sve(vReg dst_src1, vReg src2) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 (MulVS dst_src1 src2));\n+  format %{ \"vmulS_sve $dst_src1, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_mul($dst_src1$$FloatRegister, __ H, ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmulI_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (MulVI src1 src2));\n+  format %{ \"vmulI_neon $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ mulv($dst$$FloatRegister, get_arrangement(this),\n+            $src1$$FloatRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmulI_sve(vReg dst_src1, vReg src2) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 (MulVI dst_src1 src2));\n+  format %{ \"vmulI_sve $dst_src1, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_mul($dst_src1$$FloatRegister, __ S, ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector mul - LONG\n+\n+instruct vmulL_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (MulVL src1 src2));\n+  format %{ \"vmulL_neon $dst, $src1, $src2\\t# 2L\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == 16, \"must be\");\n+    __ umov(rscratch1, $src1$$FloatRegister, __ D, 0);\n+    __ umov(rscratch2, $src2$$FloatRegister, __ D, 0);\n+    __ mul(rscratch2, rscratch2, rscratch1);\n+    __ mov($dst$$FloatRegister, __ D, 0, rscratch2);\n+    __ umov(rscratch1, $src1$$FloatRegister, __ D, 1);\n+    __ umov(rscratch2, $src2$$FloatRegister, __ D, 1);\n+    __ mul(rscratch2, rscratch2, rscratch1);\n+    __ mov($dst$$FloatRegister, __ D, 1, rscratch2);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmulL_sve(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (MulVL dst_src1 src2));\n+  format %{ \"vmulL_sve $dst_src1, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_mul($dst_src1$$FloatRegister, __ D, ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector mul - floating-point\n+\n+instruct vmulF(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (MulVF src1 src2));\n+  format %{ \"vmulF $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fmul($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fmul($dst$$FloatRegister, __ S, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmulD(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (MulVD src1 src2));\n+  format %{ \"vmulD $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fmul($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fmul($dst$$FloatRegister, __ D, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector mul - predicated\n+\n+instruct vmulB_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (MulVB (Binary dst_src1 src2) pg));\n+  format %{ \"vmulB_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_mul($dst_src1$$FloatRegister, __ B, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmulS_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (MulVS (Binary dst_src1 src2) pg));\n+  format %{ \"vmulS_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_mul($dst_src1$$FloatRegister, __ H, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmulI_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (MulVI (Binary dst_src1 src2) pg));\n+  format %{ \"vmulI_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_mul($dst_src1$$FloatRegister, __ S, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmulL_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (MulVL (Binary dst_src1 src2) pg));\n+  format %{ \"vmulL_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_mul($dst_src1$$FloatRegister, __ D, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmulF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (MulVF (Binary dst_src1 src2) pg));\n+  format %{ \"vmulF_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fmul($dst_src1$$FloatRegister, __ S, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmulD_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (MulVD (Binary dst_src1 src2) pg));\n+  format %{ \"vmulD_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fmul($dst_src1$$FloatRegister, __ D, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector float div -----------------------------\n+\n+\/\/ vector float div\n+\n+instruct vdivF_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (DivVF src1 src2));\n+  format %{ \"vdivF_neon $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ fdiv($dst$$FloatRegister, get_arrangement(this),\n+            $src1$$FloatRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vdivF_sve(vReg dst_src1, vReg src2) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 (DivVF dst_src1 src2));\n+  format %{ \"vdivF_sve $dst_src1, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_fdiv($dst_src1$$FloatRegister, __ S, ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vdivD_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (DivVD src1 src2));\n+  format %{ \"vdivD_neon $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ fdiv($dst$$FloatRegister, get_arrangement(this),\n+            $src1$$FloatRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vdivD_sve(vReg dst_src1, vReg src2) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 (DivVD dst_src1 src2));\n+  format %{ \"vdivD_sve $dst_src1, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_fdiv($dst_src1$$FloatRegister, __ D, ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector float div - predicated\n+\n+instruct vdivF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (DivVF (Binary dst_src1 src2) pg));\n+  format %{ \"vdivF_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fdiv($dst_src1$$FloatRegister, __ S, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vdivD_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (DivVD (Binary dst_src1 src2) pg));\n+  format %{ \"vdivD_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fdiv($dst_src1$$FloatRegister, __ D, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector and -----------------------------------\n+\n+\/\/ vector and\n+\n+instruct vand(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (AndV src1 src2));\n+  format %{ \"vand $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ andr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_and($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector and - predicated\n+\n+instruct vand_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AndV (Binary dst_src1 src2) pg));\n+  format %{ \"vand_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_and($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector and reg imm (unpredicated)\n+\n+instruct vandImmB(vReg dst_src, immBLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AndV dst_src (ReplicateB con)));\n+  format %{ \"vandImmB $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    __ sve_and($dst_src$$FloatRegister, __ B, (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vandImmS(vReg dst_src, immSLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AndV dst_src (ReplicateS con)));\n+  format %{ \"vandImmS $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    __ sve_and($dst_src$$FloatRegister, __ H, (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vandImmI(vReg dst_src, immILog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AndV dst_src (ReplicateI con)));\n+  format %{ \"vandImmI $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    __ sve_and($dst_src$$FloatRegister, __ S, (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vandImmL(vReg dst_src, immLLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AndV dst_src (ReplicateL con)));\n+  format %{ \"vandImmL $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    __ sve_and($dst_src$$FloatRegister, __ D, (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector or ------------------------------------\n+\n+\/\/ vector or\n+\n+instruct vor(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (OrV src1 src2));\n+  format %{ \"vor $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ orr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_orr($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector or - predicated\n+\n+instruct vor_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (OrV (Binary dst_src1 src2) pg));\n+  format %{ \"vor_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_orr($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector or reg imm (unpredicated)\n+\n+instruct vorImmB(vReg dst_src, immBLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (OrV dst_src (ReplicateB con)));\n+  format %{ \"vorImmB $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    __ sve_orr($dst_src$$FloatRegister, __ B, (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vorImmS(vReg dst_src, immSLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (OrV dst_src (ReplicateS con)));\n+  format %{ \"vorImmS $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    __ sve_orr($dst_src$$FloatRegister, __ H, (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vorImmI(vReg dst_src, immILog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (OrV dst_src (ReplicateI con)));\n+  format %{ \"vorImmI $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    __ sve_orr($dst_src$$FloatRegister, __ S, (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vorImmL(vReg dst_src, immLLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (OrV dst_src (ReplicateL con)));\n+  format %{ \"vorImmL $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    __ sve_orr($dst_src$$FloatRegister, __ D, (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector xor -----------------------------------\n+\n+\/\/ vector xor\n+\n+instruct vxor(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (XorV src1 src2));\n+  format %{ \"vxor $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ eor($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_eor($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector xor - predicated\n+\n+instruct vxor_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (XorV (Binary dst_src1 src2) pg));\n+  format %{ \"vxor_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_eor($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector xor reg imm (unpredicated)\n+\n+instruct vxorImmB(vReg dst_src, immBLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (XorV dst_src (ReplicateB con)));\n+  format %{ \"vxorImmB $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    __ sve_eor($dst_src$$FloatRegister, __ B, (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vxorImmS(vReg dst_src, immSLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (XorV dst_src (ReplicateS con)));\n+  format %{ \"vxorImmS $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    __ sve_eor($dst_src$$FloatRegister, __ H, (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vxorImmI(vReg dst_src, immILog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (XorV dst_src (ReplicateI con)));\n+  format %{ \"vxorImmI $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    __ sve_eor($dst_src$$FloatRegister, __ S, (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vxorImmL(vReg dst_src, immLLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (XorV dst_src (ReplicateL con)));\n+  format %{ \"vxorImmL $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    __ sve_eor($dst_src$$FloatRegister, __ D, (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector not -----------------------------------\n+\n+\/\/ vector not\n+\n+instruct vnotI(vReg dst, vReg src, immI_M1 m1) %{\n+  match(Set dst (XorV src (ReplicateB m1)));\n+  match(Set dst (XorV src (ReplicateS m1)));\n+  match(Set dst (XorV src (ReplicateI m1)));\n+  format %{ \"vnotI $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ notr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+              $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_not($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vnotL(vReg dst, vReg src, immL_M1 m1) %{\n+  match(Set dst (XorV src (ReplicateL m1)));\n+  format %{ \"vnotL $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ notr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+              $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_not($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector not - predicated\n+\n+instruct vnotI_masked(vReg dst_src, immI_M1 m1, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (XorV (Binary dst_src (ReplicateB m1)) pg));\n+  match(Set dst_src (XorV (Binary dst_src (ReplicateS m1)) pg));\n+  match(Set dst_src (XorV (Binary dst_src (ReplicateI m1)) pg));\n+  format %{ \"vnotI_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_not($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vnotL_masked(vReg dst_src, immL_M1 m1, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (XorV (Binary dst_src (ReplicateL m1)) pg));\n+  format %{ \"vnotL_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_not($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector and_not -------------------------------\n+\n+\/\/ vector and_not\n+\n+instruct vand_notI(vReg dst, vReg src1, vReg src2, immI_M1 m1) %{\n+  match(Set dst (AndV src1 (XorV src2 (ReplicateB m1))));\n+  match(Set dst (AndV src1 (XorV src2 (ReplicateS m1))));\n+  match(Set dst (AndV src1 (XorV src2 (ReplicateI m1))));\n+  format %{ \"vand_notI $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ bic($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+             $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_bic($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vand_notL(vReg dst, vReg src1, vReg src2, immL_M1 m1) %{\n+  match(Set dst (AndV src1 (XorV src2 (ReplicateL m1))));\n+  format %{ \"vand_notL $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ bic($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+             $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_bic($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector and_not - predicated\n+\n+instruct vand_notI_masked(vReg dst_src1, vReg src2, immI_M1 m1, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateB m1))) pg));\n+  match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateS m1))) pg));\n+  match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateI m1))) pg));\n+  format %{ \"vand_notI_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_bic($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vand_notL_masked(vReg dst_src1, vReg src2, immL_M1 m1, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateL m1))) pg));\n+  format %{ \"vand_notL_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_bic($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector abs -----------------------------------\n+\n+\/\/ vector abs\n+\n+instruct vabsB(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (AbsVB src));\n+  format %{ \"vabsB $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ absr($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_abs($dst$$FloatRegister, __ B, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vabsS(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (AbsVS src));\n+  format %{ \"vabsS $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ absr($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_abs($dst$$FloatRegister, __ H, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vabsI(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (AbsVI src));\n+  format %{ \"vabsI $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ absr($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_abs($dst$$FloatRegister, __ S, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vabsL(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (AbsVL src));\n+  format %{ \"vabsL $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ absr($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_abs($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vabsF(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (AbsVF src));\n+  format %{ \"vabsF $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fabs($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fabs($dst$$FloatRegister, __ S, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vabsD(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (AbsVD src));\n+  format %{ \"vabsD $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fabs($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fabs($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector abs - predicated\n+\n+instruct vabsB_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AbsVB dst_src pg));\n+  format %{ \"vabsB_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    __ sve_abs($dst_src$$FloatRegister, __ B, $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vabsS_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AbsVS dst_src pg));\n+  format %{ \"vabsS_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    __ sve_abs($dst_src$$FloatRegister, __ H, $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vabsI_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AbsVI dst_src pg));\n+  format %{ \"vabsI_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    __ sve_abs($dst_src$$FloatRegister, __ S, $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vabsL_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AbsVL dst_src pg));\n+  format %{ \"vabsL_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    __ sve_abs($dst_src$$FloatRegister, __ D, $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vabsF_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AbsVF dst_src pg));\n+  format %{ \"vabsF_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    __ sve_fabs($dst_src$$FloatRegister, __ S, $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vabsD_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AbsVD dst_src pg));\n+  format %{ \"vabsD_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    __ sve_fabs($dst_src$$FloatRegister, __ D, $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector fabd ----------------------------------\n+\n+\/\/ vector fabs diff\n+\n+instruct vfabd(vReg dst, vReg src1, vReg src2) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16);\n+  match(Set dst (AbsVF (SubVF src1 src2)));\n+  match(Set dst (AbsVD (SubVD src1 src2)));\n+  format %{ \"vfabd $dst, $src1, $src2\\t# vector <= 128 bits\" %}\n+  ins_encode %{\n+    __ fabd($dst$$FloatRegister, get_arrangement(this),\n+            $src1$$FloatRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector neg -----------------------------------\n+\n+\/\/ vector neg\n+\n+instruct vnegI(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (NegVI src));\n+  format %{ \"vnegI $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ negr($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      BasicType bt = Matcher::vector_element_basic_type(this);\n+      __ sve_neg($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vnegL(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (NegVL src));\n+  format %{ \"vnegL $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ negr($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_neg($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vnegF(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (NegVF src));\n+  format %{ \"vnegF $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fneg($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fneg($dst$$FloatRegister, __ S, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vnegD(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (NegVD src));\n+  format %{ \"vnegD $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fneg($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fneg($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector neg - predicated\n+\n+instruct vnegI_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (NegVI dst_src pg));\n+  format %{ \"vnegI_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_neg($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vnegL_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (NegVL dst_src pg));\n+  format %{ \"vnegL_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    __ sve_neg($dst_src$$FloatRegister, __ D, $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vnegF_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (NegVF dst_src pg));\n+  format %{ \"vnegF_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    __ sve_fneg($dst_src$$FloatRegister, __ S, $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vnegD_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (NegVD dst_src pg));\n+  format %{ \"vnegD_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    __ sve_fneg($dst_src$$FloatRegister, __ D, $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector sqrt ----------------------------------\n+\n+\/\/ vector sqrt\n+\n+instruct vsqrtF(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (SqrtVF src));\n+  format %{ \"vsqrtF $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fsqrt($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fsqrt($dst$$FloatRegister, __ S, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsqrtD(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (SqrtVD src));\n+  format %{ \"vsqrtD $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fsqrt($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fsqrt($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector sqrt - predicated\n+\n+instruct vsqrtF_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (SqrtVF dst_src pg));\n+  format %{ \"vsqrtF_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    __ sve_fsqrt($dst_src$$FloatRegister, __ S, $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsqrtD_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (SqrtVD dst_src pg));\n+  format %{ \"vsqrtD_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    __ sve_fsqrt($dst_src$$FloatRegister, __ D, $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector min -----------------------------------\n+\n+\/\/ vector min - LONG\n+\n+instruct vminL_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst (MinV src1 src2));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vminL_neon $dst, $src1, $src2\\t# 2L\" %}\n+  ins_encode %{\n+    __ cmgt($dst$$FloatRegister, __ T2D, $src1$$FloatRegister, $src2$$FloatRegister);\n+    __ bsl($dst$$FloatRegister, __ T16B, $src2$$FloatRegister, $src1$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vminL_sve(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst_src1 (MinV dst_src1 src2));\n+  format %{ \"vminL_sve $dst_src1, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_smin($dst_src1$$FloatRegister, __ D, ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector min - B\/S\/I\/F\/D\n+\n+instruct vmin_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(Matcher::vector_element_basic_type(n) != T_LONG &&\n+            VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (MinV src1 src2));\n+  format %{ \"vmin_neon $dst, $src1, $src2\\t# B\/S\/I\/F\/D\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(bt)) {\n+      __ fmin($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(is_integral_type(bt) && bt != T_LONG, \"unsupported type\");\n+      __ minv($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmin_sve(vReg dst_src1, vReg src2) %{\n+  predicate(Matcher::vector_element_basic_type(n) != T_LONG &&\n+            !VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 (MinV dst_src1 src2));\n+  format %{ \"vmin_sve $dst_src1, $dst_src1, $src2\\t# B\/S\/I\/F\/D\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(bt)) {\n+      __ sve_fmin($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  ptrue, $src2$$FloatRegister);\n+    } else {\n+      assert(is_integral_type(bt) && bt != T_LONG, \"unsupported type\");\n+      __ sve_smin($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  ptrue, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector min - predicated\n+\n+instruct vmin_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (MinV (Binary dst_src1 src2) pg));\n+  format %{ \"vmin_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(bt)) {\n+      __ sve_fmin($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  $pg$$PRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(is_integral_type(bt), \"unsupported type\");\n+      __ sve_smin($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  $pg$$PRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector max -----------------------------------\n+\n+\/\/ vector max - LONG\n+\n+instruct vmaxL_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst (MaxV src1 src2));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vmaxL_neon $dst, $src1, $src2\\t# 2L\" %}\n+  ins_encode %{\n+    __ cmgt($dst$$FloatRegister, __ T2D, $src1$$FloatRegister, $src2$$FloatRegister);\n+    __ bsl($dst$$FloatRegister, __ T16B, $src1$$FloatRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaxL_sve(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst_src1 (MaxV dst_src1 src2));\n+  format %{ \"vmaxL_sve $dst_src1, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_smax($dst_src1$$FloatRegister, __ D, ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector max - B\/S\/I\/F\/D\n+\n+instruct vmax_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(Matcher::vector_element_basic_type(n) != T_LONG &&\n+            VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (MaxV src1 src2));\n+  format %{ \"vmax_neon $dst, $src1, $src2\\t# B\/S\/I\/F\/D\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(bt)) {\n+      __ fmax($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(is_integral_type(bt) && bt != T_LONG, \"unsupported type\");\n+      __ maxv($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmax_sve(vReg dst_src1, vReg src2) %{\n+  predicate(Matcher::vector_element_basic_type(n) != T_LONG &&\n+            !VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 (MaxV dst_src1 src2));\n+  format %{ \"vmax_sve $dst_src1, $dst_src1, $src2\\t# B\/S\/I\/F\/D\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(bt)) {\n+      __ sve_fmax($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  ptrue, $src2$$FloatRegister);\n+    } else {\n+      assert(is_integral_type(bt) && bt != T_LONG, \"unsupported type\");\n+      __ sve_smax($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  ptrue, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector max - predicated\n+\n+instruct vmax_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (MaxV (Binary dst_src1 src2) pg));\n+  format %{ \"vmax_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(bt)) {\n+      __ sve_fmax($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  $pg$$PRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(is_integral_type(bt), \"unsupported type\");\n+      __ sve_smax($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  $pg$$PRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ MLA RELATED ----------------------------------\n+\n+\/\/ vector mla\n+\/\/ dst_src1 = dst_src1 + src2 * src3\n+\n+instruct vmla(vReg dst_src1, vReg src2, vReg src3) %{\n+  match(Set dst_src1 (AddVB dst_src1 (MulVB src2 src3)));\n+  match(Set dst_src1 (AddVS dst_src1 (MulVS src2 src3)));\n+  match(Set dst_src1 (AddVI dst_src1 (MulVI src2 src3)));\n+  match(Set dst_src1 (AddVL dst_src1 (MulVL src2 src3)));\n+  format %{ \"vmla $dst_src1, src2, src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes) && bt != T_LONG) {\n+      \/\/ NEON mlav does not accept T2D arrangement.\n+      __ mlav($dst_src1$$FloatRegister, get_arrangement(this),\n+              $src2$$FloatRegister, $src3$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_mla($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 ptrue, $src2$$FloatRegister, $src3$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmla_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddVB (Binary dst_src1 (MulVB src2 src3)) pg));\n+  match(Set dst_src1 (AddVS (Binary dst_src1 (MulVS src2 src3)) pg));\n+  match(Set dst_src1 (AddVI (Binary dst_src1 (MulVI src2 src3)) pg));\n+  match(Set dst_src1 (AddVL (Binary dst_src1 (MulVL src2 src3)) pg));\n+  format %{ \"vmla_masked $dst_src1, $pg, src2, src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_mla($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fmla\n+\/\/ dst_src1 = dst_src1 + src2 * src3\n+\n+instruct vfmla(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA);\n+  match(Set dst_src1 (FmaVF dst_src1 (Binary src2 src3)));\n+  match(Set dst_src1 (FmaVD dst_src1 (Binary src2 src3)));\n+  format %{ \"vfmla $dst_src1, $src2, $src3\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fmla($dst_src1$$FloatRegister, get_arrangement(this),\n+              $src2$$FloatRegister, $src3$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      BasicType bt = Matcher::vector_element_basic_type(this);\n+      __ sve_fmla($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  ptrue, $src2$$FloatRegister, $src3$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fmad - predicated\n+\/\/ dst_src1 = dst_src1 * src2 + src3\n+\n+instruct vfmad_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n+  predicate(UseFMA && UseSVE > 0);\n+  match(Set dst_src1 (FmaVF (Binary dst_src1 src2) (Binary src3 pg)));\n+  match(Set dst_src1 (FmaVD (Binary dst_src1 src2) (Binary src3 pg)));\n+  format %{ \"vfmad_masked $dst_src1, $pg, $src2, $src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fmad($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                $pg$$PRegister, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector mls\n+\/\/ dst_src1 = dst_src1 - src2 * src3\n+\n+instruct vmls(vReg dst_src1, vReg src2, vReg src3) %{\n+  match(Set dst_src1 (SubVB dst_src1 (MulVB src2 src3)));\n+  match(Set dst_src1 (SubVS dst_src1 (MulVS src2 src3)));\n+  match(Set dst_src1 (SubVI dst_src1 (MulVI src2 src3)));\n+  match(Set dst_src1 (SubVL dst_src1 (MulVL src2 src3)));\n+  format %{ \"vmls $dst_src1, src2, src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes) && bt != T_LONG) {\n+      \/\/ NEON mlsv does not accept T2D arrangement.\n+      __ mlsv($dst_src1$$FloatRegister, get_arrangement(this),\n+              $src2$$FloatRegister, $src3$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_mls($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 ptrue, $src2$$FloatRegister, $src3$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmls_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (SubVB (Binary dst_src1 (MulVB src2 src3)) pg));\n+  match(Set dst_src1 (SubVS (Binary dst_src1 (MulVS src2 src3)) pg));\n+  match(Set dst_src1 (SubVI (Binary dst_src1 (MulVI src2 src3)) pg));\n+  match(Set dst_src1 (SubVL (Binary dst_src1 (MulVL src2 src3)) pg));\n+  format %{ \"vmls_masked $dst_src1, $pg, src2, src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_mls($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fmls\n+\n+\/\/ dst_src1 = dst_src1 + -src2 * src3\n+\/\/ The NegVF\/NegVD must not be predicated.\n+instruct vfmls1(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVF dst_src1 (Binary (NegVF src2) src3)));\n+  match(Set dst_src1 (FmaVD dst_src1 (Binary (NegVD src2) src3)));\n+  format %{ \"vfmls1 $dst_src1, $src2, $src3\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fmls($dst_src1$$FloatRegister, get_arrangement(this),\n+              $src2$$FloatRegister, $src3$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      BasicType bt = Matcher::vector_element_basic_type(this);\n+      __ sve_fmls($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  ptrue, $src2$$FloatRegister, $src3$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = dst_src1 + src2 * -src3\n+\/\/ The NegVF\/NegVD must not be predicated.\n+instruct vfmls2(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && !n->in(2)->in(2)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVF dst_src1 (Binary src2 (NegVF src3))));\n+  match(Set dst_src1 (FmaVD dst_src1 (Binary src2 (NegVD src3))));\n+  format %{ \"vfmls2 $dst_src1, $src2, $src3\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fmls($dst_src1$$FloatRegister, get_arrangement(this),\n+              $src2$$FloatRegister, $src3$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      BasicType bt = Matcher::vector_element_basic_type(this);\n+      __ sve_fmls($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  ptrue, $src2$$FloatRegister, $src3$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fmsb - predicated\n+\n+\/\/ dst_src1 = dst_src1 * -src2 + src3\n+\/\/ The NegVF\/NegVD must not be predicated.\n+instruct vfmsb_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(1)->in(2)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVF (Binary dst_src1 (NegVF src2)) (Binary src3 pg)));\n+  match(Set dst_src1 (FmaVD (Binary dst_src1 (NegVD src2)) (Binary src3 pg)));\n+  format %{ \"vfmsb_masked $dst_src1, $pg, $src2, $src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fmsb($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                $pg$$PRegister, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fnmla (sve)\n+\n+\/\/ dst_src1 = -dst_src1 + -src2 * src3\n+\/\/ The NegVF\/NegVD must not be predicated.\n+instruct vfnmla1(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(1)->as_Vector()->is_predicated_vector() &&\n+            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVF (NegVF dst_src1) (Binary (NegVF src2) src3)));\n+  match(Set dst_src1 (FmaVD (NegVD dst_src1) (Binary (NegVD src2) src3)));\n+  format %{ \"vfnmla1 $dst_src1, $src2, $src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fnmla($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 ptrue, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = -dst_src1 + src2 * -src3\n+\/\/ The NegVF\/NegVD must not be predicated.\n+instruct vfnmla2(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(1)->as_Vector()->is_predicated_vector() &&\n+            !n->in(2)->in(2)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVF (NegVF dst_src1) (Binary src2 (NegVF src3))));\n+  match(Set dst_src1 (FmaVD (NegVD dst_src1) (Binary src2 (NegVD src3))));\n+  format %{ \"vfnmla2 $dst_src1, $src2, $src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fnmla($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 ptrue, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fnmad - predicated\n+\n+\/\/ dst_src1 = -src3 + dst_src1 * -src2\n+\/\/ The NegVF\/NegVD must not be predicated.\n+instruct vfnmad_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(1)->in(2)->as_Vector()->is_predicated_vector() &&\n+            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVF (Binary dst_src1 (NegVF src2)) (Binary (NegVF src3) pg)));\n+  match(Set dst_src1 (FmaVD (Binary dst_src1 (NegVD src2)) (Binary (NegVD src3) pg)));\n+  format %{ \"vfnmad_masked $dst_src1, $pg, $src2, $src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fnmad($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 $pg$$PRegister, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fnmls (sve)\n+\n+\/\/ dst_src1 = -dst_src1 + src2 * src3\n+\/\/ The NegVF\/NegVD must not be predicated.\n+instruct vfnmls(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(1)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVF (NegVF dst_src1) (Binary src2 src3)));\n+  match(Set dst_src1 (FmaVD (NegVD dst_src1) (Binary src2 src3)));\n+  format %{ \"vfnmls $dst_src1, $src2, $src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fnmls($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 ptrue, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fnmsb - predicated\n+\n+\/\/ dst_src1 = -src3 + dst_src1 * src2\n+\/\/ The NegVF\/NegVD must not be predicated.\n+instruct vfnmsb_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVF (Binary dst_src1 src2) (Binary (NegVF src3) pg)));\n+  match(Set dst_src1 (FmaVD (Binary dst_src1 src2) (Binary (NegVD src3) pg)));\n+  format %{ \"vfnmsb_masked $dst_src1, $pg, $src2, $src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fnmsb($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 $pg$$PRegister, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ MulAddVS2VI\n+\/\/ Vector Multiply-Add Shorts into Integer\n+\n+instruct vmuladdS2I(vReg dst, vReg src1, vReg src2, vReg tmp) %{\n+  predicate(Matcher::vector_length_in_bytes(n) == 16 &&\n+            Matcher::vector_element_basic_type(n->in(1)) == T_SHORT);\n+  match(Set dst (MulAddVS2VI src1 src2));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vmuladdS2I $dst, $src1, $src2\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ smullv($tmp$$FloatRegister, __ T4H, $src1$$FloatRegister, $src2$$FloatRegister);\n+    __ smullv($dst$$FloatRegister, __ T8H, $src1$$FloatRegister, $src2$$FloatRegister);\n+    __ addpv($dst$$FloatRegister, __ T4S, $tmp$$FloatRegister, $dst$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector shift ---------------------------------\n+\n+\/\/ Vector right shift in AArch64 ASIMD\n+\/\/\n+\/\/ Right shifts with vector shift count on AArch64 ASIMD are implemented\n+\/\/ as left shift by negative shift count.\n+\/\/ There are two cases for vector shift count.\n+\/\/\n+\/\/ Case 1: The vector shift count is from replication.\n+\/\/        |            |\n+\/\/    LoadVector  RShiftCntV\n+\/\/        |       \/\n+\/\/     RShiftVI\n+\/\/\n+\/\/ Case 2: The vector shift count is from loading.\n+\/\/ This case isn't supported by middle-end now. But it's supported by\n+\/\/ panama\/vectorIntrinsics(JEP 338: Vector API).\n+\/\/        |            |\n+\/\/    LoadVector  LoadVector\n+\/\/        |       \/\n+\/\/     RShiftVI\n+\/\/\n+\/\/ The negate is conducted in RShiftCntV rule for case 1, whereas it's done in\n+\/\/ RShiftV* rules for case 2. Because there exists an optimization opportunity\n+\/\/ for case 1, that is, multiple neg instructions in inner loop can be hoisted\n+\/\/ to outer loop and merged into one neg instruction.\n+\/\/\n+\/\/ Note that ShiftVNode::is_var_shift() indicates whether the vector shift\n+\/\/ count is a variable vector(case 2) or not(a vector generated by RShiftCntV,\n+\/\/ i.e. case 1).\n+\n+\/\/ vector shift count\n+\n+instruct vshiftcntL(vReg dst, iRegIorL2I cnt) %{\n+  match(Set dst (LShiftCntV cnt));\n+  format %{ \"vshiftcntL $dst, $cnt\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ dup($dst$$FloatRegister, get_arrangement(this), $cnt$$Register);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      BasicType bt = Matcher::vector_element_basic_type(this);\n+      __ sve_dup($dst$$FloatRegister, __ elemType_to_regVariant(bt), $cnt$$Register);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vshiftcntR(vReg dst, iRegIorL2I cnt) %{\n+  match(Set dst (RShiftCntV cnt));\n+  format %{ \"vshiftcntR $dst, $cnt\" %}\n+  ins_encode %{\n+    if (UseSVE == 0) {\n+      uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+      assert(length_in_bytes <= 16, \"must be\");\n+      __ negw(rscratch1, $cnt$$Register);\n+      __ dup($dst$$FloatRegister, get_arrangement(this), rscratch1);\n+    } else {\n+      BasicType bt = Matcher::vector_element_basic_type(this);\n+      __ sve_dup($dst$$FloatRegister, __ elemType_to_regVariant(bt), $cnt$$Register);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector shift left\n+\n+instruct vlsl_neon(vReg dst, vReg src, vReg shift) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (LShiftVB src shift));\n+  match(Set dst (LShiftVS src shift));\n+  match(Set dst (LShiftVI src shift));\n+  match(Set dst (LShiftVL src shift));\n+  format %{ \"vlsl_neon $dst, $src, $shift\" %}\n+  ins_encode %{\n+    __ sshl($dst$$FloatRegister, get_arrangement(this),\n+            $src$$FloatRegister, $shift$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsl_sve(vReg dst_src, vReg shift) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src (LShiftVB dst_src shift));\n+  match(Set dst_src (LShiftVS dst_src shift));\n+  match(Set dst_src (LShiftVI dst_src shift));\n+  match(Set dst_src (LShiftVL dst_src shift));\n+  format %{ \"vlsl_sve $dst_src, $dst_src, $shift\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_lsl($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+               ptrue, $shift$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector shift right (arithmetic)\n+\n+instruct vasr_neon(vReg dst, vReg src, vReg shift) %{\n+  predicate(UseSVE == 0 && !n->as_ShiftV()->is_var_shift());\n+  match(Set dst (RShiftVB src shift));\n+  match(Set dst (RShiftVS src shift));\n+  match(Set dst (RShiftVI src shift));\n+  match(Set dst (RShiftVL src shift));\n+  format %{ \"vasr_neon $dst, $src, $shift\\t# not variable shift\" %}\n+  ins_encode %{\n+    __ sshl($dst$$FloatRegister, get_arrangement(this),\n+            $src$$FloatRegister, $shift$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasr_neon_var(vReg dst, vReg src, vReg shift) %{\n+  predicate(UseSVE == 0 && n->as_ShiftV()->is_var_shift());\n+  match(Set dst (RShiftVB src shift));\n+  match(Set dst (RShiftVS src shift));\n+  match(Set dst (RShiftVI src shift));\n+  match(Set dst (RShiftVL src shift));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vasr_neon_var $dst, $src, $shift\\t# variable shift\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ negr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+            $shift$$FloatRegister);\n+    __ sshl($dst$$FloatRegister, get_arrangement(this),\n+            $src$$FloatRegister, $dst$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasr_sve(vReg dst_src, vReg shift) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (RShiftVB dst_src shift));\n+  match(Set dst_src (RShiftVS dst_src shift));\n+  match(Set dst_src (RShiftVI dst_src shift));\n+  match(Set dst_src (RShiftVL dst_src shift));\n+  format %{ \"vasr_sve $dst_src, $dst_src, $shift\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_asr($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+               ptrue, $shift$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector shift right (logical)\n+\n+instruct vlsr_neon(vReg dst, vReg src, vReg shift) %{\n+  predicate(UseSVE == 0 && !n->as_ShiftV()->is_var_shift());\n+  match(Set dst (URShiftVB src shift));\n+  match(Set dst (URShiftVS src shift));\n+  match(Set dst (URShiftVI src shift));\n+  match(Set dst (URShiftVL src shift));\n+  format %{ \"vlsr_neon $dst, $src, $shift\\t# not variable shift\" %}\n+  ins_encode %{\n+    __ ushl($dst$$FloatRegister, get_arrangement(this),\n+            $src$$FloatRegister, $shift$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsr_neon_var(vReg dst, vReg src, vReg shift) %{\n+  predicate(UseSVE == 0 && n->as_ShiftV()->is_var_shift());\n+  match(Set dst (URShiftVB src shift));\n+  match(Set dst (URShiftVS src shift));\n+  match(Set dst (URShiftVI src shift));\n+  match(Set dst (URShiftVL src shift));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vlsr_neon_var $dst, $src, $shift\\t# variable shift\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ negr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+            $shift$$FloatRegister);\n+    __ ushl($dst$$FloatRegister, get_arrangement(this),\n+            $src$$FloatRegister, $dst$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsr_sve(vReg dst_src, vReg shift) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (URShiftVB dst_src shift));\n+  match(Set dst_src (URShiftVS dst_src shift));\n+  match(Set dst_src (URShiftVI dst_src shift));\n+  match(Set dst_src (URShiftVL dst_src shift));\n+  format %{ \"vlsr_sve $dst_src, $dst_src, $shift\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_lsr($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+               ptrue, $shift$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector shift with imm\n+\n+instruct vlsl_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(assert_not_var_shift(n));\n+  match(Set dst (LShiftVB src (LShiftCntV shift)));\n+  match(Set dst (LShiftVS src (LShiftCntV shift)));\n+  match(Set dst (LShiftVI src (LShiftCntV shift)));\n+  match(Set dst (LShiftVL src (LShiftCntV shift)));\n+  format %{ \"vlsl_imm $dst, $src, $shift\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    int con = (int)$shift$$constant;\n+    if (is_subword_type(bt)) {\n+      \/\/ Optimize for B\/S\n+      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;\n+      if (con >= esize_in_bits) {\n+        if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+          __ eor($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+                 $src$$FloatRegister, $src$$FloatRegister);\n+        } else {\n+          assert(UseSVE > 0, \"must be sve\");\n+          __ sve_eor($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+        }\n+        return;\n+      }\n+    }\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ shl($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister, con);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_lsl($dst$$FloatRegister, __ elemType_to_regVariant(bt), $src$$FloatRegister, con);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasr_imm(vReg dst, vReg src, immI_positive shift) %{\n+  predicate(assert_not_var_shift(n));\n+  match(Set dst (RShiftVB src (RShiftCntV shift)));\n+  match(Set dst (RShiftVS src (RShiftCntV shift)));\n+  match(Set dst (RShiftVI src (RShiftCntV shift)));\n+  match(Set dst (RShiftVL src (RShiftCntV shift)));\n+  format %{ \"vasr_imm $dst, $src, $shift\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    int con = (int)$shift$$constant;\n+    if (is_subword_type(bt)) {\n+      \/\/ Refine con for B\/S\n+      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;\n+      if (con >= esize_in_bits) con = esize_in_bits - 1;\n+    }\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ sshr($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister, con);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_asr($dst$$FloatRegister, __ elemType_to_regVariant(bt), $src$$FloatRegister, con);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsr_imm(vReg dst, vReg src, immI_positive shift) %{\n+  predicate(assert_not_var_shift(n));\n+  match(Set dst (URShiftVB src (RShiftCntV shift)));\n+  match(Set dst (URShiftVS src (RShiftCntV shift)));\n+  match(Set dst (URShiftVI src (RShiftCntV shift)));\n+  match(Set dst (URShiftVL src (RShiftCntV shift)));\n+  format %{ \"vlsr_imm $dst, $src, $shift\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    int con = (int)$shift$$constant;\n+    if (is_subword_type(bt)) {\n+      \/\/ Optimize for B\/S\n+      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;\n+      if (con >= esize_in_bits) {\n+        if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+          __ eor($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+                 $src$$FloatRegister, $src$$FloatRegister);\n+        } else {\n+          assert(UseSVE > 0, \"must be sve\");\n+          __ sve_eor($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+        }\n+        return;\n+      }\n+    }\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ ushr($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister, con);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_lsr($dst$$FloatRegister, __ elemType_to_regVariant(bt), $src$$FloatRegister, con);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ shift right add with imm (vector length <= 128 bits only)\n+\n+instruct vasra_imm(vReg dst, vReg src, immI_positive shift) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16);\n+  match(Set dst (AddVB dst (RShiftVB src (RShiftCntV shift))));\n+  match(Set dst (AddVS dst (RShiftVS src (RShiftCntV shift))));\n+  match(Set dst (AddVI dst (RShiftVI src (RShiftCntV shift))));\n+  match(Set dst (AddVL dst (RShiftVL src (RShiftCntV shift))));\n+  format %{ \"vasra_imm $dst, $src, $shift\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int con = (int)$shift$$constant;\n+    if (is_subword_type(bt)) {\n+      \/\/ Refine con for B\/S\n+      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;\n+      if (con >= esize_in_bits) con = esize_in_bits - 1;\n+    }\n+    __ ssra($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister, con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsra_imm(vReg dst, vReg src, immI_positive shift) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16);\n+  match(Set dst (AddVB dst (URShiftVB src (RShiftCntV shift))));\n+  match(Set dst (AddVS dst (URShiftVS src (RShiftCntV shift))));\n+  match(Set dst (AddVI dst (URShiftVI src (RShiftCntV shift))));\n+  match(Set dst (AddVL dst (URShiftVL src (RShiftCntV shift))));\n+  format %{ \"vlsra_imm $dst, $src, $shift\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int con = (int)$shift$$constant;\n+    if (is_subword_type(bt)) { \/\/ for B\/H\n+      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;\n+      if (con < esize_in_bits) {\n+        __ usra($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister, con);\n+      }\n+    } else { \/\/ for S\/D\n+      assert(type2aelembytes(bt) == 4 || type2aelembytes(bt) == 8, \"unsupported type\");\n+      __ usra($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister, con);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector shift - predicated\n+\n+instruct vlsl_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (LShiftVB (Binary dst_src1 src2) pg));\n+  match(Set dst_src1 (LShiftVS (Binary dst_src1 src2) pg));\n+  match(Set dst_src1 (LShiftVI (Binary dst_src1 src2) pg));\n+  match(Set dst_src1 (LShiftVL (Binary dst_src1 src2) pg));\n+  format %{ \"vlsl_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_lsl($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasr_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (RShiftVB (Binary dst_src1 src2) pg));\n+  match(Set dst_src1 (RShiftVS (Binary dst_src1 src2) pg));\n+  match(Set dst_src1 (RShiftVI (Binary dst_src1 src2) pg));\n+  match(Set dst_src1 (RShiftVL (Binary dst_src1 src2) pg));\n+  format %{ \"vasr_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_asr($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsr_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (URShiftVB (Binary dst_src1 src2) pg));\n+  match(Set dst_src1 (URShiftVS (Binary dst_src1 src2) pg));\n+  match(Set dst_src1 (URShiftVI (Binary dst_src1 src2) pg));\n+  match(Set dst_src1 (URShiftVL (Binary dst_src1 src2) pg));\n+  format %{ \"vlsr_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_lsr($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector shift with imm - predicated\n+\n+instruct vlsl_imm_masked(vReg dst_src, immI shift, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (LShiftVB (Binary dst_src (LShiftCntV shift)) pg));\n+  match(Set dst_src (LShiftVS (Binary dst_src (LShiftCntV shift)) pg));\n+  match(Set dst_src (LShiftVI (Binary dst_src (LShiftCntV shift)) pg));\n+  match(Set dst_src (LShiftVL (Binary dst_src (LShiftCntV shift)) pg));\n+  format %{ \"vlsl_imm_masked $dst_src, $pg, $dst_src, $shift\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int esize_in_bits = type2aelembytes(bt) * BitsPerByte;\n+    int con = (int)$shift$$constant;\n+    assert(con >= 0 && con < esize_in_bits, \"invalid shift immediate\");\n+    __ sve_lsl($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasr_imm_masked(vReg dst_src, immI_positive shift, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (RShiftVB (Binary dst_src (RShiftCntV shift)) pg));\n+  match(Set dst_src (RShiftVS (Binary dst_src (RShiftCntV shift)) pg));\n+  match(Set dst_src (RShiftVI (Binary dst_src (RShiftCntV shift)) pg));\n+  match(Set dst_src (RShiftVL (Binary dst_src (RShiftCntV shift)) pg));\n+  format %{ \"vasr_imm_masked $dst_src, $pg, $dst_src, $shift\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int esize_in_bits = type2aelembytes(bt) * BitsPerByte;\n+    int con = (int)$shift$$constant;\n+    assert(con > 0 && con < esize_in_bits, \"invalid shift immediate\");\n+    __ sve_asr($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsr_imm_masked(vReg dst_src, immI_positive shift, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (URShiftVB (Binary dst_src (RShiftCntV shift)) pg));\n+  match(Set dst_src (URShiftVS (Binary dst_src (RShiftCntV shift)) pg));\n+  match(Set dst_src (URShiftVI (Binary dst_src (RShiftCntV shift)) pg));\n+  match(Set dst_src (URShiftVL (Binary dst_src (RShiftCntV shift)) pg));\n+  format %{ \"vlsr_imm_masked $dst_src, $pg, $dst_src, $shift\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int esize_in_bits = type2aelembytes(bt) * BitsPerByte;\n+    int con = (int)$shift$$constant;\n+    assert(con > 0 && con < esize_in_bits, \"invalid shift immediate\");\n+    __ sve_lsr($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector reduction add -------------------------\n+\n+\/\/ reduction addI\n+\n+instruct reduce_addI_neon(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, vReg tmp) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(2))));\n+  match(Set dst (AddReductionVI isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_addI_neon $dst, $isrc, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ neon_reduce_add_integral($dst$$Register, bt,\n+                                $isrc$$Register, $vsrc$$FloatRegister,\n+                                length_in_bytes, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addI_sve(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, vRegD tmp) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(2))));\n+  match(Set dst (AddReductionVI isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_addI_sve $dst, $isrc, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           ptrue, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ reduction addL\n+\n+instruct reduce_addL_neon(iRegLNoSp dst, iRegL isrc, vReg vsrc, vReg tmp) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(2))));\n+  match(Set dst (AddReductionVL isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_addL_neon $dst, $isrc, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ neon_reduce_add_integral($dst$$Register, bt,\n+                                $isrc$$Register, $vsrc$$FloatRegister,\n+                                length_in_bytes, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addL_sve(iRegLNoSp dst, iRegL isrc, vReg vsrc, vRegD tmp) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(2))));\n+  match(Set dst (AddReductionVL isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_addL_sve $dst, $isrc, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           ptrue, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ reduction addF\n+\n+instruct reduce_addF_neon(vRegF dst, vRegF fsrc, vReg vsrc, vReg tmp) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (AddReductionVF fsrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_addF_neon $dst, $fsrc, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ fadds($dst$$FloatRegister, $fsrc$$FloatRegister, $vsrc$$FloatRegister);\n+    __ ins($tmp$$FloatRegister, __ S, $vsrc$$FloatRegister, 0, 1);\n+    __ fadds($dst$$FloatRegister, $dst$$FloatRegister, $tmp$$FloatRegister);\n+    if (length_in_bytes == 16) {\n+      __ ins($tmp$$FloatRegister, __ S, $vsrc$$FloatRegister, 0, 2);\n+      __ fadds($dst$$FloatRegister, $dst$$FloatRegister, $tmp$$FloatRegister);\n+      __ ins($tmp$$FloatRegister, __ S, $vsrc$$FloatRegister, 0, 3);\n+      __ fadds($dst$$FloatRegister, $dst$$FloatRegister, $tmp$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addF_sve(vRegF dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddReductionVF dst_src1 src2));\n+  format %{ \"reduce_addF_sve $dst_src1, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src2);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_fadda($dst_src1$$FloatRegister, __ S, ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ reduction addD\n+\n+instruct reduce_addD_neon(vRegD dst, vRegD dsrc, vReg vsrc, vReg tmp) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (AddReductionVD dsrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_addD_neon $dst, $dsrc, $vsrc\\t# 2D. KILL $tmp\" %}\n+  ins_encode %{\n+    __ faddd($dst$$FloatRegister, $dsrc$$FloatRegister, $vsrc$$FloatRegister);\n+    __ ins($tmp$$FloatRegister, __ D, $vsrc$$FloatRegister, 0, 1);\n+    __ faddd($dst$$FloatRegister, $dst$$FloatRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addD_sve(vRegD dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddReductionVD dst_src1 src2));\n+  format %{ \"reduce_addD_sve $dst_src1, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src2);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_fadda($dst_src1$$FloatRegister, __ D, ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ reduction add - predicated\n+\n+instruct reduce_addI_masked(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, pRegGov pg, vRegD tmp) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (AddReductionVI (Binary isrc vsrc) pg));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_addI_masked $dst, $isrc, $pg, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           $pg$$PRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addL_masked(iRegLNoSp dst, iRegL isrc, vReg vsrc, pRegGov pg, vRegD tmp) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (AddReductionVL (Binary isrc vsrc) pg));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_addL_masked $dst, $isrc, $pg, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           $pg$$PRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addF_masked(vRegF dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddReductionVF (Binary dst_src1 src2) pg));\n+  format %{ \"reduce_addF_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fadda($dst_src1$$FloatRegister, __ S,\n+                 $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addD_masked(vRegD dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddReductionVD (Binary dst_src1 src2) pg));\n+  format %{ \"reduce_addD_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fadda($dst_src1$$FloatRegister, __ D,\n+                 $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector reduction mul -------------------------\n+\n+instruct reduce_mulI(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc,\n+                     vReg tmp1, vReg tmp2) %{\n+  predicate(Matcher::vector_length_in_bytes(n->in(2)) == 8 ||\n+            Matcher::vector_length_in_bytes(n->in(2)) == 16);\n+  match(Set dst (MulReductionVI isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);\n+  format %{ \"reduce_mulI $dst, $isrc, $vsrc\\t# vector (64\/128 bits). KILL $tmp1, $tmp2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ neon_reduce_mul_integral($dst$$Register, bt, $isrc$$Register,\n+                                $vsrc$$FloatRegister, length_in_bytes,\n+                                $tmp1$$FloatRegister, $tmp2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_mulL(iRegLNoSp dst, iRegL isrc, vReg vsrc) %{\n+  predicate(Matcher::vector_length_in_bytes(n->in(2)) == 16);\n+  match(Set dst (MulReductionVL isrc vsrc));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_mulL $dst, $isrc, $vsrc\\t# 2L\" %}\n+  ins_encode %{\n+    __ neon_reduce_mul_integral($dst$$Register, T_LONG, $isrc$$Register,\n+                                $vsrc$$FloatRegister, 16, fnoreg, fnoreg);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_mulF(vRegF dst, vRegF fsrc, vReg vsrc, vReg tmp) %{\n+  predicate(Matcher::vector_length_in_bytes(n->in(2)) <= 16);\n+  match(Set dst (MulReductionVF fsrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_mulF $dst, $fsrc, $vsrc\\t# 2F\/4F. KILL $tmp\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ neon_reduce_mul_fp($dst$$FloatRegister, T_FLOAT, $fsrc$$FloatRegister,\n+                          $vsrc$$FloatRegister, length_in_bytes, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_mulD(vRegD dst, vRegD dsrc, vReg vsrc, vReg tmp) %{\n+  predicate(Matcher::vector_length_in_bytes(n->in(2)) == 16);\n+  match(Set dst (MulReductionVD dsrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_mulD $dst, $dsrc, $vsrc\\t# 2D. KILL $tmp\" %}\n+  ins_encode %{\n+    __ neon_reduce_mul_fp($dst$$FloatRegister, T_DOUBLE, $dsrc$$FloatRegister,\n+                          $vsrc$$FloatRegister, 16, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector reduction and -------------------------\n+\n+\/\/ reduction andI\n+\n+instruct reduce_andI_neon(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n->in(2)) != T_LONG);\n+  match(Set dst (AndReductionV isrc vsrc));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_andI_neon $dst, $isrc, $vsrc\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ neon_reduce_logical(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_andI_sve(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, vRegD tmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(2)) != T_LONG);\n+  match(Set dst (AndReductionV isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_andI_sve $dst, $isrc, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           ptrue, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ reduction andL\n+\n+instruct reduce_andL_neon(iRegLNoSp dst, iRegL isrc, vReg vsrc) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n->in(2)) == T_LONG);\n+  match(Set dst (AndReductionV isrc vsrc));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_andL_neon $dst, $isrc, $vsrc\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ neon_reduce_logical(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_andL_sve(iRegLNoSp dst, iRegL isrc, vReg vsrc, vRegD tmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(2)) == T_LONG);\n+  match(Set dst (AndReductionV isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_andL_sve $dst, $isrc, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           ptrue, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ reduction and - predicated\n+\n+instruct reduce_andI_masked(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, pRegGov pg, vRegD tmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(1)->in(2)) != T_LONG);\n+  match(Set dst (AndReductionV (Binary isrc vsrc) pg));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_andI_masked $dst, $isrc, $pg, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           $pg$$PRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_andL_masked(iRegLNoSp dst, iRegL isrc, vReg vsrc, pRegGov pg, vRegD tmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_LONG);\n+  match(Set dst (AndReductionV (Binary isrc vsrc) pg));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_andL_masked $dst, $isrc, $pg, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           $pg$$PRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector reduction or --------------------------\n+\n+\/\/ reduction orI\n+\n+instruct reduce_orI_neon(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n->in(2)) != T_LONG);\n+  match(Set dst (OrReductionV isrc vsrc));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_orI_neon $dst, $isrc, $vsrc\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ neon_reduce_logical(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_orI_sve(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, vRegD tmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(2)) != T_LONG);\n+  match(Set dst (OrReductionV isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_orI_sve $dst, $isrc, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           ptrue, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ reduction orL\n+\n+instruct reduce_orL_neon(iRegLNoSp dst, iRegL isrc, vReg vsrc) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n->in(2)) == T_LONG);\n+  match(Set dst (OrReductionV isrc vsrc));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_orL_neon $dst, $isrc, $vsrc\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ neon_reduce_logical(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_orL_sve(iRegLNoSp dst, iRegL isrc, vReg vsrc, vRegD tmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(2)) == T_LONG);\n+  match(Set dst (OrReductionV isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_orL_sve $dst, $isrc, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           ptrue, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ reduction or - predicated\n+\n+instruct reduce_orI_masked(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, pRegGov pg, vRegD tmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(1)->in(2)) != T_LONG);\n+  match(Set dst (OrReductionV (Binary isrc vsrc) pg));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_orI_masked $dst, $isrc, $pg, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           $pg$$PRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_orL_masked(iRegLNoSp dst, iRegL isrc, vReg vsrc, pRegGov pg, vRegD tmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_LONG);\n+  match(Set dst (OrReductionV (Binary isrc vsrc) pg));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_orL_masked $dst, $isrc, $pg, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           $pg$$PRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector reduction xor -------------------------\n+\n+\/\/ reduction xorI\n+\n+instruct reduce_xorI_neon(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n->in(2)) != T_LONG);\n+  match(Set dst (XorReductionV isrc vsrc));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_xorI_neon $dst, $isrc, $vsrc\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ neon_reduce_logical(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_xorI_sve(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, vRegD tmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(2)) != T_LONG);\n+  match(Set dst (XorReductionV isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_xorI_sve $dst, $isrc, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           ptrue, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ reduction xorL\n+\n+instruct reduce_xorL_neon(iRegLNoSp dst, iRegL isrc, vReg vsrc) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n->in(2)) == T_LONG);\n+  match(Set dst (XorReductionV isrc vsrc));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_xorL_neon $dst, $isrc, $vsrc\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ neon_reduce_logical(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_xorL_sve(iRegLNoSp dst, iRegL isrc, vReg vsrc, vRegD tmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(2)) == T_LONG);\n+  match(Set dst (XorReductionV isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_xorL_sve $dst, $isrc, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           ptrue, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ reduction xor - predicated\n+\n+instruct reduce_xorI_masked(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, pRegGov pg, vRegD tmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(1)->in(2)) != T_LONG);\n+  match(Set dst (XorReductionV (Binary isrc vsrc) pg));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_xorI_masked $dst, $isrc, $pg, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           $pg$$PRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_xorL_masked(iRegLNoSp dst, iRegL isrc, vReg vsrc, pRegGov pg, vRegD tmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_LONG);\n+  match(Set dst (XorReductionV (Binary isrc vsrc) pg));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_xorL_masked $dst, $isrc, $pg, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           $pg$$PRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector reduction max -------------------------\n+\n+\/\/ reduction maxI\n+\n+instruct reduce_maxI_neon(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc,\n+                          vReg tmp, rFlagsReg cr) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(2))) &&\n+            (Matcher::vector_element_basic_type(n->in(2)) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n->in(2)) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n->in(2)) == T_INT));\n+  match(Set dst (MaxReductionV isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n+  format %{ \"reduce_maxI_neon $dst, $isrc, $vsrc\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ neon_reduce_minmax_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                                   $isrc$$Register, $vsrc$$FloatRegister,\n+                                   length_in_bytes, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_maxI_sve(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc,\n+                         vRegD tmp, rFlagsReg cr) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(2))) &&\n+            (Matcher::vector_element_basic_type(n->in(2)) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n->in(2)) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n->in(2)) == T_INT));\n+  match(Set dst (MaxReductionV isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n+  format %{ \"reduce_maxI_sve $dst, $isrc, $vsrc\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           ptrue, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ reduction maxL\n+\n+instruct reduce_maxL_neon(iRegLNoSp dst, iRegL isrc, vReg vsrc, rFlagsReg cr) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n->in(2)) == T_LONG);\n+  match(Set dst (MaxReductionV isrc vsrc));\n+  effect(TEMP_DEF dst, KILL cr);\n+  format %{ \"reduce_maxL_neon $dst, $isrc, $vsrc\\t# 2L. KILL cr\" %}\n+  ins_encode %{\n+    __ neon_reduce_minmax_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n+                                   $isrc$$Register, $vsrc$$FloatRegister,\n+                                   \/* vector_length_in_bytes *\/ 16, fnoreg);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_maxL_sve(iRegLNoSp dst, iRegL isrc, vReg vsrc,\n+                         vRegD tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(2)) == T_LONG);\n+  match(Set dst (MaxReductionV isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n+  format %{ \"reduce_maxL_sve $dst, $isrc, $vsrc\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           ptrue, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ reduction maxF\n+\n+instruct reduce_maxF(vRegF dst, vRegF fsrc, vReg vsrc) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT);\n+  match(Set dst (MaxReductionV fsrc vsrc));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_maxF $dst, $fsrc, $vsrc\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      if (length_in_bytes == 8) {\n+        __ fmaxp($dst$$FloatRegister, $vsrc$$FloatRegister, __ S);\n+      } else {\n+        __ fmaxv($dst$$FloatRegister, __ T4S, $vsrc$$FloatRegister);\n+      }\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+      __ sve_fmaxv($dst$$FloatRegister, __ S, ptrue, $vsrc$$FloatRegister);\n+    }\n+    __ fmaxs($dst$$FloatRegister, $dst$$FloatRegister, $fsrc$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ reduction maxD\n+\n+instruct reduce_maxD(vRegD dst, vRegD dsrc, vReg vsrc) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE);\n+  match(Set dst (MaxReductionV dsrc vsrc));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_maxD $dst, $dsrc, $vsrc\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fmaxp($dst$$FloatRegister, $vsrc$$FloatRegister, __ D);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+      __ sve_fmaxv($dst$$FloatRegister, __ D, ptrue, $vsrc$$FloatRegister);\n+    }\n+    __ fmaxd($dst$$FloatRegister, $dst$$FloatRegister, $dsrc$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ reduction max - predicated\n+\n+instruct reduce_maxI_masked(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, pRegGov pg,\n+                            vRegD tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            (Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_INT));\n+  match(Set dst (MaxReductionV (Binary isrc vsrc) pg));\n+  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n+  format %{ \"reduce_maxI_masked $dst, $isrc, $pg, $vsrc\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           $pg$$PRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_maxL_masked(iRegLNoSp dst, iRegL isrc, vReg vsrc, pRegGov pg,\n+                            vRegD tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_LONG);\n+  match(Set dst (MaxReductionV (Binary isrc vsrc) pg));\n+  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n+  format %{ \"reduce_maxL_masked $dst, $isrc, $pg, $vsrc\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           $pg$$PRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_maxF_masked(vRegF dst, vRegF fsrc, vReg vsrc, pRegGov pg) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_FLOAT);\n+  match(Set dst (MaxReductionV (Binary fsrc vsrc) pg));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_maxF_masked $dst, $fsrc, $pg, $vsrc\" %}\n+  ins_encode %{\n+    __ sve_fmaxv($dst$$FloatRegister, __ S, $pg$$PRegister, $vsrc$$FloatRegister);\n+    __ fmaxs($dst$$FloatRegister, $dst$$FloatRegister, $fsrc$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_maxD_masked(vRegD dst, vRegD dsrc, vReg vsrc, pRegGov pg) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_DOUBLE);\n+  match(Set dst (MaxReductionV (Binary dsrc vsrc) pg));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_maxD_masked $dst, $dsrc, $pg, $vsrc\" %}\n+  ins_encode %{\n+    __ sve_fmaxv($dst$$FloatRegister, __ D, $pg$$PRegister, $vsrc$$FloatRegister);\n+    __ fmaxd($dst$$FloatRegister, $dst$$FloatRegister, $dsrc$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector reduction min -------------------------\n+\n+\/\/ reduction minI\n+\n+instruct reduce_minI_neon(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc,\n+                          vReg tmp, rFlagsReg cr) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(2))) &&\n+            (Matcher::vector_element_basic_type(n->in(2)) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n->in(2)) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n->in(2)) == T_INT));\n+  match(Set dst (MinReductionV isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n+  format %{ \"reduce_minI_neon $dst, $isrc, $vsrc\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ neon_reduce_minmax_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                                   $isrc$$Register, $vsrc$$FloatRegister,\n+                                   length_in_bytes, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_minI_sve(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc,\n+                         vRegD tmp, rFlagsReg cr) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(2))) &&\n+            (Matcher::vector_element_basic_type(n->in(2)) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n->in(2)) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n->in(2)) == T_INT));\n+  match(Set dst (MinReductionV isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n+  format %{ \"reduce_minI_sve $dst, $isrc, $vsrc\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           ptrue, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ reduction minL\n+\n+instruct reduce_minL_neon(iRegLNoSp dst, iRegL isrc, vReg vsrc, rFlagsReg cr) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n->in(2)) == T_LONG);\n+  match(Set dst (MinReductionV isrc vsrc));\n+  effect(TEMP_DEF dst, KILL cr);\n+  format %{ \"reduce_minL_neon $dst, $isrc, $vsrc\\t# 2L. KILL cr\" %}\n+  ins_encode %{\n+    __ neon_reduce_minmax_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n+                                   $isrc$$Register, $vsrc$$FloatRegister,\n+                                   \/* vector_length_in_bytes *\/ 16, fnoreg);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_minL_sve(iRegLNoSp dst, iRegL isrc, vReg vsrc,\n+                         vRegD tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(2)) == T_LONG);\n+  match(Set dst (MinReductionV isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n+  format %{ \"reduce_minL_sve $dst, $isrc, $vsrc\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           ptrue, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ reduction minF\n+\n+instruct reduce_minF(vRegF dst, vRegF fsrc, vReg vsrc) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT);\n+  match(Set dst (MinReductionV fsrc vsrc));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_minF $dst, $fsrc, $vsrc\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      if (length_in_bytes == 8) {\n+        __ fminp($dst$$FloatRegister, $vsrc$$FloatRegister, __ S);\n+      } else {\n+        __ fminv($dst$$FloatRegister, __ T4S, $vsrc$$FloatRegister);\n+      }\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+      __ sve_fminv($dst$$FloatRegister, __ S, ptrue, $vsrc$$FloatRegister);\n+    }\n+    __ fmins($dst$$FloatRegister, $dst$$FloatRegister, $fsrc$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ reduction minD\n+\n+instruct reduce_minD(vRegD dst, vRegD dsrc, vReg vsrc) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE);\n+  match(Set dst (MinReductionV dsrc vsrc));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_minD $dst, $dsrc, $vsrc\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fminp($dst$$FloatRegister, $vsrc$$FloatRegister, __ D);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+      __ sve_fminv($dst$$FloatRegister, __ D, ptrue, $vsrc$$FloatRegister);\n+    }\n+    __ fmind($dst$$FloatRegister, $dst$$FloatRegister, $dsrc$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ reduction min - predicated\n+\n+instruct reduce_minI_masked(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, pRegGov pg,\n+                            vRegD tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            (Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_INT));\n+  match(Set dst (MinReductionV (Binary isrc vsrc) pg));\n+  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n+  format %{ \"reduce_minI_masked $dst, $isrc, $pg, $vsrc\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           $pg$$PRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_minL_masked(iRegLNoSp dst, iRegL isrc, vReg vsrc, pRegGov pg,\n+                            vRegD tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_LONG);\n+  match(Set dst (MinReductionV (Binary isrc vsrc) pg));\n+  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n+  format %{ \"reduce_minL_masked $dst, $isrc, $pg, $vsrc\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           $pg$$PRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_minF_masked(vRegF dst, vRegF fsrc, vReg vsrc, pRegGov pg) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_FLOAT);\n+  match(Set dst (MinReductionV (Binary fsrc vsrc) pg));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_minF_masked $dst, $fsrc, $pg, $vsrc\" %}\n+  ins_encode %{\n+    __ sve_fminv($dst$$FloatRegister, __ S, $pg$$PRegister, $vsrc$$FloatRegister);\n+    __ fmins($dst$$FloatRegister, $dst$$FloatRegister, $fsrc$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_minD_masked(vRegD dst, vRegD dsrc, vReg vsrc, pRegGov pg) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_DOUBLE);\n+  match(Set dst (MinReductionV (Binary dsrc vsrc) pg));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_minD_masked $dst, $dsrc, $pg, $vsrc\" %}\n+  ins_encode %{\n+    __ sve_fminv($dst$$FloatRegister, __ D, $pg$$PRegister, $vsrc$$FloatRegister);\n+    __ fmind($dst$$FloatRegister, $dst$$FloatRegister, $dsrc$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector reinterpret ---------------------------\n+\n+instruct reinterpret_same_size(vReg dst_src) %{\n+  predicate(Matcher::vector_length_in_bytes(n) == Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst_src (VectorReinterpret dst_src));\n+  ins_cost(0);\n+  format %{ \"reinterpret_same_size $dst_src\\t# do nothing\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n+instruct reinterpret_resize_le128b(vReg dst, vReg src) %{\n+  predicate(Matcher::vector_length_in_bytes(n) != Matcher::vector_length_in_bytes(n->in(1)) &&\n+            Matcher::vector_length_in_bytes(n) <= 16 &&\n+            Matcher::vector_length_in_bytes(n->in(1)) <= 16);\n+  match(Set dst (VectorReinterpret src));\n+  format %{ \"reinterpret_resize_le128b $dst, $src\\t# vector <= 128 bits.\" %}\n+  ins_encode %{\n+    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, $src);\n+    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);\n+    \/\/ The higher bits in \"dst\" register must be cleared to zero.\n+    if ((length_in_bytes_src == 4 && length_in_bytes_dst == 8) ||\n+        (length_in_bytes_src == 8 && length_in_bytes_dst == 4)) {\n+      \/\/ Reinterpret between 32 bits and 64 bits\n+      __ dup($dst$$FloatRegister, __ S, $src$$FloatRegister);\n+    } else if ((length_in_bytes_src == 4 && length_in_bytes_dst == 16) ||\n+               (length_in_bytes_src == 16 && length_in_bytes_dst == 4)) {\n+      \/\/ Reinterpret between 32 bits and 128 bits\n+      __ dup($dst$$FloatRegister, __ S, $src$$FloatRegister);\n+    } else if ((length_in_bytes_src == 8 && length_in_bytes_dst == 16) ||\n+               (length_in_bytes_src == 16 && length_in_bytes_dst == 8)) {\n+      \/\/ Reinterpret between 64 bits and 128 bits\n+      __ orr($dst$$FloatRegister, __ T8B, $src$$FloatRegister, $src$$FloatRegister);\n+    } else {\n+      assert(false, \"invalid vector length\");\n+      ShouldNotReachHere();\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reinterpret_resize_gt128b(vReg dst, vReg src, pReg ptmp, rFlagsReg cr) %{\n+  predicate(Matcher::vector_length_in_bytes(n) != Matcher::vector_length_in_bytes(n->in(1)) &&\n+            (Matcher::vector_length_in_bytes(n) > 16 ||\n+             Matcher::vector_length_in_bytes(n->in(1)) > 16));\n+  match(Set dst (VectorReinterpret src));\n+  effect(TEMP_DEF dst, TEMP ptmp, KILL cr);\n+  format %{ \"reinterpret_resize_gt128b $dst, $src\\t# vector > 128 bits. KILL $ptmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, $src);\n+    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);\n+    uint length_in_bytes_resize = length_in_bytes_src < length_in_bytes_dst ?\n+                                  length_in_bytes_src : length_in_bytes_dst;\n+    assert(length_in_bytes_src <= MaxVectorSize && length_in_bytes_dst <= MaxVectorSize,\n+           \"invalid vector length\");\n+    __ sve_gen_mask_imm($ptmp$$PRegister, T_BYTE, length_in_bytes_resize);\n+    __ sve_dup($dst$$FloatRegister, __ B, 0);\n+    __ sve_sel($dst$$FloatRegister, __ B, $ptmp$$PRegister,\n+               $src$$FloatRegister, $dst$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector cast ----------------------------------\n+\n+\/\/ VectorCastB2X\n+\n+instruct vcvtBtoX(vReg dst, vReg src) %{\n+  match(Set dst (VectorCastB2X src));\n+  format %{ \"vcvtBtoX $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      \/\/ 4B to 4S\/4I\/4F, 8B to 8S\n+      __ neon_vector_extend($dst$$FloatRegister, bt == T_FLOAT ? T_INT : bt,\n+                            length_in_bytes, $src$$FloatRegister, T_BYTE);\n+      if (bt == T_FLOAT) {\n+        __ scvtfv(__ T4S, $dst$$FloatRegister, $dst$$FloatRegister);\n+      }\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+      __ sve_vector_extend($dst$$FloatRegister, size, $src$$FloatRegister, __ B);\n+      if (is_floating_point_type(bt)) {\n+        __ sve_scvtf($dst$$FloatRegister, size, ptrue, $dst$$FloatRegister, size);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorCastS2X\n+\n+instruct vcvtStoB_neon(vReg dst, vReg src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE &&\n+            VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1))));\n+  match(Set dst (VectorCastS2X src));\n+  format %{ \"vcvtStoB_neon $dst, $src\" %}\n+  ins_encode %{\n+    \/\/ 4S\/8S to 4B\/8B\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    __ neon_vector_narrow($dst$$FloatRegister, T_BYTE,\n+                          $src$$FloatRegister, T_SHORT, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtStoB_sve(vReg dst, vReg src, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE &&\n+            !VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1))));\n+  match(Set dst (VectorCastS2X src));\n+  effect(TEMP tmp);\n+  format %{ \"vcvtStoB_sve $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_vector_narrow($dst$$FloatRegister, __ B,\n+                         $src$$FloatRegister, __ H, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtStoX_extend(vReg dst, vReg src) %{\n+  predicate(type2aelembytes(Matcher::vector_element_basic_type(n)) >= 4);\n+  match(Set dst (VectorCastS2X src));\n+  format %{ \"vcvtStoX_extend $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      \/\/ 4S to 4I\/4F\n+      __ neon_vector_extend($dst$$FloatRegister, T_INT, length_in_bytes,\n+                            $src$$FloatRegister, T_SHORT);\n+      if (bt == T_FLOAT) {\n+        __ scvtfv(__ T4S, $dst$$FloatRegister, $dst$$FloatRegister);\n+      }\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+      __ sve_vector_extend($dst$$FloatRegister, size, $src$$FloatRegister, __ H);\n+      if (is_floating_point_type(bt)) {\n+        __ sve_scvtf($dst$$FloatRegister, size, ptrue, $dst$$FloatRegister, size);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorCastI2X\n+\n+instruct vcvtItoX_narrow_neon(vReg dst, vReg src) %{\n+  predicate((Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT) &&\n+            VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1))));\n+  match(Set dst (VectorCastI2X src));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vcvtItoX_narrow_neon $dst, $src\" %}\n+  ins_encode %{\n+    \/\/ 4I to 4B\/4S\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    __ neon_vector_narrow($dst$$FloatRegister, bt,\n+                          $src$$FloatRegister, T_INT, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtItoX_narrow_sve(vReg dst, vReg src, vReg tmp) %{\n+  predicate((Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT) &&\n+            !VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1))));\n+  match(Set dst (VectorCastI2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vcvtItoX_narrow_sve $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_vector_narrow($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                         $src$$FloatRegister, __ S, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtItoX(vReg dst, vReg src) %{\n+  predicate(type2aelembytes(Matcher::vector_element_basic_type(n)) >= 4);\n+  match(Set dst (VectorCastI2X src));\n+  format %{ \"vcvtItoX $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes =  Matcher::vector_length_in_bytes(this);\n+    if (bt == T_FLOAT) {\n+      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+        \/\/ 2I\/4I to 2F\/4F\n+        __ scvtfv(get_arrangement(this), $dst$$FloatRegister, $src$$FloatRegister);\n+      } else {\n+        assert(UseSVE > 0, \"must be sve\");\n+        __ sve_scvtf($dst$$FloatRegister, __ S, ptrue, $src$$FloatRegister, __ S);\n+      }\n+    } else {\n+      assert(type2aelembytes(bt) == 8, \"unsupported type\");\n+      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+        \/\/ 2I to 2L\/2D\n+        __ neon_vector_extend($dst$$FloatRegister, T_LONG, length_in_bytes,\n+                              $src$$FloatRegister, T_INT);\n+        if (bt == T_DOUBLE) {\n+          __ scvtfv(__ T2D, $dst$$FloatRegister, $dst$$FloatRegister);\n+        }\n+      } else {\n+        assert(UseSVE > 0, \"must be sve\");\n+        __ sve_vector_extend($dst$$FloatRegister, __ D, $src$$FloatRegister, __ S);\n+        if (bt == T_DOUBLE) {\n+          __ sve_scvtf($dst$$FloatRegister, __ D, ptrue, $dst$$FloatRegister, __ D);\n+        }\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorCastL2X\n+\n+instruct vcvtLtoI_neon(vReg dst, vReg src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_INT &&\n+            VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1))));\n+  match(Set dst (VectorCastL2X src));\n+  format %{ \"vcvtLtoI_neon $dst, $src\" %}\n+  ins_encode %{\n+    \/\/ 2L to 2I\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    __ neon_vector_narrow($dst$$FloatRegister, T_INT,\n+                          $src$$FloatRegister, T_LONG, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtLtoI_sve(vReg dst, vReg src, vReg tmp) %{\n+  predicate((Matcher::vector_element_basic_type(n) == T_INT &&\n+             !VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1)))) ||\n+            Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst (VectorCastL2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vcvtLtoI_sve $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_vector_narrow($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                         $src$$FloatRegister, __ D, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtLtoF_neon(vReg dst, vReg src, vRegF tmp) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst (VectorCastL2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vcvtLtoF_neon $dst, $src\\t# 2L to 2F. KILL $tmp\" %}\n+  ins_encode %{\n+    \/\/ 2L to 2F\n+    __ umov(rscratch1, $src$$FloatRegister, __ D, 0);\n+    __ scvtfs($dst$$FloatRegister, rscratch1);\n+    __ umov(rscratch1, $src$$FloatRegister, __ D, 1);\n+    __ scvtfs($tmp$$FloatRegister, rscratch1);\n+    __ ins($dst$$FloatRegister, __ S, $tmp$$FloatRegister, 1, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtLtoF_sve(vReg dst, vReg src, vReg tmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst (VectorCastL2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vcvtLtoF_sve $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ sve_scvtf($dst$$FloatRegister, __ S, ptrue, $src$$FloatRegister, __ D);\n+    __ sve_vector_narrow($dst$$FloatRegister, __ S,\n+                         $dst$$FloatRegister, __ D, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtLtoD(vReg dst, vReg src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+  match(Set dst (VectorCastL2X src));\n+  format %{ \"vcvtLtoD $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      \/\/ 2L to 2D\n+      __ scvtfv(__ T2D, $dst$$FloatRegister, $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_scvtf($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister, __ D);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorCastF2X\n+\n+instruct vcvtFtoX_narrow_neon(vReg dst, vReg src) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1))) &&\n+            (Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT));\n+  match(Set dst (VectorCastF2X src));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vcvtFtoX_narrow_neon $dst, $src\" %}\n+  ins_encode %{\n+    \/\/ 4F to 4B\/4S\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    __ fcvtzs($dst$$FloatRegister, __ T4S, $src$$FloatRegister);\n+    __ neon_vector_narrow($dst$$FloatRegister, bt,\n+                          $dst$$FloatRegister, T_INT, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtFtoX_narrow_sve(vReg dst, vReg src, vReg tmp) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1))) &&\n+            (Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT));\n+  match(Set dst (VectorCastF2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vcvtFtoX_narrow_sve $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fcvtzs($dst$$FloatRegister, __ S, ptrue, $src$$FloatRegister, __ S);\n+    __ sve_vector_narrow($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                         $dst$$FloatRegister, __ S, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtFtoX(vReg dst, vReg src) %{\n+  predicate(type2aelembytes(Matcher::vector_element_basic_type(n)) >= 4);\n+  match(Set dst (VectorCastF2X src));\n+  format %{ \"vcvtFtoX $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes =  Matcher::vector_length_in_bytes(this);\n+    if (bt == T_INT) {\n+      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+        \/\/ 2F\/4F to 2I\/4I\n+        __ fcvtzs($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+      } else {\n+        assert(UseSVE > 0, \"must be sve\");\n+        __ sve_fcvtzs($dst$$FloatRegister, __ S, ptrue, $src$$FloatRegister, __ S);\n+      }\n+    } else if (bt == T_LONG) {\n+      if (UseSVE == 0) {\n+        \/\/ 2F to 2L\n+        __ fcvtl($dst$$FloatRegister, __ T2D, $src$$FloatRegister, __ T2S);\n+        __ fcvtzs($dst$$FloatRegister, __ T2D, $dst$$FloatRegister);\n+      } else {\n+        __ sve_vector_extend($dst$$FloatRegister, __ D, $src$$FloatRegister, __ S);\n+        __ sve_fcvtzs($dst$$FloatRegister, __ D, ptrue, $dst$$FloatRegister, __ S);\n+      }\n+    } else {\n+      assert(bt == T_DOUBLE, \"unsupported type\");\n+      if (length_in_bytes == 16) {\n+        \/\/ 2F to 2D\n+        __ fcvtl($dst$$FloatRegister, __ T2D, $src$$FloatRegister, __ T2S);\n+      } else {\n+        assert(UseSVE > 0 && length_in_bytes > 16, \"must be\");\n+        __ sve_vector_extend($dst$$FloatRegister, __ D, $src$$FloatRegister, __ S);\n+        __ sve_fcvt($dst$$FloatRegister, __ D, ptrue, $dst$$FloatRegister, __ S);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorCastD2X\n+\n+instruct vcvtDtoI_neon(vReg dst, vReg src) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n) == T_INT);\n+  match(Set dst (VectorCastD2X src));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vcvtDtoI_neon $dst, $src\\t# 2D to 2I\" %}\n+  ins_encode %{\n+    \/\/ 2D to 2I\n+    __ ins($dst$$FloatRegister, __ D, $src$$FloatRegister, 0, 1);\n+    \/\/ We can't use fcvtzs(vector, integer) instruction here because we need\n+    \/\/ saturation arithmetic. See JDK-8276151.\n+    __ fcvtzdw(rscratch1, $src$$FloatRegister);\n+    __ fcvtzdw(rscratch2, $dst$$FloatRegister);\n+    __ fmovs($dst$$FloatRegister, rscratch1);\n+    __ mov($dst$$FloatRegister, __ S, 1, rscratch2);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtDtoI_sve(vReg dst, vReg src, vReg tmp) %{\n+  predicate(UseSVE > 0 &&\n+            (Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n) == T_INT));\n+  match(Set dst (VectorCastD2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vcvtDtoI_sve $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fcvtzs($dst$$FloatRegister, __ S, ptrue, $src$$FloatRegister, __ D);\n+    __ sve_vector_narrow($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                         $dst$$FloatRegister, __ D, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtDtoL(vReg dst, vReg src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst (VectorCastD2X src));\n+  format %{ \"vcvtDtoL $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes =  Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      \/\/ 2D to 2L\n+      __ fcvtzs($dst$$FloatRegister, __ T2D, $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fcvtzs($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister, __ D);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtDtoF_64b(vReg dst, vReg src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_FLOAT &&\n+            Matcher::vector_length_in_bytes(n) == 8);\n+  match(Set dst (VectorCastD2X src));\n+  format %{ \"vcvtDtoF_64b $dst, $src\\t# 2D to 2F\" %}\n+  ins_encode %{\n+    \/\/ 2D to 2F\n+    __ fcvtn($dst$$FloatRegister, __ T2S, $src$$FloatRegister, __ T2D);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtDtoF_gt64b(vReg dst, vReg src, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_FLOAT &&\n+            Matcher::vector_length_in_bytes(n) > 8);\n+  match(Set dst (VectorCastD2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vcvtDtoF_gt64b $dst, $src\\t# vector > 64 bits. KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_fcvt($dst$$FloatRegister, __ S, ptrue, $src$$FloatRegister, __ D);\n+    __ sve_vector_narrow($dst$$FloatRegister, __ S,\n+                         $dst$$FloatRegister, __ D, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Replicate ------------------------------------\n+\n+\/\/ replicate from reg\n+\n+instruct replicateB(vReg dst, iRegIorL2I src) %{\n+  match(Set dst (ReplicateB src));\n+  format %{ \"replicateB $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ dup($dst$$FloatRegister, get_arrangement(this), $src$$Register);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_dup($dst$$FloatRegister, __ B, $src$$Register);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateS(vReg dst, iRegIorL2I src) %{\n+  match(Set dst (ReplicateS src));\n+  format %{ \"replicateS $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ dup($dst$$FloatRegister, get_arrangement(this), $src$$Register);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_dup($dst$$FloatRegister, __ H, $src$$Register);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateI(vReg dst, iRegIorL2I src) %{\n+  match(Set dst (ReplicateI src));\n+  format %{ \"replicateI $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ dup($dst$$FloatRegister, get_arrangement(this), $src$$Register);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_dup($dst$$FloatRegister, __ S, $src$$Register);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateL(vReg dst, iRegL src) %{\n+  match(Set dst (ReplicateL src));\n+  format %{ \"replicateL $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ dup($dst$$FloatRegister, get_arrangement(this), $src$$Register);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_dup($dst$$FloatRegister, __ D, $src$$Register);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateF(vReg dst, vRegF src) %{\n+  match(Set dst (ReplicateF src));\n+  format %{ \"replicateF $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ dup($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_cpy($dst$$FloatRegister, __ S, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateD(vReg dst, vRegD src) %{\n+  match(Set dst (ReplicateD src));\n+  format %{ \"replicateD $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ dup($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_cpy($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ replicate from imm\n+\n+instruct replicateI_imm_le128b(vReg dst, immI con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16);\n+  match(Set dst (ReplicateB con));\n+  match(Set dst (ReplicateS con));\n+  match(Set dst (ReplicateI con));\n+  format %{ \"replicateI_imm_le128b $dst, $con\\t# vector <= 128 bits\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int imm = (int)$con$$constant;\n+    if (type2aelembytes(bt) == 1) {\n+      \/\/ Refine imm for B\n+      imm = imm & 0xff;\n+    } else if (type2aelembytes(bt) == 2) {\n+      \/\/ Refine imm for S\n+      imm = imm & 0xffff;\n+    }\n+    __ mov($dst$$FloatRegister, get_arrangement(this), imm);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateB_imm8_gt128b(vReg dst, immI8 con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16);\n+  match(Set dst (ReplicateB con));\n+  format %{ \"replicateB_imm8_gt128b $dst, $con\\t# vector > 128 bits\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_dup($dst$$FloatRegister, __ B, (int)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateS_imm8_gt128b(vReg dst, immI8_shift8 con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16);\n+  match(Set dst (ReplicateS con));\n+  format %{ \"replicateS_imm8_gt128b $dst, $con\\t# vector > 128 bits\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_dup($dst$$FloatRegister, __ H, (int)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateI_imm8_gt128b(vReg dst, immI8_shift8 con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16);\n+  match(Set dst (ReplicateI con));\n+  format %{ \"replicateI_imm8_gt128b $dst, $con\\t# vector > 128 bits\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_dup($dst$$FloatRegister, __ S, (int)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateL_imm_128b(vReg dst, immL con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) == 16);\n+  match(Set dst (ReplicateL con));\n+  format %{ \"replicateL_imm_128b $dst, $con\\t# vector > 128 bits\" %}\n+  ins_encode %{\n+    __ mov($dst$$FloatRegister, __ T2D, (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateL_imm8_gt128b(vReg dst, immL8_shift8 con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16);\n+  match(Set dst (ReplicateL con));\n+  format %{ \"replicateL_imm8_gt128b $dst, $con\\t# vector > 128 bits\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_dup($dst$$FloatRegister, __ D, (int)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector insert --------------------------------\n+\n+\/\/ BYTE, SHORT, INT\n+\n+instruct insertI_le128b(vReg dst, vReg src, iRegIorL2I val, immI idx) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16 &&\n+            (Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n) == T_INT));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  format %{ \"insertI_le128b $dst, $src, $val, $idx\\t# vector <= 128 bits\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if ($dst$$FloatRegister != $src$$FloatRegister) {\n+      __ orr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+             $src$$FloatRegister, $src$$FloatRegister);\n+    }\n+    __ mov($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+           (int)($idx$$constant), $val$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertI_index_lt32(vReg dst, vReg src, iRegIorL2I val, immI idx,\n+                            vReg tmp, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(n->in(2)->get_int() < 32 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n+            (Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n) == T_INT));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP tmp, TEMP pgtmp, KILL cr);\n+  format %{ \"insertI_index_lt32 $dst, $src, $val, $idx\\t# vector > 128 bits, index < 31. KILL $tmp, $pgtmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_index($tmp$$FloatRegister, size, -16, 1);\n+    __ sve_cmp(Assembler::EQ, $pgtmp$$PRegister, size, ptrue,\n+               $tmp$$FloatRegister, (int)($idx$$constant) - 16);\n+    if ($dst$$FloatRegister != $src$$FloatRegister) {\n+      __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+    }\n+    __ sve_cpy($dst$$FloatRegister, size, $pgtmp$$PRegister, $val$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertI_index_ge32(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg tmp1,\n+                            vReg tmp2, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(n->in(2)->get_int() >= 32 &&\n+            (Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n) == T_INT));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP pgtmp, KILL cr);\n+  format %{ \"insertI_index_ge32 $dst, $src, $val, $idx\\t# index >= 32. KILL $tmp1, $tmp2, $pgtmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_index($tmp1$$FloatRegister, size, 0, 1);\n+    __ sve_dup($tmp2$$FloatRegister, size, (int)($idx$$constant));\n+    __ sve_cmp(Assembler::EQ, $pgtmp$$PRegister, size, ptrue,\n+               $tmp1$$FloatRegister, $tmp2$$FloatRegister);\n+    if ($dst$$FloatRegister != $src$$FloatRegister) {\n+      __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+    }\n+    __ sve_cpy($dst$$FloatRegister, size, $pgtmp$$PRegister, $val$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ LONG\n+\n+instruct insertL_128b(vReg dst, vReg src, iRegL val, immI idx) %{\n+  predicate(Matcher::vector_length_in_bytes(n) == 16 &&\n+            Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  format %{ \"insertL_128b $dst, $src, $val, $idx\\t# 2L\" %}\n+  ins_encode %{\n+    if ($dst$$FloatRegister != $src$$FloatRegister) {\n+      __ orr($dst$$FloatRegister, __ T16B, $src$$FloatRegister, $src$$FloatRegister);\n+    }\n+    __ mov($dst$$FloatRegister, __ D, (int)($idx$$constant), $val$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertL_gt128b(vReg dst, vReg src, iRegL val, immI idx,\n+                        vReg tmp, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16 &&\n+            Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP tmp, TEMP pgtmp, KILL cr);\n+  format %{ \"insertL_gt128b $dst, $src, $val, $idx\\t# vector > 128 bits. KILL $tmp, $pgtmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_index($tmp$$FloatRegister, __ D, -16, 1);\n+    __ sve_cmp(Assembler::EQ, $pgtmp$$PRegister, __ D, ptrue,\n+               $tmp$$FloatRegister, (int)($idx$$constant) - 16);\n+    if ($dst$$FloatRegister != $src$$FloatRegister) {\n+      __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+    }\n+    __ sve_cpy($dst$$FloatRegister, __ D, $pgtmp$$PRegister, $val$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ FLOAT\n+\n+instruct insertF_le128b(vReg dst, vReg src, vRegF val, immI idx) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16 &&\n+            Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst);\n+  format %{ \"insertF_le128b $dst, $src, $val, $idx\\t# vector <= 128 bits\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if ($dst$$FloatRegister != $src$$FloatRegister) {\n+      __ orr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+             $src$$FloatRegister, $src$$FloatRegister);\n+    }\n+    __ ins($dst$$FloatRegister, __ S, $val$$FloatRegister, (int)($idx$$constant), 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertF_index_lt32(vReg dst, vReg src, vRegF val, immI idx,\n+                            pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(n->in(2)->get_int() < 32 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n+            Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n+  format %{ \"insertF_index_lt32 $dst, $src, $val, $idx\\t# vector > 128 bits, index < 32. KILL $pgtmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_index($dst$$FloatRegister, __ S, -16, 1);\n+    __ sve_cmp(Assembler::EQ, $pgtmp$$PRegister, __ S, ptrue,\n+               $dst$$FloatRegister, (int)($idx$$constant) - 16);\n+    __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+    __ sve_cpy($dst$$FloatRegister, __ S, $pgtmp$$PRegister, $val$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertF_index_ge32(vReg dst, vReg src, vRegF val, immI idx, vReg tmp,\n+                            pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(n->in(2)->get_int() >= 32 &&\n+            Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP pgtmp, KILL cr);\n+  format %{ \"insertF_index_ge32 $dst, $src, $val, $idx\\t# index >= 32. KILL $tmp, $pgtmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_index($tmp$$FloatRegister, __ S, 0, 1);\n+    __ sve_dup($dst$$FloatRegister, __ S, (int)($idx$$constant));\n+    __ sve_cmp(Assembler::EQ, $pgtmp$$PRegister, __ S, ptrue,\n+               $tmp$$FloatRegister, $dst$$FloatRegister);\n+    __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+    __ sve_cpy($dst$$FloatRegister, __ S, $pgtmp$$PRegister, $val$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ DOUBLE\n+\n+instruct insertD_128b(vReg dst, vReg src, vRegD val, immI idx) %{\n+  predicate(Matcher::vector_length_in_bytes(n) == 16 &&\n+            Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst);\n+  format %{ \"insertD_128b $dst, $src, $val, $idx\\t# 2D\" %}\n+  ins_encode %{\n+    if ($dst$$FloatRegister != $src$$FloatRegister) {\n+      __ orr($dst$$FloatRegister, __ T16B, $src$$FloatRegister, $src$$FloatRegister);\n+    }\n+    __ ins($dst$$FloatRegister, __ D, $val$$FloatRegister, (int)($idx$$constant), 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertD_gt128b(vReg dst, vReg src, vRegD val, immI idx,\n+                        pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16 &&\n+            Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n+  format %{ \"insertD_gt128b $dst, $src, $val, $idx\\t# vector > 128 bits. KILL $pgtmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_index($dst$$FloatRegister, __ D, -16, 1);\n+    __ sve_cmp(Assembler::EQ, $pgtmp$$PRegister, __ D, ptrue,\n+               $dst$$FloatRegister, (int)($idx$$constant) - 16);\n+    __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+    __ sve_cpy($dst$$FloatRegister, __ D, $pgtmp$$PRegister, $val$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Extract --------------------------------------\n+\/\/ BYTE\n+\n+instruct extractB_index_lt16(iRegINoSp dst, vReg src, immI idx) %{\n+  predicate(n->in(2)->get_int() < 16);\n+  match(Set dst (ExtractB src idx));\n+  format %{ \"extractB_index_lt16 $dst, $src, $idx\\t# index < 16\" %}\n+  ins_encode %{\n+    __ smov($dst$$Register, $src$$FloatRegister, __ B, (int)($idx$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct extractB_index_ge16(iRegINoSp dst, vReg src, immI idx, vReg tmp) %{\n+  predicate(n->in(2)->get_int() >= 16);\n+  match(Set dst (ExtractB src idx));\n+  effect(TEMP tmp);\n+  format %{ \"extractB_index_ge16 $dst, $src, $idx\\t# index >=16. KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_extract_integral($dst$$Register, T_BYTE, $src$$FloatRegister,\n+                            (int)($idx$$constant), $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ SHORT\n+\n+instruct extractS_index_lt8(iRegINoSp dst, vReg src, immI idx) %{\n+  predicate(n->in(2)->get_int() < 8);\n+  match(Set dst (ExtractS src idx));\n+  format %{ \"extractS_index_lt8 $dst, $src, $idx\\t# index < 8\" %}\n+  ins_encode %{\n+    __ smov($dst$$Register, $src$$FloatRegister, __ H, (int)($idx$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct extractS_index_ge8(iRegINoSp dst, vReg src, immI idx, vReg tmp) %{\n+  predicate(n->in(2)->get_int() >= 8);\n+  match(Set dst (ExtractS src idx));\n+  effect(TEMP tmp);\n+  format %{ \"extractS_index_ge8 $dst, $src, $idx\\t# index >=8. KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_extract_integral($dst$$Register, T_SHORT, $src$$FloatRegister,\n+                            (int)($idx$$constant), $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ INT\n+\n+instruct extractI_index_lt4(iRegINoSp dst, vReg src, immI idx) %{\n+  predicate(n->in(2)->get_int() < 4);\n+  match(Set dst (ExtractI src idx));\n+  format %{ \"extractI_index_lt4 $dst, $src, $idx\\t# index < 4\" %}\n+  ins_encode %{\n+    __ umov($dst$$Register, $src$$FloatRegister, __ S, (int)($idx$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct extractI_index_ge4(iRegINoSp dst, vReg src, immI idx, vReg tmp) %{\n+  predicate(n->in(2)->get_int() >= 4);\n+  match(Set dst (ExtractI src idx));\n+  effect(TEMP tmp);\n+  format %{ \"extractI_index_ge4 $dst, $src, $idx\\t# index >=4. KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_extract_integral($dst$$Register, T_INT, $src$$FloatRegister,\n+                            (int)($idx$$constant), $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ LONG\n+\n+instruct extractL_index_lt2(iRegLNoSp dst, vReg src, immI idx) %{\n+  predicate(n->in(2)->get_int() < 2);\n+  match(Set dst (ExtractL src idx));\n+  format %{ \"extractL_index_lt2 $dst, $src, $idx\\t# index < 2\" %}\n+  ins_encode %{\n+    __ umov($dst$$Register, $src$$FloatRegister, __ D, (int)($idx$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct extractL_index_ge2(iRegLNoSp dst, vReg src, immI idx, vReg tmp) %{\n+  predicate(n->in(2)->get_int() >= 2);\n+  match(Set dst (ExtractL src idx));\n+  effect(TEMP tmp);\n+  format %{ \"extractL_index_ge2 $dst, $src, $idx\\t# index >=2. KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_extract_integral($dst$$Register, T_LONG, $src$$FloatRegister,\n+                            (int)($idx$$constant), $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ FLOAT\n+\n+instruct extractF(vRegF dst, vReg src, immI idx) %{\n+  match(Set dst (ExtractF src idx));\n+  effect(TEMP_DEF dst);\n+  format %{ \"extractF $dst, $src, $idx\" %}\n+  ins_encode %{\n+    int index = (int)$idx$$constant;\n+    if (index == 0) {\n+      __ fmovs($dst$$FloatRegister, $src$$FloatRegister);\n+    } else if (index < 4) {\n+      __ ins($dst$$FloatRegister, __ S, $src$$FloatRegister, 0, index);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+      __ sve_ext($dst$$FloatRegister, $dst$$FloatRegister, index << 2);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ DOUBLE\n+\n+instruct extractD(vRegD dst, vReg src, immI idx) %{\n+  match(Set dst (ExtractD src idx));\n+  effect(TEMP_DEF dst);\n+  format %{ \"extractD $dst, $src, $idx\" %}\n+  ins_encode %{\n+    int index = (int)$idx$$constant;\n+    if (index == 0) {\n+      __ fmovd($dst$$FloatRegister, $src$$FloatRegister);\n+    } else if (index < 2) {\n+      __ ins($dst$$FloatRegister, __ D, $src$$FloatRegister, 0, index);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+      __ sve_ext($dst$$FloatRegister, $dst$$FloatRegister, index << 3);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector mask load\/store -----------------------\n+\n+\/\/ vector load mask\n+\n+instruct vloadmask_neon(vReg dst, vReg src) %{\n+  predicate(UseSVE == 0 &&\n+            (Matcher::vector_length_in_bytes(n) == 8 ||\n+             Matcher::vector_length_in_bytes(n) == 16));\n+  match(Set dst (VectorLoadMask src ));\n+  format %{ \"vloadmask_neon $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (bt == T_BYTE) {\n+      uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+      __ negr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+              $src$$FloatRegister);\n+    } else {\n+      __ uxtl($dst$$FloatRegister, __ T8H, $src$$FloatRegister, __ T8B);\n+      if (type2aelembytes(bt) >= 4) {\n+        __ uxtl($dst$$FloatRegister, __ T4S, $dst$$FloatRegister, __ T4H);\n+      }\n+      if (type2aelembytes(bt) == 8) {\n+        __ uxtl($dst$$FloatRegister, __ T2D, $dst$$FloatRegister, __ T2S);\n+      }\n+      __ negr($dst$$FloatRegister, get_arrangement(this), $dst$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vloadmaskB_sve(pRegGov dst, vReg src, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && !n->is_predicated_vector() &&\n+            Matcher::vector_element_basic_type(n) == T_BYTE);\n+  match(Set dst (VectorLoadMask src));\n+  effect(KILL cr);\n+  format %{ \"vloadmaskB_sve $dst, $src\\t# KILL cr\" %}\n+  ins_encode %{\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, __ B,\n+               ptrue, $src$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vloadmask_extend_sve(pRegGov dst, vReg src, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && !n->is_predicated_vector() &&\n+            Matcher::vector_element_basic_type(n) != T_BYTE);\n+  match(Set dst (VectorLoadMask src));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vloadmask_extend_sve $dst, $src\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_vector_extend($tmp$$FloatRegister, size, $src$$FloatRegister, __ B);\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, size, ptrue, $tmp$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vloadmaskB_masked(pRegGov dst, vReg src, pRegGov pg, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n) == T_BYTE);\n+  match(Set dst (VectorLoadMask src pg));\n+  effect(KILL cr);\n+  format %{ \"vloadmaskB_masked $dst, $pg, $src\\t# KILL cr\" %}\n+  ins_encode %{\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, __ B,\n+               $pg$$PRegister, $src$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vloadmask_extend_masked(pRegGov dst, vReg src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n) != T_BYTE);\n+  match(Set dst (VectorLoadMask src pg));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vloadmask_extend_masked $dst, $pg, $src\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_vector_extend($tmp$$FloatRegister, size, $src$$FloatRegister, __ B);\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, size,\n+               $pg$$PRegister, $tmp$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector store mask - neon\n+\n+instruct vstoremaskB_neon(vReg dst, vReg src, immI_1 size) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (VectorStoreMask src size));\n+  format %{ \"vstoremaskB_neon $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n+    __ negr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+            $src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vstoremask_narrow_neon(vReg dst, vReg src, immI_gt_1 size) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (VectorStoreMask src size));\n+  format %{ \"vstoremask_narrow_neon $dst, $src\" %}\n+  ins_encode %{\n+    int esize = (int)$size$$constant;\n+    if (esize == 2) {\n+      __ xtn($dst$$FloatRegister, __ T8B, $src$$FloatRegister, __ T8H);\n+    } else if (esize == 4) {\n+      __ xtn($dst$$FloatRegister, __ T4H, $src$$FloatRegister, __ T4S);\n+      __ xtn($dst$$FloatRegister, __ T8B, $dst$$FloatRegister, __ T8H);\n+    } else {\n+      assert(esize == 8, \"must be\");\n+      __ xtn($dst$$FloatRegister, __ T2S, $src$$FloatRegister, __ T2D);\n+      __ xtn($dst$$FloatRegister, __ T4H, $dst$$FloatRegister, __ T4S);\n+      __ xtn($dst$$FloatRegister, __ T8B, $dst$$FloatRegister, __ T8H);\n+    }\n+    __ negr($dst$$FloatRegister, __ T8B, $dst$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector store mask - sve\n+\n+instruct vstoremaskB_sve(vReg dst, pRegGov src, immI_1 size) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorStoreMask src size));\n+  format %{ \"vstoremaskB_sve $dst, $src\" %}\n+  ins_encode %{\n+    __ sve_cpy($dst$$FloatRegister, __ B, $src$$PRegister, 1, false);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vstoremask_narrow_sve(vReg dst, pRegGov src, immI_gt_1 size, vReg tmp) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorStoreMask src size));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vstoremask_narrow_sve $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    Assembler::SIMD_RegVariant size = __ elemBytes_to_regVariant((int)$size$$constant);\n+    __ sve_cpy($dst$$FloatRegister, size, $src$$PRegister, 1, false);\n+    __ sve_vector_narrow($dst$$FloatRegister, __ B,\n+                         $dst$$FloatRegister, size, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Combined rules for vector mask load when the vector element type is not T_BYTE\n+\n+\/\/ VectorLoadMask+LoadVector, and the VectorLoadMask is unpredicated.\n+instruct vloadmask_loadV(pRegGov dst, indirect mem, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && !n->is_predicated_vector() &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) > 1);\n+  match(Set dst (VectorLoadMask (LoadVector mem)));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vloadmask_loadV $dst, $mem\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    \/\/ Load mask values which are boolean type, and extend them to the\n+    \/\/ defined vector element type. Convert the vector to predicate.\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, $tmp$$FloatRegister,\n+                          ptrue, T_BOOLEAN, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, __ elemType_to_regVariant(bt),\n+               ptrue, $tmp$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorLoadMask+LoadVector, and the VectorLoadMask is predicated.\n+instruct vloadmask_loadV_masked(pRegGov dst, indirect mem, pRegGov pg,\n+                                vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) > 1);\n+  match(Set dst (VectorLoadMask (LoadVector mem) pg));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vloadmask_loadV_masked $dst, $pg, $mem\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    \/\/ Load valid mask values which are boolean type, and extend them to the\n+    \/\/ defined vector element type. Convert the vector to predicate.\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, $tmp$$FloatRegister,\n+                          $pg$$PRegister, T_BOOLEAN, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $tmp$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorLoadMask+LoadVectorMasked, and the VectorLoadMask is unpredicated.\n+instruct vloadmask_loadVMasked(pRegGov dst, vmemA mem, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && !n->is_predicated_vector() &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) > 1);\n+  match(Set dst (VectorLoadMask (LoadVectorMasked mem pg)));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vloadmask_loadVMasked $dst, $mem\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    \/\/ Load mask values which are boolean type, and extend them to the\n+    \/\/ defined vector element type. Convert the vector to predicate.\n+    \/\/\n+    \/\/ Note that we cannot use \"pg\" here, since it is the predicate used\n+    \/\/ for the vector load with boolean type. But the predicate used in\n+    \/\/ the extending \"sve_ld1b\" is based on the final extended vector type,\n+    \/\/ which is the full-sized predicate (ptrue) used in VectorLoadMask.\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, $tmp$$FloatRegister,\n+                          ptrue, T_BOOLEAN, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, __ elemType_to_regVariant(bt),\n+               ptrue, $tmp$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorLoadMask+LoadVectorMasked, and the VectorLoadMask is predicated.\n+instruct vloadmask_loadVMasked_masked(pRegGov dst, vmemA mem, pRegGov pg1, pRegGov pg2,\n+                                      vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) > 1);\n+  match(Set dst (VectorLoadMask (LoadVectorMasked mem pg1) pg2));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vloadmask_loadVMasked_masked $dst, $pg2, $mem\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    \/\/ Load valid mask values which are boolean type, and extend them to the\n+    \/\/ defined vector element type. Convert the vector to predicate.\n+    \/\/\n+    \/\/ Note that we cannot use \"pg1\" here, since it is the predicate used\n+    \/\/ for the vector load with boolean type. But the predicate used in\n+    \/\/ the extending \"sve_ld1b\" is based on the final extended vector type,\n+    \/\/ which is the \"pg2\" used in VectorLoadMask.\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, $tmp$$FloatRegister,\n+                          $pg2$$PRegister, T_BOOLEAN, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, __ elemType_to_regVariant(bt),\n+               $pg2$$PRegister, $tmp$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Combined rules for vector mask store when the vector element type is not T_BYTE\n+\n+\/\/ StoreVector+VectorStoreMask, and the vector size of \"src\" is equal to the MaxVectorSize.\n+instruct storeV_vstoremask(indirect mem, pRegGov src, immI_gt_1 esize, vReg tmp) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length_in_bytes(n->as_StoreVector()->in(MemNode::ValueIn)->in(1)) == MaxVectorSize);\n+  match(Set mem (StoreVector mem (VectorStoreMask src esize)));\n+  effect(TEMP tmp);\n+  format %{ \"storeV_vstoremask $mem, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    \/\/ Convert the valid src predicate to vector, and store the vector elements\n+    \/\/ as boolean values.\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    assert(type2aelembytes(bt) == (int)$esize$$constant, \"unsupported type\");\n+    Assembler::SIMD_RegVariant size = __ elemBytes_to_regVariant($esize$$constant);\n+    __ sve_cpy($tmp$$FloatRegister, size, $src$$PRegister, 1, false);\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, $tmp$$FloatRegister,\n+                          ptrue, T_BOOLEAN, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ StoreVector+VectorStoreMask, and the vector size of \"src\" is less than the MaxVectorSize.\n+instruct storeV_vstoremask_masked(indirect mem, pRegGov src, immI_gt_1 esize,\n+                                  vReg tmp, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length_in_bytes(n->as_StoreVector()->in(MemNode::ValueIn)->in(1)) < MaxVectorSize);\n+  match(Set mem (StoreVector mem (VectorStoreMask src esize)));\n+  effect(TEMP tmp, TEMP pgtmp, KILL cr);\n+  format %{ \"storeV_vstoremask_masked $mem, $src\\t# KILL $tmp, $pgtmp, cr\" %}\n+  ins_encode %{\n+    \/\/ Convert the valid src predicate to vector, and store the vector elements\n+    \/\/ as boolean values.\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_cpy($tmp$$FloatRegister, size, $src$$PRegister, 1, false);\n+    __ sve_gen_mask_imm($pgtmp$$PRegister, bt, Matcher::vector_length(this, $src));\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, $tmp$$FloatRegister,\n+                          $pgtmp$$PRegister, T_BOOLEAN, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ StoreVectorMasked+VectorStoreMask, and the vector size of \"src\" is equal to the MaxVectorSize.\n+instruct storeVMasked_vstoremask(vmemA mem, pRegGov src, pRegGov pg, immI_gt_1 esize, vReg tmp) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length_in_bytes(n->as_StoreVector()->in(MemNode::ValueIn)->in(1)) == MaxVectorSize);\n+  match(Set mem (StoreVectorMasked mem (Binary (VectorStoreMask src esize) pg)));\n+  effect(TEMP tmp);\n+  format %{ \"storeVMasked_vstoremask $mem, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    \/\/ Convert the valid src predicate to vector, and store the vector elements\n+    \/\/ as boolean values.\n+    \/\/\n+    \/\/ Note that we cannot use \"pg\" here, since it is the predicate used\n+    \/\/ for the vector store with boolean type. But the predicate used in\n+    \/\/ the narrowing \"sve_st1b\" is based on the \"src\" vector type, which\n+    \/\/ is the full-sized predicate (ptrue) here.\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    assert(type2aelembytes(bt) == (int)$esize$$constant, \"unsupported type.\");\n+    Assembler::SIMD_RegVariant size = __ elemBytes_to_regVariant($esize$$constant);\n+    __ sve_cpy($tmp$$FloatRegister, size, $src$$PRegister, 1, false);\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, $tmp$$FloatRegister,\n+                          ptrue, T_BOOLEAN, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ StoreVectorMasked+VectorStoreMask, and the vector size of \"src\" is less than the MaxVectorSize.\n+instruct storeVMasked_vstoremask_masked(vmemA mem, pRegGov src, pRegGov pg, immI_gt_1 esize,\n+                                        vReg tmp, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length_in_bytes(n->as_StoreVector()->in(MemNode::ValueIn)->in(1)) < MaxVectorSize);\n+  match(Set mem (StoreVectorMasked mem (Binary (VectorStoreMask src esize) pg)));\n+  effect(TEMP tmp, TEMP pgtmp, KILL cr);\n+  format %{ \"storeVMasked_vstoremask_masked $mem, $src\\t# KILL $tmp, $pgtmp, cr\" %}\n+  ins_encode %{\n+    \/\/ Convert the valid src predicate to vector, and store the vector elements\n+    \/\/ as boolean values.\n+    \/\/\n+    \/\/ Note that we cannot use \"pg\" here, since it is the predicate used for the\n+    \/\/ vector store with boolean type. But the predicate used in the narrowing\n+    \/\/ \"sve_st1b\" is based on the \"src\" vector type, which needed to be generated\n+    \/\/ here.\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_cpy($tmp$$FloatRegister, size, $src$$PRegister, 1, false);\n+    __ sve_gen_mask_imm($pgtmp$$PRegister, bt, Matcher::vector_length(this, $src));\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, $tmp$$FloatRegister,\n+                          $pgtmp$$PRegister, T_BOOLEAN, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector mask basic OPs ------------------------\n+\n+\/\/ vector mask logical ops: and\/or\/xor\/and_not\n+\n+instruct vmask_and(pRegGov pd, pRegGov pn, pRegGov pm) %{\n+  predicate(UseSVE > 0);\n+  match(Set pd (AndVMask pn pm));\n+  format %{ \"vmask_and $pd, $pn, $pm\" %}\n+  ins_encode %{\n+    __ sve_and($pd$$PRegister, ptrue, $pn$$PRegister, $pm$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_or(pRegGov pd, pRegGov pn, pRegGov pm) %{\n+  predicate(UseSVE > 0);\n+  match(Set pd (OrVMask pn pm));\n+  format %{ \"vmask_or $pd, $pn, $pm\" %}\n+  ins_encode %{\n+    __ sve_orr($pd$$PRegister, ptrue, $pn$$PRegister, $pm$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_xor(pRegGov pd, pRegGov pn, pRegGov pm) %{\n+  predicate(UseSVE > 0);\n+  match(Set pd (XorVMask pn pm));\n+  format %{ \"vmask_xor $pd, $pn, $pm\" %}\n+  ins_encode %{\n+    __ sve_eor($pd$$PRegister, ptrue, $pn$$PRegister, $pm$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_and_notI(pRegGov pd, pRegGov pn, pRegGov pm, immI_M1 m1) %{\n+  predicate(UseSVE > 0);\n+  match(Set pd (AndVMask pn (XorVMask pm (MaskAll m1))));\n+  format %{ \"vmask_and_notI $pd, $pn, $pm\" %}\n+  ins_encode %{\n+    __ sve_bic($pd$$PRegister, ptrue, $pn$$PRegister, $pm$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_and_notL(pRegGov pd, pRegGov pn, pRegGov pm, immL_M1 m1) %{\n+  predicate(UseSVE > 0);\n+  match(Set pd (AndVMask pn (XorVMask pm (MaskAll m1))));\n+  format %{ \"vmask_and_notL $pd, $pn, $pm\" %}\n+  ins_encode %{\n+    __ sve_bic($pd$$PRegister, ptrue, $pn$$PRegister, $pm$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector mask compare\n+\n+instruct vmaskcmp_neon(vReg dst, vReg src1, vReg src2, immI cond) %{\n+  predicate(UseSVE == 0 &&\n+            (Matcher::vector_length_in_bytes(n) == 8 ||\n+             Matcher::vector_length_in_bytes(n) == 16));\n+  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n+  format %{ \"vmaskcmp_neon $dst, $src1, $src2, $cond\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ neon_compare($dst$$FloatRegister, bt, $src1$$FloatRegister,\n+                    $src2$$FloatRegister, (int)($cond$$constant),\n+                    \/* isQ *\/ length_in_bytes == 16);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskcmp_sve(pRegGov dst, vReg src1, vReg src2, immI cond, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n+  effect(KILL cr);\n+  format %{ \"vmaskcmp_sve $dst, $src1, $src2, $cond\\t# KILL cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_compare($dst$$PRegister, bt, ptrue, $src1$$FloatRegister,\n+                   $src2$$FloatRegister, (int)($cond$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskcmp_masked(pRegGov dst, vReg src1, vReg src2, immI cond,\n+                         pRegGov pg, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorMaskCmp (Binary src1 src2) (Binary cond pg)));\n+  effect(KILL cr);\n+  format %{ \"vmaskcmp_masked $dst, $pg, $src1, $src2, $cond\\t# KILL cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_compare($dst$$PRegister, bt, $pg$$PRegister, $src1$$FloatRegister,\n+                   $src2$$FloatRegister, (int)($cond$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector mask cast\n+\n+instruct vmaskcast_same_esize_neon(vReg dst_src) %{\n+  predicate(UseSVE == 0 &&\n+            Matcher::vector_length_in_bytes(n) == Matcher::vector_length_in_bytes(n->in(1)) &&\n+            (Matcher::vector_length_in_bytes(n) == 8 || Matcher::vector_length_in_bytes(n) == 16));\n+  match(Set dst_src (VectorMaskCast dst_src));\n+  ins_cost(0);\n+  format %{ \"vmaskcast_same_esize_neon $dst_src\\t# do nothing\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n+instruct vmaskcast_same_esize_sve(pRegGov dst_src) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length_in_bytes(n) == Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst_src (VectorMaskCast dst_src));\n+  ins_cost(0);\n+  format %{ \"vmaskcast_same_esize_sve $dst_src\\t# do nothing\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n+instruct vmaskcast_extend(pRegGov dst, pReg src) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length_in_bytes(n) > Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vmaskcast_extend $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);\n+    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, $src);\n+    assert(length_in_bytes_dst == 2 * length_in_bytes_src ||\n+           length_in_bytes_dst == 4 * length_in_bytes_src ||\n+           length_in_bytes_dst == 8 * length_in_bytes_src, \"invalid vector length\");\n+    __ sve_vmaskcast_extend($dst$$PRegister, $src$$PRegister,\n+                            length_in_bytes_dst, length_in_bytes_src);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskcast_narrow(pRegGov dst, pReg src) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length_in_bytes(n) < Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vmaskcast_narrow $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);\n+    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, $src);\n+    assert(length_in_bytes_dst * 2 == length_in_bytes_src ||\n+           length_in_bytes_dst * 4 == length_in_bytes_src ||\n+           length_in_bytes_dst * 8 == length_in_bytes_src, \"invalid vector length\");\n+    __ sve_vmaskcast_narrow($dst$$PRegister, $src$$PRegister,\n+                            length_in_bytes_dst, length_in_bytes_src);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector mask reinterpret\n+\n+instruct vmask_reinterpret_same_esize(pRegGov dst_src) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length(n) == Matcher::vector_length(n->in(1)) &&\n+            Matcher::vector_length_in_bytes(n) == Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst_src (VectorReinterpret dst_src));\n+  ins_cost(0);\n+  format %{ \"vmask_reinterpret_same_esize $dst_src\\t# do nothing\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n+instruct vmask_reinterpret_diff_esize(pRegGov dst, pRegGov src, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length(n) != Matcher::vector_length(n->in(1)) &&\n+            Matcher::vector_length_in_bytes(n) == Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorReinterpret src));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vmask_reinterpret_diff_esize $dst, $src\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType from_bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant from_size = __ elemType_to_regVariant(from_bt);\n+    BasicType to_bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n+    __ sve_cpy($tmp$$FloatRegister, from_size, $src$$PRegister, -1, false);\n+    __ sve_cmp(Assembler::EQ, $dst$$PRegister, to_size, ptrue, $tmp$$FloatRegister, -1);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector mask reductions -----------------------\n+\n+\/\/ true count\n+\n+instruct vmask_truecount_neon(iRegINoSp dst, vReg src, vReg tmp) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (VectorMaskTrueCount src));\n+  effect(TEMP tmp);\n+  format %{ \"vmask_truecount_neon $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    \/\/ Input \"src\" is a vector of boolean represented as bytes with\n+    \/\/ 0x00\/0x01 as element values.\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    assert(bt == T_BOOLEAN, \"unsupported type\");\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    __ addv($tmp$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+            $src$$FloatRegister);\n+    __ umov($dst$$Register, $tmp$$FloatRegister, __ B, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_truecount_sve(iRegINoSp dst, pReg src) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorMaskTrueCount src));\n+  format %{ \"vmask_truecount_sve $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ sve_cntp($dst$$Register, __ elemType_to_regVariant(bt),\n+                ptrue, $src$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ first true\n+\n+instruct vmask_firsttrue_lt8e(iRegINoSp dst, vReg src, rFlagsReg cr) %{\n+  predicate(UseSVE == 0 &&\n+            Matcher::vector_length(n->in(1)) < 8);\n+  match(Set dst (VectorMaskFirstTrue src));\n+  effect(KILL cr);\n+  format %{ \"vmask_firsttrue_lt8e $dst, $src\\t# vector < 8 elements (neon). KILL cr\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the first active lane of the\n+    \/\/ vector mask, or VLENGTH if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    \/\/\n+    \/\/ Computed by reversing the bits and counting the leading\n+    \/\/ zero bytes.\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    assert(bt == T_BOOLEAN, \"unsupported type\");\n+    __ fmovd($dst$$Register, $src$$FloatRegister);\n+    __ rbit($dst$$Register, $dst$$Register);\n+    __ clz($dst$$Register, $dst$$Register);\n+    __ lsrw($dst$$Register, $dst$$Register, 3);\n+    __ movw(rscratch1, Matcher::vector_length(this, $src));\n+    __ cmpw($dst$$Register, rscratch1);\n+    __ cselw($dst$$Register, rscratch1, $dst$$Register, Assembler::GE);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_firsttrue_8or16e(iRegINoSp dst, vReg src) %{\n+  predicate(UseSVE == 0 &&\n+            (Matcher::vector_length(n->in(1)) == 8 || Matcher::vector_length(n->in(1)) == 16));\n+  match(Set dst (VectorMaskFirstTrue src));\n+  format %{ \"vmask_firsttrue_8or16e $dst, $src\\t# vector 8B\/16B (neon)\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the first active lane of the\n+    \/\/ vector mask, or VLENGTH if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    \/\/\n+    \/\/ Computed by reversing the bits and counting the leading\n+    \/\/ zero bytes.\n+\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    assert(bt == T_BOOLEAN, \"unsupported type\");\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    if (length_in_bytes == 8) {\n+      __ fmovd($dst$$Register, $src$$FloatRegister);\n+      __ rbit($dst$$Register, $dst$$Register);\n+      __ clz($dst$$Register, $dst$$Register);\n+      __ lsrw($dst$$Register, $dst$$Register, 3);\n+    } else {\n+      assert(length_in_bytes == 16, \"must be\");\n+      Label FIRST_TRUE_INDEX;\n+\n+      \/\/ Try to compute the result from lower 64 bits.\n+      __ fmovd($dst$$Register, $src$$FloatRegister);\n+      __ movw(rscratch1, zr);\n+      __ cbnz($dst$$Register, FIRST_TRUE_INDEX);\n+\n+      \/\/ Compute the result from the higher 64 bits.\n+      __ fmovhid($dst$$Register, $src$$FloatRegister);\n+      __ movw(rscratch1, 8);\n+\n+      \/\/ Reverse the bits and count the leading zero bytes.\n+      __ bind(FIRST_TRUE_INDEX);\n+      __ rbit($dst$$Register, $dst$$Register);\n+      __ clz($dst$$Register, $dst$$Register);\n+      __ addw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Return the index of the first mask lane that is set, or vector length if none of\n+\/\/ them are set.\n+\n+instruct vmask_firsttrue_sve(iRegINoSp dst, pReg src, pReg ptmp) %{\n+  predicate(UseSVE > 0 && !n->is_predicated_vector());\n+  match(Set dst (VectorMaskFirstTrue src));\n+  effect(TEMP ptmp);\n+  format %{ \"vmask_firsttrue_sve $dst, $src\\t# KILL $ptmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_brkb($ptmp$$PRegister, ptrue, $src$$PRegister, false);\n+    __ sve_cntp($dst$$Register, __ elemType_to_regVariant(bt), ptrue, $ptmp$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_firsttrue_masked(iRegINoSp dst, pReg src, pRegGov pg, pReg ptmp) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorMaskFirstTrue src pg));\n+  effect(TEMP ptmp);\n+  format %{ \"vmask_firsttrue_masked $dst, $pg, $src\\t# KILL $ptmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ sve_brkb($ptmp$$PRegister, $pg$$PRegister, $src$$PRegister, false);\n+    __ sve_cntp($dst$$Register, __ elemType_to_regVariant(bt), ptrue, $ptmp$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ last true\n+\n+instruct vmask_lasttrue_neon(iRegINoSp dst, vReg src) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (VectorMaskLastTrue src));\n+  format %{ \"vmask_lasttrue_neon $dst, $src\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the last active lane of the\n+    \/\/ vector mask, or -1 if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    assert(bt == T_BOOLEAN, \"unsupported type\");\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    if (length_in_bytes <= 8) {\n+      \/\/ Computed by counting the leading zero bytes and\n+      \/\/ subtracting it by 7 (VLENGTH - 1).\n+      __ fmovd($dst$$Register, $src$$FloatRegister);\n+      __ clz($dst$$Register, $dst$$Register);\n+      __ movw(rscratch1, 7);\n+      __ subw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n+    } else {\n+      assert(length_in_bytes == 16, \"must be\");\n+      Label LAST_TRUE_INDEX;\n+\n+      \/\/ Try to compute the result from higher 64 bits.\n+      __ fmovhid($dst$$Register, $src$$FloatRegister);\n+      __ movw(rscratch1, 16 - 1);\n+      __ cbnz($dst$$Register, LAST_TRUE_INDEX);\n+\n+      \/\/ Compute the result from the lower 64 bits.\n+      __ fmovd($dst$$Register, $src$$FloatRegister);\n+      __ movw(rscratch1, 8 - 1);\n+\n+      \/\/ Count the leading zero bytes and subtract it by 15 (VLENGTH - 1).\n+      __ bind(LAST_TRUE_INDEX);\n+      __ clz($dst$$Register, $dst$$Register);\n+      __ subw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_lasttrue_sve(iRegINoSp dst, pReg src, pReg ptmp) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorMaskLastTrue src));\n+  effect(TEMP ptmp);\n+  format %{ \"vmask_lasttrue_sve $dst, $src\\t# KILL $ptmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ sve_vmask_lasttrue($dst$$Register, bt, $src$$PRegister, $ptmp$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ tolong\n+\n+instruct vmask_tolong_neon(iRegLNoSp dst, vReg src) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (VectorMaskToLong src));\n+  format %{ \"vmask_tolong_neon $dst, $src\" %}\n+  ins_encode %{\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    if (length_in_bytes <= 8) {\n+      __ fmovd($dst$$Register, $src$$FloatRegister);\n+      __ bytemask_compress($dst$$Register);\n+    } else {\n+      assert(length_in_bytes == 16, \"must be\");\n+      __ umov($dst$$Register, $src$$FloatRegister, __ D, 0);\n+      __ umov(rscratch1, $src$$FloatRegister, __ D, 1);\n+      __ bytemask_compress($dst$$Register);\n+      __ bytemask_compress(rscratch1);\n+      __ orr($dst$$Register, $dst$$Register, rscratch1, Assembler::LSL, 8);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_tolong_sve(iRegLNoSp dst, pReg src, vReg tmp1, vReg tmp2) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorMaskToLong src));\n+  effect(TEMP tmp1, TEMP tmp2);\n+  format %{ \"vmask_tolong_sve $dst, $src\\t# KILL $tmp1, $tmp2\" %}\n+  ins_encode %{\n+    __ sve_vmask_tolong($dst$$Register, $src$$PRegister,\n+                        Matcher::vector_element_basic_type(this, $src),\n+                        Matcher::vector_length(this, $src),\n+                        $tmp1$$FloatRegister, $tmp2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ fromlong\n+\n+instruct vmask_fromlong(pRegGov dst, iRegL src, vReg tmp1, vReg tmp2) %{\n+  match(Set dst (VectorLongToMask src));\n+  effect(TEMP tmp1, TEMP tmp2);\n+  format %{ \"vmask_fromlong $dst, $src\\t# vector (sve2). KILL $tmp1, $tmp2\" %}\n+  ins_encode %{\n+    __ sve_vmask_fromlong($dst$$PRegister, $src$$Register,\n+                          Matcher::vector_element_basic_type(this),\n+                          Matcher::vector_length(this),\n+                          $tmp1$$FloatRegister, $tmp2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector mask generation -----------------------\n+\n+\/\/ maskAll\n+\n+instruct vmaskAll_immI(pRegGov dst, immI src, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (MaskAll src));\n+  effect(KILL cr);\n+  format %{ \"vmaskAll_immI $dst, $src\\t# KILL cr\" %}\n+  ins_encode %{\n+    int con = (int)$src$$constant;\n+    if (con == 0) {\n+      __ sve_pfalse($dst$$PRegister);\n+    } else {\n+      assert(con == -1, \"invalid constant value for mask\");\n+      BasicType bt = Matcher::vector_element_basic_type(this);\n+      __ sve_gen_mask_imm($dst$$PRegister, bt, Matcher::vector_length(this));\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskAllI(pRegGov dst, iRegIorL2I src, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && !n->is_predicated_vector());\n+  match(Set dst (MaskAll src));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vmaskAllI $dst, $src\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_dup($tmp$$FloatRegister, size, $src$$Register);\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, size, ptrue, $tmp$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskAllI_masked(pRegGov dst, iRegIorL2I src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (MaskAll src pg));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vmaskAllI_masked $dst, $pg, $src\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_dup($tmp$$FloatRegister, size, $src$$Register);\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, size,\n+               $pg$$PRegister, $tmp$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskAll_immL(pRegGov dst, immL src, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (MaskAll src));\n+  effect(KILL cr);\n+  format %{ \"vmaskAll_immL $dst, $src\\t# KILL cr\" %}\n+  ins_encode %{\n+    long con = (long)$src$$constant;\n+    if (con == 0) {\n+      __ sve_pfalse($dst$$PRegister);\n+    } else {\n+      assert(con == -1, \"invalid constant value for mask\");\n+      BasicType bt = Matcher::vector_element_basic_type(this);\n+      __ sve_gen_mask_imm($dst$$PRegister, bt, Matcher::vector_length(this));\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskAllL(pRegGov dst, iRegL src, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && !n->is_predicated_vector());\n+  match(Set dst (MaskAll src));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vmaskAllL $dst, $src\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_dup($tmp$$FloatRegister, size, $src$$Register);\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, size, ptrue, $tmp$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskAllL_masked(pRegGov dst, iRegL src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (MaskAll src pg));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vmaskAllL_masked $dst, $pg, $src\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_dup($tmp$$FloatRegister, size, $src$$Register);\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, size,\n+               $pg$$PRegister, $tmp$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vetcor mask generation\n+\n+instruct vmask_gen_I(pRegGov pd, iRegIorL2I src, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set pd (VectorMaskGen (ConvI2L src)));\n+  effect(KILL cr);\n+  format %{ \"vmask_gen_I $pd, $src\\t# KILL cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_whilelow($pd$$PRegister, __ elemType_to_regVariant(bt), zr, $src$$Register);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct vmask_gen_L(pRegGov pd, iRegL src, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set pd (VectorMaskGen src));\n+  effect(KILL cr);\n+  format %{ \"vmask_gen_L $pd, $src\\t# KILL cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_whilelo($pd$$PRegister, __ elemType_to_regVariant(bt), zr, $src$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_gen_imm(pRegGov pd, immL con, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set pd (VectorMaskGen con));\n+  effect(KILL cr);\n+  format %{ \"vmask_gen_imm $pd, $con\\t# KILL cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_gen_mask_imm($pd$$PRegister, bt, (uint)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Popcount vector ------------------------------\n+\n+\/\/ vector popcount - INT\n+\n+instruct vpopcountI(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (PopCountVI src));\n+  format %{ \"vpopcountI $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (bt == T_BYTE) {\n+      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+        __ cnt($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+               $src$$FloatRegister);\n+      } else {\n+        assert(UseSVE > 0, \"must be sve\");\n+        __ sve_cnt($dst$$FloatRegister, __ B, ptrue, $src$$FloatRegister);\n+      }\n+    } else {\n+      assert(bt == T_SHORT || bt == T_INT, \"unsupported\");\n+      if (UseSVE == 0) {\n+        assert(length_in_bytes == 8 || length_in_bytes == 16, \"unsupported\");\n+        __ cnt($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+               $src$$FloatRegister);\n+        __ uaddlp($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+                  $dst$$FloatRegister);\n+        if (bt == T_INT) {\n+          __ uaddlp($dst$$FloatRegister, length_in_bytes == 16 ? __ T8H : __ T4H,\n+                    $dst$$FloatRegister);\n+        }\n+      } else {\n+        __ sve_cnt($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                   ptrue, $src$$FloatRegister);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector popcount - LONG\n+\n+instruct vpopcountL(vReg dst, vReg src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_LONG &&\n+            !n->as_Vector()->is_predicated_vector());\n+  match(Set dst (PopCountVL src));\n+  format %{ \"vpopcountL $dst, $src\" %}\n+  ins_encode %{\n+    if (UseSVE == 0) {\n+      __ cnt($dst$$FloatRegister, __ T16B, $src$$FloatRegister);\n+      __ uaddlp($dst$$FloatRegister, __ T16B, $dst$$FloatRegister);\n+      __ uaddlp($dst$$FloatRegister, __ T8H, $dst$$FloatRegister);\n+      __ uaddlp($dst$$FloatRegister, __ T4S, $dst$$FloatRegister);\n+    } else {\n+      __ sve_cnt($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ If the PopCountVL is generated by auto-vectorization, the dst basic\n+\/\/ type is T_INT. And once we have unified the type definition for\n+\/\/ Vector API and auto-vectorization, this rule can be merged with\n+\/\/ \"vpopcountL\" rule.\n+\n+instruct vpopcountL_I(vReg dst, vReg src, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_INT &&\n+            !n->as_Vector()->is_predicated_vector());\n+  match(Set dst (PopCountVL src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vpopcountL_I $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    if (UseSVE == 0) {\n+      __ cnt($dst$$FloatRegister, __ T16B, $src$$FloatRegister);\n+      __ uaddlp($dst$$FloatRegister, __ T16B, $dst$$FloatRegister);\n+      __ uaddlp($dst$$FloatRegister, __ T8H, $dst$$FloatRegister);\n+      __ uaddlp($dst$$FloatRegister, __ T4S, $dst$$FloatRegister);\n+      __ xtn($dst$$FloatRegister, __ T2S, $dst$$FloatRegister, __ T2D);\n+    } else {\n+      __ sve_cnt($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+      __ sve_vector_narrow($dst$$FloatRegister, __ S,\n+                           $dst$$FloatRegister, __ D, $tmp$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector popcount - predicated\n+\n+instruct vpopcountI_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (PopCountVI dst_src pg));\n+  format %{ \"vpopcountI_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_cnt($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vpopcountL_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst_src (PopCountVL dst_src pg));\n+  format %{ \"vpopcountL_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    __ sve_cnt($dst_src$$FloatRegister, __ D,\n+               $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector blend ---------------------------------\n+\n+instruct vblend_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (VectorBlend (Binary src1 src2) dst));\n+  format %{ \"vblend_neon $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n+    __ bsl($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+           $src2$$FloatRegister, $src1$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vblend_sve(vReg dst, vReg src1, vReg src2, pReg pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorBlend (Binary src1 src2) pg));\n+  format %{ \"vblend_sve $dst, $pg, $src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_sel($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $src2$$FloatRegister, $src1$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector round ---------------------------------\n+\n+\/\/ vector Math.round\n+\n+instruct vround_le128b(vReg dst, vReg src, vReg tmp1, vReg tmp2,\n+                       vReg tmp3, rFlagsReg cr) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16);\n+  match(Set dst (RoundVF src));\n+  match(Set dst (RoundVD src));\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+  format %{ \"vround_le128b $dst, $src\\t# vector <= 128 bits. KILL $tmp1, $tmp2, $tmp3, cr\" %}\n+  ins_encode %{\n+    __ vector_round_neon($dst$$FloatRegister, $src$$FloatRegister,\n+                         $tmp1$$FloatRegister, $tmp2$$FloatRegister,\n+                         $tmp3$$FloatRegister, get_arrangement(this));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vround_gt128b(vReg dst, vReg src, vReg tmp1, vReg tmp2,\n+                       pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16);\n+  match(Set dst (RoundVF src));\n+  match(Set dst (RoundVD src));\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP pgtmp, KILL cr);\n+  format %{ \"vround_gt128b $dst, $src\\t# vector > 128 bits. KILL $tmp1, $tmp2, $pgtmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vector_round_sve($dst$$FloatRegister, $src$$FloatRegister,\n+                        $tmp1$$FloatRegister, $tmp2$$FloatRegister,\n+                        $pgtmp$$PRegister, __ elemType_to_regVariant(bt));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ RoundDouble ----------------------------------\n+\n+\/\/ vector Math.rint, floor, ceil\n+\n+instruct vroundD(vReg dst, vReg src, immI rmode) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+  match(Set dst (RoundDoubleModeV src rmode));\n+  format %{ \"vroundD $dst, $src, $rmode\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      switch ($rmode$$constant) {\n+        case RoundDoubleModeNode::rmode_rint:\n+          __ frintn($dst$$FloatRegister, __ T2D, $src$$FloatRegister);\n+          break;\n+        case RoundDoubleModeNode::rmode_floor:\n+          __ frintm($dst$$FloatRegister, __ T2D, $src$$FloatRegister);\n+          break;\n+        case RoundDoubleModeNode::rmode_ceil:\n+          __ frintp($dst$$FloatRegister, __ T2D, $src$$FloatRegister);\n+          break;\n+        default:\n+          assert(false, \"unsupported\");\n+          ShouldNotReachHere();\n+      }\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      switch ($rmode$$constant) {\n+        case RoundDoubleModeNode::rmode_rint:\n+          __ sve_frintn($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+          break;\n+        case RoundDoubleModeNode::rmode_floor:\n+          __ sve_frintm($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+          break;\n+        case RoundDoubleModeNode::rmode_ceil:\n+          __ sve_frintp($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+          break;\n+        default:\n+          assert(false, \"unsupported\");\n+          ShouldNotReachHere();\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ VectorTest -----------------------------------\n+\n+\/\/ anytrue\n+\n+instruct vtest_anytrue_neon(iRegINoSp dst, vReg src1, vReg src2, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE == 0 &&\n+            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::ne);\n+  match(Set dst (VectorTest src1 src2 ));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vtest_anytrue_neon $dst, $src1\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    \/\/ No need to use src2.\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src1);\n+    assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n+    __ addv($tmp$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B, $src1$$FloatRegister);\n+    __ umov($dst$$Register, $tmp$$FloatRegister, __ B, 0);\n+    __ cmpw($dst$$Register, zr);\n+    __ csetw($dst$$Register, Assembler::NE);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vtest_anytrue_sve(iRegINoSp dst, pRegGov src1, pRegGov src2, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::ne);\n+  match(Set dst (VectorTest src1 src2));\n+  effect(KILL cr);\n+  format %{ \"vtest_anytrue_sve $dst, $src1\\t# KILL cr\" %}\n+  ins_encode %{\n+    \/\/ \"src2\" is not used for sve.\n+    __ sve_ptest(ptrue, $src1$$PRegister);\n+    __ csetw($dst$$Register, Assembler::NE);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ alltrue\n+\n+instruct vtest_alltrue_neon(iRegINoSp dst, vReg src1, vReg src2, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE == 0 &&\n+            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow);\n+  match(Set dst (VectorTest src1 src2));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vtest_alltrue_neon $dst, $src1\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    \/\/ No need to use src2.\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src1);\n+    assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n+    __ uminv($tmp$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B, $src1$$FloatRegister);\n+    __ umov($dst$$Register, $tmp$$FloatRegister, __ B, 0);\n+    __ cmpw($dst$$Register, 0xff);\n+    __ csetw($dst$$Register, Assembler::EQ);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vtest_alltrue_sve(iRegINoSp dst, pRegGov src1, pRegGov src2, pReg ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow);\n+  match(Set dst (VectorTest src1 src2));\n+  effect(TEMP ptmp, KILL cr);\n+  format %{ \"vtest_alltrue_sve $dst, $src1, $src2\\t# KILL $ptmp, cr\" %}\n+  ins_encode %{\n+    __ sve_eors($ptmp$$PRegister, ptrue, $src1$$PRegister, $src2$$PRegister);\n+    __ csetw($dst$$Register, Assembler::EQ);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector shuffle -------------------------------\n+\n+instruct loadshuffle(vReg dst, vReg src) %{\n+  match(Set dst (VectorLoadShuffle src));\n+  format %{ \"loadshuffle $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (bt == T_BYTE) {\n+      if ($dst$$FloatRegister != $src$$FloatRegister) {\n+        if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+          __ orr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+                 $src$$FloatRegister, $src$$FloatRegister);\n+        } else {\n+          assert(UseSVE > 0, \"must be sve\");\n+          __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+        }\n+      }\n+    } else {\n+      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+        \/\/ 4S\/8S, 4I, 4F\n+        __ uxtl($dst$$FloatRegister, __ T8H, $src$$FloatRegister, __ T8B);\n+        if (type2aelembytes(bt) == 4) {\n+          __ uxtl($dst$$FloatRegister, __ T4S, $dst$$FloatRegister, __ T4H);\n+        }\n+      } else {\n+        assert(UseSVE > 0, \"must be sve\");\n+        __ sve_vector_extend($dst$$FloatRegister,  __ elemType_to_regVariant(bt),\n+                             $src$$FloatRegister, __ B);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector rearrange -----------------------------\n+\n+\/\/ Here is an example that rearranges a NEON vector with 4 ints:\n+\/\/ Rearrange V1 int[a0, a1, a2, a3] to V2 int[a2, a3, a0, a1]\n+\/\/   1. Get the indices of V1 and store them as Vi byte[0, 1, 2, 3].\n+\/\/   2. Convert Vi byte[0, 1, 2, 3] to the indices of V2 and also store them as Vi byte[2, 3, 0, 1].\n+\/\/   3. Unsigned extend Long Vi from byte[2, 3, 0, 1] to int[2, 3, 0, 1].\n+\/\/   4. Multiply Vi int[2, 3, 0, 1] with constant int[0x04040404, 0x04040404, 0x04040404, 0x04040404]\n+\/\/      and get tbl base Vm int[0x08080808, 0x0c0c0c0c, 0x00000000, 0x04040404].\n+\/\/   5. Add Vm with constant int[0x03020100, 0x03020100, 0x03020100, 0x03020100]\n+\/\/      and get tbl index Vm int[0x0b0a0908, 0x0f0e0d0c, 0x03020100, 0x07060504]\n+\/\/   6. Use Vm as index register, and use V1 as table register.\n+\/\/      Then get V2 as the result by tbl NEON instructions.\n+\/\/ Notes:\n+\/\/   Step 1 matches VectorLoadConst.\n+\/\/   Step 3 matches VectorLoadShuffle.\n+\/\/   Step 4, 5, 6 match VectorRearrange.\n+\/\/   For VectorRearrange short\/int, the reason why such complex calculation is\n+\/\/   required is because NEON tbl supports bytes table only, so for short\/int, we\n+\/\/   need to lookup 2\/4 bytes as a group. For VectorRearrange long, we use bsl\n+\/\/   to implement rearrange.\n+\n+instruct rearrange_HS_neon(vReg dst, vReg src, vReg shuffle, vReg tmp1, vReg tmp2) %{\n+  predicate(UseSVE == 0 &&\n+            (Matcher::vector_element_basic_type(n) == T_SHORT ||\n+             (type2aelembytes(Matcher::vector_element_basic_type(n)) == 4 &&\n+              Matcher::vector_length_in_bytes(n) == 16)));\n+  match(Set dst (VectorRearrange src shuffle));\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);\n+  format %{ \"rearrange_HS_neon $dst, $src, $shuffle\\t# vector (4S\/8S\/4I\/4F). KILL $tmp1, $tmp2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (bt == T_SHORT) {\n+      uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+      assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n+      Assembler::SIMD_Arrangement size1 = length_in_bytes == 16 ? __ T16B : __ T8B;\n+      Assembler::SIMD_Arrangement size2 = length_in_bytes == 16 ? __ T8H : __ T4H;\n+      __ mov($tmp1$$FloatRegister, size1, 0x02);\n+      __ mov($tmp2$$FloatRegister, size2, 0x0100);\n+      __ mulv($dst$$FloatRegister, size2, $shuffle$$FloatRegister, $tmp1$$FloatRegister);\n+      __ addv($dst$$FloatRegister, size1, $dst$$FloatRegister, $tmp2$$FloatRegister);\n+      __ tbl($dst$$FloatRegister, size1, $src$$FloatRegister, 1, $dst$$FloatRegister);\n+    } else {\n+      assert(bt == T_INT || bt == T_FLOAT, \"unsupported type\");\n+      __ mov($tmp1$$FloatRegister, __ T16B, 0x04);\n+      __ mov($tmp2$$FloatRegister, __ T4S, 0x03020100);\n+      __ mulv($dst$$FloatRegister, __ T4S, $shuffle$$FloatRegister, $tmp1$$FloatRegister);\n+      __ addv($dst$$FloatRegister, __ T16B, $dst$$FloatRegister, $tmp2$$FloatRegister);\n+      __ tbl($dst$$FloatRegister, __ T16B, $src$$FloatRegister, 1, $dst$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct rearrange(vReg dst, vReg src, vReg shuffle) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE || UseSVE > 0);\n+  match(Set dst (VectorRearrange src shuffle));\n+  format %{ \"rearrange $dst, $src, $shuffle\" %}\n+  ins_encode %{\n+    BasicType bt_dst = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (bt_dst == T_BYTE && VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ tbl($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+             $src$$FloatRegister, 1, $shuffle$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      BasicType bt_src = Matcher::vector_element_basic_type(this, $src);\n+      __ sve_tbl($dst$$FloatRegister, __ elemType_to_regVariant(bt_src),\n+                 $src$$FloatRegister, $shuffle$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector Load Gather ---------------------------\n+\n+instruct gather_loadS(vReg dst, indirect mem, vReg idx) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) == 4);\n+  match(Set dst (LoadVectorGather mem idx));\n+  format %{ \"gather_loadS $dst, $mem, $idx\\t# vector (sve)\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_ld1w_gather($dst$$FloatRegister, ptrue,\n+                       as_Register($mem$$base), $idx$$FloatRegister);\n+ %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct gather_loadD(vReg dst, indirect mem, vReg idx, vReg tmp) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) == 8);\n+  match(Set dst (LoadVectorGather mem idx));\n+  effect(TEMP tmp);\n+  format %{ \"gather_loadD $dst, $mem, $idx\\t# vector (sve). KILL $tmp\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_uunpklo($tmp$$FloatRegister, __ D, $idx$$FloatRegister);\n+    __ sve_ld1d_gather($dst$$FloatRegister, ptrue, as_Register($mem$$base),\n+                       $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct gather_loadS_masked(vReg dst, indirect mem, vReg idx, pRegGov pg) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) == 4);\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx pg)));\n+  format %{ \"gather_loadS_masked $dst, $pg, $mem, $idx\" %}\n+  ins_encode %{\n+    __ sve_ld1w_gather($dst$$FloatRegister, $pg$$PRegister,\n+                       as_Register($mem$$base), $idx$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct gather_loadD_masked(vReg dst, indirect mem, vReg idx, pRegGov pg, vReg tmp) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) == 8);\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx pg)));\n+  effect(TEMP tmp);\n+  format %{ \"gather_loadD_masked $dst, $pg, $mem, $idx\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ sve_uunpklo($tmp$$FloatRegister, __ D, $idx$$FloatRegister);\n+    __ sve_ld1d_gather($dst$$FloatRegister, $pg$$PRegister,\n+                       as_Register($mem$$base), $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector Store Scatter -------------------------\n+\n+instruct scatter_storeS(indirect mem, vReg src, vReg idx) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n->in(3)->in(1))) == 4);\n+  match(Set mem (StoreVectorScatter mem (Binary src idx)));\n+  format %{ \"scatter_storeS $mem, $idx, $src\\t# vector (sve)\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_st1w_scatter($src$$FloatRegister, ptrue,\n+                        as_Register($mem$$base), $idx$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct scatter_storeD(indirect mem, vReg src, vReg idx, vReg tmp) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n->in(3)->in(1))) == 8);\n+  match(Set mem (StoreVectorScatter mem (Binary src idx)));\n+  effect(TEMP tmp);\n+  format %{ \"scatter_storeD $mem, $idx, $src\\t# vector (sve). KILL $tmp\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_uunpklo($tmp$$FloatRegister, __ D, $idx$$FloatRegister);\n+    __ sve_st1d_scatter($src$$FloatRegister, ptrue,\n+                        as_Register($mem$$base), $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct scatter_storeS_masked(indirect mem, vReg src, vReg idx, pRegGov pg) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n->in(3)->in(1))) == 4);\n+  match(Set mem (StoreVectorScatterMasked mem (Binary src (Binary idx pg))));\n+  format %{ \"scatter_storeS_masked $mem, $pg, $idx, $src\" %}\n+  ins_encode %{\n+    __ sve_st1w_scatter($src$$FloatRegister, $pg$$PRegister,\n+                        as_Register($mem$$base), $idx$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct scatter_storeD_masked(indirect mem, vReg src, vReg idx, pRegGov pg, vReg tmp) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n->in(3)->in(1))) == 8);\n+  match(Set mem (StoreVectorScatterMasked mem (Binary src (Binary idx pg))));\n+  effect(TEMP tmp);\n+  format %{ \"scatter_storeD_masked $mem, $pg, $idx, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ sve_uunpklo($tmp$$FloatRegister, __ D, $idx$$FloatRegister);\n+    __ sve_st1d_scatter($src$$FloatRegister, $pg$$PRegister,\n+                        as_Register($mem$$base), $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ CountLeadingZerosV ---------------------------\n+\n+instruct vcountLeadingZeros(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (CountLeadingZerosV src));\n+  format %{ \"vcountLeadingZeros $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (bt == T_LONG) {\n+      if (UseSVE == 0) {\n+        __ umov(rscratch1, $src$$FloatRegister, __ D, 0);\n+        __ clz(rscratch1, rscratch1);\n+        __ mov($dst$$FloatRegister, __ D, 0, rscratch1);\n+        __ umov(rscratch1, $src$$FloatRegister, __ D, 1);\n+        __ clz(rscratch1, rscratch1);\n+        __ mov($dst$$FloatRegister, __ D, 1, rscratch1);\n+      } else {\n+        __ sve_clz($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+      }\n+    } else {\n+      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+        __ clz($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+      } else {\n+        assert(UseSVE > 0, \"must be sve\");\n+        __ sve_clz($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                   ptrue, $src$$FloatRegister);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ The dst and src should use the same register to make sure the\n+\/\/ inactive lanes in dst save the same elements as src.\n+\n+instruct vcountLeadingZeros_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (CountLeadingZerosV dst_src pg));\n+  format %{ \"vcountLeadingZeros_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_clz($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ CountTrailingZerosV --------------------------\n+\n+instruct vcountTrailingZeros(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (CountTrailingZerosV src));\n+  format %{ \"vcountTrailingZeros $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (bt == T_BYTE) {\n+      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+        __ rbit($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+                $src$$FloatRegister);\n+        __ clz($dst$$FloatRegister, get_arrangement(this), $dst$$FloatRegister);\n+      } else {\n+        assert(UseSVE > 0, \"must be sve\");\n+        __ sve_rbit($dst$$FloatRegister, __ B, ptrue, $src$$FloatRegister);\n+        __ sve_clz($dst$$FloatRegister, __ B, ptrue, $dst$$FloatRegister);\n+      }\n+    } else {\n+      assert(bt == T_SHORT || bt == T_INT || bt == T_LONG, \"unsupported type\");\n+      if (UseSVE == 0) {\n+        assert(length_in_bytes == 8 || length_in_bytes == 16, \"unsupported\");\n+        __ neon_reverse_bits($dst$$FloatRegister, $src$$FloatRegister,\n+                             bt, \/* isQ *\/ length_in_bytes == 16);\n+        if (bt != T_LONG) {\n+          __ clz($dst$$FloatRegister, get_arrangement(this), $dst$$FloatRegister);\n+        } else {\n+          __ umov(rscratch1, $dst$$FloatRegister, __ D, 0);\n+          __ clz(rscratch1, rscratch1);\n+          __ mov($dst$$FloatRegister, __ D, 0, rscratch1);\n+          __ umov(rscratch1, $dst$$FloatRegister, __ D, 1);\n+          __ clz(rscratch1, rscratch1);\n+          __ mov($dst$$FloatRegister, __ D, 1, rscratch1);\n+        }\n+      } else {\n+        Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+        __ sve_rbit($dst$$FloatRegister, size, ptrue, $src$$FloatRegister);\n+        __ sve_clz($dst$$FloatRegister, size, ptrue, $dst$$FloatRegister);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ The dst and src should use the same register to make sure the\n+\/\/ inactive lanes in dst save the same elements as src.\n+instruct vcountTrailingZeros_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (CountTrailingZerosV dst_src pg));\n+  format %{ \"vcountTrailingZeros_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_rbit($dst_src$$FloatRegister, size,\n+                $pg$$PRegister, $dst_src$$FloatRegister);\n+    __ sve_clz($dst_src$$FloatRegister, size,\n+               $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ ReverseV -------------------------------------\n+\n+instruct vreverse(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (ReverseV src));\n+  format %{ \"vreverse $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (bt == T_BYTE) {\n+      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+        __ rbit($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+                $src$$FloatRegister);\n+      } else {\n+        assert(UseSVE > 0, \"must be sve\");\n+        __ sve_rbit($dst$$FloatRegister, __ B, ptrue, $src$$FloatRegister);\n+      }\n+    } else {\n+      assert(bt == T_SHORT || bt == T_INT || bt == T_LONG, \"unsupported type\");\n+      if (UseSVE == 0) {\n+        assert(length_in_bytes == 8 || length_in_bytes == 16, \"unsupported\");\n+        __ neon_reverse_bits($dst$$FloatRegister, $src$$FloatRegister,\n+                             bt, \/* isQ *\/ length_in_bytes == 16);\n+      } else {\n+        __ sve_rbit($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                    ptrue, $src$$FloatRegister);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ The dst and src should use the same register to make sure the\n+\/\/ inactive lanes in dst save the same elements as src.\n+\n+instruct vreverse_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (ReverseV dst_src pg));\n+  format %{ \"vreverse_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_rbit($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ ReverseBytesV --------------------------------\n+\n+instruct vreverseBytes(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (ReverseBytesV src));\n+  format %{ \"vreverseBytes $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      assert(length_in_bytes == 8 || length_in_bytes == 16, \"unsupported\");\n+      if (bt == T_BYTE) {\n+        if ($dst$$FloatRegister != $src$$FloatRegister) {\n+          __ orr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+                 $src$$FloatRegister, $src$$FloatRegister);\n+        }\n+      } else {\n+        __ neon_reverse_bytes($dst$$FloatRegister, $src$$FloatRegister,\n+                              bt, \/* isQ *\/ length_in_bytes == 16);\n+      }\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      if (bt == T_BYTE) {\n+        if ($dst$$FloatRegister != $src$$FloatRegister) {\n+          __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+        }\n+      } else {\n+        __ sve_revb($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                    ptrue, $src$$FloatRegister);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ The dst and src should use the same register to make sure the\n+\/\/ inactive lanes in dst save the same elements as src.\n+instruct vreverseBytes_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (ReverseBytesV dst_src pg));\n+  format %{ \"vreverseBytes_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (bt == T_BYTE) {\n+      \/\/ do nothing\n+    } else {\n+      __ sve_revb($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  $pg$$PRegister, $dst_src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Populate Index to a Vector -------------------\n+\n+instruct populateindex(vReg dst, iRegIorL2I src1, immI src2) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (PopulateIndex src1 src2));\n+  format %{ \"populateindex $dst, $src1, $src2\\t # populate index (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_index($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 $src1$$Register, (int)($src2$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Compress\/Expand Operations -------------------\n+\n+instruct mcompress(pReg dst, pReg pg, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (CompressM pg));\n+  effect(KILL cr);\n+  format %{ \"mcompress $dst, $pg\\t# KILL cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_cntp(rscratch1, size, ptrue, $pg$$PRegister);\n+    __ sve_whilelo(as_PRegister($dst$$reg), size, zr, rscratch1);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcompress(vReg dst, vReg src, pRegGov pg) %{\n+  predicate(UseSVE > 0 &&\n+            !is_subword_type(Matcher::vector_element_basic_type(n)));\n+  match(Set dst (CompressV src pg));\n+  format %{ \"vcompress $dst, $src, $pg\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_compact($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                   $src$$FloatRegister, $pg$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcompressB(vReg dst, vReg src, pReg pg, vReg tmp1, vReg tmp2,\n+                    vReg tmp3, vReg tmp4, pReg ptmp, pRegGov pgtmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n) == T_BYTE);\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP ptmp, TEMP pgtmp);\n+  match(Set dst (CompressV src pg));\n+  format %{ \"vcompressB $dst, $src, $pg\\t# KILL $tmp1, $tmp2, $tmp3, tmp4, $ptmp, $pgtmp\" %}\n+  ins_encode %{\n+    __ sve_compress_byte($dst$$FloatRegister, $src$$FloatRegister, $pg$$PRegister,\n+                         $tmp1$$FloatRegister,$tmp2$$FloatRegister,\n+                         $tmp3$$FloatRegister,$tmp4$$FloatRegister,\n+                         $ptmp$$PRegister, $pgtmp$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcompressS(vReg dst, vReg src, pReg pg,\n+                    vReg tmp1, vReg tmp2, pRegGov pgtmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n) == T_SHORT);\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP pgtmp);\n+  match(Set dst (CompressV src pg));\n+  format %{ \"vcompressS $dst, $src, $pg\\t# KILL $tmp1, $tmp2, $pgtmp\" %}\n+  ins_encode %{\n+    __ sve_compress_short($dst$$FloatRegister, $src$$FloatRegister, $pg$$PRegister,\n+                          $tmp1$$FloatRegister,$tmp2$$FloatRegister, $pgtmp$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vexpand(vReg dst, vReg src, pRegGov pg) %{\n+  match(Set dst (ExpandV src pg));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vexpand $dst, $pg, $src\" %}\n+  ins_encode %{\n+    \/\/ Example input:   src   = 1 2 3 4 5 6 7 8\n+    \/\/                  pg    = 1 0 0 1 1 0 1 1\n+    \/\/ Expected result: dst   = 4 0 0 5 6 0 7 8\n+\n+    \/\/ The basic idea is to use TBL which can shuffle the elements in the given\n+    \/\/ vector flexibly. HISTCNT + SUB is used to generate the second source input\n+    \/\/ for TBL whose value is used to select the indexed element from src vector.\n+\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    assert(UseSVE == 2 && !is_subword_type(bt), \"unsupported\");\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    \/\/ dst = 0 0 0 0 0 0 0 0\n+    __ sve_dup($dst$$FloatRegister, size, 0);\n+    \/\/ dst = 5 0 0 4 3 0 2 1\n+    __ sve_histcnt($dst$$FloatRegister, size, $pg$$PRegister,\n+                   $dst$$FloatRegister, $dst$$FloatRegister);\n+    \/\/ dst = 4 -1 -1 3 2 -1 1 0\n+    __ sve_sub($dst$$FloatRegister, size, 1);\n+    \/\/ dst = 4 0 0 5 6 0 7 8\n+    __ sve_tbl($dst$$FloatRegister, size, $src$$FloatRegister, $dst$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector signum --------------------------------\n+\n+\/\/ Vector Math.signum\n+\n+instruct vsignum_le128b(vReg dst, vReg src, vReg zero, vReg one) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16);\n+  match(Set dst (SignumVF src (Binary zero one)));\n+  match(Set dst (SignumVD src (Binary zero one)));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vsignum_le128b $dst, $src\\t# vector <= 128 bits\" %}\n+  ins_encode %{\n+    __ vector_signum_neon($dst$$FloatRegister, $src$$FloatRegister, $zero$$FloatRegister,\n+                          $one$$FloatRegister, get_arrangement(this));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsignum_gt128b(vReg dst, vReg src, vReg zero, vReg one, vReg tmp, pRegGov pgtmp) %{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16);\n+  match(Set dst (SignumVF src (Binary zero one)));\n+  match(Set dst (SignumVD src (Binary zero one)));\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP pgtmp);\n+  format %{ \"vsignum_gt128b $dst, $src\\t# vector > 128 bits. KILL $tmp, $pgtmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vector_signum_sve($dst$$FloatRegister, $src$$FloatRegister, $zero$$FloatRegister,\n+                         $one$$FloatRegister, $tmp$$FloatRegister, $pgtmp$$PRegister,\n+                         __ elemType_to_regVariant(bt));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":6394,"deletions":0,"binary":false,"changes":6394,"status":"added"},{"patch":"@@ -0,0 +1,4734 @@\n+\/\/\n+\/\/ Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2020, 2022, Arm Limited. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\/\/\n+\n+dnl Generate the warning\n+\/\/ This file is automatically generated by running \"m4 aarch64_vector_ad.m4\". Do not edit!\n+dnl\n+\n+\/\/ AArch64 VECTOR Architecture Description File\n+\n+\n+dnl\n+dnl OPERAND_VMEMORYA_IMMEDIATE_OFFSET($1,            $2      )\n+dnl OPERAND_VMEMORYA_IMMEDIATE_OFFSET(imm_type_abbr, imm_type)\n+define(`OPERAND_VMEMORYA_IMMEDIATE_OFFSET', `\n+operand vmemA_imm$1Offset4() %{\n+  \/\/ (esize \/ msize) = 1\n+  predicate(Address::offset_ok_for_sve_immed(n->get_$2(), 4,\n+            Matcher::scalable_vector_reg_size(T_BYTE)));\n+  match(Con$1);\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}')dnl\n+dnl\n+dnl OPERAND_VMEMORYA_INDIRECT_OFFSET($1           )\n+dnl OPERAND_VMEMORYA_INDIRECT_OFFSET(imm_type_abbr)\n+define(`OPERAND_VMEMORYA_INDIRECT_OFFSET', `\n+operand vmemA_indOff$1`'4(iRegP reg, vmemA_imm$1Offset4 off) %{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP reg off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    `index'(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}')dnl\n+dnl\n+\/\/ 4 bit signed offset -- for predicated load\/store\n+OPERAND_VMEMORYA_IMMEDIATE_OFFSET(I, int)\n+OPERAND_VMEMORYA_IMMEDIATE_OFFSET(L, long)\n+OPERAND_VMEMORYA_INDIRECT_OFFSET(I)\n+OPERAND_VMEMORYA_INDIRECT_OFFSET(L)\n+\n+\/\/ The indOff of vmemA is valid only when the vector element (load to\/store from)\n+\/\/ size equals to memory element (load from\/store to) size.\n+opclass vmemA(indirect, vmemA_indOffI4, vmemA_indOffL4);\n+\n+source_hpp %{\n+  \/\/ Assert that the given node is not a variable shift.\n+  bool assert_not_var_shift(const Node* n);\n+\n+  Assembler::SIMD_Arrangement get_arrangement(const Node* n);\n+%}\n+\n+source %{\n+\n+  typedef void (C2_MacroAssembler::* sve_mem_insn_predicate)(FloatRegister Rt, Assembler::SIMD_RegVariant T,\n+                                                             PRegister Pg, const Address &adr);\n+\n+  \/\/ Predicated load\/store, with optional ptrue to all elements of given predicate register.\n+  static void loadStoreA_predicated(C2_MacroAssembler masm, bool is_store, FloatRegister reg,\n+                                    PRegister pg, BasicType mem_elem_bt, BasicType vector_elem_bt,\n+                                    int opcode, Register base, int index, int size, int disp) {\n+    sve_mem_insn_predicate insn;\n+    int mesize = type2aelembytes(mem_elem_bt);\n+    if (index == -1) {\n+      assert(size == 0, \"unsupported address mode: scale size = %d\", size);\n+      switch(mesize) {\n+      case 1:\n+        insn = is_store ? &C2_MacroAssembler::sve_st1b : &C2_MacroAssembler::sve_ld1b;\n+        break;\n+      case 2:\n+        insn = is_store ? &C2_MacroAssembler::sve_st1h : &C2_MacroAssembler::sve_ld1h;\n+        break;\n+      case 4:\n+        insn = is_store ? &C2_MacroAssembler::sve_st1w : &C2_MacroAssembler::sve_ld1w;\n+        break;\n+      case 8:\n+        insn = is_store ? &C2_MacroAssembler::sve_st1d : &C2_MacroAssembler::sve_ld1d;\n+        break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+      }\n+      int imm4 = disp \/ mesize \/ Matcher::scalable_vector_reg_size(vector_elem_bt);\n+      (masm.*insn)(reg, Assembler::elemType_to_regVariant(vector_elem_bt), pg, Address(base, imm4));\n+    } else {\n+      assert(false, \"unimplemented\");\n+      ShouldNotReachHere();\n+    }\n+  }\n+\n+  const bool Matcher::match_rule_supported_superword(int opcode, int vlen, BasicType bt) {\n+    if (UseSVE == 0) {\n+      \/\/ ConvD2I and ConvL2F are not profitable to be vectorized on NEON, because no direct\n+      \/\/ NEON instructions support them. But the match rule support for them is profitable for\n+      \/\/ Vector API intrinsics.\n+      if ((opcode == Op_VectorCastD2X && bt == T_INT) ||\n+          (opcode == Op_VectorCastL2X && bt == T_FLOAT)) {\n+        return false;\n+      }\n+    }\n+    return match_rule_supported_vector(opcode, vlen, bt);\n+  }\n+\n+  \/\/ Identify extra cases that we might want to provide match rules for vector nodes and\n+  \/\/ other intrinsics guarded with vector length (vlen) and element type (bt).\n+  const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {\n+    if (!match_rule_supported(opcode)) {\n+      return false;\n+    }\n+\n+    int length_in_bytes = vlen * type2aelembytes(bt);\n+    if (UseSVE == 0 && length_in_bytes > 16) {\n+      return false;\n+    }\n+\n+    \/\/ Check whether specific Op is supported.\n+    \/\/ Fail fast, otherwise fall through to common vector_size_supported() check.\n+    switch (opcode) {\n+      case Op_MulVL:\n+      case Op_AndVMask:\n+      case Op_OrVMask:\n+      case Op_XorVMask:\n+      case Op_MaskAll:\n+      case Op_VectorMaskGen:\n+      case Op_LoadVectorMasked:\n+      case Op_StoreVectorMasked:\n+      case Op_LoadVectorGather:\n+      case Op_StoreVectorScatter:\n+      case Op_LoadVectorGatherMasked:\n+      case Op_StoreVectorScatterMasked:\n+      case Op_PopulateIndex:\n+      case Op_CompressM:\n+      case Op_CompressV:\n+        if (UseSVE == 0) {\n+          return false;\n+        }\n+        break;\n+      case Op_MulAddVS2VI:\n+        if (length_in_bytes != 16) {\n+          return false;\n+        }\n+        break;\n+      case Op_MulReductionVD:\n+      case Op_MulReductionVF:\n+      case Op_MulReductionVI:\n+      case Op_MulReductionVL:\n+        \/\/ No vector multiply reduction instructions, but we do\n+        \/\/ emit scalar instructions for 64\/128-bit vectors.\n+        if (length_in_bytes != 8 && length_in_bytes != 16) {\n+          return false;\n+        }\n+        break;\n+      case Op_VectorMaskCmp:\n+        if (length_in_bytes < 8) {\n+          return false;\n+        }\n+        break;\n+      case Op_VectorLoadShuffle:\n+      case Op_VectorRearrange:\n+        if (vlen < 4) {\n+          return false;\n+        }\n+        break;\n+      case Op_ExpandV:\n+        if (UseSVE < 2 || is_subword_type(bt)) {\n+          return false;\n+        }\n+        break;\n+      case Op_VectorMaskToLong:\n+        if (UseSVE > 0 && vlen > 64) {\n+          return false;\n+        }\n+        break;\n+      case Op_VectorLongToMask:\n+        if (UseSVE < 2 || vlen > 64 || !VM_Version::supports_svebitperm()) {\n+          return false;\n+        }\n+        break;\n+      default:\n+        break;\n+    }\n+    return vector_size_supported(bt, vlen);\n+  }\n+\n+  const bool Matcher::match_rule_supported_vector_masked(int opcode, int vlen, BasicType bt) {\n+    \/\/ Only SVE supports masked operations.\n+    if (UseSVE == 0) {\n+      return false;\n+    }\n+\n+    \/\/ If an opcode does not support the masked version,\n+    \/\/ unpredicated node with VectorBlend node will be used instead.\n+    switch(opcode) {\n+      case Op_VectorRearrange:\n+      case Op_MulReductionVD:\n+      case Op_MulReductionVF:\n+      case Op_MulReductionVI:\n+      case Op_MulReductionVL:\n+        return false;\n+      \/\/ We use Op_LoadVectorMasked to implement the predicated Op_LoadVector.\n+      \/\/ Hence we turn to check whether Op_LoadVectorMasked is supported. The\n+      \/\/ same as vector store\/gather\/scatter.\n+      case Op_LoadVector:\n+        opcode = Op_LoadVectorMasked;\n+        break;\n+      case Op_StoreVector:\n+        opcode = Op_StoreVectorMasked;\n+        break;\n+      case Op_LoadVectorGather:\n+        opcode = Op_LoadVectorGatherMasked;\n+        break;\n+      case Op_StoreVectorScatter:\n+        opcode = Op_StoreVectorScatterMasked;\n+        break;\n+      default:\n+        break;\n+    }\n+\n+    return match_rule_supported_vector(opcode, vlen, bt);\n+  }\n+\n+  const bool Matcher::vector_needs_partial_operations(Node* node, const TypeVect* vt) {\n+    \/\/ Only SVE has partial vector operations\n+    if (UseSVE == 0) {\n+      return false;\n+    }\n+\n+    switch(node->Opcode()) {\n+      case Op_VectorLoadMask:\n+      case Op_VectorMaskCmp:\n+      case Op_LoadVectorGather:\n+      case Op_StoreVectorScatter:\n+      case Op_AddReductionVF:\n+      case Op_AddReductionVD:\n+      case Op_AndReductionV:\n+      case Op_OrReductionV:\n+      case Op_XorReductionV:\n+      \/\/ Mask is needed for partial Op_VectorMaskFirstTrue, because when the\n+      \/\/ input predicate is all-false, the result should be the vector length\n+      \/\/ instead of the vector register size.\n+      case Op_VectorMaskFirstTrue:\n+        return true;\n+      case Op_MaskAll:\n+        return !node->in(1)->is_Con();\n+      case Op_LoadVector:\n+      case Op_StoreVector:\n+        \/\/ We use NEON load\/store instructions if the vector length is <= 128 bits.\n+        return vt->length_in_bytes() > 16;\n+      case Op_AddReductionVI:\n+      case Op_AddReductionVL:\n+        \/\/ We may prefer using NEON instructions rather than SVE partial operations.\n+        return !VM_Version::use_neon_for_vector(vt->length_in_bytes());\n+      case Op_MinReductionV:\n+      case Op_MaxReductionV:\n+        \/\/ For BYTE\/SHORT\/INT\/FLOAT\/DOUBLE types, we may prefer using NEON\n+        \/\/ instructions rather than SVE partial operations.\n+        return vt->element_basic_type() == T_LONG ||\n+               !VM_Version::use_neon_for_vector(vt->length_in_bytes());\n+      default:\n+        \/\/ For other ops whose vector size is smaller than the max vector size, a\n+        \/\/ full-sized unpredicated operation does not impact the final vector result.\n+        return false;\n+    }\n+  }\n+\n+  \/\/ Assert that the given node is not a variable shift.\n+  bool assert_not_var_shift(const Node* n) {\n+    assert(!n->as_ShiftV()->is_var_shift(), \"illegal variable shift\");\n+    return true;\n+  }\n+\n+  Assembler::SIMD_Arrangement get_arrangement(const Node* n) {\n+    BasicType bt = Matcher::vector_element_basic_type(n);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(n);\n+    return Assembler::esize2arrangement((uint)type2aelembytes(bt),\n+                                        \/* isQ *\/ length_in_bytes == 16);\n+  }\n+%}\n+\n+\n+\/\/ All VECTOR instructions\n+\n+\/\/ ------------------------------ Vector load\/store ----------------------------\n+dnl\n+dnl VECTOR_LOAD_STORE($1,   $2,     $3,       $4,    $5  )\n+dnl VECTOR_LOAD_STORE(type, nbytes, arg_name, nbits, size)\n+define(`VECTOR_LOAD_STORE', `\n+\/\/ ifelse(load, $1, Load, Store) Vector ($4 bits)\n+instruct $1V$2(vReg $3, vmem$2 mem) %{\n+  predicate(`n->as_'ifelse(load, $1, Load, Store)Vector()->memory_size() == $2);\n+  match(Set ifelse(load, $1, dst (LoadVector mem), mem (StoreVector mem src)));\n+  format %{ \"$1V$2 ifelse(load, $1, `$dst, $mem', `$mem, $src')\\t# vector ($4 bits)\" %}\n+  ins_encode( `aarch64_enc_'ifelse(load, $1, ldr, str)v$5($3, mem) );\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+VECTOR_LOAD_STORE(load,  2,  dst, 16,  H)\n+VECTOR_LOAD_STORE(store, 2,  src, 16,  H)\n+VECTOR_LOAD_STORE(load,  4,  dst, 32,  S)\n+VECTOR_LOAD_STORE(store, 4,  src, 32,  S)\n+VECTOR_LOAD_STORE(load,  8,  dst, 64,  D)\n+VECTOR_LOAD_STORE(store, 8,  src, 64,  D)\n+VECTOR_LOAD_STORE(load,  16, dst, 128, Q)\n+VECTOR_LOAD_STORE(store, 16, src, 128, Q)\n+\n+\/\/ Load Vector (> 128 bits)\n+instruct loadV(vReg dst, vmemA mem) %{\n+  predicate(n->as_LoadVector()->memory_size() > 16);\n+  match(Set dst (LoadVector mem));\n+  format %{ \"loadV $dst, $mem\\t# vector (sve)\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), \/* is_store *\/ false,\n+                          $dst$$FloatRegister, ptrue, bt, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Store Vector (> 128 bits)\n+instruct storeV(vReg src, vmemA mem) %{\n+  predicate(n->as_StoreVector()->memory_size() > 16);\n+  match(Set mem (StoreVector mem src));\n+  format %{ \"storeV $mem, $src\\t# vector (sve)\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), \/* is_store *\/ true,\n+                          $src$$FloatRegister, ptrue, bt, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector load\/store - predicated\n+\n+instruct loadV_masked(vReg dst, vmemA mem, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (LoadVectorMasked mem pg));\n+  format %{ \"loadV_masked $dst, $pg, $mem\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), \/* is_store *\/ false, $dst$$FloatRegister,\n+                          $pg$$PRegister, bt, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct storeV_masked(vReg src, vmemA mem, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set mem (StoreVectorMasked mem (Binary src pg)));\n+  format %{ \"storeV_masked $mem, $pg, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), \/* is_store *\/ true, $src$$FloatRegister,\n+                          $pg$$PRegister, bt, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector load const\n+\n+instruct vloadconB(vReg dst, immI0 src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE);\n+  match(Set dst (VectorLoadConst src));\n+  format %{ \"vloadconB $dst, $src\\t# load\/generate iota indices\" %}\n+  ins_encode %{\n+    if (UseSVE == 0) {\n+      uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+      assert(length_in_bytes <= 16, \"must be\");\n+      __ lea(rscratch1, ExternalAddress(StubRoutines::aarch64::vector_iota_indices()));\n+      if (length_in_bytes == 16) {\n+        __ ldrq($dst$$FloatRegister, rscratch1);\n+      } else {\n+        __ ldrd($dst$$FloatRegister, rscratch1);\n+      }\n+    } else {\n+      __ sve_index($dst$$FloatRegister, __ B, 0, 1);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+dnl\n+dnl BINARY_OP($1,        $2,      $3,        $4,       $5  )\n+dnl BINARY_OP(rule_name, op_name, insn_neon, insn_sve, size)\n+define(`BINARY_OP', `\n+instruct $1(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst ($2 src1 src2));\n+  format %{ \"$1 $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ $3($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ $4($dst$$FloatRegister, __ $5, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl BINARY_OP_PREDICATE($1,        $2,      $3,   $4  )\n+dnl BINARY_OP_PREDICATE(rule_name, op_name, insn, size)\n+define(`BINARY_OP_PREDICATE', `\n+instruct $1_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 ($2 (Binary dst_src1 src2) pg));\n+  format %{ \"$1_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ $3($dst_src1$$FloatRegister, __ $4, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl VADD_IMM($1,   $2,       $3  )\n+dnl VADD_IMM(type, imm_type, size)\n+define(`VADD_IMM', `\n+instruct vaddImm$1(vReg dst_src, $2 con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AddV$1 dst_src (Replicate$1 con)));\n+  format %{ \"vaddImm$1 $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    int val = (int)$con$$constant;\n+    if (val > 0) {\n+      __ sve_add($dst_src$$FloatRegister, __ $3, val);\n+    } else {\n+      __ sve_sub($dst_src$$FloatRegister, __ $3, -val);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ ------------------------------ Vector add -----------------------------------\n+\n+\/\/ vector add\n+BINARY_OP(vaddB, AddVB, addv, sve_add,  B)\n+BINARY_OP(vaddS, AddVS, addv, sve_add,  H)\n+BINARY_OP(vaddI, AddVI, addv, sve_add,  S)\n+BINARY_OP(vaddL, AddVL, addv, sve_add,  D)\n+BINARY_OP(vaddF, AddVF, fadd, sve_fadd, S)\n+BINARY_OP(vaddD, AddVD, fadd, sve_fadd, D)\n+\n+\/\/ vector add - predicated\n+BINARY_OP_PREDICATE(vaddB, AddVB, sve_add,  B)\n+BINARY_OP_PREDICATE(vaddS, AddVS, sve_add,  H)\n+BINARY_OP_PREDICATE(vaddI, AddVI, sve_add,  S)\n+BINARY_OP_PREDICATE(vaddL, AddVL, sve_add,  D)\n+BINARY_OP_PREDICATE(vaddF, AddVF, sve_fadd, S)\n+BINARY_OP_PREDICATE(vaddD, AddVD, sve_fadd, D)\n+\n+\/\/ vector add reg imm (unpredicated)\n+VADD_IMM(B, immBAddSubV, B)\n+VADD_IMM(S, immIAddSubV, H)\n+VADD_IMM(I, immIAddSubV, S)\n+VADD_IMM(L, immLAddSubV, D)\n+\n+\/\/ ------------------------------ Vector sub -----------------------------------\n+\n+\/\/ vector sub\n+BINARY_OP(vsubB, SubVB, subv, sve_sub,  B)\n+BINARY_OP(vsubS, SubVS, subv, sve_sub,  H)\n+BINARY_OP(vsubI, SubVI, subv, sve_sub,  S)\n+BINARY_OP(vsubL, SubVL, subv, sve_sub,  D)\n+BINARY_OP(vsubF, SubVF, fsub, sve_fsub, S)\n+BINARY_OP(vsubD, SubVD, fsub, sve_fsub, D)\n+\n+\/\/ vector sub - predicated\n+BINARY_OP_PREDICATE(vsubB, SubVB, sve_sub,  B)\n+BINARY_OP_PREDICATE(vsubS, SubVS, sve_sub,  H)\n+BINARY_OP_PREDICATE(vsubI, SubVI, sve_sub,  S)\n+BINARY_OP_PREDICATE(vsubL, SubVL, sve_sub,  D)\n+BINARY_OP_PREDICATE(vsubF, SubVF, sve_fsub, S)\n+BINARY_OP_PREDICATE(vsubD, SubVD, sve_fsub, D)\n+\n+dnl\n+dnl BINARY_OP_NEON_SVE_PAIRWISE($1,        $2,      $3,        $4,       $5  )\n+dnl BINARY_OP_NEON_SVE_PAIRWISE(rule_name, op_name, insn_neon, insn_sve, size)\n+define(`BINARY_OP_NEON_SVE_PAIRWISE', `\n+instruct $1_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst ($2 src1 src2));\n+  format %{ \"$1_neon $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ $3($dst$$FloatRegister, get_arrangement(this),\n+            $src1$$FloatRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct $1_sve(vReg dst_src1, vReg src2) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 ($2 dst_src1 src2));\n+  format %{ \"$1_sve $dst_src1, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ $4($dst_src1$$FloatRegister, __ $5, ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ ------------------------------ Vector mul -----------------------------------\n+\n+\/\/ vector mul - BYTE, CHAR, SHORT, INT\n+BINARY_OP_NEON_SVE_PAIRWISE(vmulB, MulVB, mulv, sve_mul, B)\n+BINARY_OP_NEON_SVE_PAIRWISE(vmulS, MulVS, mulv, sve_mul, H)\n+BINARY_OP_NEON_SVE_PAIRWISE(vmulI, MulVI, mulv, sve_mul, S)\n+\n+\/\/ vector mul - LONG\n+\n+instruct vmulL_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (MulVL src1 src2));\n+  format %{ \"vmulL_neon $dst, $src1, $src2\\t# 2L\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == 16, \"must be\");\n+    __ umov(rscratch1, $src1$$FloatRegister, __ D, 0);\n+    __ umov(rscratch2, $src2$$FloatRegister, __ D, 0);\n+    __ mul(rscratch2, rscratch2, rscratch1);\n+    __ mov($dst$$FloatRegister, __ D, 0, rscratch2);\n+    __ umov(rscratch1, $src1$$FloatRegister, __ D, 1);\n+    __ umov(rscratch2, $src2$$FloatRegister, __ D, 1);\n+    __ mul(rscratch2, rscratch2, rscratch1);\n+    __ mov($dst$$FloatRegister, __ D, 1, rscratch2);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmulL_sve(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (MulVL dst_src1 src2));\n+  format %{ \"vmulL_sve $dst_src1, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_mul($dst_src1$$FloatRegister, __ D, ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector mul - floating-point\n+BINARY_OP(vmulF, MulVF, fmul, sve_fmul, S)\n+BINARY_OP(vmulD, MulVD, fmul, sve_fmul, D)\n+\n+\/\/ vector mul - predicated\n+BINARY_OP_PREDICATE(vmulB, MulVB, sve_mul,  B)\n+BINARY_OP_PREDICATE(vmulS, MulVS, sve_mul,  H)\n+BINARY_OP_PREDICATE(vmulI, MulVI, sve_mul,  S)\n+BINARY_OP_PREDICATE(vmulL, MulVL, sve_mul,  D)\n+BINARY_OP_PREDICATE(vmulF, MulVF, sve_fmul, S)\n+BINARY_OP_PREDICATE(vmulD, MulVD, sve_fmul, D)\n+\n+\/\/ ------------------------------ Vector float div -----------------------------\n+\n+\/\/ vector float div\n+BINARY_OP_NEON_SVE_PAIRWISE(vdivF, DivVF, fdiv, sve_fdiv, S)\n+BINARY_OP_NEON_SVE_PAIRWISE(vdivD, DivVD, fdiv, sve_fdiv, D)\n+\n+\/\/ vector float div - predicated\n+BINARY_OP_PREDICATE(vdivF, DivVF, sve_fdiv, S)\n+BINARY_OP_PREDICATE(vdivD, DivVD, sve_fdiv, D)\n+dnl\n+dnl BITWISE_OP($1,        $2,      $3,        $4      )\n+dnl BITWISE_OP(rule_name, op_name, insn_neon, insn_sve)\n+define(`BITWISE_OP', `\n+instruct $1(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst ($2 src1 src2));\n+  format %{ \"$1 $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ $3($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ $4($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl BITWISE_OP_PREDICATE($1,        $2,      $3  )\n+dnl BITWISE_OP_PREDICATE(rule_name, op_name, insn)\n+define(`BITWISE_OP_PREDICATE', `\n+instruct $1_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 ($2 (Binary dst_src1 src2) pg));\n+  format %{ \"$1_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ $3($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl BITWISE_OP_IMM($1,        $2,   $3,      $4,   $5  )\n+dnl BITWISE_OP_IMM(rule_name, type, op_name, insn, size)\n+define(`BITWISE_OP_IMM', `\n+instruct $1(vReg dst_src, imm$2Log con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src ($3 dst_src (Replicate$2 con)));\n+  format %{ \"$1 $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    __ $4($dst_src$$FloatRegister, __ $5, (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\n+\/\/ ------------------------------ Vector and -----------------------------------\n+\n+\/\/ vector and\n+BITWISE_OP(vand, AndV, andr, sve_and)\n+\n+\/\/ vector and - predicated\n+BITWISE_OP_PREDICATE(vand, AndV, sve_and)\n+\n+\/\/ vector and reg imm (unpredicated)\n+BITWISE_OP_IMM(vandImmB, B, AndV, sve_and, B)\n+BITWISE_OP_IMM(vandImmS, S, AndV, sve_and, H)\n+BITWISE_OP_IMM(vandImmI, I, AndV, sve_and, S)\n+BITWISE_OP_IMM(vandImmL, L, AndV, sve_and, D)\n+\n+\/\/ ------------------------------ Vector or ------------------------------------\n+\n+\/\/ vector or\n+BITWISE_OP(vor, OrV, orr, sve_orr)\n+\n+\/\/ vector or - predicated\n+BITWISE_OP_PREDICATE(vor, OrV, sve_orr)\n+\n+\/\/ vector or reg imm (unpredicated)\n+BITWISE_OP_IMM(vorImmB, B, OrV, sve_orr, B)\n+BITWISE_OP_IMM(vorImmS, S, OrV, sve_orr, H)\n+BITWISE_OP_IMM(vorImmI, I, OrV, sve_orr, S)\n+BITWISE_OP_IMM(vorImmL, L, OrV, sve_orr, D)\n+\n+\/\/ ------------------------------ Vector xor -----------------------------------\n+\n+\/\/ vector xor\n+BITWISE_OP(vxor, XorV, eor, sve_eor)\n+\n+\/\/ vector xor - predicated\n+BITWISE_OP_PREDICATE(vxor, XorV, sve_eor)\n+\n+\/\/ vector xor reg imm (unpredicated)\n+BITWISE_OP_IMM(vxorImmB, B, XorV, sve_eor, B)\n+BITWISE_OP_IMM(vxorImmS, S, XorV, sve_eor, H)\n+BITWISE_OP_IMM(vxorImmI, I, XorV, sve_eor, S)\n+BITWISE_OP_IMM(vxorImmL, L, XorV, sve_eor, D)\n+\n+\/\/ ------------------------------ Vector not -----------------------------------\n+\n+dnl\n+define(`MATCH_RULE', `ifelse($1, I,\n+`match(Set dst (XorV src (ReplicateB m1)));\n+  match(Set dst (XorV src (ReplicateS m1)));\n+  match(Set dst (XorV src (ReplicateI m1)));',\n+`match(Set dst (XorV src (ReplicateL m1)));')')dnl\n+dnl\n+dnl VECTOR_NOT($1  )\n+dnl VECTOR_NOT(type)\n+define(`VECTOR_NOT', `\n+instruct vnot$1`'(vReg dst, vReg src, imm$1_M1 m1) %{\n+  MATCH_RULE($1)\n+  format %{ \"vnot$1 $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ notr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+              $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_not($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector not\n+VECTOR_NOT(I)\n+VECTOR_NOT(L)\n+undefine(MATCH_RULE)\n+dnl\n+define(`MATCH_RULE', `ifelse($1, I,\n+`match(Set dst_src (XorV (Binary dst_src (ReplicateB m1)) pg));\n+  match(Set dst_src (XorV (Binary dst_src (ReplicateS m1)) pg));\n+  match(Set dst_src (XorV (Binary dst_src (ReplicateI m1)) pg));',\n+`match(Set dst_src (XorV (Binary dst_src (ReplicateL m1)) pg));')')dnl\n+dnl\n+dnl VECTOR_NOT_PREDICATE($1  )\n+dnl VECTOR_NOT_PREDICATE(type)\n+define(`VECTOR_NOT_PREDICATE', `\n+instruct vnot$1_masked`'(vReg dst_src, imm$1_M1 m1, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  MATCH_RULE($1)\n+  format %{ \"vnot$1_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_not($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector not - predicated\n+VECTOR_NOT_PREDICATE(I)\n+VECTOR_NOT_PREDICATE(L)\n+undefine(MATCH_RULE)\n+dnl\n+\/\/ ------------------------------ Vector and_not -------------------------------\n+\n+dnl\n+define(`MATCH_RULE', `ifelse($1, I,\n+`match(Set dst (AndV src1 (XorV src2 (ReplicateB m1))));\n+  match(Set dst (AndV src1 (XorV src2 (ReplicateS m1))));\n+  match(Set dst (AndV src1 (XorV src2 (ReplicateI m1))));',\n+`match(Set dst (AndV src1 (XorV src2 (ReplicateL m1))));')')dnl\n+dnl\n+dnl VECTOR_AND_NOT($1  )\n+dnl VECTOR_AND_NOT(type)\n+define(`VECTOR_AND_NOT', `\n+instruct vand_not$1`'(vReg dst, vReg src1, vReg src2, imm$1_M1 m1) %{\n+  MATCH_RULE($1)\n+  format %{ \"vand_not$1 $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ bic($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+             $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_bic($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector and_not\n+VECTOR_AND_NOT(I)\n+VECTOR_AND_NOT(L)\n+undefine(MATCH_RULE)\n+dnl\n+define(`MATCH_RULE', `ifelse($1, I,\n+`match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateB m1))) pg));\n+  match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateS m1))) pg));\n+  match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateI m1))) pg));',\n+`match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateL m1))) pg));')')dnl\n+dnl\n+dnl VECTOR_AND_NOT_PREDICATE($1  )\n+dnl VECTOR_AND_NOT_PREDICATE(type)\n+define(`VECTOR_AND_NOT_PREDICATE', `\n+instruct vand_not$1_masked`'(vReg dst_src1, vReg src2, imm$1_M1 m1, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  MATCH_RULE($1)\n+  format %{ \"vand_not$1_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_bic($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector and_not - predicated\n+VECTOR_AND_NOT_PREDICATE(I)\n+VECTOR_AND_NOT_PREDICATE(L)\n+undefine(MATCH_RULE)\n+dnl\n+dnl UNARY_OP($1,        $2,      $3,        $4,       $5  )\n+dnl UNARY_OP(rule_name, op_name, insn_neon, insn_sve, size)\n+define(`UNARY_OP', `\n+instruct $1(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst ($2 src));\n+  format %{ \"$1 $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ $3($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ $4($dst$$FloatRegister, __ $5, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl UNARY_OP_PREDICATE($1,        $2,      $3  )\n+dnl UNARY_OP_PREDICATE(rule_name, op_name, insn)\n+define(`UNARY_OP_PREDICATE', `\n+instruct $1_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src ($2 dst_src pg));\n+  format %{ \"$1_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ $3($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl UNARY_OP_PREDICATE_WITH_SIZE($1,        $2,      $3,   $4  )\n+dnl UNARY_OP_PREDICATE_WITH_SIZE(rule_name, op_name, insn, size)\n+define(`UNARY_OP_PREDICATE_WITH_SIZE', `\n+instruct $1_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src ($2 dst_src pg));\n+  format %{ \"$1_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    __ $3($dst_src$$FloatRegister, __ $4, $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ ------------------------------ Vector abs -----------------------------------\n+\n+\/\/ vector abs\n+UNARY_OP(vabsB, AbsVB, absr, sve_abs,  B)\n+UNARY_OP(vabsS, AbsVS, absr, sve_abs,  H)\n+UNARY_OP(vabsI, AbsVI, absr, sve_abs,  S)\n+UNARY_OP(vabsL, AbsVL, absr, sve_abs,  D)\n+UNARY_OP(vabsF, AbsVF, fabs, sve_fabs, S)\n+UNARY_OP(vabsD, AbsVD, fabs, sve_fabs, D)\n+\n+\/\/ vector abs - predicated\n+UNARY_OP_PREDICATE_WITH_SIZE(vabsB, AbsVB, sve_abs,  B)\n+UNARY_OP_PREDICATE_WITH_SIZE(vabsS, AbsVS, sve_abs,  H)\n+UNARY_OP_PREDICATE_WITH_SIZE(vabsI, AbsVI, sve_abs,  S)\n+UNARY_OP_PREDICATE_WITH_SIZE(vabsL, AbsVL, sve_abs,  D)\n+UNARY_OP_PREDICATE_WITH_SIZE(vabsF, AbsVF, sve_fabs, S)\n+UNARY_OP_PREDICATE_WITH_SIZE(vabsD, AbsVD, sve_fabs, D)\n+\n+\/\/ ------------------------------ Vector fabd ----------------------------------\n+\n+\/\/ vector fabs diff\n+\n+instruct vfabd(vReg dst, vReg src1, vReg src2) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16);\n+  match(Set dst (AbsVF (SubVF src1 src2)));\n+  match(Set dst (AbsVD (SubVD src1 src2)));\n+  format %{ \"vfabd $dst, $src1, $src2\\t# vector <= 128 bits\" %}\n+  ins_encode %{\n+    __ fabd($dst$$FloatRegister, get_arrangement(this),\n+            $src1$$FloatRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector neg -----------------------------------\n+\n+\/\/ vector neg\n+\n+instruct vnegI(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (NegVI src));\n+  format %{ \"vnegI $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ negr($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      BasicType bt = Matcher::vector_element_basic_type(this);\n+      __ sve_neg($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+UNARY_OP(vnegL, NegVL, negr, sve_neg,  D)\n+UNARY_OP(vnegF, NegVF, fneg, sve_fneg, S)\n+UNARY_OP(vnegD, NegVD, fneg, sve_fneg, D)\n+\n+\/\/ vector neg - predicated\n+UNARY_OP_PREDICATE(vnegI, NegVI, sve_neg)\n+UNARY_OP_PREDICATE_WITH_SIZE(vnegL, NegVL, sve_neg,  D)\n+UNARY_OP_PREDICATE_WITH_SIZE(vnegF, NegVF, sve_fneg, S)\n+UNARY_OP_PREDICATE_WITH_SIZE(vnegD, NegVD, sve_fneg, D)\n+\n+\/\/ ------------------------------ Vector sqrt ----------------------------------\n+\n+\/\/ vector sqrt\n+UNARY_OP(vsqrtF, SqrtVF, fsqrt, sve_fsqrt, S)\n+UNARY_OP(vsqrtD, SqrtVD, fsqrt, sve_fsqrt, D)\n+\n+\/\/ vector sqrt - predicated\n+UNARY_OP_PREDICATE_WITH_SIZE(vsqrtF, SqrtVF, sve_fsqrt, S)\n+UNARY_OP_PREDICATE_WITH_SIZE(vsqrtD, SqrtVD, sve_fsqrt, D)\n+\n+dnl\n+dnl VMINMAX_L_NEON($1,   $2     )\n+dnl VMINMAX_L_NEON(type, op_name)\n+define(`VMINMAX_L_NEON', `\n+instruct v$1L_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst ($2 src1 src2));\n+  effect(TEMP_DEF dst);\n+  format %{ \"v$1L_neon $dst, $src1, $src2\\t# 2L\" %}\n+  ins_encode %{\n+    __ cmgt($dst$$FloatRegister, __ T2D, $src1$$FloatRegister, $src2$$FloatRegister);\n+    __ bsl($dst$$FloatRegister, __ T16B, ifelse(min, $1, $src2, $src1)$$FloatRegister, ifelse(min, $1, $src1, $src2)$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl VMINMAX_L_SVE($1,   $2,      $3  )\n+dnl VMINMAX_L_SVE(type, op_name, insn)\n+define(`VMINMAX_L_SVE', `\n+instruct v$1L_sve(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst_src1 ($2 dst_src1 src2));\n+  format %{ \"v$1L_sve $dst_src1, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ $3($dst_src1$$FloatRegister, __ D, ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl VMINMAX_NEON($1,   $2,      $3,      $4           )\n+dnl VMINMAX_NEON(type, op_name, insn_fp, insn_integral)\n+define(`VMINMAX_NEON', `\n+instruct v$1_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(Matcher::vector_element_basic_type(n) != T_LONG &&\n+            VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst ($2 src1 src2));\n+  format %{ \"v$1_neon $dst, $src1, $src2\\t# B\/S\/I\/F\/D\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(bt)) {\n+      __ $3($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(is_integral_type(bt) && bt != T_LONG, \"unsupported type\");\n+      __ $4($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl VMINMAX_SVE($1,   $2,      $3,      $4           )\n+dnl VMINMAX_SVE(type, op_name, insn_fp, insn_integral)\n+define(`VMINMAX_SVE', `\n+instruct v$1_sve(vReg dst_src1, vReg src2) %{\n+  predicate(Matcher::vector_element_basic_type(n) != T_LONG &&\n+            !VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 ($2 dst_src1 src2));\n+  format %{ \"v$1_sve $dst_src1, $dst_src1, $src2\\t# B\/S\/I\/F\/D\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(bt)) {\n+      __ $3($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  ptrue, $src2$$FloatRegister);\n+    } else {\n+      assert(is_integral_type(bt) && bt != T_LONG, \"unsupported type\");\n+      __ $4($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  ptrue, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl VMINMAX_PREDICATE($1,   $2,      $3,      $4           )\n+dnl VMINMAX_PREDICATE(type, op_name, insn_fp, insn_integral)\n+define(`VMINMAX_PREDICATE', `\n+instruct v$1_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 ($2 (Binary dst_src1 src2) pg));\n+  format %{ \"v$1_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(bt)) {\n+      __ $3($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  $pg$$PRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(is_integral_type(bt), \"unsupported type\");\n+      __ $4($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  $pg$$PRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ ------------------------------ Vector min -----------------------------------\n+\n+\/\/ vector min - LONG\n+VMINMAX_L_NEON(min, MinV)\n+VMINMAX_L_SVE(min, MinV, sve_smin)\n+\n+\/\/ vector min - B\/S\/I\/F\/D\n+VMINMAX_NEON(min, MinV, fmin, minv)\n+VMINMAX_SVE(min, MinV, sve_fmin, sve_smin)\n+\n+\/\/ vector min - predicated\n+VMINMAX_PREDICATE(min, MinV, sve_fmin, sve_smin)\n+\n+\/\/ ------------------------------ Vector max -----------------------------------\n+\n+\/\/ vector max - LONG\n+VMINMAX_L_NEON(max, MaxV)\n+VMINMAX_L_SVE(max, MaxV, sve_smax)\n+\n+\/\/ vector max - B\/S\/I\/F\/D\n+VMINMAX_NEON(max, MaxV, fmax, maxv)\n+VMINMAX_SVE(max, MaxV, sve_fmax, sve_smax)\n+\n+\/\/ vector max - predicated\n+VMINMAX_PREDICATE(max, MaxV, sve_fmax, sve_smax)\n+\n+\/\/ ------------------------------ MLA RELATED ----------------------------------\n+\n+\/\/ vector mla\n+\/\/ dst_src1 = dst_src1 + src2 * src3\n+\n+instruct vmla(vReg dst_src1, vReg src2, vReg src3) %{\n+  match(Set dst_src1 (AddVB dst_src1 (MulVB src2 src3)));\n+  match(Set dst_src1 (AddVS dst_src1 (MulVS src2 src3)));\n+  match(Set dst_src1 (AddVI dst_src1 (MulVI src2 src3)));\n+  match(Set dst_src1 (AddVL dst_src1 (MulVL src2 src3)));\n+  format %{ \"vmla $dst_src1, src2, src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes) && bt != T_LONG) {\n+      \/\/ NEON mlav does not accept T2D arrangement.\n+      __ mlav($dst_src1$$FloatRegister, get_arrangement(this),\n+              $src2$$FloatRegister, $src3$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_mla($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 ptrue, $src2$$FloatRegister, $src3$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmla_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddVB (Binary dst_src1 (MulVB src2 src3)) pg));\n+  match(Set dst_src1 (AddVS (Binary dst_src1 (MulVS src2 src3)) pg));\n+  match(Set dst_src1 (AddVI (Binary dst_src1 (MulVI src2 src3)) pg));\n+  match(Set dst_src1 (AddVL (Binary dst_src1 (MulVL src2 src3)) pg));\n+  format %{ \"vmla_masked $dst_src1, $pg, src2, src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_mla($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fmla\n+\/\/ dst_src1 = dst_src1 + src2 * src3\n+\n+instruct vfmla(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA);\n+  match(Set dst_src1 (FmaVF dst_src1 (Binary src2 src3)));\n+  match(Set dst_src1 (FmaVD dst_src1 (Binary src2 src3)));\n+  format %{ \"vfmla $dst_src1, $src2, $src3\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fmla($dst_src1$$FloatRegister, get_arrangement(this),\n+              $src2$$FloatRegister, $src3$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      BasicType bt = Matcher::vector_element_basic_type(this);\n+      __ sve_fmla($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  ptrue, $src2$$FloatRegister, $src3$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fmad - predicated\n+\/\/ dst_src1 = dst_src1 * src2 + src3\n+\n+instruct vfmad_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n+  predicate(UseFMA && UseSVE > 0);\n+  match(Set dst_src1 (FmaVF (Binary dst_src1 src2) (Binary src3 pg)));\n+  match(Set dst_src1 (FmaVD (Binary dst_src1 src2) (Binary src3 pg)));\n+  format %{ \"vfmad_masked $dst_src1, $pg, $src2, $src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fmad($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                $pg$$PRegister, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector mls\n+\/\/ dst_src1 = dst_src1 - src2 * src3\n+\n+instruct vmls(vReg dst_src1, vReg src2, vReg src3) %{\n+  match(Set dst_src1 (SubVB dst_src1 (MulVB src2 src3)));\n+  match(Set dst_src1 (SubVS dst_src1 (MulVS src2 src3)));\n+  match(Set dst_src1 (SubVI dst_src1 (MulVI src2 src3)));\n+  match(Set dst_src1 (SubVL dst_src1 (MulVL src2 src3)));\n+  format %{ \"vmls $dst_src1, src2, src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes) && bt != T_LONG) {\n+      \/\/ NEON mlsv does not accept T2D arrangement.\n+      __ mlsv($dst_src1$$FloatRegister, get_arrangement(this),\n+              $src2$$FloatRegister, $src3$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_mls($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 ptrue, $src2$$FloatRegister, $src3$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmls_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (SubVB (Binary dst_src1 (MulVB src2 src3)) pg));\n+  match(Set dst_src1 (SubVS (Binary dst_src1 (MulVS src2 src3)) pg));\n+  match(Set dst_src1 (SubVI (Binary dst_src1 (MulVI src2 src3)) pg));\n+  match(Set dst_src1 (SubVL (Binary dst_src1 (MulVL src2 src3)) pg));\n+  format %{ \"vmls_masked $dst_src1, $pg, src2, src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_mls($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fmls\n+\n+\/\/ dst_src1 = dst_src1 + -src2 * src3\n+\/\/ The NegVF\/NegVD must not be predicated.\n+instruct vfmls1(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVF dst_src1 (Binary (NegVF src2) src3)));\n+  match(Set dst_src1 (FmaVD dst_src1 (Binary (NegVD src2) src3)));\n+  format %{ \"vfmls1 $dst_src1, $src2, $src3\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fmls($dst_src1$$FloatRegister, get_arrangement(this),\n+              $src2$$FloatRegister, $src3$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      BasicType bt = Matcher::vector_element_basic_type(this);\n+      __ sve_fmls($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  ptrue, $src2$$FloatRegister, $src3$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = dst_src1 + src2 * -src3\n+\/\/ The NegVF\/NegVD must not be predicated.\n+instruct vfmls2(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && !n->in(2)->in(2)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVF dst_src1 (Binary src2 (NegVF src3))));\n+  match(Set dst_src1 (FmaVD dst_src1 (Binary src2 (NegVD src3))));\n+  format %{ \"vfmls2 $dst_src1, $src2, $src3\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fmls($dst_src1$$FloatRegister, get_arrangement(this),\n+              $src2$$FloatRegister, $src3$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      BasicType bt = Matcher::vector_element_basic_type(this);\n+      __ sve_fmls($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  ptrue, $src2$$FloatRegister, $src3$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fmsb - predicated\n+\n+\/\/ dst_src1 = dst_src1 * -src2 + src3\n+\/\/ The NegVF\/NegVD must not be predicated.\n+instruct vfmsb_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(1)->in(2)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVF (Binary dst_src1 (NegVF src2)) (Binary src3 pg)));\n+  match(Set dst_src1 (FmaVD (Binary dst_src1 (NegVD src2)) (Binary src3 pg)));\n+  format %{ \"vfmsb_masked $dst_src1, $pg, $src2, $src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fmsb($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                $pg$$PRegister, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fnmla (sve)\n+\n+\/\/ dst_src1 = -dst_src1 + -src2 * src3\n+\/\/ The NegVF\/NegVD must not be predicated.\n+instruct vfnmla1(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(1)->as_Vector()->is_predicated_vector() &&\n+            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVF (NegVF dst_src1) (Binary (NegVF src2) src3)));\n+  match(Set dst_src1 (FmaVD (NegVD dst_src1) (Binary (NegVD src2) src3)));\n+  format %{ \"vfnmla1 $dst_src1, $src2, $src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fnmla($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 ptrue, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = -dst_src1 + src2 * -src3\n+\/\/ The NegVF\/NegVD must not be predicated.\n+instruct vfnmla2(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(1)->as_Vector()->is_predicated_vector() &&\n+            !n->in(2)->in(2)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVF (NegVF dst_src1) (Binary src2 (NegVF src3))));\n+  match(Set dst_src1 (FmaVD (NegVD dst_src1) (Binary src2 (NegVD src3))));\n+  format %{ \"vfnmla2 $dst_src1, $src2, $src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fnmla($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 ptrue, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fnmad - predicated\n+\n+\/\/ dst_src1 = -src3 + dst_src1 * -src2\n+\/\/ The NegVF\/NegVD must not be predicated.\n+instruct vfnmad_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(1)->in(2)->as_Vector()->is_predicated_vector() &&\n+            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVF (Binary dst_src1 (NegVF src2)) (Binary (NegVF src3) pg)));\n+  match(Set dst_src1 (FmaVD (Binary dst_src1 (NegVD src2)) (Binary (NegVD src3) pg)));\n+  format %{ \"vfnmad_masked $dst_src1, $pg, $src2, $src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fnmad($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 $pg$$PRegister, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fnmls (sve)\n+\n+\/\/ dst_src1 = -dst_src1 + src2 * src3\n+\/\/ The NegVF\/NegVD must not be predicated.\n+instruct vfnmls(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(1)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVF (NegVF dst_src1) (Binary src2 src3)));\n+  match(Set dst_src1 (FmaVD (NegVD dst_src1) (Binary src2 src3)));\n+  format %{ \"vfnmls $dst_src1, $src2, $src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fnmls($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 ptrue, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fnmsb - predicated\n+\n+\/\/ dst_src1 = -src3 + dst_src1 * src2\n+\/\/ The NegVF\/NegVD must not be predicated.\n+instruct vfnmsb_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVF (Binary dst_src1 src2) (Binary (NegVF src3) pg)));\n+  match(Set dst_src1 (FmaVD (Binary dst_src1 src2) (Binary (NegVD src3) pg)));\n+  format %{ \"vfnmsb_masked $dst_src1, $pg, $src2, $src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fnmsb($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 $pg$$PRegister, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ MulAddVS2VI\n+\/\/ Vector Multiply-Add Shorts into Integer\n+\n+instruct vmuladdS2I(vReg dst, vReg src1, vReg src2, vReg tmp) %{\n+  predicate(Matcher::vector_length_in_bytes(n) == 16 &&\n+            Matcher::vector_element_basic_type(n->in(1)) == T_SHORT);\n+  match(Set dst (MulAddVS2VI src1 src2));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vmuladdS2I $dst, $src1, $src2\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ smullv($tmp$$FloatRegister, __ T4H, $src1$$FloatRegister, $src2$$FloatRegister);\n+    __ smullv($dst$$FloatRegister, __ T8H, $src1$$FloatRegister, $src2$$FloatRegister);\n+    __ addpv($dst$$FloatRegister, __ T4S, $tmp$$FloatRegister, $dst$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector shift ---------------------------------\n+\n+\/\/ Vector right shift in AArch64 ASIMD\n+\/\/\n+\/\/ Right shifts with vector shift count on AArch64 ASIMD are implemented\n+\/\/ as left shift by negative shift count.\n+\/\/ There are two cases for vector shift count.\n+\/\/\n+\/\/ Case 1: The vector shift count is from replication.\n+\/\/        |            |\n+\/\/    LoadVector  RShiftCntV\n+\/\/        |       \/\n+\/\/     RShiftVI\n+\/\/\n+\/\/ Case 2: The vector shift count is from loading.\n+\/\/ This case isn't supported by middle-end now. But it's supported by\n+\/\/ panama\/vectorIntrinsics(JEP 338: Vector API).\n+\/\/        |            |\n+\/\/    LoadVector  LoadVector\n+\/\/        |       \/\n+\/\/     RShiftVI\n+\/\/\n+\/\/ The negate is conducted in RShiftCntV rule for case 1, whereas it's done in\n+\/\/ RShiftV* rules for case 2. Because there exists an optimization opportunity\n+\/\/ for case 1, that is, multiple neg instructions in inner loop can be hoisted\n+\/\/ to outer loop and merged into one neg instruction.\n+\/\/\n+\/\/ Note that ShiftVNode::is_var_shift() indicates whether the vector shift\n+\/\/ count is a variable vector(case 2) or not(a vector generated by RShiftCntV,\n+\/\/ i.e. case 1).\n+\n+\/\/ vector shift count\n+\n+instruct vshiftcntL(vReg dst, iRegIorL2I cnt) %{\n+  match(Set dst (LShiftCntV cnt));\n+  format %{ \"vshiftcntL $dst, $cnt\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ dup($dst$$FloatRegister, get_arrangement(this), $cnt$$Register);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      BasicType bt = Matcher::vector_element_basic_type(this);\n+      __ sve_dup($dst$$FloatRegister, __ elemType_to_regVariant(bt), $cnt$$Register);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vshiftcntR(vReg dst, iRegIorL2I cnt) %{\n+  match(Set dst (RShiftCntV cnt));\n+  format %{ \"vshiftcntR $dst, $cnt\" %}\n+  ins_encode %{\n+    if (UseSVE == 0) {\n+      uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+      assert(length_in_bytes <= 16, \"must be\");\n+      __ negw(rscratch1, $cnt$$Register);\n+      __ dup($dst$$FloatRegister, get_arrangement(this), rscratch1);\n+    } else {\n+      BasicType bt = Matcher::vector_element_basic_type(this);\n+      __ sve_dup($dst$$FloatRegister, __ elemType_to_regVariant(bt), $cnt$$Register);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector shift left\n+\n+instruct vlsl_neon(vReg dst, vReg src, vReg shift) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (LShiftVB src shift));\n+  match(Set dst (LShiftVS src shift));\n+  match(Set dst (LShiftVI src shift));\n+  match(Set dst (LShiftVL src shift));\n+  format %{ \"vlsl_neon $dst, $src, $shift\" %}\n+  ins_encode %{\n+    __ sshl($dst$$FloatRegister, get_arrangement(this),\n+            $src$$FloatRegister, $shift$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsl_sve(vReg dst_src, vReg shift) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src (LShiftVB dst_src shift));\n+  match(Set dst_src (LShiftVS dst_src shift));\n+  match(Set dst_src (LShiftVI dst_src shift));\n+  match(Set dst_src (LShiftVL dst_src shift));\n+  format %{ \"vlsl_sve $dst_src, $dst_src, $shift\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_lsl($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+               ptrue, $shift$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+dnl\n+dnl VRSHIFT_NEON($1,   $2,      $3  )\n+dnl VRSHIFT_NEON(type, op_name, insn)\n+define(`VRSHIFT_NEON', `\n+instruct v$1_neon(vReg dst, vReg src, vReg shift) %{\n+  predicate(UseSVE == 0 && !n->as_ShiftV()->is_var_shift());\n+  match(Set dst ($2VB src shift));\n+  match(Set dst ($2VS src shift));\n+  match(Set dst ($2VI src shift));\n+  match(Set dst ($2VL src shift));\n+  format %{ \"v$1_neon $dst, $src, $shift\\t# not variable shift\" %}\n+  ins_encode %{\n+    __ $3($dst$$FloatRegister, get_arrangement(this),\n+            $src$$FloatRegister, $shift$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl VRSHIFT_NEON_VAR($1,   $2,      $3  )\n+dnl VRSHIFT_NEON_VAR(type, op_name, insn)\n+define(`VRSHIFT_NEON_VAR', `\n+instruct v$1_neon_var(vReg dst, vReg src, vReg shift) %{\n+  predicate(UseSVE == 0 && n->as_ShiftV()->is_var_shift());\n+  match(Set dst ($2VB src shift));\n+  match(Set dst ($2VS src shift));\n+  match(Set dst ($2VI src shift));\n+  match(Set dst ($2VL src shift));\n+  effect(TEMP_DEF dst);\n+  format %{ \"v$1_neon_var $dst, $src, $shift\\t# variable shift\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ negr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+            $shift$$FloatRegister);\n+    __ $3($dst$$FloatRegister, get_arrangement(this),\n+            $src$$FloatRegister, $dst$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl VRSHIFT_SVE($1,   $2,      $3  )\n+dnl VRSHIFT_SVE(type, op_name, insn)\n+define(`VRSHIFT_SVE', `\n+instruct v$1_sve(vReg dst_src, vReg shift) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src ($2VB dst_src shift));\n+  match(Set dst_src ($2VS dst_src shift));\n+  match(Set dst_src ($2VI dst_src shift));\n+  match(Set dst_src ($2VL dst_src shift));\n+  format %{ \"v$1_sve $dst_src, $dst_src, $shift\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ $3($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+               ptrue, $shift$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector shift right (arithmetic)\n+VRSHIFT_NEON(asr, RShift, sshl)\n+VRSHIFT_NEON_VAR(asr, RShift, sshl)\n+VRSHIFT_SVE(asr, RShift, sve_asr)\n+\n+\/\/ vector shift right (logical)\n+VRSHIFT_NEON(lsr, URShift, ushl)\n+VRSHIFT_NEON_VAR(lsr, URShift, ushl)\n+VRSHIFT_SVE(lsr, URShift, sve_lsr)\n+\n+\/\/ vector shift with imm\n+\n+instruct vlsl_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(assert_not_var_shift(n));\n+  match(Set dst (LShiftVB src (LShiftCntV shift)));\n+  match(Set dst (LShiftVS src (LShiftCntV shift)));\n+  match(Set dst (LShiftVI src (LShiftCntV shift)));\n+  match(Set dst (LShiftVL src (LShiftCntV shift)));\n+  format %{ \"vlsl_imm $dst, $src, $shift\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    int con = (int)$shift$$constant;\n+    if (is_subword_type(bt)) {\n+      \/\/ Optimize for B\/S\n+      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;\n+      if (con >= esize_in_bits) {\n+        if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+          __ eor($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+                 $src$$FloatRegister, $src$$FloatRegister);\n+        } else {\n+          assert(UseSVE > 0, \"must be sve\");\n+          __ sve_eor($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+        }\n+        return;\n+      }\n+    }\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ shl($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister, con);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_lsl($dst$$FloatRegister, __ elemType_to_regVariant(bt), $src$$FloatRegister, con);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasr_imm(vReg dst, vReg src, immI_positive shift) %{\n+  predicate(assert_not_var_shift(n));\n+  match(Set dst (RShiftVB src (RShiftCntV shift)));\n+  match(Set dst (RShiftVS src (RShiftCntV shift)));\n+  match(Set dst (RShiftVI src (RShiftCntV shift)));\n+  match(Set dst (RShiftVL src (RShiftCntV shift)));\n+  format %{ \"vasr_imm $dst, $src, $shift\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    int con = (int)$shift$$constant;\n+    if (is_subword_type(bt)) {\n+      \/\/ Refine con for B\/S\n+      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;\n+      if (con >= esize_in_bits) con = esize_in_bits - 1;\n+    }\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ sshr($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister, con);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_asr($dst$$FloatRegister, __ elemType_to_regVariant(bt), $src$$FloatRegister, con);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsr_imm(vReg dst, vReg src, immI_positive shift) %{\n+  predicate(assert_not_var_shift(n));\n+  match(Set dst (URShiftVB src (RShiftCntV shift)));\n+  match(Set dst (URShiftVS src (RShiftCntV shift)));\n+  match(Set dst (URShiftVI src (RShiftCntV shift)));\n+  match(Set dst (URShiftVL src (RShiftCntV shift)));\n+  format %{ \"vlsr_imm $dst, $src, $shift\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    int con = (int)$shift$$constant;\n+    if (is_subword_type(bt)) {\n+      \/\/ Optimize for B\/S\n+      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;\n+      if (con >= esize_in_bits) {\n+        if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+          __ eor($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+                 $src$$FloatRegister, $src$$FloatRegister);\n+        } else {\n+          assert(UseSVE > 0, \"must be sve\");\n+          __ sve_eor($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+        }\n+        return;\n+      }\n+    }\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ ushr($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister, con);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_lsr($dst$$FloatRegister, __ elemType_to_regVariant(bt), $src$$FloatRegister, con);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ shift right add with imm (vector length <= 128 bits only)\n+\n+instruct vasra_imm(vReg dst, vReg src, immI_positive shift) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16);\n+  match(Set dst (AddVB dst (RShiftVB src (RShiftCntV shift))));\n+  match(Set dst (AddVS dst (RShiftVS src (RShiftCntV shift))));\n+  match(Set dst (AddVI dst (RShiftVI src (RShiftCntV shift))));\n+  match(Set dst (AddVL dst (RShiftVL src (RShiftCntV shift))));\n+  format %{ \"vasra_imm $dst, $src, $shift\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int con = (int)$shift$$constant;\n+    if (is_subword_type(bt)) {\n+      \/\/ Refine con for B\/S\n+      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;\n+      if (con >= esize_in_bits) con = esize_in_bits - 1;\n+    }\n+    __ ssra($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister, con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsra_imm(vReg dst, vReg src, immI_positive shift) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16);\n+  match(Set dst (AddVB dst (URShiftVB src (RShiftCntV shift))));\n+  match(Set dst (AddVS dst (URShiftVS src (RShiftCntV shift))));\n+  match(Set dst (AddVI dst (URShiftVI src (RShiftCntV shift))));\n+  match(Set dst (AddVL dst (URShiftVL src (RShiftCntV shift))));\n+  format %{ \"vlsra_imm $dst, $src, $shift\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int con = (int)$shift$$constant;\n+    if (is_subword_type(bt)) { \/\/ for B\/H\n+      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;\n+      if (con < esize_in_bits) {\n+        __ usra($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister, con);\n+      }\n+    } else { \/\/ for S\/D\n+      assert(type2aelembytes(bt) == 4 || type2aelembytes(bt) == 8, \"unsupported type\");\n+      __ usra($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister, con);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+dnl\n+dnl VSHIFT_PREDICATE($1,   $2,      $3  )\n+dnl VSHIFT_PREDICATE(type, op_name, insn)\n+define(`VSHIFT_PREDICATE', `\n+instruct v$1_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 ($2VB (Binary dst_src1 src2) pg));\n+  match(Set dst_src1 ($2VS (Binary dst_src1 src2) pg));\n+  match(Set dst_src1 ($2VI (Binary dst_src1 src2) pg));\n+  match(Set dst_src1 ($2VL (Binary dst_src1 src2) pg));\n+  format %{ \"v$1_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ $3($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl VSHIFT_IMM_PREDICATE($1,   $2,       $3,       $4,       $5  )\n+dnl VSHIFT_IMM_PREDICATE(type, arg_type, op_name1, op_name2, insn)\n+define(`VSHIFT_IMM_PREDICATE', `\n+instruct v$1_imm_masked(vReg dst_src, $2 shift, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src ($3VB (Binary dst_src ($4 shift)) pg));\n+  match(Set dst_src ($3VS (Binary dst_src ($4 shift)) pg));\n+  match(Set dst_src ($3VI (Binary dst_src ($4 shift)) pg));\n+  match(Set dst_src ($3VL (Binary dst_src ($4 shift)) pg));\n+  format %{ \"v$1_imm_masked $dst_src, $pg, $dst_src, $shift\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int esize_in_bits = type2aelembytes(bt) * BitsPerByte;\n+    int con = (int)$shift$$constant;\n+    assert(con ifelse($1, lsl, >=, >) 0 && con < esize_in_bits, \"invalid shift immediate\");\n+    __ $5($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector shift - predicated\n+VSHIFT_PREDICATE(lsl, LShift,  sve_lsl)\n+VSHIFT_PREDICATE(asr, RShift,  sve_asr)\n+VSHIFT_PREDICATE(lsr, URShift, sve_lsr)\n+\n+\/\/ vector shift with imm - predicated\n+VSHIFT_IMM_PREDICATE(lsl, immI,          LShift,  LShiftCntV, sve_lsl)\n+VSHIFT_IMM_PREDICATE(asr, immI_positive, RShift,  RShiftCntV, sve_asr)\n+VSHIFT_IMM_PREDICATE(lsr, immI_positive, URShift, RShiftCntV, sve_lsr)\n+\n+\/\/ ------------------------------ Vector reduction add -------------------------\n+\n+dnl\n+dnl REDUCE_ADD_INT_NEON_SVE_PAIRWISE($1,   $2      )\n+dnl REDUCE_ADD_INT_NEON_SVE_PAIRWISE(type, arg_type)\n+define(`REDUCE_ADD_INT_NEON_SVE_PAIRWISE', `\n+instruct reduce_add$1_neon(iReg$1NoSp dst, $2 isrc, vReg vsrc, vReg tmp) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(2))));\n+  match(Set dst (AddReductionV$1 isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_add$1_neon $dst, $isrc, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ neon_reduce_add_integral($dst$$Register, bt,\n+                                $isrc$$Register, $vsrc$$FloatRegister,\n+                                length_in_bytes, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_add$1_sve(iReg$1NoSp dst, $2 isrc, vReg vsrc, vRegD tmp) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(2))));\n+  match(Set dst (AddReductionV$1 isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_add$1_sve $dst, $isrc, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           ptrue, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ reduction addI\n+REDUCE_ADD_INT_NEON_SVE_PAIRWISE(I, iRegIorL2I)\n+\n+\/\/ reduction addL\n+REDUCE_ADD_INT_NEON_SVE_PAIRWISE(L, iRegL)\n+\n+\/\/ reduction addF\n+\n+instruct reduce_addF_neon(vRegF dst, vRegF fsrc, vReg vsrc, vReg tmp) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (AddReductionVF fsrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_addF_neon $dst, $fsrc, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ fadds($dst$$FloatRegister, $fsrc$$FloatRegister, $vsrc$$FloatRegister);\n+    __ ins($tmp$$FloatRegister, __ S, $vsrc$$FloatRegister, 0, 1);\n+    __ fadds($dst$$FloatRegister, $dst$$FloatRegister, $tmp$$FloatRegister);\n+    if (length_in_bytes == 16) {\n+      __ ins($tmp$$FloatRegister, __ S, $vsrc$$FloatRegister, 0, 2);\n+      __ fadds($dst$$FloatRegister, $dst$$FloatRegister, $tmp$$FloatRegister);\n+      __ ins($tmp$$FloatRegister, __ S, $vsrc$$FloatRegister, 0, 3);\n+      __ fadds($dst$$FloatRegister, $dst$$FloatRegister, $tmp$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+dnl\n+dnl REDUCE_ADD_FP_SVE($1,   $2  )\n+dnl REDUCE_ADD_FP_SVE(type, size)\n+define(`REDUCE_ADD_FP_SVE', `\n+instruct reduce_add$1_sve(vReg$1 dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddReductionV$1 dst_src1 src2));\n+  format %{ \"reduce_add$1_sve $dst_src1, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src2);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_fadda($dst_src1$$FloatRegister, __ $2, ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+REDUCE_ADD_FP_SVE(F, S)\n+\n+\/\/ reduction addD\n+\n+instruct reduce_addD_neon(vRegD dst, vRegD dsrc, vReg vsrc, vReg tmp) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (AddReductionVD dsrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_addD_neon $dst, $dsrc, $vsrc\\t# 2D. KILL $tmp\" %}\n+  ins_encode %{\n+    __ faddd($dst$$FloatRegister, $dsrc$$FloatRegister, $vsrc$$FloatRegister);\n+    __ ins($tmp$$FloatRegister, __ D, $vsrc$$FloatRegister, 0, 1);\n+    __ faddd($dst$$FloatRegister, $dst$$FloatRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+REDUCE_ADD_FP_SVE(D, D)\n+\n+\/\/ reduction add - predicated\n+dnl\n+dnl REDUCE_ADD_INT_PREDICATE($1,        $2     )\n+dnl REDUCE_ADD_INT_PREDICATE(insn_name, op_name)\n+define(`REDUCE_ADD_INT_PREDICATE', `\n+instruct reduce_add$1_masked(iReg$1NoSp dst, $2 isrc, vReg vsrc, pRegGov pg, vRegD tmp) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (AddReductionV$1 (Binary isrc vsrc) pg));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_add$1_masked $dst, $isrc, $pg, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           $pg$$PRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl REDUCE_ADD_FP_PREDICATE($1,        $2     )\n+dnl REDUCE_ADD_FP_PREDICATE(insn_name, op_name)\n+define(`REDUCE_ADD_FP_PREDICATE', `\n+instruct reduce_add$1_masked(vReg$1 dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddReductionV$1 (Binary dst_src1 src2) pg));\n+  format %{ \"reduce_add$1_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fadda($dst_src1$$FloatRegister, __ $2,\n+                 $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+REDUCE_ADD_INT_PREDICATE(I, iRegIorL2I)\n+REDUCE_ADD_INT_PREDICATE(L, iRegL)\n+REDUCE_ADD_FP_PREDICATE(F, S)\n+REDUCE_ADD_FP_PREDICATE(D, D)\n+\n+\/\/ ------------------------------ Vector reduction mul -------------------------\n+\n+instruct reduce_mulI(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc,\n+                     vReg tmp1, vReg tmp2) %{\n+  predicate(Matcher::vector_length_in_bytes(n->in(2)) == 8 ||\n+            Matcher::vector_length_in_bytes(n->in(2)) == 16);\n+  match(Set dst (MulReductionVI isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);\n+  format %{ \"reduce_mulI $dst, $isrc, $vsrc\\t# vector (64\/128 bits). KILL $tmp1, $tmp2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ neon_reduce_mul_integral($dst$$Register, bt, $isrc$$Register,\n+                                $vsrc$$FloatRegister, length_in_bytes,\n+                                $tmp1$$FloatRegister, $tmp2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_mulL(iRegLNoSp dst, iRegL isrc, vReg vsrc) %{\n+  predicate(Matcher::vector_length_in_bytes(n->in(2)) == 16);\n+  match(Set dst (MulReductionVL isrc vsrc));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_mulL $dst, $isrc, $vsrc\\t# 2L\" %}\n+  ins_encode %{\n+    __ neon_reduce_mul_integral($dst$$Register, T_LONG, $isrc$$Register,\n+                                $vsrc$$FloatRegister, 16, fnoreg, fnoreg);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_mulF(vRegF dst, vRegF fsrc, vReg vsrc, vReg tmp) %{\n+  predicate(Matcher::vector_length_in_bytes(n->in(2)) <= 16);\n+  match(Set dst (MulReductionVF fsrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_mulF $dst, $fsrc, $vsrc\\t# 2F\/4F. KILL $tmp\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ neon_reduce_mul_fp($dst$$FloatRegister, T_FLOAT, $fsrc$$FloatRegister,\n+                          $vsrc$$FloatRegister, length_in_bytes, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_mulD(vRegD dst, vRegD dsrc, vReg vsrc, vReg tmp) %{\n+  predicate(Matcher::vector_length_in_bytes(n->in(2)) == 16);\n+  match(Set dst (MulReductionVD dsrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_mulD $dst, $dsrc, $vsrc\\t# 2D. KILL $tmp\" %}\n+  ins_encode %{\n+    __ neon_reduce_mul_fp($dst$$FloatRegister, T_DOUBLE, $dsrc$$FloatRegister,\n+                          $vsrc$$FloatRegister, 16, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+dnl\n+dnl REDUCE_BITWISE_OP_NEON($1,        $2       $3    $4     )\n+dnl REDUCE_BITWISE_OP_NEON(insn_name, is_long, type, op_name)\n+define(`REDUCE_BITWISE_OP_NEON', `\n+instruct reduce_$1$2_neon(iReg$2NoSp dst, $3 isrc, vReg vsrc) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n->in(2)) ifelse($2, L, ==, !=) T_LONG);\n+  match(Set dst ($4 isrc vsrc));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_$1$2_neon $dst, $isrc, $vsrc\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ neon_reduce_logical(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl REDUCE_BITWISE_OP_SVE($1,        $2       $3    $4     )\n+dnl REDUCE_BITWISE_OP_SVE(insn_name, is_long, type, op_name)\n+define(`REDUCE_BITWISE_OP_SVE', `\n+instruct reduce_$1$2_sve(iReg$2NoSp dst, $3 isrc, vReg vsrc, vRegD tmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(2)) ifelse($2, L, ==, !=) T_LONG);\n+  match(Set dst ($4 isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_$1$2_sve $dst, $isrc, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           ptrue, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl REDUCE_BITWISE_OP_PREDICATE($1,        $2       $3    $4     )\n+dnl REDUCE_BITWISE_OP_PREDICATE(insn_name, is_long, type, op_name)\n+define(`REDUCE_BITWISE_OP_PREDICATE', `\n+instruct reduce_$1$2_masked(iReg$2NoSp dst, $3 isrc, vReg vsrc, pRegGov pg, vRegD tmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(1)->in(2)) ifelse($2, L, ==, !=) T_LONG);\n+  match(Set dst ($4 (Binary isrc vsrc) pg));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_$1$2_masked $dst, $isrc, $pg, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           $pg$$PRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ ------------------------------ Vector reduction and -------------------------\n+\n+\/\/ reduction andI\n+REDUCE_BITWISE_OP_NEON(and, I, iRegIorL2I, AndReductionV)\n+REDUCE_BITWISE_OP_SVE(and, I, iRegIorL2I, AndReductionV)\n+\n+\/\/ reduction andL\n+REDUCE_BITWISE_OP_NEON(and, L, iRegL, AndReductionV)\n+REDUCE_BITWISE_OP_SVE(and, L, iRegL, AndReductionV)\n+\n+\/\/ reduction and - predicated\n+REDUCE_BITWISE_OP_PREDICATE(and, I, iRegIorL2I, AndReductionV)\n+REDUCE_BITWISE_OP_PREDICATE(and, L, iRegL,      AndReductionV)\n+\n+\/\/ ------------------------------ Vector reduction or --------------------------\n+\n+\/\/ reduction orI\n+REDUCE_BITWISE_OP_NEON(or, I, iRegIorL2I, OrReductionV)\n+REDUCE_BITWISE_OP_SVE(or, I, iRegIorL2I, OrReductionV)\n+\n+\/\/ reduction orL\n+REDUCE_BITWISE_OP_NEON(or, L, iRegL, OrReductionV)\n+REDUCE_BITWISE_OP_SVE(or, L, iRegL, OrReductionV)\n+\n+\/\/ reduction or - predicated\n+REDUCE_BITWISE_OP_PREDICATE(or, I, iRegIorL2I, OrReductionV)\n+REDUCE_BITWISE_OP_PREDICATE(or, L, iRegL,      OrReductionV)\n+\n+\/\/ ------------------------------ Vector reduction xor -------------------------\n+\n+\/\/ reduction xorI\n+REDUCE_BITWISE_OP_NEON(xor, I, iRegIorL2I, XorReductionV)\n+REDUCE_BITWISE_OP_SVE(xor, I, iRegIorL2I, XorReductionV)\n+\n+\/\/ reduction xorL\n+REDUCE_BITWISE_OP_NEON(xor, L, iRegL, XorReductionV)\n+REDUCE_BITWISE_OP_SVE(xor, L, iRegL, XorReductionV)\n+\n+\/\/ reduction xor - predicated\n+REDUCE_BITWISE_OP_PREDICATE(xor, I, iRegIorL2I, XorReductionV)\n+REDUCE_BITWISE_OP_PREDICATE(xor, L, iRegL,      XorReductionV)\n+\n+dnl\n+dnl REDUCE_MAXMIN_I_NEON($1,   $2     )\n+dnl REDUCE_MAXMIN_I_NEON(type, op_name)\n+define(`REDUCE_MAXMIN_I_NEON', `\n+instruct reduce_$1I_neon(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc,\n+                          vReg tmp, rFlagsReg cr) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(2))) &&\n+            (Matcher::vector_element_basic_type(n->in(2)) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n->in(2)) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n->in(2)) == T_INT));\n+  match(Set dst ($2 isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n+  format %{ \"reduce_$1I_neon $dst, $isrc, $vsrc\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ neon_reduce_minmax_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                                   $isrc$$Register, $vsrc$$FloatRegister,\n+                                   length_in_bytes, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl REDUCE_MAXMIN_I_SVE($1,   $2     )\n+dnl REDUCE_MAXMIN_I_SVE(type, op_name)\n+define(`REDUCE_MAXMIN_I_SVE', `\n+instruct reduce_$1I_sve(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc,\n+                         vRegD tmp, rFlagsReg cr) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(2))) &&\n+            (Matcher::vector_element_basic_type(n->in(2)) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n->in(2)) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n->in(2)) == T_INT));\n+  match(Set dst ($2 isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n+  format %{ \"reduce_$1I_sve $dst, $isrc, $vsrc\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           ptrue, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl REDUCE_MAXMIN_L_NEON($1,   $2     )\n+dnl REDUCE_MAXMIN_L_NEON(type, op_name)\n+define(`REDUCE_MAXMIN_L_NEON', `\n+instruct reduce_$1L_neon(iRegLNoSp dst, iRegL isrc, vReg vsrc, rFlagsReg cr) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n->in(2)) == T_LONG);\n+  match(Set dst ($2 isrc vsrc));\n+  effect(TEMP_DEF dst, KILL cr);\n+  format %{ \"reduce_$1L_neon $dst, $isrc, $vsrc\\t# 2L. KILL cr\" %}\n+  ins_encode %{\n+    __ neon_reduce_minmax_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n+                                   $isrc$$Register, $vsrc$$FloatRegister,\n+                                   \/* vector_length_in_bytes *\/ 16, fnoreg);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl REDUCE_MAXMIN_L_SVE($1,   $2     )\n+dnl REDUCE_MAXMIN_L_SVE(type, op_name)\n+define(`REDUCE_MAXMIN_L_SVE', `\n+instruct reduce_$1L_sve(iRegLNoSp dst, iRegL isrc, vReg vsrc,\n+                         vRegD tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(2)) == T_LONG);\n+  match(Set dst ($2 isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n+  format %{ \"reduce_$1L_sve $dst, $isrc, $vsrc\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           ptrue, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl REDUCE_MAXMIN_F($1,   $2,      $3,    $4,    $5,    $6   )\n+dnl REDUCE_MAXMIN_F(type, op_name, insn1, insn2, insn3, insn4)\n+define(`REDUCE_MAXMIN_F', `\n+instruct reduce_$1F(vRegF dst, vRegF fsrc, vReg vsrc) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT);\n+  match(Set dst ($2 fsrc vsrc));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_$1F $dst, $fsrc, $vsrc\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      if (length_in_bytes == 8) {\n+        __ $3($dst$$FloatRegister, $vsrc$$FloatRegister, __ S);\n+      } else {\n+        __ $4($dst$$FloatRegister, __ T4S, $vsrc$$FloatRegister);\n+      }\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+      __ $5($dst$$FloatRegister, __ S, ptrue, $vsrc$$FloatRegister);\n+    }\n+    __ $6($dst$$FloatRegister, $dst$$FloatRegister, $fsrc$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl REDUCE_MAXMIN_D($1,   $2,      $3,    $4,    $5   )\n+dnl REDUCE_MAXMIN_D(type, op_name, insn1, insn2, insn3)\n+define(`REDUCE_MAXMIN_D', `\n+instruct reduce_$1D(vRegD dst, vRegD dsrc, vReg vsrc) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE);\n+  match(Set dst ($2 dsrc vsrc));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_$1D $dst, $dsrc, $vsrc\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ $3($dst$$FloatRegister, $vsrc$$FloatRegister, __ D);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+      __ $4($dst$$FloatRegister, __ D, ptrue, $vsrc$$FloatRegister);\n+    }\n+    __ $5($dst$$FloatRegister, $dst$$FloatRegister, $dsrc$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl REDUCE_MAXMIN_INT_PREDICATE($1,   $2,      $3,       $4     )\n+dnl REDUCE_MAXMIN_INT_PREDICATE(type, is_long, arg_type, op_name)\n+define(`REDUCE_MAXMIN_INT_PREDICATE', `\n+instruct reduce_$1$2_masked(iReg$2NoSp dst, $3 isrc, vReg vsrc, pRegGov pg,\n+                            vRegD tmp, rFlagsReg cr) %{\n+  ifelse($2, I,\n+       `predicate(UseSVE > 0 &&\n+            (Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_INT));',\n+       `predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_LONG);')\n+  match(Set dst ($4 (Binary isrc vsrc) pg));\n+  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n+  format %{ \"reduce_$1$2_masked $dst, $isrc, $pg, $vsrc\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           $pg$$PRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl REDUCE_MAXMIN_FP_PREDICATE($1,   $2,       $3,       $4,      $5,    $6   )\n+dnl REDUCE_MAXMIN_FP_PREDICATE(type, is_float, arg_name, op_name, insn1, insn2)\n+define(`REDUCE_MAXMIN_FP_PREDICATE', `\n+instruct reduce_$1$2_masked(vReg$2 dst, vReg$2 $3, vReg vsrc, pRegGov pg) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(1)->in(2)) == ifelse($2, F, T_FLOAT, T_DOUBLE));\n+  match(Set dst ($4 (Binary $3 vsrc) pg));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_$1$2_masked $dst, $$3, $pg, $vsrc\" %}\n+  ins_encode %{\n+    __ $5($dst$$FloatRegister, __ ifelse($2, F, S, D), $pg$$PRegister, $vsrc$$FloatRegister);\n+    __ $6($dst$$FloatRegister, $dst$$FloatRegister, $$3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ ------------------------------ Vector reduction max -------------------------\n+\n+\/\/ reduction maxI\n+REDUCE_MAXMIN_I_NEON(max, MaxReductionV)\n+REDUCE_MAXMIN_I_SVE(max, MaxReductionV)\n+\n+\/\/ reduction maxL\n+REDUCE_MAXMIN_L_NEON(max, MaxReductionV)\n+REDUCE_MAXMIN_L_SVE(max, MaxReductionV)\n+\n+\/\/ reduction maxF\n+REDUCE_MAXMIN_F(max, MaxReductionV, fmaxp, fmaxv, sve_fmaxv, fmaxs)\n+\n+\/\/ reduction maxD\n+REDUCE_MAXMIN_D(max, MaxReductionV, fmaxp, sve_fmaxv, fmaxd)\n+\n+\/\/ reduction max - predicated\n+REDUCE_MAXMIN_INT_PREDICATE(max, I, iRegIorL2I, MaxReductionV)\n+REDUCE_MAXMIN_INT_PREDICATE(max, L, iRegL,      MaxReductionV)\n+REDUCE_MAXMIN_FP_PREDICATE(max, F, fsrc, MaxReductionV, sve_fmaxv, fmaxs)\n+REDUCE_MAXMIN_FP_PREDICATE(max, D, dsrc, MaxReductionV, sve_fmaxv, fmaxd)\n+\n+\/\/ ------------------------------ Vector reduction min -------------------------\n+\n+\/\/ reduction minI\n+REDUCE_MAXMIN_I_NEON(min, MinReductionV)\n+REDUCE_MAXMIN_I_SVE(min, MinReductionV)\n+\n+\/\/ reduction minL\n+REDUCE_MAXMIN_L_NEON(min, MinReductionV)\n+REDUCE_MAXMIN_L_SVE(min, MinReductionV)\n+\n+\/\/ reduction minF\n+REDUCE_MAXMIN_F(min, MinReductionV, fminp, fminv, sve_fminv, fmins)\n+\n+\/\/ reduction minD\n+REDUCE_MAXMIN_D(min, MinReductionV, fminp, sve_fminv, fmind)\n+\n+\/\/ reduction min - predicated\n+REDUCE_MAXMIN_INT_PREDICATE(min, I, iRegIorL2I, MinReductionV)\n+REDUCE_MAXMIN_INT_PREDICATE(min, L, iRegL,      MinReductionV)\n+REDUCE_MAXMIN_FP_PREDICATE(min, F, fsrc, MinReductionV, sve_fminv, fmins)\n+REDUCE_MAXMIN_FP_PREDICATE(min, D, dsrc, MinReductionV, sve_fminv, fmind)\n+\n+\/\/ ------------------------------ Vector reinterpret ---------------------------\n+\n+instruct reinterpret_same_size(vReg dst_src) %{\n+  predicate(Matcher::vector_length_in_bytes(n) == Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst_src (VectorReinterpret dst_src));\n+  ins_cost(0);\n+  format %{ \"reinterpret_same_size $dst_src\\t# do nothing\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n+instruct reinterpret_resize_le128b(vReg dst, vReg src) %{\n+  predicate(Matcher::vector_length_in_bytes(n) != Matcher::vector_length_in_bytes(n->in(1)) &&\n+            Matcher::vector_length_in_bytes(n) <= 16 &&\n+            Matcher::vector_length_in_bytes(n->in(1)) <= 16);\n+  match(Set dst (VectorReinterpret src));\n+  format %{ \"reinterpret_resize_le128b $dst, $src\\t# vector <= 128 bits.\" %}\n+  ins_encode %{\n+    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, $src);\n+    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);\n+    \/\/ The higher bits in \"dst\" register must be cleared to zero.\n+    if ((length_in_bytes_src == 4 && length_in_bytes_dst == 8) ||\n+        (length_in_bytes_src == 8 && length_in_bytes_dst == 4)) {\n+      \/\/ Reinterpret between 32 bits and 64 bits\n+      __ dup($dst$$FloatRegister, __ S, $src$$FloatRegister);\n+    } else if ((length_in_bytes_src == 4 && length_in_bytes_dst == 16) ||\n+               (length_in_bytes_src == 16 && length_in_bytes_dst == 4)) {\n+      \/\/ Reinterpret between 32 bits and 128 bits\n+      __ dup($dst$$FloatRegister, __ S, $src$$FloatRegister);\n+    } else if ((length_in_bytes_src == 8 && length_in_bytes_dst == 16) ||\n+               (length_in_bytes_src == 16 && length_in_bytes_dst == 8)) {\n+      \/\/ Reinterpret between 64 bits and 128 bits\n+      __ orr($dst$$FloatRegister, __ T8B, $src$$FloatRegister, $src$$FloatRegister);\n+    } else {\n+      assert(false, \"invalid vector length\");\n+      ShouldNotReachHere();\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reinterpret_resize_gt128b(vReg dst, vReg src, pReg ptmp, rFlagsReg cr) %{\n+  predicate(Matcher::vector_length_in_bytes(n) != Matcher::vector_length_in_bytes(n->in(1)) &&\n+            (Matcher::vector_length_in_bytes(n) > 16 ||\n+             Matcher::vector_length_in_bytes(n->in(1)) > 16));\n+  match(Set dst (VectorReinterpret src));\n+  effect(TEMP_DEF dst, TEMP ptmp, KILL cr);\n+  format %{ \"reinterpret_resize_gt128b $dst, $src\\t# vector > 128 bits. KILL $ptmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, $src);\n+    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);\n+    uint length_in_bytes_resize = length_in_bytes_src < length_in_bytes_dst ?\n+                                  length_in_bytes_src : length_in_bytes_dst;\n+    assert(length_in_bytes_src <= MaxVectorSize && length_in_bytes_dst <= MaxVectorSize,\n+           \"invalid vector length\");\n+    __ sve_gen_mask_imm($ptmp$$PRegister, T_BYTE, length_in_bytes_resize);\n+    __ sve_dup($dst$$FloatRegister, __ B, 0);\n+    __ sve_sel($dst$$FloatRegister, __ B, $ptmp$$PRegister,\n+               $src$$FloatRegister, $dst$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector cast ----------------------------------\n+\n+\/\/ VectorCastB2X\n+\n+instruct vcvtBtoX(vReg dst, vReg src) %{\n+  match(Set dst (VectorCastB2X src));\n+  format %{ \"vcvtBtoX $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      \/\/ 4B to 4S\/4I\/4F, 8B to 8S\n+      __ neon_vector_extend($dst$$FloatRegister, bt == T_FLOAT ? T_INT : bt,\n+                            length_in_bytes, $src$$FloatRegister, T_BYTE);\n+      if (bt == T_FLOAT) {\n+        __ scvtfv(__ T4S, $dst$$FloatRegister, $dst$$FloatRegister);\n+      }\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+      __ sve_vector_extend($dst$$FloatRegister, size, $src$$FloatRegister, __ B);\n+      if (is_floating_point_type(bt)) {\n+        __ sve_scvtf($dst$$FloatRegister, size, ptrue, $dst$$FloatRegister, size);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorCastS2X\n+\n+instruct vcvtStoB_neon(vReg dst, vReg src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE &&\n+            VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1))));\n+  match(Set dst (VectorCastS2X src));\n+  format %{ \"vcvtStoB_neon $dst, $src\" %}\n+  ins_encode %{\n+    \/\/ 4S\/8S to 4B\/8B\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    __ neon_vector_narrow($dst$$FloatRegister, T_BYTE,\n+                          $src$$FloatRegister, T_SHORT, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtStoB_sve(vReg dst, vReg src, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE &&\n+            !VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1))));\n+  match(Set dst (VectorCastS2X src));\n+  effect(TEMP tmp);\n+  format %{ \"vcvtStoB_sve $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_vector_narrow($dst$$FloatRegister, __ B,\n+                         $src$$FloatRegister, __ H, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtStoX_extend(vReg dst, vReg src) %{\n+  predicate(type2aelembytes(Matcher::vector_element_basic_type(n)) >= 4);\n+  match(Set dst (VectorCastS2X src));\n+  format %{ \"vcvtStoX_extend $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      \/\/ 4S to 4I\/4F\n+      __ neon_vector_extend($dst$$FloatRegister, T_INT, length_in_bytes,\n+                            $src$$FloatRegister, T_SHORT);\n+      if (bt == T_FLOAT) {\n+        __ scvtfv(__ T4S, $dst$$FloatRegister, $dst$$FloatRegister);\n+      }\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+      __ sve_vector_extend($dst$$FloatRegister, size, $src$$FloatRegister, __ H);\n+      if (is_floating_point_type(bt)) {\n+        __ sve_scvtf($dst$$FloatRegister, size, ptrue, $dst$$FloatRegister, size);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorCastI2X\n+\n+instruct vcvtItoX_narrow_neon(vReg dst, vReg src) %{\n+  predicate((Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT) &&\n+            VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1))));\n+  match(Set dst (VectorCastI2X src));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vcvtItoX_narrow_neon $dst, $src\" %}\n+  ins_encode %{\n+    \/\/ 4I to 4B\/4S\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    __ neon_vector_narrow($dst$$FloatRegister, bt,\n+                          $src$$FloatRegister, T_INT, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtItoX_narrow_sve(vReg dst, vReg src, vReg tmp) %{\n+  predicate((Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT) &&\n+            !VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1))));\n+  match(Set dst (VectorCastI2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vcvtItoX_narrow_sve $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_vector_narrow($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                         $src$$FloatRegister, __ S, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtItoX(vReg dst, vReg src) %{\n+  predicate(type2aelembytes(Matcher::vector_element_basic_type(n)) >= 4);\n+  match(Set dst (VectorCastI2X src));\n+  format %{ \"vcvtItoX $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes =  Matcher::vector_length_in_bytes(this);\n+    if (bt == T_FLOAT) {\n+      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+        \/\/ 2I\/4I to 2F\/4F\n+        __ scvtfv(get_arrangement(this), $dst$$FloatRegister, $src$$FloatRegister);\n+      } else {\n+        assert(UseSVE > 0, \"must be sve\");\n+        __ sve_scvtf($dst$$FloatRegister, __ S, ptrue, $src$$FloatRegister, __ S);\n+      }\n+    } else {\n+      assert(type2aelembytes(bt) == 8, \"unsupported type\");\n+      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+        \/\/ 2I to 2L\/2D\n+        __ neon_vector_extend($dst$$FloatRegister, T_LONG, length_in_bytes,\n+                              $src$$FloatRegister, T_INT);\n+        if (bt == T_DOUBLE) {\n+          __ scvtfv(__ T2D, $dst$$FloatRegister, $dst$$FloatRegister);\n+        }\n+      } else {\n+        assert(UseSVE > 0, \"must be sve\");\n+        __ sve_vector_extend($dst$$FloatRegister, __ D, $src$$FloatRegister, __ S);\n+        if (bt == T_DOUBLE) {\n+          __ sve_scvtf($dst$$FloatRegister, __ D, ptrue, $dst$$FloatRegister, __ D);\n+        }\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorCastL2X\n+\n+instruct vcvtLtoI_neon(vReg dst, vReg src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_INT &&\n+            VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1))));\n+  match(Set dst (VectorCastL2X src));\n+  format %{ \"vcvtLtoI_neon $dst, $src\" %}\n+  ins_encode %{\n+    \/\/ 2L to 2I\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    __ neon_vector_narrow($dst$$FloatRegister, T_INT,\n+                          $src$$FloatRegister, T_LONG, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtLtoI_sve(vReg dst, vReg src, vReg tmp) %{\n+  predicate((Matcher::vector_element_basic_type(n) == T_INT &&\n+             !VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1)))) ||\n+            Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst (VectorCastL2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vcvtLtoI_sve $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_vector_narrow($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                         $src$$FloatRegister, __ D, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtLtoF_neon(vReg dst, vReg src, vRegF tmp) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst (VectorCastL2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vcvtLtoF_neon $dst, $src\\t# 2L to 2F. KILL $tmp\" %}\n+  ins_encode %{\n+    \/\/ 2L to 2F\n+    __ umov(rscratch1, $src$$FloatRegister, __ D, 0);\n+    __ scvtfs($dst$$FloatRegister, rscratch1);\n+    __ umov(rscratch1, $src$$FloatRegister, __ D, 1);\n+    __ scvtfs($tmp$$FloatRegister, rscratch1);\n+    __ ins($dst$$FloatRegister, __ S, $tmp$$FloatRegister, 1, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtLtoF_sve(vReg dst, vReg src, vReg tmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst (VectorCastL2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vcvtLtoF_sve $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ sve_scvtf($dst$$FloatRegister, __ S, ptrue, $src$$FloatRegister, __ D);\n+    __ sve_vector_narrow($dst$$FloatRegister, __ S,\n+                         $dst$$FloatRegister, __ D, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtLtoD(vReg dst, vReg src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+  match(Set dst (VectorCastL2X src));\n+  format %{ \"vcvtLtoD $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      \/\/ 2L to 2D\n+      __ scvtfv(__ T2D, $dst$$FloatRegister, $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_scvtf($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister, __ D);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorCastF2X\n+\n+instruct vcvtFtoX_narrow_neon(vReg dst, vReg src) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1))) &&\n+            (Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT));\n+  match(Set dst (VectorCastF2X src));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vcvtFtoX_narrow_neon $dst, $src\" %}\n+  ins_encode %{\n+    \/\/ 4F to 4B\/4S\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    __ fcvtzs($dst$$FloatRegister, __ T4S, $src$$FloatRegister);\n+    __ neon_vector_narrow($dst$$FloatRegister, bt,\n+                          $dst$$FloatRegister, T_INT, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtFtoX_narrow_sve(vReg dst, vReg src, vReg tmp) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1))) &&\n+            (Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT));\n+  match(Set dst (VectorCastF2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vcvtFtoX_narrow_sve $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fcvtzs($dst$$FloatRegister, __ S, ptrue, $src$$FloatRegister, __ S);\n+    __ sve_vector_narrow($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                         $dst$$FloatRegister, __ S, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtFtoX(vReg dst, vReg src) %{\n+  predicate(type2aelembytes(Matcher::vector_element_basic_type(n)) >= 4);\n+  match(Set dst (VectorCastF2X src));\n+  format %{ \"vcvtFtoX $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes =  Matcher::vector_length_in_bytes(this);\n+    if (bt == T_INT) {\n+      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+        \/\/ 2F\/4F to 2I\/4I\n+        __ fcvtzs($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+      } else {\n+        assert(UseSVE > 0, \"must be sve\");\n+        __ sve_fcvtzs($dst$$FloatRegister, __ S, ptrue, $src$$FloatRegister, __ S);\n+      }\n+    } else if (bt == T_LONG) {\n+      if (UseSVE == 0) {\n+        \/\/ 2F to 2L\n+        __ fcvtl($dst$$FloatRegister, __ T2D, $src$$FloatRegister, __ T2S);\n+        __ fcvtzs($dst$$FloatRegister, __ T2D, $dst$$FloatRegister);\n+      } else {\n+        __ sve_vector_extend($dst$$FloatRegister, __ D, $src$$FloatRegister, __ S);\n+        __ sve_fcvtzs($dst$$FloatRegister, __ D, ptrue, $dst$$FloatRegister, __ S);\n+      }\n+    } else {\n+      assert(bt == T_DOUBLE, \"unsupported type\");\n+      if (length_in_bytes == 16) {\n+        \/\/ 2F to 2D\n+        __ fcvtl($dst$$FloatRegister, __ T2D, $src$$FloatRegister, __ T2S);\n+      } else {\n+        assert(UseSVE > 0 && length_in_bytes > 16, \"must be\");\n+        __ sve_vector_extend($dst$$FloatRegister, __ D, $src$$FloatRegister, __ S);\n+        __ sve_fcvt($dst$$FloatRegister, __ D, ptrue, $dst$$FloatRegister, __ S);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorCastD2X\n+\n+instruct vcvtDtoI_neon(vReg dst, vReg src) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n) == T_INT);\n+  match(Set dst (VectorCastD2X src));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vcvtDtoI_neon $dst, $src\\t# 2D to 2I\" %}\n+  ins_encode %{\n+    \/\/ 2D to 2I\n+    __ ins($dst$$FloatRegister, __ D, $src$$FloatRegister, 0, 1);\n+    \/\/ We can't use fcvtzs(vector, integer) instruction here because we need\n+    \/\/ saturation arithmetic. See JDK-8276151.\n+    __ fcvtzdw(rscratch1, $src$$FloatRegister);\n+    __ fcvtzdw(rscratch2, $dst$$FloatRegister);\n+    __ fmovs($dst$$FloatRegister, rscratch1);\n+    __ mov($dst$$FloatRegister, __ S, 1, rscratch2);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtDtoI_sve(vReg dst, vReg src, vReg tmp) %{\n+  predicate(UseSVE > 0 &&\n+            (Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n) == T_INT));\n+  match(Set dst (VectorCastD2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vcvtDtoI_sve $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fcvtzs($dst$$FloatRegister, __ S, ptrue, $src$$FloatRegister, __ D);\n+    __ sve_vector_narrow($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                         $dst$$FloatRegister, __ D, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtDtoL(vReg dst, vReg src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst (VectorCastD2X src));\n+  format %{ \"vcvtDtoL $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes =  Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      \/\/ 2D to 2L\n+      __ fcvtzs($dst$$FloatRegister, __ T2D, $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fcvtzs($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister, __ D);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtDtoF_64b(vReg dst, vReg src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_FLOAT &&\n+            Matcher::vector_length_in_bytes(n) == 8);\n+  match(Set dst (VectorCastD2X src));\n+  format %{ \"vcvtDtoF_64b $dst, $src\\t# 2D to 2F\" %}\n+  ins_encode %{\n+    \/\/ 2D to 2F\n+    __ fcvtn($dst$$FloatRegister, __ T2S, $src$$FloatRegister, __ T2D);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtDtoF_gt64b(vReg dst, vReg src, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_FLOAT &&\n+            Matcher::vector_length_in_bytes(n) > 8);\n+  match(Set dst (VectorCastD2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vcvtDtoF_gt64b $dst, $src\\t# vector > 64 bits. KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_fcvt($dst$$FloatRegister, __ S, ptrue, $src$$FloatRegister, __ D);\n+    __ sve_vector_narrow($dst$$FloatRegister, __ S,\n+                         $dst$$FloatRegister, __ D, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Replicate ------------------------------------\n+\n+dnl REPLICATE_INT($1,   $2,       $3  )\n+dnl REPLICATE_INT(type, arg_type, size)\n+define(`REPLICATE_INT', `\n+instruct replicate$1(vReg dst, $2 src) %{\n+  match(Set dst (Replicate$1 src));\n+  format %{ \"replicate$1 $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ dup($dst$$FloatRegister, get_arrangement(this), $src$$Register);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_dup($dst$$FloatRegister, __ $3, $src$$Register);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl REPLICATE_FP($1,   $2  )\n+dnl REPLICATE_FP(type, size)\n+define(`REPLICATE_FP', `\n+instruct replicate$1(vReg dst, vReg$1 src) %{\n+  match(Set dst (Replicate$1 src));\n+  format %{ \"replicate$1 $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ dup($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_cpy($dst$$FloatRegister, __ $2, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl REPLICATE_IMM_SVE($1,   $2,       $3  )\n+dnl REPLICATE_IMM_SVE(type, arg_type, size)\n+define(`REPLICATE_IMM_SVE', `\n+instruct replicate$1_imm8_gt128b(vReg dst, $2 con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16);\n+  match(Set dst (Replicate$1 con));\n+  format %{ \"replicate$1_imm8_gt128b $dst, $con\\t# vector > 128 bits\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_dup($dst$$FloatRegister, __ $3, (int)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ replicate from reg\n+REPLICATE_INT(B, iRegIorL2I, B)\n+REPLICATE_INT(S, iRegIorL2I, H)\n+REPLICATE_INT(I, iRegIorL2I, S)\n+REPLICATE_INT(L, iRegL,      D)\n+REPLICATE_FP(F, S)\n+REPLICATE_FP(D, D)\n+\n+\/\/ replicate from imm\n+\n+instruct replicateI_imm_le128b(vReg dst, immI con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16);\n+  match(Set dst (ReplicateB con));\n+  match(Set dst (ReplicateS con));\n+  match(Set dst (ReplicateI con));\n+  format %{ \"replicateI_imm_le128b $dst, $con\\t# vector <= 128 bits\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int imm = (int)$con$$constant;\n+    if (type2aelembytes(bt) == 1) {\n+      \/\/ Refine imm for B\n+      imm = imm & 0xff;\n+    } else if (type2aelembytes(bt) == 2) {\n+      \/\/ Refine imm for S\n+      imm = imm & 0xffff;\n+    }\n+    __ mov($dst$$FloatRegister, get_arrangement(this), imm);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+dnl\n+REPLICATE_IMM_SVE(B, immI8,        B)\n+REPLICATE_IMM_SVE(S, immI8_shift8, H)\n+REPLICATE_IMM_SVE(I, immI8_shift8, S)\n+\n+instruct replicateL_imm_128b(vReg dst, immL con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) == 16);\n+  match(Set dst (ReplicateL con));\n+  format %{ \"replicateL_imm_128b $dst, $con\\t# vector > 128 bits\" %}\n+  ins_encode %{\n+    __ mov($dst$$FloatRegister, __ T2D, (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+dnl\n+REPLICATE_IMM_SVE(L, immL8_shift8, D)\n+\n+\/\/ ------------------------------ Vector insert --------------------------------\n+\n+\/\/ BYTE, SHORT, INT\n+\n+instruct insertI_le128b(vReg dst, vReg src, iRegIorL2I val, immI idx) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16 &&\n+            (Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n) == T_INT));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  format %{ \"insertI_le128b $dst, $src, $val, $idx\\t# vector <= 128 bits\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if ($dst$$FloatRegister != $src$$FloatRegister) {\n+      __ orr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+             $src$$FloatRegister, $src$$FloatRegister);\n+    }\n+    __ mov($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+           (int)($idx$$constant), $val$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertI_index_lt32(vReg dst, vReg src, iRegIorL2I val, immI idx,\n+                            vReg tmp, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(n->in(2)->get_int() < 32 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n+            (Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n) == T_INT));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP tmp, TEMP pgtmp, KILL cr);\n+  format %{ \"insertI_index_lt32 $dst, $src, $val, $idx\\t# vector > 128 bits, index < 31. KILL $tmp, $pgtmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_index($tmp$$FloatRegister, size, -16, 1);\n+    __ sve_cmp(Assembler::EQ, $pgtmp$$PRegister, size, ptrue,\n+               $tmp$$FloatRegister, (int)($idx$$constant) - 16);\n+    if ($dst$$FloatRegister != $src$$FloatRegister) {\n+      __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+    }\n+    __ sve_cpy($dst$$FloatRegister, size, $pgtmp$$PRegister, $val$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertI_index_ge32(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg tmp1,\n+                            vReg tmp2, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(n->in(2)->get_int() >= 32 &&\n+            (Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n) == T_INT));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP pgtmp, KILL cr);\n+  format %{ \"insertI_index_ge32 $dst, $src, $val, $idx\\t# index >= 32. KILL $tmp1, $tmp2, $pgtmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_index($tmp1$$FloatRegister, size, 0, 1);\n+    __ sve_dup($tmp2$$FloatRegister, size, (int)($idx$$constant));\n+    __ sve_cmp(Assembler::EQ, $pgtmp$$PRegister, size, ptrue,\n+               $tmp1$$FloatRegister, $tmp2$$FloatRegister);\n+    if ($dst$$FloatRegister != $src$$FloatRegister) {\n+      __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+    }\n+    __ sve_cpy($dst$$FloatRegister, size, $pgtmp$$PRegister, $val$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ LONG\n+\n+instruct insertL_128b(vReg dst, vReg src, iRegL val, immI idx) %{\n+  predicate(Matcher::vector_length_in_bytes(n) == 16 &&\n+            Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  format %{ \"insertL_128b $dst, $src, $val, $idx\\t# 2L\" %}\n+  ins_encode %{\n+    if ($dst$$FloatRegister != $src$$FloatRegister) {\n+      __ orr($dst$$FloatRegister, __ T16B, $src$$FloatRegister, $src$$FloatRegister);\n+    }\n+    __ mov($dst$$FloatRegister, __ D, (int)($idx$$constant), $val$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertL_gt128b(vReg dst, vReg src, iRegL val, immI idx,\n+                        vReg tmp, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16 &&\n+            Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP tmp, TEMP pgtmp, KILL cr);\n+  format %{ \"insertL_gt128b $dst, $src, $val, $idx\\t# vector > 128 bits. KILL $tmp, $pgtmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_index($tmp$$FloatRegister, __ D, -16, 1);\n+    __ sve_cmp(Assembler::EQ, $pgtmp$$PRegister, __ D, ptrue,\n+               $tmp$$FloatRegister, (int)($idx$$constant) - 16);\n+    if ($dst$$FloatRegister != $src$$FloatRegister) {\n+      __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+    }\n+    __ sve_cpy($dst$$FloatRegister, __ D, $pgtmp$$PRegister, $val$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ FLOAT\n+\n+instruct insertF_le128b(vReg dst, vReg src, vRegF val, immI idx) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16 &&\n+            Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst);\n+  format %{ \"insertF_le128b $dst, $src, $val, $idx\\t# vector <= 128 bits\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if ($dst$$FloatRegister != $src$$FloatRegister) {\n+      __ orr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+             $src$$FloatRegister, $src$$FloatRegister);\n+    }\n+    __ ins($dst$$FloatRegister, __ S, $val$$FloatRegister, (int)($idx$$constant), 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertF_index_lt32(vReg dst, vReg src, vRegF val, immI idx,\n+                            pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(n->in(2)->get_int() < 32 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n+            Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n+  format %{ \"insertF_index_lt32 $dst, $src, $val, $idx\\t# vector > 128 bits, index < 32. KILL $pgtmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_index($dst$$FloatRegister, __ S, -16, 1);\n+    __ sve_cmp(Assembler::EQ, $pgtmp$$PRegister, __ S, ptrue,\n+               $dst$$FloatRegister, (int)($idx$$constant) - 16);\n+    __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+    __ sve_cpy($dst$$FloatRegister, __ S, $pgtmp$$PRegister, $val$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertF_index_ge32(vReg dst, vReg src, vRegF val, immI idx, vReg tmp,\n+                            pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(n->in(2)->get_int() >= 32 &&\n+            Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP pgtmp, KILL cr);\n+  format %{ \"insertF_index_ge32 $dst, $src, $val, $idx\\t# index >= 32. KILL $tmp, $pgtmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_index($tmp$$FloatRegister, __ S, 0, 1);\n+    __ sve_dup($dst$$FloatRegister, __ S, (int)($idx$$constant));\n+    __ sve_cmp(Assembler::EQ, $pgtmp$$PRegister, __ S, ptrue,\n+               $tmp$$FloatRegister, $dst$$FloatRegister);\n+    __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+    __ sve_cpy($dst$$FloatRegister, __ S, $pgtmp$$PRegister, $val$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ DOUBLE\n+\n+instruct insertD_128b(vReg dst, vReg src, vRegD val, immI idx) %{\n+  predicate(Matcher::vector_length_in_bytes(n) == 16 &&\n+            Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst);\n+  format %{ \"insertD_128b $dst, $src, $val, $idx\\t# 2D\" %}\n+  ins_encode %{\n+    if ($dst$$FloatRegister != $src$$FloatRegister) {\n+      __ orr($dst$$FloatRegister, __ T16B, $src$$FloatRegister, $src$$FloatRegister);\n+    }\n+    __ ins($dst$$FloatRegister, __ D, $val$$FloatRegister, (int)($idx$$constant), 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertD_gt128b(vReg dst, vReg src, vRegD val, immI idx,\n+                        pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16 &&\n+            Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n+  format %{ \"insertD_gt128b $dst, $src, $val, $idx\\t# vector > 128 bits. KILL $pgtmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_index($dst$$FloatRegister, __ D, -16, 1);\n+    __ sve_cmp(Assembler::EQ, $pgtmp$$PRegister, __ D, ptrue,\n+               $dst$$FloatRegister, (int)($idx$$constant) - 16);\n+    __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+    __ sve_cpy($dst$$FloatRegister, __ D, $pgtmp$$PRegister, $val$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Extract --------------------------------------\n+dnl\n+dnl EXTRACT_INT_SMALL($1,   $2,    $3,       $4,   $5  )\n+dnl EXTRACT_INT_SMALL(type, index, arg_type, insn, size)\n+define(`EXTRACT_INT_SMALL', `\n+instruct extract$1_index_lt$2($3 dst, vReg src, immI idx) %{\n+  predicate(n->in(2)->get_int() < $2);\n+  match(Set dst (Extract$1 src idx));\n+  format %{ \"extract$1_index_lt$2 $dst, $src, $idx\\t# index < $2\" %}\n+  ins_encode %{\n+    __ $4($dst$$Register, $src$$FloatRegister, __ $5, (int)($idx$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl\n+dnl EXTRACT_INT_LARGE($1,   $2,    $3,       $4       )\n+dnl EXTRACT_INT_LARGE(type, index, arg_type, data_type)\n+define(`EXTRACT_INT_LARGE', `\n+instruct extract$1_index_ge$2($3 dst, vReg src, immI idx, vReg tmp) %{\n+  predicate(n->in(2)->get_int() >= $2);\n+  match(Set dst (Extract$1 src idx));\n+  effect(TEMP tmp);\n+  format %{ \"extract$1_index_ge$2 $dst, $src, $idx\\t# index >=$2. KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_extract_integral($dst$$Register, $4, $src$$FloatRegister,\n+                            (int)($idx$$constant), $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ BYTE\n+EXTRACT_INT_SMALL(B, 16, iRegINoSp, smov, B)\n+EXTRACT_INT_LARGE(B, 16, iRegINoSp, T_BYTE)\n+\n+\/\/ SHORT\n+EXTRACT_INT_SMALL(S, 8, iRegINoSp, smov, H)\n+EXTRACT_INT_LARGE(S, 8, iRegINoSp, T_SHORT)\n+\n+\/\/ INT\n+EXTRACT_INT_SMALL(I, 4, iRegINoSp, umov, S)\n+EXTRACT_INT_LARGE(I, 4, iRegINoSp, T_INT)\n+\n+\/\/ LONG\n+EXTRACT_INT_SMALL(L, 2, iRegLNoSp, umov, D)\n+EXTRACT_INT_LARGE(L, 2, iRegLNoSp, T_LONG)\n+\n+dnl\n+dnl EXTRACT_FP($1,   $2,   $3,    $4,   $5   )\n+dnl EXTRACT_FP(type, insn, index, size, shift)\n+define(`EXTRACT_FP', `\n+instruct extract$1(vReg$1 dst, vReg src, immI idx) %{\n+  match(Set dst (Extract$1 src idx));\n+  effect(TEMP_DEF dst);\n+  format %{ \"extract$1 $dst, $src, $idx\" %}\n+  ins_encode %{\n+    int index = (int)$idx$$constant;\n+    if (index == 0) {\n+      __ $2($dst$$FloatRegister, $src$$FloatRegister);\n+    } else if (index < $3) {\n+      __ ins($dst$$FloatRegister, __ $4, $src$$FloatRegister, 0, index);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+      __ sve_ext($dst$$FloatRegister, $dst$$FloatRegister, index << $5);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ FLOAT\n+EXTRACT_FP(F, fmovs, 4, S, 2)\n+\n+\/\/ DOUBLE\n+EXTRACT_FP(D, fmovd, 2, D, 3)\n+\n+\/\/ ------------------------------ Vector mask load\/store -----------------------\n+\n+\/\/ vector load mask\n+\n+instruct vloadmask_neon(vReg dst, vReg src) %{\n+  predicate(UseSVE == 0 &&\n+            (Matcher::vector_length_in_bytes(n) == 8 ||\n+             Matcher::vector_length_in_bytes(n) == 16));\n+  match(Set dst (VectorLoadMask src ));\n+  format %{ \"vloadmask_neon $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (bt == T_BYTE) {\n+      uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+      __ negr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+              $src$$FloatRegister);\n+    } else {\n+      __ uxtl($dst$$FloatRegister, __ T8H, $src$$FloatRegister, __ T8B);\n+      if (type2aelembytes(bt) >= 4) {\n+        __ uxtl($dst$$FloatRegister, __ T4S, $dst$$FloatRegister, __ T4H);\n+      }\n+      if (type2aelembytes(bt) == 8) {\n+        __ uxtl($dst$$FloatRegister, __ T2D, $dst$$FloatRegister, __ T2S);\n+      }\n+      __ negr($dst$$FloatRegister, get_arrangement(this), $dst$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vloadmaskB_sve(pRegGov dst, vReg src, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && !n->is_predicated_vector() &&\n+            Matcher::vector_element_basic_type(n) == T_BYTE);\n+  match(Set dst (VectorLoadMask src));\n+  effect(KILL cr);\n+  format %{ \"vloadmaskB_sve $dst, $src\\t# KILL cr\" %}\n+  ins_encode %{\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, __ B,\n+               ptrue, $src$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vloadmask_extend_sve(pRegGov dst, vReg src, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && !n->is_predicated_vector() &&\n+            Matcher::vector_element_basic_type(n) != T_BYTE);\n+  match(Set dst (VectorLoadMask src));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vloadmask_extend_sve $dst, $src\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_vector_extend($tmp$$FloatRegister, size, $src$$FloatRegister, __ B);\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, size, ptrue, $tmp$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vloadmaskB_masked(pRegGov dst, vReg src, pRegGov pg, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n) == T_BYTE);\n+  match(Set dst (VectorLoadMask src pg));\n+  effect(KILL cr);\n+  format %{ \"vloadmaskB_masked $dst, $pg, $src\\t# KILL cr\" %}\n+  ins_encode %{\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, __ B,\n+               $pg$$PRegister, $src$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vloadmask_extend_masked(pRegGov dst, vReg src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n) != T_BYTE);\n+  match(Set dst (VectorLoadMask src pg));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vloadmask_extend_masked $dst, $pg, $src\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_vector_extend($tmp$$FloatRegister, size, $src$$FloatRegister, __ B);\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, size,\n+               $pg$$PRegister, $tmp$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector store mask - neon\n+\n+instruct vstoremaskB_neon(vReg dst, vReg src, immI_1 size) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (VectorStoreMask src size));\n+  format %{ \"vstoremaskB_neon $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n+    __ negr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+            $src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vstoremask_narrow_neon(vReg dst, vReg src, immI_gt_1 size) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (VectorStoreMask src size));\n+  format %{ \"vstoremask_narrow_neon $dst, $src\" %}\n+  ins_encode %{\n+    int esize = (int)$size$$constant;\n+    if (esize == 2) {\n+      __ xtn($dst$$FloatRegister, __ T8B, $src$$FloatRegister, __ T8H);\n+    } else if (esize == 4) {\n+      __ xtn($dst$$FloatRegister, __ T4H, $src$$FloatRegister, __ T4S);\n+      __ xtn($dst$$FloatRegister, __ T8B, $dst$$FloatRegister, __ T8H);\n+    } else {\n+      assert(esize == 8, \"must be\");\n+      __ xtn($dst$$FloatRegister, __ T2S, $src$$FloatRegister, __ T2D);\n+      __ xtn($dst$$FloatRegister, __ T4H, $dst$$FloatRegister, __ T4S);\n+      __ xtn($dst$$FloatRegister, __ T8B, $dst$$FloatRegister, __ T8H);\n+    }\n+    __ negr($dst$$FloatRegister, __ T8B, $dst$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector store mask - sve\n+\n+instruct vstoremaskB_sve(vReg dst, pRegGov src, immI_1 size) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorStoreMask src size));\n+  format %{ \"vstoremaskB_sve $dst, $src\" %}\n+  ins_encode %{\n+    __ sve_cpy($dst$$FloatRegister, __ B, $src$$PRegister, 1, false);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vstoremask_narrow_sve(vReg dst, pRegGov src, immI_gt_1 size, vReg tmp) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorStoreMask src size));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vstoremask_narrow_sve $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    Assembler::SIMD_RegVariant size = __ elemBytes_to_regVariant((int)$size$$constant);\n+    __ sve_cpy($dst$$FloatRegister, size, $src$$PRegister, 1, false);\n+    __ sve_vector_narrow($dst$$FloatRegister, __ B,\n+                         $dst$$FloatRegister, size, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Combined rules for vector mask load when the vector element type is not T_BYTE\n+\n+\/\/ VectorLoadMask+LoadVector, and the VectorLoadMask is unpredicated.\n+instruct vloadmask_loadV(pRegGov dst, indirect mem, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && !n->is_predicated_vector() &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) > 1);\n+  match(Set dst (VectorLoadMask (LoadVector mem)));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vloadmask_loadV $dst, $mem\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    \/\/ Load mask values which are boolean type, and extend them to the\n+    \/\/ defined vector element type. Convert the vector to predicate.\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, $tmp$$FloatRegister,\n+                          ptrue, T_BOOLEAN, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, __ elemType_to_regVariant(bt),\n+               ptrue, $tmp$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorLoadMask+LoadVector, and the VectorLoadMask is predicated.\n+instruct vloadmask_loadV_masked(pRegGov dst, indirect mem, pRegGov pg,\n+                                vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) > 1);\n+  match(Set dst (VectorLoadMask (LoadVector mem) pg));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vloadmask_loadV_masked $dst, $pg, $mem\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    \/\/ Load valid mask values which are boolean type, and extend them to the\n+    \/\/ defined vector element type. Convert the vector to predicate.\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, $tmp$$FloatRegister,\n+                          $pg$$PRegister, T_BOOLEAN, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $tmp$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorLoadMask+LoadVectorMasked, and the VectorLoadMask is unpredicated.\n+instruct vloadmask_loadVMasked(pRegGov dst, vmemA mem, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && !n->is_predicated_vector() &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) > 1);\n+  match(Set dst (VectorLoadMask (LoadVectorMasked mem pg)));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vloadmask_loadVMasked $dst, $mem\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    \/\/ Load mask values which are boolean type, and extend them to the\n+    \/\/ defined vector element type. Convert the vector to predicate.\n+    \/\/\n+    \/\/ Note that we cannot use \"pg\" here, since it is the predicate used\n+    \/\/ for the vector load with boolean type. But the predicate used in\n+    \/\/ the extending \"sve_ld1b\" is based on the final extended vector type,\n+    \/\/ which is the full-sized predicate (ptrue) used in VectorLoadMask.\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, $tmp$$FloatRegister,\n+                          ptrue, T_BOOLEAN, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, __ elemType_to_regVariant(bt),\n+               ptrue, $tmp$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorLoadMask+LoadVectorMasked, and the VectorLoadMask is predicated.\n+instruct vloadmask_loadVMasked_masked(pRegGov dst, vmemA mem, pRegGov pg1, pRegGov pg2,\n+                                      vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) > 1);\n+  match(Set dst (VectorLoadMask (LoadVectorMasked mem pg1) pg2));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vloadmask_loadVMasked_masked $dst, $pg2, $mem\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    \/\/ Load valid mask values which are boolean type, and extend them to the\n+    \/\/ defined vector element type. Convert the vector to predicate.\n+    \/\/\n+    \/\/ Note that we cannot use \"pg1\" here, since it is the predicate used\n+    \/\/ for the vector load with boolean type. But the predicate used in\n+    \/\/ the extending \"sve_ld1b\" is based on the final extended vector type,\n+    \/\/ which is the \"pg2\" used in VectorLoadMask.\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, $tmp$$FloatRegister,\n+                          $pg2$$PRegister, T_BOOLEAN, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, __ elemType_to_regVariant(bt),\n+               $pg2$$PRegister, $tmp$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Combined rules for vector mask store when the vector element type is not T_BYTE\n+\n+\/\/ StoreVector+VectorStoreMask, and the vector size of \"src\" is equal to the MaxVectorSize.\n+instruct storeV_vstoremask(indirect mem, pRegGov src, immI_gt_1 esize, vReg tmp) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length_in_bytes(n->as_StoreVector()->in(MemNode::ValueIn)->in(1)) == MaxVectorSize);\n+  match(Set mem (StoreVector mem (VectorStoreMask src esize)));\n+  effect(TEMP tmp);\n+  format %{ \"storeV_vstoremask $mem, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    \/\/ Convert the valid src predicate to vector, and store the vector elements\n+    \/\/ as boolean values.\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    assert(type2aelembytes(bt) == (int)$esize$$constant, \"unsupported type\");\n+    Assembler::SIMD_RegVariant size = __ elemBytes_to_regVariant($esize$$constant);\n+    __ sve_cpy($tmp$$FloatRegister, size, $src$$PRegister, 1, false);\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, $tmp$$FloatRegister,\n+                          ptrue, T_BOOLEAN, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ StoreVector+VectorStoreMask, and the vector size of \"src\" is less than the MaxVectorSize.\n+instruct storeV_vstoremask_masked(indirect mem, pRegGov src, immI_gt_1 esize,\n+                                  vReg tmp, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length_in_bytes(n->as_StoreVector()->in(MemNode::ValueIn)->in(1)) < MaxVectorSize);\n+  match(Set mem (StoreVector mem (VectorStoreMask src esize)));\n+  effect(TEMP tmp, TEMP pgtmp, KILL cr);\n+  format %{ \"storeV_vstoremask_masked $mem, $src\\t# KILL $tmp, $pgtmp, cr\" %}\n+  ins_encode %{\n+    \/\/ Convert the valid src predicate to vector, and store the vector elements\n+    \/\/ as boolean values.\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_cpy($tmp$$FloatRegister, size, $src$$PRegister, 1, false);\n+    __ sve_gen_mask_imm($pgtmp$$PRegister, bt, Matcher::vector_length(this, $src));\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, $tmp$$FloatRegister,\n+                          $pgtmp$$PRegister, T_BOOLEAN, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ StoreVectorMasked+VectorStoreMask, and the vector size of \"src\" is equal to the MaxVectorSize.\n+instruct storeVMasked_vstoremask(vmemA mem, pRegGov src, pRegGov pg, immI_gt_1 esize, vReg tmp) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length_in_bytes(n->as_StoreVector()->in(MemNode::ValueIn)->in(1)) == MaxVectorSize);\n+  match(Set mem (StoreVectorMasked mem (Binary (VectorStoreMask src esize) pg)));\n+  effect(TEMP tmp);\n+  format %{ \"storeVMasked_vstoremask $mem, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    \/\/ Convert the valid src predicate to vector, and store the vector elements\n+    \/\/ as boolean values.\n+    \/\/\n+    \/\/ Note that we cannot use \"pg\" here, since it is the predicate used\n+    \/\/ for the vector store with boolean type. But the predicate used in\n+    \/\/ the narrowing \"sve_st1b\" is based on the \"src\" vector type, which\n+    \/\/ is the full-sized predicate (ptrue) here.\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    assert(type2aelembytes(bt) == (int)$esize$$constant, \"unsupported type.\");\n+    Assembler::SIMD_RegVariant size = __ elemBytes_to_regVariant($esize$$constant);\n+    __ sve_cpy($tmp$$FloatRegister, size, $src$$PRegister, 1, false);\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, $tmp$$FloatRegister,\n+                          ptrue, T_BOOLEAN, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ StoreVectorMasked+VectorStoreMask, and the vector size of \"src\" is less than the MaxVectorSize.\n+instruct storeVMasked_vstoremask_masked(vmemA mem, pRegGov src, pRegGov pg, immI_gt_1 esize,\n+                                        vReg tmp, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length_in_bytes(n->as_StoreVector()->in(MemNode::ValueIn)->in(1)) < MaxVectorSize);\n+  match(Set mem (StoreVectorMasked mem (Binary (VectorStoreMask src esize) pg)));\n+  effect(TEMP tmp, TEMP pgtmp, KILL cr);\n+  format %{ \"storeVMasked_vstoremask_masked $mem, $src\\t# KILL $tmp, $pgtmp, cr\" %}\n+  ins_encode %{\n+    \/\/ Convert the valid src predicate to vector, and store the vector elements\n+    \/\/ as boolean values.\n+    \/\/\n+    \/\/ Note that we cannot use \"pg\" here, since it is the predicate used for the\n+    \/\/ vector store with boolean type. But the predicate used in the narrowing\n+    \/\/ \"sve_st1b\" is based on the \"src\" vector type, which needed to be generated\n+    \/\/ here.\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_cpy($tmp$$FloatRegister, size, $src$$PRegister, 1, false);\n+    __ sve_gen_mask_imm($pgtmp$$PRegister, bt, Matcher::vector_length(this, $src));\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, $tmp$$FloatRegister,\n+                          $pgtmp$$PRegister, T_BOOLEAN, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector mask basic OPs ------------------------\n+\n+dnl\n+dnl VMASK_BITWISE_OP($1,   $2,      $3  )\n+dnl VMASK_BITWISE_OP(type, op_name, insn)\n+define(`VMASK_BITWISE_OP', `\n+instruct vmask_$1(pRegGov pd, pRegGov pn, pRegGov pm) %{\n+  predicate(UseSVE > 0);\n+  match(Set pd ($2 pn pm));\n+  format %{ \"vmask_$1 $pd, $pn, $pm\" %}\n+  ins_encode %{\n+    __ $3($pd$$PRegister, ptrue, $pn$$PRegister, $pm$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl VMASK_AND_NOT($1  )\n+dnl VMASK_AND_NOT(type)\n+define(`VMASK_AND_NOT', `\n+instruct vmask_and_not$1(pRegGov pd, pRegGov pn, pRegGov pm, imm$1_M1 m1) %{\n+  predicate(UseSVE > 0);\n+  match(Set pd (AndVMask pn (XorVMask pm (MaskAll m1))));\n+  format %{ \"vmask_and_not$1 $pd, $pn, $pm\" %}\n+  ins_encode %{\n+    __ sve_bic($pd$$PRegister, ptrue, $pn$$PRegister, $pm$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector mask logical ops: and\/or\/xor\/and_not\n+VMASK_BITWISE_OP(and, AndVMask, sve_and)\n+VMASK_BITWISE_OP(or,  OrVMask,  sve_orr)\n+VMASK_BITWISE_OP(xor, XorVMask, sve_eor)\n+VMASK_AND_NOT(I)\n+VMASK_AND_NOT(L)\n+\n+\/\/ vector mask compare\n+\n+instruct vmaskcmp_neon(vReg dst, vReg src1, vReg src2, immI cond) %{\n+  predicate(UseSVE == 0 &&\n+            (Matcher::vector_length_in_bytes(n) == 8 ||\n+             Matcher::vector_length_in_bytes(n) == 16));\n+  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n+  format %{ \"vmaskcmp_neon $dst, $src1, $src2, $cond\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ neon_compare($dst$$FloatRegister, bt, $src1$$FloatRegister,\n+                    $src2$$FloatRegister, (int)($cond$$constant),\n+                    \/* isQ *\/ length_in_bytes == 16);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskcmp_sve(pRegGov dst, vReg src1, vReg src2, immI cond, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n+  effect(KILL cr);\n+  format %{ \"vmaskcmp_sve $dst, $src1, $src2, $cond\\t# KILL cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_compare($dst$$PRegister, bt, ptrue, $src1$$FloatRegister,\n+                   $src2$$FloatRegister, (int)($cond$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskcmp_masked(pRegGov dst, vReg src1, vReg src2, immI cond,\n+                         pRegGov pg, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorMaskCmp (Binary src1 src2) (Binary cond pg)));\n+  effect(KILL cr);\n+  format %{ \"vmaskcmp_masked $dst, $pg, $src1, $src2, $cond\\t# KILL cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_compare($dst$$PRegister, bt, $pg$$PRegister, $src1$$FloatRegister,\n+                   $src2$$FloatRegister, (int)($cond$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector mask cast\n+\n+instruct vmaskcast_same_esize_neon(vReg dst_src) %{\n+  predicate(UseSVE == 0 &&\n+            Matcher::vector_length_in_bytes(n) == Matcher::vector_length_in_bytes(n->in(1)) &&\n+            (Matcher::vector_length_in_bytes(n) == 8 || Matcher::vector_length_in_bytes(n) == 16));\n+  match(Set dst_src (VectorMaskCast dst_src));\n+  ins_cost(0);\n+  format %{ \"vmaskcast_same_esize_neon $dst_src\\t# do nothing\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n+instruct vmaskcast_same_esize_sve(pRegGov dst_src) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length_in_bytes(n) == Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst_src (VectorMaskCast dst_src));\n+  ins_cost(0);\n+  format %{ \"vmaskcast_same_esize_sve $dst_src\\t# do nothing\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n+instruct vmaskcast_extend(pRegGov dst, pReg src) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length_in_bytes(n) > Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vmaskcast_extend $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);\n+    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, $src);\n+    assert(length_in_bytes_dst == 2 * length_in_bytes_src ||\n+           length_in_bytes_dst == 4 * length_in_bytes_src ||\n+           length_in_bytes_dst == 8 * length_in_bytes_src, \"invalid vector length\");\n+    __ sve_vmaskcast_extend($dst$$PRegister, $src$$PRegister,\n+                            length_in_bytes_dst, length_in_bytes_src);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskcast_narrow(pRegGov dst, pReg src) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length_in_bytes(n) < Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vmaskcast_narrow $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);\n+    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, $src);\n+    assert(length_in_bytes_dst * 2 == length_in_bytes_src ||\n+           length_in_bytes_dst * 4 == length_in_bytes_src ||\n+           length_in_bytes_dst * 8 == length_in_bytes_src, \"invalid vector length\");\n+    __ sve_vmaskcast_narrow($dst$$PRegister, $src$$PRegister,\n+                            length_in_bytes_dst, length_in_bytes_src);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector mask reinterpret\n+\n+instruct vmask_reinterpret_same_esize(pRegGov dst_src) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length(n) == Matcher::vector_length(n->in(1)) &&\n+            Matcher::vector_length_in_bytes(n) == Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst_src (VectorReinterpret dst_src));\n+  ins_cost(0);\n+  format %{ \"vmask_reinterpret_same_esize $dst_src\\t# do nothing\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n+instruct vmask_reinterpret_diff_esize(pRegGov dst, pRegGov src, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length(n) != Matcher::vector_length(n->in(1)) &&\n+            Matcher::vector_length_in_bytes(n) == Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorReinterpret src));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vmask_reinterpret_diff_esize $dst, $src\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType from_bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant from_size = __ elemType_to_regVariant(from_bt);\n+    BasicType to_bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n+    __ sve_cpy($tmp$$FloatRegister, from_size, $src$$PRegister, -1, false);\n+    __ sve_cmp(Assembler::EQ, $dst$$PRegister, to_size, ptrue, $tmp$$FloatRegister, -1);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector mask reductions -----------------------\n+\n+\/\/ true count\n+\n+instruct vmask_truecount_neon(iRegINoSp dst, vReg src, vReg tmp) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (VectorMaskTrueCount src));\n+  effect(TEMP tmp);\n+  format %{ \"vmask_truecount_neon $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    \/\/ Input \"src\" is a vector of boolean represented as bytes with\n+    \/\/ 0x00\/0x01 as element values.\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    assert(bt == T_BOOLEAN, \"unsupported type\");\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    __ addv($tmp$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+            $src$$FloatRegister);\n+    __ umov($dst$$Register, $tmp$$FloatRegister, __ B, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_truecount_sve(iRegINoSp dst, pReg src) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorMaskTrueCount src));\n+  format %{ \"vmask_truecount_sve $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ sve_cntp($dst$$Register, __ elemType_to_regVariant(bt),\n+                ptrue, $src$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ first true\n+\n+instruct vmask_firsttrue_lt8e(iRegINoSp dst, vReg src, rFlagsReg cr) %{\n+  predicate(UseSVE == 0 &&\n+            Matcher::vector_length(n->in(1)) < 8);\n+  match(Set dst (VectorMaskFirstTrue src));\n+  effect(KILL cr);\n+  format %{ \"vmask_firsttrue_lt8e $dst, $src\\t# vector < 8 elements (neon). KILL cr\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the first active lane of the\n+    \/\/ vector mask, or VLENGTH if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    \/\/\n+    \/\/ Computed by reversing the bits and counting the leading\n+    \/\/ zero bytes.\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    assert(bt == T_BOOLEAN, \"unsupported type\");\n+    __ fmovd($dst$$Register, $src$$FloatRegister);\n+    __ rbit($dst$$Register, $dst$$Register);\n+    __ clz($dst$$Register, $dst$$Register);\n+    __ lsrw($dst$$Register, $dst$$Register, 3);\n+    __ movw(rscratch1, Matcher::vector_length(this, $src));\n+    __ cmpw($dst$$Register, rscratch1);\n+    __ cselw($dst$$Register, rscratch1, $dst$$Register, Assembler::GE);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_firsttrue_8or16e(iRegINoSp dst, vReg src) %{\n+  predicate(UseSVE == 0 &&\n+            (Matcher::vector_length(n->in(1)) == 8 || Matcher::vector_length(n->in(1)) == 16));\n+  match(Set dst (VectorMaskFirstTrue src));\n+  format %{ \"vmask_firsttrue_8or16e $dst, $src\\t# vector 8B\/16B (neon)\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the first active lane of the\n+    \/\/ vector mask, or VLENGTH if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    \/\/\n+    \/\/ Computed by reversing the bits and counting the leading\n+    \/\/ zero bytes.\n+\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    assert(bt == T_BOOLEAN, \"unsupported type\");\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    if (length_in_bytes == 8) {\n+      __ fmovd($dst$$Register, $src$$FloatRegister);\n+      __ rbit($dst$$Register, $dst$$Register);\n+      __ clz($dst$$Register, $dst$$Register);\n+      __ lsrw($dst$$Register, $dst$$Register, 3);\n+    } else {\n+      assert(length_in_bytes == 16, \"must be\");\n+      Label FIRST_TRUE_INDEX;\n+\n+      \/\/ Try to compute the result from lower 64 bits.\n+      __ fmovd($dst$$Register, $src$$FloatRegister);\n+      __ movw(rscratch1, zr);\n+      __ cbnz($dst$$Register, FIRST_TRUE_INDEX);\n+\n+      \/\/ Compute the result from the higher 64 bits.\n+      __ fmovhid($dst$$Register, $src$$FloatRegister);\n+      __ movw(rscratch1, 8);\n+\n+      \/\/ Reverse the bits and count the leading zero bytes.\n+      __ bind(FIRST_TRUE_INDEX);\n+      __ rbit($dst$$Register, $dst$$Register);\n+      __ clz($dst$$Register, $dst$$Register);\n+      __ addw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Return the index of the first mask lane that is set, or vector length if none of\n+\/\/ them are set.\n+\n+instruct vmask_firsttrue_sve(iRegINoSp dst, pReg src, pReg ptmp) %{\n+  predicate(UseSVE > 0 && !n->is_predicated_vector());\n+  match(Set dst (VectorMaskFirstTrue src));\n+  effect(TEMP ptmp);\n+  format %{ \"vmask_firsttrue_sve $dst, $src\\t# KILL $ptmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_brkb($ptmp$$PRegister, ptrue, $src$$PRegister, false);\n+    __ sve_cntp($dst$$Register, __ elemType_to_regVariant(bt), ptrue, $ptmp$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_firsttrue_masked(iRegINoSp dst, pReg src, pRegGov pg, pReg ptmp) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorMaskFirstTrue src pg));\n+  effect(TEMP ptmp);\n+  format %{ \"vmask_firsttrue_masked $dst, $pg, $src\\t# KILL $ptmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ sve_brkb($ptmp$$PRegister, $pg$$PRegister, $src$$PRegister, false);\n+    __ sve_cntp($dst$$Register, __ elemType_to_regVariant(bt), ptrue, $ptmp$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ last true\n+\n+instruct vmask_lasttrue_neon(iRegINoSp dst, vReg src) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (VectorMaskLastTrue src));\n+  format %{ \"vmask_lasttrue_neon $dst, $src\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the last active lane of the\n+    \/\/ vector mask, or -1 if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    assert(bt == T_BOOLEAN, \"unsupported type\");\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    if (length_in_bytes <= 8) {\n+      \/\/ Computed by counting the leading zero bytes and\n+      \/\/ subtracting it by 7 (VLENGTH - 1).\n+      __ fmovd($dst$$Register, $src$$FloatRegister);\n+      __ clz($dst$$Register, $dst$$Register);\n+      __ movw(rscratch1, 7);\n+      __ subw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n+    } else {\n+      assert(length_in_bytes == 16, \"must be\");\n+      Label LAST_TRUE_INDEX;\n+\n+      \/\/ Try to compute the result from higher 64 bits.\n+      __ fmovhid($dst$$Register, $src$$FloatRegister);\n+      __ movw(rscratch1, 16 - 1);\n+      __ cbnz($dst$$Register, LAST_TRUE_INDEX);\n+\n+      \/\/ Compute the result from the lower 64 bits.\n+      __ fmovd($dst$$Register, $src$$FloatRegister);\n+      __ movw(rscratch1, 8 - 1);\n+\n+      \/\/ Count the leading zero bytes and subtract it by 15 (VLENGTH - 1).\n+      __ bind(LAST_TRUE_INDEX);\n+      __ clz($dst$$Register, $dst$$Register);\n+      __ subw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_lasttrue_sve(iRegINoSp dst, pReg src, pReg ptmp) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorMaskLastTrue src));\n+  effect(TEMP ptmp);\n+  format %{ \"vmask_lasttrue_sve $dst, $src\\t# KILL $ptmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ sve_vmask_lasttrue($dst$$Register, bt, $src$$PRegister, $ptmp$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ tolong\n+\n+instruct vmask_tolong_neon(iRegLNoSp dst, vReg src) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (VectorMaskToLong src));\n+  format %{ \"vmask_tolong_neon $dst, $src\" %}\n+  ins_encode %{\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    if (length_in_bytes <= 8) {\n+      __ fmovd($dst$$Register, $src$$FloatRegister);\n+      __ bytemask_compress($dst$$Register);\n+    } else {\n+      assert(length_in_bytes == 16, \"must be\");\n+      __ umov($dst$$Register, $src$$FloatRegister, __ D, 0);\n+      __ umov(rscratch1, $src$$FloatRegister, __ D, 1);\n+      __ bytemask_compress($dst$$Register);\n+      __ bytemask_compress(rscratch1);\n+      __ orr($dst$$Register, $dst$$Register, rscratch1, Assembler::LSL, 8);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_tolong_sve(iRegLNoSp dst, pReg src, vReg tmp1, vReg tmp2) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorMaskToLong src));\n+  effect(TEMP tmp1, TEMP tmp2);\n+  format %{ \"vmask_tolong_sve $dst, $src\\t# KILL $tmp1, $tmp2\" %}\n+  ins_encode %{\n+    __ sve_vmask_tolong($dst$$Register, $src$$PRegister,\n+                        Matcher::vector_element_basic_type(this, $src),\n+                        Matcher::vector_length(this, $src),\n+                        $tmp1$$FloatRegister, $tmp2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ fromlong\n+\n+instruct vmask_fromlong(pRegGov dst, iRegL src, vReg tmp1, vReg tmp2) %{\n+  match(Set dst (VectorLongToMask src));\n+  effect(TEMP tmp1, TEMP tmp2);\n+  format %{ \"vmask_fromlong $dst, $src\\t# vector (sve2). KILL $tmp1, $tmp2\" %}\n+  ins_encode %{\n+    __ sve_vmask_fromlong($dst$$PRegister, $src$$Register,\n+                          Matcher::vector_element_basic_type(this),\n+                          Matcher::vector_length(this),\n+                          $tmp1$$FloatRegister, $tmp2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector mask generation -----------------------\n+\n+\/\/ maskAll\n+dnl\n+dnl VMASKALL_IMM($1,   $2      )\n+dnl VMASKALL_IMM(type, var_type)\n+define(`VMASKALL_IMM', `\n+instruct vmaskAll_imm$1(pRegGov dst, imm$1 src, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (MaskAll src));\n+  effect(KILL cr);\n+  format %{ \"vmaskAll_imm$1 $dst, $src\\t# KILL cr\" %}\n+  ins_encode %{\n+    $2 con = ($2)$src$$constant;\n+    if (con == 0) {\n+      __ sve_pfalse($dst$$PRegister);\n+    } else {\n+      assert(con == -1, \"invalid constant value for mask\");\n+      BasicType bt = Matcher::vector_element_basic_type(this);\n+      __ sve_gen_mask_imm($dst$$PRegister, bt, Matcher::vector_length(this));\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl VMASKALL($1,   $2      )\n+dnl VMASKALL(type, arg_type)\n+define(`VMASKALL', `\n+instruct vmaskAll$1(pRegGov dst, $2 src, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && !n->is_predicated_vector());\n+  match(Set dst (MaskAll src));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vmaskAll$1 $dst, $src\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_dup($tmp$$FloatRegister, size, $src$$Register);\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, size, ptrue, $tmp$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl VMASKALL_PREDICATE($1,   $2      )\n+dnl VMASKALL_PREDICATE(type, arg_type)\n+define(`VMASKALL_PREDICATE', `\n+instruct vmaskAll$1_masked(pRegGov dst, $2 src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (MaskAll src pg));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vmaskAll$1_masked $dst, $pg, $src\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_dup($tmp$$FloatRegister, size, $src$$Register);\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, size,\n+               $pg$$PRegister, $tmp$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+VMASKALL_IMM(I, int)\n+VMASKALL(I, iRegIorL2I)\n+VMASKALL_PREDICATE(I, iRegIorL2I)\n+VMASKALL_IMM(L, long)\n+VMASKALL(L, iRegL)\n+VMASKALL_PREDICATE(L, iRegL)\n+\n+\/\/ vetcor mask generation\n+\n+instruct vmask_gen_I(pRegGov pd, iRegIorL2I src, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set pd (VectorMaskGen (ConvI2L src)));\n+  effect(KILL cr);\n+  format %{ \"vmask_gen_I $pd, $src\\t# KILL cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_whilelow($pd$$PRegister, __ elemType_to_regVariant(bt), zr, $src$$Register);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct vmask_gen_L(pRegGov pd, iRegL src, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set pd (VectorMaskGen src));\n+  effect(KILL cr);\n+  format %{ \"vmask_gen_L $pd, $src\\t# KILL cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_whilelo($pd$$PRegister, __ elemType_to_regVariant(bt), zr, $src$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_gen_imm(pRegGov pd, immL con, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set pd (VectorMaskGen con));\n+  effect(KILL cr);\n+  format %{ \"vmask_gen_imm $pd, $con\\t# KILL cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_gen_mask_imm($pd$$PRegister, bt, (uint)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Popcount vector ------------------------------\n+\n+\/\/ vector popcount - INT\n+\n+instruct vpopcountI(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (PopCountVI src));\n+  format %{ \"vpopcountI $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (bt == T_BYTE) {\n+      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+        __ cnt($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+               $src$$FloatRegister);\n+      } else {\n+        assert(UseSVE > 0, \"must be sve\");\n+        __ sve_cnt($dst$$FloatRegister, __ B, ptrue, $src$$FloatRegister);\n+      }\n+    } else {\n+      assert(bt == T_SHORT || bt == T_INT, \"unsupported\");\n+      if (UseSVE == 0) {\n+        assert(length_in_bytes == 8 || length_in_bytes == 16, \"unsupported\");\n+        __ cnt($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+               $src$$FloatRegister);\n+        __ uaddlp($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+                  $dst$$FloatRegister);\n+        if (bt == T_INT) {\n+          __ uaddlp($dst$$FloatRegister, length_in_bytes == 16 ? __ T8H : __ T4H,\n+                    $dst$$FloatRegister);\n+        }\n+      } else {\n+        __ sve_cnt($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                   ptrue, $src$$FloatRegister);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector popcount - LONG\n+\n+instruct vpopcountL(vReg dst, vReg src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_LONG &&\n+            !n->as_Vector()->is_predicated_vector());\n+  match(Set dst (PopCountVL src));\n+  format %{ \"vpopcountL $dst, $src\" %}\n+  ins_encode %{\n+    if (UseSVE == 0) {\n+      __ cnt($dst$$FloatRegister, __ T16B, $src$$FloatRegister);\n+      __ uaddlp($dst$$FloatRegister, __ T16B, $dst$$FloatRegister);\n+      __ uaddlp($dst$$FloatRegister, __ T8H, $dst$$FloatRegister);\n+      __ uaddlp($dst$$FloatRegister, __ T4S, $dst$$FloatRegister);\n+    } else {\n+      __ sve_cnt($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ If the PopCountVL is generated by auto-vectorization, the dst basic\n+\/\/ type is T_INT. And once we have unified the type definition for\n+\/\/ Vector API and auto-vectorization, this rule can be merged with\n+\/\/ \"vpopcountL\" rule.\n+\n+instruct vpopcountL_I(vReg dst, vReg src, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_INT &&\n+            !n->as_Vector()->is_predicated_vector());\n+  match(Set dst (PopCountVL src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vpopcountL_I $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    if (UseSVE == 0) {\n+      __ cnt($dst$$FloatRegister, __ T16B, $src$$FloatRegister);\n+      __ uaddlp($dst$$FloatRegister, __ T16B, $dst$$FloatRegister);\n+      __ uaddlp($dst$$FloatRegister, __ T8H, $dst$$FloatRegister);\n+      __ uaddlp($dst$$FloatRegister, __ T4S, $dst$$FloatRegister);\n+      __ xtn($dst$$FloatRegister, __ T2S, $dst$$FloatRegister, __ T2D);\n+    } else {\n+      __ sve_cnt($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+      __ sve_vector_narrow($dst$$FloatRegister, __ S,\n+                           $dst$$FloatRegister, __ D, $tmp$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector popcount - predicated\n+UNARY_OP_PREDICATE(vpopcountI, PopCountVI, sve_cnt)\n+\n+instruct vpopcountL_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst_src (PopCountVL dst_src pg));\n+  format %{ \"vpopcountL_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    __ sve_cnt($dst_src$$FloatRegister, __ D,\n+               $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector blend ---------------------------------\n+\n+instruct vblend_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (VectorBlend (Binary src1 src2) dst));\n+  format %{ \"vblend_neon $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n+    __ bsl($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+           $src2$$FloatRegister, $src1$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vblend_sve(vReg dst, vReg src1, vReg src2, pReg pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorBlend (Binary src1 src2) pg));\n+  format %{ \"vblend_sve $dst, $pg, $src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_sel($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $src2$$FloatRegister, $src1$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector round ---------------------------------\n+\n+\/\/ vector Math.round\n+\n+instruct vround_le128b(vReg dst, vReg src, vReg tmp1, vReg tmp2,\n+                       vReg tmp3, rFlagsReg cr) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16);\n+  match(Set dst (RoundVF src));\n+  match(Set dst (RoundVD src));\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+  format %{ \"vround_le128b $dst, $src\\t# vector <= 128 bits. KILL $tmp1, $tmp2, $tmp3, cr\" %}\n+  ins_encode %{\n+    __ vector_round_neon($dst$$FloatRegister, $src$$FloatRegister,\n+                         $tmp1$$FloatRegister, $tmp2$$FloatRegister,\n+                         $tmp3$$FloatRegister, get_arrangement(this));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vround_gt128b(vReg dst, vReg src, vReg tmp1, vReg tmp2,\n+                       pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16);\n+  match(Set dst (RoundVF src));\n+  match(Set dst (RoundVD src));\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP pgtmp, KILL cr);\n+  format %{ \"vround_gt128b $dst, $src\\t# vector > 128 bits. KILL $tmp1, $tmp2, $pgtmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vector_round_sve($dst$$FloatRegister, $src$$FloatRegister,\n+                        $tmp1$$FloatRegister, $tmp2$$FloatRegister,\n+                        $pgtmp$$PRegister, __ elemType_to_regVariant(bt));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ RoundDouble ----------------------------------\n+\n+\/\/ vector Math.rint, floor, ceil\n+\n+instruct vroundD(vReg dst, vReg src, immI rmode) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+  match(Set dst (RoundDoubleModeV src rmode));\n+  format %{ \"vroundD $dst, $src, $rmode\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      switch ($rmode$$constant) {\n+        case RoundDoubleModeNode::rmode_rint:\n+          __ frintn($dst$$FloatRegister, __ T2D, $src$$FloatRegister);\n+          break;\n+        case RoundDoubleModeNode::rmode_floor:\n+          __ frintm($dst$$FloatRegister, __ T2D, $src$$FloatRegister);\n+          break;\n+        case RoundDoubleModeNode::rmode_ceil:\n+          __ frintp($dst$$FloatRegister, __ T2D, $src$$FloatRegister);\n+          break;\n+        default:\n+          assert(false, \"unsupported\");\n+          ShouldNotReachHere();\n+      }\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      switch ($rmode$$constant) {\n+        case RoundDoubleModeNode::rmode_rint:\n+          __ sve_frintn($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+          break;\n+        case RoundDoubleModeNode::rmode_floor:\n+          __ sve_frintm($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+          break;\n+        case RoundDoubleModeNode::rmode_ceil:\n+          __ sve_frintp($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+          break;\n+        default:\n+          assert(false, \"unsupported\");\n+          ShouldNotReachHere();\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ VectorTest -----------------------------------\n+\n+\/\/ anytrue\n+\n+instruct vtest_anytrue_neon(iRegINoSp dst, vReg src1, vReg src2, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE == 0 &&\n+            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::ne);\n+  match(Set dst (VectorTest src1 src2 ));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vtest_anytrue_neon $dst, $src1\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    \/\/ No need to use src2.\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src1);\n+    assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n+    __ addv($tmp$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B, $src1$$FloatRegister);\n+    __ umov($dst$$Register, $tmp$$FloatRegister, __ B, 0);\n+    __ cmpw($dst$$Register, zr);\n+    __ csetw($dst$$Register, Assembler::NE);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vtest_anytrue_sve(iRegINoSp dst, pRegGov src1, pRegGov src2, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::ne);\n+  match(Set dst (VectorTest src1 src2));\n+  effect(KILL cr);\n+  format %{ \"vtest_anytrue_sve $dst, $src1\\t# KILL cr\" %}\n+  ins_encode %{\n+    \/\/ \"src2\" is not used for sve.\n+    __ sve_ptest(ptrue, $src1$$PRegister);\n+    __ csetw($dst$$Register, Assembler::NE);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ alltrue\n+\n+instruct vtest_alltrue_neon(iRegINoSp dst, vReg src1, vReg src2, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE == 0 &&\n+            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow);\n+  match(Set dst (VectorTest src1 src2));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vtest_alltrue_neon $dst, $src1\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    \/\/ No need to use src2.\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src1);\n+    assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n+    __ uminv($tmp$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B, $src1$$FloatRegister);\n+    __ umov($dst$$Register, $tmp$$FloatRegister, __ B, 0);\n+    __ cmpw($dst$$Register, 0xff);\n+    __ csetw($dst$$Register, Assembler::EQ);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vtest_alltrue_sve(iRegINoSp dst, pRegGov src1, pRegGov src2, pReg ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow);\n+  match(Set dst (VectorTest src1 src2));\n+  effect(TEMP ptmp, KILL cr);\n+  format %{ \"vtest_alltrue_sve $dst, $src1, $src2\\t# KILL $ptmp, cr\" %}\n+  ins_encode %{\n+    __ sve_eors($ptmp$$PRegister, ptrue, $src1$$PRegister, $src2$$PRegister);\n+    __ csetw($dst$$Register, Assembler::EQ);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector shuffle -------------------------------\n+\n+instruct loadshuffle(vReg dst, vReg src) %{\n+  match(Set dst (VectorLoadShuffle src));\n+  format %{ \"loadshuffle $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (bt == T_BYTE) {\n+      if ($dst$$FloatRegister != $src$$FloatRegister) {\n+        if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+          __ orr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+                 $src$$FloatRegister, $src$$FloatRegister);\n+        } else {\n+          assert(UseSVE > 0, \"must be sve\");\n+          __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+        }\n+      }\n+    } else {\n+      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+        \/\/ 4S\/8S, 4I, 4F\n+        __ uxtl($dst$$FloatRegister, __ T8H, $src$$FloatRegister, __ T8B);\n+        if (type2aelembytes(bt) == 4) {\n+          __ uxtl($dst$$FloatRegister, __ T4S, $dst$$FloatRegister, __ T4H);\n+        }\n+      } else {\n+        assert(UseSVE > 0, \"must be sve\");\n+        __ sve_vector_extend($dst$$FloatRegister,  __ elemType_to_regVariant(bt),\n+                             $src$$FloatRegister, __ B);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector rearrange -----------------------------\n+\n+\/\/ Here is an example that rearranges a NEON vector with 4 ints:\n+\/\/ Rearrange V1 int[a0, a1, a2, a3] to V2 int[a2, a3, a0, a1]\n+\/\/   1. Get the indices of V1 and store them as Vi byte[0, 1, 2, 3].\n+\/\/   2. Convert Vi byte[0, 1, 2, 3] to the indices of V2 and also store them as Vi byte[2, 3, 0, 1].\n+\/\/   3. Unsigned extend Long Vi from byte[2, 3, 0, 1] to int[2, 3, 0, 1].\n+\/\/   4. Multiply Vi int[2, 3, 0, 1] with constant int[0x04040404, 0x04040404, 0x04040404, 0x04040404]\n+\/\/      and get tbl base Vm int[0x08080808, 0x0c0c0c0c, 0x00000000, 0x04040404].\n+\/\/   5. Add Vm with constant int[0x03020100, 0x03020100, 0x03020100, 0x03020100]\n+\/\/      and get tbl index Vm int[0x0b0a0908, 0x0f0e0d0c, 0x03020100, 0x07060504]\n+\/\/   6. Use Vm as index register, and use V1 as table register.\n+\/\/      Then get V2 as the result by tbl NEON instructions.\n+\/\/ Notes:\n+\/\/   Step 1 matches VectorLoadConst.\n+\/\/   Step 3 matches VectorLoadShuffle.\n+\/\/   Step 4, 5, 6 match VectorRearrange.\n+\/\/   For VectorRearrange short\/int, the reason why such complex calculation is\n+\/\/   required is because NEON tbl supports bytes table only, so for short\/int, we\n+\/\/   need to lookup 2\/4 bytes as a group. For VectorRearrange long, we use bsl\n+\/\/   to implement rearrange.\n+\n+instruct rearrange_HS_neon(vReg dst, vReg src, vReg shuffle, vReg tmp1, vReg tmp2) %{\n+  predicate(UseSVE == 0 &&\n+            (Matcher::vector_element_basic_type(n) == T_SHORT ||\n+             (type2aelembytes(Matcher::vector_element_basic_type(n)) == 4 &&\n+              Matcher::vector_length_in_bytes(n) == 16)));\n+  match(Set dst (VectorRearrange src shuffle));\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);\n+  format %{ \"rearrange_HS_neon $dst, $src, $shuffle\\t# vector (4S\/8S\/4I\/4F). KILL $tmp1, $tmp2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (bt == T_SHORT) {\n+      uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+      assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n+      Assembler::SIMD_Arrangement size1 = length_in_bytes == 16 ? __ T16B : __ T8B;\n+      Assembler::SIMD_Arrangement size2 = length_in_bytes == 16 ? __ T8H : __ T4H;\n+      __ mov($tmp1$$FloatRegister, size1, 0x02);\n+      __ mov($tmp2$$FloatRegister, size2, 0x0100);\n+      __ mulv($dst$$FloatRegister, size2, $shuffle$$FloatRegister, $tmp1$$FloatRegister);\n+      __ addv($dst$$FloatRegister, size1, $dst$$FloatRegister, $tmp2$$FloatRegister);\n+      __ tbl($dst$$FloatRegister, size1, $src$$FloatRegister, 1, $dst$$FloatRegister);\n+    } else {\n+      assert(bt == T_INT || bt == T_FLOAT, \"unsupported type\");\n+      __ mov($tmp1$$FloatRegister, __ T16B, 0x04);\n+      __ mov($tmp2$$FloatRegister, __ T4S, 0x03020100);\n+      __ mulv($dst$$FloatRegister, __ T4S, $shuffle$$FloatRegister, $tmp1$$FloatRegister);\n+      __ addv($dst$$FloatRegister, __ T16B, $dst$$FloatRegister, $tmp2$$FloatRegister);\n+      __ tbl($dst$$FloatRegister, __ T16B, $src$$FloatRegister, 1, $dst$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct rearrange(vReg dst, vReg src, vReg shuffle) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE || UseSVE > 0);\n+  match(Set dst (VectorRearrange src shuffle));\n+  format %{ \"rearrange $dst, $src, $shuffle\" %}\n+  ins_encode %{\n+    BasicType bt_dst = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (bt_dst == T_BYTE && VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ tbl($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+             $src$$FloatRegister, 1, $shuffle$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      BasicType bt_src = Matcher::vector_element_basic_type(this, $src);\n+      __ sve_tbl($dst$$FloatRegister, __ elemType_to_regVariant(bt_src),\n+                 $src$$FloatRegister, $shuffle$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector Load Gather ---------------------------\n+\n+instruct gather_loadS(vReg dst, indirect mem, vReg idx) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) == 4);\n+  match(Set dst (LoadVectorGather mem idx));\n+  format %{ \"gather_loadS $dst, $mem, $idx\\t# vector (sve)\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_ld1w_gather($dst$$FloatRegister, ptrue,\n+                       as_Register($mem$$base), $idx$$FloatRegister);\n+ %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct gather_loadD(vReg dst, indirect mem, vReg idx, vReg tmp) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) == 8);\n+  match(Set dst (LoadVectorGather mem idx));\n+  effect(TEMP tmp);\n+  format %{ \"gather_loadD $dst, $mem, $idx\\t# vector (sve). KILL $tmp\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_uunpklo($tmp$$FloatRegister, __ D, $idx$$FloatRegister);\n+    __ sve_ld1d_gather($dst$$FloatRegister, ptrue, as_Register($mem$$base),\n+                       $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct gather_loadS_masked(vReg dst, indirect mem, vReg idx, pRegGov pg) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) == 4);\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx pg)));\n+  format %{ \"gather_loadS_masked $dst, $pg, $mem, $idx\" %}\n+  ins_encode %{\n+    __ sve_ld1w_gather($dst$$FloatRegister, $pg$$PRegister,\n+                       as_Register($mem$$base), $idx$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct gather_loadD_masked(vReg dst, indirect mem, vReg idx, pRegGov pg, vReg tmp) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) == 8);\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx pg)));\n+  effect(TEMP tmp);\n+  format %{ \"gather_loadD_masked $dst, $pg, $mem, $idx\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ sve_uunpklo($tmp$$FloatRegister, __ D, $idx$$FloatRegister);\n+    __ sve_ld1d_gather($dst$$FloatRegister, $pg$$PRegister,\n+                       as_Register($mem$$base), $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector Store Scatter -------------------------\n+\n+instruct scatter_storeS(indirect mem, vReg src, vReg idx) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n->in(3)->in(1))) == 4);\n+  match(Set mem (StoreVectorScatter mem (Binary src idx)));\n+  format %{ \"scatter_storeS $mem, $idx, $src\\t# vector (sve)\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_st1w_scatter($src$$FloatRegister, ptrue,\n+                        as_Register($mem$$base), $idx$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct scatter_storeD(indirect mem, vReg src, vReg idx, vReg tmp) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n->in(3)->in(1))) == 8);\n+  match(Set mem (StoreVectorScatter mem (Binary src idx)));\n+  effect(TEMP tmp);\n+  format %{ \"scatter_storeD $mem, $idx, $src\\t# vector (sve). KILL $tmp\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_uunpklo($tmp$$FloatRegister, __ D, $idx$$FloatRegister);\n+    __ sve_st1d_scatter($src$$FloatRegister, ptrue,\n+                        as_Register($mem$$base), $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct scatter_storeS_masked(indirect mem, vReg src, vReg idx, pRegGov pg) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n->in(3)->in(1))) == 4);\n+  match(Set mem (StoreVectorScatterMasked mem (Binary src (Binary idx pg))));\n+  format %{ \"scatter_storeS_masked $mem, $pg, $idx, $src\" %}\n+  ins_encode %{\n+    __ sve_st1w_scatter($src$$FloatRegister, $pg$$PRegister,\n+                        as_Register($mem$$base), $idx$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct scatter_storeD_masked(indirect mem, vReg src, vReg idx, pRegGov pg, vReg tmp) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n->in(3)->in(1))) == 8);\n+  match(Set mem (StoreVectorScatterMasked mem (Binary src (Binary idx pg))));\n+  effect(TEMP tmp);\n+  format %{ \"scatter_storeD_masked $mem, $pg, $idx, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ sve_uunpklo($tmp$$FloatRegister, __ D, $idx$$FloatRegister);\n+    __ sve_st1d_scatter($src$$FloatRegister, $pg$$PRegister,\n+                        as_Register($mem$$base), $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ CountLeadingZerosV ---------------------------\n+\n+instruct vcountLeadingZeros(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (CountLeadingZerosV src));\n+  format %{ \"vcountLeadingZeros $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (bt == T_LONG) {\n+      if (UseSVE == 0) {\n+        __ umov(rscratch1, $src$$FloatRegister, __ D, 0);\n+        __ clz(rscratch1, rscratch1);\n+        __ mov($dst$$FloatRegister, __ D, 0, rscratch1);\n+        __ umov(rscratch1, $src$$FloatRegister, __ D, 1);\n+        __ clz(rscratch1, rscratch1);\n+        __ mov($dst$$FloatRegister, __ D, 1, rscratch1);\n+      } else {\n+        __ sve_clz($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+      }\n+    } else {\n+      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+        __ clz($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+      } else {\n+        assert(UseSVE > 0, \"must be sve\");\n+        __ sve_clz($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                   ptrue, $src$$FloatRegister);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ The dst and src should use the same register to make sure the\n+\/\/ inactive lanes in dst save the same elements as src.\n+UNARY_OP_PREDICATE(vcountLeadingZeros, CountLeadingZerosV, sve_clz)\n+\n+\/\/ ------------------------------ CountTrailingZerosV --------------------------\n+\n+instruct vcountTrailingZeros(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (CountTrailingZerosV src));\n+  format %{ \"vcountTrailingZeros $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (bt == T_BYTE) {\n+      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+        __ rbit($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+                $src$$FloatRegister);\n+        __ clz($dst$$FloatRegister, get_arrangement(this), $dst$$FloatRegister);\n+      } else {\n+        assert(UseSVE > 0, \"must be sve\");\n+        __ sve_rbit($dst$$FloatRegister, __ B, ptrue, $src$$FloatRegister);\n+        __ sve_clz($dst$$FloatRegister, __ B, ptrue, $dst$$FloatRegister);\n+      }\n+    } else {\n+      assert(bt == T_SHORT || bt == T_INT || bt == T_LONG, \"unsupported type\");\n+      if (UseSVE == 0) {\n+        assert(length_in_bytes == 8 || length_in_bytes == 16, \"unsupported\");\n+        __ neon_reverse_bits($dst$$FloatRegister, $src$$FloatRegister,\n+                             bt, \/* isQ *\/ length_in_bytes == 16);\n+        if (bt != T_LONG) {\n+          __ clz($dst$$FloatRegister, get_arrangement(this), $dst$$FloatRegister);\n+        } else {\n+          __ umov(rscratch1, $dst$$FloatRegister, __ D, 0);\n+          __ clz(rscratch1, rscratch1);\n+          __ mov($dst$$FloatRegister, __ D, 0, rscratch1);\n+          __ umov(rscratch1, $dst$$FloatRegister, __ D, 1);\n+          __ clz(rscratch1, rscratch1);\n+          __ mov($dst$$FloatRegister, __ D, 1, rscratch1);\n+        }\n+      } else {\n+        Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+        __ sve_rbit($dst$$FloatRegister, size, ptrue, $src$$FloatRegister);\n+        __ sve_clz($dst$$FloatRegister, size, ptrue, $dst$$FloatRegister);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ The dst and src should use the same register to make sure the\n+\/\/ inactive lanes in dst save the same elements as src.\n+instruct vcountTrailingZeros_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (CountTrailingZerosV dst_src pg));\n+  format %{ \"vcountTrailingZeros_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_rbit($dst_src$$FloatRegister, size,\n+                $pg$$PRegister, $dst_src$$FloatRegister);\n+    __ sve_clz($dst_src$$FloatRegister, size,\n+               $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ ReverseV -------------------------------------\n+\n+instruct vreverse(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (ReverseV src));\n+  format %{ \"vreverse $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (bt == T_BYTE) {\n+      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+        __ rbit($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+                $src$$FloatRegister);\n+      } else {\n+        assert(UseSVE > 0, \"must be sve\");\n+        __ sve_rbit($dst$$FloatRegister, __ B, ptrue, $src$$FloatRegister);\n+      }\n+    } else {\n+      assert(bt == T_SHORT || bt == T_INT || bt == T_LONG, \"unsupported type\");\n+      if (UseSVE == 0) {\n+        assert(length_in_bytes == 8 || length_in_bytes == 16, \"unsupported\");\n+        __ neon_reverse_bits($dst$$FloatRegister, $src$$FloatRegister,\n+                             bt, \/* isQ *\/ length_in_bytes == 16);\n+      } else {\n+        __ sve_rbit($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                    ptrue, $src$$FloatRegister);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ The dst and src should use the same register to make sure the\n+\/\/ inactive lanes in dst save the same elements as src.\n+UNARY_OP_PREDICATE(vreverse, ReverseV, sve_rbit)\n+\n+\/\/ ------------------------------ ReverseBytesV --------------------------------\n+\n+instruct vreverseBytes(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (ReverseBytesV src));\n+  format %{ \"vreverseBytes $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      assert(length_in_bytes == 8 || length_in_bytes == 16, \"unsupported\");\n+      if (bt == T_BYTE) {\n+        if ($dst$$FloatRegister != $src$$FloatRegister) {\n+          __ orr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+                 $src$$FloatRegister, $src$$FloatRegister);\n+        }\n+      } else {\n+        __ neon_reverse_bytes($dst$$FloatRegister, $src$$FloatRegister,\n+                              bt, \/* isQ *\/ length_in_bytes == 16);\n+      }\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      if (bt == T_BYTE) {\n+        if ($dst$$FloatRegister != $src$$FloatRegister) {\n+          __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+        }\n+      } else {\n+        __ sve_revb($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                    ptrue, $src$$FloatRegister);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ The dst and src should use the same register to make sure the\n+\/\/ inactive lanes in dst save the same elements as src.\n+instruct vreverseBytes_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (ReverseBytesV dst_src pg));\n+  format %{ \"vreverseBytes_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (bt == T_BYTE) {\n+      \/\/ do nothing\n+    } else {\n+      __ sve_revb($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  $pg$$PRegister, $dst_src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Populate Index to a Vector -------------------\n+\n+instruct populateindex(vReg dst, iRegIorL2I src1, immI src2) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (PopulateIndex src1 src2));\n+  format %{ \"populateindex $dst, $src1, $src2\\t # populate index (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_index($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 $src1$$Register, (int)($src2$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Compress\/Expand Operations -------------------\n+\n+instruct mcompress(pReg dst, pReg pg, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (CompressM pg));\n+  effect(KILL cr);\n+  format %{ \"mcompress $dst, $pg\\t# KILL cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_cntp(rscratch1, size, ptrue, $pg$$PRegister);\n+    __ sve_whilelo(as_PRegister($dst$$reg), size, zr, rscratch1);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcompress(vReg dst, vReg src, pRegGov pg) %{\n+  predicate(UseSVE > 0 &&\n+            !is_subword_type(Matcher::vector_element_basic_type(n)));\n+  match(Set dst (CompressV src pg));\n+  format %{ \"vcompress $dst, $src, $pg\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_compact($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                   $src$$FloatRegister, $pg$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcompressB(vReg dst, vReg src, pReg pg, vReg tmp1, vReg tmp2,\n+                    vReg tmp3, vReg tmp4, pReg ptmp, pRegGov pgtmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n) == T_BYTE);\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP ptmp, TEMP pgtmp);\n+  match(Set dst (CompressV src pg));\n+  format %{ \"vcompressB $dst, $src, $pg\\t# KILL $tmp1, $tmp2, $tmp3, tmp4, $ptmp, $pgtmp\" %}\n+  ins_encode %{\n+    __ sve_compress_byte($dst$$FloatRegister, $src$$FloatRegister, $pg$$PRegister,\n+                         $tmp1$$FloatRegister,$tmp2$$FloatRegister,\n+                         $tmp3$$FloatRegister,$tmp4$$FloatRegister,\n+                         $ptmp$$PRegister, $pgtmp$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcompressS(vReg dst, vReg src, pReg pg,\n+                    vReg tmp1, vReg tmp2, pRegGov pgtmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n) == T_SHORT);\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP pgtmp);\n+  match(Set dst (CompressV src pg));\n+  format %{ \"vcompressS $dst, $src, $pg\\t# KILL $tmp1, $tmp2, $pgtmp\" %}\n+  ins_encode %{\n+    __ sve_compress_short($dst$$FloatRegister, $src$$FloatRegister, $pg$$PRegister,\n+                          $tmp1$$FloatRegister,$tmp2$$FloatRegister, $pgtmp$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vexpand(vReg dst, vReg src, pRegGov pg) %{\n+  match(Set dst (ExpandV src pg));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vexpand $dst, $pg, $src\" %}\n+  ins_encode %{\n+    \/\/ Example input:   src   = 1 2 3 4 5 6 7 8\n+    \/\/                  pg    = 1 0 0 1 1 0 1 1\n+    \/\/ Expected result: dst   = 4 0 0 5 6 0 7 8\n+\n+    \/\/ The basic idea is to use TBL which can shuffle the elements in the given\n+    \/\/ vector flexibly. HISTCNT + SUB is used to generate the second source input\n+    \/\/ for TBL whose value is used to select the indexed element from src vector.\n+\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    assert(UseSVE == 2 && !is_subword_type(bt), \"unsupported\");\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    \/\/ dst = 0 0 0 0 0 0 0 0\n+    __ sve_dup($dst$$FloatRegister, size, 0);\n+    \/\/ dst = 5 0 0 4 3 0 2 1\n+    __ sve_histcnt($dst$$FloatRegister, size, $pg$$PRegister,\n+                   $dst$$FloatRegister, $dst$$FloatRegister);\n+    \/\/ dst = 4 -1 -1 3 2 -1 1 0\n+    __ sve_sub($dst$$FloatRegister, size, 1);\n+    \/\/ dst = 4 0 0 5 6 0 7 8\n+    __ sve_tbl($dst$$FloatRegister, size, $src$$FloatRegister, $dst$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector signum --------------------------------\n+\n+\/\/ Vector Math.signum\n+\n+instruct vsignum_le128b(vReg dst, vReg src, vReg zero, vReg one) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16);\n+  match(Set dst (SignumVF src (Binary zero one)));\n+  match(Set dst (SignumVD src (Binary zero one)));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vsignum_le128b $dst, $src\\t# vector <= 128 bits\" %}\n+  ins_encode %{\n+    __ vector_signum_neon($dst$$FloatRegister, $src$$FloatRegister, $zero$$FloatRegister,\n+                          $one$$FloatRegister, get_arrangement(this));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsignum_gt128b(vReg dst, vReg src, vReg zero, vReg one, vReg tmp, pRegGov pgtmp) %{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16);\n+  match(Set dst (SignumVF src (Binary zero one)));\n+  match(Set dst (SignumVD src (Binary zero one)));\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP pgtmp);\n+  format %{ \"vsignum_gt128b $dst, $src\\t# vector > 128 bits. KILL $tmp, $pgtmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vector_signum_sve($dst$$FloatRegister, $src$$FloatRegister, $zero$$FloatRegister,\n+                         $one$$FloatRegister, $tmp$$FloatRegister, $pgtmp$$PRegister,\n+                         __ elemType_to_regVariant(bt));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":4734,"deletions":0,"binary":false,"changes":4734,"status":"added"},{"patch":"@@ -2569,0 +2569,1 @@\n+  INSN(facgt, 1, 1, 0b111011);\n@@ -3515,5 +3516,9 @@\n-    if (fp == 0) {                                                                     \\\n-      assert(T != Q, \"invalid size\");                                                  \\\n-    } else {                                                                           \\\n-      assert(T != B && T != Q, \"invalid size\");                                        \\\n-      assert(cond != HI && cond != HS, \"invalid condition for fcm\");                   \\\n+    assert(T != Q, \"invalid size\");                                                    \\\n+    bool is_absolute = op2 == 0b11;                                                    \\\n+    if (fp == 1) {                                                                     \\\n+      assert(T != B, \"invalid size\");                                                  \\\n+      if (is_absolute) {                                                               \\\n+        assert(cond == GT || cond == GE, \"invalid condition for fac\");                 \\\n+      } else {                                                                         \\\n+        assert(cond != HI && cond != HS, \"invalid condition for fcm\");                 \\\n+      }                                                                                \\\n@@ -3525,2 +3530,2 @@\n-      case GE: cond_op = (op2 << 2) | 0b00; break;                                     \\\n-      case GT: cond_op = (op2 << 2) | 0b01; break;                                     \\\n+      case GE: cond_op = (op2 << 2) | (is_absolute ? 0b01 : 0b00); break;              \\\n+      case GT: cond_op = (op2 << 2) | (is_absolute ? 0b11 : 0b01); break;              \\\n@@ -3536,2 +3541,3 @@\n-  INSN(sve_cmp, 0b00100100, 0b10, 0);\n-  INSN(sve_fcm, 0b01100101, 0b01, 1);\n+  INSN(sve_cmp, 0b00100100, 0b10, 0); \/\/ Integer compare vectors\n+  INSN(sve_fcm, 0b01100101, 0b01, 1); \/\/ Floating-point compare vectors\n+  INSN(sve_fac, 0b01100101, 0b11, 1); \/\/ Floating-point absolute compare vectors\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"opto\/compile.hpp\"\n@@ -1006,1 +1007,1 @@\n-      sve_extract_integral(rscratch1, D, vtmp1, idx, \/* is_signed *\/ false, vtmp2);\n+      sve_extract_integral(rscratch1, T_LONG, vtmp1, idx, vtmp2);\n@@ -1110,0 +1111,1 @@\n+\/\/ Clobbers: rflags\n@@ -1147,0 +1149,55 @@\n+\/\/ Extend integer vector src to dst with the same lane count\n+\/\/ but larger element size, e.g. 4B -> 4I\n+void C2_MacroAssembler::neon_vector_extend(FloatRegister dst, BasicType dst_bt, unsigned dst_vlen_in_bytes,\n+                                           FloatRegister src, BasicType src_bt) {\n+  if (src_bt == T_BYTE) {\n+    if (dst_bt == T_SHORT) {\n+      \/\/ 4B\/8B to 4S\/8S\n+      assert(dst_vlen_in_bytes == 8 || dst_vlen_in_bytes == 16, \"unsupported\");\n+      sxtl(dst, T8H, src, T8B);\n+    } else {\n+      \/\/ 4B to 4I\n+      assert(dst_vlen_in_bytes == 16 && dst_bt == T_INT, \"unsupported\");\n+      sxtl(dst, T8H, src, T8B);\n+      sxtl(dst, T4S, dst, T4H);\n+    }\n+  } else if (src_bt == T_SHORT) {\n+    \/\/ 4S to 4I\n+    assert(dst_vlen_in_bytes == 16 && dst_bt == T_INT, \"unsupported\");\n+    sxtl(dst, T4S, src, T4H);\n+  } else if (src_bt == T_INT) {\n+    \/\/ 2I to 2L\n+    assert(dst_vlen_in_bytes == 16 && dst_bt == T_LONG, \"unsupported\");\n+    sxtl(dst, T2D, src, T2S);\n+  } else {\n+    ShouldNotReachHere();\n+  }\n+}\n+\n+\/\/ Narrow integer vector src down to dst with the same lane count\n+\/\/ but smaller element size, e.g. 4I -> 4B\n+void C2_MacroAssembler::neon_vector_narrow(FloatRegister dst, BasicType dst_bt,\n+                                           FloatRegister src, BasicType src_bt, unsigned src_vlen_in_bytes) {\n+  if (src_bt == T_SHORT) {\n+    \/\/ 4S\/8S to 4B\/8B\n+    assert(src_vlen_in_bytes == 8 || src_vlen_in_bytes == 16, \"unsupported\");\n+    assert(dst_bt == T_BYTE, \"unsupported\");\n+    xtn(dst, T8B, src, T8H);\n+  } else if (src_bt == T_INT) {\n+    \/\/ 4I to 4B\/4S\n+    assert(src_vlen_in_bytes == 16, \"unsupported\");\n+    assert(dst_bt == T_BYTE || dst_bt == T_SHORT, \"unsupported\");\n+    xtn(dst, T4H, src, T4S);\n+    if (dst_bt == T_BYTE) {\n+      xtn(dst, T8B, dst, T8H);\n+    }\n+  } else if (src_bt == T_LONG) {\n+    \/\/ 2L to 2I\n+    assert(src_vlen_in_bytes == 16, \"unsupported\");\n+    assert(dst_bt == T_INT, \"unsupported\");\n+    xtn(dst, T2S, src, T2D);\n+  } else {\n+    ShouldNotReachHere();\n+  }\n+}\n+\n@@ -1259,0 +1316,269 @@\n+\/\/ Vector reduction add for integral type with ASIMD instructions.\n+void C2_MacroAssembler::neon_reduce_add_integral(Register dst, BasicType bt,\n+                                                 Register isrc, FloatRegister vsrc,\n+                                                 unsigned vector_length_in_bytes,\n+                                                 FloatRegister vtmp) {\n+  assert(vector_length_in_bytes == 8 || vector_length_in_bytes == 16, \"unsupported\");\n+  assert_different_registers(dst, isrc);\n+  bool isQ = vector_length_in_bytes == 16;\n+\n+  BLOCK_COMMENT(\"neon_reduce_add_integral {\");\n+    switch(bt) {\n+      case T_BYTE:\n+        addv(vtmp, isQ ? T16B : T8B, vsrc);\n+        smov(dst, vtmp, B, 0);\n+        addw(dst, dst, isrc, ext::sxtb);\n+        break;\n+      case T_SHORT:\n+        addv(vtmp, isQ ? T8H : T4H, vsrc);\n+        smov(dst, vtmp, H, 0);\n+        addw(dst, dst, isrc, ext::sxth);\n+        break;\n+      case T_INT:\n+        isQ ? addv(vtmp, T4S, vsrc) : addpv(vtmp, T2S, vsrc, vsrc);\n+        umov(dst, vtmp, S, 0);\n+        addw(dst, dst, isrc);\n+        break;\n+      case T_LONG:\n+        assert(isQ, \"unsupported\");\n+        addpd(vtmp, vsrc);\n+        umov(dst, vtmp, D, 0);\n+        add(dst, dst, isrc);\n+        break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+    }\n+  BLOCK_COMMENT(\"} neon_reduce_add_integral\");\n+}\n+\n+\/\/ Vector reduction multiply for integral type with ASIMD instructions.\n+\/\/ Note: temporary registers vtmp1 and vtmp2 are not used in some cases.\n+\/\/ Clobbers: rscratch1\n+void C2_MacroAssembler::neon_reduce_mul_integral(Register dst, BasicType bt,\n+                                                 Register isrc, FloatRegister vsrc,\n+                                                 unsigned vector_length_in_bytes,\n+                                                 FloatRegister vtmp1, FloatRegister vtmp2) {\n+  assert(vector_length_in_bytes == 8 || vector_length_in_bytes == 16, \"unsupported\");\n+  bool isQ = vector_length_in_bytes == 16;\n+\n+  BLOCK_COMMENT(\"neon_reduce_mul_integral {\");\n+    switch(bt) {\n+      case T_BYTE:\n+        if (isQ) {\n+          \/\/ Multiply the lower half and higher half of vector iteratively.\n+          \/\/ vtmp1 = vsrc[8:15]\n+          ins(vtmp1, D, vsrc, 0, 1);\n+          \/\/ vtmp1[n] = vsrc[n] * vsrc[n + 8], where n=[0, 7]\n+          mulv(vtmp1, T8B, vtmp1, vsrc);\n+          \/\/ vtmp2 = vtmp1[4:7]\n+          ins(vtmp2, S, vtmp1, 0, 1);\n+          \/\/ vtmp1[n] = vtmp1[n] * vtmp1[n + 4], where n=[0, 3]\n+          mulv(vtmp1, T8B, vtmp2, vtmp1);\n+        } else {\n+          ins(vtmp1, S, vsrc, 0, 1);\n+          mulv(vtmp1, T8B, vtmp1, vsrc);\n+        }\n+        \/\/ vtmp2 = vtmp1[2:3]\n+        ins(vtmp2, H, vtmp1, 0, 1);\n+        \/\/ vtmp2[n] = vtmp1[n] * vtmp1[n + 2], where n=[0, 1]\n+        mulv(vtmp2, T8B, vtmp2, vtmp1);\n+        \/\/ dst = vtmp2[0] * isrc * vtmp2[1]\n+        umov(rscratch1, vtmp2, B, 0);\n+        mulw(dst, rscratch1, isrc);\n+        sxtb(dst, dst);\n+        umov(rscratch1, vtmp2, B, 1);\n+        mulw(dst, rscratch1, dst);\n+        sxtb(dst, dst);\n+        break;\n+      case T_SHORT:\n+        if (isQ) {\n+          ins(vtmp2, D, vsrc, 0, 1);\n+          mulv(vtmp2, T4H, vtmp2, vsrc);\n+          ins(vtmp1, S, vtmp2, 0, 1);\n+          mulv(vtmp1, T4H, vtmp1, vtmp2);\n+        } else {\n+          ins(vtmp1, S, vsrc, 0, 1);\n+          mulv(vtmp1, T4H, vtmp1, vsrc);\n+        }\n+        umov(rscratch1, vtmp1, H, 0);\n+        mulw(dst, rscratch1, isrc);\n+        sxth(dst, dst);\n+        umov(rscratch1, vtmp1, H, 1);\n+        mulw(dst, rscratch1, dst);\n+        sxth(dst, dst);\n+        break;\n+      case T_INT:\n+        if (isQ) {\n+          ins(vtmp1, D, vsrc, 0, 1);\n+          mulv(vtmp1, T2S, vtmp1, vsrc);\n+        } else {\n+          vtmp1 = vsrc;\n+        }\n+        umov(rscratch1, vtmp1, S, 0);\n+        mul(dst, rscratch1, isrc);\n+        umov(rscratch1, vtmp1, S, 1);\n+        mul(dst, rscratch1, dst);\n+        break;\n+      case T_LONG:\n+        umov(rscratch1, vsrc, D, 0);\n+        mul(dst, isrc, rscratch1);\n+        umov(rscratch1, vsrc, D, 1);\n+        mul(dst, dst, rscratch1);\n+        break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+    }\n+  BLOCK_COMMENT(\"} neon_reduce_mul_integral\");\n+}\n+\n+\/\/ Vector reduction multiply for floating-point type with ASIMD instructions.\n+void C2_MacroAssembler::neon_reduce_mul_fp(FloatRegister dst, BasicType bt,\n+                                           FloatRegister fsrc, FloatRegister vsrc,\n+                                           unsigned vector_length_in_bytes,\n+                                           FloatRegister vtmp) {\n+  assert(vector_length_in_bytes == 8 || vector_length_in_bytes == 16, \"unsupported\");\n+  bool isQ = vector_length_in_bytes == 16;\n+\n+  BLOCK_COMMENT(\"neon_reduce_mul_fp {\");\n+    switch(bt) {\n+      case T_FLOAT:\n+        fmuls(dst, fsrc, vsrc);\n+        ins(vtmp, S, vsrc, 0, 1);\n+        fmuls(dst, dst, vtmp);\n+        if (isQ) {\n+          ins(vtmp, S, vsrc, 0, 2);\n+          fmuls(dst, dst, vtmp);\n+          ins(vtmp, S, vsrc, 0, 3);\n+          fmuls(dst, dst, vtmp);\n+         }\n+        break;\n+      case T_DOUBLE:\n+        assert(isQ, \"unsupported\");\n+        fmuld(dst, fsrc, vsrc);\n+        ins(vtmp, D, vsrc, 0, 1);\n+        fmuld(dst, dst, vtmp);\n+        break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+    }\n+  BLOCK_COMMENT(\"} neon_reduce_mul_fp\");\n+}\n+\n+\/\/ Helper to select logical instruction\n+void C2_MacroAssembler::neon_reduce_logical_helper(int opc, bool is64, Register Rd,\n+                                                   Register Rn, Register Rm,\n+                                                   enum shift_kind kind, unsigned shift) {\n+  switch(opc) {\n+    case Op_AndReductionV:\n+      is64 ? andr(Rd, Rn, Rm, kind, shift) : andw(Rd, Rn, Rm, kind, shift);\n+      break;\n+    case Op_OrReductionV:\n+      is64 ? orr(Rd, Rn, Rm, kind, shift) : orrw(Rd, Rn, Rm, kind, shift);\n+      break;\n+    case Op_XorReductionV:\n+      is64 ? eor(Rd, Rn, Rm, kind, shift) : eorw(Rd, Rn, Rm, kind, shift);\n+      break;\n+    default:\n+      assert(false, \"unsupported\");\n+      ShouldNotReachHere();\n+  }\n+}\n+\n+\/\/ Vector reduction logical operations And, Or, Xor\n+\/\/ Clobbers: rscratch1\n+void C2_MacroAssembler::neon_reduce_logical(int opc, Register dst, BasicType bt,\n+                                            Register isrc, FloatRegister vsrc,\n+                                            unsigned vector_length_in_bytes) {\n+  assert(opc == Op_AndReductionV || opc == Op_OrReductionV || opc == Op_XorReductionV,\n+         \"unsupported\");\n+  assert(vector_length_in_bytes == 8 || vector_length_in_bytes == 16, \"unsupported\");\n+  assert_different_registers(dst, isrc);\n+  bool isQ = vector_length_in_bytes == 16;\n+\n+  BLOCK_COMMENT(\"neon_reduce_logical {\");\n+    umov(rscratch1, vsrc, isQ ? D : S, 0);\n+    umov(dst, vsrc, isQ ? D : S, 1);\n+    neon_reduce_logical_helper(opc, \/* is64 *\/ true, dst, dst, rscratch1);\n+    switch(bt) {\n+      case T_BYTE:\n+        if (isQ) {\n+          neon_reduce_logical_helper(opc, \/* is64 *\/ true, dst, dst, dst, Assembler::LSR, 32);\n+        }\n+        neon_reduce_logical_helper(opc, \/* is64 *\/ false, dst, dst, dst, Assembler::LSR, 16);\n+        neon_reduce_logical_helper(opc, \/* is64 *\/ false, dst, dst, dst, Assembler::LSR, 8);\n+        neon_reduce_logical_helper(opc, \/* is64 *\/ false, dst, isrc, dst);\n+        sxtb(dst, dst);\n+        break;\n+      case T_SHORT:\n+        if (isQ) {\n+          neon_reduce_logical_helper(opc, \/* is64 *\/ true, dst, dst, dst, Assembler::LSR, 32);\n+        }\n+        neon_reduce_logical_helper(opc, \/* is64 *\/ false, dst, dst, dst, Assembler::LSR, 16);\n+        neon_reduce_logical_helper(opc, \/* is64 *\/ false, dst, isrc, dst);\n+        sxth(dst, dst);\n+        break;\n+      case T_INT:\n+        if (isQ) {\n+          neon_reduce_logical_helper(opc, \/* is64 *\/ true, dst, dst, dst, Assembler::LSR, 32);\n+        }\n+        neon_reduce_logical_helper(opc, \/* is64 *\/ false, dst, isrc, dst);\n+        break;\n+      case T_LONG:\n+        assert(isQ, \"unsupported\");\n+        neon_reduce_logical_helper(opc, \/* is64 *\/ true, dst, isrc, dst);\n+        break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+    }\n+  BLOCK_COMMENT(\"} neon_reduce_logical\");\n+}\n+\n+\/\/ Vector reduction min\/max for integral type with ASIMD instructions.\n+\/\/ Note: vtmp is not used and expected to be fnoreg for T_LONG case.\n+\/\/ Clobbers: rscratch1, rflags\n+void C2_MacroAssembler::neon_reduce_minmax_integral(int opc, Register dst, BasicType bt,\n+                                                    Register isrc, FloatRegister vsrc,\n+                                                    unsigned vector_length_in_bytes,\n+                                                    FloatRegister vtmp) {\n+  assert(opc == Op_MinReductionV || opc == Op_MaxReductionV, \"unsupported\");\n+  assert(vector_length_in_bytes == 8 || vector_length_in_bytes == 16, \"unsupported\");\n+  assert(bt == T_BYTE || bt == T_SHORT || bt == T_INT || bt == T_LONG, \"unsupported\");\n+  assert_different_registers(dst, isrc);\n+  bool isQ = vector_length_in_bytes == 16;\n+  bool is_min = opc == Op_MinReductionV;\n+\n+  BLOCK_COMMENT(\"neon_reduce_minmax_integral {\");\n+    if (bt == T_LONG) {\n+      assert(vtmp == fnoreg, \"should be\");\n+      assert(isQ, \"should be\");\n+      umov(rscratch1, vsrc, D, 0);\n+      cmp(isrc, rscratch1);\n+      csel(dst, isrc, rscratch1, is_min ? LT : GT);\n+      umov(rscratch1, vsrc, D, 1);\n+      cmp(dst, rscratch1);\n+      csel(dst, dst, rscratch1, is_min ? LT : GT);\n+    } else {\n+      SIMD_Arrangement size = esize2arrangement((unsigned)type2aelembytes(bt), isQ);\n+      if (size == T2S) {\n+        is_min ? sminp(vtmp, size, vsrc, vsrc) : smaxp(vtmp, size, vsrc, vsrc);\n+      } else {\n+        is_min ? sminv(vtmp, size, vsrc) : smaxv(vtmp, size, vsrc);\n+      }\n+      if (bt == T_INT) {\n+        umov(dst, vtmp, S, 0);\n+      } else {\n+        smov(dst, vtmp, elemType_to_regVariant(bt), 0);\n+      }\n+      cmpw(dst, isrc);\n+      cselw(dst, dst, isrc, is_min ? LT : GT);\n+    }\n+  BLOCK_COMMENT(\"} neon_reduce_minmax_integral\");\n+}\n+\n+\/\/ Vector reduction for integral type with SVE instruction.\n+\/\/ Supported operations are Add, And, Or, Xor, Max, Min.\n+\/\/ rflags would be clobbered if opc is Op_MaxReductionV or Op_MinReductionV.\n@@ -1269,1 +1595,0 @@\n-      smov(dst, tmp, size, 0);\n@@ -1271,0 +1596,1 @@\n+        smov(dst, tmp, size, 0);\n@@ -1273,0 +1599,1 @@\n+        smov(dst, tmp, size, 0);\n@@ -1275,0 +1602,1 @@\n+        umov(dst, tmp, size, 0);\n@@ -1287,1 +1615,1 @@\n-      if (bt == T_LONG) {\n+      if (bt == T_INT || bt == T_LONG) {\n@@ -1289,1 +1617,0 @@\n-        andr(dst, dst, src1);\n@@ -1292,0 +1619,4 @@\n+      }\n+      if (bt == T_LONG) {\n+        andr(dst, dst, src1);\n+      } else {\n@@ -1298,1 +1629,1 @@\n-      if (bt == T_LONG) {\n+      if (bt == T_INT || bt == T_LONG) {\n@@ -1300,1 +1631,0 @@\n-        orr(dst, dst, src1);\n@@ -1303,0 +1633,4 @@\n+      }\n+      if (bt == T_LONG) {\n+        orr(dst, dst, src1);\n+      } else {\n@@ -1309,1 +1643,1 @@\n-      if (bt == T_LONG) {\n+      if (bt == T_INT || bt == T_LONG) {\n@@ -1311,1 +1645,0 @@\n-        eor(dst, dst, src1);\n@@ -1314,0 +1647,4 @@\n+      }\n+      if (bt == T_LONG) {\n+        eor(dst, dst, src1);\n+      } else {\n@@ -1320,1 +1657,1 @@\n-      if (bt == T_LONG) {\n+      if (bt == T_INT || bt == T_LONG) {\n@@ -1322,0 +1659,4 @@\n+      } else {\n+        smov(dst, tmp, size, 0);\n+      }\n+      if (bt == T_LONG) {\n@@ -1325,1 +1666,0 @@\n-        smov(dst, tmp, size, 0);\n@@ -1333,1 +1673,1 @@\n-      if (bt == T_LONG) {\n+      if (bt == T_INT || bt == T_LONG) {\n@@ -1335,0 +1675,4 @@\n+      } else {\n+        smov(dst, tmp, size, 0);\n+      }\n+      if (bt == T_LONG) {\n@@ -1338,1 +1682,0 @@\n-        smov(dst, tmp, size, 0);\n@@ -1575,4 +1918,4 @@\n-void C2_MacroAssembler::sve_extract_integral(Register dst, SIMD_RegVariant size, FloatRegister src, int idx,\n-                                             bool is_signed, FloatRegister vtmp) {\n-  assert(UseSVE > 0 && size != Q, \"unsupported\");\n-  assert(!(is_signed && size == D), \"signed extract (D) not supported.\");\n+void C2_MacroAssembler::sve_extract_integral(Register dst, BasicType bt, FloatRegister src,\n+                                             int idx, FloatRegister vtmp) {\n+  assert(bt == T_BYTE || bt == T_SHORT || bt == T_INT || bt == T_LONG, \"unsupported element type\");\n+  Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);\n@@ -1580,1 +1923,5 @@\n-    is_signed ? smov(dst, src, size, idx) : umov(dst, src, size, idx);\n+    if (bt == T_INT || bt == T_LONG) {\n+      umov(dst, src, size, idx);\n+    } else {\n+      smov(dst, src, size, idx);\n+    }\n@@ -1584,1 +1931,5 @@\n-    is_signed ? smov(dst, vtmp, size, 0) : umov(dst, vtmp, size, 0);\n+    if (bt == T_INT || bt == T_LONG) {\n+      umov(dst, vtmp, size, 0);\n+    } else {\n+      smov(dst, vtmp, size, 0);\n+    }\n@@ -1590,0 +1941,1 @@\n+\/\/ Clobbers: rscratch1, rflags\n@@ -1591,1 +1943,1 @@\n-                                       FloatRegister tmp2, FloatRegister tmp3, SIMD_Arrangement T) {\n+                                          FloatRegister tmp2, FloatRegister tmp3, SIMD_Arrangement T) {\n@@ -1622,0 +1974,1 @@\n+\/\/ Clobbers: rscratch1, rflags\n@@ -1623,1 +1976,2 @@\n-                                      FloatRegister tmp2, PRegister ptmp, SIMD_RegVariant T) {\n+                                         FloatRegister tmp2, PRegister pgtmp, SIMD_RegVariant T) {\n+  assert(pgtmp->is_governing(), \"This register has to be a governing predicate register\");\n@@ -1634,1 +1988,1 @@\n-      assert(T == S || T == D, \"invalid arrangement\");\n+      assert(T == S || T == D, \"invalid register variant\");\n@@ -1644,1 +1998,1 @@\n-  sve_cmp(HS, ptmp, T, ptrue, tmp2, tmp1);\n+  sve_cmp(HS, pgtmp, T, ptrue, tmp2, tmp1);\n@@ -1647,3 +2001,3 @@\n-    sve_cpy(tmp1, T, ptmp, 0.5);\n-    sve_fadd(tmp1, T, ptmp, src);\n-    sve_frintm(dst, T, ptmp, tmp1);\n+    sve_cpy(tmp1, T, pgtmp, 0.5);\n+    sve_fadd(tmp1, T, pgtmp, src);\n+    sve_frintm(dst, T, pgtmp, tmp1);\n@@ -1657,0 +2011,45 @@\n+\n+void C2_MacroAssembler::vector_signum_neon(FloatRegister dst, FloatRegister src, FloatRegister zero,\n+                                           FloatRegister one, SIMD_Arrangement T) {\n+  assert_different_registers(dst, src, zero, one);\n+  assert(T == T2S || T == T4S || T == T2D, \"invalid arrangement\");\n+\n+  facgt(dst, T, src, zero);\n+  ushr(dst, T, dst, 1); \/\/ dst=0 for +-0.0 and NaN. 0x7FF..F otherwise\n+  bsl(dst, T == T2S ? T8B : T16B, one, src); \/\/ Result in dst\n+}\n+\n+void C2_MacroAssembler::vector_signum_sve(FloatRegister dst, FloatRegister src, FloatRegister zero,\n+                                          FloatRegister one, FloatRegister vtmp, PRegister pgtmp, SIMD_RegVariant T) {\n+    assert_different_registers(dst, src, zero, one, vtmp);\n+    assert(pgtmp->is_governing(), \"This register has to be a governing predicate register\");\n+\n+    sve_orr(vtmp, src, src);\n+    sve_fac(Assembler::GT, pgtmp, T, ptrue, src, zero); \/\/ pmtp=0 for +-0.0 and NaN. 0x1 otherwise\n+    switch (T) {\n+    case S:\n+      sve_and(vtmp, T, min_jint); \/\/ Extract the sign bit of float value in every lane of src\n+      sve_orr(vtmp, T, jint_cast(1.0)); \/\/ OR it with +1 to make the final result +1 or -1 depending\n+                                        \/\/ on the sign of the float value\n+      break;\n+    case D:\n+      sve_and(vtmp, T, min_jlong);\n+      sve_orr(vtmp, T, jlong_cast(1.0));\n+      break;\n+    default:\n+      assert(false, \"unsupported\");\n+      ShouldNotReachHere();\n+    }\n+    sve_sel(dst, T, pgtmp, vtmp, src); \/\/ Select either from src or vtmp based on the predicate register pgtmp\n+                                       \/\/ Result in dst\n+}\n+\n+bool C2_MacroAssembler::in_scratch_emit_size() {\n+  if (ciEnv::current()->task() != NULL) {\n+    PhaseOutput* phase_output = Compile::current()->output();\n+    if (phase_output != NULL && phase_output->in_scratch_emit_size()) {\n+      return true;\n+    }\n+  }\n+  return MacroAssembler::in_scratch_emit_size();\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":424,"deletions":25,"binary":false,"changes":449,"status":"modified"},{"patch":"@@ -30,0 +30,7 @@\n+ private:\n+  \/\/ Return true if the phase output is in the scratch emit size mode.\n+  virtual bool in_scratch_emit_size() override;\n+\n+  void neon_reduce_logical_helper(int opc, bool sf, Register Rd, Register Rn, Register Rm,\n+                                  enum shift_kind kind = Assembler::LSL, unsigned shift = 0);\n+\n@@ -83,0 +90,7 @@\n+  \/\/ Vector cast\n+  void neon_vector_extend(FloatRegister dst, BasicType dst_bt, unsigned dst_vlen_in_bytes,\n+                          FloatRegister src, BasicType src_bt);\n+\n+  void neon_vector_narrow(FloatRegister dst, BasicType dst_bt,\n+                          FloatRegister src, BasicType src_bt, unsigned src_vlen_in_bytes);\n+\n@@ -95,0 +109,21 @@\n+  \/\/ Vector reduction\n+  void neon_reduce_add_integral(Register dst, BasicType bt,\n+                                Register isrc, FloatRegister vsrc,\n+                                unsigned vector_length_in_bytes, FloatRegister vtmp);\n+\n+  void neon_reduce_mul_integral(Register dst, BasicType bt,\n+                                Register isrc, FloatRegister vsrc,\n+                                unsigned vector_length_in_bytes,\n+                                FloatRegister vtmp1, FloatRegister vtmp2);\n+\n+  void neon_reduce_mul_fp(FloatRegister dst, BasicType bt,\n+                          FloatRegister fsrc, FloatRegister vsrc,\n+                          unsigned vector_length_in_bytes, FloatRegister vtmp);\n+\n+  void neon_reduce_logical(int opc, Register dst, BasicType bt, Register isrc,\n+                           FloatRegister vsrc, unsigned vector_length_in_bytes);\n+\n+  void neon_reduce_minmax_integral(int opc, Register dst, BasicType bt,\n+                                   Register isrc, FloatRegister vsrc,\n+                                   unsigned vector_length_in_bytes, FloatRegister vtmp);\n+\n@@ -106,2 +141,2 @@\n-  void sve_extract_integral(Register dst, SIMD_RegVariant size, FloatRegister src, int idx,\n-                            bool is_signed, FloatRegister vtmp);\n+  void sve_extract_integral(Register dst, BasicType bt, FloatRegister src,\n+                            int idx, FloatRegister vtmp);\n@@ -114,1 +149,1 @@\n-                        FloatRegister tmp2, PRegister ptmp,\n+                        FloatRegister tmp2, PRegister pgtmp,\n@@ -133,0 +168,7 @@\n+  \/\/ java.lang.Math::signum intrinsics\n+  void vector_signum_neon(FloatRegister dst, FloatRegister src, FloatRegister zero,\n+                          FloatRegister one, SIMD_Arrangement T);\n+\n+  void vector_signum_sve(FloatRegister dst, FloatRegister src, FloatRegister zero,\n+                         FloatRegister one, FloatRegister vtmp, PRegister pgtmp, SIMD_RegVariant T);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":45,"deletions":3,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -29,0 +29,49 @@\n+void CodeBuffer::share_trampoline_for(address dest, int caller_offset) {\n+  if (_shared_trampoline_requests == nullptr) {\n+    constexpr unsigned init_size = 8;\n+    constexpr unsigned max_size  = 256;\n+    _shared_trampoline_requests = new SharedTrampolineRequests(init_size, max_size);\n+  }\n+\n+  bool created;\n+  Offsets* offsets = _shared_trampoline_requests->put_if_absent(dest, &created);\n+  if (created) {\n+    _shared_trampoline_requests->maybe_grow();\n+  }\n+  offsets->add(caller_offset);\n+  _finalize_stubs = true;\n+}\n+\n+static bool emit_shared_trampolines(CodeBuffer* cb, CodeBuffer::SharedTrampolineRequests* requests) {\n+  if (requests == nullptr) {\n+    return true;\n+  }\n+\n+  MacroAssembler masm(cb);\n+\n+  bool p_succeeded = true;\n+  auto emit = [&](address dest, const CodeBuffer::Offsets &offsets) {\n+    masm.set_code_section(cb->stubs());\n+    masm.align(wordSize);\n+\n+    LinkedListIterator<int> it(offsets.head());\n+    int offset = *it.next();\n+    for (; !it.is_empty(); offset = *it.next()) {\n+      masm.relocate(trampoline_stub_Relocation::spec(cb->insts()->start() + offset));\n+    }\n+    masm.set_code_section(cb->insts());\n+\n+    address stub = masm.emit_trampoline_stub(offset, dest);\n+    if (stub == nullptr) {\n+      ciEnv::current()->record_failure(\"CodeCache is full\");\n+      p_succeeded = false;\n+    }\n+\n+    return p_succeeded;\n+  };\n+\n+  requests->iterate(emit);\n+\n+  return p_succeeded;\n+}\n+\n@@ -30,1 +79,2 @@\n-  return emit_shared_stubs_to_interp<MacroAssembler>(this, _shared_stub_to_interp_requests);\n+  return emit_shared_stubs_to_interp<MacroAssembler>(this, _shared_stub_to_interp_requests)\n+      && emit_shared_trampolines(this, _shared_trampoline_requests);\n","filename":"src\/hotspot\/cpu\/aarch64\/codeBuffer_aarch64.cpp","additions":51,"deletions":1,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+  void share_trampoline_for(address dest, int caller_offset);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/codeBuffer_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"oops\/method.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationEntry_aarch64.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -217,1 +217,3 @@\n-    const int fsize = ContinuationHelper::InterpretedFrame::frame_bottom(hf) - hf.unextended_sp();\n+    \/\/ If caller is interpreted it already made room for the callee arguments\n+    int overlap = caller.is_interpreted_frame() ? ContinuationHelper::InterpretedFrame::stack_argsize(hf) : 0;\n+    const int fsize = ContinuationHelper::InterpretedFrame::frame_bottom(hf) - hf.unextended_sp() - overlap;\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationFreezeThaw_aarch64.inline.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-#include \"runtime\/synchronizer.hpp\"\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,2 +34,0 @@\n-#include \"runtime\/javaThread.hpp\"\n-#include \"runtime\/sharedRuntime.hpp\"\n@@ -37,0 +35,1 @@\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/g1\/g1BarrierSetAssembler_aarch64.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -854,2 +854,1 @@\n-address MacroAssembler::trampoline_call(Address entry, CodeBuffer* cbuf,\n-                                        bool check_emit_size) {\n+address MacroAssembler::trampoline_call(Address entry, CodeBuffer* cbuf) {\n@@ -861,0 +860,3 @@\n+  address target = entry.target();\n+\n+  \/\/ We might need a trampoline if branches are far.\n@@ -862,1 +864,1 @@\n-  if (!need_trampoline && entry.rspec().type() == relocInfo::runtime_call_type && !CodeCache::contains(entry.target())) {\n+  if (!need_trampoline && entry.rspec().type() == relocInfo::runtime_call_type && !CodeCache::contains(target)) {\n@@ -865,1 +867,0 @@\n-    address target = entry.target();\n@@ -876,1 +877,0 @@\n-  \/\/ We need a trampoline if branches are far.\n@@ -878,3 +878,1 @@\n-    bool in_scratch_emit_size = false;\n-#ifdef COMPILER2\n-    if (check_emit_size) {\n+    if (!in_scratch_emit_size()) {\n@@ -883,11 +881,9 @@\n-      CompileTask* task = ciEnv::current()->task();\n-      in_scratch_emit_size =\n-        (task != NULL && is_c2_compile(task->comp_level()) &&\n-         Compile::current()->output()->in_scratch_emit_size());\n-    }\n-#endif\n-    if (!in_scratch_emit_size) {\n-      address stub = emit_trampoline_stub(offset(), entry.target());\n-      if (stub == NULL) {\n-        postcond(pc() == badAddress);\n-        return NULL; \/\/ CodeCache is full\n+      if (entry.rspec().type() == relocInfo::runtime_call_type) {\n+        assert(CodeBuffer::supports_shared_stubs(), \"must support shared stubs\");\n+        code()->share_trampoline_for(entry.target(), offset());\n+      } else {\n+        address stub = emit_trampoline_stub(offset(), target);\n+        if (stub == NULL) {\n+          postcond(pc() == badAddress);\n+          return NULL; \/\/ CodeCache is full\n+        }\n@@ -896,0 +892,1 @@\n+    target = pc();\n@@ -900,5 +897,2 @@\n-  if (!need_trampoline) {\n-    bl(entry.target());\n-  } else {\n-    bl(pc());\n-  }\n+  bl(target);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":18,"deletions":24,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -636,0 +636,4 @@\n+  \/\/ Return whether code is emitted to a scratch blob.\n+  virtual bool in_scratch_emit_size() {\n+    return false;\n+  }\n@@ -1178,1 +1182,1 @@\n-  address trampoline_call(Address entry, CodeBuffer* cbuf = NULL, bool check_emit_size = true);\n+  address trampoline_call(Address entry, CodeBuffer* cbuf = NULL);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -55,2 +55,2 @@\n-  \/\/ No support for generic vector operands.\n-  static const bool supports_generic_vector_operands = false;\n+  \/\/ aarch64 supports generic vector operands: vReg.\n+  static const bool supports_generic_vector_operands = true;\n","filename":"src\/hotspot\/cpu\/aarch64\/matcher_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-    max_slots_per_register = 8,\n+    max_slots_per_register = 4,\n","filename":"src\/hotspot\/cpu\/aarch64\/register_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"oops\/method.inline.hpp\"\n@@ -1052,2 +1053,1 @@\n-    __ cmp(c_rarg2, (u1)0);\n-    __ br(Assembler::NE, call_thaw);\n+    __ cbnz(c_rarg2, call_thaw);\n@@ -1056,1 +1056,1 @@\n-    __ trampoline_call(resolve, \/*cbuf=*\/ NULL, \/*check_emit_size=*\/ false);\n+    __ trampoline_call(resolve);\n@@ -1078,2 +1078,1 @@\n-  __ cmp(c_rarg2, (u1)0);\n-  __ br(Assembler::NE, call_thaw);\n+  __ cbnz(c_rarg2, call_thaw);\n@@ -1082,1 +1081,1 @@\n-  __ trampoline_call(resolve, \/*cbuf=*\/ NULL, \/*check_emit_size=*\/ false);\n+  __ trampoline_call(resolve);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -58,4 +58,0 @@\n-#ifndef PRODUCT\n-#include \"oops\/method.hpp\"\n-#endif \/\/ !PRODUCT\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"runtime\/signature.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/upcallLinker_aarch64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-    decl(ASIMD,         simd,          1)     \\\n+    decl(ASIMD,         asimd,         1)     \\\n@@ -170,0 +170,6 @@\n+\n+  \/\/ For common 64\/128-bit unpredicated vector operations, we may prefer\n+  \/\/ emitting NEON instructions rather than the corresponding SVE instructions.\n+  static bool use_neon_for_vector(int vector_length_in_bytes) {\n+    return vector_length_in_bytes <= 16;\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-#include \"runtime\/synchronizer.hpp\"\n-\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-#include \"runtime\/synchronizer.hpp\"\n-\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-#include \"runtime\/synchronizer.hpp\"\n-\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-#include \"runtime\/synchronizer.hpp\"\n-\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,4 +66,4 @@\n-REGISTER_DECLARATION(Register, c_rarg0, rcx);\n-REGISTER_DECLARATION(Register, c_rarg1, rdx);\n-REGISTER_DECLARATION(Register, c_rarg2, r8);\n-REGISTER_DECLARATION(Register, c_rarg3, r9);\n+constexpr Register c_rarg0 = rcx;\n+constexpr Register c_rarg1 = rdx;\n+constexpr Register c_rarg2 =  r8;\n+constexpr Register c_rarg3 =  r9;\n@@ -71,4 +71,4 @@\n-REGISTER_DECLARATION(XMMRegister, c_farg0, xmm0);\n-REGISTER_DECLARATION(XMMRegister, c_farg1, xmm1);\n-REGISTER_DECLARATION(XMMRegister, c_farg2, xmm2);\n-REGISTER_DECLARATION(XMMRegister, c_farg3, xmm3);\n+constexpr XMMRegister c_farg0 = xmm0;\n+constexpr XMMRegister c_farg1 = xmm1;\n+constexpr XMMRegister c_farg2 = xmm2;\n+constexpr XMMRegister c_farg3 = xmm3;\n@@ -78,15 +78,15 @@\n-REGISTER_DECLARATION(Register, c_rarg0, rdi);\n-REGISTER_DECLARATION(Register, c_rarg1, rsi);\n-REGISTER_DECLARATION(Register, c_rarg2, rdx);\n-REGISTER_DECLARATION(Register, c_rarg3, rcx);\n-REGISTER_DECLARATION(Register, c_rarg4, r8);\n-REGISTER_DECLARATION(Register, c_rarg5, r9);\n-\n-REGISTER_DECLARATION(XMMRegister, c_farg0, xmm0);\n-REGISTER_DECLARATION(XMMRegister, c_farg1, xmm1);\n-REGISTER_DECLARATION(XMMRegister, c_farg2, xmm2);\n-REGISTER_DECLARATION(XMMRegister, c_farg3, xmm3);\n-REGISTER_DECLARATION(XMMRegister, c_farg4, xmm4);\n-REGISTER_DECLARATION(XMMRegister, c_farg5, xmm5);\n-REGISTER_DECLARATION(XMMRegister, c_farg6, xmm6);\n-REGISTER_DECLARATION(XMMRegister, c_farg7, xmm7);\n+constexpr Register c_rarg0 = rdi;\n+constexpr Register c_rarg1 = rsi;\n+constexpr Register c_rarg2 = rdx;\n+constexpr Register c_rarg3 = rcx;\n+constexpr Register c_rarg4 =  r8;\n+constexpr Register c_rarg5 =  r9;\n+\n+constexpr XMMRegister c_farg0 = xmm0;\n+constexpr XMMRegister c_farg1 = xmm1;\n+constexpr XMMRegister c_farg2 = xmm2;\n+constexpr XMMRegister c_farg3 = xmm3;\n+constexpr XMMRegister c_farg4 = xmm4;\n+constexpr XMMRegister c_farg5 = xmm5;\n+constexpr XMMRegister c_farg6 = xmm6;\n+constexpr XMMRegister c_farg7 = xmm7;\n@@ -112,3 +112,3 @@\n-REGISTER_DECLARATION(Register, j_rarg0, c_rarg1);\n-REGISTER_DECLARATION(Register, j_rarg1, c_rarg2);\n-REGISTER_DECLARATION(Register, j_rarg2, c_rarg3);\n+constexpr Register j_rarg0 = c_rarg1;\n+constexpr Register j_rarg1 = c_rarg2;\n+constexpr Register j_rarg2 = c_rarg3;\n@@ -117,2 +117,2 @@\n-REGISTER_DECLARATION(Register, j_rarg3, rdi);\n-REGISTER_DECLARATION(Register, j_rarg4, rsi);\n+constexpr Register j_rarg3 = rdi;\n+constexpr Register j_rarg4 = rsi;\n@@ -120,2 +120,2 @@\n-REGISTER_DECLARATION(Register, j_rarg3, c_rarg4);\n-REGISTER_DECLARATION(Register, j_rarg4, c_rarg5);\n+constexpr Register j_rarg3 = c_rarg4;\n+constexpr Register j_rarg4 = c_rarg5;\n@@ -123,1 +123,1 @@\n-REGISTER_DECLARATION(Register, j_rarg5, c_rarg0);\n+constexpr Register j_rarg5 = c_rarg0;\n@@ -125,8 +125,8 @@\n-REGISTER_DECLARATION(XMMRegister, j_farg0, xmm0);\n-REGISTER_DECLARATION(XMMRegister, j_farg1, xmm1);\n-REGISTER_DECLARATION(XMMRegister, j_farg2, xmm2);\n-REGISTER_DECLARATION(XMMRegister, j_farg3, xmm3);\n-REGISTER_DECLARATION(XMMRegister, j_farg4, xmm4);\n-REGISTER_DECLARATION(XMMRegister, j_farg5, xmm5);\n-REGISTER_DECLARATION(XMMRegister, j_farg6, xmm6);\n-REGISTER_DECLARATION(XMMRegister, j_farg7, xmm7);\n+constexpr XMMRegister j_farg0 = xmm0;\n+constexpr XMMRegister j_farg1 = xmm1;\n+constexpr XMMRegister j_farg2 = xmm2;\n+constexpr XMMRegister j_farg3 = xmm3;\n+constexpr XMMRegister j_farg4 = xmm4;\n+constexpr XMMRegister j_farg5 = xmm5;\n+constexpr XMMRegister j_farg6 = xmm6;\n+constexpr XMMRegister j_farg7 = xmm7;\n@@ -134,2 +134,2 @@\n-REGISTER_DECLARATION(Register, rscratch1, r10);  \/\/ volatile\n-REGISTER_DECLARATION(Register, rscratch2, r11);  \/\/ volatile\n+constexpr Register rscratch1 = r10;  \/\/ volatile\n+constexpr Register rscratch2 = r11;  \/\/ volatile\n@@ -137,2 +137,2 @@\n-REGISTER_DECLARATION(Register, r12_heapbase, r12); \/\/ callee-saved\n-REGISTER_DECLARATION(Register, r15_thread, r15); \/\/ callee-saved\n+constexpr Register r12_heapbase = r12; \/\/ callee-saved\n+constexpr Register r15_thread   = r15; \/\/ callee-saved\n@@ -152,1 +152,1 @@\n-REGISTER_DECLARATION(Register, rbp_mh_SP_save, noreg);\n+constexpr Register rbp_mh_SP_save = noreg;\n@@ -952,4 +952,0 @@\n-  \/\/ These are dummies to prevent surprise implicit conversions to Register\n-  void push(void* v);\n-  void pop(void* v);\n-\n@@ -1111,4 +1107,0 @@\n-  \/\/ these are dummies used to catch attempting to convert NULL to Register\n-  void cmpl(Register dst, void* junk); \/\/ dummy\n-  void cmpq(Register dst, void* junk); \/\/ dummy\n-\n@@ -1616,6 +1608,0 @@\n-  \/\/ These dummies prevent using movl from converting a zero (like NULL) into Register\n-  \/\/ by giving the compiler two choices it can't resolve\n-\n-  void movl(Address  dst, void* junk);\n-  void movl(Register dst, void* junk);\n-\n@@ -1628,6 +1614,0 @@\n-\n-  \/\/ These dummies prevent using movq from converting a zero (like NULL) into Register\n-  \/\/ by giving the compiler two choices it can't resolve\n-\n-  void movq(Address  dst, void* dummy);\n-  void movq(Register dst, void* dummy);\n@@ -1656,1 +1636,0 @@\n-  void movslq(Register dst, void* src); \/\/ Dummy declaration to cause NULL to be ambiguous\n@@ -2935,1 +2914,1 @@\n-    _embedded_opmask_register_specifier = (*mask).encoding() & 0x7;\n+    _embedded_opmask_register_specifier = mask->encoding() & 0x7;\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":45,"deletions":66,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -42,3 +42,3 @@\n-  pd_nof_cpu_regs_frame_map = RegisterImpl::number_of_registers,       \/\/ number of registers used during code emission\n-  pd_nof_fpu_regs_frame_map = FloatRegisterImpl::number_of_registers,  \/\/ number of registers used during code emission\n-  pd_nof_xmm_regs_frame_map = XMMRegisterImpl::number_of_registers,    \/\/ number of registers used during code emission\n+  pd_nof_cpu_regs_frame_map = Register::number_of_registers,       \/\/ number of registers used during code emission\n+  pd_nof_fpu_regs_frame_map = FloatRegister::number_of_registers,  \/\/ number of registers used during code emission\n+  pd_nof_xmm_regs_frame_map = XMMRegister::number_of_registers,    \/\/ number of registers used during code emission\n","filename":"src\/hotspot\/cpu\/x86\/c1_Defs_x86.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-XMMRegister FrameMap::_xmm_regs [] = { 0, };\n+XMMRegister FrameMap::_xmm_regs[] = {};\n","filename":"src\/hotspot\/cpu\/x86\/c1_FrameMap_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n-    return XMMRegisterImpl::available_xmm_registers();\n+    return XMMRegister::available_xmm_registers();\n","filename":"src\/hotspot\/cpu\/x86\/c1_FrameMap_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -322,1 +322,1 @@\n-        __ cmpptr(Address(OSR_buf, slot_offset + 1*BytesPerWord), (int32_t)NULL_WORD);\n+        __ cmpptr(Address(OSR_buf, slot_offset + 1*BytesPerWord), NULL_WORD);\n@@ -443,2 +443,2 @@\n-  __ movptr(Address(thread, JavaThread::exception_oop_offset()), (intptr_t)NULL_WORD);\n-  __ movptr(Address(thread, JavaThread::exception_pc_offset()), (intptr_t)NULL_WORD);\n+  __ movptr(Address(thread, JavaThread::exception_oop_offset()), NULL_WORD);\n+  __ movptr(Address(thread, JavaThread::exception_pc_offset()), NULL_WORD);\n@@ -736,1 +736,1 @@\n-          __ movl(as_Address(addr), (int32_t)NULL_WORD);\n+          __ movl(as_Address(addr), NULL_WORD);\n@@ -1662,1 +1662,1 @@\n-    __ cmpptr(recv_addr, (intptr_t)NULL_WORD);\n+    __ cmpptr(recv_addr, NULL_WORD);\n@@ -1714,1 +1714,1 @@\n-  __ cmpptr(obj, (int32_t)NULL_WORD);\n+  __ cmpptr(obj, NULL_WORD);\n@@ -1860,1 +1860,1 @@\n-    __ cmpptr(value, (int32_t)NULL_WORD);\n+    __ cmpptr(value, NULL_WORD);\n@@ -1956,1 +1956,1 @@\n-    assert(newval != NULL, \"new val must be register\");\n+    assert(newval != noreg, \"new val must be register\");\n@@ -1987,1 +1987,1 @@\n-    assert(newval != NULL, \"new val must be register\");\n+    assert(newval != noreg, \"new val must be register\");\n@@ -2666,1 +2666,1 @@\n-          __ cmpptr(reg1, (int32_t)0);\n+          __ cmpptr(reg1, NULL_WORD);\n@@ -2674,1 +2674,1 @@\n-          __ cmpptr(reg1, (int32_t)NULL_WORD);\n+          __ cmpptr(reg1, NULL_WORD);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-  int last_xmm_reg = pd_first_xmm_reg + XMMRegisterImpl::available_xmm_registers() - 1;\n+  int last_xmm_reg = pd_first_xmm_reg + XMMRegister::available_xmm_registers() - 1;\n","filename":"src\/hotspot\/cpu\/x86\/c1_LinearScan_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n@@ -149,2 +150,1 @@\n-  \/\/ This assumes that all prototype bits fit in an int32_t\n-  movptr(Address(obj, oopDesc::mark_offset_in_bytes ()), (int32_t)(intptr_t)markWord::prototype().value());\n+  movptr(Address(obj, oopDesc::mark_offset_in_bytes()), checked_cast<int32_t>(markWord::prototype().value()));\n@@ -256,1 +256,1 @@\n-  cmpptr(len, (int32_t)max_array_allocation_length);\n+  cmpptr(len, checked_cast<int32_t>(max_array_allocation_length));\n@@ -261,1 +261,1 @@\n-  movptr(arr_size, (int32_t)header_size * BytesPerWord + MinObjAlignmentInBytesMask);\n+  movptr(arr_size, header_size * BytesPerWord + MinObjAlignmentInBytesMask);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n@@ -113,1 +114,1 @@\n-    cmpptr(Address(thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);\n+    cmpptr(Address(thread, Thread::pending_exception_offset()), NULL_WORD);\n@@ -732,1 +733,1 @@\n-  __ cmpptr(Address(thread, JavaThread::exception_oop_offset()), (int32_t) NULL_WORD);\n+  __ cmpptr(Address(thread, JavaThread::exception_oop_offset()), NULL_WORD);\n@@ -914,1 +915,1 @@\n-    __ cmpptr(Address(thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);\n+    __ cmpptr(Address(thread, Thread::pending_exception_offset()), NULL_WORD);\n@@ -938,1 +939,1 @@\n-    __ cmpptr(Address(thread, JavaThread::exception_oop_offset()), (int32_t)NULL_WORD);\n+    __ cmpptr(Address(thread, JavaThread::exception_oop_offset()), NULL_WORD);\n@@ -944,1 +945,1 @@\n-    __ cmpptr(Address(thread, JavaThread::exception_pc_offset()), (int32_t)NULL_WORD);\n+    __ cmpptr(Address(thread, JavaThread::exception_pc_offset()), NULL_WORD);\n","filename":"src\/hotspot\/cpu\/x86\/c1_Runtime1_x86.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -414,2 +414,1 @@\n-  \/\/ Without cast to int32_t this style of movptr will destroy r10 which is typically obj.\n-  movptr(Address(boxReg, 0), (int32_t)intptr_t(markWord::unused_mark().value()));\n+  movptr(Address(boxReg, 0), checked_cast<int32_t>(markWord::unused_mark().value()));\n@@ -696,1 +695,1 @@\n-  movptr(Address(boxReg, 0), (int32_t)intptr_t(markWord::unused_mark().value()));\n+  movptr(Address(boxReg, 0), checked_cast<int32_t>(markWord::unused_mark().value()));\n@@ -791,1 +790,1 @@\n-    cmpptr(Address(boxReg, 0), (int32_t)NULL_WORD);                   \/\/ Examine the displaced header\n+    cmpptr(Address(boxReg, 0), NULL_WORD);                            \/\/ Examine the displaced header\n@@ -881,1 +880,1 @@\n-  movptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), (int32_t)NULL_WORD);\n+  movptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), NULL_WORD);\n@@ -891,1 +890,1 @@\n-  cmpptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), (int32_t)NULL_WORD);\n+  cmpptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), NULL_WORD);\n@@ -896,1 +895,1 @@\n-  movptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), (int32_t)NULL_WORD);\n+  movptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), NULL_WORD);\n@@ -907,1 +906,1 @@\n-  cmpptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), (int32_t)NULL_WORD);\n+  cmpptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), NULL_WORD);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    int delta = XMMRegisterImpl::max_slots_per_register * XMMRegisterImpl::number_of_registers;\n+    int delta = XMMRegister::max_slots_per_register * XMMRegister::number_of_registers;\n@@ -50,1 +50,1 @@\n-    int xmm_slots = XMMRegisterImpl::max_slots_per_register;\n+    int xmm_slots = XMMRegister::max_slots_per_register;\n","filename":"src\/hotspot\/cpu\/x86\/c2_init_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"oops\/method.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/continuationEntry_x86.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -214,1 +214,3 @@\n-    const int fsize = ContinuationHelper::InterpretedFrame::frame_bottom(hf) - hf.unextended_sp();\n+    \/\/ If caller is interpreted it already made room for the callee arguments\n+    int overlap = caller.is_interpreted_frame() ? ContinuationHelper::InterpretedFrame::stack_argsize(hf) : 0;\n+    const int fsize = ContinuationHelper::InterpretedFrame::frame_bottom(hf) - hf.unextended_sp() - overlap;\n","filename":"src\/hotspot\/cpu\/x86\/continuationFreezeThaw_x86.inline.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-#include \"runtime\/synchronizer.hpp\"\n-\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -207,1 +207,1 @@\n-  __ cmpptr(pre_val, (int32_t) NULL_WORD);\n+  __ cmpptr(pre_val, NULL_WORD);\n@@ -296,1 +296,1 @@\n-  __ cmpptr(new_val, (int32_t) NULL_WORD);\n+  __ cmpptr(new_val, NULL_WORD);\n@@ -311,1 +311,1 @@\n-  __ cmpb(Address(card_addr, 0), (int)G1CardTable::g1_young_card_val());\n+  __ cmpb(Address(card_addr, 0), G1CardTable::g1_young_card_val());\n@@ -315,1 +315,1 @@\n-  __ cmpb(Address(card_addr, 0), (int)G1CardTable::dirty_card_val());\n+  __ cmpb(Address(card_addr, 0), G1CardTable::dirty_card_val());\n@@ -322,1 +322,1 @@\n-  __ movb(Address(card_addr, 0), (int)G1CardTable::dirty_card_val());\n+  __ movb(Address(card_addr, 0), G1CardTable::dirty_card_val());\n@@ -423,1 +423,1 @@\n-  __ cmpptr(pre_val_reg, (int32_t)NULL_WORD);\n+  __ cmpptr(pre_val_reg, NULL_WORD);\n@@ -437,1 +437,1 @@\n-  __ cmpptr(new_val_reg, (int32_t) NULL_WORD);\n+  __ cmpptr(new_val_reg, NULL_WORD);\n@@ -536,1 +536,1 @@\n-  __ cmpb(Address(card_addr, 0), (int)G1CardTable::g1_young_card_val());\n+  __ cmpb(Address(card_addr, 0), G1CardTable::g1_young_card_val());\n@@ -540,1 +540,1 @@\n-  __ cmpb(Address(card_addr, 0), (int)CardTable::dirty_card_val());\n+  __ cmpb(Address(card_addr, 0), CardTable::dirty_card_val());\n@@ -546,1 +546,1 @@\n-  __ movb(Address(card_addr, 0), (int)CardTable::dirty_card_val());\n+  __ movb(Address(card_addr, 0), CardTable::dirty_card_val());\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1BarrierSetAssembler_x86.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-          __ movl(dst, (int32_t)NULL_WORD);\n+          __ movl(dst, NULL_WORD);\n@@ -122,1 +122,1 @@\n-          __ movslq(dst, (int32_t)NULL_WORD);\n+          __ movslq(dst, NULL_WORD);\n@@ -125,1 +125,1 @@\n-        __ movl(dst, (int32_t)NULL_WORD);\n+        __ movl(dst, NULL_WORD);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  assert(newval != NULL, \"new val must be register\");\n+  assert(newval != noreg, \"new val must be register\");\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -236,1 +236,1 @@\n-  __ cmpptr(pre_val, (int32_t) NULL_WORD);\n+  __ cmpptr(pre_val, NULL_WORD);\n@@ -817,1 +817,1 @@\n-    assert(res != NULL, \"need result register\");\n+    assert(res != noreg, \"need result register\");\n@@ -852,1 +852,1 @@\n-  __ cmpptr(pre_val_reg, (int32_t)NULL_WORD);\n+  __ cmpptr(pre_val_reg, NULL_WORD);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-                                                   NULL, $mem_ptr$$Address, $oldval$$Register, $newval$$Register,\n+                                                   noreg, $mem_ptr$$Address, $oldval$$Register, $newval$$Register,\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoah_x86_32.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-                                                   NULL, $mem_ptr$$Address, $oldval$$Register, $newval$$Register,\n+                                                   noreg, $mem_ptr$$Address, $oldval$$Register, $newval$$Register,\n@@ -107,1 +107,1 @@\n-                                                   NULL, $mem_ptr$$Address, $oldval$$Register, $newval$$Register,\n+                                                   noreg, $mem_ptr$$Address, $oldval$$Register, $newval$$Register,\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoah_x86_64.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -269,1 +269,1 @@\n-    cmpptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), (int32_t)NULL_WORD);\n+    cmpptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), NULL_WORD);\n@@ -301,1 +301,1 @@\n-    cmpptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), (int32_t)NULL_WORD);\n+    cmpptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), NULL_WORD);\n@@ -352,1 +352,1 @@\n-               movptr(oop_addr, (int32_t)NULL_WORD);\n+               movptr(oop_addr, NULL_WORD);\n@@ -366,2 +366,2 @@\n-  movl(tos_addr,  (int) ilgl);\n-  movl(val_addr,  (int32_t) NULL_WORD);\n+  movl(tos_addr, ilgl);\n+  movl(val_addr, NULL_WORD);\n@@ -389,2 +389,2 @@\n-  movl(tos_addr,  (int32_t) ilgl);\n-  movptr(val_addr,  NULL_WORD);\n+  movl(tos_addr, ilgl);\n+  movptr(val_addr, NULL_WORD);\n@@ -846,1 +846,1 @@\n-    cmpptr(rcx, (int32_t)min_frame_size);\n+    cmpptr(rcx, min_frame_size);\n@@ -1125,1 +1125,1 @@\n-    cmpptr(Address(rmon, BasicObjectLock::obj_offset_in_bytes()), (int32_t) NULL_WORD);\n+    cmpptr(Address(rmon, BasicObjectLock::obj_offset_in_bytes()), NULL_WORD);\n@@ -1228,1 +1228,1 @@\n-    movl(swap_reg, (int32_t)1);\n+    movl(swap_reg, 1);\n@@ -1330,1 +1330,1 @@\n-    movptr(Address(lock_reg, BasicObjectLock::obj_offset_in_bytes()), (int32_t)NULL_WORD);\n+    movptr(Address(lock_reg, BasicObjectLock::obj_offset_in_bytes()), NULL_WORD);\n@@ -1460,1 +1460,1 @@\n-    addptr(data, (int32_t) -DataLayout::counter_increment);\n+    addptr(data, -DataLayout::counter_increment);\n@@ -1464,1 +1464,1 @@\n-    addptr(data, (int32_t) DataLayout::counter_increment);\n+    addptr(data, DataLayout::counter_increment);\n@@ -1472,1 +1472,1 @@\n-    sbbptr(data, (int32_t)0);\n+    sbbptr(data, 0);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -179,4 +179,0 @@\n-  \/\/ These are dummies to prevent surprise implicit conversions to Register\n-  void pop(void* v); \/\/ Add unimplemented ambiguous method\n-  void push(void* v);   \/\/ Add unimplemented ambiguous method\n-\n@@ -186,1 +182,1 @@\n-    movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), (int32_t)NULL_WORD);\n+    movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), NULL_WORD);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-  __ cmpptr(Address(from(), Interpreter::local_offset_in_bytes(from_offset)), (int32_t)NULL_WORD); \/\/ do not use temp() to avoid AGI\n+  __ cmpptr(Address(from(), Interpreter::local_offset_in_bytes(from_offset)), NULL_WORD); \/\/ do not use temp() to avoid AGI\n","filename":"src\/hotspot\/cpu\/x86\/interpreterRT_x86_32.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-  if (jvmci_reg < RegisterImpl::number_of_registers) {\n+  if (jvmci_reg < Register::number_of_registers) {\n@@ -216,2 +216,2 @@\n-    jint floatRegisterNumber = jvmci_reg - RegisterImpl::number_of_registers;\n-    if (floatRegisterNumber < XMMRegisterImpl::number_of_registers) {\n+    jint floatRegisterNumber = jvmci_reg - Register::number_of_registers;\n+    if (floatRegisterNumber < XMMRegister::number_of_registers) {\n","filename":"src\/hotspot\/cpu\/x86\/jvmciCodeInstaller_x86.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -195,1 +195,1 @@\n-    mov_literal32(dst, (int32_t)src.target(), src.rspec());\n+  mov_literal32(dst, (int32_t)src.target(), src.rspec());\n@@ -201,1 +201,1 @@\n-  mov_literal32(dst, (int32_t) adr.target(), adr.rspec());\n+  mov_literal32(dst, (int32_t)adr.target(), adr.rspec());\n@@ -480,1 +480,1 @@\n-  return Address((int32_t)(intptr_t)(adr.target() - pc()), adr.target(), adr.reloc());\n+  return Address(checked_cast<int32_t>(adr.target() - pc()), adr.target(), adr.reloc());\n@@ -700,4 +700,0 @@\n-void MacroAssembler::movptr(Register dst, int32_t src) {\n-  mov64(dst, (intptr_t)src);\n-}\n-\n@@ -1065,1 +1061,1 @@\n-    cmpptr(Address(rbp, reg2offset_in(src.first())), (int32_t)NULL_WORD);\n+    cmpptr(Address(rbp, reg2offset_in(src.first())), NULL_WORD);\n@@ -1101,1 +1097,1 @@\n-    cmpptr(rOop, (int32_t)NULL_WORD);\n+    cmpptr(rOop, NULL_WORD);\n@@ -1586,1 +1582,1 @@\n-    cmpptr(Address(java_thread, Thread::pending_exception_offset()), (int32_t) NULL_WORD);\n+    cmpptr(Address(java_thread, Thread::pending_exception_offset()), NULL_WORD);\n@@ -1825,1 +1821,1 @@\n-    cmp_literal32(src1, (int32_t) src2.target(), src2.rspec());\n+    cmp_literal32(src1, (int32_t)src2.target(), src2.rspec());\n@@ -1839,1 +1835,1 @@\n-  cmp_literal32(src1, (int32_t) src2.target(), src2.rspec());\n+  cmp_literal32(src1, (int32_t)src2.target(), src2.rspec());\n@@ -3775,1 +3771,1 @@\n-  int num_xmm_registers = XMMRegisterImpl::available_xmm_registers();\n+  int num_xmm_registers = XMMRegister::available_xmm_registers();\n@@ -3816,1 +3812,1 @@\n-  gp_area_size = align_up(gp_registers.size() * RegisterImpl::max_slots_per_register * VMRegImpl::stack_slot_size,\n+  gp_area_size = align_up(gp_registers.size() * Register::max_slots_per_register * VMRegImpl::stack_slot_size,\n@@ -3909,1 +3905,1 @@\n-    int register_push_size = set.size() * RegisterImpl::max_slots_per_register * VMRegImpl::stack_slot_size;\n+    int register_push_size = set.size() * Register::max_slots_per_register * VMRegImpl::stack_slot_size;\n@@ -3919,1 +3915,1 @@\n-    spill_offset += RegisterImpl::max_slots_per_register * VMRegImpl::stack_slot_size;\n+    spill_offset += Register::max_slots_per_register * VMRegImpl::stack_slot_size;\n@@ -3925,1 +3921,1 @@\n-  int gp_reg_size = RegisterImpl::max_slots_per_register * VMRegImpl::stack_slot_size;\n+  int gp_reg_size = Register::max_slots_per_register * VMRegImpl::stack_slot_size;\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":13,"deletions":17,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -724,2 +724,2 @@\n-    if (src.is_constant()) addptr(dst, (int) src.as_constant());\n-    else                   addptr(dst,       src.as_register());\n+    if (src.is_constant()) addptr(dst, src.as_constant());\n+    else                   addptr(dst, src.as_register());\n@@ -1029,0 +1029,23 @@\n+ private:\n+  \/\/ Initialized in macroAssembler_x86_constants.cpp\n+  static address ONE;\n+  static address ONEHALF;\n+  static address SIGN_MASK;\n+  static address TWO_POW_55;\n+  static address TWO_POW_M55;\n+  static address SHIFTER;\n+  static address ZERO;\n+  static address NEG_ZERO;\n+  static address PI32INV;\n+  static address PI_INV_TABLE;\n+  static address Ctable;\n+  static address SC_1;\n+  static address SC_2;\n+  static address SC_3;\n+  static address SC_4;\n+  static address PI_4;\n+  static address P_1;\n+  static address P_3;\n+  static address P_2;\n+\n+ public:\n@@ -1043,2 +1066,1 @@\n-                Register rax, Register rbx, Register rcx, Register rdx, Register tmp1, Register tmp2,\n-                Register tmp3, Register tmp4);\n+                Register rax, Register rbx, Register rcx, Register rdx, Register tmp1);\n@@ -1055,0 +1077,9 @@\n+ private:\n+  \/\/ Initialized in macroAssembler_x86_constants.cpp\n+  static address ONES;\n+  static address L_2IL0FLOATPACKET_0;\n+  static address PI4_INV;\n+  static address PI4X3;\n+  static address PI4X4;\n+\n+ public:\n@@ -1847,1 +1878,0 @@\n-  void movptr(Register dst, int32_t imm32);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":35,"deletions":5,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-void MacroAssembler::ev_load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask=NULL) {\n+void MacroAssembler::ev_load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask) {\n@@ -61,1 +61,1 @@\n-    if (xmm_shuf_mask != NULL) {\n+    if (xmm_shuf_mask != xnoreg) {\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_aes.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,267 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"macroAssembler_x86.hpp\"\n+\n+#ifdef _LP64\n+\n+ATTRIBUTE_ALIGNED(8) juint _ONE[] = {\n+    0x00000000UL, 0x3ff00000UL\n+};\n+address MacroAssembler::ONE = (address)_ONE;\n+\n+ATTRIBUTE_ALIGNED(16) juint _ONEHALF[] = {\n+    0x00000000UL, 0x3fe00000UL, 0x00000000UL, 0x3fe00000UL\n+};\n+address MacroAssembler::ONEHALF = (address)_ONEHALF;\n+\n+ATTRIBUTE_ALIGNED(8) juint _SIGN_MASK[] = {\n+    0x00000000UL, 0x80000000UL\n+};\n+address MacroAssembler::SIGN_MASK = (address)_SIGN_MASK;\n+\n+ATTRIBUTE_ALIGNED(8) juint _TWO_POW_55[] = {\n+    0x00000000UL, 0x43600000UL\n+};\n+address MacroAssembler::TWO_POW_55 = (address)_TWO_POW_55;\n+\n+ATTRIBUTE_ALIGNED(8) juint _TWO_POW_M55[] = {\n+    0x00000000UL, 0x3c800000UL\n+};\n+address MacroAssembler::TWO_POW_M55 = (address)_TWO_POW_M55;\n+\n+ATTRIBUTE_ALIGNED(16) juint _SHIFTER[] = {\n+    0x00000000UL, 0x43380000UL, 0x00000000UL, 0x43380000UL\n+};\n+address MacroAssembler::SHIFTER = (address)_SHIFTER;\n+\n+ATTRIBUTE_ALIGNED(4) juint _ZERO[] = {\n+    0x00000000UL, 0x00000000UL\n+};\n+address MacroAssembler::ZERO = (address)_ZERO;\n+\n+ATTRIBUTE_ALIGNED(16) juint _SC_1[] = {\n+    0x55555555UL, 0xbfc55555UL, 0x00000000UL, 0xbfe00000UL\n+};\n+address MacroAssembler::SC_1 = (address)_SC_1;\n+\n+ATTRIBUTE_ALIGNED(16) juint _SC_2[] = {\n+    0x11111111UL, 0x3f811111UL, 0x55555555UL, 0x3fa55555UL\n+};\n+address MacroAssembler::SC_2 = (address)_SC_2;\n+\n+ATTRIBUTE_ALIGNED(16) juint _SC_3[] = {\n+    0x1a01a01aUL, 0xbf2a01a0UL, 0x16c16c17UL, 0xbf56c16cUL\n+};\n+address MacroAssembler::SC_3 = (address)_SC_3;\n+\n+ATTRIBUTE_ALIGNED(16) juint _SC_4[] = {\n+    0xa556c734UL, 0x3ec71de3UL, 0x1a01a01aUL, 0x3efa01a0UL\n+};\n+address MacroAssembler::SC_4 = (address)_SC_4;\n+\n+ATTRIBUTE_ALIGNED(8) juint _PI_4[] = {\n+    0x40000000UL, 0x3fe921fbUL, 0x18469899UL, 0x3e64442dUL\n+};\n+address MacroAssembler::PI_4 = (address)_PI_4;\n+\n+ATTRIBUTE_ALIGNED(8) juint _PI32INV[] = {\n+    0x6dc9c883UL, 0x40245f30UL\n+};\n+address MacroAssembler::PI32INV = (address)_PI32INV;\n+\n+ATTRIBUTE_ALIGNED(8) juint _NEG_ZERO[] = {\n+    0x00000000UL, 0x80000000UL\n+};\n+address MacroAssembler::NEG_ZERO = (address)_NEG_ZERO;\n+\n+ATTRIBUTE_ALIGNED(8) juint _P_1[] = {\n+    0x54400000UL, 0x3fb921fbUL\n+};\n+address MacroAssembler::P_1 = (address)_P_1;\n+\n+ATTRIBUTE_ALIGNED(16) juint _P_2[] = {\n+    0x1a600000UL, 0x3d90b461UL, 0x1a600000UL, 0x3d90b461UL\n+};\n+address MacroAssembler::P_2 = (address)_P_2;\n+\n+ATTRIBUTE_ALIGNED(8) juint _P_3[] = {\n+    0x2e037073UL, 0x3b63198aUL\n+};\n+address MacroAssembler::P_3 = (address)_P_3;\n+\n+\n+ATTRIBUTE_ALIGNED(16) juint _PI_INV_TABLE[] = {\n+    0x00000000UL, 0x00000000UL, 0xa2f9836eUL, 0x4e441529UL, 0xfc2757d1UL,\n+    0xf534ddc0UL, 0xdb629599UL, 0x3c439041UL, 0xfe5163abUL, 0xdebbc561UL,\n+    0xb7246e3aUL, 0x424dd2e0UL, 0x06492eeaUL, 0x09d1921cUL, 0xfe1deb1cUL,\n+    0xb129a73eUL, 0xe88235f5UL, 0x2ebb4484UL, 0xe99c7026UL, 0xb45f7e41UL,\n+    0x3991d639UL, 0x835339f4UL, 0x9c845f8bUL, 0xbdf9283bUL, 0x1ff897ffUL,\n+    0xde05980fUL, 0xef2f118bUL, 0x5a0a6d1fUL, 0x6d367ecfUL, 0x27cb09b7UL,\n+    0x4f463f66UL, 0x9e5fea2dUL, 0x7527bac7UL, 0xebe5f17bUL, 0x3d0739f7UL,\n+    0x8a5292eaUL, 0x6bfb5fb1UL, 0x1f8d5d08UL, 0x56033046UL, 0xfc7b6babUL,\n+    0xf0cfbc21UL\n+};\n+address MacroAssembler::PI_INV_TABLE = (address)_PI_INV_TABLE;\n+\n+\n+ATTRIBUTE_ALIGNED(16) juint _Ctable[] = {\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x3ff00000UL, 0x176d6d31UL, 0xbf73b92eUL,\n+    0xbc29b42cUL, 0x3fb917a6UL, 0xe0000000UL, 0xbc3e2718UL, 0x00000000UL,\n+    0x3ff00000UL, 0x011469fbUL, 0xbf93ad06UL, 0x3c69a60bUL, 0x3fc8f8b8UL,\n+    0xc0000000UL, 0xbc626d19UL, 0x00000000UL, 0x3ff00000UL, 0x939d225aUL,\n+    0xbfa60beaUL, 0x2ed59f06UL, 0x3fd29406UL, 0xa0000000UL, 0xbc75d28dUL,\n+    0x00000000UL, 0x3ff00000UL, 0x866b95cfUL, 0xbfb37ca1UL, 0xa6aea963UL,\n+    0x3fd87de2UL, 0xe0000000UL, 0xbc672cedUL, 0x00000000UL, 0x3ff00000UL,\n+    0x73fa1279UL, 0xbfbe3a68UL, 0x3806f63bUL, 0x3fde2b5dUL, 0x20000000UL,\n+    0x3c5e0d89UL, 0x00000000UL, 0x3ff00000UL, 0x5bc57974UL, 0xbfc59267UL,\n+    0x39ae68c8UL, 0x3fe1c73bUL, 0x20000000UL, 0x3c8b25ddUL, 0x00000000UL,\n+    0x3ff00000UL, 0x53aba2fdUL, 0xbfcd0dfeUL, 0x25091dd6UL, 0x3fe44cf3UL,\n+    0x20000000UL, 0x3c68076aUL, 0x00000000UL, 0x3ff00000UL, 0x99fcef32UL,\n+    0x3fca8279UL, 0x667f3bcdUL, 0x3fe6a09eUL, 0x20000000UL, 0xbc8bdd34UL,\n+    0x00000000UL, 0x3fe00000UL, 0x94247758UL, 0x3fc133ccUL, 0x6b151741UL,\n+    0x3fe8bc80UL, 0x20000000UL, 0xbc82c5e1UL, 0x00000000UL, 0x3fe00000UL,\n+    0x9ae68c87UL, 0x3fac73b3UL, 0x290ea1a3UL, 0x3fea9b66UL, 0xe0000000UL,\n+    0x3c39f630UL, 0x00000000UL, 0x3fe00000UL, 0x7f909c4eUL, 0xbf9d4a2cUL,\n+    0xf180bdb1UL, 0x3fec38b2UL, 0x80000000UL, 0xbc76e0b1UL, 0x00000000UL,\n+    0x3fe00000UL, 0x65455a75UL, 0xbfbe0875UL, 0xcf328d46UL, 0x3fed906bUL,\n+    0x20000000UL, 0x3c7457e6UL, 0x00000000UL, 0x3fe00000UL, 0x76acf82dUL,\n+    0x3fa4a031UL, 0x56c62ddaUL, 0x3fee9f41UL, 0xe0000000UL, 0x3c8760b1UL,\n+    0x00000000UL, 0x3fd00000UL, 0x0e5967d5UL, 0xbfac1d1fUL, 0xcff75cb0UL,\n+    0x3fef6297UL, 0x20000000UL, 0x3c756217UL, 0x00000000UL, 0x3fd00000UL,\n+    0x0f592f50UL, 0xbf9ba165UL, 0xa3d12526UL, 0x3fefd88dUL, 0x40000000UL,\n+    0xbc887df6UL, 0x00000000UL, 0x3fc00000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x0f592f50UL, 0x3f9ba165UL, 0xa3d12526UL, 0x3fefd88dUL,\n+    0x40000000UL, 0xbc887df6UL, 0x00000000UL, 0xbfc00000UL, 0x0e5967d5UL,\n+    0x3fac1d1fUL, 0xcff75cb0UL, 0x3fef6297UL, 0x20000000UL, 0x3c756217UL,\n+    0x00000000UL, 0xbfd00000UL, 0x76acf82dUL, 0xbfa4a031UL, 0x56c62ddaUL,\n+    0x3fee9f41UL, 0xe0000000UL, 0x3c8760b1UL, 0x00000000UL, 0xbfd00000UL,\n+    0x65455a75UL, 0x3fbe0875UL, 0xcf328d46UL, 0x3fed906bUL, 0x20000000UL,\n+    0x3c7457e6UL, 0x00000000UL, 0xbfe00000UL, 0x7f909c4eUL, 0x3f9d4a2cUL,\n+    0xf180bdb1UL, 0x3fec38b2UL, 0x80000000UL, 0xbc76e0b1UL, 0x00000000UL,\n+    0xbfe00000UL, 0x9ae68c87UL, 0xbfac73b3UL, 0x290ea1a3UL, 0x3fea9b66UL,\n+    0xe0000000UL, 0x3c39f630UL, 0x00000000UL, 0xbfe00000UL, 0x94247758UL,\n+    0xbfc133ccUL, 0x6b151741UL, 0x3fe8bc80UL, 0x20000000UL, 0xbc82c5e1UL,\n+    0x00000000UL, 0xbfe00000UL, 0x99fcef32UL, 0xbfca8279UL, 0x667f3bcdUL,\n+    0x3fe6a09eUL, 0x20000000UL, 0xbc8bdd34UL, 0x00000000UL, 0xbfe00000UL,\n+    0x53aba2fdUL, 0x3fcd0dfeUL, 0x25091dd6UL, 0x3fe44cf3UL, 0x20000000UL,\n+    0x3c68076aUL, 0x00000000UL, 0xbff00000UL, 0x5bc57974UL, 0x3fc59267UL,\n+    0x39ae68c8UL, 0x3fe1c73bUL, 0x20000000UL, 0x3c8b25ddUL, 0x00000000UL,\n+    0xbff00000UL, 0x73fa1279UL, 0x3fbe3a68UL, 0x3806f63bUL, 0x3fde2b5dUL,\n+    0x20000000UL, 0x3c5e0d89UL, 0x00000000UL, 0xbff00000UL, 0x866b95cfUL,\n+    0x3fb37ca1UL, 0xa6aea963UL, 0x3fd87de2UL, 0xe0000000UL, 0xbc672cedUL,\n+    0x00000000UL, 0xbff00000UL, 0x939d225aUL, 0x3fa60beaUL, 0x2ed59f06UL,\n+    0x3fd29406UL, 0xa0000000UL, 0xbc75d28dUL, 0x00000000UL, 0xbff00000UL,\n+    0x011469fbUL, 0x3f93ad06UL, 0x3c69a60bUL, 0x3fc8f8b8UL, 0xc0000000UL,\n+    0xbc626d19UL, 0x00000000UL, 0xbff00000UL, 0x176d6d31UL, 0x3f73b92eUL,\n+    0xbc29b42cUL, 0x3fb917a6UL, 0xe0000000UL, 0xbc3e2718UL, 0x00000000UL,\n+    0xbff00000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0xbff00000UL, 0x176d6d31UL,\n+    0x3f73b92eUL, 0xbc29b42cUL, 0xbfb917a6UL, 0xe0000000UL, 0x3c3e2718UL,\n+    0x00000000UL, 0xbff00000UL, 0x011469fbUL, 0x3f93ad06UL, 0x3c69a60bUL,\n+    0xbfc8f8b8UL, 0xc0000000UL, 0x3c626d19UL, 0x00000000UL, 0xbff00000UL,\n+    0x939d225aUL, 0x3fa60beaUL, 0x2ed59f06UL, 0xbfd29406UL, 0xa0000000UL,\n+    0x3c75d28dUL, 0x00000000UL, 0xbff00000UL, 0x866b95cfUL, 0x3fb37ca1UL,\n+    0xa6aea963UL, 0xbfd87de2UL, 0xe0000000UL, 0x3c672cedUL, 0x00000000UL,\n+    0xbff00000UL, 0x73fa1279UL, 0x3fbe3a68UL, 0x3806f63bUL, 0xbfde2b5dUL,\n+    0x20000000UL, 0xbc5e0d89UL, 0x00000000UL, 0xbff00000UL, 0x5bc57974UL,\n+    0x3fc59267UL, 0x39ae68c8UL, 0xbfe1c73bUL, 0x20000000UL, 0xbc8b25ddUL,\n+    0x00000000UL, 0xbff00000UL, 0x53aba2fdUL, 0x3fcd0dfeUL, 0x25091dd6UL,\n+    0xbfe44cf3UL, 0x20000000UL, 0xbc68076aUL, 0x00000000UL, 0xbff00000UL,\n+    0x99fcef32UL, 0xbfca8279UL, 0x667f3bcdUL, 0xbfe6a09eUL, 0x20000000UL,\n+    0x3c8bdd34UL, 0x00000000UL, 0xbfe00000UL, 0x94247758UL, 0xbfc133ccUL,\n+    0x6b151741UL, 0xbfe8bc80UL, 0x20000000UL, 0x3c82c5e1UL, 0x00000000UL,\n+    0xbfe00000UL, 0x9ae68c87UL, 0xbfac73b3UL, 0x290ea1a3UL, 0xbfea9b66UL,\n+    0xe0000000UL, 0xbc39f630UL, 0x00000000UL, 0xbfe00000UL, 0x7f909c4eUL,\n+    0x3f9d4a2cUL, 0xf180bdb1UL, 0xbfec38b2UL, 0x80000000UL, 0x3c76e0b1UL,\n+    0x00000000UL, 0xbfe00000UL, 0x65455a75UL, 0x3fbe0875UL, 0xcf328d46UL,\n+    0xbfed906bUL, 0x20000000UL, 0xbc7457e6UL, 0x00000000UL, 0xbfe00000UL,\n+    0x76acf82dUL, 0xbfa4a031UL, 0x56c62ddaUL, 0xbfee9f41UL, 0xe0000000UL,\n+    0xbc8760b1UL, 0x00000000UL, 0xbfd00000UL, 0x0e5967d5UL, 0x3fac1d1fUL,\n+    0xcff75cb0UL, 0xbfef6297UL, 0x20000000UL, 0xbc756217UL, 0x00000000UL,\n+    0xbfd00000UL, 0x0f592f50UL, 0x3f9ba165UL, 0xa3d12526UL, 0xbfefd88dUL,\n+    0x40000000UL, 0x3c887df6UL, 0x00000000UL, 0xbfc00000UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0xbff00000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x0f592f50UL, 0xbf9ba165UL, 0xa3d12526UL,\n+    0xbfefd88dUL, 0x40000000UL, 0x3c887df6UL, 0x00000000UL, 0x3fc00000UL,\n+    0x0e5967d5UL, 0xbfac1d1fUL, 0xcff75cb0UL, 0xbfef6297UL, 0x20000000UL,\n+    0xbc756217UL, 0x00000000UL, 0x3fd00000UL, 0x76acf82dUL, 0x3fa4a031UL,\n+    0x56c62ddaUL, 0xbfee9f41UL, 0xe0000000UL, 0xbc8760b1UL, 0x00000000UL,\n+    0x3fd00000UL, 0x65455a75UL, 0xbfbe0875UL, 0xcf328d46UL, 0xbfed906bUL,\n+    0x20000000UL, 0xbc7457e6UL, 0x00000000UL, 0x3fe00000UL, 0x7f909c4eUL,\n+    0xbf9d4a2cUL, 0xf180bdb1UL, 0xbfec38b2UL, 0x80000000UL, 0x3c76e0b1UL,\n+    0x00000000UL, 0x3fe00000UL, 0x9ae68c87UL, 0x3fac73b3UL, 0x290ea1a3UL,\n+    0xbfea9b66UL, 0xe0000000UL, 0xbc39f630UL, 0x00000000UL, 0x3fe00000UL,\n+    0x94247758UL, 0x3fc133ccUL, 0x6b151741UL, 0xbfe8bc80UL, 0x20000000UL,\n+    0x3c82c5e1UL, 0x00000000UL, 0x3fe00000UL, 0x99fcef32UL, 0x3fca8279UL,\n+    0x667f3bcdUL, 0xbfe6a09eUL, 0x20000000UL, 0x3c8bdd34UL, 0x00000000UL,\n+    0x3fe00000UL, 0x53aba2fdUL, 0xbfcd0dfeUL, 0x25091dd6UL, 0xbfe44cf3UL,\n+    0x20000000UL, 0xbc68076aUL, 0x00000000UL, 0x3ff00000UL, 0x5bc57974UL,\n+    0xbfc59267UL, 0x39ae68c8UL, 0xbfe1c73bUL, 0x20000000UL, 0xbc8b25ddUL,\n+    0x00000000UL, 0x3ff00000UL, 0x73fa1279UL, 0xbfbe3a68UL, 0x3806f63bUL,\n+    0xbfde2b5dUL, 0x20000000UL, 0xbc5e0d89UL, 0x00000000UL, 0x3ff00000UL,\n+    0x866b95cfUL, 0xbfb37ca1UL, 0xa6aea963UL, 0xbfd87de2UL, 0xe0000000UL,\n+    0x3c672cedUL, 0x00000000UL, 0x3ff00000UL, 0x939d225aUL, 0xbfa60beaUL,\n+    0x2ed59f06UL, 0xbfd29406UL, 0xa0000000UL, 0x3c75d28dUL, 0x00000000UL,\n+    0x3ff00000UL, 0x011469fbUL, 0xbf93ad06UL, 0x3c69a60bUL, 0xbfc8f8b8UL,\n+    0xc0000000UL, 0x3c626d19UL, 0x00000000UL, 0x3ff00000UL, 0x176d6d31UL,\n+    0xbf73b92eUL, 0xbc29b42cUL, 0xbfb917a6UL, 0xe0000000UL, 0x3c3e2718UL,\n+    0x00000000UL, 0x3ff00000UL\n+};\n+address MacroAssembler::Ctable = (address)_Ctable;\n+\n+#else \/\/ !_LP64\n+\n+ATTRIBUTE_ALIGNED(16) juint _ONES[] = {\n+    0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0xbff00000UL\n+};\n+address MacroAssembler::ONES = (address)_ONES;\n+\n+ATTRIBUTE_ALIGNED(16) juint _PI4_INV[] = {\n+    0x6dc9c883UL, 0x3ff45f30UL\n+};\n+address MacroAssembler::PI4_INV = (address)_PI4_INV;\n+\n+ATTRIBUTE_ALIGNED(16) juint _PI4X3[] = {\n+    0x54443000UL, 0xbfe921fbUL, 0x3b39a000UL, 0x3d373dcbUL, 0xe0e68948UL,\n+    0xba845c06UL\n+};\n+address MacroAssembler::PI4X3 = (address)_PI4X3;\n+\n+ATTRIBUTE_ALIGNED(16) juint _PI4X4[] = {\n+    0x54400000UL, 0xbfe921fbUL, 0x1a600000UL, 0xbdc0b461UL, 0x2e000000UL,\n+    0xbb93198aUL, 0x252049c1UL, 0xb96b839aUL\n+};\n+address MacroAssembler::PI4X4 = (address)_PI4X4;\n+\n+ATTRIBUTE_ALIGNED(16) juint _L_2IL0FLOATPACKET_0[] = {\n+    0xffffffffUL, 0x7fffffffUL, 0x00000000UL, 0x00000000UL\n+};\n+address MacroAssembler::L_2IL0FLOATPACKET_0 = (address)_L_2IL0FLOATPACKET_0;\n+\n+#endif \/\/ _LP64\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_constants.cpp","additions":267,"deletions":0,"binary":false,"changes":267,"status":"added"},{"patch":"@@ -179,5 +179,4 @@\n-ATTRIBUTE_ALIGNED(8) juint _ONE[] =\n-{\n-    0x00000000UL, 0x3ff00000UL\n-};\n-void MacroAssembler::fast_cos(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3, XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7, Register eax, Register ecx, Register edx, Register r8, Register r9, Register r10, Register r11) {\n+void MacroAssembler::fast_cos(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n+                              XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,\n+                              Register eax, Register ecx, Register edx,\n+                              Register r8, Register r9, Register r10, Register r11) {\n@@ -192,16 +191,0 @@\n-  address ONEHALF = StubRoutines::x86::_ONEHALF_addr();\n-  address P_2 = StubRoutines::x86::_P_2_addr();\n-  address SC_4 = StubRoutines::x86::_SC_4_addr();\n-  address Ctable = StubRoutines::x86::_Ctable_addr();\n-  address SC_2 = StubRoutines::x86::_SC_2_addr();\n-  address SC_3 = StubRoutines::x86::_SC_3_addr();\n-  address SC_1 = StubRoutines::x86::_SC_1_addr();\n-  address PI_INV_TABLE = StubRoutines::x86::_PI_INV_TABLE_addr();\n-  address PI_4 = (address)StubRoutines::x86::_PI_4_addr();\n-  address PI32INV = (address)StubRoutines::x86::_PI32INV_addr();\n-  address SIGN_MASK = (address)StubRoutines::x86::_SIGN_MASK_addr();\n-  address P_1 = (address)StubRoutines::x86::_P_1_addr();\n-  address P_3 = (address)StubRoutines::x86::_P_3_addr();\n-  address ONE = (address)_ONE;\n-  address NEG_ZERO = (address)StubRoutines::x86::_NEG_ZERO_addr();\n-\n@@ -443,2 +426,2 @@\n-  movq(xmm2, ExternalAddress(PI_4));    \/\/0x40000000UL, 0x3fe921fbUL, 0x18469899UL, 0x3e64442dUL\n-  movq(xmm6, ExternalAddress(8 + PI_4));    \/\/0x3fe921fbUL, 0x18469899UL, 0x3e64442dUL\n+  movq(xmm2, ExternalAddress(PI_4));     \/\/0x40000000UL, 0x3fe921fbUL, 0x18469899UL, 0x3e64442dUL\n+  movq(xmm6, ExternalAddress(PI_4 + 8)); \/\/0x3fe921fbUL, 0x18469899UL, 0x3e64442dUL\n@@ -753,1 +736,1 @@\n-\/\/          rax, rdx, rcx, rbx (tmp)\n+\/\/          eax, ecx, edx, ebx (tmp)\n@@ -757,1 +740,3 @@\n-void MacroAssembler::fast_cos(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3, XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7, Register eax, Register ecx, Register edx, Register tmp) {\n+void MacroAssembler::fast_cos(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n+                              XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,\n+                              Register eax, Register ecx, Register edx, Register tmp) {\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_cos.cpp","additions":10,"deletions":25,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -80,5 +80,0 @@\n-ATTRIBUTE_ALIGNED(16) juint _shifter[] =\n-{\n-    0x00000000UL, 0x43380000UL, 0x00000000UL, 0x43380000UL\n-};\n-\n@@ -176,9 +171,0 @@\n-ATTRIBUTE_ALIGNED(4) juint _ZERO[] =\n-{\n-    0x00000000UL, 0x00000000UL\n-};\n-\n-ATTRIBUTE_ALIGNED(4) juint _ONE_val[] =\n-{\n-    0x00000000UL, 0x3ff00000UL\n-};\n@@ -194,1 +180,3 @@\n-void MacroAssembler::fast_exp(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3, XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7, Register eax, Register ecx, Register edx, Register tmp) {\n+void MacroAssembler::fast_exp(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n+                              XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,\n+                              Register eax, Register ecx, Register edx, Register tmp) {\n@@ -198,1 +186,1 @@\n-  Label L_2TAG_PACKET_12_0_2, B1_3, B1_5, start;\n+  Label L_2TAG_PACKET_12_0_2, B1_3, B1_5;\n@@ -201,4 +189,4 @@\n-  address cv = (address)_cv;\n-  address Shifter = (address)_shifter;\n-  address mmask = (address)_mmask;\n-  address bias = (address)_bias;\n+\n+  address cv       = (address)_cv;\n+  address mmask    = (address)_mmask;\n+  address bias     = (address)_bias;\n@@ -206,9 +194,6 @@\n-  address ALLONES = (address)_ALLONES;\n-  address ebias = (address)_ebias;\n-  address XMAX = (address)_XMAX;\n-  address XMIN = (address)_XMIN;\n-  address INF = (address)_INF;\n-  address ZERO = (address)_ZERO;\n-  address ONE_val = (address)_ONE_val;\n-\n-  bind(start);\n+  address ALLONES  = (address)_ALLONES;\n+  address ebias    = (address)_ebias;\n+  address XMAX     = (address)_XMAX;\n+  address XMIN     = (address)_XMIN;\n+  address INF      = (address)_INF;\n+\n@@ -219,3 +204,3 @@\n-  movdqu(xmm6, ExternalAddress(Shifter));  \/\/ 0x00000000UL, 0x43380000UL, 0x00000000UL, 0x43380000UL\n-  movdqu(xmm2, ExternalAddress(16 + cv));    \/\/ 0xfefa0000UL, 0x3f862e42UL, 0xfefa0000UL, 0x3f862e42UL\n-  movdqu(xmm3, ExternalAddress(32 + cv));    \/\/ 0xbc9e3b3aUL, 0x3d1cf79aUL, 0xbc9e3b3aUL, 0x3d1cf79aUL\n+  movdqu(xmm2, ExternalAddress(cv + 16));  \/\/ 0xfefa0000UL, 0x3f862e42UL, 0xfefa0000UL, 0x3f862e42UL\n+  movdqu(xmm3, ExternalAddress(cv + 32));  \/\/ 0xbc9e3b3aUL, 0x3d1cf79aUL, 0xbc9e3b3aUL, 0x3d1cf79aUL\n+  movdqu(xmm6, ExternalAddress(SHIFTER));  \/\/ 0x00000000UL, 0x43380000UL, 0x00000000UL, 0x43380000UL\n@@ -395,1 +380,1 @@\n-  addsd(xmm0, ExternalAddress(ONE_val));   \/\/ 0x00000000UL, 0x3ff00000UL\n+  addsd(xmm0, ExternalAddress(ONE));   \/\/ 0x00000000UL, 0x3ff00000UL\n@@ -482,1 +467,3 @@\n-void MacroAssembler::fast_exp(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3, XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7, Register eax, Register ecx, Register edx, Register tmp) {\n+void MacroAssembler::fast_exp(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n+                              XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,\n+                              Register eax, Register ecx, Register edx, Register tmp) {\n@@ -486,1 +473,1 @@\n-  Label L_2TAG_PACKET_12_0_2, start;\n+  Label L_2TAG_PACKET_12_0_2;\n@@ -491,1 +478,0 @@\n-  bind(start);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_exp.cpp","additions":22,"deletions":36,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -186,1 +186,3 @@\n-void MacroAssembler::fast_log(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3, XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7, Register eax, Register ecx, Register edx, Register tmp1, Register tmp2) {\n+void MacroAssembler::fast_log(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n+                              XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,\n+                              Register eax, Register ecx, Register edx, Register tmp1, Register tmp2) {\n@@ -190,1 +192,1 @@\n-  Label B1_3, B1_5, start;\n+  Label B1_3, B1_5;\n@@ -194,1 +196,1 @@\n-  address log2 = (address)_log2;\n+  address log2  = (address)_log2;\n@@ -197,1 +199,0 @@\n-  bind(start);\n@@ -481,1 +482,3 @@\n-void MacroAssembler::fast_log(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3, XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7, Register eax, Register ecx, Register edx, Register tmp) {\n+void MacroAssembler::fast_log(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n+                              XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,\n+                              Register eax, Register ecx, Register edx, Register tmp) {\n@@ -485,1 +488,1 @@\n-  Label L_2TAG_PACKET_10_0_2, start;\n+  Label L_2TAG_PACKET_10_0_2;\n@@ -490,1 +493,0 @@\n-  bind(start);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_log.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -198,1 +198,3 @@\n-void MacroAssembler::fast_log10(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3, XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7, Register eax, Register ecx, Register edx, Register r11) {\n+void MacroAssembler::fast_log10(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n+                                XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,\n+                                Register eax, Register ecx, Register edx, Register r11) {\n@@ -201,1 +203,1 @@\n-  Label L_2TAG_PACKET_8_0_2, L_2TAG_PACKET_9_0_2, B1_2, B1_3, B1_5, start;\n+  Label L_2TAG_PACKET_8_0_2, L_2TAG_PACKET_9_0_2, B1_2, B1_3, B1_5;\n@@ -211,1 +213,0 @@\n-  bind(start);\n@@ -501,1 +502,3 @@\n-void MacroAssembler::fast_log10(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3, XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7, Register eax, Register ecx, Register edx, Register tmp) {\n+void MacroAssembler::fast_log10(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n+                                XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,\n+                                Register eax, Register ecx, Register edx, Register tmp) {\n@@ -505,1 +508,1 @@\n-  Label L_2TAG_PACKET_8_0_2, L_2TAG_PACKET_9_0_2, L_2TAG_PACKET_10_0_2, start;\n+  Label L_2TAG_PACKET_8_0_2, L_2TAG_PACKET_9_0_2, L_2TAG_PACKET_10_0_2;\n@@ -511,1 +514,0 @@\n-  bind(start);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_log10.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -786,1 +786,4 @@\n-void MacroAssembler::fast_pow(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3, XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7, Register eax, Register ecx, Register edx, Register tmp1, Register tmp2, Register tmp3, Register tmp4) {\n+void MacroAssembler::fast_pow(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n+                              XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,\n+                              Register eax, Register ecx, Register edx,\n+                              Register tmp1, Register tmp2, Register tmp3, Register tmp4) {\n@@ -802,1 +805,1 @@\n-  Label B1_2, B1_3, B1_5, start;\n+  Label B1_2, B1_3, B1_5;\n@@ -821,2 +824,0 @@\n-\n-  bind(start);\n@@ -2553,1 +2554,0 @@\n-  bind(start);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_pow.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  Label start, done_hash, loop0;\n+  Label done_hash, loop0;\n@@ -43,1 +43,0 @@\n-  bind(start);\n@@ -251,1 +250,1 @@\n-  Label start, done_hash, loop0;\n+  Label done_hash, loop0;\n@@ -256,1 +255,0 @@\n-  bind(start);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_sha.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -181,175 +181,0 @@\n-ATTRIBUTE_ALIGNED(16) juint StubRoutines::x86::_ONEHALF[] =\n-{\n-    0x00000000UL, 0x3fe00000UL, 0x00000000UL, 0x3fe00000UL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint StubRoutines::x86::_P_2[] =\n-{\n-    0x1a600000UL, 0x3d90b461UL, 0x1a600000UL, 0x3d90b461UL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint StubRoutines::x86::_SC_4[] =\n-{\n-    0xa556c734UL, 0x3ec71de3UL, 0x1a01a01aUL, 0x3efa01a0UL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint StubRoutines::x86::_Ctable[] =\n-{\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x3ff00000UL, 0x176d6d31UL, 0xbf73b92eUL,\n-    0xbc29b42cUL, 0x3fb917a6UL, 0xe0000000UL, 0xbc3e2718UL, 0x00000000UL,\n-    0x3ff00000UL, 0x011469fbUL, 0xbf93ad06UL, 0x3c69a60bUL, 0x3fc8f8b8UL,\n-    0xc0000000UL, 0xbc626d19UL, 0x00000000UL, 0x3ff00000UL, 0x939d225aUL,\n-    0xbfa60beaUL, 0x2ed59f06UL, 0x3fd29406UL, 0xa0000000UL, 0xbc75d28dUL,\n-    0x00000000UL, 0x3ff00000UL, 0x866b95cfUL, 0xbfb37ca1UL, 0xa6aea963UL,\n-    0x3fd87de2UL, 0xe0000000UL, 0xbc672cedUL, 0x00000000UL, 0x3ff00000UL,\n-    0x73fa1279UL, 0xbfbe3a68UL, 0x3806f63bUL, 0x3fde2b5dUL, 0x20000000UL,\n-    0x3c5e0d89UL, 0x00000000UL, 0x3ff00000UL, 0x5bc57974UL, 0xbfc59267UL,\n-    0x39ae68c8UL, 0x3fe1c73bUL, 0x20000000UL, 0x3c8b25ddUL, 0x00000000UL,\n-    0x3ff00000UL, 0x53aba2fdUL, 0xbfcd0dfeUL, 0x25091dd6UL, 0x3fe44cf3UL,\n-    0x20000000UL, 0x3c68076aUL, 0x00000000UL, 0x3ff00000UL, 0x99fcef32UL,\n-    0x3fca8279UL, 0x667f3bcdUL, 0x3fe6a09eUL, 0x20000000UL, 0xbc8bdd34UL,\n-    0x00000000UL, 0x3fe00000UL, 0x94247758UL, 0x3fc133ccUL, 0x6b151741UL,\n-    0x3fe8bc80UL, 0x20000000UL, 0xbc82c5e1UL, 0x00000000UL, 0x3fe00000UL,\n-    0x9ae68c87UL, 0x3fac73b3UL, 0x290ea1a3UL, 0x3fea9b66UL, 0xe0000000UL,\n-    0x3c39f630UL, 0x00000000UL, 0x3fe00000UL, 0x7f909c4eUL, 0xbf9d4a2cUL,\n-    0xf180bdb1UL, 0x3fec38b2UL, 0x80000000UL, 0xbc76e0b1UL, 0x00000000UL,\n-    0x3fe00000UL, 0x65455a75UL, 0xbfbe0875UL, 0xcf328d46UL, 0x3fed906bUL,\n-    0x20000000UL, 0x3c7457e6UL, 0x00000000UL, 0x3fe00000UL, 0x76acf82dUL,\n-    0x3fa4a031UL, 0x56c62ddaUL, 0x3fee9f41UL, 0xe0000000UL, 0x3c8760b1UL,\n-    0x00000000UL, 0x3fd00000UL, 0x0e5967d5UL, 0xbfac1d1fUL, 0xcff75cb0UL,\n-    0x3fef6297UL, 0x20000000UL, 0x3c756217UL, 0x00000000UL, 0x3fd00000UL,\n-    0x0f592f50UL, 0xbf9ba165UL, 0xa3d12526UL, 0x3fefd88dUL, 0x40000000UL,\n-    0xbc887df6UL, 0x00000000UL, 0x3fc00000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x0f592f50UL, 0x3f9ba165UL, 0xa3d12526UL, 0x3fefd88dUL,\n-    0x40000000UL, 0xbc887df6UL, 0x00000000UL, 0xbfc00000UL, 0x0e5967d5UL,\n-    0x3fac1d1fUL, 0xcff75cb0UL, 0x3fef6297UL, 0x20000000UL, 0x3c756217UL,\n-    0x00000000UL, 0xbfd00000UL, 0x76acf82dUL, 0xbfa4a031UL, 0x56c62ddaUL,\n-    0x3fee9f41UL, 0xe0000000UL, 0x3c8760b1UL, 0x00000000UL, 0xbfd00000UL,\n-    0x65455a75UL, 0x3fbe0875UL, 0xcf328d46UL, 0x3fed906bUL, 0x20000000UL,\n-    0x3c7457e6UL, 0x00000000UL, 0xbfe00000UL, 0x7f909c4eUL, 0x3f9d4a2cUL,\n-    0xf180bdb1UL, 0x3fec38b2UL, 0x80000000UL, 0xbc76e0b1UL, 0x00000000UL,\n-    0xbfe00000UL, 0x9ae68c87UL, 0xbfac73b3UL, 0x290ea1a3UL, 0x3fea9b66UL,\n-    0xe0000000UL, 0x3c39f630UL, 0x00000000UL, 0xbfe00000UL, 0x94247758UL,\n-    0xbfc133ccUL, 0x6b151741UL, 0x3fe8bc80UL, 0x20000000UL, 0xbc82c5e1UL,\n-    0x00000000UL, 0xbfe00000UL, 0x99fcef32UL, 0xbfca8279UL, 0x667f3bcdUL,\n-    0x3fe6a09eUL, 0x20000000UL, 0xbc8bdd34UL, 0x00000000UL, 0xbfe00000UL,\n-    0x53aba2fdUL, 0x3fcd0dfeUL, 0x25091dd6UL, 0x3fe44cf3UL, 0x20000000UL,\n-    0x3c68076aUL, 0x00000000UL, 0xbff00000UL, 0x5bc57974UL, 0x3fc59267UL,\n-    0x39ae68c8UL, 0x3fe1c73bUL, 0x20000000UL, 0x3c8b25ddUL, 0x00000000UL,\n-    0xbff00000UL, 0x73fa1279UL, 0x3fbe3a68UL, 0x3806f63bUL, 0x3fde2b5dUL,\n-    0x20000000UL, 0x3c5e0d89UL, 0x00000000UL, 0xbff00000UL, 0x866b95cfUL,\n-    0x3fb37ca1UL, 0xa6aea963UL, 0x3fd87de2UL, 0xe0000000UL, 0xbc672cedUL,\n-    0x00000000UL, 0xbff00000UL, 0x939d225aUL, 0x3fa60beaUL, 0x2ed59f06UL,\n-    0x3fd29406UL, 0xa0000000UL, 0xbc75d28dUL, 0x00000000UL, 0xbff00000UL,\n-    0x011469fbUL, 0x3f93ad06UL, 0x3c69a60bUL, 0x3fc8f8b8UL, 0xc0000000UL,\n-    0xbc626d19UL, 0x00000000UL, 0xbff00000UL, 0x176d6d31UL, 0x3f73b92eUL,\n-    0xbc29b42cUL, 0x3fb917a6UL, 0xe0000000UL, 0xbc3e2718UL, 0x00000000UL,\n-    0xbff00000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0xbff00000UL, 0x176d6d31UL,\n-    0x3f73b92eUL, 0xbc29b42cUL, 0xbfb917a6UL, 0xe0000000UL, 0x3c3e2718UL,\n-    0x00000000UL, 0xbff00000UL, 0x011469fbUL, 0x3f93ad06UL, 0x3c69a60bUL,\n-    0xbfc8f8b8UL, 0xc0000000UL, 0x3c626d19UL, 0x00000000UL, 0xbff00000UL,\n-    0x939d225aUL, 0x3fa60beaUL, 0x2ed59f06UL, 0xbfd29406UL, 0xa0000000UL,\n-    0x3c75d28dUL, 0x00000000UL, 0xbff00000UL, 0x866b95cfUL, 0x3fb37ca1UL,\n-    0xa6aea963UL, 0xbfd87de2UL, 0xe0000000UL, 0x3c672cedUL, 0x00000000UL,\n-    0xbff00000UL, 0x73fa1279UL, 0x3fbe3a68UL, 0x3806f63bUL, 0xbfde2b5dUL,\n-    0x20000000UL, 0xbc5e0d89UL, 0x00000000UL, 0xbff00000UL, 0x5bc57974UL,\n-    0x3fc59267UL, 0x39ae68c8UL, 0xbfe1c73bUL, 0x20000000UL, 0xbc8b25ddUL,\n-    0x00000000UL, 0xbff00000UL, 0x53aba2fdUL, 0x3fcd0dfeUL, 0x25091dd6UL,\n-    0xbfe44cf3UL, 0x20000000UL, 0xbc68076aUL, 0x00000000UL, 0xbff00000UL,\n-    0x99fcef32UL, 0xbfca8279UL, 0x667f3bcdUL, 0xbfe6a09eUL, 0x20000000UL,\n-    0x3c8bdd34UL, 0x00000000UL, 0xbfe00000UL, 0x94247758UL, 0xbfc133ccUL,\n-    0x6b151741UL, 0xbfe8bc80UL, 0x20000000UL, 0x3c82c5e1UL, 0x00000000UL,\n-    0xbfe00000UL, 0x9ae68c87UL, 0xbfac73b3UL, 0x290ea1a3UL, 0xbfea9b66UL,\n-    0xe0000000UL, 0xbc39f630UL, 0x00000000UL, 0xbfe00000UL, 0x7f909c4eUL,\n-    0x3f9d4a2cUL, 0xf180bdb1UL, 0xbfec38b2UL, 0x80000000UL, 0x3c76e0b1UL,\n-    0x00000000UL, 0xbfe00000UL, 0x65455a75UL, 0x3fbe0875UL, 0xcf328d46UL,\n-    0xbfed906bUL, 0x20000000UL, 0xbc7457e6UL, 0x00000000UL, 0xbfe00000UL,\n-    0x76acf82dUL, 0xbfa4a031UL, 0x56c62ddaUL, 0xbfee9f41UL, 0xe0000000UL,\n-    0xbc8760b1UL, 0x00000000UL, 0xbfd00000UL, 0x0e5967d5UL, 0x3fac1d1fUL,\n-    0xcff75cb0UL, 0xbfef6297UL, 0x20000000UL, 0xbc756217UL, 0x00000000UL,\n-    0xbfd00000UL, 0x0f592f50UL, 0x3f9ba165UL, 0xa3d12526UL, 0xbfefd88dUL,\n-    0x40000000UL, 0x3c887df6UL, 0x00000000UL, 0xbfc00000UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0xbff00000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x0f592f50UL, 0xbf9ba165UL, 0xa3d12526UL,\n-    0xbfefd88dUL, 0x40000000UL, 0x3c887df6UL, 0x00000000UL, 0x3fc00000UL,\n-    0x0e5967d5UL, 0xbfac1d1fUL, 0xcff75cb0UL, 0xbfef6297UL, 0x20000000UL,\n-    0xbc756217UL, 0x00000000UL, 0x3fd00000UL, 0x76acf82dUL, 0x3fa4a031UL,\n-    0x56c62ddaUL, 0xbfee9f41UL, 0xe0000000UL, 0xbc8760b1UL, 0x00000000UL,\n-    0x3fd00000UL, 0x65455a75UL, 0xbfbe0875UL, 0xcf328d46UL, 0xbfed906bUL,\n-    0x20000000UL, 0xbc7457e6UL, 0x00000000UL, 0x3fe00000UL, 0x7f909c4eUL,\n-    0xbf9d4a2cUL, 0xf180bdb1UL, 0xbfec38b2UL, 0x80000000UL, 0x3c76e0b1UL,\n-    0x00000000UL, 0x3fe00000UL, 0x9ae68c87UL, 0x3fac73b3UL, 0x290ea1a3UL,\n-    0xbfea9b66UL, 0xe0000000UL, 0xbc39f630UL, 0x00000000UL, 0x3fe00000UL,\n-    0x94247758UL, 0x3fc133ccUL, 0x6b151741UL, 0xbfe8bc80UL, 0x20000000UL,\n-    0x3c82c5e1UL, 0x00000000UL, 0x3fe00000UL, 0x99fcef32UL, 0x3fca8279UL,\n-    0x667f3bcdUL, 0xbfe6a09eUL, 0x20000000UL, 0x3c8bdd34UL, 0x00000000UL,\n-    0x3fe00000UL, 0x53aba2fdUL, 0xbfcd0dfeUL, 0x25091dd6UL, 0xbfe44cf3UL,\n-    0x20000000UL, 0xbc68076aUL, 0x00000000UL, 0x3ff00000UL, 0x5bc57974UL,\n-    0xbfc59267UL, 0x39ae68c8UL, 0xbfe1c73bUL, 0x20000000UL, 0xbc8b25ddUL,\n-    0x00000000UL, 0x3ff00000UL, 0x73fa1279UL, 0xbfbe3a68UL, 0x3806f63bUL,\n-    0xbfde2b5dUL, 0x20000000UL, 0xbc5e0d89UL, 0x00000000UL, 0x3ff00000UL,\n-    0x866b95cfUL, 0xbfb37ca1UL, 0xa6aea963UL, 0xbfd87de2UL, 0xe0000000UL,\n-    0x3c672cedUL, 0x00000000UL, 0x3ff00000UL, 0x939d225aUL, 0xbfa60beaUL,\n-    0x2ed59f06UL, 0xbfd29406UL, 0xa0000000UL, 0x3c75d28dUL, 0x00000000UL,\n-    0x3ff00000UL, 0x011469fbUL, 0xbf93ad06UL, 0x3c69a60bUL, 0xbfc8f8b8UL,\n-    0xc0000000UL, 0x3c626d19UL, 0x00000000UL, 0x3ff00000UL, 0x176d6d31UL,\n-    0xbf73b92eUL, 0xbc29b42cUL, 0xbfb917a6UL, 0xe0000000UL, 0x3c3e2718UL,\n-    0x00000000UL, 0x3ff00000UL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint StubRoutines::x86::_SC_2[] =\n-{\n-    0x11111111UL, 0x3f811111UL, 0x55555555UL, 0x3fa55555UL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint StubRoutines::x86::_SC_3[] =\n-{\n-    0x1a01a01aUL, 0xbf2a01a0UL, 0x16c16c17UL, 0xbf56c16cUL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint StubRoutines::x86::_SC_1[] =\n-{\n-    0x55555555UL, 0xbfc55555UL, 0x00000000UL, 0xbfe00000UL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint StubRoutines::x86::_PI_INV_TABLE[] =\n-{\n-    0x00000000UL, 0x00000000UL, 0xa2f9836eUL, 0x4e441529UL, 0xfc2757d1UL,\n-    0xf534ddc0UL, 0xdb629599UL, 0x3c439041UL, 0xfe5163abUL, 0xdebbc561UL,\n-    0xb7246e3aUL, 0x424dd2e0UL, 0x06492eeaUL, 0x09d1921cUL, 0xfe1deb1cUL,\n-    0xb129a73eUL, 0xe88235f5UL, 0x2ebb4484UL, 0xe99c7026UL, 0xb45f7e41UL,\n-    0x3991d639UL, 0x835339f4UL, 0x9c845f8bUL, 0xbdf9283bUL, 0x1ff897ffUL,\n-    0xde05980fUL, 0xef2f118bUL, 0x5a0a6d1fUL, 0x6d367ecfUL, 0x27cb09b7UL,\n-    0x4f463f66UL, 0x9e5fea2dUL, 0x7527bac7UL, 0xebe5f17bUL, 0x3d0739f7UL,\n-    0x8a5292eaUL, 0x6bfb5fb1UL, 0x1f8d5d08UL, 0x56033046UL, 0xfc7b6babUL,\n-    0xf0cfbc21UL\n-};\n-\n-ATTRIBUTE_ALIGNED(8) juint StubRoutines::x86::_PI_4[] =\n-{\n-    0x40000000UL, 0x3fe921fbUL, 0x18469899UL, 0x3e64442dUL\n-};\n-\n-ATTRIBUTE_ALIGNED(8) juint StubRoutines::x86::_PI32INV[] =\n-{\n-    0x6dc9c883UL, 0x40245f30UL\n-};\n-\n-ATTRIBUTE_ALIGNED(8) juint _SHIFTER[] =\n-{\n-    0x00000000UL, 0x43380000UL\n-};\n-\n-ATTRIBUTE_ALIGNED(8) juint StubRoutines::x86::_SIGN_MASK[] =\n-{\n-    0x00000000UL, 0x80000000UL\n-};\n-\n-ATTRIBUTE_ALIGNED(8) juint StubRoutines::x86::_P_3[] =\n-{\n-    0x2e037073UL, 0x3b63198aUL\n-};\n-\n@@ -361,21 +186,3 @@\n-ATTRIBUTE_ALIGNED(8) juint _TWO_POW_55[] =\n-{\n-    0x00000000UL, 0x43600000UL\n-};\n-\n-ATTRIBUTE_ALIGNED(8) juint _TWO_POW_M55[] =\n-{\n-    0x00000000UL, 0x3c800000UL\n-};\n-\n-ATTRIBUTE_ALIGNED(8) juint StubRoutines::x86::_P_1[] =\n-{\n-    0x54400000UL, 0x3fb921fbUL\n-};\n-\n-ATTRIBUTE_ALIGNED(8) juint StubRoutines::x86::_NEG_ZERO[] =\n-{\n-    0x00000000UL, 0x80000000UL\n-};\n-\n-void MacroAssembler::fast_sin(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3, XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7, Register eax, Register ebx, Register ecx, Register edx, Register tmp1, Register tmp2, Register tmp3, Register tmp4) {\n+void MacroAssembler::fast_sin(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n+                              XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,\n+                              Register eax, Register ebx, Register ecx, Register edx, Register tmp1) {\n@@ -386,16 +193,4 @@\n-  Label L_2TAG_PACKET_12_0_1, B1_4, start;\n-\n-  assert_different_registers(tmp1, tmp2, tmp3, tmp4, eax, ebx, ecx, edx);\n-  address ONEHALF = StubRoutines::x86::_ONEHALF_addr();\n-  address P_2 = StubRoutines::x86::_P_2_addr();\n-  address SC_4 = StubRoutines::x86::_SC_4_addr();\n-  address Ctable = StubRoutines::x86::_Ctable_addr();\n-  address SC_2 = StubRoutines::x86::_SC_2_addr();\n-  address SC_3 = StubRoutines::x86::_SC_3_addr();\n-  address SC_1 = StubRoutines::x86::_SC_1_addr();\n-  address PI_INV_TABLE = StubRoutines::x86::_PI_INV_TABLE_addr();\n-  address PI_4 = (address)StubRoutines::x86::_PI_4_addr();\n-  address PI32INV = (address)StubRoutines::x86::_PI32INV_addr();\n-  address SHIFTER = (address)_SHIFTER;\n-  address SIGN_MASK = (address)StubRoutines::x86::_SIGN_MASK_addr();\n-  address P_3 = (address)StubRoutines::x86::_P_3_addr();\n+  Label L_2TAG_PACKET_12_0_1, B1_4;\n+\n+  assert_different_registers(tmp1, eax, ebx, ecx, edx);\n+\n@@ -403,4 +198,0 @@\n-  address TWO_POW_55 = (address)_TWO_POW_55;\n-  address TWO_POW_M55 = (address)_TWO_POW_M55;\n-  address P_1 = (address)StubRoutines::x86::_P_1_addr();\n-  address NEG_ZERO = (address)StubRoutines::x86::_NEG_ZERO_addr();\n@@ -408,1 +199,0 @@\n-  bind(start);\n@@ -1627,21 +1417,0 @@\n-ATTRIBUTE_ALIGNED(16) juint StubRoutines::x86::_L_2il0floatpacket_0[] =\n-{\n-    0xffffffffUL, 0x7fffffffUL, 0x00000000UL, 0x00000000UL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint StubRoutines::x86::_Pi4Inv[] =\n-{\n-    0x6dc9c883UL, 0x3ff45f30UL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint StubRoutines::x86::_Pi4x3[] =\n-{\n-    0x54443000UL, 0xbfe921fbUL, 0x3b39a000UL, 0x3d373dcbUL, 0xe0e68948UL,\n-    0xba845c06UL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint StubRoutines::x86::_Pi4x4[] =\n-{\n-    0x54400000UL, 0xbfe921fbUL, 0x1a600000UL, 0xbdc0b461UL, 0x2e000000UL,\n-    0xbb93198aUL, 0x252049c1UL, 0xb96b839aUL\n-};\n@@ -1667,5 +1436,0 @@\n-ATTRIBUTE_ALIGNED(16) juint StubRoutines::x86::_ones[] =\n-{\n-    0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0xbff00000UL\n-};\n-\n@@ -1680,5 +1444,0 @@\n-  address L_2il0floatpacket_0 = StubRoutines::x86::_L_2il0floatpacket_0_addr();\n-  address Pi4Inv = StubRoutines::x86::_Pi4Inv_addr();\n-  address Pi4x3 = StubRoutines::x86::_Pi4x3_addr();\n-  address Pi4x4 = StubRoutines::x86::_Pi4x4_addr();\n-  address ones = StubRoutines::x86::_ones_addr();\n@@ -1709,1 +1468,1 @@\n-  andps(xmm1, ExternalAddress(L_2il0floatpacket_0));    \/\/0xffffffffUL, 0x7fffffffUL, 0x00000000UL, 0x00000000UL\n+  andps(xmm1, ExternalAddress(L_2IL0FLOATPACKET_0));    \/\/0xffffffffUL, 0x7fffffffUL, 0x00000000UL, 0x00000000UL\n@@ -1717,1 +1476,1 @@\n-  movsd(xmm0, ExternalAddress(Pi4Inv));    \/\/0x6dc9c883UL, 0x3ff45f30UL\n+  movsd(xmm0, ExternalAddress(PI4_INV));    \/\/0x6dc9c883UL, 0x3ff45f30UL\n@@ -1774,1 +1533,1 @@\n-  fld_d(ExternalAddress(Pi4x3));    \/\/0x54443000UL, 0xbfe921fbUL\n+  fld_d(ExternalAddress(PI4X3));    \/\/0x54443000UL, 0xbfe921fbUL\n@@ -1777,1 +1536,1 @@\n-  fld_d(ExternalAddress(8 + Pi4x3));    \/\/0x3b39a000UL, 0x3d373dcbUL\n+  fld_d(ExternalAddress(PI4X3 + 8));    \/\/0x3b39a000UL, 0x3d373dcbUL\n@@ -1780,1 +1539,1 @@\n-  fld_d(ExternalAddress(16 + Pi4x3));    \/\/0xe0e68948UL, 0xba845c06UL\n+  fld_d(ExternalAddress(PI4X3 + 16));    \/\/0xe0e68948UL, 0xba845c06UL\n@@ -1786,1 +1545,1 @@\n-  fld_d(ExternalAddress(Pi4x4));    \/\/0x54400000UL, 0xbfe921fbUL\n+  fld_d(ExternalAddress(PI4X4));    \/\/0x54400000UL, 0xbfe921fbUL\n@@ -1789,1 +1548,1 @@\n-  fld_d(ExternalAddress(8 + Pi4x4));    \/\/0x1a600000UL, 0xbdc0b461UL\n+  fld_d(ExternalAddress(PI4X4 + 8));    \/\/0x1a600000UL, 0xbdc0b461UL\n@@ -1792,1 +1551,1 @@\n-  fld_d(ExternalAddress(16 + Pi4x4));    \/\/0x2e000000UL, 0xbb93198aUL\n+  fld_d(ExternalAddress(PI4X4 + 16));    \/\/0x2e000000UL, 0xbb93198aUL\n@@ -1795,1 +1554,1 @@\n-  fld_d(ExternalAddress(24 + Pi4x4));    \/\/0x252049c1UL, 0xb96b839aUL\n+  fld_d(ExternalAddress(PI4X4 + 24));    \/\/0x252049c1UL, 0xb96b839aUL\n@@ -1899,2 +1658,2 @@\n-  fld_d(Address(ones, RelocationHolder::none).plus_disp(esi, Address::times_8));\n-  fld_d(Address(ones, RelocationHolder::none).plus_disp(eax, Address::times_8));\n+  fld_d(Address(ONES, RelocationHolder::none).plus_disp(esi, Address::times_8));\n+  fld_d(Address(ONES, RelocationHolder::none).plus_disp(eax, Address::times_8));\n@@ -2000,1 +1759,1 @@\n-  fld_d(Address(ones, RelocationHolder::none).plus_disp(rsi, Address::times_8));\n+  fld_d(Address(ONES, RelocationHolder::none).plus_disp(rsi, Address::times_8));\n@@ -2049,1 +1808,1 @@\n-  fld_d(Address(ones, RelocationHolder::none).plus_disp(rsi, Address::times_8));\n+  fld_d(Address(ONES, RelocationHolder::none).plus_disp(rsi, Address::times_8));\n@@ -2110,1 +1869,1 @@\n-  fld_d(Address(ones, RelocationHolder::none).plus_disp(eax, Address::times_8));\n+  fld_d(Address(ONES, RelocationHolder::none).plus_disp(eax, Address::times_8));\n@@ -2161,1 +1920,1 @@\n-  fld_d(Address(ones, RelocationHolder::none).plus_disp(eax, Address::times_8));\n+  fld_d(Address(ONES, RelocationHolder::none).plus_disp(eax, Address::times_8));\n@@ -2314,1 +2073,3 @@\n-void MacroAssembler::fast_sin(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3, XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7, Register eax, Register ebx, Register edx) {\n+void MacroAssembler::fast_sin(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n+                              XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,\n+                              Register eax, Register ebx, Register edx) {\n@@ -2317,1 +2078,2 @@\n-  Label L_2TAG_PACKET_4_0_2, start;\n+  Label L_2TAG_PACKET_4_0_2;\n+\n@@ -2319,0 +2081,1 @@\n+\n@@ -2321,1 +2084,0 @@\n-  bind(start);\n@@ -2443,1 +2205,1 @@\n-#endif\n+#endif \/\/ _LP64\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_sin.cpp","additions":29,"deletions":267,"binary":false,"changes":296,"status":"modified"},{"patch":"@@ -105,4 +105,0 @@\n-ATTRIBUTE_ALIGNED(16) juint _ONEHALF_tan[] =\n-{\n-    0x00000000UL, 0x3fe00000UL, 0x00000000UL, 0x3fe00000UL\n-};\n@@ -456,13 +452,0 @@\n-ATTRIBUTE_ALIGNED(16) juint _PI_INV_TABLE_tan[] =\n-{\n-    0x00000000UL, 0x00000000UL, 0xa2f9836eUL, 0x4e441529UL, 0xfc2757d1UL,\n-    0xf534ddc0UL, 0xdb629599UL, 0x3c439041UL, 0xfe5163abUL, 0xdebbc561UL,\n-    0xb7246e3aUL, 0x424dd2e0UL, 0x06492eeaUL, 0x09d1921cUL, 0xfe1deb1cUL,\n-    0xb129a73eUL, 0xe88235f5UL, 0x2ebb4484UL, 0xe99c7026UL, 0xb45f7e41UL,\n-    0x3991d639UL, 0x835339f4UL, 0x9c845f8bUL, 0xbdf9283bUL, 0x1ff897ffUL,\n-    0xde05980fUL, 0xef2f118bUL, 0x5a0a6d1fUL, 0x6d367ecfUL, 0x27cb09b7UL,\n-    0x4f463f66UL, 0x9e5fea2dUL, 0x7527bac7UL, 0xebe5f17bUL, 0x3d0739f7UL,\n-    0x8a5292eaUL, 0x6bfb5fb1UL, 0x1f8d5d08UL, 0x56033046UL, 0xfc7b6babUL,\n-    0xf0cfbc21UL\n-};\n-\n@@ -479,21 +462,4 @@\n-ATTRIBUTE_ALIGNED(8) juint _ONE_tan[] =\n-{\n-    0x00000000UL, 0x3ff00000UL\n-};\n-\n-ATTRIBUTE_ALIGNED(8) juint _TWO_POW_55_tan[] =\n-{\n-    0x00000000UL, 0x43600000UL\n-};\n-\n-ATTRIBUTE_ALIGNED(4) juint _TWO_POW_M55_tan[] =\n-{\n-    0x00000000UL, 0x3c800000UL\n-};\n-\n-ATTRIBUTE_ALIGNED(4) juint _NEG_ZERO_tan[] =\n-{\n-    0x00000000UL, 0x80000000UL\n-};\n-\n-void MacroAssembler::fast_tan(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3, XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7, Register eax, Register ecx, Register edx, Register r8, Register r9, Register r10, Register r11) {\n+void MacroAssembler::fast_tan(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n+                              XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,\n+                              Register eax, Register ecx, Register edx, Register r8, Register r9,\n+                              Register r10, Register r11) {\n@@ -504,1 +470,3 @@\n-  Label L_2TAG_PACKET_12_0_1, L_2TAG_PACKET_13_0_1, L_2TAG_PACKET_14_0_1, B1_2, B1_4, start;\n+  Label L_2TAG_PACKET_12_0_1, L_2TAG_PACKET_13_0_1, L_2TAG_PACKET_14_0_1, B1_2, B1_4;\n+\n+  assert_different_registers(eax, ecx, edx, r8, r9, r10, r11);\n@@ -506,2 +474,1 @@\n-  address ONEHALF = (address)_ONEHALF_tan;\n-  address MUL16 = (address)_MUL16;\n+  address MUL16     = (address)_MUL16;\n@@ -509,20 +476,14 @@\n-  address PI32INV = (address)_PI32INV_tan;\n-  address P_1 = (address)_P_1_tan;\n-  address P_2 = (address)_P_2_tan;\n-  address P_3 = (address)_P_3_tan;\n-  address Ctable = (address)_Ctable_tan;\n-  address MASK_35 = (address)_MASK_35_tan;\n-  address Q_11 = (address)_Q_11_tan;\n-  address Q_9 = (address)_Q_9_tan;\n-  address Q_7 = (address)_Q_7_tan;\n-  address Q_5 = (address)_Q_5_tan;\n-  address Q_3 = (address)_Q_3_tan;\n-  address PI_INV_TABLE = (address)_PI_INV_TABLE_tan;\n-  address PI_4 = (address)_PI_4_tan;\n-  address QQ_2 = (address)_QQ_2_tan;\n-  address ONE = (address)_ONE_tan;\n-  address TWO_POW_55 = (address)_TWO_POW_55_tan;\n-  address TWO_POW_M55 = (address)_TWO_POW_M55_tan;\n-  address NEG_ZERO = (address)_NEG_ZERO_tan;\n-\n-  bind(start);\n+  address PI32INV   = (address)_PI32INV_tan;\n+  address P_1       = (address)_P_1_tan;\n+  address P_2       = (address)_P_2_tan;\n+  address P_3       = (address)_P_3_tan;\n+  address Ctable    = (address)_Ctable_tan;\n+  address MASK_35   = (address)_MASK_35_tan;\n+  address Q_11      = (address)_Q_11_tan;\n+  address Q_9       = (address)_Q_9_tan;\n+  address Q_7       = (address)_Q_7_tan;\n+  address Q_5       = (address)_Q_5_tan;\n+  address Q_3       = (address)_Q_3_tan;\n+  address PI_4      = (address)_PI_4_tan;\n+  address QQ_2      = (address)_QQ_2_tan;\n+\n@@ -1062,0 +1023,1 @@\n+\n@@ -1096,5 +1058,0 @@\n-  address L_2il0floatpacket_0 = StubRoutines::x86::_L_2il0floatpacket_0_addr();\n-  address Pi4Inv = StubRoutines::x86::_Pi4Inv_addr();\n-  address Pi4x3 = StubRoutines::x86::_Pi4x3_addr();\n-  address Pi4x4 = StubRoutines::x86::_Pi4x4_addr();\n-  address ones = StubRoutines::x86::_ones_addr();\n@@ -1134,1 +1091,1 @@\n-  andps(xmm1, ExternalAddress(L_2il0floatpacket_0));    \/\/0xffffffffUL, 0x7fffffffUL, 0x00000000UL, 0x00000000UL\n+  andps(xmm1, ExternalAddress(L_2IL0FLOATPACKET_0));    \/\/0xffffffffUL, 0x7fffffffUL, 0x00000000UL, 0x00000000UL\n@@ -1136,1 +1093,1 @@\n-  movsd(xmm0, ExternalAddress(Pi4Inv));    \/\/\/\/0x6dc9c883UL, 0x3ff45f30UL\n+  movsd(xmm0, ExternalAddress(PI4_INV));    \/\/\/\/0x6dc9c883UL, 0x3ff45f30UL\n@@ -1191,1 +1148,1 @@\n-  fld_d(ExternalAddress(Pi4x3));    \/\/0x54443000UL, 0xbfe921fbUL\n+  fld_d(ExternalAddress(PI4X3));    \/\/0x54443000UL, 0xbfe921fbUL\n@@ -1194,1 +1151,1 @@\n-  fld_d(ExternalAddress(8 + Pi4x3));    \/\/0x3b39a000UL, 0x3d373dcbUL\n+  fld_d(ExternalAddress(PI4X3 + 8));    \/\/0x3b39a000UL, 0x3d373dcbUL\n@@ -1197,1 +1154,1 @@\n-  fld_d(ExternalAddress(16 + Pi4x3));    \/\/0xe0e68948UL, 0xba845c06UL\n+  fld_d(ExternalAddress(PI4X3 + 16));    \/\/0xe0e68948UL, 0xba845c06UL\n@@ -1203,1 +1160,1 @@\n-  fld_d(ExternalAddress(Pi4x4));    \/\/0x54400000UL, 0xbfe921fbUL\n+  fld_d(ExternalAddress(PI4X4));    \/\/0x54400000UL, 0xbfe921fbUL\n@@ -1206,1 +1163,1 @@\n-  fld_d(ExternalAddress(8 + Pi4x4));    \/\/0x1a600000UL, 0xbdc0b461UL\n+  fld_d(ExternalAddress(PI4X4 + 8));    \/\/0x1a600000UL, 0xbdc0b461UL\n@@ -1209,1 +1166,1 @@\n-  fld_d(ExternalAddress(16 + Pi4x4));    \/\/0x2e000000UL, 0xbb93198aUL\n+  fld_d(ExternalAddress(PI4X4 + 16));    \/\/0x2e000000UL, 0xbb93198aUL\n@@ -1212,1 +1169,1 @@\n-  fld_d(ExternalAddress(24 + Pi4x4));    \/\/0x252049c1UL, 0xb96b839aUL\n+  fld_d(ExternalAddress(PI4X4 + 24));    \/\/0x252049c1UL, 0xb96b839aUL\n@@ -1237,1 +1194,1 @@\n-  andps(xmm0, ExternalAddress(L_2il0floatpacket_0));    \/\/0xffffffffUL, 0x7fffffffUL, 0x00000000UL, 0x00000000UL\n+  andps(xmm0, ExternalAddress(L_2IL0FLOATPACKET_0));    \/\/0xffffffffUL, 0x7fffffffUL, 0x00000000UL, 0x00000000UL\n@@ -1262,1 +1219,1 @@\n-  fld_d(ExternalAddress(ones));\n+  fld_d(ExternalAddress(ONES));\n@@ -1348,1 +1305,1 @@\n-  fld_d(Address(ones, RelocationHolder::none).plus_disp(eax, Address::times_8));\n+  fld_d(Address(ONES, RelocationHolder::none).plus_disp(eax, Address::times_8));\n@@ -1370,1 +1327,1 @@\n-  fld_d(Address(ones, RelocationHolder::none).plus_disp(eax, Address::times_8));\n+  fld_d(Address(ONES, RelocationHolder::none).plus_disp(eax, Address::times_8));\n@@ -1415,1 +1372,1 @@\n-  fld_d(ExternalAddress(ones));\n+  fld_d(ExternalAddress(ONES));\n@@ -1467,1 +1424,1 @@\n-  fld_d(Address(ones, RelocationHolder::none).plus_disp(eax, Address::times_8));\n+  fld_d(Address(ONES, RelocationHolder::none).plus_disp(eax, Address::times_8));\n@@ -1501,1 +1458,1 @@\n-  fld_d(Address(ones, RelocationHolder::none).plus_disp(eax, Address::times_8));\n+  fld_d(Address(ONES, RelocationHolder::none).plus_disp(eax, Address::times_8));\n@@ -1564,1 +1521,1 @@\n-  fld_d(Address(ones, RelocationHolder::none).plus_disp(eax, Address::times_8));\n+  fld_d(Address(ONES, RelocationHolder::none).plus_disp(eax, Address::times_8));\n@@ -1573,1 +1530,1 @@\n-  fld_d(ExternalAddress(ones));\n+  fld_d(ExternalAddress(ONES));\n@@ -1624,1 +1581,1 @@\n-  fld_d(Address(ones, RelocationHolder::none).plus_disp(eax, Address::times_8));\n+  fld_d(Address(ONES, RelocationHolder::none).plus_disp(eax, Address::times_8));\n@@ -1970,1 +1927,0 @@\n-  Label start;\n@@ -1976,1 +1932,0 @@\n-  bind(start);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_tan.cpp","additions":42,"deletions":87,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -534,1 +534,1 @@\n-    const int saved_regs_count = RegisterImpl::number_of_registers;\n+    const int saved_regs_count = Register::number_of_registers;\n@@ -539,1 +539,1 @@\n-      assert(RegisterImpl::number_of_registers == 16, \"sanity\");\n+      assert(Register::number_of_registers == 16, \"sanity\");\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-    int base_reg_enc = (reg_base \/ XMMRegisterImpl::max_slots_per_register);\n-    assert(base_reg_enc >= 0 && base_reg_enc < XMMRegisterImpl::number_of_registers, \"invalid XMMRegister: %d\", base_reg_enc);\n+    int base_reg_enc = (reg_base \/ XMMRegister::max_slots_per_register);\n+    assert(base_reg_enc >= 0 && base_reg_enc < XMMRegister::number_of_registers, \"invalid XMMRegister: %d\", base_reg_enc);\n","filename":"src\/hotspot\/cpu\/x86\/registerMap_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,4 +29,4 @@\n-REGISTER_IMPL_DEFINITION(Register, RegisterImpl, RegisterImpl::number_of_registers);\n-REGISTER_IMPL_DEFINITION(FloatRegister, FloatRegisterImpl, FloatRegisterImpl::number_of_registers);\n-REGISTER_IMPL_DEFINITION(XMMRegister, XMMRegisterImpl, XMMRegisterImpl::number_of_registers);\n-REGISTER_IMPL_DEFINITION(KRegister, KRegisterImpl, KRegisterImpl::number_of_registers);\n+Register::RegisterImpl           all_RegisterImpls     [Register::number_of_registers      + 1];\n+FloatRegister::FloatRegisterImpl all_FloatRegisterImpls[FloatRegister::number_of_registers + 1];\n+XMMRegister::XMMRegisterImpl     all_XMMRegisterImpls  [XMMRegister::number_of_registers   + 1];\n+KRegister::KRegisterImpl         all_KRegisterImpls    [KRegister::number_of_registers     + 1];\n@@ -34,14 +34,1 @@\n-#ifndef AMD64\n-const int ConcreteRegisterImpl::max_gpr = RegisterImpl::number_of_registers;\n-#else\n-const int ConcreteRegisterImpl::max_gpr = RegisterImpl::number_of_registers << 1;\n-#endif \/\/ AMD64\n-\n-const int ConcreteRegisterImpl::max_fpr = ConcreteRegisterImpl::max_gpr +\n-    2 * FloatRegisterImpl::number_of_registers;\n-const int ConcreteRegisterImpl::max_xmm = ConcreteRegisterImpl::max_fpr +\n-    XMMRegisterImpl::max_slots_per_register * XMMRegisterImpl::number_of_registers;\n-const int ConcreteRegisterImpl::max_kpr = ConcreteRegisterImpl::max_xmm +\n-    KRegisterImpl::max_slots_per_register * KRegisterImpl::number_of_registers;\n-\n-const char* RegisterImpl::name() const {\n+const char * Register::RegisterImpl::name() const {\n@@ -49,3 +36,1 @@\n-#ifndef AMD64\n-    \"eax\", \"ecx\", \"edx\", \"ebx\", \"esp\", \"ebp\", \"esi\", \"edi\"\n-#else\n+#ifdef _LP64\n@@ -54,1 +39,3 @@\n-#endif \/\/ AMD64\n+#else\n+    \"eax\", \"ecx\", \"edx\", \"ebx\", \"esp\", \"ebp\", \"esi\", \"edi\"\n+#endif \/\/ _LP64\n@@ -59,1 +46,1 @@\n-const char* FloatRegisterImpl::name() const {\n+const char* FloatRegister::FloatRegisterImpl::name() const {\n@@ -63,1 +50,1 @@\n-  return is_valid() ? names[encoding()] : \"noreg\";\n+  return is_valid() ? names[encoding()] : \"fnoreg\";\n@@ -66,1 +53,1 @@\n-const char* XMMRegisterImpl::name() const {\n+const char* XMMRegister::XMMRegisterImpl::name() const {\n@@ -68,2 +55,2 @@\n-    \"xmm0\",\"xmm1\",\"xmm2\",\"xmm3\",\"xmm4\",\"xmm5\",\"xmm6\",\"xmm7\"\n-#ifdef AMD64\n+    \"xmm0\",    \"xmm1\",  \"xmm2\",  \"xmm3\",  \"xmm4\",  \"xmm5\",  \"xmm6\",  \"xmm7\"\n+#ifdef _LP64\n@@ -73,1 +60,1 @@\n-#endif \/\/ AMD64\n+#endif \/\/ _LP64\n@@ -78,26 +65,1 @@\n-const char* XMMRegisterImpl::sub_word_name(int i) const {\n-  const char* names[number_of_registers * 8] = {\n-      \"xmm0:0\", \"xmm0:1\", \"xmm0:2\", \"xmm0:3\", \"xmm0:4\", \"xmm0:5\", \"xmm0:6\", \"xmm0:7\",\n-      \"xmm1:0\", \"xmm1:1\", \"xmm1:2\", \"xmm1:3\", \"xmm1:4\", \"xmm1:5\", \"xmm1:6\", \"xmm1:7\",\n-      \"xmm2:0\", \"xmm2:1\", \"xmm2:2\", \"xmm2:3\", \"xmm2:4\", \"xmm2:5\", \"xmm2:6\", \"xmm2:7\",\n-      \"xmm3:0\", \"xmm3:1\", \"xmm3:2\", \"xmm3:3\", \"xmm3:4\", \"xmm3:5\", \"xmm3:6\", \"xmm3:7\",\n-      \"xmm4:0\", \"xmm4:1\", \"xmm4:2\", \"xmm4:3\", \"xmm4:4\", \"xmm4:5\", \"xmm4:6\", \"xmm4:7\",\n-      \"xmm5:0\", \"xmm5:1\", \"xmm5:2\", \"xmm5:3\", \"xmm5:4\", \"xmm5:5\", \"xmm5:6\", \"xmm5:7\",\n-      \"xmm6:0\", \"xmm6:1\", \"xmm6:2\", \"xmm6:3\", \"xmm6:4\", \"xmm6:5\", \"xmm6:6\", \"xmm6:7\",\n-      \"xmm7:0\", \"xmm7:1\", \"xmm7:2\", \"xmm7:3\", \"xmm7:4\", \"xmm7:5\", \"xmm7:6\", \"xmm7:7\",\n-#ifdef AMD64\n-      \"xmm8:0\", \"xmm8:1\", \"xmm8:2\", \"xmm8:3\", \"xmm8:4\", \"xmm8:5\", \"xmm8:6\", \"xmm8:7\",\n-      \"xmm9:0\", \"xmm9:1\", \"xmm9:2\", \"xmm9:3\", \"xmm9:4\", \"xmm9:5\", \"xmm9:6\", \"xmm9:7\",\n-      \"xmm10:0\", \"xmm10:1\", \"xmm10:2\", \"xmm10:3\", \"xmm10:4\", \"xmm10:5\", \"xmm10:6\", \"xmm10:7\",\n-      \"xmm11:0\", \"xmm11:1\", \"xmm11:2\", \"xmm11:3\", \"xmm11:4\", \"xmm11:5\", \"xmm11:6\", \"xmm11:7\",\n-      \"xmm12:0\", \"xmm12:1\", \"xmm12:2\", \"xmm12:3\", \"xmm12:4\", \"xmm12:5\", \"xmm12:6\", \"xmm12:7\",\n-      \"xmm13:0\", \"xmm13:1\", \"xmm13:2\", \"xmm13:3\", \"xmm13:4\", \"xmm13:5\", \"xmm13:6\", \"xmm13:7\",\n-      \"xmm14:0\", \"xmm14:1\", \"xmm14:2\", \"xmm14:3\", \"xmm14:4\", \"xmm14:5\", \"xmm14:6\", \"xmm14:7\",\n-      \"xmm15:0\", \"xmm15:1\", \"xmm15:2\", \"xmm15:3\", \"xmm15:4\", \"xmm15:5\", \"xmm15:6\", \"xmm15:7\",\n-#endif \/\/ AMD64\n-  };\n-  assert(i >= 0 && i < 8, \"offset too large\");\n-  return is_valid() ? names[encoding() * 8 + i] : \"xnoreg\";\n-}\n-\n-const char* KRegisterImpl::name() const {\n+const char* KRegister::KRegisterImpl::name() const {\n","filename":"src\/hotspot\/cpu\/x86\/register_x86.cpp","additions":16,"deletions":54,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -36,3 +36,4 @@\n-\/\/ Use Register as shortcut\n-class RegisterImpl;\n-typedef RegisterImpl* Register;\n+\/\/ The implementation of integer registers for the x86\/x64 architectures.\n+class Register {\n+private:\n+  int _encoding;\n@@ -40,6 +41,1 @@\n-\/\/ The implementation of integer registers for the ia32 architecture\n-\n-inline constexpr Register as_Register(int encoding);\n-\n-class RegisterImpl: public AbstractRegisterImpl {\n-  static constexpr Register first();\n+  constexpr Register(int encoding, bool unused) : _encoding(encoding) {}\n@@ -48,0 +44,2 @@\n+  inline friend constexpr Register as_Register(int encoding);\n+\n@@ -49,9 +47,3 @@\n-#ifndef AMD64\n-    number_of_registers      = 8,\n-    number_of_byte_registers = 4,\n-    max_slots_per_register   = 1\n-#else\n-    number_of_registers      = 16,\n-    number_of_byte_registers = 16,\n-    max_slots_per_register   = 2\n-#endif \/\/ AMD64\n+    number_of_registers      = LP64_ONLY( 16 ) NOT_LP64( 8 ),\n+    number_of_byte_registers = LP64_ONLY( 16 ) NOT_LP64( 4 ),\n+    max_slots_per_register   = LP64_ONLY(  2 ) NOT_LP64( 1 )\n@@ -60,2 +52,19 @@\n-  \/\/ derived registers, offsets, and addresses\n-  Register successor() const                          { return as_Register(encoding() + 1); }\n+  class RegisterImpl: public AbstractRegisterImpl {\n+    friend class Register;\n+\n+    static constexpr RegisterImpl* first();\n+\n+  public:\n+    \/\/ accessors\n+    int   raw_encoding() const      { return this - first(); }\n+    int   encoding() const          { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n+    bool  is_valid() const          { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n+    bool  has_byte_register() const { return 0 <= raw_encoding() && raw_encoding() < number_of_byte_registers; }\n+\n+    \/\/ derived registers, offsets, and addresses\n+    inline Register successor() const;\n+\n+    inline VMReg as_VMReg() const;\n+\n+    const char* name() const;\n+  };\n@@ -63,2 +72,1 @@\n-  \/\/ construction\n-  inline constexpr friend Register as_Register(int encoding);\n+  constexpr Register() : _encoding(-1) {} \/\/ noreg\n@@ -66,1 +74,2 @@\n-  inline VMReg as_VMReg() const;\n+  int operator==(const Register r) const { return _encoding == r._encoding; }\n+  int operator!=(const Register r) const { return _encoding != r._encoding; }\n@@ -68,6 +77,1 @@\n-  \/\/ accessors\n-  int   raw_encoding() const                     { return this - first(); }\n-  int   encoding() const                         { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n-  bool  is_valid() const                         { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n-  bool  has_byte_register() const                { return 0 <= raw_encoding() && raw_encoding() < number_of_byte_registers; }\n-  const char *name() const;\n+  const RegisterImpl* operator->() const { return RegisterImpl::first() + _encoding; }\n@@ -76,1 +80,1 @@\n-REGISTER_IMPL_DECLARATION(Register, RegisterImpl, RegisterImpl::number_of_registers);\n+extern Register::RegisterImpl all_RegisterImpls[Register::number_of_registers + 1] INTERNAL_VISIBILITY;\n@@ -78,1 +82,5 @@\n-\/\/ The integer registers of the ia32\/amd64 architecture\n+inline constexpr Register::RegisterImpl* Register::RegisterImpl::first() {\n+  return all_RegisterImpls + 1;\n+}\n+\n+constexpr Register noreg = Register();\n@@ -80,1 +88,6 @@\n-CONSTANT_REGISTER_DECLARATION(Register, noreg, (-1));\n+inline constexpr Register as_Register(int encoding) {\n+  if (0 <= encoding && encoding < Register::number_of_registers) {\n+    return Register(encoding, false);\n+  }\n+  return noreg;\n+}\n@@ -82,0 +95,4 @@\n+inline Register Register::RegisterImpl::successor() const {\n+  assert(is_valid(), \"sanity\");\n+  return as_Register(encoding() + 1);\n+}\n@@ -83,18 +100,18 @@\n-CONSTANT_REGISTER_DECLARATION(Register, rax,    (0));\n-CONSTANT_REGISTER_DECLARATION(Register, rcx,    (1));\n-CONSTANT_REGISTER_DECLARATION(Register, rdx,    (2));\n-CONSTANT_REGISTER_DECLARATION(Register, rbx,    (3));\n-CONSTANT_REGISTER_DECLARATION(Register, rsp,    (4));\n-CONSTANT_REGISTER_DECLARATION(Register, rbp,    (5));\n-CONSTANT_REGISTER_DECLARATION(Register, rsi,    (6));\n-CONSTANT_REGISTER_DECLARATION(Register, rdi,    (7));\n-#ifdef AMD64\n-CONSTANT_REGISTER_DECLARATION(Register, r8,     (8));\n-CONSTANT_REGISTER_DECLARATION(Register, r9,     (9));\n-CONSTANT_REGISTER_DECLARATION(Register, r10,   (10));\n-CONSTANT_REGISTER_DECLARATION(Register, r11,   (11));\n-CONSTANT_REGISTER_DECLARATION(Register, r12,   (12));\n-CONSTANT_REGISTER_DECLARATION(Register, r13,   (13));\n-CONSTANT_REGISTER_DECLARATION(Register, r14,   (14));\n-CONSTANT_REGISTER_DECLARATION(Register, r15,   (15));\n-#endif \/\/ AMD64\n+constexpr Register rax = as_Register(0);\n+constexpr Register rcx = as_Register(1);\n+constexpr Register rdx = as_Register(2);\n+constexpr Register rbx = as_Register(3);\n+constexpr Register rsp = as_Register(4);\n+constexpr Register rbp = as_Register(5);\n+constexpr Register rsi = as_Register(6);\n+constexpr Register rdi = as_Register(7);\n+#ifdef _LP64\n+constexpr Register r8  = as_Register( 8);\n+constexpr Register r9  = as_Register( 9);\n+constexpr Register r10 = as_Register(10);\n+constexpr Register r11 = as_Register(11);\n+constexpr Register r12 = as_Register(12);\n+constexpr Register r13 = as_Register(13);\n+constexpr Register r14 = as_Register(14);\n+constexpr Register r15 = as_Register(15);\n+#endif \/\/ _LP64\n@@ -102,3 +119,0 @@\n-\/\/ Use FloatRegister as shortcut\n-class FloatRegisterImpl;\n-typedef const FloatRegisterImpl* FloatRegister;\n@@ -106,1 +120,4 @@\n-inline constexpr FloatRegister as_FloatRegister(int encoding);\n+\/\/ The implementation of x87 floating point registers for the ia32 architecture.\n+class FloatRegister {\n+private:\n+  int _encoding;\n@@ -108,3 +125,1 @@\n-\/\/ The implementation of floating point registers for the ia32 architecture\n-class FloatRegisterImpl: public AbstractRegisterImpl {\n-  static constexpr FloatRegister first();\n+  constexpr FloatRegister(int encoding, bool unused) : _encoding(encoding) {}\n@@ -113,0 +128,2 @@\n+  inline friend constexpr FloatRegister as_FloatRegister(int encoding);\n+\n@@ -114,1 +131,2 @@\n-    number_of_registers = 8\n+    number_of_registers    = 8,\n+    max_slots_per_register = 2\n@@ -117,2 +135,4 @@\n-  \/\/ construction\n-  inline friend constexpr FloatRegister as_FloatRegister(int encoding);\n+  class FloatRegisterImpl: public AbstractRegisterImpl {\n+    friend class FloatRegister;\n+\n+    static constexpr FloatRegisterImpl* first();\n@@ -120,1 +140,5 @@\n-  inline VMReg as_VMReg() const;\n+  public:\n+    \/\/ accessors\n+    int   raw_encoding() const { return this - first(); }\n+    int   encoding() const     { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n+    bool  is_valid() const     { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n@@ -122,1 +146,2 @@\n-  \/\/ derived registers, offsets, and addresses\n+    \/\/ derived registers, offsets, and addresses\n+    inline FloatRegister successor() const;\n@@ -124,1 +149,4 @@\n-  FloatRegister successor() const                          { return as_FloatRegister(encoding() + 1); }\n+    inline VMReg as_VMReg() const;\n+\n+    const char* name() const;\n+  };\n@@ -126,5 +154,1 @@\n-  \/\/ accessors\n-  int   raw_encoding() const                      { return this - first(); }\n-  int   encoding() const                          { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n-  bool  is_valid() const                          { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n-  const char* name() const;\n+  constexpr FloatRegister() : _encoding(-1) {} \/\/ fnoreg\n@@ -132,0 +156,4 @@\n+  int operator==(const FloatRegister r) const { return _encoding == r._encoding; }\n+  int operator!=(const FloatRegister r) const { return _encoding != r._encoding; }\n+\n+  const FloatRegisterImpl* operator->() const { return FloatRegisterImpl::first() + _encoding; }\n@@ -134,1 +162,1 @@\n-REGISTER_IMPL_DECLARATION(FloatRegister, FloatRegisterImpl, FloatRegisterImpl::number_of_registers);\n+extern FloatRegister::FloatRegisterImpl all_FloatRegisterImpls[FloatRegister::number_of_registers + 1] INTERNAL_VISIBILITY;\n@@ -136,1 +164,3 @@\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, fnoreg, (-1));\n+inline constexpr FloatRegister::FloatRegisterImpl* FloatRegister::FloatRegisterImpl::first() {\n+  return all_FloatRegisterImpls + 1;\n+}\n@@ -138,3 +168,13 @@\n-\/\/ Use XMMRegister as shortcut\n-class XMMRegisterImpl;\n-typedef XMMRegisterImpl* XMMRegister;\n+constexpr FloatRegister fnoreg = FloatRegister();\n+\n+inline constexpr FloatRegister as_FloatRegister(int encoding) {\n+  if (0 <= encoding && encoding < FloatRegister::number_of_registers) {\n+    return FloatRegister(encoding, false);\n+  }\n+  return fnoreg;\n+}\n+\n+inline FloatRegister FloatRegister::FloatRegisterImpl::successor() const {\n+  assert(is_valid(), \"sanity\");\n+  return as_FloatRegister(encoding() + 1);\n+}\n@@ -142,1 +182,0 @@\n-inline constexpr XMMRegister as_XMMRegister(int encoding);\n@@ -145,2 +184,8 @@\n-class XMMRegisterImpl: public AbstractRegisterImpl {\n-  static constexpr XMMRegister first();\n+class XMMRegister {\n+private:\n+  int _encoding;\n+\n+  constexpr XMMRegister(int encoding, bool unused) : _encoding(encoding) {}\n+\n+public:\n+  inline friend constexpr XMMRegister as_XMMRegister(int encoding);\n@@ -148,1 +193,0 @@\n- public:\n@@ -150,7 +194,2 @@\n-#ifndef AMD64\n-    number_of_registers = 8,\n-    max_slots_per_register = 16   \/\/ 512-bit\n-#else\n-    number_of_registers = 32,\n-    max_slots_per_register = 16   \/\/ 512-bit\n-#endif \/\/ AMD64\n+    number_of_registers    = LP64_ONLY( 32 ) NOT_LP64(  8 ),\n+    max_slots_per_register = LP64_ONLY( 16 ) NOT_LP64( 16 )   \/\/ 512-bit\n@@ -159,2 +198,2 @@\n-  \/\/ construction\n-  friend constexpr XMMRegister as_XMMRegister(int encoding);\n+  class XMMRegisterImpl: public AbstractRegisterImpl {\n+    friend class XMMRegister;\n@@ -162,1 +201,1 @@\n-  inline VMReg as_VMReg() const;\n+    static constexpr XMMRegisterImpl* first();\n@@ -164,2 +203,5 @@\n-  \/\/ derived registers, offsets, and addresses\n-  XMMRegister successor() const                          { return as_XMMRegister(encoding() + 1); }\n+  public:\n+    \/\/ accessors\n+    int raw_encoding() const  { return this - first(); }\n+    int   encoding() const    { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n+    bool  is_valid() const    { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n@@ -167,6 +209,2 @@\n-  \/\/ accessors\n-  int raw_encoding() const                       { return this - first(); }\n-  int   encoding() const                         { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n-  bool  is_valid() const                         { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n-  const char* name() const;\n-  const char* sub_word_name(int offset) const;\n+    \/\/ derived registers, offsets, and addresses\n+    inline XMMRegister successor() const;\n@@ -174,2 +212,13 @@\n-  \/\/ Actually available XMM registers for use, depending on actual CPU capabilities\n-  \/\/ and flags.\n+    inline VMReg as_VMReg() const;\n+\n+    const char* name() const;\n+  };\n+\n+  constexpr XMMRegister() : _encoding(-1) {} \/\/ xnoreg\n+\n+  int operator==(const XMMRegister r) const { return _encoding == r._encoding; }\n+  int operator!=(const XMMRegister r) const { return _encoding != r._encoding; }\n+\n+  const XMMRegisterImpl* operator->() const { return XMMRegisterImpl::first() + _encoding; }\n+\n+  \/\/ Actually available XMM registers for use, depending on actual CPU capabilities and flags.\n@@ -177,1 +226,0 @@\n-    int num_xmm_regs = XMMRegisterImpl::number_of_registers;\n@@ -180,1 +228,1 @@\n-      num_xmm_regs \/= 2;\n+      return number_of_registers \/ 2;\n@@ -182,2 +230,2 @@\n-#endif\n-    return num_xmm_regs;\n+#endif \/\/ _LP64\n+    return number_of_registers;\n@@ -187,0 +235,5 @@\n+extern XMMRegister::XMMRegisterImpl all_XMMRegisterImpls[XMMRegister::number_of_registers + 1] INTERNAL_VISIBILITY;\n+\n+inline constexpr XMMRegister::XMMRegisterImpl* XMMRegister::XMMRegisterImpl::first() {\n+  return all_XMMRegisterImpls + 1;\n+}\n@@ -188,48 +241,56 @@\n-REGISTER_IMPL_DECLARATION(XMMRegister, XMMRegisterImpl, XMMRegisterImpl::number_of_registers);\n-\n-\/\/ The XMM registers, for P3 and up chips\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xnoreg , (-1));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm0 , ( 0));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm1 , ( 1));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm2 , ( 2));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm3 , ( 3));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm4 , ( 4));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm5 , ( 5));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm6 , ( 6));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm7 , ( 7));\n-#ifdef AMD64\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm8,      (8));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm9,      (9));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm10,    (10));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm11,    (11));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm12,    (12));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm13,    (13));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm14,    (14));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm15,    (15));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm16,    (16));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm17,    (17));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm18,    (18));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm19,    (19));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm20,    (20));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm21,    (21));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm22,    (22));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm23,    (23));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm24,    (24));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm25,    (25));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm26,    (26));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm27,    (27));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm28,    (28));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm29,    (29));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm30,    (30));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm31,    (31));\n-#endif \/\/ AMD64\n-\n-\/\/ Use KRegister as shortcut\n-class KRegisterImpl;\n-typedef KRegisterImpl* KRegister;\n-\n-inline constexpr KRegister as_KRegister(int encoding);\n-\n-\/\/ The implementation of AVX-3 (AVX-512) opmask registers.\n-class KRegisterImpl : public AbstractRegisterImpl {\n-  static constexpr KRegister first();\n+constexpr XMMRegister xnoreg = XMMRegister();\n+\n+inline constexpr XMMRegister as_XMMRegister(int encoding) {\n+  if (0 <= encoding && encoding < XMMRegister::number_of_registers) {\n+    return XMMRegister(encoding, false);\n+  }\n+  return xnoreg;\n+}\n+\n+inline XMMRegister XMMRegister::XMMRegisterImpl::successor() const {\n+  assert(is_valid(), \"sanity\");\n+  return as_XMMRegister(encoding() + 1);\n+}\n+\n+constexpr XMMRegister xmm0  = as_XMMRegister( 0);\n+constexpr XMMRegister xmm1  = as_XMMRegister( 1);\n+constexpr XMMRegister xmm2  = as_XMMRegister( 2);\n+constexpr XMMRegister xmm3  = as_XMMRegister( 3);\n+constexpr XMMRegister xmm4  = as_XMMRegister( 4);\n+constexpr XMMRegister xmm5  = as_XMMRegister( 5);\n+constexpr XMMRegister xmm6  = as_XMMRegister( 6);\n+constexpr XMMRegister xmm7  = as_XMMRegister( 7);\n+#ifdef _LP64\n+constexpr XMMRegister xmm8  = as_XMMRegister( 8);\n+constexpr XMMRegister xmm9  = as_XMMRegister( 9);\n+constexpr XMMRegister xmm10 = as_XMMRegister(10);\n+constexpr XMMRegister xmm11 = as_XMMRegister(11);\n+constexpr XMMRegister xmm12 = as_XMMRegister(12);\n+constexpr XMMRegister xmm13 = as_XMMRegister(13);\n+constexpr XMMRegister xmm14 = as_XMMRegister(14);\n+constexpr XMMRegister xmm15 = as_XMMRegister(15);\n+constexpr XMMRegister xmm16 = as_XMMRegister(16);\n+constexpr XMMRegister xmm17 = as_XMMRegister(17);\n+constexpr XMMRegister xmm18 = as_XMMRegister(18);\n+constexpr XMMRegister xmm19 = as_XMMRegister(19);\n+constexpr XMMRegister xmm20 = as_XMMRegister(20);\n+constexpr XMMRegister xmm21 = as_XMMRegister(21);\n+constexpr XMMRegister xmm22 = as_XMMRegister(22);\n+constexpr XMMRegister xmm23 = as_XMMRegister(23);\n+constexpr XMMRegister xmm24 = as_XMMRegister(24);\n+constexpr XMMRegister xmm25 = as_XMMRegister(25);\n+constexpr XMMRegister xmm26 = as_XMMRegister(26);\n+constexpr XMMRegister xmm27 = as_XMMRegister(27);\n+constexpr XMMRegister xmm28 = as_XMMRegister(28);\n+constexpr XMMRegister xmm29 = as_XMMRegister(29);\n+constexpr XMMRegister xmm30 = as_XMMRegister(30);\n+constexpr XMMRegister xmm31 = as_XMMRegister(31);\n+#endif \/\/ _LP64\n+\n+\n+\/\/ The implementation of AVX-512 opmask registers.\n+class KRegister {\n+private:\n+  int _encoding;\n+\n+  constexpr KRegister(int encoding, bool unused) : _encoding(encoding) {}\n@@ -238,0 +299,2 @@\n+  inline friend constexpr KRegister as_KRegister(int encoding);\n+\n@@ -245,2 +308,4 @@\n-  \/\/ construction\n-  friend constexpr KRegister as_KRegister(int encoding);\n+  class KRegisterImpl: public AbstractRegisterImpl {\n+    friend class KRegister;\n+\n+    static constexpr KRegisterImpl* first();\n@@ -248,1 +313,1 @@\n-  inline VMReg as_VMReg() const;\n+  public:\n@@ -250,2 +315,4 @@\n-  \/\/ derived registers, offsets, and addresses\n-  KRegister successor() const                          { return as_KRegister(encoding() + 1); }\n+    \/\/ accessors\n+    int   raw_encoding() const { return this - first(); }\n+    int   encoding() const     { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n+    bool  is_valid() const     { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n@@ -253,5 +320,14 @@\n-  \/\/ accessors\n-  int   raw_encoding() const                      { return this - first(); }\n-  int   encoding() const                          { assert(is_valid(), \"invalid register (%d)\", (int)raw_encoding()); return raw_encoding(); }\n-  bool  is_valid() const                          { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n-  const char* name() const;\n+    \/\/ derived registers, offsets, and addresses\n+    inline KRegister successor() const;\n+\n+    inline VMReg as_VMReg() const;\n+\n+    const char* name() const;\n+  };\n+\n+  constexpr KRegister() : _encoding(-1) {} \/\/ knoreg\n+\n+  int operator==(const KRegister r) const { return _encoding == r._encoding; }\n+  int operator!=(const KRegister r) const { return _encoding != r._encoding; }\n+\n+  const KRegisterImpl* operator->() const { return KRegisterImpl::first() + _encoding; }\n@@ -260,1 +336,28 @@\n-REGISTER_IMPL_DECLARATION(KRegister, KRegisterImpl, KRegisterImpl::number_of_registers);\n+extern KRegister::KRegisterImpl all_KRegisterImpls[KRegister::number_of_registers + 1] INTERNAL_VISIBILITY;\n+\n+inline constexpr KRegister::KRegisterImpl* KRegister::KRegisterImpl::first() {\n+  return all_KRegisterImpls + 1;\n+}\n+\n+constexpr KRegister knoreg = KRegister();\n+\n+inline constexpr KRegister as_KRegister(int encoding) {\n+  if (0 <= encoding && encoding < KRegister::number_of_registers) {\n+    return KRegister(encoding, false);\n+  }\n+  return knoreg;\n+}\n+\n+inline KRegister KRegister::KRegisterImpl::successor() const {\n+  assert(is_valid(), \"sanity\");\n+  return as_KRegister(encoding() + 1);\n+}\n+\n+constexpr KRegister k0 = as_KRegister(0);\n+constexpr KRegister k1 = as_KRegister(1);\n+constexpr KRegister k2 = as_KRegister(2);\n+constexpr KRegister k3 = as_KRegister(3);\n+constexpr KRegister k4 = as_KRegister(4);\n+constexpr KRegister k5 = as_KRegister(5);\n+constexpr KRegister k6 = as_KRegister(6);\n+constexpr KRegister k7 = as_KRegister(7);\n@@ -262,10 +365,0 @@\n-\/\/ The Mask registers, for AVX3 enabled and up chips\n-CONSTANT_REGISTER_DECLARATION(KRegister, knoreg, (-1));\n-CONSTANT_REGISTER_DECLARATION(KRegister, k0, (0));\n-CONSTANT_REGISTER_DECLARATION(KRegister, k1, (1));\n-CONSTANT_REGISTER_DECLARATION(KRegister, k2, (2));\n-CONSTANT_REGISTER_DECLARATION(KRegister, k3, (3));\n-CONSTANT_REGISTER_DECLARATION(KRegister, k4, (4));\n-CONSTANT_REGISTER_DECLARATION(KRegister, k5, (5));\n-CONSTANT_REGISTER_DECLARATION(KRegister, k6, (6));\n-CONSTANT_REGISTER_DECLARATION(KRegister, k7, (7));\n@@ -278,14 +371,17 @@\n-  \/\/ A big enough number for C2: all the registers plus flags\n-  \/\/ This number must be large enough to cover REG_COUNT (defined by c2) registers.\n-  \/\/ There is no requirement that any ordering here matches any ordering c2 gives\n-  \/\/ it's optoregs.\n-\n-  \/\/ x86_32.ad defines additional dummy FILL0-FILL7 registers, in order to tally\n-  \/\/ REG_COUNT (computed by ADLC based on the number of reg_defs seen in .ad files)\n-  \/\/ with ConcreteRegisterImpl::number_of_registers additional count of 8 is being\n-  \/\/ added for 32 bit jvm.\n-    number_of_registers = RegisterImpl::number_of_registers * RegisterImpl::max_slots_per_register +\n-      2 * FloatRegisterImpl::number_of_registers + NOT_LP64(8) LP64_ONLY(0) +\n-      XMMRegisterImpl::max_slots_per_register * XMMRegisterImpl::number_of_registers +\n-      KRegisterImpl::number_of_registers * KRegisterImpl::max_slots_per_register + \/\/ mask registers\n-      1 \/\/ eflags\n+    max_gpr = Register::number_of_registers * Register::max_slots_per_register,\n+    max_fpr = max_gpr + FloatRegister::number_of_registers * FloatRegister::max_slots_per_register,\n+    max_xmm = max_fpr + XMMRegister::number_of_registers * XMMRegister::max_slots_per_register,\n+    max_kpr = max_xmm + KRegister::number_of_registers * KRegister::max_slots_per_register,\n+\n+    \/\/ A big enough number for C2: all the registers plus flags\n+    \/\/ This number must be large enough to cover REG_COUNT (defined by c2) registers.\n+    \/\/ There is no requirement that any ordering here matches any ordering c2 gives\n+    \/\/ it's optoregs.\n+\n+    \/\/ x86_32.ad defines additional dummy FILL0-FILL7 registers, in order to tally\n+    \/\/ REG_COUNT (computed by ADLC based on the number of reg_defs seen in .ad files)\n+    \/\/ with ConcreteRegisterImpl::number_of_registers additional count of 8 is being\n+    \/\/ added for 32 bit jvm.\n+    number_of_registers = max_kpr +       \/\/ gpr\/fpr\/xmm\/kpr\n+                          NOT_LP64( 8 + ) \/\/ FILL0-FILL7 in x86_32.ad\n+                          1               \/\/ eflags\n@@ -293,6 +389,0 @@\n-\n-  static const int max_gpr;\n-  static const int max_fpr;\n-  static const int max_xmm;\n-  static const int max_kpr;\n-\n","filename":"src\/hotspot\/cpu\/x86\/register_x86.hpp","additions":280,"deletions":190,"binary":false,"changes":470,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-    __ cmpptr(obj_reg, (int32_t)NULL_WORD);\n+    __ cmpptr(obj_reg, NULL_WORD);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-  int num_xmm_regs = XMMRegisterImpl::number_of_registers;\n+  int num_xmm_regs = XMMRegister::number_of_registers;\n@@ -135,1 +135,1 @@\n-  int opmask_state_bytes = KRegisterImpl::number_of_registers * 8;\n+  int opmask_state_bytes = KRegister::number_of_registers * 8;\n@@ -202,1 +202,1 @@\n-  for (int n = 0; n < FloatRegisterImpl::number_of_registers; n++) {\n+  for (int n = 0; n < FloatRegister::number_of_registers; n++) {\n@@ -238,1 +238,1 @@\n-      for (int n = 0; n < KRegisterImpl::number_of_registers; n++) {\n+      for (int n = 0; n < KRegister::number_of_registers; n++) {\n@@ -271,1 +271,1 @@\n-  for (int n = 0; n < FloatRegisterImpl::number_of_registers; n++) {\n+  for (int n = 0; n < FloatRegister::number_of_registers; n++) {\n@@ -294,1 +294,1 @@\n-  int num_xmm_regs = XMMRegisterImpl::number_of_registers;\n+  int num_xmm_regs = XMMRegister::number_of_registers;\n@@ -307,1 +307,1 @@\n-      opmask_state_bytes = KRegisterImpl::number_of_registers * 8;\n+      opmask_state_bytes = KRegister::number_of_registers * 8;\n@@ -348,1 +348,1 @@\n-      for (int n = 0; n < KRegisterImpl::number_of_registers; n++) {\n+      for (int n = 0; n < KRegister::number_of_registers; n++) {\n@@ -415,2 +415,2 @@\n-\/\/ and VMRegImpl::stack0+1 refers to the memory word 4-byes higher.  Register\n-\/\/ up to RegisterImpl::number_of_registers) are the 32-bit\n+\/\/ and VMRegImpl::stack0+1 refers to the memory word 4-byes higher.\n+\/\/ Register up to Register::number_of_registers are the 32-bit\n@@ -538,1 +538,1 @@\n-  __ cmpptr(Address(rbx, in_bytes(Method::code_offset())), (int32_t)NULL_WORD);\n+  __ cmpptr(Address(rbx, in_bytes(Method::code_offset())), NULL_WORD);\n@@ -987,1 +987,1 @@\n-    __ cmpptr(Address(rbx, in_bytes(Method::code_offset())), (int32_t)NULL_WORD);\n+    __ cmpptr(Address(rbx, in_bytes(Method::code_offset())), NULL_WORD);\n@@ -1099,1 +1099,1 @@\n-    __ cmpptr(Address(rbp, reg2offset_in(src.first())), (int32_t)NULL_WORD);\n+    __ cmpptr(Address(rbp, reg2offset_in(src.first())), NULL_WORD);\n@@ -1121,1 +1121,1 @@\n-    __ cmpptr(rOop, (int32_t)NULL_WORD);\n+    __ cmpptr(rOop, NULL_WORD);\n@@ -1866,1 +1866,1 @@\n-      __ cmpptr(Address(rbp, lock_slot_rbp_offset), (int32_t)NULL_WORD);\n+      __ cmpptr(Address(rbp, lock_slot_rbp_offset), NULL_WORD);\n@@ -1937,1 +1937,1 @@\n-  __ cmpptr(Address(thread, in_bytes(Thread::pending_exception_offset())), (int32_t)NULL_WORD);\n+  __ cmpptr(Address(thread, in_bytes(Thread::pending_exception_offset())), NULL_WORD);\n@@ -1984,1 +1984,1 @@\n-    __ cmpptr(Address(thread, in_bytes(Thread::pending_exception_offset())), (int)NULL_WORD);\n+    __ cmpptr(Address(thread, in_bytes(Thread::pending_exception_offset())), NULL_WORD);\n@@ -2021,1 +2021,1 @@\n-      __ cmpptr(Address(thread, in_bytes(Thread::pending_exception_offset())), (int32_t)NULL_WORD);\n+      __ cmpptr(Address(thread, in_bytes(Thread::pending_exception_offset())), NULL_WORD);\n@@ -2705,1 +2705,1 @@\n-  __ cmpptr(Address(java_thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);\n+  __ cmpptr(Address(java_thread, Thread::pending_exception_offset()), NULL_WORD);\n@@ -2833,1 +2833,1 @@\n-  __ cmpptr(Address(thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);\n+  __ cmpptr(Address(thread, Thread::pending_exception_offset()), NULL_WORD);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"oops\/method.inline.hpp\"\n@@ -176,1 +177,1 @@\n-  int num_xmm_regs = XMMRegisterImpl::available_xmm_registers();\n+  int num_xmm_regs = XMMRegister::available_xmm_registers();\n@@ -226,1 +227,1 @@\n-      for(int n = 0; n < KRegisterImpl::number_of_registers; n++) {\n+      for(int n = 0; n < KRegister::number_of_registers; n++) {\n@@ -243,1 +244,1 @@\n-      for(int n = 0; n < KRegisterImpl::number_of_registers; n++) {\n+      for(int n = 0; n < KRegister::number_of_registers; n++) {\n@@ -366,1 +367,1 @@\n-  int num_xmm_regs = XMMRegisterImpl::available_xmm_registers();\n+  int num_xmm_regs = XMMRegister::available_xmm_registers();\n@@ -406,1 +407,1 @@\n-      for (int n = 0; n < KRegisterImpl::number_of_registers; n++) {\n+      for (int n = 0; n < KRegister::number_of_registers; n++) {\n@@ -423,1 +424,1 @@\n-      for (int n = 0; n < KRegisterImpl::number_of_registers; n++) {\n+      for (int n = 0; n < KRegister::number_of_registers; n++) {\n@@ -467,2 +468,2 @@\n-\/\/ and VMRegImpl::stack0+1 refers to the memory word 4-byes higher.  Register\n-\/\/ up to RegisterImpl::number_of_registers) are the 64-bit\n+\/\/ and VMRegImpl::stack0+1 refers to the memory word 4-byes higher.\n+\/\/ Register up to Register::number_of_registers are the 64-bit\n@@ -561,1 +562,1 @@\n-  __ cmpptr(Address(rbx, in_bytes(Method::code_offset())), (int32_t)NULL_WORD);\n+  __ cmpptr(Address(rbx, in_bytes(Method::code_offset())), NULL_WORD);\n@@ -999,1 +1000,1 @@\n-    __ cmpptr(Address(rbx, in_bytes(Method::code_offset())), (int32_t)NULL_WORD);\n+    __ cmpptr(Address(rbx, in_bytes(Method::code_offset())), NULL_WORD);\n@@ -1809,3 +1810,3 @@\n-  bool reg_destroyed[RegisterImpl::number_of_registers];\n-  bool freg_destroyed[XMMRegisterImpl::number_of_registers];\n-  for ( int r = 0 ; r < RegisterImpl::number_of_registers ; r++ ) {\n+  bool reg_destroyed[Register::number_of_registers];\n+  bool freg_destroyed[XMMRegister::number_of_registers];\n+  for ( int r = 0 ; r < Register::number_of_registers ; r++ ) {\n@@ -1814,1 +1815,1 @@\n-  for ( int f = 0 ; f < XMMRegisterImpl::number_of_registers ; f++ ) {\n+  for ( int f = 0 ; f < XMMRegister::number_of_registers ; f++ ) {\n@@ -2115,1 +2116,1 @@\n-      __ cmpptr(Address(rsp, lock_slot_offset * VMRegImpl::stack_slot_size), (int32_t)NULL_WORD);\n+      __ cmpptr(Address(rsp, lock_slot_offset * VMRegImpl::stack_slot_size), NULL_WORD);\n@@ -2176,1 +2177,1 @@\n-  __ movl(Address(rcx, JNIHandleBlock::top_offset_in_bytes()), (int32_t)NULL_WORD);\n+  __ movl(Address(rcx, JNIHandleBlock::top_offset_in_bytes()), NULL_WORD);\n@@ -2183,1 +2184,1 @@\n-  __ cmpptr(Address(r15_thread, in_bytes(Thread::pending_exception_offset())), (int32_t)NULL_WORD);\n+  __ cmpptr(Address(r15_thread, in_bytes(Thread::pending_exception_offset())), NULL_WORD);\n@@ -2220,1 +2221,1 @@\n-    __ cmpptr(Address(r15_thread, in_bytes(Thread::pending_exception_offset())), (int32_t)NULL_WORD);\n+    __ cmpptr(Address(r15_thread, in_bytes(Thread::pending_exception_offset())), NULL_WORD);\n@@ -2251,1 +2252,1 @@\n-    __ movptr(Address(r15_thread, in_bytes(Thread::pending_exception_offset())), (int32_t)NULL_WORD);\n+    __ movptr(Address(r15_thread, in_bytes(Thread::pending_exception_offset())), NULL_WORD);\n@@ -2260,1 +2261,1 @@\n-      __ cmpptr(Address(r15_thread, in_bytes(Thread::pending_exception_offset())), (int)NULL_WORD);\n+      __ cmpptr(Address(r15_thread, in_bytes(Thread::pending_exception_offset())), NULL_WORD);\n@@ -2418,1 +2419,1 @@\n-    __ movptr(Address(r15_thread, in_bytes(JavaThread::jvmci_implicit_exception_pc_offset())), (int32_t)NULL_WORD);\n+    __ movptr(Address(r15_thread, in_bytes(JavaThread::jvmci_implicit_exception_pc_offset())), NULL_WORD);\n@@ -2430,1 +2431,1 @@\n-    __ movl(r14, (int32_t)Deoptimization::Unpack_reexecute);\n+    __ movl(r14, Deoptimization::Unpack_reexecute);\n@@ -2482,1 +2483,1 @@\n-  __ movptr(Address(r15_thread, JavaThread::exception_pc_offset()), (int32_t)NULL_WORD);\n+  __ movptr(Address(r15_thread, JavaThread::exception_pc_offset()), NULL_WORD);\n@@ -2510,3 +2511,1 @@\n-    __ cmpptr(Address(r15_thread,\n-                    JavaThread::last_Java_fp_offset()),\n-            (int32_t)0);\n+    __ cmpptr(Address(r15_thread, JavaThread::last_Java_fp_offset()), NULL_WORD);\n@@ -2544,2 +2543,2 @@\n-  __ movptr(Address(r15_thread, JavaThread::exception_oop_offset()), (int32_t)NULL_WORD);\n-  __ movptr(Address(r15_thread, JavaThread::exception_pc_offset()), (int32_t)NULL_WORD);\n+  __ movptr(Address(r15_thread, JavaThread::exception_oop_offset()), NULL_WORD);\n+  __ movptr(Address(r15_thread, JavaThread::exception_pc_offset()), NULL_WORD);\n@@ -2627,1 +2626,1 @@\n-  __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), (int32_t)NULL_WORD );\n+  __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), NULL_WORD);\n@@ -2757,1 +2756,1 @@\n-            (int32_t)Deoptimization::Unpack_uncommon_trap);\n+              Deoptimization::Unpack_uncommon_trap);\n@@ -2828,1 +2827,1 @@\n-  __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), (int32_t)NULL_WORD );\n+  __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), NULL_WORD);\n@@ -2950,1 +2949,1 @@\n-  __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);\n+  __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), NULL_WORD);\n@@ -3091,1 +3090,1 @@\n-  __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);\n+  __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), NULL_WORD);\n@@ -3114,1 +3113,1 @@\n-  __ movptr(Address(r15_thread, JavaThread::vm_result_offset()), (int)NULL_WORD);\n+  __ movptr(Address(r15_thread, JavaThread::vm_result_offset()), NULL_WORD);\n@@ -3506,2 +3505,2 @@\n-  __ movptr(Address(r15_thread, JavaThread::exception_handler_pc_offset()), (int)NULL_WORD);\n-  __ movptr(Address(r15_thread, JavaThread::exception_pc_offset()), (int)NULL_WORD);\n+  __ movptr(Address(r15_thread, JavaThread::exception_handler_pc_offset()), NULL_WORD);\n+  __ movptr(Address(r15_thread, JavaThread::exception_pc_offset()), NULL_WORD);\n@@ -3510,1 +3509,1 @@\n-  __ movptr(Address(r15_thread, JavaThread::exception_oop_offset()), (int)NULL_WORD);\n+  __ movptr(Address(r15_thread, JavaThread::exception_oop_offset()), NULL_WORD);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":36,"deletions":37,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -179,1 +179,1 @@\n-      __ cmpptr(Address(rcx, Thread::pending_exception_offset()), (int32_t)NULL_WORD);\n+      __ cmpptr(Address(rcx, Thread::pending_exception_offset()), NULL_WORD);\n@@ -391,1 +391,1 @@\n-      __ cmpptr(Address(thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);\n+      __ cmpptr(Address(thread, Thread::pending_exception_offset()), NULL_WORD);\n@@ -1857,1 +1857,1 @@\n-      __ cmpptr(dst_klass_addr, (int32_t)NULL_WORD);\n+      __ cmpptr(dst_klass_addr, NULL_WORD);\n@@ -2207,1 +2207,1 @@\n-  void load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask=NULL) {\n+  void load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask = xnoreg) {\n@@ -2209,1 +2209,1 @@\n-    if (xmm_shuf_mask != NULL) {\n+    if (xmm_shuf_mask != xnoreg) {\n@@ -2218,1 +2218,1 @@\n-  void aes_enc_key(XMMRegister xmmdst, XMMRegister xmmtmp, Register key, int offset, XMMRegister xmm_shuf_mask=NULL) {\n+  void aes_enc_key(XMMRegister xmmdst, XMMRegister xmmtmp, Register key, int offset, XMMRegister xmm_shuf_mask = xnoreg) {\n@@ -2225,1 +2225,1 @@\n-  void aes_dec_key(XMMRegister xmmdst, XMMRegister xmmtmp, Register key, int offset, XMMRegister xmm_shuf_mask=NULL) {\n+  void aes_dec_key(XMMRegister xmmdst, XMMRegister xmmtmp, Register key, int offset, XMMRegister xmm_shuf_mask = xnoreg) {\n@@ -3509,3 +3509,3 @@\n-    const Register empty = 0; \/\/ will never be used, in order not\n-                              \/\/ to change a signature for crc32c_IPL_Alg2_Alt2\n-                              \/\/ between 64\/32 I'm just keeping it here\n+    const Register empty = noreg; \/\/ will never be used, in order not\n+                                  \/\/ to change a signature for crc32c_IPL_Alg2_Alt2\n+                                  \/\/ between 64\/32 I'm just keeping it here\n@@ -3951,1 +3951,1 @@\n-    __ cmpptr(Address(java_thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);\n+    __ cmpptr(Address(java_thread, Thread::pending_exception_offset()), NULL_WORD);\n@@ -4121,9 +4121,0 @@\n-      if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dsin) ||\n-          vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dcos) ||\n-          vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dtan)) {\n-        StubRoutines::x86::_L_2il0floatpacket_0_adr = (address)StubRoutines::x86::_L_2il0floatpacket_0;\n-        StubRoutines::x86::_Pi4Inv_adr = (address)StubRoutines::x86::_Pi4Inv;\n-        StubRoutines::x86::_Pi4x3_adr = (address)StubRoutines::x86::_Pi4x3;\n-        StubRoutines::x86::_Pi4x4_adr = (address)StubRoutines::x86::_Pi4x4;\n-        StubRoutines::x86::_ones_adr = (address)StubRoutines::x86::_ones;\n-      }\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":11,"deletions":20,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -319,1 +319,1 @@\n-      __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);\n+      __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), NULL_WORD);\n@@ -532,1 +532,1 @@\n-      __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), (int32_t) NULL_WORD);\n+      __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), NULL_WORD);\n@@ -550,1 +550,1 @@\n-    __ movptr(Address(r15_thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);\n+    __ movptr(Address(r15_thread, Thread::pending_exception_offset()), NULL_WORD);\n@@ -3569,1 +3569,1 @@\n-  void load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask=NULL) {\n+  void load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask = xnoreg) {\n@@ -3571,1 +3571,1 @@\n-    if (xmm_shuf_mask != NULL) {\n+    if (xmm_shuf_mask != xnoreg) {\n@@ -4977,9 +4977,6 @@\n-  void ev_load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask = NULL) {\n-    __ movdqu(xmmdst, Address(key, offset));\n-    if (xmm_shuf_mask != NULL) {\n-      __ pshufb(xmmdst, xmm_shuf_mask);\n-    } else {\n-      __ pshufb(xmmdst, ExternalAddress(StubRoutines::x86::key_shuffle_mask_addr()));\n-    }\n-    __ evshufi64x2(xmmdst, xmmdst, xmmdst, 0x0, Assembler::AVX_512bit);\n-\n+void ev_load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask = xnoreg) {\n+  __ movdqu(xmmdst, Address(key, offset));\n+  if (xmm_shuf_mask != xnoreg) {\n+    __ pshufb(xmmdst, xmm_shuf_mask);\n+  } else {\n+    __ pshufb(xmmdst, ExternalAddress(StubRoutines::x86::key_shuffle_mask_addr()));\n@@ -4987,0 +4984,3 @@\n+  __ evshufi64x2(xmmdst, xmmdst, xmmdst, 0x0, Assembler::AVX_512bit);\n+\n+}\n@@ -7397,3 +7397,0 @@\n-    const Register tmp2 = r9;\n-    const Register tmp3 = r10;\n-    const Register tmp4 = r11;\n@@ -7408,1 +7405,1 @@\n-    __ fast_sin(x0, x1, x2, x3, x4, x5, x6, x7, rax, rbx, rcx, rdx, tmp1, tmp2, tmp3, tmp4);\n+    __ fast_sin(x0, x1, x2, x3, x4, x5, x6, x7, rax, rbx, rcx, rdx, tmp1);\n@@ -7844,2 +7841,1 @@\n-    __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()),\n-            (int32_t) NULL_WORD);\n+    __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), NULL_WORD);\n@@ -7936,18 +7932,0 @@\n-      if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dsin) ||\n-          vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dcos) ||\n-          vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dtan)) {\n-        StubRoutines::x86::_ONEHALF_adr = (address)StubRoutines::x86::_ONEHALF;\n-        StubRoutines::x86::_P_2_adr = (address)StubRoutines::x86::_P_2;\n-        StubRoutines::x86::_SC_4_adr = (address)StubRoutines::x86::_SC_4;\n-        StubRoutines::x86::_Ctable_adr = (address)StubRoutines::x86::_Ctable;\n-        StubRoutines::x86::_SC_2_adr = (address)StubRoutines::x86::_SC_2;\n-        StubRoutines::x86::_SC_3_adr = (address)StubRoutines::x86::_SC_3;\n-        StubRoutines::x86::_SC_1_adr = (address)StubRoutines::x86::_SC_1;\n-        StubRoutines::x86::_PI_INV_TABLE_adr = (address)StubRoutines::x86::_PI_INV_TABLE;\n-        StubRoutines::x86::_PI_4_adr = (address)StubRoutines::x86::_PI_4;\n-        StubRoutines::x86::_PI32INV_adr = (address)StubRoutines::x86::_PI32INV;\n-        StubRoutines::x86::_SIGN_MASK_adr = (address)StubRoutines::x86::_SIGN_MASK;\n-        StubRoutines::x86::_P_1_adr = (address)StubRoutines::x86::_P_1;\n-        StubRoutines::x86::_P_3_adr = (address)StubRoutines::x86::_P_3;\n-        StubRoutines::x86::_NEG_ZERO_adr = (address)StubRoutines::x86::_NEG_ZERO;\n-      }\n@@ -8371,1 +8349,1 @@\n-  __ addptr(rsp, (int32_t)ContinuationEntry::size());\n+  __ addptr(rsp, checked_cast<int32_t>(ContinuationEntry::size()));\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":17,"deletions":39,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -94,23 +94,0 @@\n-\/\/tables common for sin and cos\n-address StubRoutines::x86::_ONEHALF_adr = NULL;\n-address StubRoutines::x86::_P_2_adr = NULL;\n-address StubRoutines::x86::_SC_4_adr = NULL;\n-address StubRoutines::x86::_Ctable_adr = NULL;\n-address StubRoutines::x86::_SC_2_adr = NULL;\n-address StubRoutines::x86::_SC_3_adr = NULL;\n-address StubRoutines::x86::_SC_1_adr = NULL;\n-address StubRoutines::x86::_PI_INV_TABLE_adr = NULL;\n-address StubRoutines::x86::_PI_4_adr = NULL;\n-address StubRoutines::x86::_PI32INV_adr = NULL;\n-address StubRoutines::x86::_SIGN_MASK_adr = NULL;\n-address StubRoutines::x86::_P_1_adr = NULL;\n-address StubRoutines::x86::_P_3_adr = NULL;\n-address StubRoutines::x86::_NEG_ZERO_adr = NULL;\n-\n-\/\/tables common for sincos and tancot\n-address StubRoutines::x86::_L_2il0floatpacket_0_adr = NULL;\n-address StubRoutines::x86::_Pi4Inv_adr = NULL;\n-address StubRoutines::x86::_Pi4x3_adr = NULL;\n-address StubRoutines::x86::_Pi4x4_adr = NULL;\n-address StubRoutines::x86::_ones_adr = NULL;\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.cpp","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -214,42 +214,0 @@\n-  \/\/tables common for LIBM sin and cos\n-  static juint _ONEHALF[];\n-  static address _ONEHALF_adr;\n-  static juint _P_2[];\n-  static address _P_2_adr;\n-  static juint _SC_4[];\n-  static address _SC_4_adr;\n-  static juint _Ctable[];\n-  static address _Ctable_adr;\n-  static juint _SC_2[];\n-  static address _SC_2_adr;\n-  static juint _SC_3[];\n-  static address _SC_3_adr;\n-  static juint _SC_1[];\n-  static address _SC_1_adr;\n-  static juint _PI_INV_TABLE[];\n-  static address _PI_INV_TABLE_adr;\n-  static juint _PI_4[];\n-  static address _PI_4_adr;\n-  static juint _PI32INV[];\n-  static address _PI32INV_adr;\n-  static juint _SIGN_MASK[];\n-  static address _SIGN_MASK_adr;\n-  static juint _P_1[];\n-  static address _P_1_adr;\n-  static juint _P_3[];\n-  static address _P_3_adr;\n-  static juint _NEG_ZERO[];\n-  static address _NEG_ZERO_adr;\n-\n-  \/\/tables common for LIBM sincos and tancot\n-  static juint _L_2il0floatpacket_0[];\n-  static address _L_2il0floatpacket_0_adr;\n-  static juint _Pi4Inv[];\n-  static address _Pi4Inv_adr;\n-  static juint _Pi4x3[];\n-  static address _Pi4x3_adr;\n-  static juint _Pi4x4[];\n-  static address _Pi4x4_adr;\n-  static juint _ones[];\n-  static address _ones_adr;\n-\n@@ -394,20 +352,0 @@\n-  static address _ONEHALF_addr()      { return _ONEHALF_adr; }\n-  static address _P_2_addr()      { return _P_2_adr; }\n-  static address _SC_4_addr()      { return _SC_4_adr; }\n-  static address _Ctable_addr()      { return _Ctable_adr; }\n-  static address _SC_2_addr()      { return _SC_2_adr; }\n-  static address _SC_3_addr()      { return _SC_3_adr; }\n-  static address _SC_1_addr()      { return _SC_1_adr; }\n-  static address _PI_INV_TABLE_addr()      { return _PI_INV_TABLE_adr; }\n-  static address _PI_4_addr()      { return _PI_4_adr; }\n-  static address _PI32INV_addr()      { return _PI32INV_adr; }\n-  static address _SIGN_MASK_addr()      { return _SIGN_MASK_adr; }\n-  static address _P_1_addr()      { return _P_1_adr; }\n-  static address _P_3_addr()      { return _P_3_adr; }\n-  static address _NEG_ZERO_addr()      { return _NEG_ZERO_adr; }\n-  static address _L_2il0floatpacket_0_addr()      { return _L_2il0floatpacket_0_adr; }\n-  static address _Pi4Inv_addr()      { return _Pi4Inv_adr; }\n-  static address _Pi4x3_addr()      { return _Pi4x3_adr; }\n-  static address _Pi4x4_addr()      { return _Pi4x4_adr; }\n-  static address _ones_addr()      { return _ones_adr; }\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":0,"deletions":62,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -209,1 +209,1 @@\n-  __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), (int32_t)NULL_WORD);\n+  __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), NULL_WORD);\n@@ -257,1 +257,1 @@\n-  __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), (int32_t)NULL_WORD);\n+  __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), NULL_WORD);\n@@ -291,1 +291,1 @@\n-    __ cmpptr(Address(thread, Thread::pending_exception_offset()), (int32_t) NULL_WORD);\n+    __ cmpptr(Address(thread, Thread::pending_exception_offset()), NULL_WORD);\n@@ -512,1 +512,1 @@\n-  __ cmpptr(stack_limit, (int32_t)NULL_WORD);\n+  __ cmpptr(stack_limit, NULL_WORD);\n@@ -623,1 +623,1 @@\n-  __ push((int)NULL_WORD); \/\/ leave last_sp as null\n+  __ push(NULL_WORD); \/\/ leave last_sp as null\n@@ -754,1 +754,1 @@\n-  __ cmpptr(Address(thread, JavaThread::shadow_zone_safe_limit()), (int32_t)NULL_WORD);\n+  __ cmpptr(Address(thread, JavaThread::shadow_zone_safe_limit()), NULL_WORD);\n@@ -760,1 +760,1 @@\n-  __ cmpptr(Address(thread, JavaThread::shadow_zone_growth_watermark()), (int32_t)NULL_WORD);\n+  __ cmpptr(Address(thread, JavaThread::shadow_zone_growth_watermark()), NULL_WORD);\n@@ -826,1 +826,1 @@\n-  __ push((int) NULL_WORD);\n+  __ push(NULL_WORD);\n@@ -829,1 +829,1 @@\n-  __ push((int) NULL_WORD);\n+  __ push(NULL_WORD);\n@@ -1159,1 +1159,1 @@\n-  __ movl(Address(t, JNIHandleBlock::top_offset_in_bytes()), (int32_t)NULL_WORD);\n+  __ movl(Address(t, JNIHandleBlock::top_offset_in_bytes()), NULL_WORD);\n@@ -1218,1 +1218,1 @@\n-    __ cmpptr(Address(thread, Thread::pending_exception_offset()), (int32_t) NULL_WORD);\n+    __ cmpptr(Address(thread, Thread::pending_exception_offset()), NULL_WORD);\n@@ -1375,1 +1375,1 @@\n-    __ push((int) NULL_WORD); \/\/ initialize local variables\n+    __ push(NULL_WORD); \/\/ initialize local variables\n@@ -1490,1 +1490,1 @@\n-  __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), (int32_t)NULL_WORD);\n+  __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), NULL_WORD);\n@@ -1636,1 +1636,1 @@\n-  __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), (int32_t)NULL_WORD);\n+  __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), NULL_WORD);\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -4284,1 +4284,1 @@\n-    __ cmpptr(Address(rtop, BasicObjectLock::obj_offset_in_bytes()), (int32_t) NULL_WORD);\n+    __ cmpptr(Address(rtop, BasicObjectLock::obj_offset_in_bytes()), NULL_WORD);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    for (int j = 0 ; j < XMMRegisterImpl::max_slots_per_register ; j++) {\n+    for (int j = 0 ; j < XMMRegister::max_slots_per_register ; j++) {\n@@ -59,1 +59,1 @@\n-    for (int j = 0; j < KRegisterImpl::max_slots_per_register; j++) {\n+    for (int j = 0; j < KRegister::max_slots_per_register; j++) {\n","filename":"src\/hotspot\/cpu\/x86\/vmreg_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-    (XMMRegisterImpl::max_slots_per_register * XMMRegisterImpl::available_xmm_registers());\n+    (XMMRegister::max_slots_per_register * XMMRegister::available_xmm_registers());\n@@ -90,1 +90,1 @@\n-    return base % XMMRegisterImpl::max_slots_per_register == 0;\n+    return (base % XMMRegister::max_slots_per_register) == 0;\n","filename":"src\/hotspot\/cpu\/x86\/vmreg_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,7 +28,2 @@\n-inline VMReg RegisterImpl::as_VMReg() const {\n-  if( this==noreg ) return VMRegImpl::Bad();\n-#ifdef AMD64\n-  return VMRegImpl::as_VMReg(encoding() << 1 );\n-#else\n-  return VMRegImpl::as_VMReg(encoding() );\n-#endif \/\/ AMD64\n+inline VMReg Register::RegisterImpl::as_VMReg() const {\n+  return VMRegImpl::as_VMReg(encoding() LP64_ONLY( << 1 ));\n@@ -37,1 +32,1 @@\n-inline VMReg FloatRegisterImpl::as_VMReg() const {\n+inline VMReg FloatRegister::FloatRegisterImpl::as_VMReg() const {\n@@ -41,1 +36,1 @@\n-inline VMReg XMMRegisterImpl::as_VMReg() const {\n+inline VMReg XMMRegister::XMMRegisterImpl::as_VMReg() const {\n@@ -45,1 +40,1 @@\n-inline VMReg KRegisterImpl::as_VMReg() const {\n+inline VMReg KRegister::KRegisterImpl::as_VMReg() const {\n","filename":"src\/hotspot\/cpu\/x86\/vmreg_x86.inline.hpp","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-    __ cmpptr(method, (int32_t)NULL_WORD);\n+    __ cmpptr(method, NULL_WORD);\n@@ -130,1 +130,1 @@\n-    __ cmpptr(Address(method, Method::from_compiled_offset()), (int32_t)NULL_WORD);\n+    __ cmpptr(Address(method, Method::from_compiled_offset()), NULL_WORD);\n@@ -240,1 +240,1 @@\n-    __ cmpptr(method, (int32_t)NULL_WORD);\n+    __ cmpptr(method, NULL_WORD);\n@@ -242,1 +242,1 @@\n-    __ cmpptr(Address(method, Method::from_compiled_offset()), (int32_t)NULL_WORD);\n+    __ cmpptr(Address(method, Method::from_compiled_offset()), NULL_WORD);\n","filename":"src\/hotspot\/cpu\/x86\/vtableStubs_x86_32.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-    __ cmpptr(method, (int32_t)NULL_WORD);\n+    __ cmpptr(method, NULL_WORD);\n@@ -122,1 +122,1 @@\n-    __ cmpptr(Address(method, Method::from_compiled_offset()), (int32_t)NULL_WORD);\n+    __ cmpptr(Address(method, Method::from_compiled_offset()), NULL_WORD);\n@@ -238,1 +238,1 @@\n-    __ cmpptr(method, (int32_t)NULL_WORD);\n+    __ cmpptr(method, NULL_WORD);\n@@ -240,1 +240,1 @@\n-    __ cmpptr(Address(method, Method::from_compiled_offset()), (int32_t)NULL_WORD);\n+    __ cmpptr(Address(method, Method::from_compiled_offset()), NULL_WORD);\n","filename":"src\/hotspot\/cpu\/x86\/vtableStubs_x86_64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -258,1 +258,2 @@\n-#define   HIGH_FROM_LOW(x) ((x)+2)\n+#define   HIGH_FROM_LOW(x) (as_Register((x)->encoding()+2))\n+#define   HIGH_FROM_LOW_ENC(x) ((x)+2)\n@@ -1653,1 +1654,1 @@\n-    emit_rm(cbuf, 0x3, $tertiary, HIGH_FROM_LOW($dst$$reg));\n+    emit_rm(cbuf, 0x3, $tertiary, HIGH_FROM_LOW_ENC($dst$$reg));\n@@ -1664,1 +1665,1 @@\n-    int desthi = HIGH_FROM_LOW(destlo);\n+    int desthi = HIGH_FROM_LOW_ENC(destlo);\n@@ -1949,1 +1950,1 @@\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($src$$reg));\n+    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), HIGH_FROM_LOW_ENC($src$$reg));\n@@ -1957,1 +1958,1 @@\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($src$$reg));\n+    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), HIGH_FROM_LOW_ENC($src$$reg));\n@@ -1961,1 +1962,1 @@\n-    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($src$$reg));\n+    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($src$$reg));\n@@ -2086,1 +2087,1 @@\n-    int reg_encoding = HIGH_FROM_LOW($ereg$$reg);  \/\/ Hi register of pair, computed from lo\n+    int reg_encoding = HIGH_FROM_LOW_ENC($ereg$$reg);  \/\/ Hi register of pair, computed from lo\n@@ -2097,2 +2098,2 @@\n-    if( $tertiary == 0xA4 ) { r1 = $dst$$reg;  r2 = HIGH_FROM_LOW($dst$$reg); }\n-    else                    { r2 = $dst$$reg;  r1 = HIGH_FROM_LOW($dst$$reg); }\n+    if( $tertiary == 0xA4 ) { r1 = $dst$$reg;  r2 = HIGH_FROM_LOW_ENC($dst$$reg); }\n+    else                    { r2 = $dst$$reg;  r1 = HIGH_FROM_LOW_ENC($dst$$reg); }\n@@ -2110,1 +2111,1 @@\n-    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg));\n+    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($dst$$reg));\n@@ -2117,1 +2118,1 @@\n-    emit_rm(cbuf, 0x3, $secondary, HIGH_FROM_LOW($dst$$reg));\n+    emit_rm(cbuf, 0x3, $secondary, HIGH_FROM_LOW_ENC($dst$$reg));\n@@ -2123,2 +2124,2 @@\n-    if( $secondary == 0x5 ) { r1 = $dst$$reg;  r2 = HIGH_FROM_LOW($dst$$reg); }\n-    else                    { r2 = $dst$$reg;  r1 = HIGH_FROM_LOW($dst$$reg); }\n+    if( $secondary == 0x5 ) { r1 = $dst$$reg;  r2 = HIGH_FROM_LOW_ENC($dst$$reg); }\n+    else                    { r2 = $dst$$reg;  r1 = HIGH_FROM_LOW_ENC($dst$$reg); }\n@@ -2268,1 +2269,1 @@\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg );\n+    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $dst$$reg );\n@@ -2276,1 +2277,1 @@\n-    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg));\n+    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($dst$$reg));\n@@ -2292,1 +2293,1 @@\n-    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg) );\n+    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2295,1 +2296,1 @@\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($dst$$reg));\n+    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), HIGH_FROM_LOW_ENC($dst$$reg));\n@@ -2300,1 +2301,1 @@\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg);\n+    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $dst$$reg);\n@@ -2303,1 +2304,1 @@\n-    emit_rm(cbuf, 0x3, 0x5, HIGH_FROM_LOW($dst$$reg) );\n+    emit_rm(cbuf, 0x3, 0x5, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2316,1 +2317,1 @@\n-    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg) );\n+    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2319,1 +2320,1 @@\n-    emit_rm(cbuf, 0x3, 7, HIGH_FROM_LOW($dst$$reg) );\n+    emit_rm(cbuf, 0x3, 7, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2325,1 +2326,1 @@\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg);\n+    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $dst$$reg);\n@@ -2328,1 +2329,1 @@\n-    emit_rm(cbuf, 0x3, 0x7, HIGH_FROM_LOW($dst$$reg) );\n+    emit_rm(cbuf, 0x3, 0x7, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2658,1 +2659,1 @@\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW($src1$$reg), HIGH_FROM_LOW($src2$$reg) );\n+    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($src1$$reg), HIGH_FROM_LOW_ENC($src2$$reg) );\n@@ -2674,1 +2675,1 @@\n-    encode_Copy( cbuf, HIGH_FROM_LOW(dst_encoding), src_encoding );\n+    encode_Copy( cbuf, HIGH_FROM_LOW_ENC(dst_encoding), src_encoding );\n@@ -2677,1 +2678,1 @@\n-    emit_rm(cbuf, 0x3, 7, HIGH_FROM_LOW(dst_encoding) );\n+    emit_rm(cbuf, 0x3, 7, HIGH_FROM_LOW_ENC(dst_encoding) );\n@@ -2683,1 +2684,1 @@\n-    emit_opcode(cbuf, 0x50+HIGH_FROM_LOW($src$$reg));\n+    emit_opcode(cbuf, 0x50+HIGH_FROM_LOW_ENC($src$$reg));\n@@ -2713,1 +2714,1 @@\n-    emit_opcode(cbuf, 0x50+HIGH_FROM_LOW($src$$reg));\n+    emit_opcode(cbuf, 0x50+HIGH_FROM_LOW_ENC($src$$reg));\n@@ -2745,1 +2746,1 @@\n-    emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($dst$$reg) );\n+    emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2747,1 +2748,1 @@\n-    encode_Copy( cbuf, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($src$$reg) );\n+    encode_Copy( cbuf, HIGH_FROM_LOW_ENC($dst$$reg), HIGH_FROM_LOW_ENC($src$$reg) );\n@@ -2751,1 +2752,1 @@\n-    emit_rm( cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg );\n+    emit_rm( cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $dst$$reg );\n@@ -2754,1 +2755,1 @@\n-    emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($dst$$reg) );\n+    emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2760,1 +2761,1 @@\n-    emit_rm( cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $tmp$$reg );\n+    emit_rm( cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $tmp$$reg );\n@@ -2768,1 +2769,1 @@\n-    emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($dst$$reg) );\n+    emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2783,1 +2784,1 @@\n-    emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src1$$reg) );\n+    emit_opcode(cbuf, HIGH_FROM_LOW_ENC(0x50+$src1$$reg) );\n@@ -2787,1 +2788,1 @@\n-    emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src2$$reg) );\n+    emit_opcode(cbuf, HIGH_FROM_LOW_ENC(0x50+$src2$$reg) );\n@@ -2804,1 +2805,1 @@\n-    emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src1$$reg) );\n+    emit_opcode(cbuf, HIGH_FROM_LOW_ENC(0x50+$src1$$reg) );\n@@ -2808,1 +2809,1 @@\n-    emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src2$$reg) );\n+    emit_opcode(cbuf, HIGH_FROM_LOW_ENC(0x50+$src2$$reg) );\n@@ -2829,1 +2830,1 @@\n-    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src$$reg));\n+    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($src$$reg));\n@@ -2841,1 +2842,1 @@\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW($src1$$reg), HIGH_FROM_LOW($src2$$reg) );\n+    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($src1$$reg), HIGH_FROM_LOW_ENC($src2$$reg) );\n@@ -2850,1 +2851,1 @@\n-    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src1$$reg) );\n+    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($src1$$reg) );\n@@ -2853,1 +2854,1 @@\n-    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src2$$reg) );\n+    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($src2$$reg) );\n@@ -2865,1 +2866,1 @@\n-    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src$$reg) );\n+    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($src$$reg) );\n@@ -2871,1 +2872,1 @@\n-    emit_rm    (cbuf,0x3, 0x3, HIGH_FROM_LOW($dst$$reg));\n+    emit_rm    (cbuf,0x3, 0x3, HIGH_FROM_LOW_ENC($dst$$reg));\n@@ -2875,1 +2876,1 @@\n-    emit_rm    (cbuf,0x3, 0x3, HIGH_FROM_LOW($dst$$reg));\n+    emit_rm    (cbuf,0x3, 0x3, HIGH_FROM_LOW_ENC($dst$$reg));\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":46,"deletions":45,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -6161,1 +6161,1 @@\n-      __ movl($mem$$Address, (int32_t)0);\n+      __ movl($mem$$Address, 0);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+#include \"runtime\/osInfo.hpp\"\n@@ -163,1 +164,0 @@\n-int       os::Aix::_page_size = -1;\n@@ -1754,12 +1754,0 @@\n-int os::vm_page_size() {\n-  \/\/ Seems redundant as all get out.\n-  assert(os::Aix::page_size() != -1, \"must call os::init\");\n-  return os::Aix::page_size();\n-}\n-\n-\/\/ Aix allocates memory by pages.\n-int os::vm_allocation_granularity() {\n-  assert(os::Aix::page_size() != -1, \"must call os::init\");\n-  return os::Aix::page_size();\n-}\n-\n@@ -2231,0 +2219,5 @@\n+static void set_page_size(int page_size) {\n+  OSInfo::set_vm_page_size(page_size);\n+  OSInfo::set_vm_allocation_granularity(page_size);\n+}\n+\n@@ -2287,1 +2280,1 @@\n-        Aix::_page_size = 64*K;\n+        set_page_size(64*K);\n@@ -2290,1 +2283,1 @@\n-        Aix::_page_size = 4*K;\n+        set_page_size(4*K);\n@@ -2296,1 +2289,1 @@\n-      Aix::_page_size = 4*K;\n+      set_page_size(4*K);\n@@ -2305,1 +2298,1 @@\n-    Aix::_page_size = 64*K;\n+    set_page_size(64*K);\n@@ -2312,1 +2305,1 @@\n-  _page_sizes.add(Aix::_page_size);\n+  _page_sizes.add(os::vm_page_size());\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":11,"deletions":18,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-  static int _page_size;\n@@ -89,5 +88,0 @@\n-  static int page_size(void) {\n-    assert(_page_size != -1, \"not initialized\");\n-    return _page_size;\n-  }\n-\n@@ -180,1 +174,1 @@\n-  static bool platform_print_native_stack(outputStream* st, void* context, char *buf, int buf_size);\n+  static bool platform_print_native_stack(outputStream* st, const void* context, char *buf, int buf_size);\n","filename":"src\/hotspot\/os\/aix\/os_aix.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+#include \"runtime\/osInfo.hpp\"\n@@ -124,1 +125,0 @@\n-int os::Bsd::_page_size = -1;\n@@ -1480,12 +1480,0 @@\n-int os::vm_page_size() {\n-  \/\/ Seems redundant as all get out\n-  assert(os::Bsd::page_size() != -1, \"must call os::init\");\n-  return os::Bsd::page_size();\n-}\n-\n-\/\/ Solaris allocates memory by pages.\n-int os::vm_allocation_granularity() {\n-  assert(os::Bsd::page_size() != -1, \"must call os::init\");\n-  return os::Bsd::page_size();\n-}\n-\n@@ -1669,1 +1657,1 @@\n-  char* bottom = (char*)align_down((intptr_t)addr, os::Bsd::page_size());\n+  char* bottom = (char*)align_down((intptr_t)addr, os::vm_page_size());\n@@ -1678,1 +1666,1 @@\n-  size = align_up(pointer_delta(addr, bottom, 1) + size, os::Bsd::page_size());\n+  size = align_up(pointer_delta(addr, bottom, 1) + size, os::vm_page_size());\n@@ -1932,3 +1920,5 @@\n-  Bsd::set_page_size(getpagesize());\n-  if (Bsd::page_size() == -1) {\n-    fatal(\"os_bsd.cpp: os::init: sysconf failed (%s)\", os::strerror(errno));\n+  int page_size = getpagesize();\n+  OSInfo::set_vm_page_size(page_size);\n+  OSInfo::set_vm_allocation_granularity(page_size);\n+  if (os::vm_page_size() <= 0) {\n+    fatal(\"os_bsd.cpp: os::init: getpagesize() failed (%s)\", os::strerror(errno));\n@@ -1936,1 +1926,1 @@\n-  _page_sizes.add(Bsd::page_size());\n+  _page_sizes.add(os::vm_page_size());\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":9,"deletions":19,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-  static int _page_size;\n@@ -65,3 +64,0 @@\n-  static int page_size(void)                                        { return _page_size; }\n-  static void set_page_size(int val)                                { _page_size = val; }\n-\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+#include \"runtime\/osInfo.hpp\"\n@@ -165,1 +166,0 @@\n-int os::Linux::_page_size = -1;\n@@ -608,2 +608,2 @@\n-  bottom = (address)align_down((uintptr_t)bottom, os::Linux::page_size());\n-  bottom += os::Linux::page_size() - 1;\n+  bottom = (address)align_down((uintptr_t)bottom, os::vm_page_size());\n+  bottom += os::vm_page_size() - 1;\n@@ -1081,2 +1081,2 @@\n-  if (stack_size >= (size_t)(3 * page_size())) {\n-    stack_size -= 2 * page_size();\n+  if (stack_size >= (size_t)(3 * os::vm_page_size())) {\n+    stack_size -= 2 * os::vm_page_size();\n@@ -1238,1 +1238,1 @@\n-    stack_size -= 16 * page_size();\n+    stack_size -= 16 * os::vm_page_size();\n@@ -1242,1 +1242,1 @@\n-  stack_top = align_up(stack_top, page_size());\n+  stack_top = align_up(stack_top, os::vm_page_size());\n@@ -1252,1 +1252,1 @@\n-  _initial_thread_stack_size = align_down(_initial_thread_stack_size, page_size());\n+  _initial_thread_stack_size = align_down(_initial_thread_stack_size, os::vm_page_size());\n@@ -2597,12 +2597,0 @@\n-int os::vm_page_size() {\n-  \/\/ Seems redundant as all get out\n-  assert(os::Linux::page_size() != -1, \"must call os::init\");\n-  return os::Linux::page_size();\n-}\n-\n-\/\/ Solaris allocates memory by pages.\n-int os::vm_allocation_granularity() {\n-  assert(os::Linux::page_size() != -1, \"must call os::init\");\n-  return os::Linux::page_size();\n-}\n-\n@@ -3015,1 +3003,1 @@\n-  return ((thr_type == java_thread || thr_type == compiler_thread) ? 0 : page_size());\n+  return ((thr_type == java_thread || thr_type == compiler_thread) ? 0 : os::vm_page_size());\n@@ -3426,1 +3414,1 @@\n-  char* bottom = (char*)align_down((intptr_t)addr, os::Linux::page_size());\n+  char* bottom = (char*)align_down((intptr_t)addr, os::vm_page_size());\n@@ -3435,1 +3423,1 @@\n-  size = align_up(pointer_delta(addr, bottom, 1) + size, os::Linux::page_size());\n+  size = align_up(pointer_delta(addr, bottom, 1) + size, os::vm_page_size());\n@@ -4318,1 +4306,1 @@\n-  size_t size = os::Linux::page_size();\n+  size_t size = os::vm_page_size();\n@@ -4343,2 +4331,4 @@\n-  Linux::set_page_size(sysconf(_SC_PAGESIZE));\n-  if (Linux::page_size() == -1) {\n+  int page_size = sysconf(_SC_PAGESIZE);\n+  OSInfo::set_vm_page_size(page_size);\n+  OSInfo::set_vm_allocation_granularity(page_size);\n+  if (os::vm_page_size() <= 0) {\n@@ -4348,1 +4338,1 @@\n-  _page_sizes.add(Linux::page_size());\n+  _page_sizes.add(os::vm_page_size());\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":17,"deletions":27,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-  static int _page_size;\n@@ -135,3 +134,0 @@\n-  static int page_size(void)                                        { return _page_size; }\n-  static void set_page_size(int val)                                { _page_size = val; }\n-\n@@ -431,1 +427,1 @@\n-  void* resolve_function_descriptor(void* p);\n+  static void* resolve_function_descriptor(void* p);\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -893,1 +893,1 @@\n-void os::run_periodic_checks() {\n+void os::run_periodic_checks(outputStream* st) {\n@@ -927,2 +927,2 @@\n-    os::print_signal_handlers(tty, buf, O_BUFLEN);\n-    tty->print_cr(\"Consider using jsig library.\");\n+    os::print_signal_handlers(st, buf, O_BUFLEN);\n+    st->print_cr(\"Consider using jsig library.\");\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+#include \"runtime\/osInfo.hpp\"\n@@ -271,1 +272,1 @@\n-\/\/ This method is  a periodic task to check for misbehaving JNI applications\n+\/\/ This method is a periodic task to check for misbehaving JNI applications\n@@ -274,1 +275,1 @@\n-void os::run_periodic_checks() {\n+void os::run_periodic_checks(outputStream* st) {\n@@ -2865,5 +2866,0 @@\n-int os::vm_page_size() { return os::win32::vm_page_size(); }\n-int os::vm_allocation_granularity() {\n-  return os::win32::vm_allocation_granularity();\n-}\n-\n@@ -3165,1 +3161,1 @@\n-  const size_t default_page_size = (size_t) vm_page_size();\n+  const size_t default_page_size = (size_t) os::vm_page_size();\n@@ -3884,2 +3880,0 @@\n-int    os::win32::_vm_page_size              = 0;\n-int    os::win32::_vm_allocation_granularity = 0;\n@@ -3901,2 +3895,2 @@\n-  _vm_page_size    = si.dwPageSize;\n-  _vm_allocation_granularity = si.dwAllocationGranularity;\n+  OSInfo::set_vm_page_size(si.dwPageSize);\n+  OSInfo::set_vm_allocation_granularity(si.dwAllocationGranularity);\n@@ -4216,1 +4210,1 @@\n-  _page_sizes.add(win32::vm_page_size());\n+  _page_sizes.add(os::vm_page_size());\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":7,"deletions":13,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -40,2 +40,0 @@\n-  static int    _vm_page_size;\n-  static int    _vm_allocation_granularity;\n@@ -88,6 +86,0 @@\n-  \/\/ Returns the byte size of a virtual memory page\n-  static int vm_page_size() { return _vm_page_size; }\n-\n-  \/\/ Returns the size in bytes of memory blocks which can be allocated.\n-  static int vm_allocation_granularity() { return _vm_allocation_granularity; }\n-\n","filename":"src\/hotspot\/os\/windows\/os_windows.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-  const int page_size = os::win32::vm_page_size();\n+  const int page_size = os::vm_page_size();\n","filename":"src\/hotspot\/os\/windows\/os_windows.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -513,1 +513,1 @@\n-bool os::Aix::platform_print_native_stack(outputStream* st, void* context, char *buf, int buf_size) {\n+bool os::Aix::platform_print_native_stack(outputStream* st, const void* context, char *buf, int buf_size) {\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/os_aix_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-  size_t page_bytes = os::Linux::page_size();\n+  size_t page_bytes = os::vm_page_size();\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/os_linux_zero.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2277,0 +2277,3 @@\n+#endif\n+#if defined(AARCH64)\n+    if (strcmp(rep_var,\"$PRegister\") == 0)  return \"as_PRegister\";\n","filename":"src\/hotspot\/share\/adlc\/output_c.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"compiler\/compiler_globals.hpp\"\n@@ -34,0 +33,2 @@\n+#include \"utilities\/linkedlist.hpp\"\n+#include \"utilities\/resizeableResourceHash.hpp\"\n@@ -401,0 +402,3 @@\n+  typedef LinkedListImpl<int> Offsets;\n+  typedef ResizeableResourceHashtable<address, Offsets> SharedTrampolineRequests;\n+\n@@ -427,0 +431,1 @@\n+  SharedTrampolineRequests*   _shared_trampoline_requests;     \/\/ used to collect requests for shared trampolines\n@@ -448,0 +453,1 @@\n+    _shared_trampoline_requests = NULL;\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -143,1 +143,3 @@\n-    assert(start <= end, \"must be\");\n+    int start_enc = start->encoding();\n+    int   end_enc = end->encoding();\n+    assert(start_enc <= end_enc, \"must be\");\n@@ -145,3 +147,3 @@\n-    bits <<= start->encoding();\n-    bits <<= 31 - end->encoding();\n-    bits >>= 31 - end->encoding();\n+    bits <<= start_enc;\n+    bits <<= 31 - end_enc;\n+    bits >>= 31 - end_enc;\n","filename":"src\/hotspot\/share\/asm\/register.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -162,0 +162,1 @@\n+  _dumped_to_src_obj_table(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE),\n@@ -633,0 +634,8 @@\n+  {\n+    bool created;\n+    _dumped_to_src_obj_table.put_if_absent((address)dest, src, &created);\n+    assert(created, \"must be\");\n+    if (_dumped_to_src_obj_table.maybe_grow()) {\n+      log_info(cds, hashtables)(\"Expanded _dumped_to_src_obj_table table to %d\", _dumped_to_src_obj_table.table_size());\n+    }\n+  }\n@@ -653,0 +662,7 @@\n+address ArchiveBuilder::get_src_obj(address dumped_addr) const {\n+  assert(is_in_buffer_space(dumped_addr), \"must be\");\n+  address* src_obj = _dumped_to_src_obj_table.get(dumped_addr);\n+  assert(src_obj != NULL && *src_obj != NULL, \"must be\");\n+  return *src_obj;\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -203,0 +203,1 @@\n+  ResizeableResourceHashtable<address, address, ResourceObj::C_HEAP, mtClassShared> _dumped_to_src_obj_table;\n@@ -386,0 +387,6 @@\n+  \/\/ + When creating a CDS archive, we first load Java classes and create metadata\n+  \/\/   objects as usual. These are call \"source\" objects.\n+  \/\/ + We then copy the source objects into the output buffer at \"dumped addresses\".\n+  \/\/\n+  \/\/ The following functions translate between these two (non-overlapping) spaces.\n+  \/\/ (The API should be renamed to be less confusing!)\n@@ -387,0 +394,4 @@\n+  address get_src_obj(address dumped_addr) const;\n+  template <typename T> T get_src_obj(T dumped_addr) const {\n+    return (T)get_src_obj((address)dumped_addr);\n+  }\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -104,0 +104,4 @@\n+\n+  \/\/ This is the same as java\/util\/ImmutableCollections::EMPTY_SET, which is archived\n+  ADD_EXCL(\"java\/lang\/reflect\/AccessFlag$Location\",      \"EMPTY_SET\");             \/\/ E\n+\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -258,0 +258,1 @@\n+#if INCLUDE_G1GC\n@@ -262,0 +263,1 @@\n+#endif\n@@ -461,2 +463,10 @@\n-      FileMapInfo::fail_continue(\"A jar file is not the one used while building\"\n-                                 \" the shared archive file: %s\", name);\n+      const char* bad_jar_msg = \"A jar file is not the one used while building the shared archive file:\";\n+      FileMapInfo::fail_continue(\"%s %s\", bad_jar_msg, name);\n+      if (!log_is_enabled(Info, cds)) {\n+        log_warning(cds)(\"%s %s\", bad_jar_msg, name);\n+      }\n+      if (_timestamp != st.st_mtime) {\n+        log_warning(cds)(\"%s timestamp has changed.\", name);\n+      } else {\n+        log_warning(cds)(\"%s size has changed.\", name);\n+      }\n@@ -1053,1 +1063,5 @@\n-      fail_continue(\"shared class paths mismatch (hint: enable -Xlog:class+path=info to diagnose the failure)\");\n+      const char* mismatch_msg = \"shared class paths mismatch (hint: enable -Xlog:class+path=info to diagnose the failure)\";\n+      fail_continue(\"%s\", mismatch_msg);\n+      if (!log_is_enabled(Info, cds) && !log_is_enabled(Info, class, path)) {\n+        log_warning(cds)(\"%s\", mismatch_msg);\n+      }\n@@ -1525,0 +1539,1 @@\n+#if INCLUDE_G1GC\n@@ -1526,0 +1541,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -650,1 +650,0 @@\n-#ifndef PRODUCT\n@@ -655,1 +654,0 @@\n-#endif\n@@ -946,1 +944,0 @@\n-#ifdef ASSERT\n@@ -950,1 +947,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"ci\/ciReplay.hpp\"\n@@ -35,0 +34,1 @@\n+#include \"compiler\/compiler_globals.hpp\"\n@@ -194,9 +194,0 @@\n-#ifndef PRODUCT\n-      if (ReplayCompiles && o->is_klass()) {\n-        Klass* k = (Klass*)o;\n-        if (k->is_instance_klass() && ciReplay::is_klass_unresolved((InstanceKlass*)k)) {\n-          \/\/ Klass was unresolved at replay dump time. Simulate this case.\n-          return ciEnv::_unloaded_ciinstance_klass;\n-        }\n-      }\n-#endif\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n@@ -158,1 +159,0 @@\n-#ifdef ASSERT\n@@ -162,1 +162,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -264,1 +264,0 @@\n-#ifndef PRODUCT\n@@ -271,1 +270,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"ci\/ciReplay.hpp\"\n@@ -288,0 +289,8 @@\n+  if (ReplayCompiles && key->is_klass()) {\n+    Klass* k = (Klass*)key;\n+    if (k->is_instance_klass() && ciReplay::is_klass_unresolved((InstanceKlass*)k)) {\n+      \/\/ Klass was unresolved at replay dump time. Simulate this case.\n+      return ciEnv::_unloaded_ciinstance_klass;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n@@ -59,2 +60,0 @@\n-#ifndef PRODUCT\n-\n@@ -1587,1 +1586,0 @@\n-#endif \/\/ PRODUCT\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -102,1 +102,0 @@\n-#ifndef PRODUCT\n@@ -126,1 +125,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/ci\/ciReplay.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1014,5 +1014,1 @@\n-  GrowableArray<PackageEntry*>* loaded_class_pkgs = new GrowableArray<PackageEntry*>(50);\n-  {\n-    MutexLocker ml(THREAD, Module_lock);\n-\n-    PackageEntryTable* pe_table =\n+  PackageEntryTable* pe_table =\n@@ -1020,13 +1016,1 @@\n-\n-    \/\/ Collect the packages that have at least one loaded class.\n-    for (int x = 0; x < pe_table->table_size(); x++) {\n-      for (PackageEntry* package_entry = pe_table->bucket(x);\n-           package_entry != NULL;\n-           package_entry = package_entry->next()) {\n-        if (package_entry->has_loaded_class()) {\n-          loaded_class_pkgs->append(package_entry);\n-        }\n-      }\n-    }\n-  }\n-\n+  GrowableArray<PackageEntry*>* loaded_class_pkgs = pe_table->get_system_packages();\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":2,"deletions":18,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-    _packages = new PackageEntryTable(PackageEntryTable::_packagetable_entry_size);\n+    _packages = new PackageEntryTable();\n@@ -403,7 +403,1 @@\n-    for (int i = 0; i < _modules->table_size(); i++) {\n-      for (ModuleEntry* entry = _modules->bucket(i);\n-           entry != NULL;\n-           entry = entry->next()) {\n-        f(entry);\n-      }\n-    }\n+    _modules->modules_do(f);\n@@ -416,7 +410,1 @@\n-    for (int i = 0; i < _packages->table_size(); i++) {\n-      for (PackageEntry* entry = _packages->bucket(i);\n-           entry != NULL;\n-           entry = entry->next()) {\n-        f(entry);\n-      }\n-    }\n+    _packages->packages_do(f);\n@@ -595,1 +583,1 @@\n-      modules = new ModuleEntryTable(ModuleEntryTable::_moduletable_entry_size);\n+      modules = new ModuleEntryTable();\n@@ -718,1 +706,1 @@\n-    _unnamed_module->delete_unnamed_module();\n+    delete _unnamed_module;\n@@ -1043,0 +1031,4 @@\n+\n+  if (_modules != NULL) {\n+    _modules->verify();\n+  }\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":9,"deletions":17,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -394,8 +394,0 @@\n-void ClassLoaderDataGraph::modules_unloading_do(void f(ModuleEntry*)) {\n-  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n-  for (ClassLoaderData* cld = _unloading; cld != NULL; cld = cld->next()) {\n-    assert(cld->is_unloading(), \"invariant\");\n-    cld->modules_do(f);\n-  }\n-}\n-\n@@ -410,8 +402,0 @@\n-void ClassLoaderDataGraph::packages_unloading_do(void f(PackageEntry*)) {\n-  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n-  for (ClassLoaderData* cld = _unloading; cld != NULL; cld = cld->next()) {\n-    assert(cld->is_unloading(), \"invariant\");\n-    cld->packages_do(f);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.cpp","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,0 @@\n-  static void modules_unloading_do(void f(ModuleEntry*));\n@@ -87,1 +86,0 @@\n-  static void packages_unloading_do(void f(PackageEntry*));\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,2 +84,5 @@\n-  for (int i = 0; i < met->table_size(); i++) {\n-    for (ModuleEntry* m = met->bucket(i); m != NULL;) {\n+  class Process : public ModuleClosure {\n+    JavaThread* _current;\n+   public:\n+    Process(JavaThread* current) : _current(current) {}\n+    void do_module(ModuleEntry* m) {\n@@ -89,1 +92,1 @@\n-        ClassLoader::setup_module_search_path(current, path);\n+        ClassLoader::setup_module_search_path(_current, path);\n@@ -91,1 +94,0 @@\n-      m = m->next();\n@@ -93,1 +95,3 @@\n-  }\n+  };\n+  Process process(current);\n+  met->modules_do(&process);\n@@ -95,0 +99,1 @@\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -432,1 +432,1 @@\n-void LoaderConstraintTable::verify(PlaceholderTable* placeholders) {\n+void LoaderConstraintTable::verify() {\n@@ -453,1 +453,1 @@\n-          PlaceholderEntry* entry = placeholders->get_entry(name_hash, name, loader_data);\n+          PlaceholderEntry* entry = PlaceholderTable::get_entry(name, loader_data);\n","filename":"src\/hotspot\/share\/classfile\/loaderConstraints.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,1 @@\n-  void verify(PlaceholderTable* placeholders);\n+  void verify();\n","filename":"src\/hotspot\/share\/classfile\/loaderConstraints.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,5 +54,3 @@\n-  if (_location != NULL) {\n-    \/\/ _location symbol's refcounts are managed by ModuleEntry,\n-    \/\/ must decrement the old one before updating.\n-    _location->decrement_refcount();\n-  }\n+  \/\/ _location symbol's refcounts are managed by ModuleEntry,\n+  \/\/ must decrement the old one before updating.\n+  Symbol::maybe_decrement_refcount(_location);\n@@ -101,5 +99,3 @@\n-  if (_version != NULL) {\n-    \/\/ _version symbol's refcounts are managed by ModuleEntry,\n-    \/\/ must decrement the old one before updating.\n-    _version->decrement_refcount();\n-  }\n+  \/\/ _version symbol's refcounts are managed by ModuleEntry,\n+  \/\/ must decrement the old one before updating.\n+  Symbol::maybe_decrement_refcount(_version);\n@@ -109,3 +105,1 @@\n-  if (version != NULL) {\n-    version->increment_refcount();\n-  }\n+  Symbol::maybe_increment_refcount(version);\n@@ -265,0 +259,53 @@\n+ModuleEntry::ModuleEntry(Handle module_handle,\n+                         bool is_open, Symbol* name,\n+                         Symbol* version, Symbol* location,\n+                         ClassLoaderData* loader_data) :\n+    _name(name),\n+    _loader_data(loader_data),\n+    _reads(nullptr),\n+    _version(nullptr),\n+    _location(nullptr),\n+    CDS_ONLY(_shared_path_index(-1) COMMA)\n+    _can_read_all_unnamed(false),\n+    _has_default_read_edges(false),\n+    _must_walk_reads(false),\n+    _is_open(is_open),\n+    _is_patched(false) {\n+\n+  \/\/ Initialize fields specific to a ModuleEntry\n+  if (_name == nullptr) {\n+    \/\/ Unnamed modules can read all other unnamed modules.\n+    set_can_read_all_unnamed();\n+  } else {\n+    _name->increment_refcount();\n+  }\n+\n+  if (!module_handle.is_null()) {\n+    _module = loader_data->add_handle(module_handle);\n+  }\n+\n+  set_version(version);\n+\n+  \/\/ may need to add CDS info\n+  set_location(location);\n+\n+  if (name != nullptr && ClassLoader::is_in_patch_mod_entries(name)) {\n+    set_is_patched();\n+    if (log_is_enabled(Trace, module, patch)) {\n+      ResourceMark rm;\n+      log_trace(module, patch)(\"Marked module %s as patched from --patch-module\",\n+                               name != NULL ? name->as_C_string() : UNNAMED_MODULE);\n+    }\n+  }\n+\n+  JFR_ONLY(INIT_ID(this);)\n+}\n+\n+ModuleEntry::~ModuleEntry() {\n+  \/\/ Clean out the C heap allocated reads list first before freeing the entry\n+  delete_reads();\n+  Symbol::maybe_decrement_refcount(_name);\n+  Symbol::maybe_decrement_refcount(_version);\n+  Symbol::maybe_decrement_refcount(_location);\n+}\n+\n@@ -298,9 +345,0 @@\n-  ModuleEntry* entry = NEW_C_HEAP_OBJ(ModuleEntry, mtModule);\n-\n-  \/\/ Initialize everything BasicHashtable would\n-  entry->set_next(NULL);\n-  entry->set_hash(0);\n-  entry->set_literal(NULL);\n-\n-  \/\/ Initialize fields specific to a ModuleEntry\n-  entry->init();\n@@ -308,0 +346,3 @@\n+  ModuleEntry* entry = new ModuleEntry(module_handle, \/*is_open*\/true, \/*name*\/nullptr,\n+                                       \/*version*\/ nullptr, \/*location*\/ nullptr,\n+                                       cld);\n@@ -309,11 +350,1 @@\n-  entry->set_can_read_all_unnamed();\n-\n-  if (!module_handle.is_null()) {\n-    entry->set_module(cld->add_handle(module_handle));\n-  }\n-\n-  entry->set_loader_data(cld);\n-  entry->_is_open = true;\n-\n-  JFR_ONLY(INIT_ID(entry);)\n-\n+  assert(entry->can_read_all_unnamed(), \"constructor set that\");\n@@ -323,9 +354,1 @@\n-void ModuleEntry::delete_unnamed_module() {\n-  \/\/ Do not need unlink_entry() since the unnamed module is not in the hashtable\n-  FREE_C_HEAP_OBJ(this);\n-}\n-\n-ModuleEntryTable::ModuleEntryTable(int table_size)\n-  : Hashtable<Symbol*, mtModule>(table_size, sizeof(ModuleEntry))\n-{\n-}\n+ModuleEntryTable::ModuleEntryTable() { }\n@@ -334,19 +357,8 @@\n-  \/\/ Walk through all buckets and all entries in each bucket,\n-  \/\/ freeing each entry.\n-  for (int i = 0; i < table_size(); ++i) {\n-    for (ModuleEntry* m = bucket(i); m != NULL;) {\n-      ModuleEntry* to_remove = m;\n-      \/\/ read next before freeing.\n-      m = m->next();\n-\n-      ResourceMark rm;\n-      if (to_remove->name() != NULL) {\n-        log_info(module, unload)(\"unloading module %s\", to_remove->name()->as_C_string());\n-      }\n-      log_debug(module)(\"ModuleEntryTable: deleting module: %s\", to_remove->name() != NULL ?\n-                        to_remove->name()->as_C_string() : UNNAMED_MODULE);\n-\n-      \/\/ Clean out the C heap allocated reads list first before freeing the entry\n-      to_remove->delete_reads();\n-      if (to_remove->name() != NULL) {\n-        to_remove->name()->decrement_refcount();\n+  class ModuleEntryTableDeleter : public StackObj {\n+   public:\n+    bool do_entry(const Symbol*& name, ModuleEntry*& entry) {\n+      if (log_is_enabled(Info, module, unload) || log_is_enabled(Debug, module)) {\n+        ResourceMark rm;\n+        const char* str = name->as_C_string();\n+        log_info(module, unload)(\"unloading module %s\", str);\n+        log_debug(module)(\"ModuleEntryTable: deleting module: %s\", str);\n@@ -354,7 +366,2 @@\n-      if (to_remove->version() != NULL) {\n-        to_remove->version()->decrement_refcount();\n-      }\n-      if (to_remove->location() != NULL) {\n-        to_remove->location()->decrement_refcount();\n-      }\n-      BasicHashtable<mtModule>::free_entry(to_remove);\n+      delete entry;\n+      return true;\n@@ -362,2 +369,6 @@\n-  }\n-  assert(number_of_entries() == 0, \"should have removed all entries\");\n+  };\n+\n+  ModuleEntryTableDeleter deleter;\n+  _table.unlink(&deleter);\n+  assert(_table.number_of_entries() == 0, \"should have removed all entries\");\n+\n@@ -432,1 +443,1 @@\n-  closure->push(literal_addr()); \/\/ name\n+  closure->push(&_name);\n@@ -440,2 +451,0 @@\n-  set_next(NULL);\n-  set_hash(0x0);        \/\/ re-init at runtime\n@@ -444,3 +453,3 @@\n-  if (literal() != NULL) {\n-    set_literal(ArchiveBuilder::get_relocated_symbol(literal()));\n-    ArchivePtrMarker::mark_pointer((address*)literal_addr());\n+  if (name() != NULL) {\n+    _name = ArchiveBuilder::get_relocated_symbol(_name);\n+    ArchivePtrMarker::mark_pointer((address*)&_name);\n@@ -506,2 +515,1 @@\n-  for (int i = 0; i < table_size(); ++i) {\n-    for (ModuleEntry* m = bucket(i); m != NULL; m = m->next()) {\n+  auto syms = [&] (const Symbol*& key, ModuleEntry*& m) {\n@@ -509,2 +517,2 @@\n-    }\n-  }\n+  };\n+  _table.iterate_all(syms);\n@@ -514,1 +522,1 @@\n-  Array<ModuleEntry*>* archived_modules = ArchiveBuilder::new_rw_array<ModuleEntry*>(number_of_entries());\n+  Array<ModuleEntry*>* archived_modules = ArchiveBuilder::new_rw_array<ModuleEntry*>(_table.number_of_entries());\n@@ -516,5 +524,5 @@\n-  for (int i = 0; i < table_size(); ++i) {\n-    for (ModuleEntry* m = bucket(i); m != NULL; m = m->next()) {\n-      archived_modules->at_put(n++, m);\n-    }\n-  }\n+  auto grab = [&] (const Symbol*& key, ModuleEntry*& m) {\n+    archived_modules->at_put(n++, m);\n+  };\n+  _table.iterate_all(grab);\n+\n@@ -555,4 +563,1 @@\n-\n-    unsigned int hash = compute_hash(archived_entry->name());\n-    archived_entry->set_hash(hash);\n-    add_entry(hash_to_index(hash), archived_entry);\n+    _table.put(archived_entry->name(), archived_entry);\n@@ -571,44 +576,0 @@\n-ModuleEntry* ModuleEntryTable::new_entry(unsigned int hash, Handle module_handle,\n-                                         bool is_open, Symbol* name,\n-                                         Symbol* version, Symbol* location,\n-                                         ClassLoaderData* loader_data) {\n-  assert(Module_lock->owned_by_self(), \"should have the Module_lock\");\n-  ModuleEntry* entry = (ModuleEntry*)Hashtable<Symbol*, mtModule>::new_entry(hash, name);\n-\n-  \/\/ Initialize fields specific to a ModuleEntry\n-  entry->init();\n-  if (name != NULL) {\n-    name->increment_refcount();\n-  } else {\n-    \/\/ Unnamed modules can read all other unnamed modules.\n-    entry->set_can_read_all_unnamed();\n-  }\n-\n-  if (!module_handle.is_null()) {\n-    entry->set_module(loader_data->add_handle(module_handle));\n-  }\n-\n-  entry->set_loader_data(loader_data);\n-  entry->set_version(version);\n-  entry->set_location(location);\n-  entry->set_is_open(is_open);\n-\n-  if (ClassLoader::is_in_patch_mod_entries(name)) {\n-    entry->set_is_patched();\n-    if (log_is_enabled(Trace, module, patch)) {\n-      ResourceMark rm;\n-      log_trace(module, patch)(\"Marked module %s as patched from --patch-module\",\n-                               name != NULL ? name->as_C_string() : UNNAMED_MODULE);\n-    }\n-  }\n-\n-  JFR_ONLY(INIT_ID(entry);)\n-\n-  return entry;\n-}\n-\n-void ModuleEntryTable::add_entry(int index, ModuleEntry* new_entry) {\n-  assert(Module_lock->owned_by_self(), \"should have the Module_lock\");\n-  Hashtable<Symbol*, mtModule>::add_entry(index, (HashtableEntry<Symbol*, mtModule>*)new_entry);\n-}\n-\n@@ -627,3 +588,4 @@\n-  ModuleEntry* entry = new_entry(compute_hash(module_name), module_handle, is_open, module_name,\n-                                 module_version, module_location, loader_data);\n-  add_entry(index_for(module_name), entry);\n+  ModuleEntry* entry = new ModuleEntry(module_handle, is_open, module_name,\n+                                       module_version, module_location, loader_data);\n+  bool created = _table.put(module_name, entry);\n+  assert(created, \"should be\");\n@@ -635,0 +597,1 @@\n+  assert_locked_or_safepoint(Module_lock);\n@@ -636,7 +599,2 @@\n-  int index = index_for(name);\n-  for (ModuleEntry* m = bucket(index); m != NULL; m = m->next()) {\n-    if (m->name()->fast_compare(name) == 0) {\n-      return m;\n-    }\n-  }\n-  return NULL;\n+  ModuleEntry** entry = _table.get(name);\n+  return (entry == nullptr) ? nullptr : *entry;\n@@ -649,7 +607,4 @@\n-  for (int i = 0; i < table_size(); i++) {\n-    for (ModuleEntry* entry = bucket(i);\n-                      entry != NULL;\n-                      entry = entry->next()) {\n-      entry->purge_reads();\n-    }\n-  }\n+  auto purge = [&] (const Symbol*& key, ModuleEntry*& entry) {\n+    entry->purge_reads();\n+  };\n+  _table.iterate_all(purge);\n@@ -718,0 +673,4 @@\n+  ResourceMark rm;\n+  auto printer = [&] (const Symbol*& name, ModuleEntry*& entry) {\n+    entry->print(st);\n+  };\n@@ -719,8 +678,17 @@\n-               table_size(), number_of_entries());\n-  for (int i = 0; i < table_size(); i++) {\n-    for (ModuleEntry* probe = bucket(i);\n-                              probe != NULL;\n-                              probe = probe->next()) {\n-      probe->print(st);\n-    }\n-  }\n+               _table.table_size(), _table.number_of_entries());\n+  assert_locked_or_safepoint(Module_lock);\n+  _table.iterate_all(printer);\n+}\n+\n+void ModuleEntryTable::modules_do(void f(ModuleEntry*)) {\n+  auto do_f = [&] (const Symbol*& key, ModuleEntry*& entry) {\n+    f(entry);\n+  };\n+  _table.iterate_all(do_f);\n+}\n+\n+void ModuleEntryTable::modules_do(ModuleClosure* closure) {\n+  auto do_f = [&] (const Symbol*& key, ModuleEntry*& entry) {\n+    closure->do_module(entry);\n+  };\n+  _table.iterate_all(do_f);\n@@ -730,2 +698,1 @@\n-  ResourceMark rm;\n-  st->print_cr(\"entry \" PTR_FORMAT \" name %s module \" PTR_FORMAT \" loader %s version %s location %s strict %s next \" PTR_FORMAT,\n+  st->print_cr(\"entry \" PTR_FORMAT \" name %s module \" PTR_FORMAT \" loader %s version %s location %s strict %s\",\n@@ -738,1 +705,1 @@\n-               BOOL_TO_STR(!can_read_all_unnamed()), p2i(next()));\n+               BOOL_TO_STR(!can_read_all_unnamed()));\n@@ -742,1 +709,5 @@\n-  verify_table<ModuleEntry>(\"Module Entry Table\");\n+  auto do_f = [&] (const Symbol*& key, ModuleEntry*& entry) {\n+    entry->verify();\n+  };\n+  assert_locked_or_safepoint(Module_lock);\n+  _table.iterate_all(do_f);\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.cpp","additions":135,"deletions":164,"binary":false,"changes":299,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"utilities\/hashtable.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"utilities\/resourceHash.hpp\"\n@@ -62,2 +62,2 @@\n-\/\/ data structure.\n-class ModuleEntry : public HashtableEntry<Symbol*, mtModule> {\n+\/\/ data structure.  This lock must be taken on all accesses to either table.\n+class ModuleEntry : public CHeapObj<mtModule> {\n@@ -68,0 +68,1 @@\n+  Symbol*          _name;              \/\/ name of this module\n@@ -84,14 +85,4 @@\n-  void init() {\n-    _module = OopHandle();\n-    _shared_pd = OopHandle();\n-    _loader_data = NULL;\n-    _reads = NULL;\n-    _version = NULL;\n-    _location = NULL;\n-    _can_read_all_unnamed = false;\n-    _has_default_read_edges = false;\n-    _must_walk_reads = false;\n-    _is_patched = false;\n-    _is_open = false;\n-    CDS_ONLY(_shared_path_index = -1);\n-  }\n+  ModuleEntry(Handle module_handle,\n+              bool is_open, Symbol* name,\n+              Symbol* version, Symbol* location,\n+              ClassLoaderData* loader_data);\n@@ -99,2 +90,1 @@\n-  Symbol*          name() const                        { return literal(); }\n-  void             set_name(Symbol* n)                 { set_literal(n); }\n+  ~ModuleEntry();\n@@ -102,0 +92,1 @@\n+  Symbol*          name() const                        { return _name; }\n@@ -132,1 +123,1 @@\n-  bool             is_named() const                    { return (name() != NULL); }\n+  bool             is_named() const                    { return (_name != NULL); }\n@@ -163,7 +154,0 @@\n-  ModuleEntry* next() const {\n-    return (ModuleEntry*)HashtableEntry<Symbol*, mtModule>::next();\n-  }\n-  ModuleEntry** next_addr() {\n-    return (ModuleEntry**)HashtableEntry<Symbol*, mtModule>::next_addr();\n-  }\n-\n@@ -181,1 +165,0 @@\n-  void delete_unnamed_module();\n@@ -222,9 +205,1 @@\n-\/\/ The ModuleEntryTable's lookup is lock free.\n-\/\/\n-class ModuleEntryTable : public Hashtable<Symbol*, mtModule> {\n-  friend class VMStructs;\n-public:\n-  enum Constants {\n-    _moduletable_entry_size  = 109 \/\/ number of entries in module entry table\n-  };\n-\n+class ModuleEntryTable : public CHeapObj<mtModule> {\n@@ -233,13 +208,2 @@\n-\n-  ModuleEntry* new_entry(unsigned int hash, Handle module_handle, bool is_open,\n-                         Symbol* name, Symbol* version, Symbol* location, ClassLoaderData* loader_data);\n-  void add_entry(int index, ModuleEntry* new_entry);\n-\n-  int entry_size() const { return BasicHashtable<mtModule>::entry_size(); }\n-\n-  ModuleEntry** bucket_addr(int i) {\n-    return (ModuleEntry**)Hashtable<Symbol*, mtModule>::bucket_addr(i);\n-  }\n-\n-  static unsigned int compute_hash(Symbol* name) { return ((name == NULL) ? 0 : (unsigned int)(name->identity_hash())); }\n-  int index_for(Symbol* name) const              { return hash_to_index(compute_hash(name)); }\n+  ResourceHashtable<const Symbol*, ModuleEntry*, 109, ResourceObj::C_HEAP, mtModule,\n+                    Symbol::compute_hash> _table;\n@@ -248,1 +212,1 @@\n-  ModuleEntryTable(int table_size);\n+  ModuleEntryTable();\n@@ -251,4 +215,0 @@\n-  ModuleEntry* bucket(int i) {\n-    return (ModuleEntry*)Hashtable<Symbol*, mtModule>::bucket(i);\n-  }\n-\n@@ -264,1 +224,1 @@\n-  \/\/ Only lookup module within loader's module entry table.  The table read is lock-free.\n+  \/\/ Only lookup module within loader's module entry table.\n@@ -282,0 +242,3 @@\n+  void modules_do(void f(ModuleEntry*));\n+  void modules_do(ModuleClosure* closure);\n+\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.hpp","additions":19,"deletions":56,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -217,2 +217,2 @@\n-        package_table->locked_create_entry_if_not_exist(pkg_list->at(x),\n-                                                        ModuleEntryTable::javabase_moduleEntry());\n+        package_table->locked_create_entry_if_absent(pkg_list->at(x),\n+                                                     ModuleEntryTable::javabase_moduleEntry());\n","filename":"src\/hotspot\/share\/classfile\/modules.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n-#include \"utilities\/hashtable.inline.hpp\"\n@@ -45,0 +44,20 @@\n+PackageEntry::PackageEntry(Symbol* name, ModuleEntry* module) :\n+  _name(name),\n+  _module(module),\n+  _export_flags(0),\n+  _classpath_index(-1),\n+  _must_walk_exports(false),\n+  _qualified_exports(NULL),\n+  _defined_by_cds_in_class_path(0)\n+{\n+  \/\/ name can't be null\n+  _name->increment_refcount();\n+\n+  JFR_ONLY(INIT_ID(this);)\n+}\n+\n+PackageEntry::~PackageEntry() {\n+  delete_qualified_exports();\n+  _name->decrement_refcount();\n+}\n+\n@@ -172,4 +191,1 @@\n-PackageEntryTable::PackageEntryTable(int table_size)\n-  : Hashtable<Symbol*, mtModule>(table_size, sizeof(PackageEntry))\n-{\n-}\n+PackageEntryTable::PackageEntryTable() { }\n@@ -178,13 +194,11 @@\n-  \/\/ Walk through all buckets and all entries in each bucket,\n-  \/\/ freeing each entry.\n-  for (int i = 0; i < table_size(); ++i) {\n-    for (PackageEntry* p = bucket(i); p != NULL;) {\n-      PackageEntry* to_remove = p;\n-      \/\/ read next before freeing.\n-      p = p->next();\n-\n-      \/\/ Clean out the C heap allocated qualified exports list first before freeing the entry\n-      to_remove->delete_qualified_exports();\n-      to_remove->name()->decrement_refcount();\n-\n-      BasicHashtable<mtModule>::free_entry(to_remove);\n+  class PackageEntryTableDeleter : public StackObj {\n+   public:\n+    bool do_entry(const Symbol*& name, PackageEntry*& entry) {\n+      if (log_is_enabled(Info, module, unload) || log_is_enabled(Debug, module)) {\n+        ResourceMark rm;\n+        const char* str = name->as_C_string();\n+        log_info(module, unload)(\"unloading package %s\", str);\n+        log_debug(module)(\"PackageEntry: deleting package: %s\", str);\n+      }\n+      delete entry;\n+      return true;\n@@ -192,2 +206,5 @@\n-  }\n-  assert(number_of_entries() == 0, \"should have removed all entries\");\n+  };\n+\n+  PackageEntryTableDeleter deleter;\n+  _table.unlink(&deleter);\n+  assert(_table.number_of_entries() == 0, \"should have removed all entries\");\n@@ -228,1 +245,1 @@\n-  closure->push(literal_addr()); \/\/ name\n+  closure->push(&_name);\n@@ -234,3 +251,1 @@\n-  set_next(NULL);\n-  set_literal(ArchiveBuilder::get_relocated_symbol(literal()));\n-  set_hash(0x0);  \/\/ re-init at runtime\n+  _name = ArchiveBuilder::get_relocated_symbol(_name);\n@@ -242,1 +257,1 @@\n-  ArchivePtrMarker::mark_pointer((address*)literal_addr());\n+  ArchivePtrMarker::mark_pointer((address*)&_name);\n@@ -258,2 +273,1 @@\n-  for (int i = 0; i < table_size(); ++i) {\n-    for (PackageEntry* p = bucket(i); p != NULL; p = p->next()) {\n+  auto syms = [&] (const Symbol*& key, PackageEntry*& p) {\n@@ -261,2 +275,2 @@\n-    }\n-  }\n+  };\n+  _table.iterate_all(syms);\n@@ -267,6 +281,4 @@\n-  int n, i;\n-  for (n = 0, i = 0; i < table_size(); ++i) {\n-    for (PackageEntry* p = bucket(i); p != NULL; p = p->next()) {\n-      if (p->module()->name() != NULL) {\n-        n++;\n-      }\n+  int n = 0;\n+  auto count = [&] (const Symbol*& key, PackageEntry*& p) {\n+    if (p->module()->is_named()) {\n+      n++;\n@@ -274,1 +286,2 @@\n-  }\n+  };\n+  _table.iterate_all(count);\n@@ -277,7 +290,7 @@\n-  for (n = 0, i = 0; i < table_size(); ++i) {\n-    for (PackageEntry* p = bucket(i); p != NULL; p = p->next()) {\n-      if (p->module()->name() != NULL) {\n-        \/\/ We don't archive unnamed modules, or packages in unnamed modules. They will be\n-        \/\/ created on-demand at runtime as classes in such packages are loaded.\n-        archived_packages->at_put(n++, p);\n-      }\n+  \/\/ reset n\n+  n = 0;\n+  auto grab = [&] (const Symbol*& key, PackageEntry*& p) {\n+    if (p->module()->is_named()) {\n+      \/\/ We don't archive unnamed modules, or packages in unnamed modules. They will be\n+      \/\/ created on-demand at runtime as classes in such packages are loaded.\n+      archived_packages->at_put(n++, p);\n@@ -285,1 +298,3 @@\n-  }\n+  };\n+  _table.iterate_all(grab);\n+\n@@ -289,1 +304,1 @@\n-  for (i = 0; i < n; i++) {\n+  for (int i = 0; i < n; i++) {\n@@ -309,4 +324,1 @@\n-\n-    unsigned int hash = compute_hash(archived_entry->name());\n-    archived_entry->set_hash(hash);\n-    add_entry(hash_to_index(hash), archived_entry);\n+    _table.put(archived_entry->name(), archived_entry);\n@@ -318,18 +330,0 @@\n-PackageEntry* PackageEntryTable::new_entry(unsigned int hash, Symbol* name, ModuleEntry* module) {\n-  assert(Module_lock->owned_by_self(), \"should have the Module_lock\");\n-  PackageEntry* entry = (PackageEntry*)Hashtable<Symbol*, mtModule>::new_entry(hash, name);\n-\n-  JFR_ONLY(INIT_ID(entry);)\n-\n-  \/\/ Initialize fields specific to a PackageEntry\n-  entry->init();\n-  entry->name()->increment_refcount();\n-  entry->set_module(module);\n-  return entry;\n-}\n-\n-void PackageEntryTable::add_entry(int index, PackageEntry* new_entry) {\n-  assert(Module_lock->owned_by_self(), \"should have the Module_lock\");\n-  Hashtable<Symbol*, mtModule>::add_entry(index, (HashtableEntry<Symbol*, mtModule>*)new_entry);\n-}\n-\n@@ -341,2 +335,3 @@\n-  PackageEntry* entry = new_entry(compute_hash(name), name, module);\n-  add_entry(index_for(name), entry);\n+  PackageEntry* entry = new PackageEntry(name, module);\n+  bool created = _table.put(name, entry);\n+  assert(created, \"must be\");\n@@ -347,1 +342,1 @@\n-void PackageEntryTable::locked_create_entry_if_not_exist(Symbol* name, ModuleEntry* module) {\n+PackageEntry* PackageEntryTable::locked_create_entry_if_absent(Symbol* name, ModuleEntry* module) {\n@@ -350,2 +345,8 @@\n-  if (locked_lookup_only(name) == NULL) {\n-    locked_create_entry(name, module);\n+  bool created;\n+  PackageEntry* entry = new PackageEntry(name, module);\n+  PackageEntry** old_entry = _table.put_if_absent(name, entry, &created);\n+  if (created) {\n+    return entry;\n+  } else {\n+    delete entry;\n+    return *old_entry;\n@@ -355,1 +356,1 @@\n-PackageEntry* PackageEntryTable::lookup(Symbol* name, ModuleEntry* module) {\n+PackageEntry* PackageEntryTable::create_entry_if_absent(Symbol* name, ModuleEntry* module) {\n@@ -357,9 +358,1 @@\n-  PackageEntry* p = locked_lookup_only(name);\n-  if (p != NULL) {\n-    return p;\n-  } else {\n-    assert(module != NULL, \"module should never be null\");\n-    PackageEntry* entry = new_entry(compute_hash(name), name, module);\n-    add_entry(index_for(name), entry);\n-    return entry;\n-  }\n+  return locked_create_entry_if_absent(name, module);\n@@ -376,7 +369,2 @@\n-  int index = index_for(name);\n-  for (PackageEntry* p = bucket(index); p != NULL; p = p->next()) {\n-    if (p->name()->fast_compare(name) == 0) {\n-      return p;\n-    }\n-  }\n-  return NULL;\n+  PackageEntry** entry = _table.get(name);\n+  return entry == nullptr ? nullptr : *entry;\n@@ -389,12 +377,9 @@\n-  for (int i = 0; i < table_size(); i++) {\n-    for (PackageEntry* entry = bucket(i);\n-                       entry != NULL;\n-                       entry = entry->next()) {\n-      ModuleEntry* m = entry->module();\n-      Symbol* module_name = (m == NULL ? NULL : m->name());\n-      if (module_name != NULL &&\n-          (module_name->fast_compare(vmSymbols::java_base()) == 0) &&\n-          !pkg_list->contains(entry->name())) {\n-        ResourceMark rm;\n-        vm_exit_during_initialization(\"A non-\" JAVA_BASE_NAME \" package was loaded prior to module system initialization\", entry->name()->as_C_string());\n-      }\n+  auto verifier = [&] (const Symbol*& name, PackageEntry*& entry) {\n+    ModuleEntry* m = entry->module();\n+    Symbol* module_name = (m == NULL ? NULL : m->name());\n+    if (module_name != NULL &&\n+      (module_name->fast_compare(vmSymbols::java_base()) == 0) &&\n+        !pkg_list->contains(entry->name())) {\n+      ResourceMark rm;\n+      vm_exit_during_initialization(\"A non-\" JAVA_BASE_NAME \" package was loaded prior to module system initialization\",\n+                                    entry->name()->as_C_string());\n@@ -402,1 +387,2 @@\n-  }\n+  };\n+  _table.iterate_all(verifier);\n@@ -427,11 +413,7 @@\n-  for (int i = 0; i < table_size(); i++) {\n-    for (PackageEntry* entry = bucket(i);\n-                       entry != NULL;\n-                       entry = entry->next()) {\n-      if (entry->exported_pending_delete()) {\n-        \/\/ exported list is pending deletion due to a transition\n-        \/\/ from qualified to unqualified\n-        entry->delete_qualified_exports();\n-      } else if (entry->is_qual_exported()) {\n-        entry->purge_qualified_exports();\n-      }\n+  auto purge = [&] (const Symbol*& name, PackageEntry*& entry) {\n+    if (entry->exported_pending_delete()) {\n+      \/\/ exported list is pending deletion due to a transition\n+      \/\/ from qualified to unqualified\n+      entry->delete_qualified_exports();\n+    } else if (entry->is_qual_exported()) {\n+      entry->purge_qualified_exports();\n@@ -439,1 +421,25 @@\n-  }\n+  };\n+  _table.iterate_all(purge);\n+}\n+\n+void PackageEntryTable::packages_do(void f(PackageEntry*)) {\n+  auto doit = [&] (const Symbol*&name, PackageEntry*& entry) {\n+    f(entry);\n+  };\n+  assert_locked_or_safepoint(Module_lock);\n+  _table.iterate_all(doit);\n+}\n+\n+\n+GrowableArray<PackageEntry*>*  PackageEntryTable::get_system_packages() {\n+  GrowableArray<PackageEntry*>* loaded_class_pkgs = new GrowableArray<PackageEntry*>(50);\n+  auto grab = [&] (const Symbol*&name, PackageEntry*& entry) {\n+    if (entry->has_loaded_class()) {\n+      loaded_class_pkgs->append(entry);\n+    }\n+  };\n+\n+  MutexLocker ml(Module_lock);\n+  _table.iterate_all(grab);\n+  \/\/ Returns a resource allocated object so caller must have ResourceMark\n+  return loaded_class_pkgs;\n@@ -443,0 +449,3 @@\n+  auto printer = [&] (const Symbol*& name, PackageEntry*& entry) {\n+    entry->print(st);\n+  };\n@@ -444,8 +453,2 @@\n-               table_size(), number_of_entries());\n-  for (int i = 0; i < table_size(); i++) {\n-    for (PackageEntry* probe = bucket(i);\n-                       probe != NULL;\n-                       probe = probe->next()) {\n-      probe->print(st);\n-    }\n-  }\n+               _table.table_size(), _table.number_of_entries());\n+  _table.iterate_all(printer);\n@@ -460,1 +463,1 @@\n-               INT32_FORMAT \" is_exported_unqualified %d is_exported_allUnnamed %d \" \"next \" PTR_FORMAT,\n+               INT32_FORMAT \" is_exported_unqualified %d is_exported_allUnnamed %d \",\n@@ -464,9 +467,1 @@\n-               _export_flags == PKG_EXP_ALLUNNAMED, p2i(next()));\n-}\n-\n-void PackageEntryTable::verify() {\n-  verify_table<PackageEntry>(\"Package Entry Table\");\n-}\n-\n-void PackageEntry::verify() {\n-  guarantee(name() != NULL, \"A package entry must have a corresponding symbol name.\");\n+               _export_flags == PKG_EXP_ALLUNNAMED);\n","filename":"src\/hotspot\/share\/classfile\/packageEntry.cpp","additions":128,"deletions":133,"binary":false,"changes":261,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-#include \"utilities\/hashtable.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n@@ -41,0 +41,1 @@\n+class ModuleEntry;\n@@ -100,1 +101,1 @@\n-class PackageEntry : public HashtableEntry<Symbol*, mtModule> {\n+class PackageEntry : public CHeapObj<mtModule> {\n@@ -102,0 +103,1 @@\n+  Symbol*      _name;\n@@ -123,8 +125,2 @@\n-  void init() {\n-    _module = NULL;\n-    _export_flags = 0;\n-    _classpath_index = -1;\n-    _must_walk_exports = false;\n-    _qualified_exports = NULL;\n-    _defined_by_cds_in_class_path = 0;\n-  }\n+  PackageEntry(Symbol* name, ModuleEntry* module);\n+  ~PackageEntry();\n@@ -133,1 +129,1 @@\n-  Symbol*            name() const               { return literal(); }\n+  Symbol*            name() const               { return _name; }\n@@ -202,8 +198,0 @@\n-  PackageEntry* next() const {\n-    return (PackageEntry*)HashtableEntry<Symbol*, mtModule>::next();\n-  }\n-\n-  PackageEntry** next_addr() {\n-    return (PackageEntry**)HashtableEntry<Symbol*, mtModule>::next_addr();\n-  }\n-\n@@ -220,1 +208,0 @@\n-  void verify();\n@@ -251,22 +238,3 @@\n-\/\/ The PackageEntryTable's lookup is lock free.\n-\/\/\n-class PackageEntryTable : public Hashtable<Symbol*, mtModule> {\n-  friend class VMStructs;\n-public:\n-  enum Constants {\n-    _packagetable_entry_size = 109  \/\/ number of entries in package entry table\n-  };\n-\n-private:\n-  PackageEntry* new_entry(unsigned int hash, Symbol* name, ModuleEntry* module);\n-  void add_entry(int index, PackageEntry* new_entry);\n-\n-  int entry_size() const { return BasicHashtable<mtModule>::entry_size(); }\n-\n-  PackageEntry** bucket_addr(int i) {\n-    return (PackageEntry**)Hashtable<Symbol*, mtModule>::bucket_addr(i);\n-  }\n-\n-  static unsigned int compute_hash(Symbol* name) { return (unsigned int)(name->identity_hash()); }\n-  int index_for(Symbol* name) const { return hash_to_index(compute_hash(name)); }\n-\n+class PackageEntryTable : public CHeapObj<mtModule> {\n+  ResourceHashtable<const Symbol*, PackageEntry*, 109, ResourceObj::C_HEAP, mtModule,\n+                    Symbol::compute_hash> _table;\n@@ -274,1 +242,1 @@\n-  PackageEntryTable(int table_size);\n+  PackageEntryTable();\n@@ -277,4 +245,0 @@\n-  PackageEntry* bucket(int i) {\n-    return (PackageEntry*)Hashtable<Symbol*, mtModule>::bucket(i);\n-  }\n-\n@@ -287,1 +251,1 @@\n-  void locked_create_entry_if_not_exist(Symbol* name, ModuleEntry* module);\n+  PackageEntry* locked_create_entry_if_absent(Symbol* name, ModuleEntry* module);\n@@ -291,1 +255,1 @@\n-  PackageEntry* lookup(Symbol* name, ModuleEntry* module);\n+  PackageEntry* create_entry_if_absent(Symbol* name, ModuleEntry* module);\n@@ -306,0 +270,4 @@\n+  GrowableArray<PackageEntry*>* get_system_packages();\n+\n+  void packages_do(void f(PackageEntry*));\n+\n@@ -307,1 +275,0 @@\n-  void verify();\n","filename":"src\/hotspot\/share\/classfile\/packageEntry.hpp","additions":18,"deletions":51,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,20 @@\n-#include \"utilities\/hashtable.inline.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n+\n+class PlaceholderKey {\n+  Symbol* _name;\n+  ClassLoaderData* _loader_data;\n+ public:\n+  PlaceholderKey(Symbol* name, ClassLoaderData* l) : _name(name), _loader_data(l) {}\n+\n+  static bool equals(PlaceholderKey const& k1, PlaceholderKey const& k2) {\n+    return (k1._name == k2._name && k1._loader_data == k2._loader_data);\n+  }\n+  static unsigned hash(PlaceholderKey const& k) {\n+    return (unsigned) k._name->identity_hash() ^ (int)((intptr_t)k._loader_data >> 3);\n+  }\n+  void print_on(outputStream* st) const;\n+};\n+\n+const int _placeholder_table_size = 503;   \/\/ Does this really have to be prime?\n+ResourceHashtable<PlaceholderKey, PlaceholderEntry, _placeholder_table_size, ResourceObj::C_HEAP, mtClass,\n+                  PlaceholderKey::hash, PlaceholderKey::equals> _placeholders;\n@@ -176,24 +195,0 @@\n-PlaceholderEntry* PlaceholderTable::new_entry(int hash, Symbol* name,\n-                                              ClassLoaderData* loader_data,\n-                                              Symbol* supername) {\n-  PlaceholderEntry* entry = (PlaceholderEntry*)Hashtable<Symbol*, mtClass>::new_entry(hash, name);\n-  \/\/ Hashtable with Symbol* literal must increment and decrement refcount.\n-  name->increment_refcount();\n-  entry->set_loader_data(loader_data);\n-  entry->set_supername(supername);\n-  entry->set_superThreadQ(NULL);\n-  entry->set_loadInstanceThreadQ(NULL);\n-  entry->set_defineThreadQ(NULL);\n-  entry->set_definer(NULL);\n-  entry->set_instance_klass(NULL);\n-  return entry;\n-}\n-\n-void PlaceholderTable::free_entry(PlaceholderEntry* entry) {\n-  \/\/ decrement Symbol refcount here because Hashtable doesn't.\n-  entry->literal()->decrement_refcount();\n-  if (entry->supername() != NULL) entry->supername()->decrement_refcount();\n-  BasicHashtable<mtClass>::free_entry(entry);\n-}\n-\n-\n@@ -204,3 +199,2 @@\n-PlaceholderEntry* PlaceholderTable::add_entry(unsigned int hash,\n-                                              Symbol* class_name, ClassLoaderData* loader_data,\n-                                              Symbol* supername){\n+PlaceholderEntry* add_entry(Symbol* class_name, ClassLoaderData* loader_data,\n+                            Symbol* supername){\n@@ -210,6 +204,9 @@\n-  \/\/ Both readers and writers are locked so it's safe to just\n-  \/\/ create the placeholder and insert it in the list without a membar.\n-  PlaceholderEntry* entry = new_entry(hash, class_name, loader_data, supername);\n-  int index = hash_to_index(hash);\n-  Hashtable<Symbol*, mtClass>::add_entry(index, entry);\n-  return entry;\n+  PlaceholderEntry entry;\n+  entry.set_supername(supername);\n+  PlaceholderKey key(class_name, loader_data);\n+  \/\/ Since we're storing this key in the hashtable, we need to increment the refcount.\n+  class_name->increment_refcount();\n+  bool created;\n+  PlaceholderEntry* table_copy = _placeholders.put_if_absent(key, entry, &created);\n+  assert(created, \"better be absent\");\n+  return table_copy;\n@@ -218,1 +215,0 @@\n-\n@@ -220,21 +216,1 @@\n-void PlaceholderTable::remove_entry(unsigned int hash,\n-                                    Symbol* class_name,\n-                                    ClassLoaderData* loader_data) {\n-  assert_locked_or_safepoint(SystemDictionary_lock);\n-  int index = hash_to_index(hash);\n-  PlaceholderEntry** p = bucket_addr(index);\n-  while (*p != NULL) {\n-    PlaceholderEntry *probe = *p;\n-    if (probe->hash() == hash && probe->equals(class_name, loader_data)) {\n-      \/\/ Delete entry\n-      *p = probe->next();\n-      free_entry(probe);\n-      return;\n-    }\n-    p = probe->next_addr();\n-  }\n-}\n-\n-PlaceholderEntry* PlaceholderTable::get_entry(unsigned int hash,\n-                                              Symbol* class_name,\n-                                              ClassLoaderData* loader_data) {\n+void remove_entry(Symbol* class_name, ClassLoaderData* loader_data) {\n@@ -243,10 +219,4 @@\n-  int index = hash_to_index(hash);\n-  for (PlaceholderEntry *place_probe = bucket(index);\n-                         place_probe != NULL;\n-                         place_probe = place_probe->next()) {\n-    if (place_probe->hash() == hash &&\n-        place_probe->equals(class_name, loader_data)) {\n-      return place_probe;\n-    }\n-  }\n-  return NULL;\n+  PlaceholderKey key(class_name, loader_data);\n+  _placeholders.remove(key);\n+  \/\/ Decrement the refcount in key, since it's no longer in the table.\n+  class_name->decrement_refcount();\n@@ -255,5 +225,5 @@\n-Symbol* PlaceholderTable::find_entry(unsigned int hash,\n-                                     Symbol* class_name,\n-                                     ClassLoaderData* loader_data) {\n-  PlaceholderEntry* probe = get_entry(hash, class_name, loader_data);\n-  return (probe != NULL ? probe->klassname() : NULL);\n+\n+PlaceholderEntry* PlaceholderTable::get_entry(Symbol* class_name, ClassLoaderData* loader_data) {\n+  assert_locked_or_safepoint(SystemDictionary_lock);\n+  PlaceholderKey key(class_name, loader_data);\n+  return _placeholders.get(key);\n@@ -277,1 +247,1 @@\n-    entry->print_entry(&ls);\n+    entry->print_on(&ls);\n@@ -286,2 +256,1 @@\n-PlaceholderEntry* PlaceholderTable::find_and_add(unsigned int hash,\n-                                                 Symbol* name,\n+PlaceholderEntry* PlaceholderTable::find_and_add(Symbol* name,\n@@ -293,1 +262,1 @@\n-  PlaceholderEntry* probe = get_entry(hash, name, loader_data);\n+  PlaceholderEntry* probe = get_entry(name, loader_data);\n@@ -296,1 +265,1 @@\n-    probe = add_entry(hash, name, loader_data, supername);\n+    probe = add_entry(name, loader_data, supername);\n@@ -321,2 +290,1 @@\n-void PlaceholderTable::find_and_remove(unsigned int hash,\n-                                       Symbol* name, ClassLoaderData* loader_data,\n+void PlaceholderTable::find_and_remove(Symbol* name, ClassLoaderData* loader_data,\n@@ -325,10 +293,10 @@\n-    assert_locked_or_safepoint(SystemDictionary_lock);\n-    PlaceholderEntry *probe = get_entry(hash, name, loader_data);\n-    if (probe != NULL) {\n-       log(probe, \"find_and_remove\", action);\n-       probe->remove_seen_thread(thread, action);\n-       \/\/ If no other threads using this entry, and this thread is not using this entry for other states\n-       if ((probe->superThreadQ() == NULL) && (probe->loadInstanceThreadQ() == NULL)\n-          && (probe->defineThreadQ() == NULL) && (probe->definer() == NULL)) {\n-         remove_entry(hash, name, loader_data);\n-       }\n+  assert_locked_or_safepoint(SystemDictionary_lock);\n+  PlaceholderEntry* probe = get_entry(name, loader_data);\n+  if (probe != NULL) {\n+    log(probe, \"find_and_remove\", action);\n+    probe->remove_seen_thread(thread, action);\n+    \/\/ If no other threads using this entry, and this thread is not using this entry for other states\n+    if ((probe->superThreadQ() == NULL) && (probe->loadInstanceThreadQ() == NULL)\n+        && (probe->defineThreadQ() == NULL) && (probe->definer() == NULL)) {\n+      probe->clear_supername();\n+      remove_entry(name, loader_data);\n@@ -337,3 +305,0 @@\n-\n-PlaceholderTable::PlaceholderTable(int table_size)\n-    : Hashtable<Symbol*, mtClass>(table_size, sizeof(PlaceholderEntry)) {\n@@ -342,7 +307,4 @@\n-void PlaceholderEntry::verify() const {\n-  guarantee(loader_data() != NULL, \"Must have been setup.\");\n-  guarantee(loader_data()->class_loader() == NULL || loader_data()->class_loader()->is_instance(),\n-            \"checking type of _loader\");\n-  guarantee(instance_klass() == NULL\n-            || instance_klass()->is_instance_klass(),\n-            \"checking type of instance_klass result\");\n+void PlaceholderKey::print_on(outputStream* st) const {\n+  _name->print_value_on(st);\n+  st->print(\", loader \");\n+  _loader_data->print_value_on(st);\n@@ -351,14 +313,1 @@\n-void PlaceholderTable::verify() {\n-  verify_table<PlaceholderEntry>(\"Placeholder Table\");\n-}\n-\n-\n-\/\/ Note, doesn't append a cr\n-\/\/ Can't call this print_on because HashtableEntry doesn't initialize its vptr\n-\/\/ and print_on is a virtual function so the vptr call crashes.\n-void PlaceholderEntry::print_entry(outputStream* st) const {\n-  klassname()->print_value_on(st);\n-  if (loader_data() != NULL) {\n-    st->print(\", loader \");\n-    loader_data()->print_value_on(st);\n-  }\n+void PlaceholderEntry::print_on(outputStream* st) const {\n@@ -389,1 +338,7 @@\n-void PlaceholderTable::print_on(outputStream* st) const {\n+void PlaceholderTable::print_on(outputStream* st) {\n+  auto printer = [&] (PlaceholderKey& key, PlaceholderEntry& entry) {\n+      st->print(\"placeholder \");\n+      key.print_on(st);\n+      entry.print_on(st);\n+      return true;\n+  };\n@@ -391,9 +346,2 @@\n-                table_size(), number_of_entries());\n-  for (int pindex = 0; pindex < table_size(); pindex++) {\n-    for (PlaceholderEntry* probe = bucket(pindex);\n-                           probe != NULL;\n-                           probe = probe->next()) {\n-      st->print(\"%4d: placeholder \", pindex);\n-      probe->print_entry(st);\n-    }\n-  }\n+                _placeholders.table_size(), _placeholders.number_of_entries());\n+  _placeholders.iterate(printer);\n@@ -402,1 +350,1 @@\n-void PlaceholderTable::print() const { return print_on(tty); }\n+void PlaceholderTable::print() { return print_on(tty); }\n","filename":"src\/hotspot\/share\/classfile\/placeholders.cpp","additions":72,"deletions":124,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-#include \"utilities\/hashtable.hpp\"\n-\n@@ -39,38 +37,13 @@\n-class PlaceholderTable : public Hashtable<Symbol*, mtClass> {\n-\n-public:\n-  PlaceholderTable(int table_size);\n-\n-  PlaceholderEntry* new_entry(int hash, Symbol* name, ClassLoaderData* loader_data, Symbol* supername);\n-  void free_entry(PlaceholderEntry* entry);\n-\n-  PlaceholderEntry* bucket(int i) const {\n-    return (PlaceholderEntry*)Hashtable<Symbol*, mtClass>::bucket(i);\n-  }\n-\n-  PlaceholderEntry** bucket_addr(int i) {\n-    return (PlaceholderEntry**)Hashtable<Symbol*, mtClass>::bucket_addr(i);\n-  }\n-\n-  PlaceholderEntry* add_entry(unsigned int hash, Symbol* name,\n-                              ClassLoaderData* loader_data,\n-                              Symbol* supername);\n-\n-  \/\/ This returns a Symbol* to match type for SystemDictionary\n-  Symbol* find_entry(unsigned int hash,\n-                     Symbol* name, ClassLoaderData* loader_data);\n-\n-  PlaceholderEntry* get_entry(unsigned int hash,\n-                              Symbol* name, ClassLoaderData* loader_data);\n-\n-\/\/ caller to create a placeholder entry must enumerate an action\n-\/\/ caller claims ownership of that action\n-\/\/ For parallel classloading:\n-\/\/ multiple LOAD_INSTANCE threads can proceed in parallel\n-\/\/ multiple LOAD_SUPER threads can proceed in parallel\n-\/\/ LOAD_SUPER needed to check for class circularity\n-\/\/ DEFINE_CLASS: ultimately define class must be single threaded\n-\/\/ on a class\/classloader basis\n-\/\/ so the head of that queue owns the token\n-\/\/ and the rest of the threads return the result the first thread gets\n- enum classloadAction {\n+class PlaceholderTable : public AllStatic {\n+ public:\n+  \/\/ caller to create a placeholder entry must enumerate an action\n+  \/\/ caller claims ownership of that action\n+  \/\/ For parallel classloading:\n+  \/\/ multiple LOAD_INSTANCE threads can proceed in parallel\n+  \/\/ multiple LOAD_SUPER threads can proceed in parallel\n+  \/\/ LOAD_SUPER needed to check for class circularity\n+  \/\/ DEFINE_CLASS: ultimately define class must be single threaded\n+  \/\/ on a class\/classloader basis\n+  \/\/ so the head of that queue owns the token\n+  \/\/ and the rest of the threads return the result the first thread gets\n+  enum classloadAction {\n@@ -80,1 +53,3 @@\n- };\n+  };\n+\n+  static PlaceholderEntry* get_entry(Symbol* name, ClassLoaderData* loader_data);\n@@ -85,7 +60,3 @@\n-  PlaceholderEntry* find_and_add(unsigned int hash,\n-                                 Symbol* name, ClassLoaderData* loader_data,\n-                                 classloadAction action, Symbol* supername,\n-                                 JavaThread* thread);\n-\n-  void remove_entry(unsigned int hash,\n-                    Symbol* name, ClassLoaderData* loader_data);\n+  static PlaceholderEntry* find_and_add(Symbol* name, ClassLoaderData* loader_data,\n+                                        classloadAction action, Symbol* supername,\n+                                        JavaThread* thread);\n@@ -95,2 +66,1 @@\n-  void find_and_remove(unsigned int hash,\n-                       Symbol* name, ClassLoaderData* loader_data,\n+  static void find_and_remove(Symbol* name, ClassLoaderData* loader_data,\n@@ -99,3 +69,2 @@\n-  void print_on(outputStream* st) const;\n-  void print() const;\n-  void verify();\n+  static void print_on(outputStream* st);\n+  static void print();\n@@ -111,3 +80,1 @@\n-\n-class PlaceholderEntry : public HashtableEntry<Symbol*, mtClass> {\n-\n+class PlaceholderEntry {\n@@ -115,1 +82,0 @@\n-\n@@ -117,1 +83,0 @@\n-  ClassLoaderData*  _loader_data;   \/\/ initiating loader\n@@ -137,5 +102,3 @@\n-  \/\/ Simple accessors, used only by SystemDictionary\n-  Symbol*            klassname()           const { return literal(); }\n-\n-  ClassLoaderData*   loader_data()         const { return _loader_data; }\n-  void               set_loader_data(ClassLoaderData* loader_data) { _loader_data = loader_data; }\n+  PlaceholderEntry() :\n+     _supername(nullptr), _definer(nullptr), _instanceKlass(nullptr),\n+     _superThreadQ(nullptr), _loadInstanceThreadQ(nullptr), _defineThreadQ(nullptr) { }\n@@ -145,0 +108,1 @@\n+    Symbol::maybe_decrement_refcount(_supername);\n@@ -146,1 +110,5 @@\n-    if (_supername != NULL) _supername->increment_refcount();\n+    Symbol::maybe_increment_refcount(_supername);\n+  }\n+  void               clear_supername() {\n+    Symbol::maybe_decrement_refcount(_supername);\n+    _supername = nullptr;\n@@ -164,14 +132,0 @@\n-  PlaceholderEntry* next() const {\n-    return (PlaceholderEntry*)HashtableEntry<Symbol*, mtClass>::next();\n-  }\n-\n-  PlaceholderEntry** next_addr() {\n-    return (PlaceholderEntry**)HashtableEntry<Symbol*, mtClass>::next_addr();\n-  }\n-\n-  \/\/ Test for equality\n-  \/\/ Entries are unique for class\/classloader name pair\n-  bool equals(Symbol* class_name, ClassLoaderData* loader) const {\n-    return (klassname() == class_name && loader_data() == loader);\n-  }\n-\n@@ -193,3 +147,1 @@\n-  \/\/ Print method doesn't append a cr\n-  void print_entry(outputStream* st) const;\n-  void verify() const;\n+  void print_on(outputStream* st) const;\n","filename":"src\/hotspot\/share\/classfile\/placeholders.hpp","additions":34,"deletions":82,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -226,1 +226,1 @@\n-  _local_table = new StringTableHash(start_size_log_2, END_SIZE, REHASH_LEN);\n+  _local_table = new StringTableHash(start_size_log_2, END_SIZE, REHASH_LEN, true);\n@@ -506,1 +506,1 @@\n-  StringTableHash* new_table = new StringTableHash(new_size, END_SIZE, REHASH_LEN);\n+  StringTableHash* new_table = new StringTableHash(new_size, END_SIZE, REHASH_LEN, true);\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-  _local_table = new SymbolTableHash(start_size_log_2, END_SIZE, REHASH_LEN);\n+  _local_table = new SymbolTableHash(start_size_log_2, END_SIZE, REHASH_LEN, true);\n@@ -786,1 +786,1 @@\n-  SymbolTableHash* new_table = new SymbolTableHash(new_size, END_SIZE, REHASH_LEN);\n+  SymbolTableHash* new_table = new SymbolTableHash(new_size, END_SIZE, REHASH_LEN, true);\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -129,5 +130,0 @@\n-\/\/ Hashtable holding placeholders for classes being loaded.\n-const int _placeholder_table_size = 1009;\n-static PlaceholderTable* _placeholders   = NULL;\n-static PlaceholderTable*   placeholders() { return _placeholders; }\n-\n@@ -392,1 +388,1 @@\n-    probe->print_entry(&ls);\n+    probe->print_on(&ls);\n@@ -445,1 +441,0 @@\n-  assert(placeholders()->compute_hash(class_name) == name_hash, \"they're the same hashcode\");\n@@ -463,1 +458,1 @@\n-      PlaceholderEntry* probe = placeholders()->get_entry(name_hash, class_name, loader_data);\n+      PlaceholderEntry* probe = PlaceholderTable::get_entry(class_name, loader_data);\n@@ -472,5 +467,4 @@\n-      PlaceholderEntry* newprobe = placeholders()->find_and_add(name_hash,\n-                                                                class_name,\n-                                                                loader_data,\n-                                                                PlaceholderTable::LOAD_SUPER,\n-                                                                super_name, THREAD);\n+      PlaceholderEntry* newprobe = PlaceholderTable::find_and_add(class_name,\n+                                                                  loader_data,\n+                                                                  PlaceholderTable::LOAD_SUPER,\n+                                                                  super_name, THREAD);\n@@ -495,1 +489,1 @@\n-    placeholders()->find_and_remove(name_hash, class_name, loader_data, PlaceholderTable::LOAD_SUPER, THREAD);\n+    PlaceholderTable::find_and_remove(class_name, loader_data, PlaceholderTable::LOAD_SUPER, THREAD);\n@@ -582,1 +576,1 @@\n-  PlaceholderEntry* oldprobe = placeholders()->get_entry(name_hash, name, loader_data);\n+  PlaceholderEntry* oldprobe = PlaceholderTable::get_entry(name, loader_data);\n@@ -623,1 +617,1 @@\n-        oldprobe = placeholders()->get_entry(name_hash, name, loader_data);\n+        oldprobe = PlaceholderTable::get_entry(name, loader_data);\n@@ -692,2 +686,0 @@\n-  assert(placeholders()->compute_hash(name) == name_hash, \"they're the same hashcode\");\n-\n@@ -702,1 +694,1 @@\n-      PlaceholderEntry* placeholder = placeholders()->get_entry(name_hash, name, loader_data);\n+      PlaceholderEntry* placeholder = PlaceholderTable::get_entry(name, loader_data);\n@@ -760,4 +752,4 @@\n-          PlaceholderEntry* newprobe = placeholders()->find_and_add(name_hash, name, loader_data,\n-                                                                    PlaceholderTable::LOAD_INSTANCE,\n-                                                                    NULL,\n-                                                                    THREAD);\n+          PlaceholderEntry* newprobe = PlaceholderTable::find_and_add(name, loader_data,\n+                                                                      PlaceholderTable::LOAD_INSTANCE,\n+                                                                      NULL,\n+                                                                      THREAD);\n@@ -777,1 +769,1 @@\n-    \/\/ placeholders()->find_and_add(PlaceholderTable::LOAD_INSTANCE),\n+    \/\/ PlaceholderTable::find_and_add(PlaceholderTable::LOAD_INSTANCE),\n@@ -791,1 +783,1 @@\n-      placeholders()->find_and_remove(name_hash, name, loader_data, PlaceholderTable::LOAD_INSTANCE, THREAD);\n+      PlaceholderTable::find_and_remove(name, loader_data, PlaceholderTable::LOAD_INSTANCE, THREAD);\n@@ -1541,1 +1533,1 @@\n-\/\/ placeholders()->find_and_add(PlaceholderTable::DEFINE_CLASS),\n+\/\/ PlaceholderTable::find_and_add(PlaceholderTable::DEFINE_CLASS),\n@@ -1565,3 +1557,2 @@\n-    assert(placeholders()->compute_hash(name_h) == name_hash, \"they're the same hashcode\");\n-    PlaceholderEntry* probe = placeholders()->find_and_add(name_hash, name_h, loader_data,\n-                                                           PlaceholderTable::DEFINE_CLASS, NULL, THREAD);\n+    PlaceholderEntry* probe = PlaceholderTable::find_and_add(name_h, loader_data,\n+                                                             PlaceholderTable::DEFINE_CLASS, NULL, THREAD);\n@@ -1580,1 +1571,1 @@\n-      placeholders()->find_and_remove(name_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, THREAD);\n+      PlaceholderTable::find_and_remove(name_h, loader_data, PlaceholderTable::DEFINE_CLASS, THREAD);\n@@ -1598,1 +1589,1 @@\n-    PlaceholderEntry* probe = placeholders()->get_entry(name_hash, name_h, loader_data);\n+    PlaceholderEntry* probe = PlaceholderTable::get_entry(name_h, loader_data);\n@@ -1604,1 +1595,1 @@\n-    placeholders()->find_and_remove(name_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, THREAD);\n+    PlaceholderTable::find_and_remove(name_h, loader_data, PlaceholderTable::DEFINE_CLASS, THREAD);\n@@ -1727,1 +1718,0 @@\n-  _placeholders        = new PlaceholderTable(_placeholder_table_size);\n@@ -2492,1 +2482,1 @@\n-  placeholders()->print_on(st);\n+  PlaceholderTable::print_on(st);\n@@ -2508,2 +2498,0 @@\n-  guarantee(placeholders()->number_of_entries() >= 0,\n-            \"Verify of placeholders failed\");\n@@ -2516,2 +2504,0 @@\n-  placeholders()->verify();\n-\n@@ -2520,1 +2506,1 @@\n-  constraints()->verify(placeholders());\n+  constraints()->verify();\n@@ -2532,1 +2518,0 @@\n-    placeholders()->print_table_statistics(st, \"Placeholder Table\");\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":25,"deletions":40,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"utilities\/resourceHash.hpp\"\n@@ -111,0 +112,2 @@\n+class ConstantPoolCache;\n+class ConstantPoolCacheEntry;\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n@@ -761,1 +762,1 @@\n-void CodeCache::do_unloading(BoolObjectClosure* is_alive, bool unloading_occurred) {\n+void CodeCache::do_unloading(bool unloading_occurred) {\n@@ -763,1 +764,0 @@\n-  UnloadingScope scope(is_alive);\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -200,1 +200,1 @@\n-  static void do_unloading(BoolObjectClosure* is_alive, bool unloading_occurred);\n+  static void do_unloading(bool unloading_occurred);\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -208,0 +208,6 @@\n+nmethodBucket* DependencyContext::release_and_get_next_not_unloading(nmethodBucket* b) {\n+  nmethodBucket* next = b->next_not_unloading();\n+  release(b);\n+  return next;\n+ }\n+\n@@ -210,1 +216,7 @@\n-int DependencyContext::remove_all_dependents() {\n+void DependencyContext::remove_all_dependents() {\n+  nmethodBucket* b = dependencies_not_unloading();\n+  set_dependencies(NULL);\n+  assert(b == nullptr, \"All dependents should be unloading\");\n+}\n+\n+int DependencyContext::remove_and_mark_for_deoptimization_all_dependents() {\n@@ -214,1 +226,0 @@\n-  int removed = 0;\n@@ -221,7 +232,1 @@\n-    nmethodBucket* next = b->next_not_unloading();\n-    removed++;\n-    release(b);\n-    b = next;\n-  }\n-  if (UsePerfData && removed > 0) {\n-    _perf_total_buckets_deallocated_count->inc(removed);\n+    b = release_and_get_next_not_unloading(b);\n","filename":"src\/hotspot\/share\/code\/dependencyContext.cpp","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -123,1 +123,2 @@\n-  int  remove_all_dependents();\n+  void remove_all_dependents();\n+  int  remove_and_mark_for_deoptimization_all_dependents();\n@@ -125,0 +126,1 @@\n+  static nmethodBucket* release_and_get_next_not_unloading(nmethodBucket* b);\n","filename":"src\/hotspot\/share\/code\/dependencyContext.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,3 @@\n-#include \"runtime\/os.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"runtime\/osInfo.hpp\"\n@@ -30,0 +32,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -1264,1 +1267,1 @@\n-    assert(target == NULL || (uintptr_t)target >= (uintptr_t)os::vm_page_size(), INTPTR_FORMAT, (intptr_t)target);\n+    assert(target == NULL || (uintptr_t)target >= (uintptr_t)OSInfo::vm_page_size(), INTPTR_FORMAT, (intptr_t)target);\n","filename":"src\/hotspot\/share\/code\/relocInfo.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+class Mutex;\n+\n","filename":"src\/hotspot\/share\/code\/stubs.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n+#include \"include\/jvm_io.h\"\n@@ -35,2 +37,0 @@\n-#include \"compiler\/compilerDefinitions.hpp\"\n-#include \"gc\/shared\/gcConfig.hpp\"\n@@ -226,4 +226,0 @@\n-bool CompilerConfig::is_interpreter_only() {\n-  return Arguments::is_interpreter_only() || TieredStopAtLevel == CompLevel_none;\n-}\n-\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-#include \"compiler\/compiler_globals.hpp\"\n-#include \"jvmci\/jvmci_globals.hpp\"\n@@ -31,1 +29,1 @@\n-#include \"runtime\/globals.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -141,3 +139,3 @@\n-  static bool is_jvmci_compiler()    { return JVMCI_ONLY(has_jvmci() && UseJVMCICompiler) NOT_JVMCI(false); }\n-  static bool is_jvmci()             { return JVMCI_ONLY(has_jvmci() && EnableJVMCI) NOT_JVMCI(false);      }\n-  static bool is_interpreter_only();\n+  inline static bool is_jvmci_compiler();\n+  inline static bool is_jvmci();\n+  inline static bool is_interpreter_only();\n@@ -150,89 +148,0 @@\n-  \/\/\n-\n-  \/\/ Is the JVM in a configuration that permits only c1-compiled methods (level 1,2,3)?\n-  static bool is_c1_only() {\n-    if (!is_interpreter_only() && has_c1()) {\n-      const bool c1_only = !has_c2() && !is_jvmci_compiler();\n-      const bool tiered_degraded_to_c1_only = TieredCompilation && TieredStopAtLevel >= CompLevel_simple && TieredStopAtLevel < CompLevel_full_optimization;\n-      const bool c1_only_compilation_mode = CompilationModeFlag::quick_only();\n-      return c1_only || tiered_degraded_to_c1_only || c1_only_compilation_mode;\n-    }\n-    return false;\n-  }\n-\n-  static bool is_c1_or_interpreter_only_no_jvmci() {\n-    assert(is_jvmci_compiler() && is_jvmci() || !is_jvmci_compiler(), \"JVMCI compiler implies enabled JVMCI\");\n-    return !is_jvmci() && (is_interpreter_only() || is_c1_only());\n-  }\n-\n-  static bool is_c1_only_no_jvmci() {\n-    return is_c1_only() && !is_jvmci();\n-  }\n-\n-  \/\/ Is the JVM in a configuration that permits only c1-compiled methods at level 1?\n-  static bool is_c1_simple_only() {\n-    if (is_c1_only()) {\n-      const bool tiered_degraded_to_level_1 = TieredCompilation && TieredStopAtLevel == CompLevel_simple;\n-      const bool c1_only_compilation_mode = CompilationModeFlag::quick_only();\n-      const bool tiered_off = !TieredCompilation;\n-      return tiered_degraded_to_level_1 || c1_only_compilation_mode || tiered_off;\n-    }\n-    return false;\n-  }\n-\n-  static bool is_c2_enabled() {\n-    return has_c2() && !is_interpreter_only() && !is_c1_only() && !is_jvmci_compiler();\n-  }\n-\n-  static bool is_jvmci_compiler_enabled() {\n-    return is_jvmci_compiler() && !is_interpreter_only() && !is_c1_only();\n-  }\n-  \/\/ Is the JVM in a configuration that permits only c2-compiled methods?\n-  static bool is_c2_only() {\n-    if (is_c2_enabled()) {\n-      const bool c2_only = !has_c1();\n-      \/\/ There is no JVMCI compiler to replace C2 in the broker, and the user (or ergonomics)\n-      \/\/ is forcing C1 off.\n-      const bool c2_only_compilation_mode = CompilationModeFlag::high_only();\n-      const bool tiered_off = !TieredCompilation;\n-      return c2_only || c2_only_compilation_mode || tiered_off;\n-    }\n-    return false;\n-  }\n-\n-  \/\/ Is the JVM in a configuration that permits only jvmci-compiled methods?\n-  static bool is_jvmci_compiler_only() {\n-    if (is_jvmci_compiler_enabled()) {\n-      const bool jvmci_compiler_only = !has_c1();\n-      \/\/ JVMCI compiler replaced C2 and the user (or ergonomics) is forcing C1 off.\n-      const bool jvmci_only_compilation_mode = CompilationModeFlag::high_only();\n-      const bool tiered_off = !TieredCompilation;\n-      return jvmci_compiler_only || jvmci_only_compilation_mode || tiered_off;\n-    }\n-    return false;\n-  }\n-\n-  static bool is_c2_or_jvmci_compiler_only() {\n-    return is_c2_only() || is_jvmci_compiler_only();\n-  }\n-\n-  \/\/ Tiered is basically C1 & (C2 | JVMCI) minus all the odd cases with restrictions.\n-  static bool is_tiered() {\n-    assert(is_c1_simple_only() && is_c1_only() || !is_c1_simple_only(), \"c1 simple mode must imply c1-only mode\");\n-    return has_tiered() && !is_interpreter_only() && !is_c1_only() && !is_c2_or_jvmci_compiler_only();\n-  }\n-\n-  static bool is_c1_enabled() {\n-    return has_c1() && !is_interpreter_only() && !is_c2_or_jvmci_compiler_only();\n-  }\n-\n-  static bool is_c1_profiling() {\n-    const bool c1_only_profiling = is_c1_only() && !is_c1_simple_only();\n-    const bool tiered = is_tiered();\n-    return c1_only_profiling || tiered;\n-  }\n-\n-\n-  static bool is_c2_or_jvmci_compiler_enabled() {\n-    return is_c2_enabled() || is_jvmci_compiler_enabled();\n-  }\n@@ -240,0 +149,16 @@\n+  inline static bool is_tiered();\n+\n+  inline static bool is_c1_enabled();\n+  inline static bool is_c1_only();\n+  inline static bool is_c1_simple_only();\n+  inline static bool is_c1_or_interpreter_only_no_jvmci();\n+  inline static bool is_c1_only_no_jvmci();\n+  inline static bool is_c1_profiling();\n+\n+  inline static bool is_jvmci_compiler_enabled();\n+  inline static bool is_jvmci_compiler_only();\n+\n+  inline static bool is_c2_only();\n+  inline static bool is_c2_enabled();\n+  inline static bool is_c2_or_jvmci_compiler_only();\n+  inline static bool is_c2_or_jvmci_compiler_enabled();\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.hpp","additions":20,"deletions":95,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_COMPILER_COMPILERDEFINITIONS_INLINE_HPP\n+#define SHARE_COMPILER_COMPILERDEFINITIONS_INLINE_HPP\n+\n+#include \"compiler\/compilerDefinitions.hpp\"\n+\n+#include \"compiler\/compiler_globals.hpp\"\n+#include \"compiler\/compilerDefinitions.hpp\"\n+#include \"runtime\/arguments.hpp\"\n+\n+inline bool CompilerConfig::is_interpreter_only() {\n+  return Arguments::is_interpreter_only() || TieredStopAtLevel == CompLevel_none;\n+}\n+\n+inline bool CompilerConfig::is_jvmci_compiler()    { return JVMCI_ONLY(has_jvmci() && UseJVMCICompiler) NOT_JVMCI(false); }\n+inline bool CompilerConfig::is_jvmci()             { return JVMCI_ONLY(has_jvmci() && EnableJVMCI     ) NOT_JVMCI(false); }\n+\n+\/\/ is_*_only() functions describe situations in which the JVM is in one way or another\n+\/\/ forced to use a particular compiler or their combination. The constraint functions\n+\/\/ deliberately ignore the fact that there may also be methods installed\n+\/\/ through JVMCI (where the JVMCI compiler was invoked not through the broker). Be sure\n+\/\/ to check for those (using is_jvmci()) in situations where it matters.\n+\/\/\n+\n+\/\/ Is the JVM in a configuration that permits only c1-compiled methods (level 1,2,3)?\n+inline bool CompilerConfig::is_c1_only() {\n+  if (!is_interpreter_only() && has_c1()) {\n+    const bool c1_only = !has_c2() && !is_jvmci_compiler();\n+    const bool tiered_degraded_to_c1_only = TieredCompilation && TieredStopAtLevel >= CompLevel_simple && TieredStopAtLevel < CompLevel_full_optimization;\n+    const bool c1_only_compilation_mode = CompilationModeFlag::quick_only();\n+    return c1_only || tiered_degraded_to_c1_only || c1_only_compilation_mode;\n+  }\n+  return false;\n+}\n+\n+inline bool CompilerConfig::is_c1_or_interpreter_only_no_jvmci() {\n+  assert(is_jvmci_compiler() && is_jvmci() || !is_jvmci_compiler(), \"JVMCI compiler implies enabled JVMCI\");\n+  return !is_jvmci() && (is_interpreter_only() || is_c1_only());\n+}\n+\n+inline bool CompilerConfig::is_c1_only_no_jvmci() {\n+  return is_c1_only() && !is_jvmci();\n+}\n+\n+\/\/ Is the JVM in a configuration that permits only c1-compiled methods at level 1?\n+inline bool CompilerConfig::is_c1_simple_only() {\n+  if (is_c1_only()) {\n+    const bool tiered_degraded_to_level_1 = TieredCompilation && TieredStopAtLevel == CompLevel_simple;\n+    const bool c1_only_compilation_mode = CompilationModeFlag::quick_only();\n+    const bool tiered_off = !TieredCompilation;\n+    return tiered_degraded_to_level_1 || c1_only_compilation_mode || tiered_off;\n+  }\n+  return false;\n+}\n+\n+inline bool CompilerConfig::is_c2_enabled() {\n+  return has_c2() && !is_interpreter_only() && !is_c1_only() && !is_jvmci_compiler();\n+}\n+\n+inline bool CompilerConfig::is_jvmci_compiler_enabled() {\n+  return is_jvmci_compiler() && !is_interpreter_only() && !is_c1_only();\n+}\n+\/\/ Is the JVM in a configuration that permits only c2-compiled methods?\n+inline bool CompilerConfig::is_c2_only() {\n+  if (is_c2_enabled()) {\n+    const bool c2_only = !has_c1();\n+    \/\/ There is no JVMCI compiler to replace C2 in the broker, and the user (or ergonomics)\n+    \/\/ is forcing C1 off.\n+    const bool c2_only_compilation_mode = CompilationModeFlag::high_only();\n+    const bool tiered_off = !TieredCompilation;\n+    return c2_only || c2_only_compilation_mode || tiered_off;\n+  }\n+  return false;\n+}\n+\n+\/\/ Is the JVM in a configuration that permits only jvmci-compiled methods?\n+inline bool CompilerConfig::is_jvmci_compiler_only() {\n+  if (is_jvmci_compiler_enabled()) {\n+    const bool jvmci_compiler_only = !has_c1();\n+    \/\/ JVMCI compiler replaced C2 and the user (or ergonomics) is forcing C1 off.\n+    const bool jvmci_only_compilation_mode = CompilationModeFlag::high_only();\n+    const bool tiered_off = !TieredCompilation;\n+    return jvmci_compiler_only || jvmci_only_compilation_mode || tiered_off;\n+  }\n+  return false;\n+}\n+\n+inline bool CompilerConfig::is_c2_or_jvmci_compiler_only() {\n+  return is_c2_only() || is_jvmci_compiler_only();\n+}\n+\n+\/\/ Tiered is basically C1 & (C2 | JVMCI) minus all the odd cases with restrictions.\n+inline bool CompilerConfig::is_tiered() {\n+  assert(is_c1_simple_only() && is_c1_only() || !is_c1_simple_only(), \"c1 simple mode must imply c1-only mode\");\n+  return has_tiered() && !is_interpreter_only() && !is_c1_only() && !is_c2_or_jvmci_compiler_only();\n+}\n+\n+inline bool CompilerConfig::is_c1_enabled() {\n+  return has_c1() && !is_interpreter_only() && !is_c2_or_jvmci_compiler_only();\n+}\n+\n+inline bool CompilerConfig::is_c1_profiling() {\n+  const bool c1_only_profiling = is_c1_only() && !is_c1_simple_only();\n+  const bool tiered = is_tiered();\n+  return c1_only_profiling || tiered;\n+}\n+\n+inline bool CompilerConfig::is_c2_or_jvmci_compiler_enabled() {\n+  return is_c2_enabled() || is_jvmci_compiler_enabled();\n+}\n+\n+#endif \/\/ SHARE_COMPILER_COMPILERDEFINITIONS_INLINE_HPP\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.inline.hpp","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -308,1 +308,1 @@\n-  develop(bool, ReplayCompiles, false,                                      \\\n+  product(bool, ReplayCompiles, false, DIAGNOSTIC,                          \\\n@@ -319,1 +319,1 @@\n-  develop(intx, ReplaySuppressInitializers, 2,                              \\\n+  product(intx, ReplaySuppressInitializers, 2, DIAGNOSTIC,                  \\\n@@ -328,1 +328,1 @@\n-  develop(bool, ReplayIgnoreInitErrors, false,                              \\\n+  product(bool, ReplayIgnoreInitErrors, false, DIAGNOSTIC,                  \\\n","filename":"src\/hotspot\/share\/compiler\/compiler_globals.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2017, 2022, Red Hat, Inc. All rights reserved.\n@@ -28,0 +28,2 @@\n+#include \"gc\/epsilon\/epsilonBarrierSet.hpp\"\n+#include \"gc\/epsilon\/epsilonMonitoringSupport.hpp\"\n@@ -31,2 +33,1 @@\n-#include \"gc\/epsilon\/epsilonMonitoringSupport.hpp\"\n-#include \"gc\/epsilon\/epsilonBarrierSet.hpp\"\n+#include \"memory\/virtualspace.hpp\"\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonHeap.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -296,0 +296,40 @@\n+G1PLABAllocator::PerDestinationPLABData::PerDestinationPLABData() :\n+  _alloc_buffer(nullptr),\n+  _direct_allocated(0),\n+  _num_plab_fills(0),\n+  _num_direct_allocations(0),\n+  _plab_fill_counter(0),\n+  _cur_desired_plab_size(0),\n+  _num_alloc_buffers(0) { }\n+\n+G1PLABAllocator::PerDestinationPLABData::~PerDestinationPLABData() {\n+  if (_alloc_buffer == nullptr) {\n+    return;\n+  }\n+  for (uint node_index = 0; node_index < _num_alloc_buffers; node_index++) {\n+    delete _alloc_buffer[node_index];\n+  }\n+}\n+\n+void G1PLABAllocator::PerDestinationPLABData::initialize(uint num_alloc_buffers, size_t desired_plab_size, size_t tolerated_refills) {\n+  _num_alloc_buffers = num_alloc_buffers;\n+  _alloc_buffer = NEW_C_HEAP_ARRAY(PLAB*, _num_alloc_buffers, mtGC);\n+\n+  for (uint node_index = 0; node_index < _num_alloc_buffers; node_index++) {\n+    _alloc_buffer[node_index] = new PLAB(desired_plab_size);\n+  }\n+\n+  _plab_fill_counter = tolerated_refills;\n+  _cur_desired_plab_size = desired_plab_size;\n+}\n+\n+void G1PLABAllocator::PerDestinationPLABData::notify_plab_refill(size_t tolerated_refills, size_t next_plab_size) {\n+  _num_plab_fills++;\n+  if (should_boost()) {\n+    _plab_fill_counter = tolerated_refills;\n+    _cur_desired_plab_size = next_plab_size;\n+  } else {\n+    _plab_fill_counter--;\n+  }\n+}\n+\n@@ -312,3 +352,2 @@\n-    \/\/ Make the tolerated refills a huge number; -2 because we add one to this\n-    \/\/ value later and it would overflow otherwise.\n-    _tolerated_refills = (size_t)-2;\n+    \/\/ Make the tolerated refills a huge number.\n+    _tolerated_refills = SIZE_MAX;\n@@ -316,1 +355,2 @@\n-\n+  \/\/ The initial PLAB refill should not count, hence the +1 for the first boost.\n+  size_t initial_tolerated_refills = ResizePLAB ? _tolerated_refills + 1 : _tolerated_refills;\n@@ -318,22 +358,1 @@\n-    _direct_allocated[state] = 0;\n-    uint length = alloc_buffers_length(state);\n-    _alloc_buffers[state] = NEW_C_HEAP_ARRAY(PLAB*, length, mtGC);\n-    size_t word_sz = _g1h->desired_plab_sz(state);\n-    for (uint node_index = 0; node_index < length; node_index++) {\n-      _alloc_buffers[state][node_index] = new PLAB(word_sz);\n-    }\n-    _num_plab_fills[state] = 0;\n-    \/\/ The initial PLAB refill should not count, hence the +1 for the first boost.\n-    _plab_fill_counter[state] = _tolerated_refills + 1;\n-    _num_direct_allocations[state] = 0;\n-    _cur_desired_plab_size[state] = word_sz;\n-  }\n-}\n-\n-G1PLABAllocator::~G1PLABAllocator() {\n-  for (region_type_t state = 0; state < G1HeapRegionAttr::Num; state++) {\n-    uint length = alloc_buffers_length(state);\n-    for (uint node_index = 0; node_index < length; node_index++) {\n-      delete _alloc_buffers[state][node_index];\n-    }\n-    FREE_C_HEAP_ARRAY(PLAB*, _alloc_buffers[state]);\n+    _data[state].initialize(alloc_buffers_length(state), _g1h->desired_plab_sz(state), initial_tolerated_refills);\n@@ -354,2 +373,3 @@\n-  bool const should_boost_plab = _plab_fill_counter[dest.type()] == 0;\n-  if (should_boost_plab) {\n+  PerDestinationPLABData* plab_data = &_data[dest.type()];\n+\n+  if (plab_data->should_boost()) {\n@@ -370,1 +390,0 @@\n-    _num_plab_fills[dest.type()]++;\n@@ -373,5 +392,1 @@\n-    if (should_boost_plab) {\n-      _plab_fill_counter[dest.type()] = _tolerated_refills;\n-    } else {\n-      _plab_fill_counter[dest.type()]--;\n-    }\n+    plab_data->notify_plab_refill(_tolerated_refills, next_plab_word_size);\n@@ -379,1 +394,0 @@\n-    _cur_desired_plab_size[dest.type()] = plab_word_size;\n@@ -407,2 +421,2 @@\n-    _direct_allocated[dest.type()] += word_sz;\n-    _num_direct_allocations[dest.type()]++;\n+    plab_data->_direct_allocated += word_sz;\n+    plab_data->_num_direct_allocations++;\n@@ -426,3 +440,4 @@\n-    stats->add_num_plab_filled(_num_plab_fills[state]);\n-    stats->add_direct_allocated(_direct_allocated[state]);\n-    stats->add_num_direct_allocated(_num_direct_allocations[state]);\n+    PerDestinationPLABData* plab_data = &_data[state];\n+    stats->add_num_plab_filled(plab_data->_num_plab_fills);\n+    stats->add_direct_allocated(plab_data->_direct_allocated);\n+    stats->add_num_direct_allocated(plab_data->_num_direct_allocations);\n@@ -434,1 +449,1 @@\n-                      _num_plab_fills[G1HeapRegionAttr::Young],\n+                      _data[G1HeapRegionAttr::Young]._num_plab_fills,\n@@ -438,1 +453,1 @@\n-                      _num_plab_fills[G1HeapRegionAttr::Old],\n+                      _data[G1HeapRegionAttr::Old]._num_plab_fills,\n@@ -456,1 +471,1 @@\n-  return _cur_desired_plab_size[which.type()];\n+  return _data[which.type()]._cur_desired_plab_size;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.cpp","additions":58,"deletions":43,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -159,1 +159,4 @@\n-  PLAB** _alloc_buffers[G1HeapRegionAttr::Num];\n+  \/\/ Collects per-destination information (e.g. young, old gen) about current PLAB\n+  \/\/ and statistics about it.\n+  struct PerDestinationPLABData {\n+    PLAB** _alloc_buffer;\n@@ -161,2 +164,3 @@\n-  \/\/ Number of words allocated directly (not counting PLAB allocation).\n-  size_t _direct_allocated[G1HeapRegionAttr::Num];\n+    size_t _direct_allocated;             \/\/ Number of words allocated directly (not counting PLAB allocation).\n+    size_t _num_plab_fills;               \/\/ Number of PLAB refills experienced so far.\n+    size_t _num_direct_allocations;       \/\/ Number of direct allocations experienced so far.\n@@ -164,3 +168,2 @@\n-  \/\/ Number of PLAB refills experienced so far.\n-  size_t _num_plab_fills[G1HeapRegionAttr::Num];\n-  size_t _num_direct_allocations[G1HeapRegionAttr::Num];\n+    size_t _plab_fill_counter;            \/\/ How many PLAB refills left until boosting.\n+    size_t _cur_desired_plab_size;        \/\/ Current desired PLAB size incorporating eventual boosting.\n@@ -168,3 +171,15 @@\n-  size_t _plab_fill_counter[G1HeapRegionAttr::Num];\n-  \/\/ Current desired PLAB size incorporating eventual boosting.\n-  size_t _cur_desired_plab_size[G1HeapRegionAttr::Num];\n+    uint _num_alloc_buffers;              \/\/ The number of PLABs for this destination.\n+\n+    PerDestinationPLABData();\n+    ~PerDestinationPLABData();\n+\n+    void initialize(uint num_alloc_buffers, size_t desired_plab_size, size_t tolerated_refills);\n+\n+    \/\/ Should we actually boost the PLAB size?\n+    \/\/ The _plab_refill_counter reset value encodes the ResizePLAB flag value already, so no\n+    \/\/ need to check here.\n+    bool should_boost() const { return _plab_fill_counter == 0; }\n+\n+    void notify_plab_refill(size_t tolerated_refills, size_t next_plab_size);\n+\n+  } _data[G1HeapRegionAttr::Num];\n@@ -189,1 +204,0 @@\n-  ~G1PLABAllocator();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.hpp","additions":24,"deletions":10,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-  assert(_alloc_buffers[dest.type()] != NULL,\n+  assert(_data[dest.type()]._alloc_buffer != nullptr,\n@@ -104,1 +104,1 @@\n-    return _alloc_buffers[dest][node_index];\n+    return _data[dest]._alloc_buffer[node_index];\n@@ -106,1 +106,1 @@\n-    return _alloc_buffers[dest][0];\n+    return _data[dest]._alloc_buffer[0];\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -229,1 +229,5 @@\n-  return predict_zero_bounded(_alloc_rate_ms_seq);\n+  if (enough_samples_available(_alloc_rate_ms_seq)) {\n+    return predict_zero_bounded(_alloc_rate_ms_seq);\n+  } else {\n+    return 0.0;\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Analytics.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -283,1 +283,1 @@\n-    _table(mm, initial_log_table_size) {\n+    _table(mm, initial_log_table_size, false) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -987,8 +987,0 @@\n-  \/\/ If we start the compaction before the CM threads finish\n-  \/\/ scanning the root regions we might trip them over as we'll\n-  \/\/ be moving objects \/ updating references. So let's wait until\n-  \/\/ they are done. By telling them to abort, they should complete\n-  \/\/ early.\n-  _cm->root_regions()->abort();\n-  _cm->root_regions()->wait_until_scan_finished();\n-\n@@ -2893,2 +2885,1 @@\n-void G1CollectedHeap::complete_cleaning(BoolObjectClosure* is_alive,\n-                                        bool class_unloading_occurred) {\n+void G1CollectedHeap::complete_cleaning(bool class_unloading_occurred) {\n@@ -2896,1 +2887,1 @@\n-  G1ParallelCleaningTask unlink_task(is_alive, num_workers, class_unloading_occurred);\n+  G1ParallelCleaningTask unlink_task(num_workers, class_unloading_occurred);\n@@ -3282,1 +3273,1 @@\n-    _cm->root_regions()->add(alloc_region->top_at_mark_start(), alloc_region->top());\n+    _cm->add_root_region(alloc_region);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1270,1 +1270,1 @@\n-  void complete_cleaning(BoolObjectClosure* is_alive, bool class_unloading_occurred);\n+  void complete_cleaning(bool class_unloading_occurred);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1009,0 +1009,8 @@\n+bool G1ConcurrentMark::wait_until_root_region_scan_finished() {\n+  return root_regions()->wait_until_scan_finished();\n+}\n+\n+void G1ConcurrentMark::add_root_region(HeapRegion* r) {\n+  root_regions()->add(r->top_at_mark_start(), r->top());\n+}\n+\n@@ -1684,0 +1692,1 @@\n+    CodeCache::UnloadingScope scope(&g1_is_alive);\n@@ -1685,1 +1694,1 @@\n-    _g1h->complete_cleaning(&g1_is_alive, purged_classes);\n+    _g1h->complete_cleaning(purged_classes);\n@@ -2021,0 +2030,8 @@\n+  \/\/ If we start the compaction before the CM threads finish\n+  \/\/ scanning the root regions we might trip them over as we'll\n+  \/\/ be moving objects \/ updating references. So let's wait until\n+  \/\/ they are done. By telling them to abort, they should complete\n+  \/\/ early.\n+  root_regions()->abort();\n+  root_regions()->wait_until_scan_finished();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -288,0 +288,1 @@\n+  friend class G1CMRootRegionScanTask;\n@@ -500,2 +501,0 @@\n-  G1CMRootMemRegions* root_regions() { return &_root_regions; }\n-\n@@ -560,0 +559,5 @@\n+  bool wait_until_root_region_scan_finished();\n+  void add_root_region(HeapRegion* r);\n+\n+private:\n+  G1CMRootMemRegions* root_regions() { return &_root_regions; }\n@@ -564,0 +568,2 @@\n+public:\n+\n@@ -611,1 +617,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -76,1 +76,0 @@\n-    size_t _marked_words;\n@@ -81,4 +80,0 @@\n-    void reset_marked_words() {\n-      _marked_words = 0;\n-    }\n-\n@@ -89,6 +84,0 @@\n-    void assert_marked_words(HeapRegion* hr) {\n-      assert((_marked_words * HeapWordSize) == hr->marked_bytes(),\n-             \"Mismatch between marking and re-calculation for region %u, %zu != %zu\",\n-             hr->hrm_index(), (_marked_words * HeapWordSize), hr->marked_bytes());\n-    }\n-\n@@ -97,1 +86,0 @@\n-      _marked_words += processed;\n@@ -231,1 +219,0 @@\n-      reset_marked_words();\n@@ -243,3 +230,0 @@\n-      \/\/ Assert that the size of marked objects from the marking matches\n-      \/\/ the size of the objects which we scanned to rebuild remembered sets.\n-      assert_marked_words(hr);\n@@ -273,1 +257,0 @@\n-      reset_marked_words();\n@@ -285,7 +268,0 @@\n-      } else if (_bitmap->is_marked(humongous) && should_rebuild_or_scrub(hr)) {\n-        \/\/ Only verify that the marked size matches the rebuilt size if this object was marked\n-        \/\/ and the object should still be handled. The should_rebuild_or_scrub() state can\n-        \/\/ change during rebuild for humongous objects that are eagerly reclaimed so we need to\n-        \/\/ check this.\n-        \/\/ If the object has not been marked the size from marking will be 0.\n-        assert_marked_words(hr);\n@@ -302,1 +278,0 @@\n-      _marked_words(0),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRebuildAndScrub.cpp","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  virtual uint add(HeapRegion* hr) {\n+  uint add(HeapRegion* hr) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EdenRegions.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -304,0 +304,1 @@\n+    CodeCache::UnloadingScope unloading_scope(&_is_alive);\n@@ -306,1 +307,1 @@\n-    _heap->complete_cleaning(&_is_alive, purged_class);\n+    _heap->complete_cleaning(purged_class);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCScope.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/g1\/g1HeapRegionEventSender.hpp\"\n@@ -28,1 +29,1 @@\n-#include \"g1HeapRegionEventSender.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionEventSender.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/g1\/g1Analytics.hpp\"\n@@ -28,1 +29,1 @@\n-#include \"gc\/g1\/g1Analytics.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MemoryPool.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1NUMA.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -54,2 +54,1 @@\n-G1ParallelCleaningTask::G1ParallelCleaningTask(BoolObjectClosure* is_alive,\n-                                               uint num_workers,\n+G1ParallelCleaningTask::G1ParallelCleaningTask(uint num_workers,\n@@ -59,1 +58,1 @@\n-  _code_cache_task(num_workers, is_alive, unloading_occurred),\n+  _code_cache_task(num_workers, unloading_occurred),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParallelCleaning.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -57,2 +57,1 @@\n-  G1ParallelCleaningTask(BoolObjectClosure* is_alive,\n-                         uint num_workers,\n+  G1ParallelCleaningTask(uint num_workers,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParallelCleaning.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+  _young_list_desired_length(0),\n@@ -65,1 +66,0 @@\n-  _young_list_fixed_length(0),\n@@ -103,3 +103,0 @@\n-  if (!use_adaptive_young_list_length()) {\n-    _young_list_fixed_length = _young_gen_sizer.min_desired_young_length();\n-  }\n@@ -110,1 +107,1 @@\n-  update_young_list_max_and_target_length();\n+  update_young_length_bounds();\n@@ -185,1 +182,4 @@\n-uint G1Policy::calculate_young_list_desired_min_length(uint base_min_length) const {\n+uint G1Policy::calculate_desired_eden_length_by_mmu() const {\n+  \/\/ One could argue that any useful eden length to keep any MMU wouldn't be zero, but\n+  \/\/ in theory this is possible. Other constraints enforce a minimum eden size of one\n+  \/\/ region anyway.\n@@ -188,8 +188,4 @@\n-    if (_analytics->num_alloc_rate_ms() > 3) {\n-      double now_sec = os::elapsedTime();\n-      double when_ms = _mmu_tracker->when_max_gc_sec(now_sec) * 1000.0;\n-      double alloc_rate_ms = _analytics->predict_alloc_rate_ms();\n-      desired_min_length = (uint) ceil(alloc_rate_ms * when_ms);\n-    } else {\n-      \/\/ otherwise we don't have enough info to make the prediction\n-    }\n+    double now_sec = os::elapsedTime();\n+    double when_ms = _mmu_tracker->when_max_gc_sec(now_sec) * 1000.0;\n+    double alloc_rate_ms = _analytics->predict_alloc_rate_ms();\n+    desired_min_length = (uint) ceil(alloc_rate_ms * when_ms);\n@@ -197,4 +193,43 @@\n-  desired_min_length += base_min_length;\n-  \/\/ make sure we don't go below any user-defined minimum bound\n-  return MAX2(_young_gen_sizer.min_desired_young_length(), desired_min_length);\n-}\n+  return desired_min_length;\n+}\n+\n+void G1Policy::update_young_length_bounds() {\n+  update_young_length_bounds(_analytics->predict_rs_length());\n+}\n+\n+void G1Policy::update_young_length_bounds(size_t rs_length) {\n+  _young_list_desired_length = calculate_young_desired_length(rs_length);\n+  _young_list_target_length = calculate_young_target_length(_young_list_desired_length);\n+  _young_list_max_length = calculate_young_max_length(_young_list_target_length);\n+\n+  log_debug(gc, ergo, heap)(\"Young list lengths: desired: %u, target: %u, max: %u\",\n+                            _young_list_desired_length,\n+                            _young_list_target_length,\n+                            _young_list_max_length);\n+}\n+\n+\/\/ Calculates desired young gen length. It is calculated from:\n+\/\/\n+\/\/ - sizer min\/max bounds on young gen\n+\/\/ - pause time goal for whole young gen evacuation\n+\/\/ - MMU goal influencing eden to make GCs spaced apart.\n+\/\/ - a minimum one eden region length.\n+\/\/\n+\/\/ We may enter with already allocated eden and survivor regions, that may be\n+\/\/ higher than the maximum, or the above goals may result in a desired value\n+\/\/ smaller than are already allocated.\n+\/\/ The main reason is revising young length, with or without the GCLocker being\n+\/\/ active.\n+\/\/\n+uint G1Policy::calculate_young_desired_length(size_t rs_length) const {\n+  uint min_young_length_by_sizer = _young_gen_sizer.min_desired_young_length();\n+  uint max_young_length_by_sizer = _young_gen_sizer.max_desired_young_length();\n+\n+  assert(min_young_length_by_sizer >= 1, \"invariant\");\n+  assert(max_young_length_by_sizer >= min_young_length_by_sizer, \"invariant\");\n+\n+  \/\/ Absolute minimum eden length.\n+  \/\/ Enforcing a minimum eden length helps at startup when the predictors are not\n+  \/\/ yet trained on the application to avoid unnecessary (but very short) full gcs\n+  \/\/ on very small (initial) heaps.\n+  uint const MinDesiredEdenLength = 1;\n@@ -202,23 +237,1 @@\n-uint G1Policy::calculate_young_list_desired_max_length() const {\n-  \/\/ Here, we might want to also take into account any additional\n-  \/\/ constraints (i.e., user-defined minimum bound). Currently, we\n-  \/\/ effectively don't set this bound.\n-  return _young_gen_sizer.max_desired_young_length();\n-}\n-\n-uint G1Policy::update_young_list_max_and_target_length() {\n-  return update_young_list_max_and_target_length(_analytics->predict_rs_length());\n-}\n-\n-uint G1Policy::update_young_list_max_and_target_length(size_t rs_length) {\n-  uint unbounded_target_length = update_young_list_target_length(rs_length);\n-  update_max_gc_locker_expansion();\n-  return unbounded_target_length;\n-}\n-\n-uint G1Policy::update_young_list_target_length(size_t rs_length) {\n-  YoungTargetLengths young_lengths = young_list_target_lengths(rs_length);\n-  _young_list_target_length = young_lengths.first;\n-\n-  return young_lengths.second;\n-}\n+  \/\/ Calculate the absolute and desired min bounds first.\n@@ -226,2 +239,19 @@\n-G1Policy::YoungTargetLengths G1Policy::young_list_target_lengths(size_t rs_length) const {\n-  YoungTargetLengths result;\n+  \/\/ This is how many survivor regions we already have.\n+  const uint survivor_length = _g1h->survivor_regions_count();\n+  \/\/ Size of the already allocated young gen.\n+  const uint allocated_young_length = _g1h->young_regions_count();\n+  \/\/ This is the absolute minimum young length that we can return. Ensure that we\n+  \/\/ don't go below any user-defined minimum bound; but we might have already\n+  \/\/ allocated more than that for various reasons. In this case, use that.\n+  uint absolute_min_young_length = MAX2(allocated_young_length, min_young_length_by_sizer);\n+  \/\/ Calculate the absolute max bounds. After evac failure or when revising the\n+  \/\/ young length we might have exceeded absolute min length or absolute_max_length,\n+  \/\/ so adjust the result accordingly.\n+  uint absolute_max_young_length = MAX2(max_young_length_by_sizer, absolute_min_young_length);\n+\n+  uint desired_eden_length_by_mmu = 0;\n+  uint desired_eden_length_by_pause = 0;\n+\n+  uint desired_young_length = 0;\n+  if (use_adaptive_young_list_length()) {\n+    desired_eden_length_by_mmu = calculate_desired_eden_length_by_mmu();\n@@ -229,1 +259,2 @@\n-  \/\/ Calculate the absolute and desired min bounds first.\n+    const size_t pending_cards = _analytics->predict_pending_cards();\n+    double survivor_base_time_ms = predict_base_elapsed_time_ms(pending_cards, rs_length);\n@@ -231,9 +262,4 @@\n-  \/\/ This is how many young regions we already have (currently: the survivors).\n-  const uint base_min_length = _g1h->survivor_regions_count();\n-  uint desired_min_length = calculate_young_list_desired_min_length(base_min_length);\n-  \/\/ This is the absolute minimum young length. Ensure that we\n-  \/\/ will at least have one eden region available for allocation.\n-  uint absolute_min_length = base_min_length + MAX2(_g1h->eden_regions_count(), (uint)1);\n-  \/\/ If we shrank the young list target it should not shrink below the current size.\n-  desired_min_length = MAX2(desired_min_length, absolute_min_length);\n-  \/\/ Calculate the absolute and desired max bounds.\n+    desired_eden_length_by_pause =\n+      calculate_desired_eden_length_by_pause(survivor_base_time_ms,\n+                                             absolute_min_young_length - survivor_length,\n+                                             absolute_max_young_length - survivor_length);\n@@ -241,1 +267,6 @@\n-  uint desired_max_length = calculate_young_list_desired_max_length();\n+    \/\/ Incorporate MMU concerns; assume that it overrides the pause time\n+    \/\/ goal, as the default value has been chosen to effectively disable it.\n+    \/\/ Also request at least one eden region, see above for reasons.\n+    uint desired_eden_length = MAX3(desired_eden_length_by_pause,\n+                                    desired_eden_length_by_mmu,\n+                                    MinDesiredEdenLength);\n@@ -243,13 +274,1 @@\n-  uint young_list_target_length = 0;\n-  if (use_adaptive_young_list_length()) {\n-    if (collector_state()->in_young_only_phase()) {\n-      young_list_target_length =\n-                        calculate_young_list_target_length(rs_length,\n-                                                           base_min_length,\n-                                                           desired_min_length,\n-                                                           desired_max_length);\n-    } else {\n-      \/\/ Don't calculate anything and let the code below bound it to\n-      \/\/ the desired_min_length, i.e., do the next GC as soon as\n-      \/\/ possible to maximize how many old regions we can add to it.\n-    }\n+    desired_young_length = desired_eden_length + survivor_length;\n@@ -259,9 +278,1 @@\n-    young_list_target_length = _young_list_fixed_length;\n-  }\n-\n-  result.second = young_list_target_length;\n-\n-  \/\/ We will try our best not to \"eat\" into the reserve.\n-  uint absolute_max_length = 0;\n-  if (_free_regions_at_end_of_collection > _reserve_regions) {\n-    absolute_max_length = _free_regions_at_end_of_collection - _reserve_regions;\n+    desired_young_length = min_young_length_by_sizer;\n@@ -269,2 +280,97 @@\n-  if (desired_max_length > absolute_max_length) {\n-    desired_max_length = absolute_max_length;\n+  \/\/ Clamp to absolute min\/max after we determined desired lengths.\n+  desired_young_length = clamp(desired_young_length, absolute_min_young_length, absolute_max_young_length);\n+\n+  log_trace(gc, ergo, heap)(\"Young desired length %u \"\n+                            \"survivor length %u \"\n+                            \"allocated young length %u \"\n+                            \"absolute min young length %u \"\n+                            \"absolute max young length %u \"\n+                            \"desired eden length by mmu %u \"\n+                            \"desired eden length by pause %u \"\n+                            \"desired eden length by default %u\",\n+                            desired_young_length, survivor_length,\n+                            allocated_young_length, absolute_min_young_length,\n+                            absolute_max_young_length, desired_eden_length_by_mmu,\n+                            desired_eden_length_by_pause,\n+                            MinDesiredEdenLength);\n+\n+  assert(desired_young_length >= allocated_young_length, \"must be\");\n+  return desired_young_length;\n+}\n+\n+\/\/ Limit the desired (wished) young length by current free regions. If the request\n+\/\/ can be satisfied without using up reserve regions, do so, otherwise eat into\n+\/\/ the reserve, giving away at most what the heap sizer allows.\n+uint G1Policy::calculate_young_target_length(uint desired_young_length) const {\n+  uint allocated_young_length = _g1h->young_regions_count();\n+\n+  uint receiving_additional_eden;\n+  if (allocated_young_length >= desired_young_length) {\n+    \/\/ Already used up all we actually want (may happen as G1 revises the\n+    \/\/ young list length concurrently, or caused by gclocker). Do not allow more,\n+    \/\/ potentially resulting in GC.\n+    receiving_additional_eden = 0;\n+    log_trace(gc, ergo, heap)(\"Young target length: Already used up desired young %u allocated %u\",\n+                              desired_young_length,\n+                              allocated_young_length);\n+  } else {\n+    \/\/ Now look at how many free regions are there currently, and the heap reserve.\n+    \/\/ We will try our best not to \"eat\" into the reserve as long as we can. If we\n+    \/\/ do, we at most eat the sizer's minimum regions into the reserve or half the\n+    \/\/ reserve rounded up (if possible; this is an arbitrary value).\n+\n+    uint max_to_eat_into_reserve = MIN2(_young_gen_sizer.min_desired_young_length(),\n+                                        (_reserve_regions + 1) \/ 2);\n+\n+    log_trace(gc, ergo, heap)(\"Young target length: Common \"\n+                              \"free regions at end of collection %u \"\n+                              \"desired young length %u \"\n+                              \"reserve region %u \"\n+                              \"max to eat into reserve %u\",\n+                              _free_regions_at_end_of_collection,\n+                              desired_young_length,\n+                              _reserve_regions,\n+                              max_to_eat_into_reserve);\n+\n+    if (_free_regions_at_end_of_collection <= _reserve_regions) {\n+      \/\/ Fully eat (or already eating) into the reserve, hand back at most absolute_min_length regions.\n+      uint receiving_young = MIN3(_free_regions_at_end_of_collection,\n+                                  desired_young_length,\n+                                  max_to_eat_into_reserve);\n+      \/\/ We could already have allocated more regions than what we could get\n+      \/\/ above.\n+      receiving_additional_eden = allocated_young_length < receiving_young ?\n+                                  receiving_young - allocated_young_length : 0;\n+\n+      log_trace(gc, ergo, heap)(\"Young target length: Fully eat into reserve \"\n+                                \"receiving young %u receiving additional eden %u\",\n+                                receiving_young,\n+                                receiving_additional_eden);\n+    } else if (_free_regions_at_end_of_collection < (desired_young_length + _reserve_regions)) {\n+      \/\/ Partially eat into the reserve, at most max_to_eat_into_reserve regions.\n+      uint free_outside_reserve = _free_regions_at_end_of_collection - _reserve_regions;\n+      assert(free_outside_reserve < desired_young_length,\n+             \"must be %u %u\",\n+             free_outside_reserve, desired_young_length);\n+\n+      uint receiving_within_reserve = MIN2(desired_young_length - free_outside_reserve,\n+                                           max_to_eat_into_reserve);\n+      uint receiving_young = free_outside_reserve + receiving_within_reserve;\n+      \/\/ Again, we could have already allocated more than we could get.\n+      receiving_additional_eden = allocated_young_length < receiving_young ?\n+                                  receiving_young - allocated_young_length : 0;\n+\n+      log_trace(gc, ergo, heap)(\"Young target length: Partially eat into reserve \"\n+                                \"free outside reserve %u \"\n+                                \"receiving within reserve %u \"\n+                                \"receiving young %u \"\n+                                \"receiving additional eden %u\",\n+                                free_outside_reserve, receiving_within_reserve,\n+                                receiving_young, receiving_additional_eden);\n+    } else {\n+      \/\/ No need to use the reserve.\n+      receiving_additional_eden = desired_young_length - allocated_young_length;\n+      log_trace(gc, ergo, heap)(\"Young target length: No need to use reserve \"\n+                                \"receiving additional eden %u\",\n+                                receiving_additional_eden);\n+    }\n@@ -273,9 +379,1 @@\n-  \/\/ Make sure we don't go over the desired max length, nor under the\n-  \/\/ desired min length. In case they clash, desired_min_length wins\n-  \/\/ which is why that test is second.\n-  if (young_list_target_length > desired_max_length) {\n-    young_list_target_length = desired_max_length;\n-  }\n-  if (young_list_target_length < desired_min_length) {\n-    young_list_target_length = desired_min_length;\n-  }\n+  uint target_young_length = allocated_young_length + receiving_additional_eden;\n@@ -283,3 +381,1 @@\n-  assert(young_list_target_length > base_min_length,\n-         \"we should be able to allocate at least one eden region\");\n-  assert(young_list_target_length >= absolute_min_length, \"post-condition\");\n+  assert(target_young_length >= allocated_young_length, \"must be\");\n@@ -287,2 +383,7 @@\n-  result.first = young_list_target_length;\n-  return result;\n+  log_trace(gc, ergo, heap)(\"Young target length: \"\n+                            \"young target length %u \"\n+                            \"allocated young length %u \"\n+                            \"received additional eden %u\",\n+                            target_young_length, allocated_young_length,\n+                            receiving_additional_eden);\n+  return target_young_length;\n@@ -291,10 +392,11 @@\n-uint G1Policy::calculate_young_list_target_length(size_t rs_length,\n-                                                  uint base_min_length,\n-                                                  uint desired_min_length,\n-                                                  uint desired_max_length) const {\n-  assert(use_adaptive_young_list_length(), \"pre-condition\");\n-  assert(collector_state()->in_young_only_phase(), \"only call this for young GCs\");\n-\n-  \/\/ In case some edge-condition makes the desired max length too small...\n-  if (desired_max_length <= desired_min_length) {\n-    return desired_min_length;\n+uint G1Policy::calculate_desired_eden_length_by_pause(double base_time_ms,\n+                                                      uint min_eden_length,\n+                                                      uint max_eden_length) const {\n+  if (!next_gc_should_be_mixed(nullptr)) {\n+    return calculate_desired_eden_length_before_young_only(base_time_ms,\n+                                                           min_eden_length,\n+                                                           max_eden_length);\n+  } else {\n+    return calculate_desired_eden_length_before_mixed(base_time_ms,\n+                                                      min_eden_length,\n+                                                      max_eden_length);\n@@ -302,0 +404,1 @@\n+}\n@@ -303,16 +406,6 @@\n-  \/\/ We'll adjust min_young_length and max_young_length not to include\n-  \/\/ the already allocated young regions (i.e., so they reflect the\n-  \/\/ min and max eden regions we'll allocate). The base_min_length\n-  \/\/ will be reflected in the predictions by the\n-  \/\/ survivor_regions_evac_time prediction.\n-  assert(desired_min_length > base_min_length, \"invariant\");\n-  uint min_young_length = desired_min_length - base_min_length;\n-  assert(desired_max_length > base_min_length, \"invariant\");\n-  uint max_young_length = desired_max_length - base_min_length;\n-\n-  const double target_pause_time_ms = _mmu_tracker->max_gc_time() * 1000.0;\n-  const size_t pending_cards = _analytics->predict_pending_cards();\n-  const double base_time_ms = predict_base_elapsed_time_ms(pending_cards, rs_length);\n-  const uint available_free_regions = _free_regions_at_end_of_collection;\n-  const uint base_free_regions =\n-    available_free_regions > _reserve_regions ? available_free_regions - _reserve_regions : 0;\n+uint G1Policy::calculate_desired_eden_length_before_young_only(double base_time_ms,\n+                                                               uint min_eden_length,\n+                                                               uint max_eden_length) const {\n+  assert(use_adaptive_young_list_length(), \"pre-condition\");\n+\n+  assert(min_eden_length <= max_eden_length, \"must be %u %u\", min_eden_length, max_eden_length);\n@@ -324,2 +417,2 @@\n-                           base_free_regions,\n-                           target_pause_time_ms,\n+                           _free_regions_at_end_of_collection,\n+                           _mmu_tracker->max_gc_time() * 1000.0,\n@@ -327,1 +420,1 @@\n-  if (p.will_fit(min_young_length)) {\n+  if (p.will_fit(min_eden_length)) {\n@@ -332,1 +425,1 @@\n-    if (p.will_fit(max_young_length)) {\n+    if (p.will_fit(max_eden_length)) {\n@@ -336,1 +429,1 @@\n-      min_young_length = max_young_length;\n+      min_eden_length = max_eden_length;\n@@ -353,2 +446,2 @@\n-      assert(min_young_length < max_young_length, \"invariant\");\n-      uint diff = (max_young_length - min_young_length) \/ 2;\n+      assert(min_eden_length < max_eden_length, \"invariant\");\n+      uint diff = (max_eden_length - min_eden_length) \/ 2;\n@@ -356,3 +449,3 @@\n-        uint young_length = min_young_length + diff;\n-        if (p.will_fit(young_length)) {\n-          min_young_length = young_length;\n+        uint eden_length = min_eden_length + diff;\n+        if (p.will_fit(eden_length)) {\n+          min_eden_length = eden_length;\n@@ -360,1 +453,1 @@\n-          max_young_length = young_length;\n+          max_eden_length = eden_length;\n@@ -362,2 +455,2 @@\n-        assert(min_young_length <  max_young_length, \"invariant\");\n-        diff = (max_young_length - min_young_length) \/ 2;\n+        assert(min_eden_length <  max_eden_length, \"invariant\");\n+        diff = (max_eden_length - min_eden_length) \/ 2;\n@@ -369,2 +462,2 @@\n-      assert(min_young_length < max_young_length,\n-             \"otherwise we should have discovered that max_young_length \"\n+      assert(min_eden_length < max_eden_length,\n+             \"otherwise we should have discovered that max_eden_length \"\n@@ -372,2 +465,2 @@\n-      assert(p.will_fit(min_young_length),\n-             \"min_young_length, the result of the binary search, should \"\n+      assert(p.will_fit(min_eden_length),\n+             \"min_eden_length, the result of the binary search, should \"\n@@ -375,2 +468,2 @@\n-      assert(!p.will_fit(min_young_length + 1),\n-             \"min_young_length, the result of the binary search, should be \"\n+      assert(!p.will_fit(min_eden_length + 1),\n+             \"min_eden_length, the result of the binary search, should be \"\n@@ -383,1 +476,21 @@\n-  return base_min_length + min_young_length;\n+  return min_eden_length;\n+}\n+\n+uint G1Policy::calculate_desired_eden_length_before_mixed(double survivor_base_time_ms,\n+                                                          uint min_eden_length,\n+                                                          uint max_eden_length) const {\n+  G1CollectionSetCandidates* candidates = _collection_set->candidates();\n+\n+  uint min_old_regions_end = MIN2(candidates->cur_idx() + calc_min_old_cset_length(candidates),\n+                                  candidates->num_regions());\n+  double predicted_region_evac_time_ms = survivor_base_time_ms;\n+  for (uint i = candidates->cur_idx(); i < min_old_regions_end; i++) {\n+    HeapRegion* r = candidates->at(i);\n+    predicted_region_evac_time_ms += predict_region_total_time_ms(r, false);\n+  }\n+  uint desired_eden_length_by_min_cset_length =\n+     calculate_desired_eden_length_before_young_only(predicted_region_evac_time_ms,\n+                                                     min_eden_length,\n+                                                     max_eden_length);\n+\n+  return desired_eden_length_by_min_cset_length;\n@@ -413,2 +526,1 @@\n-\n-    update_young_list_max_and_target_length(rs_length_prediction);\n+    update_young_length_bounds(rs_length_prediction);\n@@ -459,1 +571,1 @@\n-  update_young_list_max_and_target_length();\n+  update_young_length_bounds();\n@@ -795,5 +907,1 @@\n-    \/\/ IHOP control wants to know the expected young gen length if it were not\n-    \/\/ restrained by the heap reserve. Using the actual length would make the\n-    \/\/ prediction too small and the limit the young gen every time we get to the\n-    \/\/ predicted target occupancy.\n-    size_t last_unrestrained_young_length = update_young_list_max_and_target_length();\n+    update_young_length_bounds();\n@@ -803,1 +911,0 @@\n-                           last_unrestrained_young_length * HeapRegion::GrainBytes,\n@@ -854,1 +961,0 @@\n-                                      size_t young_gen_size,\n@@ -882,0 +988,5 @@\n+    \/\/ IHOP control wants to know the expected young gen length if it were not\n+    \/\/ restrained by the heap reserve. Using the actual length would make the\n+    \/\/ prediction too small and the limit the young gen every time we get to the\n+    \/\/ predicted target occupancy.\n+    size_t young_gen_size = young_list_desired_length() * HeapRegion::GrainBytes;\n@@ -989,1 +1100,1 @@\n-void G1Policy::update_max_gc_locker_expansion() {\n+uint G1Policy::calculate_young_max_length(uint target_young_length) const {\n@@ -997,2 +1108,0 @@\n-  } else {\n-    assert(expansion_region_num == 0, \"sanity\");\n@@ -1000,2 +1109,3 @@\n-  _young_list_max_length = _young_list_target_length + expansion_region_num;\n-  assert(_young_list_target_length <= _young_list_max_length, \"post-condition\");\n+  uint max_length = target_young_length + expansion_region_num;\n+  assert(target_young_length <= max_length, \"overflow\");\n+  return max_length;\n@@ -1255,1 +1365,3 @@\n-    log_debug(gc, ergo)(\"%s (candidate old regions not available)\", no_candidates_str);\n+    if (no_candidates_str != nullptr) {\n+      log_debug(gc, ergo)(\"%s (candidate old regions not available)\", no_candidates_str);\n+    }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":266,"deletions":154,"binary":false,"changes":420,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-                              size_t young_gen_size,\n@@ -80,0 +79,1 @@\n+  uint _young_list_desired_length;\n@@ -81,1 +81,0 @@\n-  uint _young_list_fixed_length;\n@@ -175,0 +174,1 @@\n+\n@@ -196,38 +196,38 @@\n-  \/\/ Updates the internal young list maximum and target lengths. Returns the\n-  \/\/ unbounded young list target length. If no rs_length parameter is passed,\n-  \/\/ predict the RS length using the prediction model, otherwise use the\n-  \/\/ given rs_length as the prediction.\n-  uint update_young_list_max_and_target_length();\n-  uint update_young_list_max_and_target_length(size_t rs_length);\n-\n-  \/\/ Update the young list target length either by setting it to the\n-  \/\/ desired fixed value or by calculating it using G1's pause\n-  \/\/ prediction model.\n-  \/\/ Returns the unbounded young list target length.\n-  uint update_young_list_target_length(size_t rs_length);\n-\n-  \/\/ Calculate and return the minimum desired young list target\n-  \/\/ length. This is the minimum desired young list length according\n-  \/\/ to the user's inputs.\n-  uint calculate_young_list_desired_min_length(uint base_min_length) const;\n-\n-  \/\/ Calculate and return the maximum desired young list target\n-  \/\/ length. This is the maximum desired young list length according\n-  \/\/ to the user's inputs.\n-  uint calculate_young_list_desired_max_length() const;\n-\n-  \/\/ Calculate and return the maximum young list target length that\n-  \/\/ can fit into the pause time goal. The parameters are: rs_length\n-  \/\/ represent the prediction of how large the young RSet lengths will\n-  \/\/ be, base_min_length is the already existing number of regions in\n-  \/\/ the young list, min_length and max_length are the desired min and\n-  \/\/ max young list length according to the user's inputs.\n-  uint calculate_young_list_target_length(size_t rs_length,\n-                                          uint base_min_length,\n-                                          uint desired_min_length,\n-                                          uint desired_max_length) const;\n-\n-  \/\/ Result of the bounded_young_list_target_length() method, containing both the\n-  \/\/ bounded as well as the unbounded young list target lengths in this order.\n-  typedef Pair<uint, uint, StackObj> YoungTargetLengths;\n-  YoungTargetLengths young_list_target_lengths(size_t rs_length) const;\n+  \/\/ Updates the internal young gen maximum and target and desired lengths.\n+  \/\/ If no rs_length parameter is passed, predict the RS length using the\n+  \/\/ prediction model, otherwise use the given rs_length as the prediction.\n+  void update_young_length_bounds();\n+  void update_young_length_bounds(size_t rs_length);\n+\n+  \/\/ Calculate and return the minimum desired eden length based on the MMU target.\n+  uint calculate_desired_eden_length_by_mmu() const;\n+\n+  \/\/ Calculate the desired eden length meeting the pause time goal.\n+  \/\/ The parameters are: rs_length represents the prediction of how large the\n+  \/\/ young RSet lengths will be, min_eden_length and max_eden_length are the bounds\n+  \/\/ (inclusive) within eden can grow.\n+  uint calculate_desired_eden_length_by_pause(double base_time_ms,\n+                                              uint min_eden_length,\n+                                              uint max_eden_length) const;\n+\n+  \/\/ Calculate the desired eden length that can fit into the pause time\n+  \/\/ goal before young only gcs.\n+  uint calculate_desired_eden_length_before_young_only(double base_time_ms,\n+                                                       uint min_eden_length,\n+                                                       uint max_eden_length) const;\n+\n+  \/\/ Calculates the desired eden length before mixed gc so that after adding the\n+  \/\/ minimum amount of old gen regions from the collection set, the eden fits into\n+  \/\/ the pause time goal.\n+  uint calculate_desired_eden_length_before_mixed(double survivor_base_time_ms,\n+                                                  uint min_eden_length,\n+                                                  uint max_eden_length) const;\n+\n+  \/\/ Calculate desired young length based on current situation without taking actually\n+  \/\/ available free regions into account.\n+  uint calculate_young_desired_length(size_t rs_length) const;\n+  \/\/ Limit the given desired young length to available free regions.\n+  uint calculate_young_target_length(uint desired_young_length) const;\n+  \/\/ The GCLocker might cause us to need more regions than the target. Calculate\n+  \/\/ the maximum number of regions to use in that case.\n+  uint calculate_young_max_length(uint target_young_length) const;\n@@ -384,0 +384,1 @@\n+  uint young_list_desired_length() const { return _young_list_desired_length; }\n@@ -444,2 +445,0 @@\n-  void update_max_gc_locker_expansion();\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":41,"deletions":42,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionToSpaceMapper.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-                                  \"marked %zu \"\n@@ -76,1 +75,0 @@\n-                                  r->marked_bytes(),\n@@ -105,1 +103,1 @@\n-bool G1RemSetTrackingPolicy::update_before_rebuild(HeapRegion* r, size_t live_bytes) {\n+bool G1RemSetTrackingPolicy::update_before_rebuild(HeapRegion* r, size_t live_bytes_below_tams) {\n@@ -117,2 +115,2 @@\n-  size_t between_tams_and_top = (r->top() - r->top_at_mark_start()) * HeapWordSize;\n-  size_t total_live_bytes = live_bytes + between_tams_and_top;\n+  size_t live_bytes_above_tams = (r->top() - r->top_at_mark_start()) * HeapWordSize;\n+  size_t total_live_bytes = live_bytes_below_tams + live_bytes_above_tams;\n@@ -134,1 +132,1 @@\n-  print_before_rebuild(r, selected_for_rebuild, total_live_bytes, live_bytes);\n+  print_before_rebuild(r, selected_for_rebuild, total_live_bytes, live_bytes_below_tams);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetTrackingPolicy.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-  bool update_before_rebuild(HeapRegion* r, size_t live_bytes);\n+  bool update_before_rebuild(HeapRegion* r, size_t live_bytes_below_tams);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetTrackingPolicy.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SegmentedArrayFreeMemoryTask.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  virtual uint add(HeapRegion* hr);\n+  uint add(HeapRegion* hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SurvivorRegions.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -248,1 +248,1 @@\n-  bool waited = concurrent_mark()->root_regions()->wait_until_scan_finished();\n+  bool waited = concurrent_mark()->wait_until_root_region_scan_finished();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -398,1 +398,1 @@\n-  size_t _before_used_bytes;   \/\/ Usage in regions successfully evacutate\n+  size_t _before_used_bytes;   \/\/ Usage in regions successfully evacuate\n@@ -441,1 +441,1 @@\n-    size_t used_words = r->marked_bytes() \/ HeapWordSize;\n+    size_t used_words = r->live_bytes() \/ HeapWordSize;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -240,1 +240,0 @@\n-  _marked_bytes(0),\n@@ -274,3 +273,1 @@\n-  \/\/ parsable after the self-forwarding point removal, and update _marked_bytes\n-  \/\/ at the end.\n-  _marked_bytes = 0;\n+  \/\/ parsable after the self-forwarding point removal.\n@@ -294,1 +291,0 @@\n-  _marked_bytes = marked_bytes;\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -142,6 +142,3 @@\n-  \/\/ Return the address of the beginning of the block that contains \"addr\".\n-  \/\/ \"q\" is a block boundary that is <= \"addr\"; \"n\" is the address of the\n-  \/\/ next block (or the end of the HeapRegion.)\n-  inline HeapWord* forward_to_block_containing_addr(HeapWord* q, HeapWord* n,\n-                                                    const void* addr,\n-                                                    HeapWord* pb) const;\n+  inline HeapWord* advance_to_block_containing_addr(const void* addr,\n+                                                    HeapWord* const pb,\n+                                                    HeapWord* first_block) const;\n@@ -249,3 +246,0 @@\n-  \/\/ We use concurrent marking to determine the amount of live data\n-  \/\/ in each heap region.\n-  size_t _marked_bytes;    \/\/ Bytes known to be live via last completed marking.\n@@ -257,1 +251,0 @@\n-    _marked_bytes = 0;\n@@ -342,2 +335,0 @@\n-  \/\/ The number of bytes marked live in the region in the last marking phase.\n-  size_t marked_bytes() const { return _marked_bytes; }\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -85,19 +85,0 @@\n-inline HeapWord* HeapRegion::forward_to_block_containing_addr(HeapWord* q, HeapWord* n,\n-                                                              const void* addr,\n-                                                              HeapWord* pb) const {\n-  while (n <= addr) {\n-    \/\/ When addr is not covered by the block starting at q we need to\n-    \/\/ step forward until we find the correct block. With the BOT\n-    \/\/ being precise, we should never have to step through more than\n-    \/\/ a single card.\n-    assert(!G1BlockOffsetTablePart::is_crossing_card_boundary(n, (HeapWord*)addr), \"must be\");\n-    q = n;\n-    assert(cast_to_oop(q)->klass_or_null() != nullptr,\n-        \"start of block must be an initialized object\");\n-    n += block_size(q, pb);\n-  }\n-  assert(q <= addr, \"wrong order for q and addr\");\n-  assert(addr < n, \"wrong order for addr and n\");\n-  return q;\n-}\n-\n@@ -108,0 +89,17 @@\n+inline HeapWord* HeapRegion::advance_to_block_containing_addr(const void* addr,\n+                                                              HeapWord* const pb,\n+                                                              HeapWord* first_block) const {\n+  HeapWord* cur_block = first_block;\n+  while (true) {\n+    HeapWord* next_block = cur_block + block_size(cur_block, pb);\n+    if (next_block > addr) {\n+      assert(cur_block <= addr, \"postcondition\");\n+      return cur_block;\n+    }\n+    cur_block = next_block;\n+    \/\/ Because the BOT is precise, we should never step into the next card\n+    \/\/ (i.e. crossing the card boundary).\n+    assert(!G1BlockOffsetTablePart::is_crossing_card_boundary(cur_block, (HeapWord*)addr), \"must be\");\n+  }\n+}\n+\n@@ -109,5 +107,2 @@\n-  HeapWord* q = _bot_part.block_start_reaching_into_card(addr);\n-  \/\/ The returned address is the block that reaches into the card of addr. Walk\n-  \/\/ the heap to get to the block reaching into addr.\n-  HeapWord* n = q + block_size(q, pb);\n-  return forward_to_block_containing_addr(q, n, addr, pb);\n+  HeapWord* first_block = _bot_part.block_start_reaching_into_card(addr);\n+  return advance_to_block_containing_addr(addr, pb, first_block);\n@@ -207,1 +202,0 @@\n-  _marked_bytes = used();\n@@ -320,2 +314,1 @@\n-  _marked_bytes = marked_bytes;\n-  _garbage_bytes = byte_size(bottom(), top_at_mark_start()) - _marked_bytes;\n+  _garbage_bytes = byte_size(bottom(), top_at_mark_start()) - marked_bytes;\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":20,"deletions":27,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2059,0 +2059,1 @@\n+    CodeCache::UnloadingScope scope(is_alive_closure());\n@@ -2064,1 +2065,1 @@\n-    CodeCache::do_unloading(is_alive_closure(), purged_class);\n+    CodeCache::do_unloading(purged_class);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -218,0 +218,1 @@\n+    CodeCache::UnloadingScope scope(&is_alive);\n@@ -223,1 +224,1 @@\n-    CodeCache::do_unloading(&is_alive, purged_class);\n+    CodeCache::do_unloading(purged_class);\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/collectedHeap.hpp\"\n@@ -33,0 +34,1 @@\n+#include \"memory\/universe.hpp\"\n@@ -34,1 +36,1 @@\n-#include \"oops\/method.hpp\"\n+#include \"oops\/method.inline.hpp\"\n@@ -41,8 +43,0 @@\n-class LoadPhantomOopClosure : public OopClosure {\n-public:\n-  virtual void do_oop(oop* p) {\n-    NativeAccess<ON_PHANTOM_OOP_REF>::oop_load(p);\n-  }\n-  virtual void do_oop(narrowOop* p) { ShouldNotReachHere(); }\n-};\n-\n@@ -70,0 +64,17 @@\n+  class OopKeepAliveClosure : public OopClosure {\n+  public:\n+    virtual void do_oop(oop* p) {\n+      \/\/ Loads on nmethod oops are phantom strength.\n+      \/\/\n+      \/\/ Note that we could have used NativeAccess<ON_PHANTOM_OOP_REF>::oop_load(p),\n+      \/\/ but that would have *required* us to convert the returned LoadOopProxy to an oop,\n+      \/\/ or else keep alive load barrier will never be called. It's the LoadOopProxy-to-oop\n+      \/\/ conversion that performs the load barriers. This is too subtle, so we instead\n+      \/\/ perform an explicit keep alive call.\n+      oop obj = NativeAccess<ON_PHANTOM_OOP_REF | AS_NO_KEEPALIVE>::oop_load(p);\n+      Universe::heap()->keep_alive(obj);\n+    }\n+\n+    virtual void do_oop(narrowOop* p) { ShouldNotReachHere(); }\n+  };\n+\n@@ -71,3 +82,2 @@\n-  \/\/ SATB GC, then it is important that this code marks them live. This is done\n-  \/\/ by the phantom load.\n-  LoadPhantomOopClosure cl;\n+  \/\/ SATB GC, then it is important that this code marks them live.\n+  OopKeepAliveClosure cl;\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetNMethod.cpp","additions":22,"deletions":12,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -382,38 +382,0 @@\n-void CardTable::dirty(MemRegion mr) {\n-  CardValue* first = byte_for(mr.start());\n-  CardValue* last  = byte_after(mr.last());\n-  memset(first, dirty_card, last-first);\n-}\n-\n-MemRegion CardTable::dirty_card_range_after_reset(MemRegion mr,\n-                                                  bool reset,\n-                                                  int reset_val) {\n-  for (int i = 0; i < _cur_covered_regions; i++) {\n-    MemRegion mri = mr.intersection(_covered[i]);\n-    if (!mri.is_empty()) {\n-      CardValue* cur_entry, *next_entry, *limit;\n-      for (cur_entry = byte_for(mri.start()), limit = byte_for(mri.last());\n-           cur_entry <= limit;\n-           cur_entry  = next_entry) {\n-        next_entry = cur_entry + 1;\n-        if (*cur_entry == dirty_card) {\n-          size_t dirty_cards;\n-          \/\/ Accumulate maximal dirty card range, starting at cur_entry\n-          for (dirty_cards = 1;\n-               next_entry <= limit && *next_entry == dirty_card;\n-               dirty_cards++, next_entry++);\n-          MemRegion cur_cards(addr_for(cur_entry),\n-                              dirty_cards * _card_size_in_words);\n-          if (reset) {\n-            for (size_t i = 0; i < dirty_cards; i++) {\n-              cur_entry[i] = reset_val;\n-            }\n-          }\n-          return cur_cards;\n-        }\n-      }\n-    }\n-  }\n-  return MemRegion(mr.end(), mr.end());\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.cpp","additions":0,"deletions":38,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -176,1 +176,0 @@\n-  void dirty(MemRegion mr);\n@@ -192,1 +191,3 @@\n-    size_t delta = pointer_delta(p, _byte_map_base, sizeof(CardValue));\n+    \/\/ As _byte_map_base may be \"negative\" (the card table has been allocated before\n+    \/\/ the heap in memory), do not use pointer_delta() to avoid the assertion failure.\n+    size_t delta = p - _byte_map_base;\n@@ -221,7 +222,0 @@\n-  \/\/ Return the MemRegion corresponding to the first maximal run\n-  \/\/ of dirty cards lying completely within MemRegion mr.\n-  \/\/ If reset is \"true\", then sets those card table entries to the given\n-  \/\/ value.\n-  MemRegion dirty_card_range_after_reset(MemRegion mr, bool reset,\n-                                         int reset_val);\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.hpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableBarrierSet.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,2 +35,1 @@\n-CodeCacheUnloadingTask::CodeCacheUnloadingTask(uint num_workers, BoolObjectClosure* is_alive, bool unloading_occurred) :\n-  _unloading_scope(is_alive),\n+CodeCacheUnloadingTask::CodeCacheUnloadingTask(uint num_workers, bool unloading_occurred) :\n","filename":"src\/hotspot\/share\/gc\/shared\/parallelCleaning.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-  CodeCache::UnloadingScope _unloading_scope;\n@@ -44,1 +43,1 @@\n-  CodeCacheUnloadingTask(uint num_workers, BoolObjectClosure* is_alive, bool unloading_occurred);\n+  CodeCacheUnloadingTask(uint num_workers, bool unloading_occurred);\n","filename":"src\/hotspot\/share\/gc\/shared\/parallelCleaning.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-#include \"compiler\/compilerDefinitions.hpp\"\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/threadLocalAllocBuffer.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+#include \"code\/codeCache.hpp\"\n@@ -1793,0 +1794,2 @@\n+    ShenandoahIsAliveSelector is_alive;\n+    CodeCache::UnloadingScope scope(is_alive.is_alive_closure());\n@@ -1797,1 +1800,0 @@\n-    ShenandoahIsAliveSelector is_alive;\n@@ -1799,1 +1801,1 @@\n-    ShenandoahClassUnloadingTask unlink_task(phase, is_alive.is_alive_closure(), num_workers, purged_class);\n+    ShenandoahClassUnloadingTask unlink_task(phase, num_workers, purged_class);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"memory\/padded.hpp\"\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPadding.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-                                                           BoolObjectClosure* is_alive,\n@@ -41,1 +40,1 @@\n-  _code_cache_task(num_workers, is_alive, unloading_occurred),\n+  _code_cache_task(num_workers, unloading_occurred),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahParallelCleaning.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-                               BoolObjectClosure* is_alive,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahParallelCleaning.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+#include \"runtime\/arguments.hpp\"\n@@ -114,0 +115,11 @@\n+  if (!HAS_PENDING_EXCEPTION && Arguments::is_dumping_archive()) {\n+    if (_pool->pool_holder()->is_shared()) {\n+      assert(DynamicDumpSharedSpaces, \"must be\");\n+      \/\/ We are linking a shared class from the base archive. This\n+      \/\/ class won't be written into the dynamic archive, so there's no\n+      \/\/ need to save its CpCaches.\n+    } else {\n+      cache->save_for_archive(THREAD);\n+    }\n+  }\n+\n@@ -118,5 +130,0 @@\n-  } else {\n-    DEBUG_ONLY(\n-    if (DumpSharedSpaces) {\n-      cache->verify_just_initialized();\n-    })\n","filename":"src\/hotspot\/share\/interpreter\/rewriter.cpp","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+#include \"runtime\/arguments.hpp\"\n@@ -591,2 +592,2 @@\n-                                &&opc_invokehandle,     &&opc_default,        &&opc_default,\n-\/* 0xEC *\/ &&opc_default,       &&opc_default,          &&opc_default,        &&opc_default,\n+                                &&opc_invokehandle,     &&opc_nofast_getfield,&&opc_nofast_putfield,\n+\/* 0xEC *\/ &&opc_nofast_aload_0,&&opc_nofast_iload,     &&opc_default,        &&opc_default,\n@@ -865,0 +866,7 @@\n+      CASE(_nofast_iload):\n+      {\n+        \/\/ Normal, non-rewritable iload handling.\n+        SET_STACK_SLOT(LOCALS_SLOT(pc[1]), 0);\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(2, 1);\n+      }\n+\n@@ -925,2 +933,3 @@\n-            case Bytecodes::_getfield: {\n-              \/* Otherwise, do nothing here, wait until it gets rewritten to _fast_Xgetfield.\n+            case Bytecodes::_getfield:\n+            case Bytecodes::_nofast_getfield: {\n+              \/* Otherwise, do nothing here, wait until\/if it gets rewritten to _fast_Xgetfield.\n@@ -936,0 +945,9 @@\n+        \/\/ Normal aload_0 handling.\n+        VERIFY_OOP(LOCALS_OBJECT(0));\n+        SET_STACK_OBJECT(LOCALS_OBJECT(0), 0);\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(1, 1);\n+      }\n+\n+      CASE(_nofast_aload_0):\n+      {\n+        \/\/ Normal, non-rewritable aload_0 handling.\n@@ -1704,0 +1722,1 @@\n+      CASE(_nofast_getfield):\n@@ -1714,0 +1733,7 @@\n+          \/\/ Interpreter runtime does not expect \"nofast\" opcodes,\n+          \/\/ prepare the vanilla opcode for it.\n+          Bytecodes::Code code = (Bytecodes::Code)opcode;\n+          if (code == Bytecodes::_nofast_getfield) {\n+            code = Bytecodes::_getfield;\n+          }\n+\n@@ -1715,2 +1741,2 @@\n-          if (!cache->is_resolved((Bytecodes::Code)opcode)) {\n-            CALL_VM(InterpreterRuntime::resolve_from_cache(THREAD, (Bytecodes::Code)opcode),\n+          if (!cache->is_resolved(code)) {\n+            CALL_VM(InterpreterRuntime::resolve_from_cache(THREAD, code),\n@@ -1730,1 +1756,2 @@\n-            if (REWRITE_BYTECODES && !cache->is_volatile()) {\n+            if (REWRITE_BYTECODES && !cache->is_volatile() &&\n+                  ((Bytecodes::Code)opcode != Bytecodes::_nofast_getfield)) {\n@@ -1822,0 +1849,1 @@\n+      CASE(_nofast_putfield):\n@@ -1826,2 +1854,10 @@\n-          if (!cache->is_resolved((Bytecodes::Code)opcode)) {\n-            CALL_VM(InterpreterRuntime::resolve_from_cache(THREAD, (Bytecodes::Code)opcode),\n+\n+          \/\/ Interpreter runtime does not expect \"nofast\" opcodes,\n+          \/\/ prepare the vanilla opcode for it.\n+          Bytecodes::Code code = (Bytecodes::Code)opcode;\n+          if (code == Bytecodes::_nofast_putfield) {\n+            code = Bytecodes::_putfield;\n+          }\n+\n+          if (!cache->is_resolved(code)) {\n+            CALL_VM(InterpreterRuntime::resolve_from_cache(THREAD, code),\n@@ -1852,1 +1888,2 @@\n-            if (REWRITE_BYTECODES && !cache->is_volatile()) {\n+            if (REWRITE_BYTECODES && !cache->is_volatile() &&\n+                  ((Bytecodes::Code)opcode != Bytecodes::_nofast_putfield)) {\n@@ -2418,1 +2455,1 @@\n-              if (REWRITE_BYTECODES) {\n+              if (REWRITE_BYTECODES && !UseSharedSpaces && !Arguments::is_dumping_archive()) {\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":48,"deletions":11,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -434,3 +434,7 @@\n-  ModuleEntry* const jdk_jfr_module = table->lookup_only(jdk_jfr_module_symbol);\n-  if (jdk_jfr_module == NULL) {\n-    return false;\n+  ModuleEntry* jdk_jfr_module;\n+  {\n+    MutexLocker ml(Module_lock);\n+    jdk_jfr_module = table->lookup_only(jdk_jfr_module_symbol);\n+    if (jdk_jfr_module == NULL) {\n+      return false;\n+    }\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrEventClassTransformer.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompiler.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,1 +108,1 @@\n-  \/\/ Support thin wrappers over primitive types.\n+  \/\/ Support thin wrappers over primitive types and other conversions.\n@@ -117,1 +117,14 @@\n-  template<typename T> struct Translate : public std::false_type {};\n+  template<typename T, typename Enable = void>\n+  struct Translate : public std::false_type {};\n+};\n+\n+\/\/ Enum types translate to\/from their underlying type.\n+template<typename T>\n+struct PrimitiveConversions::Translate<T, std::enable_if_t<std::is_enum<T>::value>>\n+  : public std::true_type\n+{\n+  using Value = T;\n+  using Decayed = std::underlying_type_t<T>;\n+\n+  static constexpr Decayed decay(Value x) { return static_cast<Decayed>(x); }\n+  static constexpr Value recover(Decayed x) { return static_cast<Value>(x); }\n","filename":"src\/hotspot\/share\/metaprogramming\/primitiveConversions.hpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -426,0 +426,1 @@\n+    \/\/ cache() is NULL if this class is not yet linked.\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/archiveBuilder.hpp\"\n@@ -29,0 +30,1 @@\n+#include \"classfile\/systemDictionaryShared.hpp\"\n@@ -65,18 +67,0 @@\n-void ConstantPoolCacheEntry::verify_just_initialized(bool f2_used) {\n-  assert((_indices & (~cp_index_mask)) == 0, \"sanity\");\n-  assert(_f1 == NULL, \"sanity\");\n-  assert(_flags == 0, \"sanity\");\n-  if (!f2_used) {\n-    assert(_f2 == 0, \"sanity\");\n-  }\n-}\n-\n-void ConstantPoolCacheEntry::reinitialize(bool f2_used) {\n-  _indices &= cp_index_mask;\n-  _f1 = NULL;\n-  _flags = 0;\n-  if (!f2_used) {\n-    _f2 = 0;\n-  }\n-}\n-\n@@ -703,2 +687,8 @@\n-void ConstantPoolCache::verify_just_initialized() {\n-  DEBUG_ONLY(walk_entries_for_initialization(\/*check_only = *\/ true));\n+void ConstantPoolCache::save_for_archive(TRAPS) {\n+#if INCLUDE_CDS\n+  ClassLoaderData* loader_data = constant_pool()->pool_holder()->class_loader_data();\n+  _initial_entries = MetadataFactory::new_array<ConstantPoolCacheEntry>(loader_data, length(), CHECK);\n+  for (int i = 0; i < length(); i++) {\n+    _initial_entries->at_put(i, *entry_at(i));\n+  }\n+#endif\n@@ -708,4 +698,1 @@\n-  walk_entries_for_initialization(\/*check_only = *\/ false);\n-}\n-\n-void ConstantPoolCache::walk_entries_for_initialization(bool check_only) {\n+#if INCLUDE_CDS\n@@ -713,49 +700,9 @@\n-  \/\/ When dumping the archive, we want to clean up the ConstantPoolCache\n-  \/\/ to remove any effect of linking due to the execution of Java code --\n-  \/\/ each ConstantPoolCacheEntry will have the same contents as if\n-  \/\/ ConstantPoolCache::initialize has just returned:\n-  \/\/\n-  \/\/ - We keep the ConstantPoolCache::constant_pool_index() bits for all entries.\n-  \/\/ - We keep the \"f2\" field for entries used by invokedynamic and invokehandle\n-  \/\/ - All other bits in the entries are cleared to zero.\n-  ResourceMark rm;\n-\n-  InstanceKlass* ik = constant_pool()->pool_holder();\n-  bool* f2_used = NEW_RESOURCE_ARRAY(bool, length());\n-  memset(f2_used, 0, sizeof(bool) * length());\n-\n-  Thread* current = Thread::current();\n-\n-  \/\/ Find all the slots that we need to preserve f2\n-  for (int i = 0; i < ik->methods()->length(); i++) {\n-    Method* m = ik->methods()->at(i);\n-    RawBytecodeStream bcs(methodHandle(current, m));\n-    while (!bcs.is_last_bytecode()) {\n-      Bytecodes::Code opcode = bcs.raw_next();\n-      switch (opcode) {\n-      case Bytecodes::_invokedynamic: {\n-          int index = Bytes::get_native_u4(bcs.bcp() + 1);\n-          int cp_cache_index = constant_pool()->invokedynamic_cp_cache_index(index);\n-          f2_used[cp_cache_index] = 1;\n-        }\n-        break;\n-      case Bytecodes::_invokehandle: {\n-          int cp_cache_index = Bytes::get_native_u2(bcs.bcp() + 1);\n-          f2_used[cp_cache_index] = 1;\n-        }\n-        break;\n-      default:\n-        break;\n-      }\n-    }\n-  }\n-\n-  if (check_only) {\n-    DEBUG_ONLY(\n-      for (int i=0; i<length(); i++) {\n-        entry_at(i)->verify_just_initialized(f2_used[i]);\n-      })\n-  } else {\n-    for (int i=0; i<length(); i++) {\n-      entry_at(i)->reinitialize(f2_used[i]);\n-    }\n+  \/\/ <this> is the copy to be written into the archive. It's in the ArchiveBuilder's \"buffer space\".\n+  \/\/ However, this->_initial_entries was not copied\/relocated by the ArchiveBuilder, so it's\n+  \/\/ still pointing to the array allocated inside save_for_archive().\n+  assert(_initial_entries != NULL, \"archived cpcache must have been initialized\");\n+  assert(!ArchiveBuilder::current()->is_in_buffer_space(_initial_entries), \"must be\");\n+  for (int i=0; i<length(); i++) {\n+    \/\/ Restore each entry to the initial state -- just after Rewriter::make_constant_pool_cache()\n+    \/\/ has finished.\n+    *entry_at(i) = _initial_entries->at(i);\n@@ -763,0 +710,2 @@\n+  _initial_entries = NULL;\n+#endif\n@@ -771,0 +720,7 @@\n+#if INCLUDE_CDS\n+  if (_initial_entries != NULL) {\n+    Arguments::assert_is_dumping_archive();\n+    MetadataFactory::free_array<ConstantPoolCacheEntry>(data, _initial_entries);\n+    _initial_entries = NULL;\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":29,"deletions":73,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -389,3 +389,0 @@\n-\n-  void verify_just_initialized(bool f2_used);\n-  void reinitialize(bool f2_used);\n@@ -407,0 +404,5 @@\n+\n+  \/\/ The narrowOop pointer to the archived resolved_references. Set at CDS dump\n+  \/\/ time when caching java heap object is supported.\n+  CDS_JAVA_HEAP_ONLY(int _archived_references_index;) \/\/ Gap on LP64\n+\n@@ -419,3 +421,1 @@\n-  \/\/ The narrowOop pointer to the archived resolved_references. Set at CDS dump\n-  \/\/ time when caching java heap object is supported.\n-  CDS_JAVA_HEAP_ONLY(int _archived_references_index;)\n+  CDS_ONLY(Array<ConstantPoolCacheEntry>* _initial_entries;)\n@@ -460,1 +460,1 @@\n-  void verify_just_initialized();\n+  void save_for_archive(TRAPS);\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -579,1 +579,0 @@\n-\n@@ -2883,1 +2882,1 @@\n-        _package_entry = loader_data->packages()->lookup(pkg_name, ModuleEntryTable::javabase_moduleEntry());\n+        _package_entry = loader_data->packages()->create_entry_if_absent(pkg_name, ModuleEntryTable::javabase_moduleEntry());\n@@ -2886,2 +2885,1 @@\n-        _package_entry = loader_data->packages()->lookup(pkg_name,\n-                                                         loader_data->unnamed_module());\n+        _package_entry = loader_data->packages()->create_entry_if_absent(pkg_name, loader_data->unnamed_module());\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"classfile\/vmSymbols.hpp\"\n@@ -739,3 +738,2 @@\n-  bool is_continuation_enter_intrinsic() const { return intrinsic_id() == vmIntrinsics::_Continuation_enterSpecial; }\n-\n-  bool is_special_native_intrinsic() const { return is_method_handle_intrinsic() || is_continuation_enter_intrinsic(); }\n+  inline bool is_continuation_enter_intrinsic() const;\n+  inline bool is_special_native_intrinsic() const;\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"classfile\/vmIntrinsics.hpp\"\n@@ -92,0 +93,7 @@\n+inline bool Method::is_continuation_enter_intrinsic() const {\n+  return intrinsic_id() == vmIntrinsics::_Continuation_enterSpecial;\n+}\n+inline bool Method::is_special_native_intrinsic() const {\n+  return is_method_handle_intrinsic() || is_continuation_enter_intrinsic();\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/method.inline.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -300,0 +300,4 @@\n+  static unsigned int compute_hash(const Symbol* const& name) {\n+    return (unsigned int) name->identity_hash();\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/symbol.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -593,2 +593,2 @@\n-  for( j = 1; j < succ->num_preds(); j++)\n-    if( succ->pred(j)->in(0) == bp )\n+  for (j = 1; j < succ->num_preds(); j++) {\n+    if (succ->pred(j)->in(0) == bp) {\n@@ -596,0 +596,2 @@\n+    }\n+  }\n@@ -597,3 +599,3 @@\n-  Block *dead = b->_succs[1-idx];\n-  for( j = 1; j < dead->num_preds(); j++)\n-    if( dead->pred(j)->in(0) == bp )\n+  Block* dead = b->_succs[1 - idx];\n+  for (j = 1; j < dead->num_preds(); j++) {\n+    if (dead->pred(j)->in(0) == bp) {\n@@ -601,0 +603,2 @@\n+    }\n+  }\n@@ -604,1 +608,1 @@\n-  for( int k = 1; dead->get_node(k)->is_Phi(); k++ )\n+  for (int k = 1; dead->get_node(k)->is_Phi(); k++) {\n@@ -606,0 +610,14 @@\n+  }\n+  \/\/ If the fake exit block becomes unreachable, remove it from the block list.\n+  if (dead->num_preds() == 1) {\n+    for (uint i = 0; i < number_of_blocks(); i++) {\n+      Block* block = get_block(i);\n+      if (block == dead) {\n+        _blocks.remove(i);\n+      } else if (block->_pre_order > dead->_pre_order) {\n+        \/\/ Enforce contiguous pre-order indices (assumed by PhaseBlockLayout).\n+        block->_pre_order--;\n+      }\n+    }\n+    _number_of_blocks--;\n+  }\n","filename":"src\/hotspot\/share\/opto\/block.cpp","additions":24,"deletions":6,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1574,1 +1574,0 @@\n-  init_req( ValidLengthTest    , topnode);\n@@ -1601,0 +1600,48 @@\n+\/\/=============================================================================\n+Node* AllocateArrayNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+  if (remove_dead_region(phase, can_reshape))  return this;\n+  \/\/ Don't bother trying to transform a dead node\n+  if (in(0) && in(0)->is_top())  return NULL;\n+\n+  const Type* type = phase->type(Ideal_length());\n+  if (type->isa_int() && type->is_int()->_hi < 0) {\n+    if (can_reshape) {\n+      PhaseIterGVN *igvn = phase->is_IterGVN();\n+      \/\/ Unreachable fall through path (negative array length),\n+      \/\/ the allocation can only throw so disconnect it.\n+      Node* proj = proj_out_or_null(TypeFunc::Control);\n+      Node* catchproj = NULL;\n+      if (proj != NULL) {\n+        for (DUIterator_Fast imax, i = proj->fast_outs(imax); i < imax; i++) {\n+          Node *cn = proj->fast_out(i);\n+          if (cn->is_Catch()) {\n+            catchproj = cn->as_Multi()->proj_out_or_null(CatchProjNode::fall_through_index);\n+            break;\n+          }\n+        }\n+      }\n+      if (catchproj != NULL && catchproj->outcnt() > 0 &&\n+          (catchproj->outcnt() > 1 ||\n+           catchproj->unique_out()->Opcode() != Op_Halt)) {\n+        assert(catchproj->is_CatchProj(), \"must be a CatchProjNode\");\n+        Node* nproj = catchproj->clone();\n+        igvn->register_new_node_with_optimizer(nproj);\n+\n+        Node *frame = new ParmNode( phase->C->start(), TypeFunc::FramePtr );\n+        frame = phase->transform(frame);\n+        \/\/ Halt & Catch Fire\n+        Node* halt = new HaltNode(nproj, frame, \"unexpected negative array length\");\n+        phase->C->root()->add_req(halt);\n+        phase->transform(halt);\n+\n+        igvn->replace_node(catchproj, phase->C->top());\n+        return this;\n+      }\n+    } else {\n+      \/\/ Can't correct it during regular GVN so register for IGVN\n+      phase->C->record_for_igvn(this);\n+    }\n+  }\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":48,"deletions":1,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -879,1 +879,0 @@\n-    ValidLengthTest,\n@@ -889,1 +888,0 @@\n-    fields[ValidLengthTest] = TypeInt::BOOL;\n@@ -984,2 +982,4 @@\n-  AllocateArrayNode(Compile* C, const TypeFunc* atype, Node* ctrl, Node* mem, Node* abio, Node* size, Node* klass_node,\n-                    Node* initial_test, Node* count_val, Node* valid_length_test)\n+  AllocateArrayNode(Compile* C, const TypeFunc *atype, Node *ctrl, Node *mem, Node *abio,\n+                    Node* size, Node* klass_node, Node* initial_test,\n+                    Node* count_val\n+                    )\n@@ -991,1 +991,0 @@\n-    set_req(AllocateNode::ValidLengthTest, valid_length_test);\n@@ -994,0 +993,1 @@\n+  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2732,11 +2732,0 @@\n-      } else if (call->is_AllocateArray()) {\n-        Node* klass_node = call->in(AllocateNode::KlassNode);\n-        Node* length = call->in(AllocateNode::ALength);\n-        const Type* length_type = phase->type(length);\n-        const Type* klass_type = phase->type(klass_node);\n-        Node* valid_length_test = call->in(AllocateNode::ValidLengthTest);\n-        const Type* valid_length_test_t = phase->type(valid_length_test);\n-        if (length_type == Type::TOP || klass_type == Type::TOP || valid_length_test_t == Type::TOP ||\n-            valid_length_test_t->is_int()->is_con(0)) {\n-          f[CatchProjNode::fall_through_index] = Type::TOP;\n-        }\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3992,1 +3992,1 @@\n-          CallNode* call = n->in(0)->in(0)->as_Call();\n+          CallNode *call = n->in(0)->in(0)->as_Call();\n@@ -4001,1 +4001,1 @@\n-            Node* arg0 = call->in(TypeFunc::Parms);\n+            Node *arg0 = call->in(TypeFunc::Parms);\n@@ -4006,3 +4006,4 @@\n-          } else if (call->entry_point() == OptoRuntime::new_array_Java() ||\n-                     call->entry_point() == OptoRuntime::new_array_nozero_Java()) {\n-            \/\/ Check for illegal array length. In such case, the optimizer has\n+          } else if (call->entry_point() == OptoRuntime::new_array_Java() &&\n+                     call->req() > TypeFunc::Parms+1 &&\n+                     call->is_CallStaticJava()) {\n+            \/\/ Check for negative array length. In such case, the optimizer has\n@@ -4011,5 +4012,3 @@\n-            assert(call->is_CallStaticJava(), \"static call expected\");\n-            assert(call->req() == call->jvms()->endoff() + 1, \"missing extra input\");\n-            Node* valid_length_test = call->in(call->req()-1);\n-            call->del_req(call->req()-1);\n-            if (valid_length_test->find_int_con(1) == 0) {\n+            Node *arg1 = call->in(TypeFunc::Parms+1);\n+            if (arg1->is_Type() &&\n+                arg1->as_Type()->type()->join(TypeInt::POS)->empty()) {\n@@ -4018,2 +4017,0 @@\n-            assert(n->outcnt() == required_outcnt, \"malformed control flow\");\n-            continue;\n@@ -4028,8 +4025,0 @@\n-    } else if (n->is_PCTable() && n->in(0) && n->in(0)->in(0) && n->in(0)->in(0)->is_Call()) {\n-      CallNode* call = n->in(0)->in(0)->as_Call();\n-      if (call->entry_point() == OptoRuntime::new_array_Java() ||\n-          call->entry_point() == OptoRuntime::new_array_nozero_Java()) {\n-        assert(call->is_CallStaticJava(), \"static call expected\");\n-        assert(call->req() == call->jvms()->endoff() + 1, \"missing extra input\");\n-        call->del_req(call->req()-1); \/\/ valid length test useless now\n-      }\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":9,"deletions":20,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2604,3 +2604,1 @@\n-  Node* norm = new CatchProjNode(catc, CatchProjNode::fall_through_index, CatchProjNode::no_handler_bci);\n-  _gvn.set_type_bottom(norm);\n-  C->record_for_igvn(norm);\n+  Node* norm = _gvn.transform( new CatchProjNode(catc, CatchProjNode::fall_through_index, CatchProjNode::no_handler_bci) );\n@@ -3857,9 +3855,0 @@\n-  const TypeOopPtr* ary_type = _gvn.type(klass_node)->is_klassptr()->as_instance_type();\n-  Node* valid_length_test = _gvn.intcon(1);\n-  if (ary_type->isa_aryptr()) {\n-    BasicType bt = ary_type->isa_aryptr()->elem()->array_element_basic_type();\n-    jint max = TypeAryPtr::max_array_length(bt);\n-    Node* valid_length_cmp  = _gvn.transform(new CmpUNode(length, intcon(max)));\n-    valid_length_test = _gvn.transform(new BoolNode(valid_length_cmp, BoolTest::le));\n-  }\n-\n@@ -3872,1 +3861,1 @@\n-                            length, valid_length_test);\n+                            length);\n@@ -3879,0 +3868,1 @@\n+  const TypeOopPtr* ary_type = _gvn.type(klass_node)->is_klassptr()->as_instance_type();\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -138,0 +138,8 @@\n+#if defined(AARCH64)\n+  PRegister as_PRegister(PhaseRegAlloc* ra_, const Node* node) const {\n+    return ::as_PRegister(reg(ra_, node));\n+  }\n+  PRegister as_PRegister(PhaseRegAlloc* ra_, const Node* node, int idx) const {\n+    return ::as_PRegister(reg(ra_, node, idx));\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1195,2 +1195,1 @@\n-            address slow_call_address,  \/\/ Address of slow call\n-            Node* valid_length_test \/\/ whether length is valid or not\n+            address slow_call_address  \/\/ Address of slow call\n@@ -1381,6 +1380,0 @@\n-  \/\/ For array allocations, copy the valid length check to the call node so Compile::final_graph_reshaping() can verify\n-  \/\/ that the call has the expected number of CatchProj nodes (in case the allocation always fails and the fallthrough\n-  \/\/ path dies).\n-  if (valid_length_test != NULL) {\n-    call->add_req(valid_length_test);\n-  }\n@@ -1873,1 +1866,1 @@\n-                         OptoRuntime::new_instance_Java(), NULL);\n+                         OptoRuntime::new_instance_Java());\n@@ -1878,1 +1871,0 @@\n-  Node* valid_length_test = alloc->in(AllocateNode::ValidLengthTest);\n@@ -1893,1 +1885,1 @@\n-                         slow_call_address, valid_length_test);\n+                         slow_call_address);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -94,2 +94,2 @@\n-                              address slow_call_address,\n-                              Node* valid_length_test);\n+                              address slow_call_address);\n+  void yank_initalize_node(InitializeNode* node);\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1756,1 +1756,5 @@\n-\/\/------------------------------analyze----------------------------------------\n+\/\/ In this analysis, all types are initially set to TOP. We iteratively call Value() on all nodes of the graph until\n+\/\/ we reach a fixed-point (i.e. no types change anymore). We start with a list that only contains the root node. Each time\n+\/\/ a new type is set, we push all uses of that node back to the worklist (in some cases, we also push grandchildren\n+\/\/ or nodes even further down back to the worklist because their type could change as a result of the current type\n+\/\/ change).\n@@ -1759,2 +1763,2 @@\n-  for (int i = C->unique() - 1; i >= 0; i--)  {\n-    _types.map(i,Type::TOP);\n+  for (uint i = 0; i < C->unique(); i++)  {\n+    _types.map(i, Type::TOP);\n@@ -1769,6 +1773,8 @@\n-  while( worklist.size() ) {\n-    Node* n; \/\/ Node to be examined in this iteration\n-    if (StressCCP) {\n-      n = worklist.remove(C->random() % worklist.size());\n-    } else {\n-      n = worklist.pop();\n+  while (worklist.size() != 0) {\n+    Node* n = fetch_next_node(worklist);\n+    const Type* new_type = n->Value(this);\n+    if (new_type != type(n)) {\n+      assert(ccp_type_widens(new_type, type(n)), \"ccp type must widen\");\n+      dump_type_and_node(n, new_type);\n+      set_type(n, new_type);\n+      push_child_nodes_to_worklist(worklist, n);\n@@ -1776,3 +1782,12 @@\n-    const Type *t = n->Value(this);\n-    if (t != type(n)) {\n-      assert(ccp_type_widens(t, type(n)), \"ccp type must widen\");\n+  }\n+}\n+\n+\/\/ Fetch next node from worklist to be examined in this iteration.\n+Node* PhaseCCP::fetch_next_node(Unique_Node_List& worklist) {\n+  if (StressCCP) {\n+    return worklist.remove(C->random() % worklist.size());\n+  } else {\n+    return worklist.pop();\n+  }\n+}\n+\n@@ -1780,5 +1795,9 @@\n-      if( TracePhaseCCP ) {\n-        t->dump();\n-        do { tty->print(\"\\t\"); } while (tty->position() < 16);\n-        n->dump();\n-      }\n+void PhaseCCP::dump_type_and_node(const Node* n, const Type* t) {\n+  if (TracePhaseCCP) {\n+    t->dump();\n+    do {\n+      tty->print(\"\\t\");\n+    } while (tty->position() < 16);\n+    n->dump();\n+  }\n+}\n@@ -1786,29 +1805,0 @@\n-      set_type(n, t);\n-      for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n-        Node* m = n->fast_out(i);   \/\/ Get user\n-        if (m->is_Region()) {  \/\/ New path to Region?  Must recheck Phis too\n-          for (DUIterator_Fast i2max, i2 = m->fast_outs(i2max); i2 < i2max; i2++) {\n-            Node* p = m->fast_out(i2); \/\/ Propagate changes to uses\n-            if (p->bottom_type() != type(p)) { \/\/ If not already bottomed out\n-              worklist.push(p); \/\/ Propagate change to user\n-            }\n-          }\n-        }\n-        \/\/ If we changed the receiver type to a call, we need to revisit\n-        \/\/ the Catch following the call.  It's looking for a non-NULL\n-        \/\/ receiver to know when to enable the regular fall-through path\n-        \/\/ in addition to the NullPtrException path\n-        if (m->is_Call()) {\n-          for (DUIterator_Fast i2max, i2 = m->fast_outs(i2max); i2 < i2max; i2++) {\n-            Node* p = m->fast_out(i2);  \/\/ Propagate changes to uses\n-            if (p->is_Proj() && p->as_Proj()->_con == TypeFunc::Control) {\n-              Node* catch_node = p->find_out_with(Op_Catch);\n-              if (catch_node != NULL) {\n-                worklist.push(catch_node);\n-              }\n-            }\n-          }\n-        }\n-        if (m->bottom_type() != type(m)) { \/\/ If not already bottomed out\n-          worklist.push(m);     \/\/ Propagate change to user\n-        }\n@@ -1816,24 +1806,48 @@\n-        \/\/ CmpU nodes can get their type information from two nodes up in the\n-        \/\/ graph (instead of from the nodes immediately above). Make sure they\n-        \/\/ are added to the worklist if nodes they depend on are updated, since\n-        \/\/ they could be missed and get wrong types otherwise.\n-        uint m_op = m->Opcode();\n-        if (m_op == Op_AddI || m_op == Op_SubI) {\n-          for (DUIterator_Fast i2max, i2 = m->fast_outs(i2max); i2 < i2max; i2++) {\n-            Node* p = m->fast_out(i2); \/\/ Propagate changes to uses\n-            if (p->Opcode() == Op_CmpU) {\n-              \/\/ Got a CmpU which might need the new type information from node n.\n-              if(p->bottom_type() != type(p)) { \/\/ If not already bottomed out\n-                worklist.push(p); \/\/ Propagate change to user\n-              }\n-            }\n-          }\n-        }\n-        \/\/ If n is used in a counted loop exit condition then the type\n-        \/\/ of the counted loop's Phi depends on the type of n. See\n-        \/\/ PhiNode::Value().\n-        if (m_op == Op_CmpI || m_op == Op_CmpL) {\n-          PhiNode* phi = countedloop_phi_from_cmp(m->as_Cmp(), n);\n-          if (phi != NULL) {\n-            worklist.push(phi);\n-          }\n+\/\/ We need to propagate the type change of 'n' to all its uses. Depending on the kind of node, additional nodes\n+\/\/ (grandchildren or even further down) need to be revisited as their types could also be improved as a result\n+\/\/ of the new type of 'n'. Push these nodes to the worklist.\n+void PhaseCCP::push_child_nodes_to_worklist(Unique_Node_List& worklist, Node* n) const {\n+  for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+    Node* use = n->fast_out(i);\n+    push_if_not_bottom_type(worklist, use);\n+    push_more_uses(worklist, n, use);\n+  }\n+}\n+\n+void PhaseCCP::push_if_not_bottom_type(Unique_Node_List& worklist, Node* n) const {\n+  if (n->bottom_type() != type(n)) {\n+    worklist.push(n);\n+  }\n+}\n+\n+\/\/ For some nodes, we need to propagate the type change to grandchildren or even further down.\n+\/\/ Add them back to the worklist.\n+void PhaseCCP::push_more_uses(Unique_Node_List& worklist, Node* parent, const Node* use) const {\n+  push_phis(worklist, use);\n+  push_catch(worklist, use);\n+  push_cmpu(worklist, use);\n+  push_counted_loop_phi(worklist, parent, use);\n+  push_loadp(worklist, use);\n+  push_and(worklist, parent, use);\n+}\n+\n+\n+\/\/ We must recheck Phis too if use is a Region.\n+void PhaseCCP::push_phis(Unique_Node_List& worklist, const Node* use) const {\n+  if (use->is_Region()) {\n+    for (DUIterator_Fast imax, i = use->fast_outs(imax); i < imax; i++) {\n+      push_if_not_bottom_type(worklist, use->fast_out(i));\n+    }\n+  }\n+}\n+\n+\/\/ If we changed the receiver type to a call, we need to revisit the Catch node following the call. It's looking for a\n+\/\/ non-NULL receiver to know when to enable the regular fall-through path in addition to the NullPtrException path.\n+void PhaseCCP::push_catch(Unique_Node_List& worklist, const Node* use) {\n+  if (use->is_Call()) {\n+    for (DUIterator_Fast imax, i = use->fast_outs(imax); i < imax; i++) {\n+      Node* proj = use->fast_out(i);\n+      if (proj->is_Proj() && proj->as_Proj()->_con == TypeFunc::Control) {\n+        Node* catch_node = proj->find_out_with(Op_Catch);\n+        if (catch_node != NULL) {\n+          worklist.push(catch_node);\n@@ -1841,22 +1855,47 @@\n-        \/\/ Loading the java mirror from a Klass requires two loads and the type\n-        \/\/ of the mirror load depends on the type of 'n'. See LoadNode::Value().\n-        BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n-        bool has_load_barrier_nodes = bs->has_load_barrier_nodes();\n-\n-        if (m_op == Op_LoadP && m->bottom_type()->isa_rawptr()) {\n-          for (DUIterator_Fast i2max, i2 = m->fast_outs(i2max); i2 < i2max; i2++) {\n-            Node* u = m->fast_out(i2);\n-            const Type* ut = u->bottom_type();\n-            if (u->Opcode() == Op_LoadP && ut->isa_instptr() && ut != type(u)) {\n-              if (has_load_barrier_nodes) {\n-                \/\/ Search for load barriers behind the load\n-                for (DUIterator_Fast i3max, i3 = u->fast_outs(i3max); i3 < i3max; i3++) {\n-                  Node* b = u->fast_out(i3);\n-                  if (bs->is_gc_barrier_node(b)) {\n-                    worklist.push(b);\n-                  }\n-                }\n-              }\n-              worklist.push(u);\n-            }\n-          }\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ CmpU nodes can get their type information from two nodes up in the graph (instead of from the nodes immediately\n+\/\/ above). Make sure they are added to the worklist if nodes they depend on are updated since they could be missed\n+\/\/ and get wrong types otherwise.\n+void PhaseCCP::push_cmpu(Unique_Node_List& worklist, const Node* use) const {\n+  uint use_op = use->Opcode();\n+  if (use_op == Op_AddI || use_op == Op_SubI) {\n+    for (DUIterator_Fast imax, i = use->fast_outs(imax); i < imax; i++) {\n+      Node* cmpu = use->fast_out(i);\n+      if (cmpu->Opcode() == Op_CmpU) {\n+        \/\/ Got a CmpU which might need the new type information from node n.\n+        push_if_not_bottom_type(worklist, cmpu);\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ If n is used in a counted loop exit condition, then the type of the counted loop's Phi depends on the type of 'n'.\n+\/\/ Seem PhiNode::Value().\n+void PhaseCCP::push_counted_loop_phi(Unique_Node_List& worklist, Node* parent, const Node* use) {\n+  uint use_op = use->Opcode();\n+  if (use_op == Op_CmpI || use_op == Op_CmpL) {\n+    PhiNode* phi = countedloop_phi_from_cmp(use->as_Cmp(), parent);\n+    if (phi != NULL) {\n+      worklist.push(phi);\n+    }\n+  }\n+}\n+\n+\/\/ Loading the java mirror from a Klass requires two loads and the type of the mirror load depends on the type of 'n'.\n+\/\/ See LoadNode::Value().\n+void PhaseCCP::push_loadp(Unique_Node_List& worklist, const Node* use) const {\n+  BarrierSetC2* barrier_set = BarrierSet::barrier_set()->barrier_set_c2();\n+  bool has_load_barrier_nodes = barrier_set->has_load_barrier_nodes();\n+\n+  if (use->Opcode() == Op_LoadP && use->bottom_type()->isa_rawptr()) {\n+    for (DUIterator_Fast imax, i = use->fast_outs(imax); i < imax; i++) {\n+      Node* loadp = use->fast_out(i);\n+      const Type* ut = loadp->bottom_type();\n+      if (loadp->Opcode() == Op_LoadP && ut->isa_instptr() && ut != type(loadp)) {\n+        if (has_load_barrier_nodes) {\n+          \/\/ Search for load barriers behind the load\n+          push_load_barrier(worklist, barrier_set, loadp);\n@@ -1864,1 +1903,1 @@\n-        push_and(worklist, n, m);\n+        worklist.push(loadp);\n@@ -1870,0 +1909,9 @@\n+void PhaseCCP::push_load_barrier(Unique_Node_List& worklist, const BarrierSetC2* barrier_set, const Node* use) {\n+  for (DUIterator_Fast imax, i = use->fast_outs(imax); i < imax; i++) {\n+    Node* barrier_node = use->fast_out(i);\n+    if (barrier_set->is_gc_barrier_node(barrier_node)) {\n+      worklist.push(barrier_node);\n+    }\n+  }\n+}\n+\n@@ -1879,3 +1927,2 @@\n-      if ((and_node_op == Op_AndI || and_node_op == Op_AndL)\n-          && and_node->bottom_type() != type(and_node)) {\n-        worklist.push(and_node);\n+      if (and_node_op == Op_AndI || and_node_op == Op_AndL) {\n+        push_if_not_bottom_type(worklist, and_node);\n@@ -1887,0 +1934,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":144,"deletions":96,"binary":false,"changes":240,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+class BarrierSetC2;\n@@ -569,2 +570,14 @@\n-  virtual Node *transform_once( Node *n );\n-\n+  virtual Node* transform_once(Node* n);\n+\n+  Node* fetch_next_node(Unique_Node_List& worklist);\n+  static void dump_type_and_node(const Node* n, const Type* t) PRODUCT_RETURN;\n+\n+  void push_child_nodes_to_worklist(Unique_Node_List& worklist, Node* n) const;\n+  void push_if_not_bottom_type(Unique_Node_List& worklist, Node* n) const;\n+  void push_more_uses(Unique_Node_List& worklist, Node* parent, const Node* use) const;\n+  void push_phis(Unique_Node_List& worklist, const Node* use) const;\n+  static void push_catch(Unique_Node_List& worklist, const Node* use);\n+  void push_cmpu(Unique_Node_List& worklist, const Node* use) const;\n+  static void push_counted_loop_phi(Unique_Node_List& worklist, Node* parent, const Node* use);\n+  void push_loadp(Unique_Node_List& worklist, const Node* use) const;\n+  static void push_load_barrier(Unique_Node_List& worklist, const BarrierSetC2* barrier_set, const Node* use);\n@@ -573,1 +586,1 @@\n-public:\n+ public:\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-         SlotsPerVecA = RISCV_ONLY(4) NOT_RISCV(8),\n+         SlotsPerVecA = 4,\n","filename":"src\/hotspot\/share\/opto\/regmask.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -131,2 +131,2 @@\n-              assert(use->is_If() || use->is_CMove() || use->Opcode() == Op_Opaque1 || use->is_AllocateArray(), \"unexpected node type\");\n-              Node *use_c = (use->is_If() || use->is_AllocateArray()) ? use->in(0) : get_ctrl(use);\n+              assert(use->is_If() || use->is_CMove() || use->Opcode() == Op_Opaque1, \"unexpected node type\");\n+              Node *use_c = use->is_If() ? use->in(0) : get_ctrl(use);\n@@ -169,3 +169,2 @@\n-                assert(u->is_If() || u->is_CMove() || u->Opcode() == Op_Opaque1 || u->is_AllocateArray(), \"unexpected node type\");\n-                assert(u->is_AllocateArray() || u->in(1) == bol, \"\");\n-                assert(!u->is_AllocateArray() || u->in(AllocateNode::ValidLengthTest) == bol, \"wrong input to AllocateArray\");\n+                assert(u->is_If() || u->is_CMove() || u->Opcode() == Op_Opaque1, \"unexpected node type\");\n+                assert(u->in(1) == bol, \"\");\n@@ -173,1 +172,1 @@\n-                Node *u_ctrl = (u->is_If() || u->is_AllocateArray()) ? u->in(0) : get_ctrl(u);\n+                Node *u_ctrl = u->is_If() ? u->in(0) : get_ctrl(u);\n@@ -177,1 +176,1 @@\n-                _igvn.replace_input_of(u, u->is_AllocateArray() ? AllocateNode::ValidLengthTest : 1, x);\n+                _igvn.replace_input_of(u, 1, x);\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -264,2 +264,4 @@\n-        \/\/ This region should lose its Phis and be optimized out by igvn but there's a chance the if folds to top first\n-        \/\/ which then causes a reachable part of the graph to become dead.\n+        \/\/ This region should lose its Phis. They are removed either in PhaseRemoveUseless (for data phis) or in IGVN\n+        \/\/ (for memory phis). During IGVN, there is a chance that the If folds to top before the Region is processed\n+        \/\/ which then causes a reachable part of the graph to become dead. To prevent this, set the boolean input of\n+        \/\/ the If to a constant to nicely let the diamond Region\/If fold away.\n@@ -267,1 +269,1 @@\n-        C->gvn_replace_by(n, iff->in(0));\n+        C->gvn_replace_by(iff->in(1), _stringopts->gvn()->intcon(0));\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -283,3 +283,0 @@\n-  bool is_ptr_to_boxing_obj() const;\n-\n-\n@@ -2038,6 +2035,0 @@\n-inline bool Type::is_ptr_to_boxing_obj() const {\n-  const TypeInstPtr* tp = isa_instptr();\n-  return (tp != NULL) && (tp->offset() == 0) &&\n-         tp->instance_klass()->is_box_klass();\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -3659,1 +3660,0 @@\n-#ifndef PRODUCT\n@@ -3661,1 +3661,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-\n@@ -52,0 +51,1 @@\n+class ThreadsList;\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1498,1 +1498,1 @@\n-      marked = deps.remove_all_dependents();\n+      marked = deps.remove_and_mark_for_deoptimization_all_dependents();\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"oops\/method.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/stackwalk.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -604,1 +604,0 @@\n-      size_t prev_live = r->marked_bytes();\n@@ -612,3 +611,3 @@\n-        \/\/ we don't include non-full regions since they are unlikely included in mixed gc\n-        \/\/ for testing purposes it's enough to have lowest estimation of total memory that is expected to be freed\n-          _total_memory_to_free += size - prev_live;\n+          \/\/ We don't include non-full regions since they are unlikely included in mixed gc\n+          \/\/ for testing purposes it's enough to have lowest estimation of total memory that is expected to be freed\n+          _total_memory_to_free += size - live;\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -3874,0 +3875,2 @@\n+#ifndef PRODUCT\n+  \/\/ UseDebuggerErgo is notproduct\n@@ -3877,0 +3880,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -383,1 +383,1 @@\n-\/\/ Handle load for pointer, integral and enum types.\n+\/\/ Handle load for pointer and integral types.\n@@ -388,1 +388,1 @@\n-  typename EnableIf<IsIntegral<T>::value || std::is_enum<T>::value || IsPointer<T>::value>::type>\n+  typename EnableIf<IsIntegral<T>::value || IsPointer<T>::value>::type>\n@@ -433,1 +433,1 @@\n-\/\/ Handle store for integral and enum types.\n+\/\/ Handle store for integral types.\n@@ -440,1 +440,1 @@\n-  typename EnableIf<IsIntegral<T>::value || std::is_enum<T>::value>::type>\n+  typename EnableIf<IsIntegral<T>::value>::type>\n@@ -736,1 +736,1 @@\n-\/\/ Handle cmpxchg for integral and enum types.\n+\/\/ Handle cmpxchg for integral types.\n@@ -742,1 +742,1 @@\n-  typename EnableIf<IsIntegral<T>::value || std::is_enum<T>::value>::type>\n+  typename EnableIf<IsIntegral<T>::value>::type>\n@@ -871,1 +871,1 @@\n-\/\/ Handle xchg for integral and enum types.\n+\/\/ Handle xchg for integral types.\n@@ -877,1 +877,1 @@\n-  typename EnableIf<IsIntegral<T>::value || std::is_enum<T>::value>::type>\n+  typename EnableIf<IsIntegral<T>::value>::type>\n","filename":"src\/hotspot\/share\/runtime\/atomic.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -27,0 +28,1 @@\n+#include \"oops\/method.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"oops\/method.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"oops\/method.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"compiler\/compilerDefinitions.hpp\"\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsCompiler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-#include \"oops\/method.hpp\"\n+#include \"oops\/method.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-     void task() { os::run_periodic_checks(); }\n+     void task() { os::run_periodic_checks(tty); }\n","filename":"src\/hotspot\/share\/runtime\/jniPeriodicChecker.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,4 @@\n-#include \"runtime\/synchronizer.hpp\"\n+#include \"memory\/allocation.hpp\"\n+\n+class BasicObjectLock;\n+class OopClosure;\n","filename":"src\/hotspot\/share\/runtime\/monitorChunk.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/monitorDeflationThread.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/osInfo.hpp\"\n@@ -259,1 +260,1 @@\n-  static void   run_periodic_checks();\n+  static void   run_periodic_checks(outputStream* st);\n@@ -374,1 +375,1 @@\n-  static int    vm_page_size();\n+  static int vm_page_size() { return OSInfo::vm_page_size(); }\n@@ -415,1 +416,2 @@\n-  static int    vm_allocation_granularity();\n+  static int vm_allocation_granularity() { return OSInfo::vm_allocation_granularity(); }\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/osInfo.hpp\"\n+\n+int OSInfo::_vm_page_size = -1;\n+int OSInfo::_vm_allocation_granularity = -1;\n+\n","filename":"src\/hotspot\/share\/runtime\/osInfo.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_OSINFO_HPP\n+#define SHARE_RUNTIME_OSINFO_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/debug.hpp\"\n+\n+\/\/ Static information about the operating system. Initialized exactly once\n+\/\/ at VM start-up and never changes again.\n+class OSInfo : AllStatic {\n+  static int    _vm_page_size;\n+  static int    _vm_allocation_granularity;\n+\n+public:\n+  \/\/ Returns the byte size of a virtual memory page\n+  static int vm_page_size() { return _vm_page_size; }\n+\n+  \/\/ Returns the size, in bytes, of the granularity with which memory can be reserved using os::reserve_memory().\n+  static int vm_allocation_granularity() { return _vm_allocation_granularity; }\n+\n+  static void set_vm_page_size(int n) {\n+    assert(_vm_page_size < 0, \"init only once\");\n+    assert(n > 0, \"sanity\");\n+    _vm_page_size = n;\n+  }\n+\n+  static void set_vm_allocation_granularity(int n) {\n+    assert(_vm_allocation_granularity < 0, \"init only once\");\n+    assert(n > 0, \"sanity\");\n+    _vm_allocation_granularity = n;\n+  }\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_OSINFO_HPP\n","filename":"src\/hotspot\/share\/runtime\/osInfo.hpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/os.hpp\"\n+#include \"runtime\/osInfo.hpp\"\n@@ -66,1 +66,1 @@\n-  static bool    is_poll_address(address addr)  { return addr >= _polling_page && addr < (_polling_page + os::vm_page_size()); }\n+  static bool    is_poll_address(address addr)  { return addr >= _polling_page && addr < (_polling_page + OSInfo::vm_page_size()); }\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-#include \"utilities\/hashtable.inline.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n@@ -2393,0 +2393,6 @@\n+#ifndef PRODUCT\n+static int _lookups; \/\/ number of calls to lookup\n+static int _equals;  \/\/ number of buckets checked with matching hash\n+static int _hits;    \/\/ number of successful lookups\n+static int _compact; \/\/ number of equals calls with compact signature\n+#endif\n@@ -2579,8 +2585,0 @@\n-};\n-\n-\n-\/\/ A hashtable mapping from AdapterFingerPrints to AdapterHandlerEntries\n-class AdapterHandlerTable : public BasicHashtable<mtCode> {\n-  friend class AdapterHandlerTableIterator;\n-\n- private:\n@@ -2588,10 +2586,3 @@\n-#ifndef PRODUCT\n-  static int _lookups; \/\/ number of calls to lookup\n-  static int _buckets; \/\/ number of buckets checked\n-  static int _equals;  \/\/ number of buckets checked with matching hash\n-  static int _hits;    \/\/ number of successful lookups\n-  static int _compact; \/\/ number of equals calls with compact signature\n-#endif\n-\n-  AdapterHandlerEntry* bucket(int i) {\n-    return (AdapterHandlerEntry*)BasicHashtable<mtCode>::bucket(i);\n+  static bool equals(AdapterFingerPrint* const& fp1, AdapterFingerPrint* const& fp2) {\n+    NOT_PRODUCT(_equals++);\n+    return fp1->equals(fp2);\n@@ -2600,9 +2591,2 @@\n- public:\n-  AdapterHandlerTable()\n-    : BasicHashtable<mtCode>(293, (sizeof(AdapterHandlerEntry))) { }\n-\n-  \/\/ Create a new entry suitable for insertion in the table\n-  AdapterHandlerEntry* new_entry(AdapterFingerPrint* fingerprint, address i2c_entry, address c2i_entry, address c2i_unverified_entry, address c2i_no_clinit_check_entry) {\n-    AdapterHandlerEntry* entry = (AdapterHandlerEntry*)BasicHashtable<mtCode>::new_entry(fingerprint->compute_hash());\n-    entry->init(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);\n-    return entry;\n+  static unsigned int compute_hash(AdapterFingerPrint* const& fp) {\n+    return fp->compute_hash();\n@@ -2610,0 +2594,1 @@\n+};\n@@ -2611,22 +2596,13 @@\n-  \/\/ Insert an entry into the table\n-  void add(AdapterHandlerEntry* entry) {\n-    int index = hash_to_index(entry->hash());\n-    add_entry(index, entry);\n-  }\n-\n-  void free_entry(AdapterHandlerEntry* entry) {\n-    entry->deallocate();\n-    BasicHashtable<mtCode>::free_entry(entry);\n-  }\n-\n-  \/\/ Find a entry with the same fingerprint if it exists\n-  AdapterHandlerEntry* lookup(int total_args_passed, BasicType* sig_bt) {\n-    NOT_PRODUCT(_lookups++);\n-    AdapterFingerPrint fp(total_args_passed, sig_bt);\n-    unsigned int hash = fp.compute_hash();\n-    int index = hash_to_index(hash);\n-    for (AdapterHandlerEntry* e = bucket(index); e != NULL; e = e->next()) {\n-      NOT_PRODUCT(_buckets++);\n-      if (e->hash() == hash) {\n-        NOT_PRODUCT(_equals++);\n-        if (fp.equals(e->fingerprint())) {\n+\/\/ A hashtable mapping from AdapterFingerPrints to AdapterHandlerEntries\n+ResourceHashtable<AdapterFingerPrint*, AdapterHandlerEntry*, 293,\n+                  ResourceObj::C_HEAP, mtCode,\n+                  AdapterFingerPrint::compute_hash,\n+                  AdapterFingerPrint::equals> _adapter_handler_table;\n+\n+\/\/ Find a entry with the same fingerprint if it exists\n+static AdapterHandlerEntry* lookup(int total_args_passed, BasicType* sig_bt) {\n+  NOT_PRODUCT(_lookups++);\n+  assert_lock_strong(AdapterHandlerLibrary_lock);\n+  AdapterFingerPrint fp(total_args_passed, sig_bt);\n+  AdapterHandlerEntry** entry = _adapter_handler_table.get(&fp);\n+  if (entry != nullptr) {\n@@ -2634,2 +2610,2 @@\n-          if (fp.is_compact()) _compact++;\n-          _hits++;\n+    if (fp.is_compact()) _compact++;\n+    _hits++;\n@@ -2637,5 +2613,1 @@\n-          return e;\n-        }\n-      }\n-    }\n-    return NULL;\n+    return *entry;\n@@ -2643,0 +2615,2 @@\n+  return nullptr;\n+}\n@@ -2645,33 +2619,11 @@\n-  void print_statistics() {\n-    ResourceMark rm;\n-    int longest = 0;\n-    int empty = 0;\n-    int total = 0;\n-    int nonempty = 0;\n-    for (int index = 0; index < table_size(); index++) {\n-      int count = 0;\n-      for (AdapterHandlerEntry* e = bucket(index); e != NULL; e = e->next()) {\n-        count++;\n-      }\n-      if (count != 0) nonempty++;\n-      if (count == 0) empty++;\n-      if (count > longest) longest = count;\n-      total += count;\n-    }\n-    tty->print_cr(\"AdapterHandlerTable: empty %d longest %d total %d average %f\",\n-                  empty, longest, total, total \/ (double)nonempty);\n-    tty->print_cr(\"AdapterHandlerTable: lookups %d buckets %d equals %d hits %d compact %d\",\n-                  _lookups, _buckets, _equals, _hits, _compact);\n-  }\n-#endif\n-};\n-\n-\n-#ifndef PRODUCT\n-\n-int AdapterHandlerTable::_lookups;\n-int AdapterHandlerTable::_buckets;\n-int AdapterHandlerTable::_equals;\n-int AdapterHandlerTable::_hits;\n-int AdapterHandlerTable::_compact;\n-\n+static void print_table_statistics() {\n+  auto size = [&] (AdapterFingerPrint* key, AdapterHandlerEntry* a) {\n+    return sizeof(*key) + sizeof(*a);\n+  };\n+  TableStatistics ts = _adapter_handler_table.statistics_calculate(size);\n+  ts.print(tty, \"AdapterHandlerTable\");\n+  tty->print_cr(\"AdapterHandlerTable (table_size=%d, entries=%d)\",\n+                _adapter_handler_table.table_size(), _adapter_handler_table.number_of_entries());\n+  tty->print_cr(\"AdapterHandlerTable: lookups %d equals %d hits %d compact %d\",\n+                _lookups, _equals, _hits, _compact);\n+}\n@@ -2680,37 +2632,0 @@\n-class AdapterHandlerTableIterator : public StackObj {\n- private:\n-  AdapterHandlerTable* _table;\n-  int _index;\n-  AdapterHandlerEntry* _current;\n-\n-  void scan() {\n-    while (_index < _table->table_size()) {\n-      AdapterHandlerEntry* a = _table->bucket(_index);\n-      _index++;\n-      if (a != NULL) {\n-        _current = a;\n-        return;\n-      }\n-    }\n-  }\n-\n- public:\n-  AdapterHandlerTableIterator(AdapterHandlerTable* table): _table(table), _index(0), _current(NULL) {\n-    scan();\n-  }\n-  bool has_next() {\n-    return _current != NULL;\n-  }\n-  AdapterHandlerEntry* next() {\n-    if (_current != NULL) {\n-      AdapterHandlerEntry* result = _current;\n-      _current = _current->next();\n-      if (_current == NULL) scan();\n-      return result;\n-    } else {\n-      return NULL;\n-    }\n-  }\n-};\n-\n-\n@@ -2719,1 +2634,0 @@\n-AdapterHandlerTable* AdapterHandlerLibrary::_adapters = NULL;\n@@ -2737,1 +2651,2 @@\n-static void post_adapter_creation(const AdapterBlob* new_adapter, const AdapterHandlerEntry* entry) {\n+static void post_adapter_creation(const AdapterBlob* new_adapter,\n+                                  const AdapterHandlerEntry* entry) {\n@@ -2764,3 +2679,0 @@\n-    assert(_adapters == NULL, \"Initializing more than once\");\n-\n-    _adapters = new AdapterHandlerTable();\n@@ -2779,1 +2691,0 @@\n-\n@@ -2814,1 +2725,3 @@\n-  return _adapters->new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);\n+  \/\/ Insert an entry into the table\n+  return new AdapterHandlerEntry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry,\n+                                 c2i_no_clinit_check_entry);\n@@ -2900,1 +2813,1 @@\n-  \/\/ the AdapterHandlerTable (it is not safe for concurrent readers\n+  \/\/ the _adapter_handler_table (it is not safe for concurrent readers\n@@ -2903,1 +2816,0 @@\n-  assert(_adapters != NULL, \"Uninitialized\");\n@@ -2925,1 +2837,1 @@\n-    entry = _adapters->lookup(total_args_passed, sig_bt);\n+    entry = lookup(total_args_passed, sig_bt);\n@@ -2935,1 +2847,1 @@\n-        _adapters->free_entry(comparison_entry);\n+        delete comparison_entry;\n@@ -3007,1 +2919,1 @@\n-                  _adapters->number_of_entries(), fingerprint->as_basic_args_string(),\n+                  _adapter_handler_table.number_of_entries(), fingerprint->as_basic_args_string(),\n@@ -3024,1 +2936,2 @@\n-    _adapters->add(entry);\n+    assert_lock_strong(AdapterHandlerLibrary_lock);\n+    _adapter_handler_table.put(fingerprint, entry);\n@@ -3054,1 +2967,1 @@\n-void AdapterHandlerEntry::deallocate() {\n+AdapterHandlerEntry::~AdapterHandlerEntry() {\n@@ -3343,6 +3256,7 @@\n-  AdapterHandlerTableIterator iter(_adapters);\n-  while (iter.has_next()) {\n-    AdapterHandlerEntry* a = iter.next();\n-    if (b == CodeCache::find_blob(a->get_i2c_entry())) return true;\n-  }\n-  return false;\n+  bool found = false;\n+  auto findblob = [&] (AdapterFingerPrint* key, AdapterHandlerEntry* a) {\n+    return (found = (b == CodeCache::find_blob(a->get_i2c_entry())));\n+  };\n+  assert_locked_or_safepoint(AdapterHandlerLibrary_lock);\n+  _adapter_handler_table.iterate(findblob);\n+  return found;\n@@ -3352,3 +3266,2 @@\n-  AdapterHandlerTableIterator iter(_adapters);\n-  while (iter.has_next()) {\n-    AdapterHandlerEntry* a = iter.next();\n+  bool found = false;\n+  auto findblob = [&] (AdapterFingerPrint* key, AdapterHandlerEntry* a) {\n@@ -3356,0 +3269,1 @@\n+      found = true;\n@@ -3357,2 +3271,4 @@\n-      a->print_adapter_on(tty);\n-      return;\n+      a->print_adapter_on(st);\n+      return true;\n+    } else {\n+      return false; \/\/ keep looking\n@@ -3360,2 +3276,4 @@\n-  }\n-  assert(false, \"Should have found handler\");\n+  };\n+  assert_locked_or_safepoint(AdapterHandlerLibrary_lock);\n+  _adapter_handler_table.iterate(findblob);\n+  assert(found, \"Should have found handler\");\n@@ -3384,1 +3302,1 @@\n-  _adapters->print_statistics();\n+  print_table_statistics();\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":73,"deletions":155,"binary":false,"changes":228,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"utilities\/hashtable.hpp\"\n@@ -38,1 +37,0 @@\n-class AdapterHandlerTable;\n@@ -614,2 +612,1 @@\n-class AdapterHandlerEntry : public BasicHashtableEntry<mtCode> {\n-  friend class AdapterHandlerTable;\n+class AdapterHandlerEntry : public CHeapObj<mtCode> {\n@@ -632,6 +629,8 @@\n-  void init(AdapterFingerPrint* fingerprint, address i2c_entry, address c2i_entry, address c2i_unverified_entry, address c2i_no_clinit_check_entry) {\n-    _fingerprint = fingerprint;\n-    _i2c_entry = i2c_entry;\n-    _c2i_entry = c2i_entry;\n-    _c2i_unverified_entry = c2i_unverified_entry;\n-    _c2i_no_clinit_check_entry = c2i_no_clinit_check_entry;\n+  AdapterHandlerEntry(AdapterFingerPrint* fingerprint, address i2c_entry, address c2i_entry,\n+                      address c2i_unverified_entry,\n+                      address c2i_no_clinit_check_entry) :\n+    _fingerprint(fingerprint),\n+    _i2c_entry(i2c_entry),\n+    _c2i_entry(c2i_entry),\n+    _c2i_unverified_entry(c2i_unverified_entry),\n+    _c2i_no_clinit_check_entry(c2i_no_clinit_check_entry)\n@@ -639,1 +638,1 @@\n-    _saved_code_length = 0;\n+    , _saved_code_length(0)\n@@ -641,3 +640,1 @@\n-  }\n-\n-  void deallocate();\n+  { }\n@@ -645,2 +642,1 @@\n-  \/\/ should never be used\n-  AdapterHandlerEntry();\n+  ~AdapterHandlerEntry();\n@@ -659,4 +655,0 @@\n-  AdapterHandlerEntry* next() {\n-    return (AdapterHandlerEntry*)BasicHashtableEntry<mtCode>::next();\n-  }\n-\n@@ -677,1 +669,0 @@\n-  static AdapterHandlerTable* _adapters;\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":12,"deletions":21,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+class frame;\n","filename":"src\/hotspot\/share\/runtime\/stackValue.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+#include \"utilities\/linkedlist.hpp\"\n@@ -62,0 +63,5 @@\n+class ObjectMonitorsHashtable::PtrList :\n+  public LinkedListImpl<ObjectMonitor*,\n+                        ResourceObj::C_HEAP, mtThread,\n+                        AllocFailStrategy::RETURN_NULL> {};\n+\n@@ -81,1 +87,1 @@\n-    list = new (ResourceObj::C_HEAP, mtThread) ObjectMonitorsHashtable::PtrList();\n+    list = new (ResourceObj::C_HEAP, mtThread) ObjectMonitorsHashtable::PtrList;\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,0 @@\n-#include \"utilities\/growableArray.hpp\"\n-#include \"utilities\/linkedlist.hpp\"\n@@ -36,0 +34,1 @@\n+template <typename T> class GrowableArray;\n@@ -52,3 +51,1 @@\n-  typedef LinkedListImpl<ObjectMonitor*,\n-                         ResourceObj::C_HEAP, mtThread,\n-                         AllocFailStrategy::RETURN_NULL> PtrList;\n+  class PtrList;\n@@ -56,0 +53,1 @@\n+ private:\n@@ -60,1 +58,0 @@\n- private:\n@@ -69,1 +66,1 @@\n-  ObjectMonitorsHashtable() : _ptrs(new (ResourceObj::C_HEAP, mtThread) PtrTable()), _key_count(0), _om_count(0) {}\n+  ObjectMonitorsHashtable() : _ptrs(new (ResourceObj::C_HEAP, mtThread) PtrTable), _key_count(0), _om_count(0) {}\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1046,1 +1046,5 @@\n-  \/\/ Wait until we are the last non-daemon thread to execute\n+  \/\/ Wait until we are the last non-daemon thread to execute, or\n+  \/\/ if we are a daemon then wait until the last non-daemon thread has\n+  \/\/ executed.\n+  bool daemon = java_lang_Thread::is_daemon(thread->threadObj());\n+  int expected = daemon ? 0 : 1;\n@@ -1049,1 +1053,1 @@\n-    while (Threads::number_of_non_daemon_threads() > 1)\n+    while (Threads::number_of_non_daemon_threads() > expected)\n@@ -1226,3 +1230,5 @@\n-      \/\/ Only one thread left, do a notify on the Threads_lock so a thread waiting\n-      \/\/ on destroy_vm will wake up.\n-      if (number_of_non_daemon_threads() == 1) {\n+      \/\/ If this is the last non-daemon thread then we need to do\n+      \/\/ a notify on the Threads_lock so a thread waiting\n+      \/\/ on destroy_vm will wake up. But that thread could be a daemon\n+      \/\/ or non-daemon, so we notify for both the 0 and 1 case.\n+      if (number_of_non_daemon_threads() <= 1) {\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"oops\/method.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+class ObjectMonitorsHashtable;\n+\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2555,1 +2555,0 @@\n-  declare_constant(RegisterImpl::number_of_registers)                     \\\n@@ -2557,1 +2556,1 @@\n-  declare_preprocessor_constant(\"REG_COUNT\", REG_COUNT)                \\\n+  declare_preprocessor_constant(\"REG_COUNT\", REG_COUNT)                   \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -465,0 +465,5 @@\n+    if (k == nullptr) {\n+      fatal(\"Should have the DiagnosticCommandImpl class\");\n+      return; \/\/ silence the compiler\n+    }\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticFramework.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -273,1 +273,1 @@\n-  _table = new FinalizerHashtable(start_size_log_2, MAX_SIZE);\n+  _table = new FinalizerHashtable(start_size_log_2, MAX_SIZE, FinalizerHashtable::DEFAULT_GROW_HINT);\n","filename":"src\/hotspot\/share\/services\/finalizerService.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"precompiled.hpp\"\n+\n+#include \"services\/mallocHeader.inline.hpp\"\n+\n+#include \"runtime\/os.hpp\"\n+#include \"services\/mallocSiteTable.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/nativeCallStack.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+\n+void MallocHeader::print_block_on_error(outputStream* st, address bad_address) const {\n+  assert(bad_address >= (address)this, \"sanity\");\n+\n+  \/\/ This function prints block information, including hex dump, in case of a detected\n+  \/\/ corruption. The hex dump should show both block header and corruption site\n+  \/\/ (which may or may not be close together or identical). Plus some surrounding area.\n+  \/\/\n+  \/\/ Note that we use os::print_hex_dump(), which is able to cope with unmapped\n+  \/\/ memory (it uses SafeFetch).\n+\n+  st->print_cr(\"NMT Block at \" PTR_FORMAT \", corruption at: \" PTR_FORMAT \": \",\n+               p2i(this), p2i(bad_address));\n+  static const size_t min_dump_length = 256;\n+  address from1 = align_down((address)this, sizeof(void*)) - (min_dump_length \/ 2);\n+  address to1 = from1 + min_dump_length;\n+  address from2 = align_down(bad_address, sizeof(void*)) - (min_dump_length \/ 2);\n+  address to2 = from2 + min_dump_length;\n+  if (from2 > to1) {\n+    \/\/ Dump gets too large, split up in two sections.\n+    os::print_hex_dump(st, from1, to1, 1);\n+    st->print_cr(\"...\");\n+    os::print_hex_dump(st, from2, to2, 1);\n+  } else {\n+    \/\/ print one hex dump\n+    os::print_hex_dump(st, from1, to2, 1);\n+  }\n+}\n+\n+bool MallocHeader::get_stack(NativeCallStack& stack) const {\n+  return MallocSiteTable::access_stack(stack, _mst_marker);\n+}\n","filename":"src\/hotspot\/share\/services\/mallocHeader.cpp","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SERVICES_MALLOCHEADER_HPP\n+#define SHARE_SERVICES_MALLOCHEADER_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"utilities\/nativeCallStack.hpp\"\n+\n+class outputStream;\n+\n+\/*\n+ * Malloc tracking header.\n+ *\n+ * If NMT is active (state >= minimal), we need to track allocations. A simple and cheap way to\n+ * do this is by using malloc headers.\n+ *\n+ * The user allocation is preceded by a header and is immediately followed by a (possibly unaligned)\n+ *  footer canary:\n+ *\n+ * +--------------+-------------  ....  ------------------+-----+\n+ * |    header    |               user                    | can |\n+ * |              |             allocation                | ary |\n+ * +--------------+-------------  ....  ------------------+-----+\n+ *     16 bytes              user size                      2 byte\n+ *\n+ * Alignment:\n+ *\n+ * The start of the user allocation needs to adhere to malloc alignment. We assume 128 bits\n+ * on both 64-bit\/32-bit to be enough for that. So the malloc header is 16 bytes long on both\n+ * 32-bit and 64-bit.\n+ *\n+ * Layout on 64-bit:\n+ *\n+ *     0        1        2        3        4        5        6        7\n+ * +--------+--------+--------+--------+--------+--------+--------+--------+\n+ * |                            64-bit size                                |  ...\n+ * +--------+--------+--------+--------+--------+--------+--------+--------+\n+ *\n+ *           8        9        10       11       12       13       14       15          16 ++\n+ *       +--------+--------+--------+--------+--------+--------+--------+--------+  ------------------------\n+ *  ...  |   malloc site table marker        | flags  | unused |     canary      |  ... User payload ....\n+ *       +--------+--------+--------+--------+--------+--------+--------+--------+  ------------------------\n+ *\n+ * Layout on 32-bit:\n+ *\n+ *     0        1        2        3        4        5        6        7\n+ * +--------+--------+--------+--------+--------+--------+--------+--------+\n+ * |            alt. canary            |           32-bit size             |  ...\n+ * +--------+--------+--------+--------+--------+--------+--------+--------+\n+ *\n+ *           8        9        10       11       12       13       14       15          16 ++\n+ *       +--------+--------+--------+--------+--------+--------+--------+--------+  ------------------------\n+ *  ...  |   malloc site table marker        | flags  | unused |     canary      |  ... User payload ....\n+ *       +--------+--------+--------+--------+--------+--------+--------+--------+  ------------------------\n+ *\n+ * Notes:\n+ * - We have a canary in the two bytes directly preceding the user payload. That allows us to\n+ *   catch negative buffer overflows.\n+ * - On 32-bit, due to the smaller size_t, we have some bits to spare. So we also have a second\n+ *   canary at the very start of the malloc header (generously sized 32 bits).\n+ * - The footer canary consists of two bytes. Since the footer location may be unaligned to 16 bits,\n+ *   the bytes are stored individually.\n+ *\/\n+\n+class MallocHeader {\n+\n+  NOT_LP64(uint32_t _alt_canary);\n+  const size_t _size;\n+  const uint32_t _mst_marker;\n+  const uint8_t _flags;\n+  const uint8_t _unused;\n+  uint16_t _canary;\n+\n+  static const uint16_t _header_canary_life_mark = 0xE99E;\n+  static const uint16_t _header_canary_dead_mark = 0xD99D;\n+  static const uint16_t _footer_canary_life_mark = 0xE88E;\n+  static const uint16_t _footer_canary_dead_mark = 0xD88D;\n+  NOT_LP64(static const uint32_t _header_alt_canary_life_mark = 0xE99EE99E;)\n+  NOT_LP64(static const uint32_t _header_alt_canary_dead_mark = 0xD88DD88D;)\n+\n+  \/\/ We discount sizes larger than these\n+  static const size_t max_reasonable_malloc_size = LP64_ONLY(256 * G) NOT_LP64(3500 * M);\n+\n+  void print_block_on_error(outputStream* st, address bad_address) const;\n+\n+  static uint16_t build_footer(uint8_t b1, uint8_t b2) { return ((uint16_t)b1 << 8) | (uint16_t)b2; }\n+\n+  uint8_t* footer_address() const   { return ((address)this) + sizeof(MallocHeader) + _size; }\n+  uint16_t get_footer() const       { return build_footer(footer_address()[0], footer_address()[1]); }\n+  void set_footer(uint16_t v)       { footer_address()[0] = v >> 8; footer_address()[1] = (uint8_t)v; }\n+\n+ public:\n+\n+  inline MallocHeader(size_t size, MEMFLAGS flags, const NativeCallStack& stack, uint32_t mst_marker);\n+\n+  inline size_t   size()  const { return _size; }\n+  inline MEMFLAGS flags() const { return (MEMFLAGS)_flags; }\n+  inline uint32_t mst_marker() const { return _mst_marker; }\n+  bool get_stack(NativeCallStack& stack) const;\n+\n+  inline void mark_block_as_dead();\n+\n+  \/\/ If block is broken, fill in a short descriptive text in out,\n+  \/\/ an option pointer to the corruption in p_corruption, and return false.\n+  \/\/ Return true if block is fine.\n+  inline bool check_block_integrity(char* msg, size_t msglen, address* p_corruption) const;\n+\n+  \/\/ If block is broken, print out a report to tty (optionally with\n+  \/\/ hex dump surrounding the broken block), then trigger a fatal error\n+  inline void assert_block_integrity() const;\n+};\n+\n+\/\/ This needs to be true on both 64-bit and 32-bit platforms\n+STATIC_ASSERT(sizeof(MallocHeader) == (sizeof(uint64_t) * 2));\n+\n+\n+#endif \/\/ SHARE_SERVICES_MALLOCHEADER_HPP\n","filename":"src\/hotspot\/share\/services\/mallocHeader.hpp","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SERVICES_MALLOCHEADER_INLINE_HPP\n+#define SHARE_SERVICES_MALLOCHEADER_INLINE_HPP\n+\n+#include \"services\/mallocHeader.hpp\"\n+\n+#include \"jvm_io.h\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"utilities\/nativeCallStack.hpp\"\n+\n+inline MallocHeader::MallocHeader(size_t size, MEMFLAGS flags, const NativeCallStack& stack, uint32_t mst_marker)\n+  : _size(size), _mst_marker(mst_marker), _flags(NMTUtil::flag_to_index(flags)),\n+    _unused(0), _canary(_header_canary_life_mark)\n+{\n+  assert(size < max_reasonable_malloc_size, \"Too large allocation size?\");\n+  \/\/ On 32-bit we have some bits more, use them for a second canary\n+  \/\/ guarding the start of the header.\n+  NOT_LP64(_alt_canary = _header_alt_canary_life_mark;)\n+  set_footer(_footer_canary_life_mark); \/\/ set after initializing _size\n+}\n+\n+inline void MallocHeader::mark_block_as_dead() {\n+  _canary = _header_canary_dead_mark;\n+  NOT_LP64(_alt_canary = _header_alt_canary_dead_mark);\n+  set_footer(_footer_canary_dead_mark);\n+}\n+\n+inline void MallocHeader::assert_block_integrity() const {\n+  char msg[256];\n+  address corruption = NULL;\n+  if (!check_block_integrity(msg, sizeof(msg), &corruption)) {\n+    if (corruption != NULL) {\n+      print_block_on_error(tty, (address)this);\n+    }\n+    fatal(\"NMT corruption: Block at \" PTR_FORMAT \": %s\", p2i(this), msg);\n+  }\n+}\n+\n+inline bool MallocHeader::check_block_integrity(char* msg, size_t msglen, address* p_corruption) const {\n+  \/\/ Note: if you modify the error messages here, make sure you\n+  \/\/ adapt the associated gtests too.\n+\n+  \/\/ Weed out obviously wrong block addresses of NULL or very low\n+  \/\/ values. Note that we should not call this for ::free(NULL),\n+  \/\/ which should be handled by os::free() above us.\n+  if (((size_t)p2i(this)) < K) {\n+    jio_snprintf(msg, msglen, \"invalid block address\");\n+    return false;\n+  }\n+\n+  \/\/ From here on we assume the block pointer to be valid. We could\n+  \/\/ use SafeFetch but since this is a hot path we don't. If we are\n+  \/\/ wrong, we will crash when accessing the canary, which hopefully\n+  \/\/ generates distinct crash report.\n+\n+  \/\/ Weed out obviously unaligned addresses. NMT blocks, being the result of\n+  \/\/ malloc calls, should adhere to malloc() alignment. Malloc alignment is\n+  \/\/ specified by the standard by this requirement:\n+  \/\/ \"malloc returns a pointer which is suitably aligned for any built-in type\"\n+  \/\/ For us it means that it is *at least* 64-bit on all of our 32-bit and\n+  \/\/ 64-bit platforms since we have native 64-bit types. It very probably is\n+  \/\/ larger than that, since there exist scalar types larger than 64bit. Here,\n+  \/\/ we test the smallest alignment we know.\n+  \/\/ Should we ever start using std::max_align_t, this would be one place to\n+  \/\/ fix up.\n+  if (!is_aligned(this, sizeof(uint64_t))) {\n+    *p_corruption = (address)this;\n+    jio_snprintf(msg, msglen, \"block address is unaligned\");\n+    return false;\n+  }\n+\n+  \/\/ Check header canary\n+  if (_canary != _header_canary_life_mark) {\n+    *p_corruption = (address)this;\n+    jio_snprintf(msg, msglen, \"header canary broken\");\n+    return false;\n+  }\n+\n+#ifndef _LP64\n+  \/\/ On 32-bit we have a second canary, check that one too.\n+  if (_alt_canary != _header_alt_canary_life_mark) {\n+    *p_corruption = (address)this;\n+    jio_snprintf(msg, msglen, \"header canary broken\");\n+    return false;\n+  }\n+#endif\n+\n+  \/\/ Does block size seems reasonable?\n+  if (_size >= max_reasonable_malloc_size) {\n+    *p_corruption = (address)this;\n+    jio_snprintf(msg, msglen, \"header looks invalid (weirdly large block size)\");\n+    return false;\n+  }\n+\n+  \/\/ Check footer canary\n+  if (get_footer() != _footer_canary_life_mark) {\n+    *p_corruption = footer_address();\n+    jio_snprintf(msg, msglen, \"footer canary broken at \" PTR_FORMAT \" (buffer overflow?)\",\n+                p2i(footer_address()));\n+    return false;\n+  }\n+  return true;\n+}\n+\n+#endif \/\/ SHARE_SERVICES_MALLOCHEADER_INLINE_HPP\n","filename":"src\/hotspot\/share\/services\/mallocHeader.inline.hpp","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"services\/mallocHeader.inline.hpp\"\n@@ -68,19 +69,0 @@\n-\/\/ Total malloc invocation count\n-size_t MallocMemorySnapshot::total_count() const {\n-  size_t amount = 0;\n-  for (int index = 0; index < mt_number_of_types; index ++) {\n-    amount += _malloc[index].malloc_count();\n-  }\n-  return amount;\n-}\n-\n-\/\/ Total malloc'd memory amount\n-size_t MallocMemorySnapshot::total() const {\n-  size_t amount = 0;\n-  for (int index = 0; index < mt_number_of_types; index ++) {\n-    amount += _malloc[index].malloc_size();\n-  }\n-  amount += _tracking_header.size() + total_arena();\n-  return amount;\n-}\n-\n@@ -102,0 +84,1 @@\n+  _all_mallocs.deallocate(arena_size);\n@@ -104,1 +87,0 @@\n-\n@@ -111,114 +93,0 @@\n-void MallocHeader::mark_block_as_dead() {\n-  _canary = _header_canary_dead_mark;\n-  NOT_LP64(_alt_canary = _header_alt_canary_dead_mark);\n-  set_footer(_footer_canary_dead_mark);\n-}\n-\n-void MallocHeader::print_block_on_error(outputStream* st, address bad_address) const {\n-  assert(bad_address >= (address)this, \"sanity\");\n-\n-  \/\/ This function prints block information, including hex dump, in case of a detected\n-  \/\/ corruption. The hex dump should show both block header and corruption site\n-  \/\/ (which may or may not be close together or identical). Plus some surrounding area.\n-  \/\/\n-  \/\/ Note that we use os::print_hex_dump(), which is able to cope with unmapped\n-  \/\/ memory (it uses SafeFetch).\n-\n-  st->print_cr(\"NMT Block at \" PTR_FORMAT \", corruption at: \" PTR_FORMAT \": \",\n-               p2i(this), p2i(bad_address));\n-  static const size_t min_dump_length = 256;\n-  address from1 = align_down((address)this, sizeof(void*)) - (min_dump_length \/ 2);\n-  address to1 = from1 + min_dump_length;\n-  address from2 = align_down(bad_address, sizeof(void*)) - (min_dump_length \/ 2);\n-  address to2 = from2 + min_dump_length;\n-  if (from2 > to1) {\n-    \/\/ Dump gets too large, split up in two sections.\n-    os::print_hex_dump(st, from1, to1, 1);\n-    st->print_cr(\"...\");\n-    os::print_hex_dump(st, from2, to2, 1);\n-  } else {\n-    \/\/ print one hex dump\n-    os::print_hex_dump(st, from1, to2, 1);\n-  }\n-}\n-void MallocHeader::assert_block_integrity() const {\n-  char msg[256];\n-  address corruption = NULL;\n-  if (!check_block_integrity(msg, sizeof(msg), &corruption)) {\n-    if (corruption != NULL) {\n-      print_block_on_error(tty, (address)this);\n-    }\n-    fatal(\"NMT corruption: Block at \" PTR_FORMAT \": %s\", p2i(this), msg);\n-  }\n-}\n-\n-bool MallocHeader::check_block_integrity(char* msg, size_t msglen, address* p_corruption) const {\n-  \/\/ Note: if you modify the error messages here, make sure you\n-  \/\/ adapt the associated gtests too.\n-\n-  \/\/ Weed out obviously wrong block addresses of NULL or very low\n-  \/\/ values. Note that we should not call this for ::free(NULL),\n-  \/\/ which should be handled by os::free() above us.\n-  if (((size_t)p2i(this)) < K) {\n-    jio_snprintf(msg, msglen, \"invalid block address\");\n-    return false;\n-  }\n-\n-  \/\/ From here on we assume the block pointer to be valid. We could\n-  \/\/ use SafeFetch but since this is a hot path we don't. If we are\n-  \/\/ wrong, we will crash when accessing the canary, which hopefully\n-  \/\/ generates distinct crash report.\n-\n-  \/\/ Weed out obviously unaligned addresses. NMT blocks, being the result of\n-  \/\/ malloc calls, should adhere to malloc() alignment. Malloc alignment is\n-  \/\/ specified by the standard by this requirement:\n-  \/\/ \"malloc returns a pointer which is suitably aligned for any built-in type\"\n-  \/\/ For us it means that it is *at least* 64-bit on all of our 32-bit and\n-  \/\/ 64-bit platforms since we have native 64-bit types. It very probably is\n-  \/\/ larger than that, since there exist scalar types larger than 64bit. Here,\n-  \/\/ we test the smallest alignment we know.\n-  \/\/ Should we ever start using std::max_align_t, this would be one place to\n-  \/\/ fix up.\n-  if (!is_aligned(this, sizeof(uint64_t))) {\n-    *p_corruption = (address)this;\n-    jio_snprintf(msg, msglen, \"block address is unaligned\");\n-    return false;\n-  }\n-\n-  \/\/ Check header canary\n-  if (_canary != _header_canary_life_mark) {\n-    *p_corruption = (address)this;\n-    jio_snprintf(msg, msglen, \"header canary broken\");\n-    return false;\n-  }\n-\n-#ifndef _LP64\n-  \/\/ On 32-bit we have a second canary, check that one too.\n-  if (_alt_canary != _header_alt_canary_life_mark) {\n-    *p_corruption = (address)this;\n-    jio_snprintf(msg, msglen, \"header canary broken\");\n-    return false;\n-  }\n-#endif\n-\n-  \/\/ Does block size seems reasonable?\n-  if (_size >= max_reasonable_malloc_size) {\n-    *p_corruption = (address)this;\n-    jio_snprintf(msg, msglen, \"header looks invalid (weirdly large block size)\");\n-    return false;\n-  }\n-\n-  \/\/ Check footer canary\n-  if (get_footer() != _footer_canary_life_mark) {\n-    *p_corruption = footer_address();\n-    jio_snprintf(msg, msglen, \"footer canary broken at \" PTR_FORMAT \" (buffer overflow?)\",\n-                p2i(footer_address()));\n-    return false;\n-  }\n-  return true;\n-}\n-\n-bool MallocHeader::get_stack(NativeCallStack& stack) const {\n-  return MallocSiteTable::access_stack(stack, _mst_marker);\n-}\n-\n@@ -244,1 +112,0 @@\n-  MallocMemorySummary::record_new_malloc_header(sizeof(MallocHeader));\n@@ -279,1 +146,0 @@\n-  MallocMemorySummary::record_free_malloc_header(sizeof(MallocHeader));\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":2,"deletions":136,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"services\/mallocHeader.hpp\"\n@@ -143,1 +144,1 @@\n-  MemoryCounter     _tracking_header;\n+  MemoryCounter     _all_mallocs;\n@@ -152,2 +153,2 @@\n-  inline MemoryCounter* malloc_overhead() {\n-    return &_tracking_header;\n+  inline size_t malloc_overhead() const {\n+    return _all_mallocs.count() * sizeof(MallocHeader);\n@@ -157,1 +158,4 @@\n-  size_t total_count() const;\n+  size_t total_count() const {\n+    return _all_mallocs.count();\n+  }\n+\n@@ -159,1 +163,4 @@\n-  size_t total() const;\n+  size_t total() const {\n+    return _all_mallocs.size() + malloc_overhead() + total_arena();\n+  }\n+\n@@ -173,1 +180,1 @@\n-    s->_tracking_header = _tracking_header;\n+    s->_all_mallocs = _all_mallocs;\n@@ -197,0 +204,1 @@\n+     as_snapshot()->_all_mallocs.allocate(size);\n@@ -201,0 +209,1 @@\n+     as_snapshot()->_all_mallocs.deallocate(size);\n@@ -220,9 +229,0 @@\n-   \/\/ Record memory used by malloc tracking header\n-   static inline void record_new_malloc_header(size_t sz) {\n-     as_snapshot()->malloc_overhead()->allocate(sz);\n-   }\n-\n-   static inline void record_free_malloc_header(size_t sz) {\n-     as_snapshot()->malloc_overhead()->deallocate(sz);\n-   }\n-\n@@ -231,1 +231,1 @@\n-     return as_snapshot()->malloc_overhead()->size();\n+     return as_snapshot()->malloc_overhead();\n@@ -239,116 +239,0 @@\n-\n-\/*\n- * Malloc tracking header.\n- *\n- * If NMT is active (state >= minimal), we need to track allocations. A simple and cheap way to\n- * do this is by using malloc headers.\n- *\n- * The user allocation is preceded by a header and is immediately followed by a (possibly unaligned)\n- *  footer canary:\n- *\n- * +--------------+-------------  ....  ------------------+-----+\n- * |    header    |               user                    | can |\n- * |              |             allocation                | ary |\n- * +--------------+-------------  ....  ------------------+-----+\n- *     16 bytes              user size                      2 byte\n- *\n- * Alignment:\n- *\n- * The start of the user allocation needs to adhere to malloc alignment. We assume 128 bits\n- * on both 64-bit\/32-bit to be enough for that. So the malloc header is 16 bytes long on both\n- * 32-bit and 64-bit.\n- *\n- * Layout on 64-bit:\n- *\n- *     0        1        2        3        4        5        6        7\n- * +--------+--------+--------+--------+--------+--------+--------+--------+\n- * |                            64-bit size                                |  ...\n- * +--------+--------+--------+--------+--------+--------+--------+--------+\n- *\n- *           8        9        10       11       12       13       14       15          16 ++\n- *       +--------+--------+--------+--------+--------+--------+--------+--------+  ------------------------\n- *  ...  |   malloc site table marker        | flags  | unused |     canary      |  ... User payload ....\n- *       +--------+--------+--------+--------+--------+--------+--------+--------+  ------------------------\n- *\n- * Layout on 32-bit:\n- *\n- *     0        1        2        3        4        5        6        7\n- * +--------+--------+--------+--------+--------+--------+--------+--------+\n- * |            alt. canary            |           32-bit size             |  ...\n- * +--------+--------+--------+--------+--------+--------+--------+--------+\n- *\n- *           8        9        10       11       12       13       14       15          16 ++\n- *       +--------+--------+--------+--------+--------+--------+--------+--------+  ------------------------\n- *  ...  |   malloc site table marker        | flags  | unused |     canary      |  ... User payload ....\n- *       +--------+--------+--------+--------+--------+--------+--------+--------+  ------------------------\n- *\n- * Notes:\n- * - We have a canary in the two bytes directly preceding the user payload. That allows us to\n- *   catch negative buffer overflows.\n- * - On 32-bit, due to the smaller size_t, we have some bits to spare. So we also have a second\n- *   canary at the very start of the malloc header (generously sized 32 bits).\n- * - The footer canary consists of two bytes. Since the footer location may be unaligned to 16 bits,\n- *   the bytes are stored individually.\n- *\/\n-\n-class MallocHeader {\n-\n-  NOT_LP64(uint32_t _alt_canary);\n-  const size_t _size;\n-  const uint32_t _mst_marker;\n-  const uint8_t _flags;\n-  const uint8_t _unused;\n-  uint16_t _canary;\n-\n-  static const uint16_t _header_canary_life_mark = 0xE99E;\n-  static const uint16_t _header_canary_dead_mark = 0xD99D;\n-  static const uint16_t _footer_canary_life_mark = 0xE88E;\n-  static const uint16_t _footer_canary_dead_mark = 0xD88D;\n-  NOT_LP64(static const uint32_t _header_alt_canary_life_mark = 0xE99EE99E;)\n-  NOT_LP64(static const uint32_t _header_alt_canary_dead_mark = 0xD88DD88D;)\n-\n-  \/\/ We discount sizes larger than these\n-  static const size_t max_reasonable_malloc_size = LP64_ONLY(256 * G) NOT_LP64(3500 * M);\n-\n-  void print_block_on_error(outputStream* st, address bad_address) const;\n-\n-  static uint16_t build_footer(uint8_t b1, uint8_t b2) { return ((uint16_t)b1 << 8) | (uint16_t)b2; }\n-\n-  uint8_t* footer_address() const   { return ((address)this) + sizeof(MallocHeader) + _size; }\n-  uint16_t get_footer() const       { return build_footer(footer_address()[0], footer_address()[1]); }\n-  void set_footer(uint16_t v)       { footer_address()[0] = v >> 8; footer_address()[1] = (uint8_t)v; }\n-\n- public:\n-\n-  MallocHeader(size_t size, MEMFLAGS flags, const NativeCallStack& stack, uint32_t mst_marker)\n-    : _size(size), _mst_marker(mst_marker), _flags(NMTUtil::flag_to_index(flags)),\n-      _unused(0), _canary(_header_canary_life_mark)\n-  {\n-    assert(size < max_reasonable_malloc_size, \"Too large allocation size?\");\n-    \/\/ On 32-bit we have some bits more, use them for a second canary\n-    \/\/ guarding the start of the header.\n-    NOT_LP64(_alt_canary = _header_alt_canary_life_mark;)\n-    set_footer(_footer_canary_life_mark); \/\/ set after initializing _size\n-  }\n-\n-  inline size_t   size()  const { return _size; }\n-  inline MEMFLAGS flags() const { return (MEMFLAGS)_flags; }\n-  inline uint32_t mst_marker() const { return _mst_marker; }\n-  bool get_stack(NativeCallStack& stack) const;\n-\n-  void mark_block_as_dead();\n-\n-  \/\/ If block is broken, fill in a short descriptive text in out,\n-  \/\/ an option pointer to the corruption in p_corruption, and return false.\n-  \/\/ Return true if block is fine.\n-  bool check_block_integrity(char* msg, size_t msglen, address* p_corruption) const;\n-\n-  \/\/ If block is broken, print out a report to tty (optionally with\n-  \/\/ hex dump surrounding the broken block), then trigger a fatal error\n-  void assert_block_integrity() const;\n-};\n-\n-\/\/ This needs to be true on both 64-bit and 32-bit platforms\n-STATIC_ASSERT(sizeof(MallocHeader) == (sizeof(uint64_t) * 2));\n-\n-\n","filename":"src\/hotspot\/share\/services\/mallocTracker.hpp","additions":16,"deletions":132,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-    return bl->_malloc_memory_snapshot.malloc_overhead()->size();\n+    return bl->_malloc_memory_snapshot.malloc_overhead();\n","filename":"src\/hotspot\/share\/services\/memBaseline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -160,2 +160,2 @@\n-    reserved_amount  += _malloc_snapshot->malloc_overhead()->size();\n-    committed_amount += _malloc_snapshot->malloc_overhead()->size();\n+    reserved_amount  += _malloc_snapshot->malloc_overhead();\n+    committed_amount += _malloc_snapshot->malloc_overhead();\n@@ -213,1 +213,1 @@\n-      amount_in_current_scale(_malloc_snapshot->malloc_overhead()->size()) > 0) {\n+      amount_in_current_scale(_malloc_snapshot->malloc_overhead()) > 0) {\n@@ -215,1 +215,1 @@\n-        amount_in_current_scale(_malloc_snapshot->malloc_overhead()->size()), scale);\n+        amount_in_current_scale(_malloc_snapshot->malloc_overhead()), scale);\n","filename":"src\/hotspot\/share\/services\/memReporter.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -103,0 +103,5 @@\n+    if (k == nullptr) {\n+      fatal(\"Should have the ManagementFactoryHelper or GarbageCollectorExtImpl class\");\n+      return nullptr; \/\/ silence the compiler\n+    }\n+\n","filename":"src\/hotspot\/share\/services\/memoryManager.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -125,1 +125,2 @@\n-  _local_table = new ThreadIdTableHash(start_size_log, END_SIZE);\n+  _local_table =\n+      new ThreadIdTableHash(start_size_log, END_SIZE, ThreadIdTableHash::DEFAULT_GROW_HINT);\n","filename":"src\/hotspot\/share\/services\/threadIdTable.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+class DeadlockCycle;\n+class ObjectMonitorsHashtable;\n@@ -41,3 +43,0 @@\n-class ThreadDumpResult;\n-class ThreadStackTrace;\n-class ThreadSnapshot;\n@@ -46,1 +45,3 @@\n-class DeadlockCycle;\n+class ThreadDumpResult;\n+class ThreadSnapshot;\n+class ThreadStackTrace;\n","filename":"src\/hotspot\/share\/services\/threadService.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -45,0 +45,16 @@\n+  \/\/ _stats_rate is null if statistics are not enabled.\n+  TableRateStatistics* _stats_rate;\n+  inline void safe_stats_add() {\n+    if (_stats_rate != nullptr) {\n+      _stats_rate->add();\n+    }\n+  }\n+  inline void safe_stats_remove() {\n+    if (_stats_rate != nullptr) {\n+      _stats_rate->remove();\n+    }\n+  }\n+  \/\/ Calculate statistics. Item sizes are calculated with VALUE_SIZE_FUNC.\n+  template <typename VALUE_SIZE_FUNC>\n+  TableStatistics statistics_calculate(Thread* thread, VALUE_SIZE_FUNC& vs_f);\n+\n@@ -212,5 +228,0 @@\n-  \/\/ Default sizes\n-  static const size_t DEFAULT_MAX_SIZE_LOG2 = 21;\n-  static const size_t DEFAULT_START_SIZE_LOG2 = 13;\n-  static const size_t DEFAULT_GROW_HINT = 4; \/\/ Chain length\n-\n@@ -379,0 +390,5 @@\n+  \/\/ Default sizes\n+  static const size_t DEFAULT_MAX_SIZE_LOG2 = 21;\n+  static const size_t DEFAULT_START_SIZE_LOG2 = 13;\n+  static const size_t DEFAULT_GROW_HINT = 4; \/\/ Chain length\n+  static const bool DEFAULT_ENABLE_STATISTICS = false;\n@@ -382,1 +398,2 @@\n-                      void* context = NULL);\n+                      bool enable_statistics = DEFAULT_ENABLE_STATISTICS,\n+                      void* context = nullptr);\n@@ -384,2 +401,2 @@\n-  explicit ConcurrentHashTable(void* context, size_t log2size = DEFAULT_START_SIZE_LOG2) :\n-    ConcurrentHashTable(log2size, DEFAULT_MAX_SIZE_LOG2, DEFAULT_GROW_HINT, context) {}\n+  explicit ConcurrentHashTable(void* context, size_t log2size = DEFAULT_START_SIZE_LOG2, bool enable_statistics = DEFAULT_ENABLE_STATISTICS) :\n+    ConcurrentHashTable(log2size, DEFAULT_MAX_SIZE_LOG2, DEFAULT_GROW_HINT, enable_statistics, context) {}\n@@ -389,2 +406,0 @@\n-  TableRateStatistics _stats_rate;\n-\n@@ -485,4 +500,0 @@\n-  \/\/ Calculate statistics. Item sizes are calculated with VALUE_SIZE_FUNC.\n-  template <typename VALUE_SIZE_FUNC>\n-  TableStatistics statistics_calculate(Thread* thread, VALUE_SIZE_FUNC& vs_f);\n-\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.hpp","additions":25,"deletions":14,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -475,1 +475,1 @@\n-  JFR_ONLY(_stats_rate.remove();)\n+  JFR_ONLY(safe_stats_remove();)\n@@ -524,1 +524,1 @@\n-      JFR_ONLY(_stats_rate.remove();)\n+      JFR_ONLY(safe_stats_remove();)\n@@ -563,1 +563,1 @@\n-      JFR_ONLY(_stats_rate.remove();)\n+      JFR_ONLY(safe_stats_remove();)\n@@ -905,1 +905,1 @@\n-          JFR_ONLY(_stats_rate.add();)\n+          JFR_ONLY(safe_stats_add();)\n@@ -1010,1 +1010,1 @@\n-  ConcurrentHashTable(size_t log2size, size_t log2size_limit, size_t grow_hint, void* context)\n+ConcurrentHashTable(size_t log2size, size_t log2size_limit, size_t grow_hint, bool enable_statistics, void* context)\n@@ -1016,1 +1016,5 @@\n-  _stats_rate = TableRateStatistics();\n+  if (enable_statistics) {\n+    _stats_rate = new TableRateStatistics();\n+  } else {\n+    _stats_rate = nullptr;\n+  }\n@@ -1031,0 +1035,1 @@\n+  delete _stats_rate;\n@@ -1105,1 +1110,1 @@\n-  JFR_ONLY(_stats_rate.add();)\n+  JFR_ONLY(safe_stats_add();)\n@@ -1227,1 +1232,1 @@\n-  return TableStatistics(_stats_rate, summary, literal_bytes, sizeof(Bucket), sizeof(Node));\n+  return TableStatistics(*_stats_rate, summary, literal_bytes, sizeof(Bucket), sizeof(Node));\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.inline.hpp","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,4 +80,0 @@\n-static size_t literal_size(Symbol *symbol) {\n-  return symbol->size() * HeapWordSize;\n-}\n-\n@@ -261,2 +257,0 @@\n-template class Hashtable<nmethod*, mtGC>;\n-template class HashtableEntry<nmethod*, mtGC>;\n@@ -264,2 +258,4 @@\n-template class Hashtable<ConstantPool*, mtClass>;\n-template class Hashtable<Klass*, mtClass>;\n+template class BasicHashtable<mtClass>;\n+template class BasicHashtable<mtServiceability>;\n+\n+template class Hashtable<nmethod*, mtGC>;\n@@ -269,15 +265,0 @@\n-template class Hashtable<Symbol*, mtModule>;\n-template class Hashtable<Symbol*, mtClass>;\n-template class HashtableEntry<Symbol*, mtClass>;\n-template class HashtableBucket<mtClass>;\n-template class BasicHashtableEntry<mtSymbol>;\n-template class BasicHashtableEntry<mtCode>;\n-template class BasicHashtable<mtClass>;\n-template class BasicHashtable<mtClassShared>;\n-template class BasicHashtable<mtCode>;\n-template class BasicHashtable<mtInternal>;\n-template class BasicHashtable<mtModule>;\n-template class BasicHashtable<mtCompiler>;\n-template class BasicHashtable<mtTracing>;\n-template class BasicHashtable<mtServiceability>;\n-template class BasicHashtable<mtLogging>;\n@@ -286,2 +267,0 @@\n-template void BasicHashtable<mtModule>::verify_table<ModuleEntry>(char const*);\n-template void BasicHashtable<mtModule>::verify_table<PackageEntry>(char const*);\n@@ -289,1 +268,0 @@\n-template void BasicHashtable<mtClass>::verify_table<PlaceholderEntry>(char const*);\n","filename":"src\/hotspot\/share\/utilities\/hashtable.cpp","additions":5,"deletions":27,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"utilities\/hashtable.hpp\"\n+#include \"utilities\/resizeableResourceHash.hpp\"\n@@ -50,31 +50,7 @@\n-  class BitMapFragmentTable : public BasicHashtable<F> {\n-    class Entry : public BasicHashtableEntry<F> {\n-    public:\n-      uintptr_t _key;\n-      CHeapBitMap* _value;\n-\n-      Entry* next() {\n-        return (Entry*)BasicHashtableEntry<F>::next();\n-      }\n-    };\n-\n-  protected:\n-    Entry* bucket(int i) const;\n-\n-    Entry* new_entry(unsigned int hashValue, uintptr_t key, CHeapBitMap* value);\n-\n-    unsigned hash_segment(uintptr_t key) {\n-      unsigned hash = (unsigned)key;\n-      return hash ^ (hash >> 3);\n-    }\n-\n-    unsigned hash_to_index(unsigned hash) {\n-      return hash & (BasicHashtable<F>::table_size() - 1);\n-    }\n-\n-  public:\n-    BitMapFragmentTable(int table_size) : BasicHashtable<F>(table_size, sizeof(Entry)) {}\n-    ~BitMapFragmentTable();\n-    void add(uintptr_t key, CHeapBitMap* value);\n-    CHeapBitMap** lookup(uintptr_t key);\n-  };\n+  static unsigned hash_segment(const uintptr_t& key) {\n+    unsigned hash = (unsigned)key;\n+    return hash ^ (hash >> 3);\n+  }\n+\n+  typedef ResizeableResourceHashtable<uintptr_t, CHeapBitMap*, ResourceObj::C_HEAP, F,\n+                                      hash_segment> BitMapFragmentTable;\n","filename":"src\/hotspot\/share\/utilities\/objectBitSet.hpp","additions":8,"deletions":32,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"utilities\/hashtable.inline.hpp\"\n@@ -42,1 +41,1 @@\n-        _bitmap_fragments(32),\n+        _bitmap_fragments(32, 8*K),\n@@ -56,46 +55,2 @@\n-}\n-\n-template<MEMFLAGS F>\n-ObjectBitSet<F>::BitMapFragmentTable::~BitMapFragmentTable() {\n-  for (int index = 0; index < BasicHashtable<F>::table_size(); index ++) {\n-    Entry* e = bucket(index);\n-    while (e != nullptr) {\n-      Entry* tmp = e;\n-      e = e->next();\n-      BasicHashtable<F>::free_entry(tmp);\n-    }\n-  }\n-}\n-\n-template<MEMFLAGS F>\n-inline typename ObjectBitSet<F>::BitMapFragmentTable::Entry* ObjectBitSet<F>::BitMapFragmentTable::bucket(int i) const {\n-  return (Entry*)BasicHashtable<F>::bucket(i);\n-}\n-\n-template<MEMFLAGS F>\n-inline typename ObjectBitSet<F>::BitMapFragmentTable::Entry*\n-  ObjectBitSet<F>::BitMapFragmentTable::new_entry(unsigned int hash, uintptr_t key, CHeapBitMap* value) {\n-\n-  Entry* entry = (Entry*)BasicHashtable<F>::new_entry(hash);\n-  entry->_key = key;\n-  entry->_value = value;\n-  return entry;\n-}\n-\n-template<MEMFLAGS F>\n-inline void ObjectBitSet<F>::BitMapFragmentTable::add(uintptr_t key, CHeapBitMap* value) {\n-  unsigned hash = hash_segment(key);\n-  Entry* entry = new_entry(hash, key, value);\n-  BasicHashtable<F>::add_entry(hash_to_index(hash), entry);\n-}\n-\n-template<MEMFLAGS F>\n-inline CHeapBitMap** ObjectBitSet<F>::BitMapFragmentTable::lookup(uintptr_t key) {\n-  unsigned hash = hash_segment(key);\n-  int index = hash_to_index(hash);\n-  for (Entry* e = bucket(index); e != NULL; e = e->next()) {\n-    if (e->hash() == hash && e->_key == key) {\n-      return &(e->_value);\n-    }\n-  }\n-  return NULL;\n+  \/\/ destructors for ResourceHashtable base deletes nodes, and\n+  \/\/ ResizeableResourceHashtableStorage deletes the table.\n@@ -117,1 +72,1 @@\n-  CHeapBitMap** found = _bitmap_fragments.lookup(granule);\n+  CHeapBitMap** found = _bitmap_fragments.get(granule);\n@@ -124,4 +79,2 @@\n-    if (_bitmap_fragments.number_of_entries() * 100 \/ _bitmap_fragments.table_size() > 25) {\n-      _bitmap_fragments.resize(_bitmap_fragments.table_size() * 2);\n-    }\n-    _bitmap_fragments.add(granule, bits);\n+    _bitmap_fragments.put(granule, bits);\n+    _bitmap_fragments.maybe_grow();\n","filename":"src\/hotspot\/share\/utilities\/objectBitSet.inline.hpp","additions":6,"deletions":53,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/numberSeq.hpp\"\n+#include \"utilities\/tableStatistics.hpp\"\n@@ -262,0 +265,20 @@\n+  template<typename Function>\n+  TableStatistics statistics_calculate(Function size_function) const {\n+    NumberSeq summary;\n+    size_t literal_bytes = 0;\n+    Node* const* bucket = table();\n+    const unsigned sz = table_size();\n+    while (bucket < bucket_at(sz)) {\n+      Node* node = *bucket;\n+      int count = 0;\n+      while (node != NULL) {\n+        literal_bytes += size_function(node->_key, node->_value);\n+        count++;\n+        node = node->_next;\n+      }\n+      summary.add((double)count);\n+      ++bucket;\n+    }\n+    return TableStatistics(summary, literal_bytes, sizeof(Node*), sizeof(Node));\n+  }\n+\n@@ -270,1 +293,1 @@\n-  FixedResourceHashtableStorage() : _table() {}\n+  FixedResourceHashtableStorage() { memset(_table, 0, sizeof(_table)); }\n","filename":"src\/hotspot\/share\/utilities\/resourceHash.hpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,1 +94,1 @@\n-TableStatistics::TableStatistics(TableRateStatistics& rate_stats, NumberSeq summary, size_t literal_bytes, size_t bucket_bytes, size_t node_bytes) :\n+TableStatistics::TableStatistics(NumberSeq summary, size_t literal_bytes, size_t bucket_bytes, size_t node_bytes) :\n@@ -117,0 +117,1 @@\n+}\n@@ -118,0 +119,4 @@\n+TableStatistics::TableStatistics(TableRateStatistics& rate_stats,\n+                                  NumberSeq summary, size_t literal_bytes,\n+                                  size_t bucket_bytes, size_t node_bytes) :\n+  TableStatistics(summary, literal_bytes, bucket_bytes, node_bytes) {\n","filename":"src\/hotspot\/share\/utilities\/tableStatistics.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-class TableRateStatistics : CHeapObj<mtStatistics> {\n+class TableRateStatistics : public CHeapObj<mtStatistics> {\n@@ -85,0 +85,1 @@\n+  TableStatistics(NumberSeq summary, size_t literal_bytes, size_t bucket_bytes, size_t node_bytes);\n","filename":"src\/hotspot\/share\/utilities\/tableStatistics.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -215,2 +215,1 @@\n-        NativeBuffer buffer = NativeBuffers.getNativeBuffer(size);\n-        try {\n+        try (NativeBuffer buffer = NativeBuffers.getNativeBuffer(size)) {\n@@ -246,2 +245,0 @@\n-        } finally {\n-            buffer.release();\n@@ -269,2 +266,1 @@\n-                NativeBuffer buffer = NativeBuffers.asNativeBuffer(value);\n-                try {\n+                try (NativeBuffer buffer = NativeBuffers.asNativeBuffer(value)) {\n@@ -273,2 +269,0 @@\n-                } finally {\n-                    buffer.release();\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxDosFileAttributeView.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,3 +39,2 @@\n-        NativeBuffer pathBuffer = NativeBuffers.asNativeBuffer(filename);\n-        NativeBuffer typeBuffer = NativeBuffers.asNativeBuffer(type);\n-        try {\n+        try (NativeBuffer pathBuffer = NativeBuffers.asNativeBuffer(filename);\n+             NativeBuffer typeBuffer = NativeBuffers.asNativeBuffer(type)) {\n@@ -43,3 +42,0 @@\n-        } finally {\n-            typeBuffer.release();\n-            pathBuffer.release();\n@@ -56,2 +52,1 @@\n-        NativeBuffer buffer = NativeBuffers.getNativeBuffer(buflen);\n-        try {\n+        try (NativeBuffer buffer = NativeBuffers.getNativeBuffer(buflen)) {\n@@ -59,2 +54,0 @@\n-        } finally {\n-            buffer.release();\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxNativeDispatcher.java","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -253,9 +253,4 @@\n-            int wd = -1;\n-            try {\n-                NativeBuffer buffer =\n-                    NativeBuffers.asNativeBuffer(dir.getByteArrayForSysCalls());\n-                try {\n-                    wd = inotifyAddWatch(ifd, buffer.address(), mask);\n-                } finally {\n-                    buffer.release();\n-                }\n+            int wd;\n+            try (NativeBuffer buffer =\n+                 NativeBuffers.asNativeBuffer(dir.getByteArrayForSysCalls())) {\n+                wd = inotifyAddWatch(ifd, buffer.address(), mask);\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxWatchService.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.fs;\n+\n+import java.io.IOException;\n+import java.nio.file.attribute.FileTime;\n+import java.util.concurrent.TimeUnit;\n+import static sun.nio.fs.BsdNativeDispatcher.setattrlist;\n+\n+class BsdFileAttributeViews {\n+    \/\/\n+    \/\/ Use setattrlist(2) system call which can set creation, modification,\n+    \/\/ and access times.\n+    \/\/\n+    private static void setTimes(UnixPath path, FileTime lastModifiedTime,\n+                                 FileTime lastAccessTime, FileTime createTime,\n+                                 boolean followLinks) throws IOException\n+    {\n+        \/\/ null => don't change\n+        if (lastModifiedTime == null && lastAccessTime == null &&\n+            createTime == null) {\n+            \/\/ no effect\n+            return;\n+        }\n+\n+        \/\/ permission check\n+        path.checkWrite();\n+\n+        int commonattr = 0;\n+        long modValue = 0L;\n+        if (lastModifiedTime != null) {\n+            modValue = lastModifiedTime.to(TimeUnit.NANOSECONDS);\n+            commonattr |= UnixConstants.ATTR_CMN_MODTIME;\n+        }\n+        long accValue = 0L;\n+        if (lastAccessTime != null) {\n+            accValue = lastAccessTime.to(TimeUnit.NANOSECONDS);\n+            commonattr |= UnixConstants.ATTR_CMN_ACCTIME;\n+        }\n+        long createValue = 0L;\n+        if (createTime != null) {\n+            createValue = createTime.to(TimeUnit.NANOSECONDS);\n+            commonattr |= UnixConstants.ATTR_CMN_CRTIME;\n+        }\n+\n+        try {\n+            setattrlist(path, commonattr, modValue, accValue, createValue,\n+                        followLinks ?  0 : UnixConstants.FSOPT_NOFOLLOW);\n+        } catch (UnixException x) {\n+            x.rethrowAsIOException(path);\n+        }\n+    }\n+\n+    static class Basic extends UnixFileAttributeViews.Basic {\n+        Basic(UnixPath file, boolean followLinks) {\n+            super(file, followLinks);\n+        }\n+\n+        @Override\n+        public void setTimes(FileTime lastModifiedTime,\n+                             FileTime lastAccessTime,\n+                             FileTime createTime) throws IOException\n+        {\n+            BsdFileAttributeViews.setTimes(file, lastModifiedTime,\n+                                           lastAccessTime, createTime,\n+                                           followLinks);\n+        }\n+    }\n+\n+    static class Posix extends UnixFileAttributeViews.Posix {\n+        Posix(UnixPath file, boolean followLinks) {\n+            super(file, followLinks);\n+        }\n+\n+        @Override\n+        public void setTimes(FileTime lastModifiedTime,\n+                             FileTime lastAccessTime,\n+                             FileTime createTime) throws IOException\n+        {\n+            BsdFileAttributeViews.setTimes(file, lastModifiedTime,\n+                                           lastAccessTime, createTime,\n+                                           followLinks);\n+        }\n+    }\n+\n+    static class Unix extends UnixFileAttributeViews.Unix {\n+        Unix(UnixPath file, boolean followLinks) {\n+            super(file, followLinks);\n+        }\n+\n+        @Override\n+        public void setTimes(FileTime lastModifiedTime,\n+                             FileTime lastAccessTime,\n+                             FileTime createTime) throws IOException\n+        {\n+            BsdFileAttributeViews.setTimes(file, lastModifiedTime,\n+                                           lastAccessTime, createTime,\n+                                           followLinks);\n+        }\n+    }\n+\n+    static Basic createBasicView(UnixPath file, boolean followLinks) {\n+        return new Basic(file, followLinks);\n+    }\n+\n+    static Posix createPosixView(UnixPath file, boolean followLinks) {\n+        return new Posix(file, followLinks);\n+    }\n+\n+    static Unix createUnixView(UnixPath file, boolean followLinks) {\n+        return new Unix(file, followLinks);\n+    }\n+}\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdFileAttributeViews.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,3 +57,15 @@\n-        if (type == UserDefinedFileAttributeView.class) {\n-            return (V) new BsdUserDefinedFileAttributeView(UnixPath.toUnixPath(obj),\n-                    Util.followLinks(options));\n+        if (type == BasicFileAttributeView.class ||\n+            type == PosixFileAttributeView.class ||\n+            type == UserDefinedFileAttributeView.class) {\n+\n+            UnixPath file = UnixPath.toUnixPath(obj);\n+            boolean followLinks = Util.followLinks(options);\n+\n+            if (type == BasicFileAttributeView.class)\n+                return (V) BsdFileAttributeViews.createBasicView(file,\n+                                                                 followLinks);\n+            else if (type == PosixFileAttributeView.class)\n+                return (V) BsdFileAttributeViews.createPosixView(file,\n+                                                                 followLinks);\n+            \/\/ user-defined is the only possibility\n+            return (V) new BsdUserDefinedFileAttributeView(file, followLinks);\n@@ -61,0 +73,1 @@\n+\n@@ -69,3 +82,17 @@\n-        if (name.equals(\"user\")) {\n-            return new BsdUserDefinedFileAttributeView(UnixPath.toUnixPath(obj),\n-                    Util.followLinks(options));\n+        if (name.equals(\"basic\") || name.equals(\"posix\") ||\n+            name.equals(\"unix\")  || name.equals(\"user\")) {\n+\n+            UnixPath file = UnixPath.toUnixPath(obj);\n+            boolean followLinks = Util.followLinks(options);\n+\n+            if (name.equals(\"basic\"))\n+                return BsdFileAttributeViews.createBasicView(file, followLinks);\n+\n+            if (name.equals(\"posix\"))\n+                return BsdFileAttributeViews.createPosixView(file, followLinks);\n+\n+            if (name.equals(\"unix\"))\n+                return BsdFileAttributeViews.createUnixView(file, followLinks);\n+\n+            \/\/ user-defined is the only possibility\n+            return new BsdUserDefinedFileAttributeView(file, followLinks);\n@@ -73,0 +100,1 @@\n+\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdFileSystemProvider.java","additions":35,"deletions":7,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.misc.Blocker;\n+\n@@ -56,2 +58,1 @@\n-        NativeBuffer pathBuffer = copyToNativeBuffer(path);\n-        try {\n+        try (NativeBuffer pathBuffer = copyToNativeBuffer(path)) {\n@@ -59,2 +60,0 @@\n-        } finally {\n-            pathBuffer.release();\n@@ -65,0 +64,23 @@\n+    \/**\n+     * setattrlist(const char* path, struct attrlist* attrList, void* attrBuf,\n+     *             size_t attrBufSize, unsigned long options)\n+     *\/\n+    static void setattrlist(UnixPath path, int commonattr, long modTime,\n+                            long accTime, long createTime, long options)\n+        throws UnixException\n+    {\n+        try (NativeBuffer buffer = copyToNativeBuffer(path)) {\n+            long comp = Blocker.begin();\n+            try {\n+                setattrlist0(buffer.address(), commonattr, modTime, accTime,\n+                             createTime, options);\n+            } finally {\n+                Blocker.end(comp);\n+            }\n+        }\n+    }\n+    private static native void setattrlist0(long pathAddress, int commonattr,\n+                                            long modTime, long accTime,\n+                                            long createTime, long options)\n+        throws UnixException;\n+\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdNativeDispatcher.java","additions":27,"deletions":5,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include <sys\/attr.h>\n@@ -226,0 +227,41 @@\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_fs_BsdNativeDispatcher_setattrlist0(JNIEnv* env, jclass this,\n+    jlong pathAddress, int commonattr, jlong modTime, jlong accTime,\n+    jlong createTime, jlong options)\n+{\n+    const char* path = (const char*)jlong_to_ptr(pathAddress);\n+    \/\/ attributes must align on 4-byte boundaries per the getattrlist(2) spec\n+    const int attrsize = ((sizeof(struct timespec) + 3)\/4)*4;\n+    char buf[3*attrsize];\n+\n+    int count = 0;\n+    \/\/ attributes are ordered per the getattrlist(2) spec\n+    if ((commonattr & ATTR_CMN_CRTIME) != 0) {\n+        struct timespec* t = (struct timespec*)buf;\n+        t->tv_sec   = createTime \/ 1000000000;\n+        t->tv_nsec  = createTime % 1000000000;\n+        count++;\n+    }\n+    if ((commonattr & ATTR_CMN_MODTIME) != 0) {\n+        struct timespec* t = (struct timespec*)(buf + count*attrsize);\n+        t->tv_sec   = modTime \/ 1000000000;\n+        t->tv_nsec  = modTime % 1000000000;\n+        count++;\n+    }\n+    if ((commonattr & ATTR_CMN_ACCTIME) != 0) {\n+        struct timespec* t = (struct timespec*)(buf + count*attrsize);\n+        t->tv_sec   = accTime \/ 1000000000;\n+        t->tv_nsec  = accTime % 1000000000;\n+        count++;\n+    }\n+\n+    struct attrlist attrList;\n+    memset(&attrList, 0, sizeof(struct attrlist));\n+    attrList.bitmapcount = ATTR_BIT_MAP_COUNT;\n+    attrList.commonattr = commonattr;\n+\n+    if (setattrlist(path, &attrList, (void*)buf, count*attrsize, options) != 0) {\n+        throwUnixException(env, errno);\n+    }\n+}\n","filename":"src\/java.base\/macosx\/native\/libnio\/fs\/BsdNativeDispatcher.c","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1349,10 +1349,12 @@\n-        \/\/ This likely needs some refinement. Exploration of hidden\n-        \/\/ classes, array classes.  Location.CLASS allows SUPER and\n-        \/\/ AccessFlag.MODULE which INNER_CLASS forbids. INNER_CLASS\n-        \/\/ allows PRIVATE, PROTECTED, and STATIC, which are not\n-        \/\/ allowed on Location.CLASS.\n-        return AccessFlag.maskToAccessFlags(getModifiers(),\n-                                            (isMemberClass() || isLocalClass() ||\n-                                             isAnonymousClass() || isArray()) ?\n-                                            AccessFlag.Location.INNER_CLASS :\n-                                            AccessFlag.Location.CLASS);\n+        \/\/ Location.CLASS allows SUPER and AccessFlag.MODULE which\n+        \/\/ INNER_CLASS forbids. INNER_CLASS allows PRIVATE, PROTECTED,\n+        \/\/ and STATIC, which are not allowed on Location.CLASS.\n+        \/\/ Use getClassAccessFlagsRaw to expose SUPER status.\n+        var location = (isMemberClass() || isLocalClass() ||\n+                        isAnonymousClass() || isArray()) ?\n+            AccessFlag.Location.INNER_CLASS :\n+            AccessFlag.Location.CLASS;\n+        return AccessFlag.maskToAccessFlags((location == AccessFlag.Location.CLASS) ?\n+                                            getClassAccessFlagsRaw() :\n+                                            getModifiers(),\n+                                            location);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.util.StringJoiner;\n@@ -1117,4 +1116,0 @@\n-                StringJoiner command = new StringJoiner(\" \");\n-                for (String s: cmdarray) {\n-                    command.add(s);\n-                }\n@@ -1122,1 +1117,1 @@\n-                event.command = command.toString();\n+                event.command = String.join(\" \", cmdarray);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ProcessBuilder.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.lang.module.ModuleDescriptor.Version;\n@@ -55,0 +54,3 @@\n+    private static final String NATIVE_METHOD = \"Native Method\";\n+    private static final String UNKNOWN_SOURCE = \"Unknown Source\";\n+\n@@ -358,0 +360,1 @@\n+    @Override\n@@ -359,4 +362,11 @@\n-        String s = \"\";\n-        if (!dropClassLoaderName() && classLoaderName != null &&\n-                !classLoaderName.isEmpty()) {\n-            s += classLoaderName + \"\/\";\n+        int estimatedLength = length(classLoaderName) + 1\n+                + length(moduleName) + 1\n+                + length(moduleVersion) + 1\n+                + declaringClass.length() + 1\n+                + methodName.length() + 1\n+                + Math.max(UNKNOWN_SOURCE.length(), length(fileName)) + 1\n+                + 12;\n+\n+        StringBuilder sb = new StringBuilder(estimatedLength);\n+        if (!dropClassLoaderName() && classLoaderName != null && !classLoaderName.isEmpty()) {\n+            sb.append(classLoaderName).append('\/');\n@@ -364,0 +374,1 @@\n+\n@@ -365,1 +376,5 @@\n-            s += moduleName;\n+            sb.append(moduleName);\n+            if (!dropModuleVersion() && moduleVersion != null && !moduleVersion.isEmpty()) {\n+                sb.append('@').append(moduleVersion);\n+            }\n+        }\n@@ -367,3 +382,13 @@\n-            if (!dropModuleVersion() && moduleVersion != null &&\n-                    !moduleVersion.isEmpty()) {\n-                s += \"@\" + moduleVersion;\n+        if (sb.length() > 0) {\n+            sb.append('\/');\n+        }\n+\n+        sb.append(declaringClass).append('.').append(methodName).append('(');\n+        if (isNativeMethod()) {\n+            sb.append(NATIVE_METHOD);\n+        } else if (fileName == null) {\n+            sb.append(UNKNOWN_SOURCE);\n+        } else {\n+            sb.append(fileName);\n+            if (lineNumber >= 0) {\n+                sb.append(':').append(lineNumber);\n@@ -372,1 +397,4 @@\n-        s = s.isEmpty() ? declaringClass : s + \"\/\" + declaringClass;\n+        sb.append(')');\n+\n+        return sb.toString();\n+    }\n@@ -374,5 +402,2 @@\n-        return s + \".\" + methodName + \"(\" +\n-             (isNativeMethod() ? \"Native Method)\" :\n-              (fileName != null && lineNumber >= 0 ?\n-               fileName + \":\" + lineNumber + \")\" :\n-                (fileName != null ?  \"\"+fileName+\")\" : \"Unknown Source)\")));\n+    private static int length(String s) {\n+        return (s == null) ? 0 : s.length();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StackTraceElement.java","additions":40,"deletions":15,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -216,2 +216,4 @@\n-         * {@return an unmodifiable set of the module {@linkplain AccessFlag\n-         * requires flags, possibly empty}}\n+         * Returns the set of the module {@linkplain AccessFlag\n+         * requires flags}.\n+         *\n+         * @return A possibly-empty unmodifiable set of requires flags\n@@ -450,2 +452,4 @@\n-         * {@return an unmodifiable set of the module {@linkplain AccessFlag\n-         * export flags} for this module descriptor, possibly empty}\n+         * Returns the set of the module {@linkplain AccessFlag\n+         * export flags} for this module descriptor.\n+         *\n+         * @return A possibly-empty unmodifiable set of export flags\n@@ -672,2 +676,4 @@\n-         * {@return an unmodifiable set of the module {@linkplain AccessFlag\n-         * opens flags}, possibly empty}\n+         * Returns the set of the module {@linkplain AccessFlag opens\n+         * flags}.\n+         *\n+         * @return A possibly-empty unmodifiable set of opens flags\n@@ -1357,2 +1363,3 @@\n-     * {@return an unmodifiable set of the {@linkplain AccessFlag\n-     * module flags}, possibly empty}\n+     * Returns the set of the {@linkplain AccessFlag module flags}.\n+     *\n+     * @return A possibly-empty unmodifiable set of module flags\n@@ -2630,1 +2637,1 @@\n-            h = h * 43 + Objects.hashCode(e.name());\n+            h += e.name().hashCode();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/module\/ModuleDescriptor.java","additions":16,"deletions":9,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.function.Function;\n@@ -73,1 +74,1 @@\n- * The JVM class file format has a new version defined for each new\n+ * The JVM class file format has a {@linkplain ClassFileFormatVersion new version} defined for each new\n@@ -94,0 +95,5 @@\n+    \/\/ Note to maintainers: anonymous class instances are used rather\n+    \/\/ than lambdas to initialize the functions used for the\n+    \/\/ cffvToLocations field to avoid using lambdas too early in JDK\n+    \/\/ initialization.\n+\n@@ -96,1 +102,1 @@\n-     * modifier {@link Modifier#PUBLIC public} with a mask value of\n+     * modifier {@link Modifier#PUBLIC public}, with a mask value of\n@@ -100,2 +106,9 @@\n-           Set.of(Location.CLASS, Location.FIELD, Location.METHOD,\n-                  Location.INNER_CLASS)),\n+           Location.SET_PUBLIC_1,\n+           new Function<ClassFileFormatVersion, Set<Location>>() {\n+               @Override\n+               public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                   return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n+                       Location.SET_CLASS_FIELD_METHOD:\n+                       Location.SET_PUBLIC_1;\n+               }\n+           }),\n@@ -105,1 +118,1 @@\n-     * source modifier {@link Modifier#PRIVATE private} with a mask\n+     * source modifier {@link Modifier#PRIVATE private}, with a mask\n@@ -108,1 +121,9 @@\n-    PRIVATE(Modifier.PRIVATE, true, Location.SET_FIELD_METHOD_INNER_CLASS),\n+    PRIVATE(Modifier.PRIVATE, true, Location.SET_FIELD_METHOD_INNER_CLASS,\n+            new Function<ClassFileFormatVersion, Set<Location>>() {\n+                @Override\n+                    public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                    return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n+                        Location.SET_FIELD_METHOD:\n+                        Location.SET_FIELD_METHOD_INNER_CLASS;\n+                }\n+            }),\n@@ -112,1 +133,1 @@\n-     * source modifier {@link Modifier#PROTECTED protected} with a mask\n+     * source modifier {@link Modifier#PROTECTED protected}, with a mask\n@@ -115,1 +136,9 @@\n-    PROTECTED(Modifier.PROTECTED, true, Location.SET_FIELD_METHOD_INNER_CLASS),\n+    PROTECTED(Modifier.PROTECTED, true, Location.SET_FIELD_METHOD_INNER_CLASS,\n+              new Function<ClassFileFormatVersion, Set<Location>>() {\n+                  @Override\n+                  public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                  return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n+                      Location.SET_FIELD_METHOD:\n+                      Location.SET_FIELD_METHOD_INNER_CLASS;\n+                  }\n+              }),\n@@ -119,1 +148,1 @@\n-     * modifier {@link Modifier#STATIC static} with a mask value of\n+     * modifier {@link Modifier#STATIC static}, with a mask value of\n@@ -122,1 +151,8 @@\n-    STATIC(Modifier.STATIC, true, Location.SET_FIELD_METHOD_INNER_CLASS),\n+    STATIC(Modifier.STATIC, true, Location.SET_FIELD_METHOD_INNER_CLASS,\n+           new Function<ClassFileFormatVersion, Set<Location>>() {\n+               @Override\n+               public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                   return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n+                       Location.SET_FIELD_METHOD:\n+                       Location.SET_FIELD_METHOD_INNER_CLASS;}\n+           }),\n@@ -126,1 +162,1 @@\n-     * modifier {@link Modifier#FINAL final} with a mask\n+     * modifier {@link Modifier#FINAL final}, with a mask\n@@ -130,2 +166,13 @@\n-          Set.of(Location.CLASS, Location.FIELD, Location.METHOD,\n-                 Location.INNER_CLASS, Location.METHOD_PARAMETER)),\n+          Location.SET_FINAL_8,\n+           new Function<ClassFileFormatVersion, Set<Location>>() {\n+              @Override\n+              public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                  if (cffv.compareTo(ClassFileFormatVersion.RELEASE_8) >= 0) {\n+                      return Location.SET_FINAL_8;\n+                  } else {\n+                      return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n+                          Location.SET_CLASS_FIELD_METHOD :\n+                          Location.SET_CLASS_FIELD_METHOD_INNER_CLASS;\n+                  }\n+              }\n+          }),\n@@ -141,1 +188,1 @@\n-    SUPER(0x0000_0020, false, Location.SET_CLASS),\n+    SUPER(0x0000_0020, false, Location.SET_CLASS, null),\n@@ -148,1 +195,8 @@\n-    OPEN(0x0000_0020, false, Set.of(Location.MODULE)),\n+        OPEN(0x0000_0020, false, Location.SET_MODULE,\n+             new Function<ClassFileFormatVersion, Set<Location>>() {\n+                 @Override\n+                 public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                     return (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) ?\n+                         Location.SET_MODULE:\n+                         Location.EMPTY_SET;}\n+             }),\n@@ -155,1 +209,8 @@\n-    TRANSITIVE(0x0000_0020, false, Location.SET_MODULE_REQUIRES),\n+    TRANSITIVE(0x0000_0020, false, Location.SET_MODULE_REQUIRES,\n+               new Function<ClassFileFormatVersion, Set<Location>>() {\n+                   @Override\n+                   public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                       return (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) ?\n+                           Location.SET_MODULE_REQUIRES:\n+                           Location.EMPTY_SET;}\n+               }),\n@@ -159,1 +220,1 @@\n-     * source modifier {@link Modifier#SYNCHRONIZED synchronized} with\n+     * source modifier {@link Modifier#SYNCHRONIZED synchronized}, with\n@@ -162,1 +223,1 @@\n-    SYNCHRONIZED(Modifier.SYNCHRONIZED, true, Location.SET_METHOD),\n+    SYNCHRONIZED(Modifier.SYNCHRONIZED, true, Location.SET_METHOD, null),\n@@ -169,8 +230,15 @@\n-    STATIC_PHASE(0x0000_0040, false, Location.SET_MODULE_REQUIRES),\n-\n-     \/**\n-      * The access flag {@code ACC_VOLATILE}, corresponding to the\n-      * source modifier {@link Modifier#VOLATILE volatile} with a mask\n-      * value of <code>{@value \"0x%04x\" Modifier#VOLATILE}<\/code>.\n-      *\/\n-    VOLATILE(Modifier.VOLATILE, true, Location.SET_FIELD),\n+    STATIC_PHASE(0x0000_0040, false, Location.SET_MODULE_REQUIRES,\n+                 new Function<ClassFileFormatVersion, Set<Location>>() {\n+                     @Override\n+                     public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                         return (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) ?\n+                             Location.SET_MODULE_REQUIRES:\n+                             Location.EMPTY_SET;}\n+                 }),\n+\n+   \/**\n+     * The access flag {@code ACC_VOLATILE}, corresponding to the\n+     * source modifier {@link Modifier#VOLATILE volatile}, with a mask\n+     * value of <code>{@value \"0x%04x\" Modifier#VOLATILE}<\/code>.\n+     *\/\n+    VOLATILE(Modifier.VOLATILE, true, Location.SET_FIELD, null),\n@@ -183,1 +251,8 @@\n-    BRIDGE(Modifier.BRIDGE, false, Location.SET_METHOD),\n+    BRIDGE(Modifier.BRIDGE, false, Location.SET_METHOD,\n+           new Function<ClassFileFormatVersion, Set<Location>>() {\n+               @Override\n+               public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                   return (cffv.compareTo(ClassFileFormatVersion.RELEASE_5) >= 0 ) ?\n+                       Location.SET_METHOD:\n+                       Location.EMPTY_SET;}\n+           }),\n@@ -187,1 +262,1 @@\n-     * source modifier {@link Modifier#TRANSIENT transient} with a\n+     * source modifier {@link Modifier#TRANSIENT transient}, with a\n@@ -190,1 +265,1 @@\n-    TRANSIENT(Modifier.TRANSIENT, true, Location.SET_FIELD),\n+    TRANSIENT(Modifier.TRANSIENT, true, Location.SET_FIELD, null),\n@@ -197,1 +272,8 @@\n-    VARARGS(Modifier.VARARGS, false, Location.SET_METHOD),\n+    VARARGS(Modifier.VARARGS, false, Location.SET_METHOD,\n+            new Function<ClassFileFormatVersion, Set<Location>>() {\n+                @Override\n+                public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                    return (cffv.compareTo(ClassFileFormatVersion.RELEASE_5) >= 0 ) ?\n+                        Location.SET_METHOD:\n+                        Location.EMPTY_SET;}\n+            }),\n@@ -201,1 +283,1 @@\n-     * modifier {@link Modifier#NATIVE native} with a mask value of\n+     * modifier {@link Modifier#NATIVE native}, with a mask value of\n@@ -204,1 +286,1 @@\n-    NATIVE(Modifier.NATIVE, true, Location.SET_METHOD),\n+    NATIVE(Modifier.NATIVE, true, Location.SET_METHOD, null),\n@@ -211,1 +293,8 @@\n-    INTERFACE(Modifier.INTERFACE, false, Location.SET_CLASS_INNER_CLASS),\n+    INTERFACE(Modifier.INTERFACE, false, Location.SET_CLASS_INNER_CLASS,\n+              new Function<ClassFileFormatVersion, Set<Location>>() {\n+                  @Override\n+                  public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                      return (cffv.compareTo(ClassFileFormatVersion.RELEASE_0) == 0 ) ?\n+                          Location.SET_CLASS:\n+                          Location.SET_CLASS_INNER_CLASS;}\n+              }),\n@@ -215,1 +304,1 @@\n-     * source modifier {@link Modifier#ABSTRACT abstract} with a mask\n+     * source modifier {@link Modifier#ABSTRACT abstract}, with a mask\n@@ -219,1 +308,8 @@\n-             Set.of(Location.CLASS, Location.METHOD, Location.INNER_CLASS)),\n+             Location.SET_CLASS_METHOD_INNER_CLASS,\n+             new Function<ClassFileFormatVersion, Set<Location>>() {\n+                 @Override\n+                 public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                     return (cffv.compareTo(ClassFileFormatVersion.RELEASE_0) == 0 ) ?\n+                         Location.SET_CLASS_METHOD:\n+                         Location.SET_CLASS_METHOD_INNER_CLASS;}\n+             }),\n@@ -223,1 +319,1 @@\n-     * modifier {@link Modifier#STRICT strictfp} with a mask value of\n+     * modifier {@link Modifier#STRICT strictfp}, with a mask value of\n@@ -231,1 +327,9 @@\n-    STRICT(Modifier.STRICT, true, Location.SET_METHOD),\n+    STRICT(Modifier.STRICT, true, Location.SET_METHOD,\n+             new Function<ClassFileFormatVersion, Set<Location>>() {\n+               @Override\n+               public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                   return (cffv.compareTo(ClassFileFormatVersion.RELEASE_2)  >= 0 &&\n+                           cffv.compareTo(ClassFileFormatVersion.RELEASE_16) <= 0) ?\n+                       Location.SET_METHOD:\n+                       Location.EMPTY_SET;}\n+           }),\n@@ -240,5 +344,16 @@\n-    SYNTHETIC(Modifier.SYNTHETIC, false,\n-              Set.of(Location.CLASS, Location.FIELD, Location.METHOD,\n-                     Location.INNER_CLASS, Location.METHOD_PARAMETER,\n-                     Location.MODULE, Location.MODULE_REQUIRES,\n-                     Location.MODULE_EXPORTS, Location.MODULE_OPENS)),\n+    SYNTHETIC(Modifier.SYNTHETIC, false, Location.SET_SYNTHETIC_9,\n+              new Function<ClassFileFormatVersion, Set<Location>>() {\n+                  @Override\n+                  public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                      if (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 )\n+                          return Location.SET_SYNTHETIC_9;\n+                      else {\n+                          return\n+                              switch(cffv) {\n+                              case RELEASE_7 -> Location.SET_SYNTHETIC_7;\n+                              case RELEASE_8 -> Location.SET_SYNTHETIC_8;\n+                              default        -> Location.EMPTY_SET;\n+                              };\n+                      }\n+                  }\n+              }),\n@@ -251,1 +366,8 @@\n-    ANNOTATION(Modifier.ANNOTATION, false, Location.SET_CLASS_INNER_CLASS),\n+    ANNOTATION(Modifier.ANNOTATION, false, Location.SET_CLASS_INNER_CLASS,\n+               new Function<ClassFileFormatVersion, Set<Location>>() {\n+                   @Override\n+                   public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                       return (cffv.compareTo(ClassFileFormatVersion.RELEASE_5) >= 0 ) ?\n+                           Location.SET_CLASS_INNER_CLASS:\n+                           Location.EMPTY_SET;}\n+               }),\n@@ -258,2 +380,8 @@\n-    ENUM(Modifier.ENUM, false,\n-         Set.of(Location.CLASS, Location.FIELD, Location.INNER_CLASS)),\n+    ENUM(Modifier.ENUM, false, Location.SET_CLASS_FIELD_INNER_CLASS,\n+         new Function<ClassFileFormatVersion, Set<Location>>() {\n+             @Override\n+             public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                 return (cffv.compareTo(ClassFileFormatVersion.RELEASE_5) >= 0 ) ?\n+                     Location.SET_CLASS_FIELD_INNER_CLASS:\n+                     Location.EMPTY_SET;}\n+         }),\n@@ -265,4 +393,13 @@\n-    MANDATED(Modifier.MANDATED, false,\n-             Set.of(Location.METHOD_PARAMETER,\n-                    Location.MODULE, Location.MODULE_REQUIRES,\n-                    Location.MODULE_EXPORTS, Location.MODULE_OPENS)),\n+    MANDATED(Modifier.MANDATED, false, Location.SET_MANDATED_9,\n+             new Function<ClassFileFormatVersion, Set<Location>>() {\n+                 @Override\n+                 public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                     if (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) {\n+                         return Location.SET_MANDATED_9;\n+                     } else {\n+                         return (cffv == ClassFileFormatVersion.RELEASE_8) ?\n+                             Location.SET_METHOD_PARAM:\n+                             Location.EMPTY_SET;\n+                     }\n+                 }\n+             }),\n@@ -274,1 +411,8 @@\n-    MODULE(0x0000_8000, false, Location.SET_CLASS)\n+    MODULE(0x0000_8000, false, Location.SET_CLASS,\n+           new Function<ClassFileFormatVersion, Set<Location>>() {\n+               @Override\n+               public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                   return (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) ?\n+                       Location.SET_CLASS:\n+                       Location.EMPTY_SET;}\n+           })\n@@ -286,0 +430,2 @@\n+    \/\/ Lambda to implement locations(ClassFileFormatVersion cffv)\n+    private final Function<ClassFileFormatVersion, Set<Location>> cffvToLocations;\n@@ -287,1 +433,4 @@\n-    private AccessFlag(int mask, boolean sourceModifier, Set<Location> locations) {\n+    private AccessFlag(int mask,\n+                       boolean sourceModifier,\n+                       Set<Location> locations,\n+                       Function<ClassFileFormatVersion, Set<Location>> cffvToLocations) {\n@@ -291,0 +440,1 @@\n+        this.cffvToLocations = cffvToLocations;\n@@ -309,1 +459,2 @@\n-     * {@return kinds of constructs the flag can be applied to}\n+     * {@return kinds of constructs the flag can be applied to in the\n+     * latest class file format version}\n@@ -315,0 +466,14 @@\n+    \/**\n+     * {@return kinds of constructs the flag can be applied to in the\n+     * given class file format version}\n+     * @param cffv the class file format version to use\n+     * @throws NullPointerException if the parameter is {@code null}\n+     *\/\n+    public Set<Location> locations(ClassFileFormatVersion cffv) {\n+        if (cffvToLocations == null) {\n+            return locations;\n+        } else {\n+            return cffvToLocations.apply(cffv);\n+        }\n+    }\n+\n@@ -405,0 +570,14 @@\n+        private static final Set<Location> EMPTY_SET = Set.of();\n+        private static final Set<Location> SET_MODULE = Set.of(MODULE);\n+        private static final Set<Location> SET_CLASS_METHOD_INNER_CLASS =\n+            Set.of(CLASS, METHOD, INNER_CLASS);\n+        private static final Set<Location> SET_CLASS_FIELD_METHOD =\n+            Set.of(CLASS, FIELD, METHOD);\n+        private static final Set<Location> SET_CLASS_FIELD_INNER_CLASS =\n+            Set.of(CLASS, FIELD, INNER_CLASS);\n+        private static final Set<Location> SET_CLASS_FIELD_METHOD_INNER_CLASS =\n+            Set.of(CLASS, FIELD, METHOD, INNER_CLASS);\n+        private static final Set<Location> SET_CLASS_METHOD =\n+            Set.of(CLASS, METHOD);\n+        private static final Set<Location> SET_FIELD_METHOD =\n+            Set.of(FIELD, METHOD);\n@@ -408,0 +587,1 @@\n+        private static final Set<Location> SET_METHOD_PARAM = Set.of(METHOD_PARAMETER);\n@@ -414,0 +594,25 @@\n+        private static final Set<Location> SET_PUBLIC_1 =\n+            Set.of(CLASS, FIELD, METHOD, INNER_CLASS);\n+        private static final Set<Location> SET_FINAL_8 =\n+            Set.of(CLASS, FIELD, METHOD,\n+                   INNER_CLASS,     \/* added in 1.1 *\/\n+                   METHOD_PARAMETER); \/* added in 8 *\/\n+        private static final Set<Location> SET_SYNTHETIC_7 =\n+              Set.of(CLASS, FIELD, METHOD,\n+                     INNER_CLASS);\n+        private static final Set<Location> SET_SYNTHETIC_8 =\n+              Set.of(CLASS, FIELD, METHOD,\n+                     INNER_CLASS, METHOD_PARAMETER);\n+        private static final Set<Location> SET_SYNTHETIC_9 =\n+              \/\/ Added as an access flag in 7\n+              Set.of(CLASS, FIELD, METHOD,\n+                     INNER_CLASS,\n+                     METHOD_PARAMETER, \/\/ Added in 8\n+                     \/\/ Module-related items added in 9\n+                     MODULE, MODULE_REQUIRES,\n+                     MODULE_EXPORTS, MODULE_OPENS);\n+        private static final Set<Location> SET_MANDATED_9 =\n+            Set.of(METHOD_PARAMETER, \/\/ From 8\n+                   \/\/ Starting in 9\n+                   MODULE, MODULE_REQUIRES,\n+                   MODULE_EXPORTS, MODULE_OPENS);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessFlag.java","additions":257,"deletions":52,"binary":false,"changes":309,"status":"modified"},{"patch":"@@ -0,0 +1,353 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect;\n+\n+\/**\n+ * Class file format versions of the Java virtual machine.\n+ *\n+ * See the appropriate edition of <cite>The Java Virtual Machine\n+ * Specification<\/cite> for information about a particular class file\n+ * format version.\n+ *\n+ * <p>Note that additional class file format version constants will be\n+ * added to model future releases of the Java Virtual Machine\n+ * Specification.\n+ *\n+ * @since 20\n+ * @see System#getProperties System property {@code java.class.version}\n+ * @see java.compiler\/javax.lang.model.SourceVersion\n+ *\/\n+@SuppressWarnings(\"doclint:reference\") \/\/ cross-module links\n+public enum ClassFileFormatVersion {\n+\n+    \/**\n+     * The original version.\n+     *\n+     * The format described in <cite>The Java Virtual Specification,\n+     * First Edition<\/cite>.\n+     *\/\n+    RELEASE_0(45),\n+\n+    \/**\n+     * The version recognized by the Java Platform 1.1.\n+     *\n+     * @apiNote\n+     * While {@code RELEASE_0} and {@code RELEASE_1} have the same\n+     * {@linkplain #major() major version}, several additional\n+     * attributes were defined for {@code RELEASE_1} (JVMS {@jvms\n+     * 4.7}).\n+     *\n+     *\/\n+    RELEASE_1(45),\n+\n+    \/**\n+     * The version recognized by the Java 2 Platform, Standard Edition,\n+     * v 1.2.\n+     *\n+     * The format described in <cite>The Java Virtual Machine\n+     * Specification, Second Edition<\/cite>, which includes the {@link\n+     * AccessFlag#STRICT ACC_STRICT} access flag.\n+     *\/\n+    RELEASE_2(46),\n+\n+    \/**\n+     * The version recognized by the Java 2 Platform, Standard Edition,\n+     * v 1.3.\n+     *\/\n+    RELEASE_3(47),\n+\n+    \/**\n+     * The version recognized by the Java 2 Platform, Standard Edition,\n+     * v 1.4.\n+     *\/\n+    RELEASE_4(48),\n+\n+    \/**\n+     * The version recognized by the Java 2 Platform, Standard\n+     * Edition 5.0.\n+     *\n+     * @see <a\n+     * href=\"https:\/\/jcp.org\/aboutJava\/communityprocess\/maintenance\/jsr924\/index.html\">\n+     * <cite>The Java Virtual Machine Specification, Second Edition updated for Java SE 5.0<\/cite><\/a>\n+     * @see <a href=\"https:\/\/jcp.org\/en\/jsr\/detail?id=14\">\n+     * JSR 14: Add Generic Types To The Java&trade; Programming Language<\/a>\n+     * @see <a href=\"https:\/\/jcp.org\/en\/jsr\/detail?id=175\">\n+     * JSR 175: A Metadata Facility for the Java&trade; Programming Language<\/a>\n+     *\/\n+    RELEASE_5(49),\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 6.\n+     *\n+     * @see <a\n+     * href=\"https:\/\/jcp.org\/aboutJava\/communityprocess\/maintenance\/jsr924\/index2.html\">\n+     * <cite>The Java Virtual Machine Specification, Java SE, Second Edition updated for Java SE 6<\/cite><\/a>\n+     *\/\n+    RELEASE_6(50),\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 7.\n+     *\n+     * @see <a\n+     * href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se7\/html\/index.html\">\n+     * <cite>The Java Virtual Machine Specification, Java SE 7 Edition<\/cite><\/a>\n+     *\/\n+    RELEASE_7(51),\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 8.\n+     *\n+     * @see <a\n+     * href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/index.html\">\n+     * <cite>The Java Virtual Machine Specification, Java SE 8 Edition<\/cite><\/a>\n+     * @see <a href=\"https:\/\/jcp.org\/en\/jsr\/detail?id=335\">\n+     * JSR 335: Lambda Expressions for the Java&trade; Programming Language<\/a>\n+     *\/\n+    RELEASE_8(52),\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 9.\n+     *\n+     * @see <a\n+     * href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/index.html\">\n+     * <cite>The Java Virtual Machine Specification, Java SE 9 Edition<\/cite><\/a>\n+     * @see <a href=\"https:\/\/jcp.org\/en\/jsr\/detail?id=376\">\n+     * JSR 376: Java&trade; Platform Module System<\/a>\n+     *\/\n+     RELEASE_9(53),\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 10.\n+     *\n+     * @see <a\n+     * href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se10\/html\/index.html\">\n+     * <cite>The Java Virtual Machine Specification, Java SE 10 Edition<\/cite><\/a>\n+     *\/\n+    RELEASE_10(54),\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 11.\n+     *\n+     * @see <a\n+     * href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se11\/html\/index.html\">\n+     * <cite>The Java Virtual Machine Specification, Java SE 11 Edition<\/cite><\/a>\n+     * @see <a href=\"https:\/\/openjdk.java.net\/jeps\/181\">\n+     * JEP 181: Nest-Based Access Control<\/a>\n+     *\/\n+    RELEASE_11(55),\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 12.\n+     *\n+     * @see <a\n+     * href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se12\/html\/index.html\">\n+     * <cite>The Java Virtual Machine Specification, Java SE 12 Edition<\/cite><\/a>\n+     *\/\n+    RELEASE_12(56),\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 13.\n+     *\n+     * @see <a\n+     * href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se13\/html\/index.html\">\n+     * <cite>The Java Virtual Machine Specification, Java SE 13 Edition<\/cite><\/a>\n+     *\/\n+    RELEASE_13(57),\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 14.\n+     *\n+     * @see <a\n+     * href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se14\/html\/index.html\">\n+     * <cite>The Java Virtual Machine Specification, Java SE 14 Edition<\/cite><\/a>\n+     *\/\n+    RELEASE_14(58),\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 15.\n+     *\n+     * @see <a\n+     * href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se15\/html\/index.html\">\n+     * <cite>The Java Virtual Machine Specification, Java SE 15 Edition<\/cite><\/a>\n+     * @see <a href=\"https:\/\/openjdk.java.net\/jeps\/371\">\n+     * JEP 371: Hidden Classes<\/a>\n+     *\/\n+    RELEASE_15(59),\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 16.\n+     *\n+     * @see <a\n+     * href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se16\/html\/index.html\">\n+     * <cite>The Java Virtual Machine Specification, Java SE 16 Edition<\/cite><\/a>\n+     *\/\n+    RELEASE_16(60),\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 17.\n+     *\n+     * Additions in this release include sealed classes and\n+     * restoration of always-strict floating-point semantics.\n+     *\n+     * @see <a\n+     * href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se17\/html\/index.html\">\n+     * <cite>The Java Virtual Machine Specification, Java SE 17 Edition<\/cite><\/a>\n+     * @see <a href=\"https:\/\/openjdk.java.net\/jeps\/306\">\n+     * JEP 306: Restore Always-Strict Floating-Point Semantics<\/a>\n+     * @see <a href=\"https:\/\/openjdk.java.net\/jeps\/409\">\n+     * JEP 409: Sealed Classes<\/a>\n+     *\/\n+    RELEASE_17(61),\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 18.\n+     *\n+     * @see <a\n+     * href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se18\/html\/index.html\">\n+     * <cite>The Java Virtual Machine Specification, Java SE 18 Edition<\/cite><\/a>\n+     *\/\n+    RELEASE_18(62),\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 19.\n+     *\/\n+    RELEASE_19(63),\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 20.\n+     *\/\n+    RELEASE_20(64);\n+\n+    \/\/ Note to maintainers: when adding constants for newer releases,\n+    \/\/ the implementation of latest() must be updated too.\n+\n+    private final int major;\n+\n+    private ClassFileFormatVersion(int major) {\n+        this.major = major;\n+    }\n+\n+    \/**\n+     * {@return the latest class file format version}\n+     *\/\n+    public static ClassFileFormatVersion latest() {\n+        return RELEASE_20;\n+    }\n+\n+    \/**\n+     * {@return the major class file version as an integer}\n+     * @jvms 4.1 The {@code ClassFile} Structure\n+     *\/\n+    public int major() {\n+        return major;\n+    }\n+\n+    \/**\n+     * {@return the latest class file format version that is usable\n+     * under the runtime version argument} If the runtime version's\n+     * {@linkplain Runtime.Version#feature() feature} is greater than\n+     * the feature of the {@linkplain #runtimeVersion() runtime\n+     * version} of the {@linkplain #latest() latest class file format\n+     * version}, an {@code IllegalArgumentException} is thrown.\n+     *\n+     * <p>Because the class file format versions of the Java platform\n+     * have so far followed a linear progression, only the feature\n+     * component of a runtime version is queried to determine the\n+     * mapping to a class file format version. If that linearity\n+     * changes in the future, other components of the runtime version\n+     * may influence the result.\n+     *\n+     * @apiNote\n+     * An expression to convert from a string value, for example\n+     * {@code \"17\"}, to the corresponding class file format version,\n+     * {@code RELEASE_17}, is:\n+     *\n+     * {@snippet lang=\"java\" :\n+     * ClassFileFormatVersion.valueOf(Runtime.Version.parse(\"17\"))}\n+     *\n+     * @param rv runtime version to map to a class file format version\n+     * @throws IllegalArgumentException if the feature of version\n+     * argument is greater than the feature of the platform version.\n+     *\/\n+    public static ClassFileFormatVersion valueOf(Runtime.Version rv) {\n+        \/\/ Could also implement this as a switch where a case was\n+        \/\/ added with each new release.\n+        return valueOf(\"RELEASE_\" + rv.feature());\n+    }\n+\n+    \/**\n+     * {@return the least runtime version that supports this class\n+     * file format version; otherwise {@code null}} The returned\n+     * runtime version has a {@linkplain Runtime.Version#feature()\n+     * feature} large enough to support this class file format version\n+     * and has no other elements set.\n+     *\n+     * Class file format versions greater than or equal to {@link\n+     * RELEASE_6} have non-{@code null} results.\n+     *\/\n+    public Runtime.Version runtimeVersion() {\n+        \/\/ Starting with Java SE 6, the leading digit was the primary\n+        \/\/ way of identifying the platform version.\n+        if (this.compareTo(RELEASE_6) >= 0) {\n+            return Runtime.Version.parse(Integer.toString(ordinal()));\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    \/**\n+     * {@return the latest class file format version whose major class\n+     * file version matches the argument}\n+     * @param major the major class file version as an integer\n+     * @throws IllegalArgumentException if the argument is outside of\n+     * the range of major class file versions\n+     *\/\n+    public static ClassFileFormatVersion fromMajor(int major) {\n+        if (major < 45  \/\/ RELEASE_0.major()\n+            || major > latest().major()) {\n+            throw new IllegalArgumentException(\"Out of range major class file vesion \"\n+                                               + major);\n+        }\n+        \/\/ RELEASE_0 and RELEASE_1 both have a major version of 45;\n+        \/\/ return RELEASE_1 for an argument of 45.\n+        return values()[major-44];\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ClassFileFormatVersion.java","additions":353,"deletions":0,"binary":false,"changes":353,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -307,1 +307,2 @@\n-     * where {@code ':'} stands for itself.\n+     * where <i>syntax<\/i> is the non-empty name of the syntax, <i>pattern<\/i>\n+     * is a possibly-empty pattern string, and {@code ':'} stands for itself.\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/FileSystem.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -54,0 +54,10 @@\n+ * @implNote This implementation only updates the message digest\n+ *      with data actually read from the input stream when it is\n+ *      {@linkplain #on(boolean) turned on}. This includes the various\n+ *      {@code read} methods, {@code transferTo}, {@code readAllBytes},\n+ *      and {@code readNBytes}. Please note that data bypassed by the\n+ *      {@code skip} method are ignored. On the other hand,\n+ *      if the underlying stream supports the {@code mark} and\n+ *      {@code reset} methods, and the same data is read again after\n+ *      {@code reset}, then the message digest is updated again.\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/security\/DigestInputStream.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -50,0 +50,3 @@\n+ * @implNote If the properties file fails to load, the JDK implementation will\n+ * throw an unspecified error when initializing the {@code Security} class.\n+ *\n@@ -186,5 +189,1 @@\n-            initializeStatic();\n-            if (sdebug != null) {\n-                sdebug.println(\"unable to load security properties \" +\n-                        \"-- using defaults\");\n-            }\n+            throw new InternalError(\"java.security file missing\");\n@@ -195,13 +194,0 @@\n-    \/*\n-     * Initialize to default values, if <java.home>\/lib\/java.security\n-     * is not found.\n-     *\/\n-    private static void initializeStatic() {\n-        props.put(\"security.provider.1\", \"sun.security.provider.Sun\");\n-        props.put(\"security.provider.2\", \"sun.security.rsa.SunRsaSign\");\n-        props.put(\"security.provider.3\", \"sun.security.ssl.SunJSSE\");\n-        props.put(\"security.provider.4\", \"com.sun.crypto.provider.SunJCE\");\n-        props.put(\"security.provider.5\", \"sun.security.jgss.SunProvider\");\n-        props.put(\"security.provider.6\", \"com.sun.security.sasl.Provider\");\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/security\/Security.java","additions":4,"deletions":18,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2581,0 +2581,3 @@\n+        if (numMappings < 0) {\n+            throw new IllegalArgumentException(\"Negative number of mappings: \" + numMappings);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/HashMap.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -397,0 +397,3 @@\n+        if (numElements < 0) {\n+            throw new IllegalArgumentException(\"Negative number of elements: \" + numElements);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/HashSet.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -813,0 +813,3 @@\n+        if (numMappings < 0) {\n+            throw new IllegalArgumentException(\"Negative number of mappings: \" + numMappings);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/LinkedHashMap.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -218,0 +218,3 @@\n+        if (numElements < 0) {\n+            throw new IllegalArgumentException(\"Negative number of elements: \" + numElements);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/LinkedHashSet.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-import java.util.stream.Collectors;\n@@ -2338,1 +2337,1 @@\n-            return Arrays.stream(stringList).collect(Collectors.joining(\",\"));\n+            return String.join(\",\", stringList);\n","filename":"src\/java.base\/share\/classes\/java\/util\/Locale.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1360,0 +1360,3 @@\n+        if (numMappings < 0) {\n+            throw new IllegalArgumentException(\"Negative number of mappings: \" + numMappings);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/WeakHashMap.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -104,0 +104,1 @@\n+    private boolean pendingOutput;\n@@ -418,0 +419,5 @@\n+            if (written == len && !finished) {\n+                pendingOutput = true;\n+            } else {\n+                pendingOutput = false;\n+            }\n@@ -713,0 +719,4 @@\n+\n+    boolean hasPendingOutput() {\n+        return pendingOutput;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Inflater.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -158,1 +158,6 @@\n-                if (inf.needsInput()) {\n+                if (inf.needsInput() && !inf.hasPendingOutput()) {\n+                    \/\/ Even if needsInput() is true, the native inflater may have some\n+                    \/\/ buffered data which couldn't fit in to the output buffer during the\n+                    \/\/ last call to inflate. Consume that buffered data first before calling\n+                    \/\/ fill() to avoid an EOF error if no more input is available and the\n+                    \/\/ next call to inflate will finish the inflation.\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/InflaterInputStream.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * (see below).  Currently the {@code AuthPermission} object is used to\n+ * (see below).  Currently, the {@code AuthPermission} object is used to\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/AuthPermission.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-    public default void destroy() throws DestroyFailedException {\n+    default void destroy() throws DestroyFailedException {\n@@ -66,1 +66,1 @@\n-    public default boolean isDestroyed() {\n+    default boolean isDestroyed() {\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/Destroyable.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-    private boolean testing = false;\n+    private final boolean testing = false;\n@@ -272,1 +272,1 @@\n-        if (! (obj instanceof PrivateCredentialPermission))\n+        if (! (obj instanceof PrivateCredentialPermission that))\n@@ -275,2 +275,0 @@\n-        PrivateCredentialPermission that = (PrivateCredentialPermission)obj;\n-\n@@ -319,2 +317,2 @@\n-        String principalClass = null;\n-        String principalName = null;\n+        String principalClass;\n+        String principalName;\n@@ -330,1 +328,1 @@\n-        if (tokenizer.hasMoreTokens() == false) {\n+        if (!tokenizer.hasMoreTokens()) {\n@@ -349,1 +347,1 @@\n-            if (tokenizer.hasMoreTokens() == false) {\n+            if (!tokenizer.hasMoreTokens()) {\n@@ -431,1 +429,1 @@\n-        \/**\n+        \/*\n@@ -536,1 +534,1 @@\n-            \/**\n+            \/*\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/PrivateCredentialPermission.java","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -28,2 +28,5 @@\n-import java.util.*;\n-import java.io.*;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectStreamField;\n+import java.security.*;\n@@ -31,7 +34,1 @@\n-import java.security.AccessController;\n-import java.security.AccessControlContext;\n-import java.security.DomainCombiner;\n-import java.security.Principal;\n-import java.security.PrivilegedExceptionAction;\n-import java.security.PrivilegedActionException;\n-import java.security.ProtectionDomain;\n+import java.util.*;\n@@ -41,1 +38,0 @@\n-import sun.security.action.GetBooleanAction;\n@@ -93,1 +89,1 @@\n- * does not implement {@code Serializable}.  Therefore all concrete\n+ * does not implement {@code Serializable}.  Therefore, all concrete\n@@ -755,1 +751,1 @@\n-        return new ClassSet<T>(PRINCIPAL_SET, c);\n+        return new ClassSet<>(PRINCIPAL_SET, c);\n@@ -849,1 +845,1 @@\n-        return new ClassSet<T>(PUB_CREDENTIAL_SET, c);\n+        return new ClassSet<>(PUB_CREDENTIAL_SET, c);\n@@ -893,1 +889,1 @@\n-        return new ClassSet<T>(PRIV_CREDENTIAL_SET, c);\n+        return new ClassSet<>(PRIV_CREDENTIAL_SET, c);\n@@ -926,3 +922,1 @@\n-        if (o instanceof Subject) {\n-\n-            final Subject that = (Subject)o;\n+        if (o instanceof final Subject that) {\n@@ -1183,1 +1177,1 @@\n-            this.elements = new LinkedList<E>();\n+            this.elements = new LinkedList<>();\n@@ -1198,2 +1192,2 @@\n-            return new Iterator<E>() {\n-                ListIterator<E> i = list.listIterator(0);\n+            return new Iterator<>() {\n+                final ListIterator<E> i = list.listIterator(0);\n@@ -1201,1 +1195,3 @@\n-                public boolean hasNext() {return i.hasNext();}\n+                public boolean hasNext() {\n+                    return i.hasNext();\n+                }\n@@ -1340,1 +1336,1 @@\n-                    \/\/ Otherwise we check the private cred set to see whether\n+                    \/\/ Otherwise, we check the private cred set to see whether\n@@ -1475,1 +1471,1 @@\n-                \/\/ element's toArray results.  Otherwise we'll let\n+                \/\/ element's toArray results.  Otherwise, we'll let\n@@ -1489,1 +1485,1 @@\n-                \/\/ element's toArray results.  Otherwise we'll let\n+                \/\/ element's toArray results.  Otherwise, we'll let\n@@ -1589,3 +1585,3 @@\n-        private int which;\n-        private Class<T> c;\n-        private Set<T> set;\n+        private final int which;\n+        private final Class<T> c;\n+        private final Set<T> set;\n@@ -1596,1 +1592,1 @@\n-            set = new HashSet<T>();\n+            set = new HashSet<>();\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/Subject.java","additions":24,"deletions":28,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,1 @@\n-     * whether or not multiple selections from the list of choices are allowed.\n+     * whether multiple selections from the list of choices are allowed.\n@@ -86,3 +86,2 @@\n-     * @param multipleSelectionsAllowed boolean specifying whether or\n-     *                  not multiple selections can be made from the\n-     *                  list of choices.\n+     * @param multipleSelectionsAllowed boolean specifying whether multiple\n+     *                  selections can be made from the list of choices.\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/callback\/ChoiceCallback.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-    private String prompt;\n+    private final String prompt;\n@@ -50,1 +50,1 @@\n-    private String defaultName;\n+    private final String defaultName;\n@@ -69,0 +69,1 @@\n+        this.defaultName = null;\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/callback\/NameCallback.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -158,3 +158,1 @@\n-        return () -> {\n-            Arrays.fill(password, ' ');\n-        };\n+        return () -> Arrays.fill(password, ' ');\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/callback\/PasswordCallback.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-    private String prompt;\n+    private final String prompt;\n@@ -51,1 +51,1 @@\n-    private String defaultText;\n+    private final String defaultText;\n@@ -70,0 +70,1 @@\n+        this.defaultText = null;\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/callback\/TextInputCallback.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-    private int messageType;\n+    private final int messageType;\n@@ -58,1 +58,1 @@\n-    private String message;\n+    private final String message;\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/callback\/TextOutputCallback.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-    private Callback callback;\n+    private final Callback callback;\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/callback\/UnsupportedCallbackException.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,3 +47,3 @@\n-    private String loginModuleName;\n-    private LoginModuleControlFlag controlFlag;\n-    private Map<String,?> options;\n+    private final String loginModuleName;\n+    private final LoginModuleControlFlag controlFlag;\n+    private final Map<String,?> options;\n@@ -125,1 +125,1 @@\n-     * This class represents whether or not a {@code LoginModule}\n+     * This class represents whether a {@code LoginModule}\n@@ -130,1 +130,1 @@\n-        private String controlFlag;\n+        private final String controlFlag;\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/login\/AppConfigurationEntry.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -324,1 +324,1 @@\n-     * may be different than the order of providers returned by\n+     * may be different from the order of providers returned by\n@@ -522,1 +522,1 @@\n-     * Otherwise this method returns null.\n+     * Otherwise, this method returns null.\n@@ -537,1 +537,1 @@\n-     * Otherwise this method returns null.\n+     * Otherwise, this method returns null.\n@@ -552,1 +552,1 @@\n-     * Otherwise this method returns null.\n+     * Otherwise, this method returns null.\n@@ -598,4 +598,4 @@\n-        private ConfigurationSpi spi;\n-        private Provider p;\n-        private String type;\n-        private Configuration.Parameters params;\n+        private final ConfigurationSpi spi;\n+        private final Provider p;\n+        private final String type;\n+        private final Configuration.Parameters params;\n@@ -631,1 +631,1 @@\n-    public static interface Parameters { }\n+    public interface Parameters { }\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/login\/Configuration.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -211,1 +211,1 @@\n-    private Map<String,?> state = new HashMap<String,Object>();\n+    private final Map<String,?> state = new HashMap<>();\n@@ -661,2 +661,1 @@\n-        LoginException error = (originalError != null) ? originalError : le;\n-        throw error;\n+        throw (originalError != null) ? originalError : le;\n@@ -770,1 +769,1 @@\n-                if (status == true) {\n+                if (status) {\n@@ -890,1 +889,1 @@\n-        \/\/ we went thru all the LoginModules.\n+        \/\/ we went through all the LoginModules.\n@@ -894,1 +893,1 @@\n-        } else if (success == false && firstError != null) {\n+        } else if (!success && firstError != null) {\n@@ -897,1 +896,1 @@\n-        } else if (success == false) {\n+        } else if (!success) {\n@@ -906,1 +905,0 @@\n-            return;\n@@ -951,1 +949,1 @@\n-     *          incapsulates Configuration info and actual module instances\n+     *          encapsulates Configuration info and actual module instances\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/login\/LoginContext.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import javax.security.auth.Subject;\n-import javax.security.auth.callback.*;\n-import javax.security.auth.login.*;\n@@ -32,0 +29,3 @@\n+import javax.security.auth.Subject;\n+import javax.security.auth.callback.CallbackHandler;\n+import javax.security.auth.login.LoginException;\n@@ -42,1 +42,1 @@\n- * to be used with a particular login application.  Therefore different\n+ * to be used with a particular login application.  Therefore, different\n@@ -228,1 +228,1 @@\n-     * @implSpec Implementations should check if a variable is {@code null}\n+     * @implNote Implementations should check if a variable is {@code null}\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/spi\/LoginModule.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,1 +94,1 @@\n-     * Currently referenced from sun.security.x509.X500Name.asX500Principal().\n+     * Currently, it is referenced from sun.security.x509.X500Name.asX500Principal().\n@@ -129,1 +129,1 @@\n-        this(name, Collections.<String, String>emptyMap());\n+        this(name, Collections.emptyMap());\n@@ -291,1 +291,1 @@\n-     * \"RFC1779\", \"RFC2253\", and \"CANONICAL\" (case insensitive).\n+     * \"RFC1779\", \"RFC2253\", and \"CANONICAL\" (case-insensitive).\n@@ -366,1 +366,1 @@\n-     * \"RFC1779\" and \"RFC2253\" (case insensitive). \"CANONICAL\" is not\n+     * \"RFC1779\" and \"RFC2253\" (case-insensitive). \"CANONICAL\" is not\n@@ -464,1 +464,1 @@\n-        if (o instanceof X500Principal == false) {\n+        if (!(o instanceof X500Principal other)) {\n@@ -467,1 +467,0 @@\n-        X500Principal other = (X500Principal)o;\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/x500\/X500Principal.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.lang.Class;\n@@ -33,2 +32,0 @@\n-import java.security.Security;\n-\n@@ -39,2 +36,1 @@\n-import java.security.PublicKey;\n-import java.util.BitSet;\n+import java.security.Security;\n","filename":"src\/java.base\/share\/classes\/javax\/security\/cert\/X509Certificate.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -178,2 +178,2 @@\n-        if (pos <= 0 || pos == syntaxAndInput.length()) {\n-            throw new IllegalArgumentException(\"pos is \" + pos);\n+        if (pos <= 0) {\n+            throw new IllegalArgumentException();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/JrtFileSystem.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1539,5 +1539,1 @@\n-                            StringJoiner cookieValue = new StringJoiner(\"; \");\n-                            for (String value : l) {\n-                                cookieValue.add(value);\n-                            }\n-                            requests.add(key, cookieValue.toString());\n+                            requests.add(key, String.join(\"; \", l));\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/HttpURLConnection.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;\n@@ -384,1 +383,1 @@\n-            extends SupportedGroups implements HandshakeProducer {\n+            implements HandshakeProducer {\n@@ -483,1 +482,1 @@\n-            extends SupportedGroups implements HandshakeProducer {\n+            implements HandshakeProducer {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SessionTicketExtension.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -330,1 +330,1 @@\n-            extends SupportedGroups implements HandshakeProducer {\n+            implements HandshakeProducer {\n@@ -475,1 +475,1 @@\n-            extends SupportedGroups implements HandshakeProducer {\n+            implements HandshakeProducer {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SupportedGroupsExtension.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -478,0 +478,2 @@\n+        {\"whose.sigalg.usagesignedjar\", \"%1$s verwendet den Signaturalgorithmus %2$s. Das gilt als Sicherheitsrisiko und kann nach %3$s nicht zum Signieren von JAR-Archiven verwendet werden.\"},\n+        {\"Unable.to.parse.denyAfter.string.in.exception.message\", \"denyAfter-Datumszeichenfolge in Ausnahmemeldung kann nicht geparst werden\"},\n","filename":"src\/java.base\/share\/classes\/sun\/security\/tools\/keytool\/Resources_de.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -478,0 +478,2 @@\n+        {\"whose.sigalg.usagesignedjar\", \"%1$s\\u306F%2$s\\u7F72\\u540D\\u30A2\\u30EB\\u30B4\\u30EA\\u30BA\\u30E0\\u3092\\u4F7F\\u7528\\u3057\\u3066\\u304A\\u308A\\u3001\\u3053\\u308C\\u306F\\u30BB\\u30AD\\u30E5\\u30EA\\u30C6\\u30A3\\u30FB\\u30EA\\u30B9\\u30AF\\u3068\\u307F\\u306A\\u3055\\u308C\\u307E\\u3059\\u3002%3$s\\u306E\\u5F8C\\u3067JAR\\u306B\\u7F72\\u540D\\u3059\\u308B\\u305F\\u3081\\u306B\\u4F7F\\u7528\\u3059\\u308B\\u3053\\u3068\\u306F\\u3067\\u304D\\u307E\\u305B\\u3093\\u3002\"},\n+        {\"Unable.to.parse.denyAfter.string.in.exception.message\", \"\\u4F8B\\u5916\\u30E1\\u30C3\\u30BB\\u30FC\\u30B8\\u306EdenyAfter\\u65E5\\u4ED8\\u6587\\u5B57\\u5217\\u3092\\u89E3\\u6790\\u3067\\u304D\\u307E\\u305B\\u3093\"},\n","filename":"src\/java.base\/share\/classes\/sun\/security\/tools\/keytool\/Resources_ja.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -478,0 +478,2 @@\n+        {\"whose.sigalg.usagesignedjar\", \"%1$s \\u4F7F\\u7528\\u7684 %2$s \\u7B7E\\u540D\\u7B97\\u6CD5\\u88AB\\u89C6\\u4E3A\\u5B58\\u5728\\u5B89\\u5168\\u98CE\\u9669\\uFF0C\\u65E0\\u6CD5\\u7528\\u4E8E\\u5728 %3$s \\u540E\\u5BF9 JAR \\u8FDB\\u884C\\u7B7E\\u540D\\u3002\"},\n+        {\"Unable.to.parse.denyAfter.string.in.exception.message\", \"\\u65E0\\u6CD5\\u89E3\\u6790\\u5F02\\u5E38\\u9519\\u8BEF\\u6D88\\u606F\\u4E2D\\u7684 denyAfter \\u65E5\\u671F\\u5B57\\u7B26\\u4E32\"},\n","filename":"src\/java.base\/share\/classes\/sun\/security\/tools\/keytool\/Resources_zh_CN.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-     * Construct an DER output stream.\n+     * Construct a DER output stream.\n@@ -69,1 +69,1 @@\n-     * Construct an DER output stream.\n+     * Construct a DER output stream.\n@@ -74,1 +74,1 @@\n-     * Writes tagged, pre-marshaled data.  This calcuates and encodes\n+     * Writes tagged, pre-marshaled data.  This calculates and encodes\n@@ -178,1 +178,1 @@\n-     * @param i the integer in bytes, equivalent to BigInteger::toByteArray.\n+     * @param buf the integer in bytes, equivalent to BigInteger::toByteArray.\n@@ -464,2 +464,2 @@\n-     * @param enc the name of the encoder that should be used corresponding\n-     * to the above tag.\n+     * @param charset the charset that should be used corresponding to\n+     * the above tag.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DerOutputStream.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -63,0 +63,3 @@\n+# These currency symbol entries are for the root bundle only to avoid throwing a\n+# MissingResourceException. They should not be copied into each localized resource bundle\n+# during translation.\n","filename":"src\/java.base\/share\/classes\/sun\/util\/resources\/CurrencyNames.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,0 +25,3 @@\n+#\n+# If this properties file fails to load, the JDK implementation will throw\n+# an unspecified error when initializing the java.security.Security class.\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -396,1 +396,1 @@\n-    jchar buf[512];\n+    jchar buf[512] = {0};\n@@ -415,0 +415,1 @@\n+\n@@ -470,0 +471,3 @@\n+    if ((*env)->EnsureLocalCapacity(env, 1) < 0)\n+        return NULL;\n+\n@@ -537,1 +541,1 @@\n-    jchar buf[512];\n+    jchar buf[512] = {0};\n","filename":"src\/java.base\/share\/native\/libjava\/jni_util.c","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -558,1 +558,1 @@\n-    s->last_flush = Z_NO_FLUSH;\n+    s->last_flush = -2;\n@@ -652,1 +652,1 @@\n-        s->high_water) {\n+        s->last_flush != -2) {\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/deflate.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+#ifdef _ALLBSD_SOURCE\n+#include <sys\/attr.h>\n+#endif\n@@ -143,0 +146,13 @@\n+    \/\/ flags used with setattrlist\n+#ifdef _ALLBSD_SOURCE\n+    static final int PREFIX_ATTR_CMN_CRTIME = ATTR_CMN_CRTIME;\n+    static final int PREFIX_ATTR_CMN_MODTIME = ATTR_CMN_MODTIME;\n+    static final int PREFIX_ATTR_CMN_ACCTIME = ATTR_CMN_ACCTIME;\n+    static final int PREFIX_FSOPT_NOFOLLOW = FSOPT_NOFOLLOW;\n+#else\n+    \/\/ not supported (dummy values will not be used at runtime).\n+    static final int PREFIX_ATTR_CMN_CRTIME = 00;\n+    static final int PREFIX_ATTR_CMN_MODTIME = 00;\n+    static final int PREFIX_ATTR_CMN_ACCTIME = 00;\n+    static final int PREFIX_FSOPT_NOFOLLOW = 00;\n+#endif\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixConstants.java.template","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-    private static class Posix extends Basic implements PosixFileAttributeView {\n+    static class Posix extends Basic implements PosixFileAttributeView {\n@@ -334,1 +334,1 @@\n-    private static class Unix extends Posix {\n+    static class Unix extends Posix {\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileAttributeViews.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -284,1 +284,1 @@\n-        if (pos <= 0 || pos == syntaxAndInput.length())\n+        if (pos <= 0)\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystem.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -340,2 +340,1 @@\n-        NativeBuffer buffer = NativeBuffers.getNativeBuffer(size);\n-        try {\n+        try (NativeBuffer buffer = NativeBuffers.getNativeBuffer(size)) {\n@@ -345,2 +344,0 @@\n-        } finally {\n-            buffer.release();\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixUserDefinedFileAttributeView.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import java.nio.file.*;\n+import java.nio.file.Path;\n@@ -44,3 +44,0 @@\n-        if (!(file instanceof Path))\n-            return null;\n-\n@@ -58,5 +55,2 @@\n-        NativeBuffer keyBuffer = null;\n-        NativeBuffer nameBuffer = null;\n-        try {\n-            keyBuffer = WindowsNativeDispatcher.asNativeBuffer(key);\n-            nameBuffer = WindowsNativeDispatcher.asNativeBuffer(\"Content Type\");\n+        try (NativeBuffer keyBuffer = WindowsNativeDispatcher.asNativeBuffer(key);\n+             NativeBuffer nameBuffer = WindowsNativeDispatcher.asNativeBuffer(\"Content Type\")) {\n@@ -67,3 +61,0 @@\n-        } finally {\n-            nameBuffer.release();\n-            keyBuffer.release();\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/RegistryFileTypeDetector.java","additions":4,"deletions":13,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -122,2 +122,1 @@\n-        NativeBuffer buffer = getFileSecurity(path, OWNER_SECURITY_INFORMATION);\n-        try {\n+        try (NativeBuffer buffer = getFileSecurity(path, OWNER_SECURITY_INFORMATION)) {\n@@ -132,2 +131,0 @@\n-        } finally {\n-            buffer.release();\n@@ -149,2 +146,1 @@\n-        NativeBuffer buffer = getFileSecurity(path, DACL_SECURITY_INFORMATION);\n-        try {\n+        try (NativeBuffer buffer = getFileSecurity(path, DACL_SECURITY_INFORMATION)) {\n@@ -152,2 +148,0 @@\n-        } finally {\n-            buffer.release();\n@@ -176,1 +170,1 @@\n-        long pOwner = 0L;\n+        long pOwner;\n@@ -186,2 +180,6 @@\n-        try {\n-            NativeBuffer buffer = NativeBuffers.getNativeBuffer(SIZEOF_SECURITY_DESCRIPTOR);\n+        try (NativeBuffer buffer = NativeBuffers.getNativeBuffer(SIZEOF_SECURITY_DESCRIPTOR)) {\n+            InitializeSecurityDescriptor(buffer.address());\n+            SetSecurityDescriptorOwner(buffer.address(), pOwner);\n+            \/\/ may need SeRestorePrivilege to set the owner\n+            WindowsSecurity.Privilege priv =\n+                WindowsSecurity.enablePrivilege(\"SeRestorePrivilege\");\n@@ -189,14 +187,3 @@\n-                InitializeSecurityDescriptor(buffer.address());\n-                SetSecurityDescriptorOwner(buffer.address(), pOwner);\n-                \/\/ may need SeRestorePrivilege to set the owner\n-                WindowsSecurity.Privilege priv =\n-                    WindowsSecurity.enablePrivilege(\"SeRestorePrivilege\");\n-                try {\n-                    SetFileSecurity(path,\n-                                    OWNER_SECURITY_INFORMATION,\n-                                    buffer.address());\n-                } finally {\n-                    priv.drop();\n-                }\n-            } catch (WindowsException x) {\n-                x.rethrowAsIOException(file);\n+                SetFileSecurity(path,\n+                                OWNER_SECURITY_INFORMATION,\n+                                buffer.address());\n@@ -204,1 +191,1 @@\n-                buffer.release();\n+                priv.drop();\n@@ -206,0 +193,2 @@\n+        } catch (WindowsException x) {\n+            x.rethrowAsIOException(file);\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsAclFileAttributeView.java","additions":16,"deletions":27,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -266,3 +266,1 @@\n-        NativeBuffer buffer = NativeBuffers\n-            .getNativeBuffer(SIZEOF_FILE_INFORMATION);\n-        try {\n+        try (NativeBuffer buffer = NativeBuffers.getNativeBuffer(SIZEOF_FILE_INFORMATION)) {\n@@ -278,2 +276,1 @@\n-                NativeBuffer reparseBuffer = NativeBuffers.getNativeBuffer(size);\n-                try {\n+                try (NativeBuffer reparseBuffer = NativeBuffers.getNativeBuffer(size)) {\n@@ -282,2 +279,0 @@\n-                } finally {\n-                    reparseBuffer.release();\n@@ -288,2 +283,0 @@\n-        } finally {\n-            buffer.release();\n@@ -303,3 +296,2 @@\n-            NativeBuffer buffer =\n-                NativeBuffers.getNativeBuffer(SIZEOF_FILE_ATTRIBUTE_DATA);\n-            try {\n+            try (NativeBuffer buffer =\n+                NativeBuffers.getNativeBuffer(SIZEOF_FILE_ATTRIBUTE_DATA)) {\n@@ -318,2 +310,0 @@\n-            } finally {\n-                buffer.release();\n@@ -329,2 +319,1 @@\n-                buffer = getBufferForFindData();\n-                try {\n+                try (NativeBuffer buffer = getBufferForFindData()) {\n@@ -343,2 +332,0 @@\n-                } finally {\n-                    buffer.release();\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsFileAttributes.java","additions":6,"deletions":19,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -517,5 +517,3 @@\n-            NativeBuffer buffer =\n-                WindowsAclFileAttributeView.getFileSecurity(path, request);\n-            try {\n-                try {\n-                    SetFileSecurity(target.getPathForWin32Calls(), request,\n+            try (NativeBuffer buffer =\n+                 WindowsAclFileAttributeView.getFileSecurity(path, request)) {\n+                SetFileSecurity(target.getPathForWin32Calls(), request,\n@@ -523,5 +521,2 @@\n-                } catch (WindowsException x) {\n-                    x.rethrowAsIOException(target);\n-                }\n-            } finally {\n-                buffer.release();\n+            } catch (WindowsException x) {\n+                x.rethrowAsIOException(target);\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsFileCopy.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -264,1 +264,1 @@\n-        if (pos <= 0 || pos == syntaxAndInput.length())\n+        if (pos <= 0)\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsFileSystem.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-import java.security.AccessController;\n-import jdk.internal.misc.Unsafe;\n@@ -305,1 +303,1 @@\n-        NativeBuffer aclBuffer = WindowsAclFileAttributeView\n+        try (NativeBuffer aclBuffer = WindowsAclFileAttributeView\n@@ -309,2 +307,1 @@\n-                | GROUP_SECURITY_INFORMATION);\n-        try {\n+                | GROUP_SECURITY_INFORMATION)) {\n@@ -318,2 +315,0 @@\n-        } finally {\n-            aclBuffer.release();\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsFileSystemProvider.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -272,2 +272,1 @@\n-        NativeBuffer buffer = NativeBuffers.getNativeBuffer(size);\n-        try {\n+        try (NativeBuffer buffer = NativeBuffers.getNativeBuffer(size)) {\n@@ -337,2 +336,0 @@\n-        } finally {\n-            buffer.release();\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsLinkSupport.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -498,2 +498,1 @@\n-        NativeBuffer buffer = asNativeBuffer(root);\n-        try {\n+        try (NativeBuffer buffer = asNativeBuffer(root)) {\n@@ -503,2 +502,0 @@\n-        } finally {\n-            buffer.release();\n@@ -529,2 +526,1 @@\n-        NativeBuffer buffer = asNativeBuffer(root);\n-        try {\n+        try (NativeBuffer buffer = asNativeBuffer(root)) {\n@@ -532,2 +528,0 @@\n-        } finally {\n-            buffer.release();\n@@ -549,2 +543,1 @@\n-        NativeBuffer buffer = asNativeBuffer(path);\n-        try {\n+        try (NativeBuffer buffer = asNativeBuffer(path)) {\n@@ -554,2 +547,0 @@\n-        } finally {\n-            buffer.release();\n@@ -571,2 +562,1 @@\n-        NativeBuffer buffer = asNativeBuffer(path);\n-        try {\n+        try (NativeBuffer buffer = asNativeBuffer(path)) {\n@@ -576,2 +566,0 @@\n-        } finally {\n-            buffer.release();\n@@ -612,2 +600,1 @@\n-        NativeBuffer buffer = asNativeBuffer(path);\n-        try {\n+        try (NativeBuffer buffer = asNativeBuffer(path)) {\n@@ -615,2 +602,0 @@\n-        } finally {\n-            buffer.release();\n@@ -656,2 +641,1 @@\n-        NativeBuffer buffer = asNativeBuffer(path);\n-        try {\n+        try (NativeBuffer buffer = asNativeBuffer(path)) {\n@@ -660,2 +644,0 @@\n-        } finally {\n-            buffer.release();\n@@ -681,2 +663,1 @@\n-        NativeBuffer buffer = asNativeBuffer(path);\n-        try {\n+        try (NativeBuffer buffer = asNativeBuffer(path)) {\n@@ -685,2 +666,0 @@\n-        } finally {\n-            buffer.release();\n@@ -838,2 +817,1 @@\n-        NativeBuffer buffer = asNativeBuffer(accountName);\n-        try {\n+        try (NativeBuffer buffer = asNativeBuffer(accountName)) {\n@@ -841,2 +819,0 @@\n-        } finally {\n-            buffer.release();\n@@ -877,2 +853,1 @@\n-        NativeBuffer buffer = asNativeBuffer(sidString);\n-        try {\n+        try (NativeBuffer buffer = asNativeBuffer(sidString)) {\n@@ -880,2 +855,0 @@\n-        } finally {\n-            buffer.release();\n@@ -977,2 +950,1 @@\n-        NativeBuffer buffer = asNativeBuffer(name);\n-        try {\n+        try (NativeBuffer buffer = asNativeBuffer(name)) {\n@@ -980,2 +952,0 @@\n-        } finally {\n-            buffer.release();\n@@ -1039,3 +1009,2 @@\n-        NativeBuffer newFileBuffer = asNativeBuffer(newFile);\n-        NativeBuffer existingFileBuffer = asNativeBuffer(existingFile);\n-        try {\n+        try (NativeBuffer newFileBuffer = asNativeBuffer(newFile);\n+             NativeBuffer existingFileBuffer = asNativeBuffer(existingFile)) {\n@@ -1043,3 +1012,0 @@\n-        } finally {\n-            existingFileBuffer.release();\n-            newFileBuffer.release();\n@@ -1060,2 +1026,1 @@\n-        NativeBuffer buffer = asNativeBuffer(path);\n-        try {\n+        try (NativeBuffer buffer = asNativeBuffer(path)) {\n@@ -1063,2 +1028,0 @@\n-        } finally {\n-            buffer.release();\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsNativeDispatcher.java","additions":13,"deletions":50,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -707,1 +707,1 @@\n-        StringBuilder sb = new StringBuilder();\n+        StringJoiner sb = new StringJoiner(\"\\\\\");\n@@ -709,3 +709,1 @@\n-            sb.append(elementAsString(i));\n-            if (i != (endIndex-1))\n-                sb.append(\"\\\\\");\n+            sb.add(elementAsString(i));\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsPath.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -143,1 +143,1 @@\n-        int size = 0;\n+        int size;\n@@ -154,2 +154,1 @@\n-        NativeBuffer sidBuffer = NativeBuffers.getNativeBuffer(size);\n-        try {\n+        try (NativeBuffer sidBuffer = NativeBuffers.getNativeBuffer(size)) {\n@@ -166,2 +165,0 @@\n-        } finally {\n-            sidBuffer.release();\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsUserPrincipals.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+ * @see java.lang.reflect.ClassFileFormatVersion\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/SourceVersion.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -403,0 +403,9 @@\n+        Icon selectedIcon = null;\n+\n+        \/\/ the fallback icon should be based on the selected state\n+        if (model.isSelected()) {\n+            selectedIcon = b.getSelectedIcon();\n+            if (selectedIcon != null) {\n+                icon = selectedIcon;\n+            }\n+        }\n@@ -406,1 +415,5 @@\n-            } else {\n+               if (tmpIcon == null) {\n+                   tmpIcon = selectedIcon;\n+               }\n+            }\n+            if (tmpIcon == null) {\n@@ -419,1 +432,5 @@\n-            } else {\n+                if (tmpIcon == null) {\n+                    tmpIcon = selectedIcon;\n+                }\n+            }\n+            if (tmpIcon == null) {\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaButtonUI.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -423,3 +423,3 @@\n-            hashCode ^= Boolean.valueOf(mi.isVisible()).hashCode();\n-            hashCode ^= Boolean.valueOf(mi.isEnabled()).hashCode();\n-            hashCode ^= Boolean.valueOf(mi.isSelected()).hashCode();\n+            hashCode ^= Boolean.hashCode(mi.isVisible());\n+            hashCode ^= Boolean.hashCode(mi.isEnabled());\n+            hashCode ^= Boolean.hashCode(mi.isSelected());\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/ScreenMenu.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -126,1 +126,8 @@\n-                accessibilityName = [accessibilityName stringByAppendingFormat:@\", %@\", [cell accessibilityLabel]];\n+                NSString *label = [cell accessibilityLabel];\n+                if (label == nil) {\n+                    id val = [cell accessibilityValue];\n+                    if (val != nil) {\n+                        label = [NSString stringWithFormat:@\"%@\", val];\n+                    }\n+                }\n+                accessibilityName = [accessibilityName stringByAppendingFormat:@\", %@\", label];\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/TableRowAccessibility.m","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-    if (isDrawOp(mtlPreviousOp) && !isDrawOp(op)) {\n+    if (isDrawOp(mtlPreviousOp)) {\n@@ -73,1 +73,5 @@\n-        mtlPreviousOp = op;\n+        if (isDrawOp(op)) {\n+            \/\/ Do not cause endEncoder if we continue with Draw operations\n+            mtlPreviousOp = op;\n+            return;\n+        }\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLRenderQueue.m","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    NSLog(@\"\\tPlease file a bug report at http:\/\/bugreport.java.com\/bugreport \\\n+    NSLog(@\"\\tPlease file a bug report at https:\/\/bugreport.java.com\/bugreport \\\n","filename":"src\/java.desktop\/macosx\/native\/libosxapp\/AWT_debug.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -530,2 +530,0 @@\n-                    transforms[0] = mdl.createTransform(xyz.getProfile(),\n-                                    ColorTransform.Any, ColorTransform.In);\n@@ -533,1 +531,1 @@\n-                        transforms[1] = mdl.createTransform(thisProfile,\n+                        transforms[0] = mdl.createTransform(xyz.getProfile(),\n@@ -535,1 +533,1 @@\n-                                        ColorTransform.Out);\n+                                        ColorTransform.In);\n@@ -537,2 +535,2 @@\n-                        transforms[1] = mdl.createTransform(thisProfile,\n-                                        ColorTransform.Any, ColorTransform.Out);\n+                        transforms[0] = mdl.createTransform(xyz.getProfile(),\n+                                        ColorTransform.Any, ColorTransform.In);\n@@ -540,0 +538,2 @@\n+                    transforms[1] = mdl.createTransform(thisProfile,\n+                                    ColorTransform.Any, ColorTransform.Out);\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_ColorSpace.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2149,3 +2149,4 @@\n-     * This is overridden to return false if the current <code>Icon<\/code>'s\n-     * <code>Image<\/code> is not equal to the\n-     * passed in <code>Image<\/code> <code>img<\/code>.\n+     * If the button icon for the current button state is either {@code null}\n+     * or not an {@code ImageIcon} with an {@code Image} equal to the\n+     * passed in {@code Image}, return {@code false}; otherwise it\n+     * will delegate to the super-class.\n@@ -2153,1 +2154,1 @@\n-     * @param img  the <code>Image<\/code> to be compared\n+     * @param img  the {@code Image} to be compared\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/AbstractButton.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n@@ -75,0 +77,4 @@\n+     * <p>\n+     * NOTE: This constructor should not be called by\n+     * applications, it is for internal use only. When called directly\n+     * it will create an un-usable instance.\n@@ -76,0 +82,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -80,0 +87,16 @@\n+\n+        \/\/  Creates a Graphics context when the constructor is called.\n+        if (this.graphics == null) {\n+            StackWalker walker = AccessController.doPrivileged(new PrivilegedAction<StackWalker>() {\n+                @Override\n+                public StackWalker run() {\n+                    StackWalker stackwalker = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE);\n+                    return stackwalker;\n+                }\n+            });\n+\n+            if (walker.getCallerClass() != this.getClass()) {\n+                BufferedImage bi = new BufferedImage(1, 1, BufferedImage.TYPE_INT_RGB);\n+                this.graphics = bi.createGraphics();\n+            }\n+        }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/DebugGraphics.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -877,2 +877,12 @@\n-     * This is overridden to return false if the current Icon's Image is\n-     * not equal to the passed in Image <code>img<\/code>.\n+     * If the component is not showing or either the icon or disabled\n+     * icon is not an {@code ImageIcon} with an {@code Image}\n+     * equal to the passed in {@code Image}, return {@code false};\n+     * otherwise it will delegate to the super-class.\n+     *\n+     * @param img   the {@code Image} to be compared\n+     * @param infoflags flags used to repaint the label when the image\n+     *           is updated and which determine how much is to be painted\n+     * @param x   the x coordinate\n+     * @param y   the y coordinate\n+     * @param w   the width\n+     * @param h   the height\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JLabel.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -725,1 +725,1 @@\n-     *       ({@code > 0 and <= getTabCount()})\n+     *       {@code (index >= 0 && index <= getTabCount())}\n@@ -728,1 +728,1 @@\n-     *         ({@code < 0 or > getTabCount()})\n+     *         {@code (index < 0 || index > getTabCount())}\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JTabbedPane.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.nio.file.Files;\n@@ -709,1 +710,3 @@\n-                            && (useSetDirectory || !fsv.isFileSystem(((File)objects[0])))) {\n+                            && (useSetDirectory\n+                                || (!fsv.isFileSystem(((File)objects[0]))\n+                                    && !Files.isSymbolicLink(((File)objects[0]).toPath())))) {\n@@ -715,1 +718,1 @@\n-                                File f = (File) object;\n+                                File f = (File)object;\n@@ -719,1 +722,1 @@\n-                                        && fsv.isFileSystem(f)\n+                                        && (fsv.isFileSystem(f) || Files.isSymbolicLink(f.toPath()))\n@@ -741,1 +744,5 @@\n-                            chooser.setSelectedFile(null);\n+                            if (Files.isSymbolicLink(file.toPath())) {\n+                                chooser.setSelectedFile(file);\n+                            } else {\n+                                chooser.setSelectedFile(null);\n+                            }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicFileChooserUI.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -727,0 +727,2 @@\n+                          SwingUtilities2.setAltGraphMask(\n+                             SwingUtilities2.getSystemMnemonicKeyMask())\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/SynthLookAndFeel.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -400,0 +400,7 @@\n+        System.err.println(\n+            \"\"\"\n+            WARNING: sun.awt.AppContext.dispose() no longer stops threads.\n+            Additionally AppContext will be removed in a future release.\n+            Remove all uses of this internal class as soon as possible.\n+            There is no replacement.\n+            \"\"\");\n@@ -505,27 +512,0 @@\n-        \/\/ Then, we stop any remaining Threads\n-        AccessController.doPrivileged((PrivilegedAction<Void>) () -> {\n-            Thread[] threads;\n-            int len, threadCount;\n-            do {\n-                len = threadGroup.activeCount() + 4;\n-                threads = new Thread[len];\n-                threadCount = threadGroup.enumerate(threads);\n-            } while (threadCount == len);\n-            for (int i = 0; i < threadCount; i++) {\n-                threads[i].stop();\n-            }\n-            return null;\n-        });\n-\n-        \/\/ Next, we sleep 10ms at a time, waiting for all of the active\n-        \/\/ Threads in the ThreadGroup to die.\n-\n-        startTime = System.currentTimeMillis();\n-        endTime = startTime + THREAD_INTERRUPT_TIMEOUT;\n-        while ((this.threadGroup.activeCount() > 0) &&\n-               (System.currentTimeMillis() < endTime)) {\n-            try {\n-                Thread.sleep(10);\n-            } catch (InterruptedException e) { }\n-        }\n-\n@@ -545,7 +525,0 @@\n-        \/\/ Finally, we destroy the ThreadGroup entirely.\n-        try {\n-            this.threadGroup.destroy();\n-        } catch (IllegalThreadStateException e) {\n-            \/\/ Fired if not all the Threads died, ignore it and proceed\n-        }\n-\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/AppContext.java","additions":7,"deletions":34,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,3 +26,0 @@\n-\/*\n- *\/\n-\n@@ -42,2 +39,2 @@\n-    private short[] index1;\n-    private String[] index2;\n+    private final short[] index1;\n+    private final String[] index2;\n@@ -105,2 +102,1 @@\n-                    byte[] outputBytes = new byte[2];\n-                    outputBytes = encodeSurrogate(c, c2);\n+                    byte[] outputBytes = encodeSurrogate(c, c2);\n@@ -161,2 +157,1 @@\n-                    byte[] outputBytes = new byte[2];\n-                    outputBytes = encodeSurrogate(c, c2);\n+                    byte[] outputBytes = encodeSurrogate(c, c2);\n@@ -207,1 +202,1 @@\n-        if (true && src.hasArray() && dst.hasArray())\n+        if (src.hasArray() && dst.hasArray())\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/DoubleByteEncoder.java","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-    memset(igLUTable, 0,  LCDLUTCOUNT);\n+    memset(igLUTable, 0, sizeof igLUTable);\n","filename":"src\/java.desktop\/windows\/native\/libfontmanager\/lcdglyph.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -748,1 +748,1 @@\n-            value += Boolean.valueOf(primitiveArray).hashCode();\n+            value += Boolean.hashCode(primitiveArray);\n","filename":"src\/java.management\/share\/classes\/javax\/management\/openmbean\/ArrayType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-#define EXIT_FAILURE -1 \/\/ mdu\n@@ -826,0 +825,1 @@\n+            \/\/ #define EXIT_FAILURE -1 \/\/ mdu\n","filename":"src\/java.security.jgss\/windows\/native\/libw2k_lsa_auth\/NativeCreds.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2005, 2010, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,0 @@\n-cachedrowsetimpl.invalidcol = Ung\\u00FCltiger Spaltenindex\n","filename":"src\/java.sql.rowset\/share\/classes\/com\/sun\/rowset\/RowSetResourceBundle_de.properties","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2005, 2010, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,0 @@\n-cachedrowsetimpl.invalidcol = \\u7121\\u52B9\\u306A\\u5217\\u7D22\\u5F15\n","filename":"src\/java.sql.rowset\/share\/classes\/com\/sun\/rowset\/RowSetResourceBundle_ja.properties","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2005, 2010, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,0 @@\n-cachedrowsetimpl.invalidcol = \\u5217\\u7D22\\u5F15\\u65E0\\u6548\n","filename":"src\/java.sql.rowset\/share\/classes\/com\/sun\/rowset\/RowSetResourceBundle_zh_CN.properties","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -572,1 +572,1 @@\n-        writer.write(Boolean.valueOf(b).toString());\n+        writer.write(Boolean.toString(b));\n","filename":"src\/java.sql.rowset\/share\/classes\/com\/sun\/rowset\/internal\/WebRowSetXmlWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -200,1 +200,1 @@\n-                \"Warnung: Die Codierung \\\"{0}\\\" wird nicht von der Java-Laufzeit unterst\\u00FCtzt.\" },\n+                \"Warnung: Die Codierung \\\"{0}\\\" wird nicht von Java Runtime unterst\\u00FCtzt.\" },\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/serializer\/utils\/SerializerMessages_de.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -130,2 +130,1 @@\n-    \/** Flag bit 21 is available. (used earlier to tag compiler-generated abstract methods that implement\n-     *  an interface method (Miranda methods)).\n+    \/** Flag is set for ClassSymbols that are being compiled from source.\n@@ -133,0 +132,1 @@\n+    public static final int FROM_SOURCE      = 1<<21; \/\/ClassSymbols\n@@ -485,0 +485,1 @@\n+        FROM_SOURCE(Flags.FROM_SOURCE),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -676,1 +676,2 @@\n-        } else if ((c.name != name || c.owner != owner) && owner.kind == TYP && c.owner.kind == PCK) {\n+        } else if ((c.name != name || c.owner != owner) && owner.kind == TYP &&\n+                   c.owner.kind == PCK && ((c.flags_field & FROM_SOURCE) == 0)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -497,1 +497,1 @@\n-        c.flags_field = chk.checkFlags(tree.pos(), tree.mods.flags, c, tree);\n+        c.flags_field = chk.checkFlags(tree.pos(), tree.mods.flags, c, tree) | FROM_SOURCE;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2594,1 +2594,1 @@\n-                if (c == outer) {\n+                if (c == outer && member.owner == c) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -113,0 +113,2 @@\n+compiler.err.annotation.missing.element.value=In Annotation fehlt ein Elementwert\n+\n@@ -1122,2 +1124,0 @@\n-compiler.misc.base.membership=Alle Basisklassen geh\\u00F6ren zu dieser Gruppe\n-\n@@ -2786,0 +2786,3 @@\n+\n+# 0: type\n+compiler.err.enclosing.class.type.non.denotable=Einschlie\\u00DFender Klassentyp: {0}\\nist nicht deklarierbar. F\\u00FChren Sie das Casting in einen deklarierbaren Typ aus\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler_de.properties","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -113,0 +113,2 @@\n+compiler.err.annotation.missing.element.value=\\u6CE8\\u91C8\\u306B\\u8981\\u7D20\\u5024\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093\n+\n@@ -1122,2 +1124,0 @@\n-compiler.misc.base.membership=\\u3059\\u3079\\u3066\\u306E\\u30D9\\u30FC\\u30B9\\u30FB\\u30AF\\u30E9\\u30B9\\u304C\\u30E1\\u30F3\\u30D0\\u30FC\\u3067\\u3059\n-\n@@ -2786,0 +2786,3 @@\n+\n+# 0: type\n+compiler.err.enclosing.class.type.non.denotable=\\u5305\\u542B\\u3059\\u308B\\u30AF\\u30E9\\u30B9\\u578B: {0}\\n\\u306F\\u975E\\u578B\\u6307\\u5B9A\\u3067\\u3059\\u3002\\u578B\\u6307\\u5B9A\\u578B\\u306B\\u30AD\\u30E3\\u30B9\\u30C8\\u3057\\u3066\\u307F\\u3066\\u304F\\u3060\\u3055\\u3044\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler_ja.properties","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -113,0 +113,2 @@\n+compiler.err.annotation.missing.element.value=\\u6CE8\\u91CA\\u7F3A\\u5C11\\u5143\\u7D20\\u503C\n+\n@@ -1122,2 +1124,0 @@\n-compiler.misc.base.membership=\\u60A8\\u7684\\u6240\\u6709\\u57FA\\u7C7B\\u90FD\\u5C5E\\u4E8E\\u6211\\u4EEC\n-\n@@ -2786,0 +2786,3 @@\n+\n+# 0: type\n+compiler.err.enclosing.class.type.non.denotable=\\u5C01\\u95ED\\u7C7B\\u7C7B\\u578B\\uFF1A{0}\\n\\u662F\\u4E0D\\u53EF\\u6307\\u793A\\u7684\\u7C7B\\u578B\\uFF0C\\u5C1D\\u8BD5\\u8F6C\\u6362\\u4E3A\\u53EF\\u6307\\u793A\\u7684\\u7C7B\\u578B\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler_zh_CN.properties","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -370,2 +370,2 @@\n-Please file a bug against the Java compiler via the Java bug reporting page (http:\/\/bugreport.java.com) \\\n-after checking the Bug Database (http:\/\/bugs.java.com) for duplicates. \\\n+Please file a bug against the Java compiler via the Java bug reporting page (https:\/\/bugreport.java.com) \\\n+after checking the Bug Database (https:\/\/bugs.java.com) for duplicates. \\\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-javac.msg.bug=Im Compiler ({0}) ist eine Ausnahme aufgetreten. Erstellen Sie auf der Java-Seite zum Melden von Bugs (http:\/\/bugreport.java.com) einen Bugbericht, nachdem Sie die Bugdatenbank (http:\/\/bugs.java.com) auf Duplikate gepr\\u00FCft haben. Geben Sie in Ihrem Bericht Ihr Programm, die folgende Diagnose und die Parameter an, die Sie dem Java-Compiler \\u00FCbergeben haben. Vielen Dank.\n+javac.msg.bug=Im Compiler ({0}) ist eine Ausnahme aufgetreten. Erstellen Sie auf der Java-Seite zum Melden von Bugs (https:\/\/bugreport.java.com) einen Bugbericht, nachdem Sie die Bugdatenbank (https:\/\/bugs.java.com) auf Duplikate gepr\\u00FCft haben. Geben Sie in Ihrem Bericht Ihr Programm, die folgende Diagnose und die Parameter an, die Sie dem Java-Compiler \\u00FCbergeben haben. Vielen Dank.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac_de.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-javac.msg.bug=\\u30B3\\u30F3\\u30D1\\u30A4\\u30E9\\u3067\\u4F8B\\u5916\\u304C\\u767A\\u751F\\u3057\\u307E\\u3057\\u305F({0})\\u3002Bug Database (http:\/\/bugs.java.com)\\u3067\\u91CD\\u8907\\u304C\\u306A\\u3044\\u304B\\u3092\\u3054\\u78BA\\u8A8D\\u306E\\u3046\\u3048\\u3001Java bug\\u30EC\\u30DD\\u30FC\\u30C8\\u30FB\\u30DA\\u30FC\\u30B8(http:\/\/bugreport.java.com)\\u3067Java\\u30B3\\u30F3\\u30D1\\u30A4\\u30E9\\u306B\\u5BFE\\u3059\\u308Bbug\\u306E\\u767B\\u9332\\u3092\\u304A\\u9858\\u3044\\u3044\\u305F\\u3057\\u307E\\u3059\\u3002\\u30EC\\u30DD\\u30FC\\u30C8\\u306B\\u306F\\u3001\\u305D\\u306E\\u30D7\\u30ED\\u30B0\\u30E9\\u30E0\\u3001\\u4E0B\\u8A18\\u306E\\u8A3A\\u65AD\\u5185\\u5BB9\\u3001\\u304A\\u3088\\u3073Java\\u30B3\\u30F3\\u30D1\\u30A4\\u30E9\\u306B\\u6E21\\u3057\\u305F\\u30D1\\u30E9\\u30E1\\u30FC\\u30BF\\u3092\\u542B\\u3081\\u3066\\u304F\\u3060\\u3055\\u3044\\u3002\\u3054\\u5354\\u529B\\u3042\\u308A\\u304C\\u3068\\u3046\\u3054\\u3056\\u3044\\u307E\\u3059\\u3002\n+javac.msg.bug=\\u30B3\\u30F3\\u30D1\\u30A4\\u30E9\\u3067\\u4F8B\\u5916\\u304C\\u767A\\u751F\\u3057\\u307E\\u3057\\u305F({0})\\u3002Bug Database (https:\/\/bugs.java.com)\\u3067\\u91CD\\u8907\\u304C\\u306A\\u3044\\u304B\\u3092\\u3054\\u78BA\\u8A8D\\u306E\\u3046\\u3048\\u3001Java bug\\u30EC\\u30DD\\u30FC\\u30C8\\u30FB\\u30DA\\u30FC\\u30B8(https:\/\/bugreport.java.com)\\u3067Java\\u30B3\\u30F3\\u30D1\\u30A4\\u30E9\\u306B\\u5BFE\\u3059\\u308Bbug\\u306E\\u767B\\u9332\\u3092\\u304A\\u9858\\u3044\\u3044\\u305F\\u3057\\u307E\\u3059\\u3002\\u30EC\\u30DD\\u30FC\\u30C8\\u306B\\u306F\\u3001\\u305D\\u306E\\u30D7\\u30ED\\u30B0\\u30E9\\u30E0\\u3001\\u4E0B\\u8A18\\u306E\\u8A3A\\u65AD\\u5185\\u5BB9\\u3001\\u304A\\u3088\\u3073Java\\u30B3\\u30F3\\u30D1\\u30A4\\u30E9\\u306B\\u6E21\\u3057\\u305F\\u30D1\\u30E9\\u30E1\\u30FC\\u30BF\\u3092\\u542B\\u3081\\u3066\\u304F\\u3060\\u3055\\u3044\\u3002\\u3054\\u5354\\u529B\\u3042\\u308A\\u304C\\u3068\\u3046\\u3054\\u3056\\u3044\\u307E\\u3059\\u3002\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac_ja.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-javac.msg.bug=\\u7F16\\u8BD1\\u5668 ({0}) \\u4E2D\\u51FA\\u73B0\\u5F02\\u5E38\\u9519\\u8BEF\\u3002\\u5982\\u679C\\u5728 Bug Database (http:\/\/bugs.java.com) \\u4E2D\\u6CA1\\u6709\\u627E\\u5230\\u8BE5\\u9519\\u8BEF\\uFF0C\\u8BF7\\u901A\\u8FC7 Java Bug \\u62A5\\u544A\\u9875 (http:\/\/bugreport.java.com) \\u5EFA\\u7ACB\\u8BE5 Java \\u7F16\\u8BD1\\u5668 Bug\\u3002\\u8BF7\\u5728\\u62A5\\u544A\\u4E2D\\u9644\\u4E0A\\u60A8\\u7684\\u7A0B\\u5E8F\\u3001\\u4EE5\\u4E0B\\u8BCA\\u65AD\\u4FE1\\u606F\\u4EE5\\u53CA\\u4F20\\u9012\\u5230 Java \\u7F16\\u8BD1\\u5668\\u7684\\u53C2\\u6570\\u3002\\u8C22\\u8C22\\u3002\n+javac.msg.bug=\\u7F16\\u8BD1\\u5668 ({0}) \\u4E2D\\u51FA\\u73B0\\u5F02\\u5E38\\u9519\\u8BEF\\u3002\\u5982\\u679C\\u5728 Bug Database (https:\/\/bugs.java.com) \\u4E2D\\u6CA1\\u6709\\u627E\\u5230\\u8BE5\\u9519\\u8BEF\\uFF0C\\u8BF7\\u901A\\u8FC7 Java Bug \\u62A5\\u544A\\u9875 (https:\/\/bugreport.java.com) \\u5EFA\\u7ACB\\u8BE5 Java \\u7F16\\u8BD1\\u5668 Bug\\u3002\\u8BF7\\u5728\\u62A5\\u544A\\u4E2D\\u9644\\u4E0A\\u60A8\\u7684\\u7A0B\\u5E8F\\u3001\\u4EE5\\u4E0B\\u8BCA\\u65AD\\u4FE1\\u606F\\u4EE5\\u53CA\\u4F20\\u9012\\u5230 Java \\u7F16\\u8BD1\\u5668\\u7684\\u53C2\\u6570\\u3002\\u8C22\\u8C22\\u3002\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac_zh_CN.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,0 +85,2 @@\n+launcher.err.security.manager=Quellcode-Launcher kann nicht mit aktiviertem Sicherheitsmanager verwendet werden\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/launcher_de.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,0 +85,2 @@\n+launcher.err.security.manager=\\u30BB\\u30AD\\u30E5\\u30EA\\u30C6\\u30A3\\u30FB\\u30DE\\u30CD\\u30FC\\u30B8\\u30E3\\u304C\\u6709\\u52B9\\u306A\\u72B6\\u614B\\u3067\\u30BD\\u30FC\\u30B9\\u30B3\\u30FC\\u30C9\\u30FB\\u30E9\\u30F3\\u30C1\\u30E3\\u3092\\u4F7F\\u7528\\u3059\\u308B\\u3053\\u3068\\u306F\\u3067\\u304D\\u307E\\u305B\\u3093\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/launcher_ja.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,0 +85,2 @@\n+launcher.err.security.manager=\\u65E0\\u6CD5\\u5728\\u542F\\u7528\\u5B89\\u5168\\u7BA1\\u7406\\u5668\\u7684\\u60C5\\u51B5\\u4E0B\\u4F7F\\u7528\\u6E90\\u4EE3\\u7801\\u542F\\u52A8\\u7A0B\\u5E8F\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/launcher_zh_CN.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -393,1 +393,1 @@\n-      rslt = hcreate_r(n, symtab->hash_table);\n+      rslt = hcreate_r(htab_sz, symtab->hash_table);\n","filename":"src\/jdk.hotspot.agent\/linux\/native\/libsaproc\/symtab.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -152,1 +152,1 @@\n-            panesPanel.add((JPanel)panels.elementAt(i), (Integer.valueOf(i)).toString());\n+            panesPanel.add((JPanel)panels.elementAt(i), Integer.toString(i));\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/com\/sun\/java\/swing\/ui\/WizardDlg.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.Objects;\n@@ -38,0 +39,2 @@\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n@@ -39,0 +42,1 @@\n+import jdk.internal.misc.TerminatingThreadLocal;\n@@ -236,0 +240,28 @@\n+    \/**\n+     * Creates a thread-local variable that notifies {@code onThreadTermination} when a thread\n+     * terminates and it has been initialized in the terminating thread (even if it was initialized\n+     * with a null value). A typical use is to release resources associated with a thread.\n+     *\n+     * @param initialValue a supplier to be used to determine the initial value\n+     * @param onThreadTermination a consumer invoked by a thread when terminating and the\n+     *            thread-local has an associated value for the terminating thread. The current\n+     *            thread's value of the thread-local variable is passed as a parameter to the\n+     *            consumer.\n+     *\/\n+    public static <T> ThreadLocal<T> createTerminatingThreadLocal(Supplier<T> initialValue, Consumer<T> onThreadTermination) {\n+        Objects.requireNonNull(initialValue, \"initialValue must be non null.\");\n+        Objects.requireNonNull(onThreadTermination, \"onThreadTermination must be non null.\");\n+        return new TerminatingThreadLocal<>() {\n+\n+            @Override\n+            protected T initialValue() {\n+                return initialValue.get();\n+            }\n+\n+            @Override\n+            protected void threadTerminated(T value) {\n+                onThreadTermination.accept(value);\n+            }\n+        };\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.services\/src\/jdk\/vm\/ci\/services\/Services.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,0 +120,2 @@\n+        {\".providerPath.option\",\n+                \"[-providerPath <list>]      Provider-Classpath\"},\n@@ -175,0 +177,1 @@\n+        {\"with.algparams.weak\", \"%1$s mit %2$s (schwach)\"},\n@@ -176,0 +179,1 @@\n+        {\"with.algparams.disabled\", \"%1$s mit %2$s (deaktiviert)\"},\n@@ -178,0 +182,1 @@\n+        {\"key.bit.eccurve.weak\", \"%1$d-Bit-%2$s-Schl\\u00FCssel (schwach)\"},\n@@ -179,0 +184,1 @@\n+        {\"key.bit.eccurve.disabled\", \"%1$d-Bit-%2$s-Schl\\u00FCssel (deaktiviert)\"},\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Resources_de.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,0 +120,2 @@\n+        {\".providerPath.option\",\n+                \"[-providerPath <list>]      \\u30D7\\u30ED\\u30D0\\u30A4\\u30C0\\u30FB\\u30AF\\u30E9\\u30B9\\u30D1\\u30B9\"},\n@@ -175,0 +177,1 @@\n+        {\"with.algparams.weak\", \"%2$s\\u3092\\u4F7F\\u7528\\u3057\\u305F%1$s (\\u5F31)\"},\n@@ -176,0 +179,1 @@\n+        {\"with.algparams.disabled\", \"%2$s\\u3092\\u4F7F\\u7528\\u3057\\u305F%1$s (\\u7121\\u52B9)\"},\n@@ -178,0 +182,1 @@\n+        {\"key.bit.eccurve.weak\", \"%1$d\\u30D3\\u30C3\\u30C8%2$s\\u30AD\\u30FC(\\u5F31)\"},\n@@ -179,0 +184,1 @@\n+        {\"key.bit.eccurve.disabled\", \"%1$d\\u30D3\\u30C3\\u30C8%2$s\\u30AD\\u30FC(\\u7121\\u52B9)\"},\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Resources_ja.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,0 +120,2 @@\n+        {\".providerPath.option\",\n+                \"[-providerPath <list>]      \\u63D0\\u4F9B\\u65B9\\u7C7B\\u8DEF\\u5F84\"},\n@@ -175,0 +177,1 @@\n+        {\"with.algparams.weak\", \"%1$s \\u4F7F\\u7528 %2$s\\uFF08\\u5F31\\uFF09\"},\n@@ -176,0 +179,1 @@\n+        {\"with.algparams.disabled\", \"%1$s \\u4F7F\\u7528 %2$s\\uFF08\\u7981\\u7528\\uFF09\"},\n@@ -178,0 +182,1 @@\n+        {\"key.bit.eccurve.weak\", \"%1$d \\u4F4D %2$s \\u5BC6\\u94A5 (\\u5F31)\"},\n@@ -179,0 +184,1 @@\n+        {\"key.bit.eccurve.disabled\", \"%1$d \\u4F4D %2$s \\u5BC6\\u94A5\\uFF08\\u7981\\u7528\\uFF09\"},\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Resources_zh_CN.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-usage.compat=Kompatibilit\\u00E4tsschnittstelle\\nVerwendung: jar {ctxui}[vfmn0PMe] [jar-file] [manifest-file] [entry-point] [-C dir] files] ...\\nOptionen:\\n    -c  erstellt ein neues Archiv\\n    -t  listet das Inhaltsverzeichnis f\\u00FCr das Archiv auf\\n    -x  extrahiert die benannten (oder alle) Dateien aus dem Archiv\\n    -u  aktualisiert ein vorhandenes Archiv\\n    -v  generiert Verbose-Ausgabe zur Standardausgabe\\n    -f  gibt den Archivdateinamen an\\n    -m  schlie\\u00DFt Manifestinformationen aus der angegebenen Manifestdatei ein\\n    -e  gibt den Anwendungseinstiegspunkt f\\u00FCr Standalone-Anwendungen an,\\n        die in einer ausf\\u00FChrbaren JAR-Datei geb\\u00FCndelt sind\\n    -0  speichert nur, keine ZIP-Komprimierung\\n    -P  beh\\u00E4lt die vorangestellten Komponenten \"\/\" (absoluter Pfad) und \"..\" (\\u00FCbergeordnetes Verzeichnis) aus dem Dateinamen bei\\n    -M  generiert keine Manifestdatei f\\u00FCr die Eintr\\u00E4ge\\n    -i  generiert Indexinformationen f\\u00FCr die angegebenen JAR-Dateien\\n    -C  wechselt zum angegebenen Verzeichnis und schlie\\u00DFt die folgende Datei ein\\nDateien, die Verzeichnisse sind, werden rekursiv verarbeitet.\\nDie Namen der Manifestdatei, der Archivdatei und des Einstiegspunkts werden\\nin der gleichen Reihenfolge wie die Flags \"m\", \"f\" und \"e\" verarbeitet.\\n\\nBeispiel 1: Zwei Klassendateien in einem Archiv classes.jar archivieren: \\n       jar cvf classes.jar Foo.class Bar.class \\nBeispiel 2: Eine vorhandene Manifestdatei \"mymanifest\" verwenden und alle\\n           Dateien im Verzeichnis foo\/ directory in \"classes.jar\" archivieren: \\n       jar cvfm classes.jar mymanifest -C foo\/ .\\n\n+usage.compat=Kompatibilit\\u00E4tsschnittstelle\\nVerwendung: jar {ctxui}[vfmn0PMe] [jar-file] [manifest-file] [entry-point] [-C dir] files] ...\\nOptionen:\\n    -c  erstellt ein neues Archiv (einschlie\\u00DFlich fehlender \\u00FCbergeordneter Verzeichnisse)\\n    -t  listet das Inhaltsverzeichnis f\\u00FCr das Archiv auf\\n    -x  extrahiert die benannten (oder alle) Dateien aus dem Archiv\\n    -u  aktualisiert ein vorhandenes Archiv\\n    -v  generiert Verbose-Ausgabe zur Standardausgabe\\n    -f  gibt den Archivdateinamen an\\n    -m  schlie\\u00DFt Manifestinformationen aus der angegebenen Manifestdatei ein\\n    -e  gibt den Anwendungseinstiegspunkt f\\u00FCr Standalone-Anwendungen an,\\n        die in einer ausf\\u00FChrbaren JAR-Datei geb\\u00FCndelt sind\\n    -0  speichert nur, keine ZIP-Komprimierung\\n    -P  beh\\u00E4lt die vorangestellten Komponenten \"\/\" (absoluter Pfad) und \"..\" (\\u00FCbergeordnetes Verzeichnis) aus Dateinamen bei\\n    -M  generiert keine Manifestdatei f\\u00FCr die Eintr\\u00E4ge\\n    -i  generiert Indexinformationen f\\u00FCr die angegebenen JAR-Dateien\\n    -C  wechselt zum angegebenen Verzeichnis und schlie\\u00DFt die folgende Datei ein\\nDateien, die Verzeichnisse sind, werden rekursiv verarbeitet.\\nDie Namen der Manifestdatei, der Archivdatei und des Einstiegspunkts werden\\nin der gleichen Reihenfolge wie die Flags \"m\", \"f\" und \"e\" angegeben.\\n\\nBeispiel 1: Zwei Klassendateien in einem Archiv namens classes.jar archivieren: \\n       jar cvf classes.jar Foo.class Bar.class \\nBeispiel 2: Die vorhandene Manifestdatei \"mymanifest\" verwenden und alle\\n           Dateien im Verzeichnis \"foo\/\" in \"classes.jar\" archivieren: \\n       jar cvfm classes.jar mymanifest -C foo\/ .\\n\n@@ -102,1 +102,1 @@\n-main.help.opt.main.create=\\  -c, --create               Archiv erstellen\n+main.help.opt.main.create=\\  -c, --create               Erstellt das Archiv. Wenn der mit\\n                             -f oder --file angegebene Archivdateiname einen Pfad enth\\u00E4lt, werden auch fehlende\\n                             \\u00FCbergeordnete Verzeichnisse erstellt\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/resources\/jar_de.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-usage.compat=\\u4E92\\u63DB\\u6027\\u30A4\\u30F3\\u30BF\\u30D5\\u30A7\\u30FC\\u30B9: \\n\\u4F7F\\u7528\\u65B9\\u6CD5: jar {ctxui}[vfmn0PMe] [jar-file] [manifest-file] [entry-point] [-C dir] files] ...\\n\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3:\\n    -c \\u30A2\\u30FC\\u30AB\\u30A4\\u30D6\\u3092\\u65B0\\u898F\\u4F5C\\u6210\\u3059\\u308B\\n    -t \\u30A2\\u30FC\\u30AB\\u30A4\\u30D6\\u306E\\u5185\\u5BB9\\u3092\\u4E00\\u89A7\\u8868\\u793A\\u3059\\u308B\\n    -x \\u6307\\u5B9A\\u306E(\\u307E\\u305F\\u306F\\u3059\\u3079\\u3066\\u306E)\\u30D5\\u30A1\\u30A4\\u30EB\\u3092\\u30A2\\u30FC\\u30AB\\u30A4\\u30D6\\u304B\\u3089\\u62BD\\u51FA\\u3059\\u308B\\n    -u \\u65E2\\u5B58\\u30A2\\u30FC\\u30AB\\u30A4\\u30D6\\u3092\\u66F4\\u65B0\\u3059\\u308B\\n    -v \\u6A19\\u6E96\\u51FA\\u529B\\u306B\\u8A73\\u7D30\\u306A\\u51FA\\u529B\\u3092\\u751F\\u6210\\u3059\\u308B\\n    -f \\u30A2\\u30FC\\u30AB\\u30A4\\u30D6\\u30FB\\u30D5\\u30A1\\u30A4\\u30EB\\u540D\\u3092\\u6307\\u5B9A\\u3059\\u308B\\n    -m \\u6307\\u5B9A\\u306E\\u30DE\\u30CB\\u30D5\\u30A7\\u30B9\\u30C8\\u30FB\\u30D5\\u30A1\\u30A4\\u30EB\\u304B\\u3089\\u30DE\\u30CB\\u30D5\\u30A7\\u30B9\\u30C8\\u60C5\\u5831\\u3092\\u53D6\\u308A\\u8FBC\\u3080\\n    -e \\u5B9F\\u884C\\u53EF\\u80FDjar\\u30D5\\u30A1\\u30A4\\u30EB\\u306B\\u30D0\\u30F3\\u30C9\\u30EB\\u3055\\u308C\\u305F\\u30B9\\u30BF\\u30F3\\u30C9\\u30A2\\u30ED\\u30F3\\u30FB\\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u306E\\n        \\u30A8\\u30F3\\u30C8\\u30EA\\u30FB\\u30DD\\u30A4\\u30F3\\u30C8\\u3092\\u6307\\u5B9A\\u3059\\u308B\\n    -0 \\u683C\\u7D0D\\u306E\\u307F\\u3002ZIP\\u5727\\u7E2E\\u3092\\u4F7F\\u7528\\u3057\\u306A\\u3044\\n    -P \\u30D5\\u30A1\\u30A4\\u30EB\\u540D\\u306E\\u5148\\u982D\\u306E'\/' (\\u7D76\\u5BFE\\u30D1\\u30B9)\\u304A\\u3088\\u3073\"..\" (\\u89AA\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA)\\u30B3\\u30F3\\u30DD\\u30FC\\u30CD\\u30F3\\u30C8\\u3092\\u4FDD\\u6301\\u3059\\u308B\\n    -M \\u30A8\\u30F3\\u30C8\\u30EA\\u306E\\u30DE\\u30CB\\u30D5\\u30A7\\u30B9\\u30C8\\u30FB\\u30D5\\u30A1\\u30A4\\u30EB\\u3092\\u4F5C\\u6210\\u3057\\u306A\\u3044\\n    -i \\u6307\\u5B9A\\u306Ejar\\u30D5\\u30A1\\u30A4\\u30EB\\u306E\\u7D22\\u5F15\\u60C5\\u5831\\u3092\\u751F\\u6210\\u3059\\u308B\\n    -C \\u6307\\u5B9A\\u306E\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA\\u306B\\u5909\\u66F4\\u3057\\u3001\\u6B21\\u306E\\u30D5\\u30A1\\u30A4\\u30EB\\u3092\\u53D6\\u308A\\u8FBC\\u3080\\n\\u30D5\\u30A1\\u30A4\\u30EB\\u304C\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA\\u306E\\u5834\\u5408\\u306F\\u518D\\u5E30\\u7684\\u306B\\u51E6\\u7406\\u3055\\u308C\\u307E\\u3059\\u3002\\n\\u30DE\\u30CB\\u30D5\\u30A7\\u30B9\\u30C8\\u30FB\\u30D5\\u30A1\\u30A4\\u30EB\\u540D\\u3001\\u30A2\\u30FC\\u30AB\\u30A4\\u30D6\\u30FB\\u30D5\\u30A1\\u30A4\\u30EB\\u540D\\u304A\\u3088\\u3073\\u30A8\\u30F3\\u30C8\\u30EA\\u30FB\\u30DD\\u30A4\\u30F3\\u30C8\\u540D\\u306F\\u3001\\n\\u30D5\\u30E9\\u30B0'm'\\u3001'f'\\u3001'e'\\u306E\\u6307\\u5B9A\\u3068\\u540C\\u3058\\u9806\\u756A\\u3067\\u6307\\u5B9A\\u3059\\u308B\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059\\u3002\\n\\n\\u4F8B1: 2\\u3064\\u306E\\u30AF\\u30E9\\u30B9\\u30FB\\u30D5\\u30A1\\u30A4\\u30EB\\u3092\\u30A2\\u30FC\\u30AB\\u30A4\\u30D6classes.jar\\u306B\\u4FDD\\u5B58\\u3059\\u308B:\\n     jar cvf classes.jar Foo.class Bar.class\\n\\u4F8B2: \\u65E2\\u5B58\\u306E\\u30DE\\u30CB\\u30D5\\u30A7\\u30B9\\u30C8\\u30FB\\u30D5\\u30A1\\u30A4\\u30EB'mymanifest'\\u3092\\u4F7F\\u7528\\u3057\\u3001foo\/\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA\\u306E\\n     \\u5168\\u30D5\\u30A1\\u30A4\\u30EB\\u3092'classes.jar'\\u306B\\u30A2\\u30FC\\u30AB\\u30A4\\u30D6\\u3059\\u308B:\\n     jar cvfm classes.jar mymanifest -C foo\/ . \\n\n+usage.compat=\\u4E92\\u63DB\\u6027\\u30A4\\u30F3\\u30BF\\u30D5\\u30A7\\u30FC\\u30B9:\\n\\u4F7F\\u7528\\u65B9\\u6CD5: jar {ctxui}[vfmn0PMe] [jar-file] [manifest-file] [entry-point] [-C dir] files] ...\\n\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3:\\n    -c  \\u30A2\\u30FC\\u30AB\\u30A4\\u30D6\\u3092\\u65B0\\u898F\\u4F5C\\u6210\\u3059\\u308B(\\u6B20\\u843D\\u3057\\u3066\\u3044\\u308B\\u89AA\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA\\u3092\\u542B\\u3080)\\n    -t  \\u30A2\\u30FC\\u30AB\\u30A4\\u30D6\\u306E\\u5185\\u5BB9\\u3092\\u4E00\\u89A7\\u8868\\u793A\\u3059\\u308B\\n    -x  \\u6307\\u5B9A\\u306E(\\u307E\\u305F\\u306F\\u3059\\u3079\\u3066\\u306E)\\u30D5\\u30A1\\u30A4\\u30EB\\u3092\\u30A2\\u30FC\\u30AB\\u30A4\\u30D6\\u304B\\u3089\\u62BD\\u51FA\\u3059\\u308B\\n    -u  \\u65E2\\u5B58\\u30A2\\u30FC\\u30AB\\u30A4\\u30D6\\u3092\\u66F4\\u65B0\\u3059\\u308B\\n    -v  \\u6A19\\u6E96\\u51FA\\u529B\\u306B\\u8A73\\u7D30\\u306A\\u51FA\\u529B\\u3092\\u751F\\u6210\\u3059\\u308B\\n    -f  \\u30A2\\u30FC\\u30AB\\u30A4\\u30D6\\u30FB\\u30D5\\u30A1\\u30A4\\u30EB\\u540D\\u3092\\u6307\\u5B9A\\u3059\\u308B\\n    -m  \\u6307\\u5B9A\\u306E\\u30DE\\u30CB\\u30D5\\u30A7\\u30B9\\u30C8\\u30FB\\u30D5\\u30A1\\u30A4\\u30EB\\u304B\\u3089\\u30DE\\u30CB\\u30D5\\u30A7\\u30B9\\u30C8\\u60C5\\u5831\\u3092\\u53D6\\u308A\\u8FBC\\u3080\\n    -e  \\u5B9F\\u884C\\u53EF\\u80FDjar\\u30D5\\u30A1\\u30A4\\u30EB\\u306B\\u30D0\\u30F3\\u30C9\\u30EB\\u3055\\u308C\\u305F\\u30B9\\u30BF\\u30F3\\u30C9\\u30A2\\u30ED\\u30F3\\u30FB\\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u306E \\n        \\u30A8\\u30F3\\u30C8\\u30EA\\u30FB\\u30DD\\u30A4\\u30F3\\u30C8\\u3092\\u6307\\u5B9A\\u3059\\u308B\\n    -0  \\u683C\\u7D0D\\u306E\\u307F\\u3002ZIP\\u5727\\u7E2E\\u3092\\u4F7F\\u7528\\u3057\\u306A\\u3044\\n    -P  \\u30D5\\u30A1\\u30A4\\u30EB\\u540D\\u306E\\u5148\\u982D\\u306E'\/' (\\u7D76\\u5BFE\\u30D1\\u30B9)\\u304A\\u3088\\u3073\"..\" (\\u89AA\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA)\\u30B3\\u30F3\\u30DD\\u30FC\\u30CD\\u30F3\\u30C8\\u3092\\u4FDD\\u6301\\u3059\\u308B\\n    -M  \\u30A8\\u30F3\\u30C8\\u30EA\\u306E\\u30DE\\u30CB\\u30D5\\u30A7\\u30B9\\u30C8\\u30FB\\u30D5\\u30A1\\u30A4\\u30EB\\u3092\\u4F5C\\u6210\\u3057\\u306A\\u3044\\n    -i  \\u6307\\u5B9A\\u306Ejar\\u30D5\\u30A1\\u30A4\\u30EB\\u306E\\u7D22\\u5F15\\u60C5\\u5831\\u3092\\u751F\\u6210\\u3059\\u308B\\n    -C  \\u6307\\u5B9A\\u306E\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA\\u306B\\u5909\\u66F4\\u3057\\u3001\\u6B21\\u306E\\u30D5\\u30A1\\u30A4\\u30EB\\u3092\\u53D6\\u308A\\u8FBC\\u3080\\n\\u30D5\\u30A1\\u30A4\\u30EB\\u304C\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA\\u306E\\u5834\\u5408\\u306F\\u518D\\u5E30\\u7684\\u306B\\u51E6\\u7406\\u3055\\u308C\\u307E\\u3059\\u3002\\n\\u30DE\\u30CB\\u30D5\\u30A7\\u30B9\\u30C8\\u30FB\\u30D5\\u30A1\\u30A4\\u30EB\\u540D\\u3001\\u30A2\\u30FC\\u30AB\\u30A4\\u30D6\\u30FB\\u30D5\\u30A1\\u30A4\\u30EB\\u540D\\u304A\\u3088\\u3073\\u30A8\\u30F3\\u30C8\\u30EA\\u30FB\\u30DD\\u30A4\\u30F3\\u30C8\\u540D\\u306F\\u3001\\n\\u30D5\\u30E9\\u30B0'm'\\u3001'f'\\u3001'e'\\u306E\\u6307\\u5B9A\\u3068\\u540C\\u3058\\u9806\\u756A\\u3067\\u6307\\u5B9A\\u3059\\u308B\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059\\u3002\\n\\n\\u4F8B1: 2\\u3064\\u306E\\u30AF\\u30E9\\u30B9\\u30FB\\u30D5\\u30A1\\u30A4\\u30EB\\u3092\\u30A2\\u30FC\\u30AB\\u30A4\\u30D6classes.jar\\u306B\\u4FDD\\u5B58\\u3059\\u308B: \\n       jar cvf classes.jar Foo.class Bar.class \\n\\u4F8B2: \\u65E2\\u5B58\\u306E\\u30DE\\u30CB\\u30D5\\u30A7\\u30B9\\u30C8\\u30FB\\u30D5\\u30A1\\u30A4\\u30EB'mymanifest'\\u3092\\u4F7F\\u7528\\u3057\\u3001foo\/\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA\\u306E\\n           \\u5168\\u30D5\\u30A1\\u30A4\\u30EB\\u3092'classes.jar'\\u306B\\u30A2\\u30FC\\u30AB\\u30A4\\u30D6\\u3059\\u308B: \\n       jar cvfm classes.jar mymanifest -C foo\/ .\\n\n@@ -102,5 +102,5 @@\n-main.help.opt.main.create=\\  -c, --create               \\u30A2\\u30FC\\u30AB\\u30A4\\u30D6\\u3092\\u4F5C\\u6210\\u3057\\u307E\\u3059\n-main.help.opt.main.generate-index=\\  -i, --generate-index=FILE  \\u6307\\u5B9A\\u306Ejar\\u30A2\\u30FC\\u30AB\\u30A4\\u30D6\\u306E\\u7D22\\u5F15\\u60C5\\u5831\\u3092\\n                             \\u751F\\u6210\\u3057\\u307E\\u3059\n-main.help.opt.main.list=\\  -t, --list                 \\u30A2\\u30FC\\u30AB\\u30A4\\u30D6\\u306E\\u5185\\u5BB9\\u3092\\u4E00\\u89A7\\u8868\\u793A\\u3057\\u307E\\u3059\n-main.help.opt.main.update=\\  -u, --update               \\u65E2\\u5B58\\u306Ejar\\u30A2\\u30FC\\u30AB\\u30A4\\u30D6\\u3092\\u66F4\\u65B0\\u3057\\u307E\\u3059\n-main.help.opt.main.extract=\\  -x, --extract              \\u6307\\u5B9A\\u306E(\\u307E\\u305F\\u306F\\u3059\\u3079\\u3066\\u306E)\\u30D5\\u30A1\\u30A4\\u30EB\\u3092\\u30A2\\u30FC\\u30AB\\u30A4\\u30D6\\u304B\\u3089\\u62BD\\u51FA\\u3057\\u307E\\u3059\n+main.help.opt.main.create=\\  -c\\u3001--create               \\u30A2\\u30FC\\u30AB\\u30A4\\u30D6\\u3092\\u4F5C\\u6210\\u3057\\u307E\\u3059\\u3002-f\\u307E\\u305F\\u306F--file\\u3067\\u6307\\u5B9A\\u3055\\u308C\\u305F\\n                             \\u30A2\\u30FC\\u30AB\\u30A4\\u30D6\\u30FB\\u30D5\\u30A1\\u30A4\\u30EB\\u540D\\u306B\\u30D1\\u30B9\\u304C\\u542B\\u307E\\u308C\\u3066\\u3044\\u308B\\u5834\\u5408\\u306F\\u3001\\n                             \\u6B20\\u843D\\u3057\\u3066\\u3044\\u308B\\u89AA\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA\\u3082\\u4F5C\\u6210\\u3055\\u308C\\u307E\\u3059\n+main.help.opt.main.generate-index=\\  -i,\\u3001--generate-index=FILE  \\u6307\\u5B9A\\u306Ejar\\u30A2\\u30FC\\u30AB\\u30A4\\u30D6\\u306E\\u7D22\\u5F15\\u60C5\\u5831\\u3092\\n                             \\u751F\\u6210\\u3057\\u307E\\u3059\n+main.help.opt.main.list=\\  -t\\u3001--list                 \\u30A2\\u30FC\\u30AB\\u30A4\\u30D6\\u306E\\u5185\\u5BB9\\u3092\\u4E00\\u89A7\\u8868\\u793A\\u3057\\u307E\\u3059\n+main.help.opt.main.update=\\  -u\\u3001--update               \\u65E2\\u5B58\\u306Ejar\\u30A2\\u30FC\\u30AB\\u30A4\\u30D6\\u3092\\u66F4\\u65B0\\u3057\\u307E\\u3059\n+main.help.opt.main.extract=\\  -x\\u3001--extract              \\u6307\\u5B9A\\u306E(\\u307E\\u305F\\u306F\\u3059\\u3079\\u3066\\u306E)\\u30D5\\u30A1\\u30A4\\u30EB\\u3092\\u30A2\\u30FC\\u30AB\\u30A4\\u30D6\\u304B\\u3089\\u62BD\\u51FA\\u3057\\u307E\\u3059\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/resources\/jar_ja.properties","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-usage.compat=\\u517C\\u5BB9\\u6027\\u63A5\\u53E3\\uFF1A\\n\\u7528\\u6CD5\\uFF1Ajar {ctxui}[vfmn0PMe] [jar-file] [manifest-file] [entry-point] [-C dir] files] ...\\n\\u9009\\u9879\\uFF1A\\n    -c  \\u521B\\u5EFA\\u65B0\\u6863\\u6848\\n    -t  \\u5217\\u51FA\\u6863\\u6848\\u76EE\\u5F55\\n    -x  \\u4ECE\\u6863\\u6848\\u4E2D\\u63D0\\u53D6\\u6307\\u5B9A\\u7684\\uFF08\\u6216\\u6240\\u6709\\uFF09\\u6587\\u4EF6\\n    -u  \\u66F4\\u65B0\\u73B0\\u6709\\u6863\\u6848\\n    -v  \\u5728\\u6807\\u51C6\\u8F93\\u51FA\\u4E2D\\u751F\\u6210\\u8BE6\\u7EC6\\u8F93\\u51FA\\n    -f  \\u6307\\u5B9A\\u6863\\u6848\\u6587\\u4EF6\\u540D\\n    -m  \\u5305\\u542B\\u6307\\u5B9A\\u6E05\\u5355\\u6587\\u4EF6\\u4E2D\\u7684\\u6E05\\u5355\\u4FE1\\u606F\\n    -e  \\u4E3A\\u6346\\u7ED1\\u5230\\u53EF\\u6267\\u884C jar \\u6587\\u4EF6\\u7684\\u72EC\\u7ACB\\u5E94\\u7528\\u7A0B\\u5E8F\\n        \\u6307\\u5B9A\\u5E94\\u7528\\u7A0B\\u5E8F\\u5165\\u53E3\\u70B9\\n    -0  \\u4EC5\\u5B58\\u50A8\\uFF1B\\u4E0D\\u4F7F\\u7528\\u4EFB\\u4F55 ZIP \\u538B\\u7F29\\n    -P  \\u4FDD\\u7559\\u6587\\u4EF6\\u540D\\u4E2D\\u7684\\u524D\\u5BFC '\/'\\uFF08\\u7EDD\\u5BF9\\u8DEF\\u5F84\\uFF09\\u548C \"..\"\\uFF08\\u7236\\u76EE\\u5F55\\uFF09\\u7EC4\\u6210\\u90E8\\u5206\\n    -M  \\u4E0D\\u521B\\u5EFA\\u6761\\u76EE\\u7684\\u6E05\\u5355\\u6587\\u4EF6\\n    -i  \\u4E3A\\u6307\\u5B9A\\u7684 jar \\u6587\\u4EF6\\u751F\\u6210\\u7D22\\u5F15\\u4FE1\\u606F\\n    -C  \\u66F4\\u6539\\u4E3A\\u6307\\u5B9A\\u7684\\u76EE\\u5F55\\u5E76\\u5305\\u542B\\u4EE5\\u4E0B\\u6587\\u4EF6\\n\\u5982\\u679C\\u4EFB\\u4F55\\u6587\\u4EF6\\u4E3A\\u76EE\\u5F55\\uFF0C\\u5219\\u5BF9\\u5176\\u8FDB\\u884C\\u9012\\u5F52\\u5904\\u7406\\u3002\\n\\u6E05\\u5355\\u6587\\u4EF6\\u540D\\u3001\\u6863\\u6848\\u6587\\u4EF6\\u540D\\u548C\\u5165\\u53E3\\u70B9\\u540D\\u79F0\\u7684\\u6307\\u5B9A\\u987A\\u5E8F\\n\\u4E0E 'm', 'f' \\u548C 'e' \\u6807\\u8BB0\\u7684\\u6307\\u5B9A\\u987A\\u5E8F\\u76F8\\u540C\\u3002\\n\\n\\u793A\\u4F8B 1\\uFF1A\\u5C06\\u4E24\\u4E2A\\u7C7B\\u6587\\u4EF6\\u5F52\\u6863\\u5230\\u4E00\\u4E2A\\u540D\\u4E3A classes.jar \\u7684\\u6863\\u6848\\u4E2D\\uFF1A\\n       jar cvf classes.jar Foo.class Bar.class \\n\\u793A\\u4F8B 2\\uFF1A\\u4F7F\\u7528\\u73B0\\u6709\\u7684\\u6E05\\u5355\\u6587\\u4EF6 'mymanifest' \\u5E76\\n           \\u5C06 foo\/ \\u76EE\\u5F55\\u4E2D\\u7684\\u6240\\u6709\\u6587\\u4EF6\\u5F52\\u6863\\u5230 'classes.jar' \\u4E2D\\uFF1A\\n       jar cvfm classes.jar mymanifest -C foo\/\\u3002\\n\n+usage.compat=\\u517C\\u5BB9\\u6027\\u63A5\\u53E3\\uFF1A\\n\\u7528\\u6CD5\\uFF1Ajar {ctxui}[vfmn0PMe] [jar-file] [manifest-file] [entry-point] [-C dir] files] ...\\n\\u9009\\u9879\\uFF1A\\n    -c  \\u521B\\u5EFA\\u65B0\\u6863\\u6848\\uFF08\\u5305\\u62EC\\u7F3A\\u5C11\\u7684\\u7236\\u76EE\\u5F55\\uFF09\\n    -t  \\u5217\\u51FA\\u6863\\u6848\\u76EE\\u5F55\\n    -x  \\u4ECE\\u6863\\u6848\\u4E2D\\u63D0\\u53D6\\u6307\\u5B9A\\u7684\\uFF08\\u6216\\u6240\\u6709\\uFF09\\u6587\\u4EF6\\n    -u  \\u66F4\\u65B0\\u73B0\\u6709\\u6863\\u6848\\n    -v  \\u5728\\u6807\\u51C6\\u8F93\\u51FA\\u4E2D\\u751F\\u6210\\u8BE6\\u7EC6\\u8F93\\u51FA\\n    -f  \\u6307\\u5B9A\\u6863\\u6848\\u6587\\u4EF6\\u540D\\n    -m  \\u5305\\u542B\\u6307\\u5B9A\\u6E05\\u5355\\u6587\\u4EF6\\u4E2D\\u7684\\u6E05\\u5355\\u4FE1\\u606F\\n    -e  \\u4E3A\\u6346\\u7ED1\\u5230\\u53EF\\u6267\\u884C jar \\u6587\\u4EF6\\u7684\\u72EC\\u7ACB\\u5E94\\u7528\\u7A0B\\u5E8F\\n        \\u6307\\u5B9A\\u5E94\\u7528\\u7A0B\\u5E8F\\u5165\\u53E3\\u70B9\\n    -0  \\u4EC5\\u5B58\\u50A8\\uFF1B\\u4E0D\\u4F7F\\u7528\\u4EFB\\u4F55 ZIP \\u538B\\u7F29\\n    -P  \\u4FDD\\u7559\\u6587\\u4EF6\\u540D\\u4E2D\\u7684\\u524D\\u5BFC '\/'\\uFF08\\u7EDD\\u5BF9\\u8DEF\\u5F84\\uFF09\\u548C \"..\"\\uFF08\\u7236\\u76EE\\u5F55\\uFF09\\u7EC4\\u6210\\u90E8\\u5206\\n    -M  \\u4E0D\\u521B\\u5EFA\\u6761\\u76EE\\u7684\\u6E05\\u5355\\u6587\\u4EF6\\n    -i  \\u4E3A\\u6307\\u5B9A\\u7684 jar \\u6587\\u4EF6\\u751F\\u6210\\u7D22\\u5F15\\u4FE1\\u606F\\n    -C  \\u66F4\\u6539\\u4E3A\\u6307\\u5B9A\\u7684\\u76EE\\u5F55\\u5E76\\u5305\\u542B\\u4EE5\\u4E0B\\u6587\\u4EF6\\n\\u5982\\u679C\\u4EFB\\u4F55\\u6587\\u4EF6\\u4E3A\\u76EE\\u5F55\\uFF0C\\u5219\\u5BF9\\u5176\\u8FDB\\u884C\\u9012\\u5F52\\u5904\\u7406\\u3002\\n\\u6E05\\u5355\\u6587\\u4EF6\\u540D\\u3001\\u6863\\u6848\\u6587\\u4EF6\\u540D\\u548C\\u5165\\u53E3\\u70B9\\u540D\\u79F0\\u7684\\u6307\\u5B9A\\u987A\\u5E8F\\n\\u4E0E 'm', 'f' \\u548C 'e' \\u6807\\u8BB0\\u7684\\u6307\\u5B9A\\u987A\\u5E8F\\u76F8\\u540C\\u3002\\n\\n\\u793A\\u4F8B 1\\uFF1A\\u5C06\\u4E24\\u4E2A\\u7C7B\\u6587\\u4EF6\\u5F52\\u6863\\u5230\\u4E00\\u4E2A\\u540D\\u4E3A classes.jar \\u7684\\u6863\\u6848\\u4E2D\\uFF1A\\n       jar cvf classes.jar Foo.class Bar.class \\n\\u793A\\u4F8B 2\\uFF1A\\u4F7F\\u7528\\u73B0\\u6709\\u7684\\u6E05\\u5355\\u6587\\u4EF6 'mymanifest' \\u5E76\\n           \\u5C06 foo\/ \\u76EE\\u5F55\\u4E2D\\u7684\\u6240\\u6709\\u6587\\u4EF6\\u5F52\\u6863\\u5230 'classes.jar' \\u4E2D\\uFF1A\\n       jar cvfm classes.jar mymanifest -C foo\/\\u3002\\n\n@@ -102,1 +102,1 @@\n-main.help.opt.main.create=\\  -c, --create               \\u521B\\u5EFA\\u6863\\u6848\n+main.help.opt.main.create=\\  -c, --create               \\u521B\\u5EFA\\u6863\\u6848\\u3002\\u901A\\u8FC7 -f \\u6216 --file \\u6307\\u5B9A\\u7684\\u6863\\u6848\\u6587\\u4EF6\\u540D\\n                             \\u5305\\u542B\\u8DEF\\u5F84\\u65F6\\uFF0C\\u8FD8\\u5C06\\u521B\\u5EFA\\n                             \\u7F3A\\u5C11\\u7684\\u7236\\u76EE\\u5F55\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/resources\/jar_zh_CN.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n@@ -46,1 +47,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;\n@@ -214,1 +214,1 @@\n-            sep = \",\" + DocletConstants.NL + \" \";\n+            sep = \",\" + Text.NL + \" \";\n@@ -228,1 +228,1 @@\n-                                .add(DocletConstants.NL)\n+                                .add(Text.NL)\n@@ -240,1 +240,1 @@\n-            result.add(DocletConstants.NL);\n+            result.add(Text.NL);\n@@ -247,1 +247,1 @@\n-                            .add(DocletConstants.NL)\n+                            .add(Text.NL)\n@@ -271,1 +271,1 @@\n-                result.add(DocletConstants.NL);\n+                result.add(Text.NL);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AbstractExecutableMemberWriter.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-            addInlineDeprecatedComment(e, tags.get(0), desc);\n+            addInlineComment(e, tags.get(0), desc);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/DeprecatedListWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;\n@@ -235,1 +234,1 @@\n-                                localTags.add(docTreeFactory.newTextTree(DocletConstants.NL));\n+                                localTags.add(docTreeFactory.newTextTree(\"\\n\"));\n@@ -251,1 +250,1 @@\n-                                localTags.add(docTreeFactory.newTextTree(DocletConstants.NL));\n+                                localTags.add(docTreeFactory.newTextTree(\"\\n\"));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/DocFilesHandlerImpl.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.util.Date;\n@@ -47,1 +46,0 @@\n-import com.sun.source.util.DocTreePath;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlConfiguration.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -305,3 +305,0 @@\n-\n-            f = DocFile.createFileForOutput(configuration, DocPaths.JQUERY_OVERRIDES_CSS);\n-            f.copyResource(DOCLET_RESOURCES.resolve(DocPaths.JQUERY_OVERRIDES_CSS), true, true);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDoclet.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -107,1 +107,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;\n@@ -175,0 +174,2 @@\n+    private final Set<String> headingIds = new HashSet<>();\n+\n@@ -1170,1 +1171,1 @@\n-                return super.add(utils.normalizeNewlines(text));\n+                return super.add(Text.normalizeNewlines(text));\n@@ -1206,4 +1207,0 @@\n-                private boolean equalsIgnoreCase(Name name, String s) {\n-                    return name != null && name.toString().equalsIgnoreCase(s);\n-                }\n-\n@@ -1362,1 +1359,1 @@\n-                    Content t = Text.of(utils.normalizeNewlines(s));\n+                    Content t = Text.of(Text.normalizeNewlines(s));\n@@ -1370,0 +1367,3 @@\n+                    if (node.getName().toString().matches(\"(?i)h[1-6]\") && !hasIdAttribute(node)) {\n+                        generateHeadingId(node, trees, attrs);\n+                    }\n@@ -1407,1 +1407,1 @@\n-                    return utils.normalizeNewlines(text);\n+                    return Text.normalizeNewlines(text);\n@@ -1439,0 +1439,33 @@\n+    private boolean equalsIgnoreCase(Name name, String s) {\n+        return name != null && name.toString().equalsIgnoreCase(s);\n+    }\n+\n+    private boolean hasIdAttribute(StartElementTree node) {\n+        return node.getAttributes().stream().anyMatch(\n+                dt -> dt instanceof AttributeTree at && equalsIgnoreCase(at.getName(), \"id\"));\n+    }\n+\n+    private void generateHeadingId(StartElementTree node, List<? extends DocTree> trees, Content content) {\n+        StringBuilder sb = new StringBuilder();\n+        String tagName = node.getName().toString().toLowerCase(Locale.ROOT);\n+        for (DocTree docTree : trees.subList(trees.indexOf(node) + 1, trees.size())) {\n+            if (docTree instanceof TextTree text) {\n+                sb.append(text.getBody());\n+            } else if (docTree instanceof LiteralTree literal) {\n+                sb.append(literal.getBody().getBody());\n+            } else if (docTree instanceof LinkTree link) {\n+                var label = link.getLabel();\n+                sb.append(label.isEmpty() ? link.getReference().getSignature() : label.toString());\n+            } else if (docTree instanceof EndElementTree endElement\n+                    && equalsIgnoreCase(endElement.getName(), tagName)) {\n+                break;\n+            } else if (docTree instanceof StartElementTree nested\n+                    && equalsIgnoreCase(nested.getName(), \"a\")\n+                    && hasIdAttribute(nested)) {\n+                return; \/\/ Avoid generating id if embedded <a id=...> is present\n+            }\n+        }\n+        HtmlId htmlId = htmlIds.forHeading(sb, headingIds);\n+        content.add(\"id=\\\"\").add(htmlId.name()).add(\"\\\"\");\n+    }\n+\n@@ -1701,1 +1734,1 @@\n-            annotation.add(lineBreak ? DocletConstants.NL : \"\");\n+            annotation.add(lineBreak ? Text.NL : \"\");\n@@ -1733,1 +1766,1 @@\n-                        annotation.add(DocletConstants.NL);\n+                        annotation.add(Text.NL);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":43,"deletions":10,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Set;\n@@ -514,0 +515,25 @@\n+\n+    \/**\n+     * Returns an id for a heading in a doc comment. The id value is derived from the contents\n+     * of the heading with additional checks to make it unique within its containing page.\n+     *\n+     * @param headingText the text contained by the heading\n+     * @param headingIds the set of heading ids already generated for the current page\n+     * @return a unique id value for the heading\n+     *\/\n+    public HtmlId forHeading(CharSequence headingText, Set<String> headingIds) {\n+        String idValue = headingText.toString()\n+                .toLowerCase(Locale.ROOT)\n+                .trim()\n+                .replaceAll(\"[^\\\\w_-]+\", \"-\");\n+        \/\/ Make id value unique\n+        idValue = idValue + \"-heading\";\n+        if (!headingIds.add(idValue)) {\n+            int counter = 1;\n+            while (!headingIds.add(idValue + counter)) {\n+                counter++;\n+            }\n+            idValue = idValue + counter;\n+        }\n+        return HtmlId.of(idValue);\n+    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlIds.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n@@ -47,1 +48,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;\n@@ -181,1 +181,1 @@\n-                        links.add(DocletConstants.NL);\n+                        links.add(Text.NL);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlLinkFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;\n@@ -153,1 +152,1 @@\n-                        content.add(DocletConstants.NL);\n+                        content.add(Text.NL);\n@@ -170,1 +169,1 @@\n-                            extendsImplements.add(DocletConstants.NL);\n+                            extendsImplements.add(Text.NL);\n@@ -195,1 +194,1 @@\n-                        content.add(DocletConstants.NL);\n+                        content.add(Text.NL);\n@@ -224,1 +223,1 @@\n-                        .forEach(a -> { content.add(a).add(\" \"); });\n+                        .forEach(a -> content.add(a).add(\" \"));\n@@ -547,1 +546,1 @@\n-                target.add(DocletConstants.NL);\n+                target.add(Text.NL);\n@@ -577,1 +576,1 @@\n-                target.add(DocletConstants.NL)\n+                target.add(Text.NL)\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Signatures.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;\n@@ -72,1 +71,1 @@\n-    private static final String NEW_LINE = DocletConstants.NL;\n+    private static final String NEW_LINE = Text.NL;\n@@ -292,1 +291,1 @@\n-            span.add(\"00\" + Integer.toString(lineno));\n+            span.add(\"00\" + lineno);\n@@ -294,1 +293,1 @@\n-            span.add(\"0\" + Integer.toString(lineno));\n+            span.add(\"0\" + lineno);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SourceToHTMLConverter.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.util.LinkedHashMap;\n@@ -35,1 +34,0 @@\n-import java.util.Map;\n@@ -357,2 +355,2 @@\n-    public boolean write(Writer out, boolean atNewline) throws IOException {\n-        return toContent().write(out, atNewline);\n+    public boolean write(Writer out, String newline, boolean atNewline) throws IOException {\n+        return toContent().write(out, newline, atNewline);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Table.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -143,2 +143,2 @@\n-    public boolean write(Writer out, boolean atNewline) throws IOException {\n-        return toContent().write(out, atNewline);\n+    public boolean write(Writer out, String newline, boolean atNewline) throws IOException {\n+        return toContent().write(out, newline, atNewline);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TableHeader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -211,1 +211,1 @@\n-        return HtmlTree.CODE(Text.of(utils.normalizeNewlines(tag.getBody().getBody())));\n+        return HtmlTree.CODE(Text.of(Text.normalizeNewlines(tag.getBody().getBody())));\n@@ -312,1 +312,1 @@\n-        return Text.of(utils.normalizeNewlines(tag.getBody().getBody()));\n+        return Text.of(Text.normalizeNewlines(tag.getBody().getBody()));\n@@ -317,7 +317,6 @@\n-        Content header;\n-        switch (kind) {\n-            case PARAMETER:         header = contents.parameters ; break;\n-            case TYPE_PARAMETER:    header = contents.typeParameters ; break;\n-            case RECORD_COMPONENT:  header = contents.recordComponents ; break;\n-            default: throw new IllegalArgumentException(kind.toString());\n-        }\n+        Content header = switch (kind) {\n+            case PARAMETER -> contents.parameters;\n+            case TYPE_PARAMETER -> contents.typeParameters;\n+            case RECORD_COMPONENT -> contents.recordComponents;\n+            default -> throw new IllegalArgumentException(kind.toString());\n+        };\n@@ -387,3 +386,3 @@\n-        links.stream().filter(Predicate.not(Content::isEmpty)).forEach(item -> {\n-            seeList.add(HtmlTree.LI(item));\n-        });\n+        links.stream()\n+                .filter(Predicate.not(Content::isEmpty))\n+                .forEach(item -> seeList.add(HtmlTree.LI(item)));\n@@ -633,1 +632,1 @@\n-            CharSequence text = utils.normalizeNewlines(sequence);\n+            CharSequence text = Text.normalizeNewlines(sequence);\n@@ -781,1 +780,1 @@\n-                        : Optional.of(Text.of(utils.normalizeNewlines(detail.get()))));\n+                        : Optional.of(Text.of(Text.normalizeNewlines(detail.get()))));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TagletWriterImpl.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-    private List<Content> mainContents = new ArrayList<>();\n+    private final List<Content> mainContents = new ArrayList<>();\n@@ -77,2 +77,2 @@\n-    public boolean write(Writer out, boolean atNewline) throws IOException {\n-        return toContent().write(out, atNewline);\n+    public boolean write(Writer out, String newline, boolean atNewline) throws IOException {\n+        return toContent().write(out, newline, atNewline);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/BodyContents.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;\n@@ -40,1 +39,1 @@\n-    private String commentText;\n+    private final String commentText;\n@@ -57,3 +56,4 @@\n-    public boolean write(Writer out, boolean atNewline) throws IOException {\n-        if (!atNewline)\n-            out.write(DocletConstants.NL);\n+    public boolean write(Writer out, String newline, boolean atNewline) throws IOException {\n+        if (!atNewline) {\n+            out.write(newline);\n+        }\n@@ -61,2 +61,3 @@\n-        out.write(commentText);\n-        out.write(\" -->\" + DocletConstants.NL);\n+        out.write(commentText.replace(\"\\n\", newline));\n+        out.write(\" -->\");\n+        out.write(newline);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/Comment.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-    public boolean write(Writer writer, boolean atNewline) throws IOException {\n+    public boolean write(Writer writer, String newline, boolean atNewline) throws IOException {\n@@ -81,1 +81,1 @@\n-            atNewline = content.write(writer, atNewline);\n+            atNewline = content.write(writer, newline, atNewline);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/ContentBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-    public boolean write(Writer writer, boolean atNewline) throws IOException {\n+    public boolean write(Writer writer, String newline, boolean atNewline) throws IOException {\n@@ -89,1 +89,1 @@\n-                case '<': case '>': case '&':\n+                case '<', '>', '&' -> {\n@@ -93,0 +93,1 @@\n+                }\n@@ -113,4 +114,4 @@\n-                case '<': sb.append(Entity.LESS_THAN.text);     break;\n-                case '>': sb.append(Entity.GREATER_THAN.text);  break;\n-                case '&': sb.append(Entity.AMPERSAND.text);     break;\n-                default:  sb.append(ch);                        break;\n+                case '<' -> sb.append(Entity.LESS_THAN.text);\n+                case '>' -> sb.append(Entity.GREATER_THAN.text);\n+                case '&' -> sb.append(Entity.AMPERSAND.text);\n+                default ->  sb.append(ch);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/Entity.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.util.Date;\n@@ -257,2 +256,2 @@\n-    public boolean write(Writer out, boolean atNewline) throws IOException {\n-        return toContent().write(out, atNewline);\n+    public boolean write(Writer out, String newline, boolean atNewline) throws IOException {\n+        return toContent().write(out, newline, atNewline);\n@@ -331,1 +330,0 @@\n-            \/\/ The order of the addStylesheet(...) calls is important\n@@ -333,1 +331,0 @@\n-            addStylesheet(head, DocPaths.JQUERY_OVERRIDES_CSS);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/Head.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.*;\n@@ -36,1 +35,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;\n@@ -56,0 +54,1 @@\n+     * Newlines are written using the platform line separator.\n@@ -62,1 +61,1 @@\n-            write(writer);\n+            write(writer, DocFile.PLATFORM_LINE_SEPARATOR);\n@@ -71,1 +70,1 @@\n-            write(writer);\n+            write(writer, \"\\n\");\n@@ -78,1 +77,1 @@\n-    private void write(Writer writer) throws IOException {\n+    private void write(Writer writer, String newline) throws IOException {\n@@ -80,2 +79,2 @@\n-        writer.write(DocletConstants.NL);\n-        docContent.write(writer, true);\n+        writer.write(newline);\n+        docContent.write(writer, newline, true);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/HtmlDocument.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import java.util.Iterator;\n@@ -44,1 +43,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;\n@@ -1054,1 +1052,1 @@\n-    public boolean write(Writer out, boolean atNewline) throws IOException {\n+    public boolean write(Writer out, String newline, boolean atNewline) throws IOException {\n@@ -1056,2 +1054,3 @@\n-        if (!isInline && !atNewline)\n-            out.write(DocletConstants.NL);\n+        if (!isInline && !atNewline) {\n+            out.write(newline);\n+        }\n@@ -1061,6 +1060,3 @@\n-        Iterator<HtmlAttr> iterator = attrs.keySet().iterator();\n-        HtmlAttr key;\n-        String value;\n-        while (iterator.hasNext()) {\n-            key = iterator.next();\n-            value = attrs.get(key);\n+        for (var attr : attrs.entrySet()) {\n+            var key = attr.getKey();\n+            var value = attr.getValue();\n@@ -1077,2 +1073,3 @@\n-        for (Content c : content)\n-            nl = c.write(out, nl);\n+        for (Content c : content) {\n+            nl = c.write(out, newline, nl);\n+        }\n@@ -1085,1 +1082,1 @@\n-            out.write(DocletConstants.NL);\n+            out.write(newline);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/HtmlTree.java","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;\n@@ -124,0 +123,1 @@\n+        assert Text.checkNewlines(rawHtml);\n@@ -154,8 +154,0 @@\n-                        case '\\r':\n-                            \/\/ Windows uses \"\\r\\n\" as line separator while UNIX uses \"\\n\".\n-                            \/\/ Skip the \"\\r\" to get consistent results across platforms.\n-                            if (i + 1 < htmlText.length() && htmlText.charAt(i + 1) == '\\n') {\n-                                i++;\n-                            }\n-                            count++;\n-                            break;\n@@ -195,3 +187,3 @@\n-    public boolean write(Writer out, boolean atNewline) throws IOException {\n-        out.write(rawHtmlContent);\n-        return rawHtmlContent.endsWith(DocletConstants.NL);\n+    public boolean write(Writer out, String newline, boolean atNewline) throws IOException {\n+        out.write(rawHtmlContent.replace(\"\\n\", newline));\n+        return rawHtmlContent.endsWith(\"\\n\");\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/RawHtml.java","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -200,1 +200,1 @@\n-        public boolean write(Writer writer, boolean atNewline) throws IOException {\n+        public boolean write(Writer writer, String newline, boolean atNewline) throws IOException {\n@@ -202,1 +202,1 @@\n-            writer.write(s.replace(\"\\n\", DocletConstants.NL));\n+            writer.write(s.replace(\"\\n\", newline));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/Script.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;\n@@ -36,0 +35,1 @@\n+ * Newlines are always represented by {@code \\n}.\n@@ -39,0 +39,1 @@\n+\n@@ -59,0 +60,1 @@\n+        assert checkNewlines(content);\n@@ -73,10 +75,1 @@\n-        int count = 0;\n-        for (int i = 0; i < cs.length(); i++) {\n-            \/\/ Windows uses \"\\r\\n\" as line separator while UNIX uses \"\\n\".\n-            \/\/ Skip the \"\\r\" to get consistent results across platforms.\n-            if (cs.charAt(i) == '\\r' && (i + 1 < cs.length()) && cs.charAt(i + 1) == '\\n') {\n-                i++;\n-            }\n-            count++;\n-        }\n-        return count;\n+        return cs.length();\n@@ -91,3 +84,51 @@\n-    public boolean write(Writer out, boolean atNewline) throws IOException {\n-        out.write(Entity.escapeHtmlChars(string));\n-        return string.endsWith(DocletConstants.NL);\n+    public boolean write(Writer out, String newline, boolean atNewline) throws IOException {\n+        out.write(Entity.escapeHtmlChars(string).replace(\"\\n\", newline));\n+        return string.endsWith(\"\\n\");\n+    }\n+\n+    \/**\n+     * The newline character, to be used when creating {@code Content} nodes.\n+     *\/\n+    public static final String NL = \"\\n\";\n+\n+    \/**\n+     * Returns a given string with all newlines in the form {@code \\n}.\n+     *\n+     * The sequences of interest are {@code \\n}, {@code \\r\\n}, and {@code \\r}.\n+     * {@code \\n} is already in the right form, so can be ignored,\n+     * leaving code to handle {@code \\r\\n}, and {@code \\r}.\n+     *\n+     * @param text the string\n+     * @return the string with newlines in the form {@code \\n}\n+     *\/\n+    public static CharSequence normalizeNewlines(CharSequence text) {\n+        \/\/ fast-track when the input is a string with no \\r characters\n+        if (text instanceof String s && s.indexOf('\\r') != -1) {\n+            return text;\n+        } else {\n+            var sb = new StringBuilder();\n+            var s = text.toString();\n+            int sLen = s.length();\n+            int start = 0;\n+            int pos;\n+            while ((pos = s.indexOf('\\r', start)) != -1) {\n+                sb.append(s, start, pos);\n+                sb.append('\\n');\n+                pos++;\n+                if (pos < sLen && s.charAt(pos) == '\\n') {\n+                    pos++;\n+                }\n+                start = pos;\n+            }\n+            sb.append(s.substring(start));\n+            return sb;\n+        }\n+    }\n+\n+    \/**\n+     * Check for the absence of {@code \\r} characters.\n+     * @param cs the characters to be checked\n+     * @return {@code true} if there are no {@code \\r} characters, and {@code false} otherwise\n+     *\/\n+    static boolean checkNewlines(CharSequence cs) {\n+        return !cs.toString().contains(\"\\r\");\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/Text.java","additions":55,"deletions":14,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;\n@@ -37,0 +36,1 @@\n+ * Newlines are always represented by {@code \\n}.\n@@ -56,0 +56,1 @@\n+        assert Text.checkNewlines(initialContent);\n@@ -66,0 +67,1 @@\n+        assert Text.checkNewlines(strContent);\n@@ -77,1 +79,1 @@\n-        return Text.charCount(stringBuilder);\n+        return stringBuilder.length();\n@@ -86,1 +88,1 @@\n-    public boolean write(Writer out, boolean atNewline) throws IOException {\n+    public boolean write(Writer out, String newline, boolean atNewline) throws IOException {\n@@ -88,2 +90,2 @@\n-        out.write(s);\n-        return s.endsWith(DocletConstants.NL);\n+        out.write(s.replace(\"\\n\", newline));\n+        return s.endsWith(\"\\n\");\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/TextBuilder.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-.ui-state-active,\n-.ui-widget-content .ui-state-active,\n-.ui-widget-header .ui-state-active,\n-a.ui-button:active,\n-.ui-button:active,\n-.ui-button.ui-state-active:hover {\n-    \/* Overrides the color of selection used in jQuery UI *\/\n-    background: #F8981D;\n-    border: 1px solid #F8981D;\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/jquery-ui.overrides.css","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -163,0 +163,6 @@\n+# 0: a date\n+doclet.Option_date_out_of_range=Wert f\\u00FCr \"--date\" au\\u00DFerhalb des g\\u00FCltigen Bereichs: {0}\n+\n+# 0: a date\n+doclet.Option_date_not_valid=Wert f\\u00FCr \"--date\" nicht g\\u00FCltig: {0}\n+\n@@ -313,0 +319,3 @@\n+doclet.usage.date.parameters=<date-and-time>\n+doclet.usage.date.description=Gibt den Wert f\\u00FCr den Zeitstempel der generierten Seiten im ISO 8601-Format an\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard_de.properties","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -163,0 +163,6 @@\n+# 0: a date\n+doclet.Option_date_out_of_range=''--date''\\u306E\\u5024\\u304C\\u7BC4\\u56F2\\u5916\\u3067\\u3059: {0}\n+\n+# 0: a date\n+doclet.Option_date_not_valid=''--date''\\u306E\\u5024\\u304C\\u6709\\u52B9\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093: {0}\n+\n@@ -313,0 +319,3 @@\n+doclet.usage.date.parameters=<date-and-time>\n+doclet.usage.date.description=\\u751F\\u6210\\u3055\\u308C\\u305F\\u30DA\\u30FC\\u30B8\\u3078\\u306E\\u30BF\\u30A4\\u30E0\\u30B9\\u30BF\\u30F3\\u30D7\\u4ED8\\u4E0E\\u306B\\u4F7F\\u7528\\u3059\\u308B\\u5024\\u3092\\nISO 8601\\u5F62\\u5F0F\\u3067\\u6307\\u5B9A\\u3057\\u307E\\u3059\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard_ja.properties","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -163,0 +163,6 @@\n+# 0: a date\n+doclet.Option_date_out_of_range=''--date'' \\u7684\\u503C\\u8D85\\u51FA\\u8303\\u56F4\\uFF1A{0}\n+\n+# 0: a date\n+doclet.Option_date_not_valid=''--date'' \\u7684\\u503C\\u65E0\\u6548\\uFF1A{0}\n+\n@@ -313,0 +319,3 @@\n+doclet.usage.date.parameters=<date-and-time>\n+doclet.usage.date.description=\\u4F7F\\u7528 ISO 8601 \\u683C\\u5F0F\\u6307\\u5B9A\\u7528\\u4E8E\\u5BF9\\u751F\\u6210\\u7684\\u9875\\u6807\\u8BB0\\u65F6\\u95F4\\u6233\\u7684\\u503C\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard_zh_CN.properties","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -323,0 +323,5 @@\n+    \/**\n+     * The default amount of space between tab stops.\n+     *\/\n+    public static final int DEFAULT_TAB_STOP_LENGTH = 8;\n+\n@@ -328,1 +333,1 @@\n-        sourceTabSize = DocletConstants.DEFAULT_TAB_STOP_LENGTH;\n+        sourceTabSize = DEFAULT_TAB_STOP_LENGTH;\n@@ -600,1 +605,1 @@\n-                            sourceTabSize = DocletConstants.DEFAULT_TAB_STOP_LENGTH;\n+                            sourceTabSize = DEFAULT_TAB_STOP_LENGTH;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/BaseOptions.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+     * Newlines are represented by {@code \\n}.\n@@ -48,1 +49,1 @@\n-            write(out, true);\n+            write(out, \"\\n\", true);\n@@ -109,1 +110,2 @@\n-     * Writes content to a writer.\n+     * Writes content to a writer, using a given newline sequence, which should be\n+     * either {@code \\n} or the platform line separator.\n@@ -112,0 +114,1 @@\n+     * @param newline the newline sequence to use\n@@ -116,1 +119,1 @@\n-    public abstract boolean write(Writer writer, boolean atNewline) throws IOException;\n+    public abstract boolean write(Writer writer, String newline, boolean atNewline) throws IOException;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/Content.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-(http:\/\/bugreport.java.com) after checking the Bug Database (http:\/\/bugs.java.com)\\n\\\n+(https:\/\/bugreport.java.com) after checking the Bug Database (https:\/\/bugs.java.com)\\n\\\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-doclet.internal.report.bug=Melden Sie auf der Java-Seite zum Melden von Bugs (http:\/\/bugreport.java.com) einen Bug\\nf\\u00FCr das javadoc-Tool, nachdem Sie in der Bugdatenbank (http:\/\/bugs.java.com) nach Duplikaten\\ngesucht haben. Nehmen Sie Fehlermeldungen und die folgende Diagnose in den Bericht auf. Vielen Dank.\n+doclet.internal.report.bug=Melden Sie auf der Java-Seite zum Melden von Bugs (https:\/\/bugreport.java.com) einen Bug\\nf\\u00FCr das javadoc-Tool, nachdem Sie in der Bugdatenbank (https:\/\/bugs.java.com) nach Duplikaten\\ngesucht haben. Nehmen Sie Fehlermeldungen und die folgende Diagnose in den Bericht auf. Vielen Dank.\n@@ -48,0 +48,1 @@\n+doclet.snippet_file_not_found=Datei nicht gefunden in Quellpfad oder Snippet-Pfad: {0}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets_de.properties","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-doclet.internal.report.bug=Bug Database (http:\/\/bugs.java.com)\\u3067\\u91CD\\u8907\\u304C\\u306A\\u3044\\u304B\\u3092\\u3054\\u78BA\\u8A8D\\u306E\\u3046\\u3048\\u3001Java bug\\u30EC\\u30DD\\u30FC\\u30C8\\u30FB\\u30DA\\u30FC\\u30B8\\n(http:\/\/bugreport.java.com)\\u3067javadoc\\u30C4\\u30FC\\u30EB\\u306B\\u5BFE\\u3059\\u308Bbug\\u306E\\u767B\\u9332\\u3092\\u304A\\u9858\\u3044\\u3044\\u305F\\u3057\\u307E\\u3059\\u3002\\n\\u30EC\\u30DD\\u30FC\\u30C8\\u306B\\u306F\\u3001\\u30A8\\u30E9\\u30FC\\u30FB\\u30E1\\u30C3\\u30BB\\u30FC\\u30B8\\u3068\\u6B21\\u306E\\u8A3A\\u65AD\\u5185\\u5BB9\\u3092\\u542B\\u3081\\u3066\\u304F\\u3060\\u3055\\u3044\\u3002\\u3054\\u5354\\u529B\\u3042\\u308A\\u304C\\u3068\\u3046\\u3054\\u3056\\u3044\\u307E\\u3059\\u3002\n+doclet.internal.report.bug=Bug Database (https:\/\/bugs.java.com)\\u3067\\u91CD\\u8907\\u304C\\u306A\\u3044\\u304B\\u3092\\u3054\\u78BA\\u8A8D\\u306E\\u3046\\u3048\\u3001Java bug\\u30EC\\u30DD\\u30FC\\u30C8\\u30FB\\u30DA\\u30FC\\u30B8\\n(https:\/\/bugreport.java.com)\\u3067javadoc\\u30C4\\u30FC\\u30EB\\u306B\\u5BFE\\u3059\\u308Bbug\\u306E\\u767B\\u9332\\u3092\\u304A\\u9858\\u3044\\u3044\\u305F\\u3057\\u307E\\u3059\\u3002\\n\\u30EC\\u30DD\\u30FC\\u30C8\\u306B\\u306F\\u3001\\u30A8\\u30E9\\u30FC\\u30FB\\u30E1\\u30C3\\u30BB\\u30FC\\u30B8\\u3068\\u6B21\\u306E\\u8A3A\\u65AD\\u5185\\u5BB9\\u3092\\u542B\\u3081\\u3066\\u304F\\u3060\\u3055\\u3044\\u3002\\u3054\\u5354\\u529B\\u3042\\u308A\\u304C\\u3068\\u3046\\u3054\\u3056\\u3044\\u307E\\u3059\\u3002\n@@ -48,0 +48,1 @@\n+doclet.snippet_file_not_found=\\u30BD\\u30FC\\u30B9\\u30FB\\u30D1\\u30B9\\u307E\\u305F\\u306F\\u30B9\\u30CB\\u30DA\\u30C3\\u30C8\\u306E\\u30D1\\u30B9\\u306B\\u30D5\\u30A1\\u30A4\\u30EB\\u304C\\u898B\\u3064\\u304B\\u308A\\u307E\\u305B\\u3093: {0}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets_ja.properties","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-doclet.internal.report.bug=\\u5982\\u679C\\u5728 Bug Database (http:\/\/bugs.java.com) \\u4E2D\\u6CA1\\u6709\\u627E\\u5230\\u91CD\\u590D\\u9879, \\n\\u8BF7\\u901A\\u8FC7 Java Bug \\u62A5\\u544A\\u9875 (http:\/\/bugreport.java.com) \\u9488\\u5BF9\\u8BE5 \\njavadoc \\u5DE5\\u5177\\u5EFA\\u7ACB Bug\\u3002\\u8BF7\\u5728\\u62A5\\u544A\\u4E2D\\u9644\\u4E0A\\u9519\\u8BEF\\u6D88\\u606F\\u548C\\u4EE5\\u4E0B\\u8BCA\\u65AD\\u4FE1\\u606F\\u3002\\u8C22\\u8C22\\u3002\n+doclet.internal.report.bug=\\u5982\\u679C\\u5728 Bug Database (https:\/\/bugs.java.com) \\u4E2D\\u6CA1\\u6709\\u627E\\u5230\\u91CD\\u590D\\u9879, \\n\\u8BF7\\u901A\\u8FC7 Java Bug \\u62A5\\u544A\\u9875 (https:\/\/bugreport.java.com) \\u9488\\u5BF9\\u8BE5 \\njavadoc \\u5DE5\\u5177\\u5EFA\\u7ACB Bug\\u3002\\u8BF7\\u5728\\u62A5\\u544A\\u4E2D\\u9644\\u4E0A\\u9519\\u8BEF\\u6D88\\u606F\\u548C\\u4EE5\\u4E0B\\u8BCA\\u65AD\\u4FE1\\u606F\\u3002\\u8C22\\u8C22\\u3002\n@@ -48,0 +48,1 @@\n+doclet.snippet_file_not_found=\\u5728\\u6E90\\u8DEF\\u5F84\\u6216\\u7247\\u6BB5\\u8DEF\\u5F84\\u4E2D\\u627E\\u4E0D\\u5230\\u6587\\u4EF6\\uFF1A{0}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets_zh_CN.properties","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -7,0 +7,42 @@\n+\/*\n+ * These CSS custom properties (variables) define the core color and font\n+ * properties used in this stylesheet.\n+ *\/\n+:root {\n+    \/* body, block and code fonts *\/\n+    --body-font-family: 'DejaVu Sans', Arial, Helvetica, sans-serif;\n+    --block-font-family: 'DejaVu Serif', Georgia, \"Times New Roman\", Times, serif;\n+    --code-font-family: 'DejaVu Sans Mono', monospace;\n+    \/* Base font sizes for body and code elements *\/\n+    --body-font-size: 14px;\n+    --code-font-size: 14px;\n+    \/* Text colors for body and block elements *\/\n+    --body-text-color: #353833;\n+    --block-text-color: #474747;\n+    \/* Background colors for various structural elements *\/\n+    --body-background-color: #ffffff;\n+    --section-background-color: #f8f8f8;\n+    --detail-background-color: #ffffff;\n+    \/* Colors for navigation bar and table captions *\/\n+    --navbar-background-color: #4D7A97;\n+    --navbar-text-color: #ffffff;\n+    \/* Background color for subnavigation and various headers *\/\n+    --subnav-background-color: #dee3e9;\n+    \/* Background and text colors for highlighted elements *\/\n+    --highlight-background-color: #f8981d;\n+    --highlight-text-color: #253441;\n+    \/* Background colors for generated tables *\/\n+    --even-row-color: #ffffff;\n+    --odd-row-color: #eeeeef;\n+    \/* Text color for page title *\/\n+    --title-color: #2c4557;\n+    \/* Text colors for links *\/\n+    --link-color: #4A6782;\n+    --link-color-active: #bb7a2a;\n+    \/* Snippet colors *\/\n+    --snippet-background-color: #ebecee;\n+    --snippet-text-color: var(--block-text-color);\n+    \/* Border colors for structural elements and user defined tables *\/\n+    --border-color: #ededed;\n+    --table-border-color: #000000;\n+}\n@@ -13,1 +55,0 @@\n-\n@@ -15,4 +56,4 @@\n-    background-color:#ffffff;\n-    color:#353833;\n-    font-family:'DejaVu Sans', Arial, Helvetica, sans-serif;\n-    font-size:14px;\n+    background-color:var(--body-background-color);\n+    color:var(--body-text-color);\n+    font-family:var(--body-font-family);\n+    font-size:var(--body-font-size);\n@@ -34,1 +75,1 @@\n-    color:#4A6782;\n+    color:var(--link-color);\n@@ -38,1 +79,1 @@\n-    color:#bb7a2a;\n+    color:var(--link-color-active);\n@@ -44,2 +85,2 @@\n-    font-family:'DejaVu Sans Mono', monospace;\n-    font-size:14px;\n+    font-family:var(--code-font-family);\n+    font-size:1em;\n@@ -48,1 +89,1 @@\n-    font-size:20px;\n+    font-size:1.428em;\n@@ -51,1 +92,1 @@\n-    font-size:18px;\n+    font-size:1.285em;\n@@ -54,1 +95,1 @@\n-    font-size:16px;\n+    font-size:1.14em;\n@@ -57,1 +98,1 @@\n-    font-size:15px;\n+    font-size:1.072em;\n@@ -60,1 +101,1 @@\n-    font-size:14px;\n+    font-size:1.001em;\n@@ -63,1 +104,1 @@\n-    font-size:13px;\n+    font-size:0.93em;\n@@ -73,1 +114,1 @@\n-    font-family:'DejaVu Sans Mono', monospace;\n+    font-family:var(--code-font-family);\n@@ -77,1 +118,1 @@\n-    font-size:14px;\n+    font-size:var(--code-font-size);\n@@ -83,2 +124,2 @@\n-    font-family:'DejaVu Sans Mono', monospace;\n-    font-size:14px;\n+    font-family:var(--code-font-family);\n+    font-size:1em;\n@@ -88,2 +129,2 @@\n-    font-family:'DejaVu Sans Mono', monospace;\n-    font-size:14px;\n+    font-family:var(--code-font-family);\n+    font-size:1em;\n@@ -97,2 +138,2 @@\n-    font-family: 'DejaVu Sans', Arial, Helvetica, sans-serif;\n-    font-size: 14px;\n+    font-family: var(--body-font-family);\n+    font-size: 1em;\n@@ -112,1 +153,1 @@\n-    font-size:11px;\n+    font-size:0.915em;\n@@ -139,2 +180,2 @@\n-    background-color:#4D7A97;\n-    color:#FFFFFF;\n+    background-color:var(--navbar-background-color);\n+    color:var(--navbar-text-color);\n@@ -148,1 +189,1 @@\n-    font-size:12px;\n+    font-size:0.857em;\n@@ -157,1 +198,1 @@\n-    background-color:#dee3e9;\n+    background-color:var(--subnav-background-color);\n@@ -161,1 +202,1 @@\n-    font-size:12px;\n+    font-size:0.857em;\n@@ -201,1 +242,1 @@\n-    color:#ffffff;\n+    color:var(--navbar-text-color);\n@@ -209,2 +250,2 @@\n-    background-color:#F8981D;\n-    color:#253441;\n+    background-color:var(--highlight-background-color);\n+    color:var(--highlight-text-color);\n@@ -231,1 +272,1 @@\n-    color:#2c4557;\n+    color:var(--title-color);\n@@ -243,1 +284,1 @@\n-    font-size:13px;\n+    font-size:0.93em;\n@@ -250,2 +291,2 @@\n-body.class-use-page  h2,\n-body.module-declaration-page  .block-list h2 {\n+body.class-use-page h2,\n+body.module-declaration-page .block-list h2 {\n@@ -259,2 +300,2 @@\n-    background-color:#dee3e9;\n-    border:1px solid #d0d9e0;\n+    background-color:var(--subnav-background-color);\n+    border:1px solid var(--border-color);\n@@ -274,1 +315,1 @@\n-    font-size:12px;\n+    font-size:0.856em;\n@@ -277,1 +318,1 @@\n-    color:#4E4E4E;\n+    color:var(--body-text-color);\n@@ -281,2 +322,2 @@\n-    font-size:14px;\n-    font-family:'DejaVu Serif', Georgia, \"Times New Roman\", Times, serif;\n+    font-size:1em;\n+    font-family:var(--block-font-family)\n@@ -349,3 +390,2 @@\n-    border-left:1px solid #EEE;\n-    border-right:1px solid #EEE;\n-    border-bottom:1px solid #EEE;\n+    border:1px solid var(--border-color);\n+    border-top:0;\n@@ -371,1 +411,1 @@\n-    color:#FFFFFF;\n+    color:var(--navbar-text-color);\n@@ -379,1 +419,1 @@\n-    background-color:#F8981D;\n+    background-color:var(--highlight-background-color);\n@@ -394,5 +434,5 @@\n-   border: none;\n-   cursor: pointer;\n-   padding: 5px 12px 7px 12px;\n-   font-weight: bold;\n-   margin-right: 8px;\n+    border: none;\n+    cursor: pointer;\n+    padding: 5px 12px 7px 12px;\n+    font-weight: bold;\n+    margin-right: 8px;\n@@ -401,2 +441,2 @@\n-   background: #F8981D;\n-   color: #253441;\n+    background: var(--highlight-background-color);\n+    color: var(--highlight-text-color);\n@@ -405,2 +445,2 @@\n-   background: #4D7A97;\n-   color: #FFFFFF;\n+    background: var(--navbar-background-color);\n+    color: var(--navbar-text-color);\n@@ -484,1 +524,1 @@\n-    background:#dee3e9;\n+    background:var(--subnav-background-color);\n@@ -517,1 +557,1 @@\n-    font-size:13px;\n+    font-size:0.93em;\n@@ -520,1 +560,1 @@\n-    font-size:13px;\n+    font-size:0.93em;\n@@ -538,1 +578,1 @@\n-    background-color:#FFFFFF;\n+    background-color:var(--even-row-color);\n@@ -541,1 +581,1 @@\n-    background-color:#EEEEEF;\n+    background-color:var(--odd-row-color);\n@@ -547,2 +587,2 @@\n-    font-size:14px;\n-    font-family:'DejaVu Serif', Georgia, \"Times New Roman\", Times, serif;\n+    font-size:var(--body-font-size);\n+    font-family:var(--block-font-family);\n@@ -560,2 +600,2 @@\n-    font-family:'DejaVu Sans Mono', monospace;\n-    font-size:14px;\n+    font-family:var(--code-font-family);\n+    font-size:1em;\n@@ -590,1 +630,1 @@\n-    color:#474747;\n+    color:var(--block-text-color);\n@@ -601,2 +641,2 @@\n-    font-size:14px;\n-    font-family:'DejaVu Serif', Georgia, \"Times New Roman\", Times, serif;\n+    font-size:1em;\n+    font-family:var(--block-font-family);\n@@ -612,2 +652,2 @@\n-    font-size:14px;\n-    font-family:'DejaVu Serif', Georgia, \"Times New Roman\", Times, serif;\n+    font-size:1em;\n+    font-family:var(--block-font-family);\n@@ -626,2 +666,2 @@\n-    font-size:14px;\n-    font-family:'DejaVu Serif', Georgia, \"Times New Roman\", Times, serif;\n+    font-size:1em;\n+    font-family:var(--block-font-family);\n@@ -646,0 +686,6 @@\n+.ui-state-active {\n+    \/* Overrides the color of selection used in jQuery UI *\/\n+    background: var(--highlight-background-color);\n+    border: 1px solid var(--highlight-background-color);\n+    color: var(--highlight-text-color);\n+}\n@@ -650,2 +696,2 @@\n-    background-color:#4D7A97;\n-    color:#FFFFFF;\n+    background-color:var(--navbar-background-color);\n+    color:var(--navbar-text-color);\n@@ -665,1 +711,1 @@\n-    background-color: #FFFFFF;\n+    background-color: var(--body-background-color);\n@@ -676,1 +722,1 @@\n-    background: #dee3e9;\n+    background: var(--subnav-background-color);\n@@ -679,1 +725,1 @@\n-    font-size: 13px;\n+    font-size: 0.93em;\n@@ -740,1 +786,1 @@\n-    font-size: 14px;\n+    font-size: 1em;\n@@ -751,1 +797,1 @@\n-    background-color: #f5f8ff;\n+    background-color: var(--subnav-background-color);\n@@ -753,1 +799,1 @@\n-    border: 0 solid #b9c8d3;\n+    border: 0 solid var(--border-color);\n@@ -760,2 +806,2 @@\n-    background: #4D7A97;\n-    color: #FFFFFF;\n+    background: var(--navbar-background-color);\n+    color: var(--navbar-text-color);\n@@ -767,2 +813,2 @@\n-    background-color:#4D7A97;\n-    color:#ffffff;\n+    background-color:var(--navbar-background-color);\n+    color:var(--navbar-text-color);\n@@ -795,3 +841,3 @@\n-    padding: 0px 20px 5px 10px;\n-    border: 1px solid #ededed;\n-    background-color: #f8f8f8;\n+    padding: 0 20px 5px 10px;\n+    border: 1px solid var(--border-color);\n+    background-color: var(--section-background-color);\n@@ -801,1 +847,1 @@\n-    background-color:#ffffff;\n+    background-color:var(--detail-background-color);\n@@ -868,1 +914,1 @@\n-    color: #303030;\n+    color: var(--body-text-color);\n@@ -872,1 +918,1 @@\n-    font-size: 85%;\n+    font-size: 0.76rem;\n@@ -879,1 +925,1 @@\n-    height: 1.35em;\n+    height: 1.16em;\n@@ -882,1 +928,1 @@\n-    height: 1em;\n+    height: 0.88em;\n@@ -901,1 +947,1 @@\n-    color: #000000;\n+    color: var(--body-text-color);\n@@ -913,1 +959,1 @@\n-    background-color: #dfe6f1;\n+    background-color: rgba(128, 128, 160, 0.2);\n@@ -916,1 +962,1 @@\n-    background-color: #cfdbee;\n+    background-color: rgba(128, 128, 160, 0.4);\n@@ -950,1 +996,1 @@\n-    background: #d3d3d3;\n+    background-color: rgba(128, 128, 160, 0.2);\n@@ -998,1 +1044,1 @@\n-    border: 1px solid black;\n+    border: 1px solid var(--table-border-color);\n@@ -1005,1 +1051,1 @@\n-    border: 1px solid black;\n+    border: 1px solid var(--table-border-color);\n@@ -1009,1 +1055,1 @@\n-    border: 1px solid black;\n+    border: 1px solid var(--table-border-color);\n@@ -1012,1 +1058,1 @@\n-    background-color: #E3E3E3;\n+    background-color: var(--subnav-background-color);\n@@ -1015,1 +1061,1 @@\n-    border: 1px solid black;\n+    border: 1px solid var(--table-border-color);\n@@ -1018,1 +1064,1 @@\n-    background-color: #EEE\n+    background-color: var(--odd-row-color)\n@@ -1021,1 +1067,1 @@\n-    background-color: #FFF\n+    background-color: var(--even-row-color)\n@@ -1024,2 +1070,2 @@\n-    border-left: 1px solid black;\n-    border-right: 1px solid black;\n+    border-left: 1px solid var(--table-border-color);\n+    border-right: 1px solid var(--table-border-color);\n@@ -1062,2 +1108,2 @@\n-        background-color: #dee3e9;\n-        color: #353833;\n+        background-color: var(--subnav-background-color);\n+        color: var(--body-text-color);\n@@ -1071,1 +1117,1 @@\n-        color:#4A6782;\n+        color:var(--link-color);\n@@ -1074,1 +1120,1 @@\n-        color:#bb7a2a;\n+        color:var(--link-color-active);\n@@ -1113,1 +1159,1 @@\n-        background-color: #ffffff;\n+        background-color: var(--navbar-text-color);\n@@ -1177,1 +1223,2 @@\n-    background-color: #ebecee;\n+    background-color: var(--snippet-background-color);\n+    color: var(--snippet-text-color);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/stylesheet.css","additions":158,"deletions":111,"binary":false,"changes":269,"status":"modified"},{"patch":"@@ -54,0 +54,6 @@\n+    \/**\n+     * The line separator for the current platform.\n+     * Use this when writing to external files.\n+     *\/\n+    public static final String PLATFORM_LINE_SEPARATOR = System.getProperty(\"line.separator\");\n+\n@@ -217,1 +223,1 @@\n-                                write(this, writer, DocletConstants.NL);\n+                                write(this, writer, PLATFORM_LINE_SEPARATOR);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/DocFile.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -97,3 +97,0 @@\n-    \/** The name of the stylesheet file overriding jQuery UI stylesheet. *\/\n-    public static final DocPath JQUERY_OVERRIDES_CSS = DocPath.create(\"jquery-ui.overrides.css\");\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/DocPaths.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,10 +34,0 @@\n-    \/**\n-     * The default amount of space between tab stops.\n-     *\/\n-    public static final int DEFAULT_TAB_STOP_LENGTH = 8;\n-\n-    \/**\n-     * The line separator for the current operating system.\n-     *\/\n-    public static final String NL = System.getProperty(\"line.separator\");\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/DocletConstants.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1238,26 +1238,0 @@\n-    public CharSequence normalizeNewlines(CharSequence text) {\n-        StringBuilder sb = new StringBuilder();\n-        final int textLength = text.length();\n-        final String NL = DocletConstants.NL;\n-        int pos = 0;\n-        for (int i = 0; i < textLength; i++) {\n-            char ch = text.charAt(i);\n-            switch (ch) {\n-                case '\\n' -> {\n-                    sb.append(text, pos, i);\n-                    sb.append(NL);\n-                    pos = i + 1;\n-                }\n-                case '\\r' -> {\n-                    sb.append(text, pos, i);\n-                    sb.append(NL);\n-                    if (i + 1 < textLength && text.charAt(i + 1) == '\\n')\n-                        i++;\n-                    pos = i + 1;\n-                }\n-            }\n-        }\n-        sb.append(text, pos, textLength);\n-        return sb;\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+dc.ref.in.missing.module = Modul f\\u00FCr Referenz nicht gefunden: {0}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/resources\/doclint_de.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+dc.ref.in.missing.module = \\u53C2\\u7167\\u7528\\u306E\\u30E2\\u30B8\\u30E5\\u30FC\\u30EB\\u304C\\u898B\\u3064\\u304B\\u308A\\u307E\\u305B\\u3093: {0}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/resources\/doclint_ja.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+dc.ref.in.missing.module = \\u627E\\u4E0D\\u5230\\u5F15\\u7528\\u7684\\u6A21\\u5757\\uFF1A{0}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/resources\/doclint_zh_CN.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -311,1 +311,1 @@\n-(http:\/\/bugreport.java.com) after checking the Bug Database (http:\/\/bugs.java.com)\\n\\\n+(https:\/\/bugreport.java.com) after checking the Bug Database (https:\/\/bugs.java.com)\\n\\\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/resources\/javadoc.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -196,1 +196,1 @@\n-doclet.internal.report.bug=Melden Sie auf der Java-Seite zum Melden von Bugs (http:\/\/bugreport.java.com) einen Bug\\nf\\u00FCr das javadoc-Tool, nachdem Sie in der Bugdatenbank (http:\/\/bugs.java.com) nach Duplikaten\\ngesucht haben. Nehmen Sie Fehlermeldungen und die folgende Diagnose in den Bericht auf. Vielen Dank.\n+doclet.internal.report.bug=Melden Sie auf der Java-Seite zum Melden von Bugs (https:\/\/bugreport.java.com) einen Bug\\nf\\u00FCr das javadoc-Tool, nachdem Sie in der Bugdatenbank (https:\/\/bugs.java.com) nach Duplikaten\\ngesucht haben. Nehmen Sie Fehlermeldungen und die folgende Diagnose in den Bericht auf. Vielen Dank.\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/resources\/javadoc_de.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -196,1 +196,1 @@\n-doclet.internal.report.bug=Bug Database (http:\/\/bugs.java.com)\\u3067\\u91CD\\u8907\\u304C\\u306A\\u3044\\u304B\\u3092\\u3054\\u78BA\\u8A8D\\u306E\\u3046\\u3048\\u3001Java bug\\u30EC\\u30DD\\u30FC\\u30C8\\u30FB\\u30DA\\u30FC\\u30B8\\n(http:\/\/bugreport.java.com)\\u3067javadoc\\u30C4\\u30FC\\u30EB\\u306B\\u5BFE\\u3059\\u308Bbug\\u306E\\u767B\\u9332\\u3092\\u304A\\u9858\\u3044\\u3044\\u305F\\u3057\\u307E\\u3059\\u3002\\n\\u30EC\\u30DD\\u30FC\\u30C8\\u306B\\u306F\\u3001\\u30A8\\u30E9\\u30FC\\u30FB\\u30E1\\u30C3\\u30BB\\u30FC\\u30B8\\u3068\\u6B21\\u306E\\u8A3A\\u65AD\\u5185\\u5BB9\\u3092\\u542B\\u3081\\u3066\\u304F\\u3060\\u3055\\u3044\\u3002\\u3054\\u5354\\u529B\\u3042\\u308A\\u304C\\u3068\\u3046\\u3054\\u3056\\u3044\\u307E\\u3059\\u3002\n+doclet.internal.report.bug=Bug Database (https:\/\/bugs.java.com)\\u3067\\u91CD\\u8907\\u304C\\u306A\\u3044\\u304B\\u3092\\u3054\\u78BA\\u8A8D\\u306E\\u3046\\u3048\\u3001Java bug\\u30EC\\u30DD\\u30FC\\u30C8\\u30FB\\u30DA\\u30FC\\u30B8\\n(https:\/\/bugreport.java.com)\\u3067javadoc\\u30C4\\u30FC\\u30EB\\u306B\\u5BFE\\u3059\\u308Bbug\\u306E\\u767B\\u9332\\u3092\\u304A\\u9858\\u3044\\u3044\\u305F\\u3057\\u307E\\u3059\\u3002\\n\\u30EC\\u30DD\\u30FC\\u30C8\\u306B\\u306F\\u3001\\u30A8\\u30E9\\u30FC\\u30FB\\u30E1\\u30C3\\u30BB\\u30FC\\u30B8\\u3068\\u6B21\\u306E\\u8A3A\\u65AD\\u5185\\u5BB9\\u3092\\u542B\\u3081\\u3066\\u304F\\u3060\\u3055\\u3044\\u3002\\u3054\\u5354\\u529B\\u3042\\u308A\\u304C\\u3068\\u3046\\u3054\\u3056\\u3044\\u307E\\u3059\\u3002\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/resources\/javadoc_ja.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -196,1 +196,1 @@\n-doclet.internal.report.bug=\\u5982\\u679C\\u5728 Bug Database (http:\/\/bugs.java.com) \\u4E2D\\u6CA1\\u6709\\u627E\\u5230\\u91CD\\u590D\\u9879, \\n\\u8BF7\\u901A\\u8FC7 Java Bug \\u62A5\\u544A\\u9875 (http:\/\/bugreport.java.com) \\u9488\\u5BF9\\u8BE5 \\njavadoc \\u5DE5\\u5177\\u5EFA\\u7ACB Bug\\u3002\\u8BF7\\u5728\\u62A5\\u544A\\u4E2D\\u9644\\u4E0A\\u9519\\u8BEF\\u6D88\\u606F\\u548C\\u4EE5\\u4E0B\\u8BCA\\u65AD\\u4FE1\\u606F\\u3002\\u8C22\\u8C22\\u3002\n+doclet.internal.report.bug=\\u5982\\u679C\\u5728 Bug Database (https:\/\/bugs.java.com) \\u4E2D\\u6CA1\\u6709\\u627E\\u5230\\u91CD\\u590D\\u9879, \\n\\u8BF7\\u901A\\u8FC7 Java Bug \\u62A5\\u544A\\u9875 (https:\/\/bugreport.java.com) \\u9488\\u5BF9\\u8BE5 \\njavadoc \\u5DE5\\u5177\\u5EFA\\u7ACB Bug\\u3002\\u8BF7\\u5728\\u62A5\\u544A\\u4E2D\\u9644\\u4E0A\\u9519\\u8BEF\\u6D88\\u606F\\u548C\\u4EE5\\u4E0B\\u8BCA\\u65AD\\u4FE1\\u606F\\u3002\\u8C22\\u8C22\\u3002\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/resources\/javadoc_zh_CN.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,0 +115,1 @@\n+err.invalid.filters=Nur eine der Optionen --package (-p), --regex (-e), --require darf angegeben werden\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/resources\/jdeps_de.properties","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,0 +115,1 @@\n+err.invalid.filters=--package (-p)\\u3001--regex (-e)\\u3001--require\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u306E\\u3044\\u305A\\u308C\\u304B1\\u3064\\u306E\\u307F\\u3092\\u6307\\u5B9A\\u3067\\u304D\\u307E\\u3059\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/resources\/jdeps_ja.properties","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,0 +115,1 @@\n+err.invalid.filters=\\u53EA\\u80FD\\u6307\\u5B9A --package (-p)\\u3001--regex (-e)\\u3001--require \\u9009\\u9879\\u4E2D\\u7684\\u4E00\\u4E2A\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/resources\/jdeps_zh_CN.properties","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -305,1 +305,0 @@\n-        {\"Threadgroup name not specified.\", \"Name der Threadgruppe nicht angegeben.\"},\n@@ -342,1 +341,1 @@\n-             \"** Befehlsliste **\\nconnectors                -- Listet verf\\u00FCgbare Connectors und Transporte in dieser VM auf\\n\\nrun [class [args]]        -- Startet die Ausf\\u00FChrung der Hauptklasse der Anwendung\\n\\nthreads [threadgroup]     -- Listet Threads auf\\nthread <Thread-ID>        -- Legt den Standardthread fest\\nsuspend [thread id(s)]    -- Unterbricht Threads (Standard: all)\\nresume [thread id(s)]    -- Nimmt Threads wieder auf (Standard: all)\\nwhere [<Thread-ID> | all] -- Gibt den Stack eines Threads aus\\nwherei [<Thread-ID> | all] -- Gibt den Stack eines Threads mit PC-Informationen aus\\nup [n frames]             -- Verschiebt den Stack eines Threads nach oben\\ndown [n frames]             -- Verschiebt den Stack eines Threads nach unten\\nkill <Thread-ID> <Ausdruck>   -- Bricht einen Thread mit dem angegebenen Ausnahmeobjekt ab\\ninterrupt <Thread-ID>     -- Unterbricht einen Thread\\n\\nprint <Ausdruck>              -- Gibt den Wert eines Ausdrucks aus\\ndump <Ausdruck>               -- Gibt alle Objektinformationen aus\\neval <Ausdruck>               -- Bewertet einen Ausdruck (wie \\\"print\\\")\\nset <lvalue> = <Ausdruck>     -- Weist einem Feld\/einer Variablen\/einem Arrayelement einen neuen Wert zu\\nlocals                    -- Gibt alle lokalen Variablen im aktuellen Stackframe aus\\n\\nclasses                   -- Listet derzeit bekannte Klassen auf\\nclass <Klassen-ID>          -- Zeigt Details einer benannten Klasse an\\nmethods <Klassen-ID>        -- Listet die Methoden einer Klasse auf\\nfields <Klassen-ID>        -- Listet die Felder einer Klasse auf\\n\\nthreadgroups              -- Listet Threadgruppen auf\\nthreadgroup <Name>        -- Legt die aktuelle Threadgruppe fest\\n\\nstop [go|thread] [<thread_id>] <at|in> <Position>\\n                          -- Legt einen Breakpoint fest\\n                          -- Wenn Sie keine Optionen angeben, wird die aktuelle Breakpoint-Liste ausgegeben\\n                          -- Wenn Sie \\\"go\\\" angeben, wird der Vorgang nach dem Stoppen sofort wiederaufgenommen\\n                          -- Wenn Sie \\\"thread\\\" angeben, wird nur der Thread unterbrochen, in dem gestoppt wurde\\n                          -- Wenn Sie weder \\\"go\\\" noch \\\"thread\\\" angeben, werden alle Threads unterbrochen\\n                          -- Wenn Sie eine ganzzahlige <thread_id> angeben, wird der Vorgang nur im angegebenen Thread gestoppt\\n                          -- \\\"at\\\" und \\\"in\\\" haben die gleiche Bedeutung\\n                          -- <Position> kann eine Zeilennummer oder eine Methode sein:\\n                          --   <class_id>:<line_number>\\n                          --   <class_id>.<Methode>[(argument_type,...)]\\nclear <class id>.<Methode>[(argument_type,...)]\\n                          -- L\\u00F6scht einen Breakpoint in einer Methode\\nclear <Klassen-ID>:<Zeile>   -- L\\u00F6scht einen Breakpoint bei einer Zeile\\nclear                     -- Listet Breakpoints auf\\ncatch [uncaught|caught|all] <Klassen-ID>|<Klassenmuster>\\n                          -- Break bei der angegebenen Ausnahme\\nignore [uncaught|caught|all] <Klassen-ID>|<Klassenmuster>\\n                          -- Bricht \\\"catch\\\" f\\u00FCr die angegebene Ausnahme ab\\nwatch [access|all] <Klassen-ID>.<Feldname>\\n                          -- \\u00DCberwacht Zugriffe\/\\u00C4nderungen eines Feldes\\nunwatch [access|all] <Klassen-ID>.<Feldname>\\n                          -- Hebt die \\u00DCberwachung der Zugriffe\/\\u00C4nderungen eines Feldes auf\\ntrace [go] methods [thread]\\n                          -- Verfolgt Methodenstarts und -beendigungen.\\n                          -- Alle Threads werden unterbrochen, es sei denn, \\\"go\\\" ist angegeben\\ntrace [go] method exit | exits [thread]\\n                          -- Verfolgt die Beendigung der aktuellen Methode oder die Beendigungen aller Methoden\\n                          -- Alle Threads werden unterbrochen, es sei denn, \\\"go\\\" ist angegeben\\nuntrace [methods]         -- Stoppt das Tracing von Methodenstarts und\/oder -beendigungen\\nstep                      -- F\\u00FChrt die aktuelle Zeile aus\\nstep up                   -- Ausf\\u00FChren, bis die aktuelle Methode an den Aufrufer zur\\u00FCckgegeben wird\\nstepi                     -- F\\u00FChrt die aktuelle Anweisung aus\\nnext                      -- Eine Zeile weiter (Aufrufe auslassen)\\ncont                      -- Setzt die Ausf\\u00FChrung ab dem Breakpoint fort\\n\\nlist [line number|method] -- Gibt den Quellcode aus\\nuse (or sourcepath) [source file path]\\n                          -- Zeigt den Quellpfad an oder \\u00E4ndert diesen\\nexclude [<Klassenmuster>, ... | \\\"none\\\"]\\n                          -- Meldet keine Schritt- oder Methodenereignisse f\\u00FCr angegebene Klassen\\nclasspath                 -- Gibt Classpath-Informationen aus der Ziel-VM aus\\n\\nmonitor <Befehl>         -- F\\u00FChrt bei jedem Programmstopp einen Befehl aus\\nmonitor                   -- Listet Monitore auf\\nunmonitor <Monitornummer>      -- L\\u00F6scht einen Monitor\\nread <Dateiname>           -- Liest eine Befehlsdatei und f\\u00FChrt diese aus\\n\\nlock <Ausdruck>               -- Gibt Sperrinformationen f\\u00FCr ein Objekt aus\\nthreadlocks [thread id]   -- Gibt Sperrinformationen f\\u00FCr einen Thread aus\\n\\npop                       -- Holt den Stack bis zum aktuellen Frame (einschlie\\u00DFlich)\\nreenter                   -- Wie \\\"pop\\\", aber der aktuelle Frame wird wieder eingegeben\\nredefine <Klassen-ID> <Klassendateiname>\\n                          -- Definiert den Code f\\u00FCr eine Klasse neu\\n\\ndisablegc <Ausdruck>          -- Verhindert die Garbage Collection eines Objekts\\nenablegc <Ausdruck>          -- L\\u00E4sst die Garbage Collection eines Objekts zu\\n\\n!!                        -- Wiederholt den letzten Befehl\\n<n> <Befehl>             -- Wiederholt einen Befehl n-mal\\nrepeat                    -- Zeigt an, ob die Wiederholung durch leeren Befehl im GDB-Stil aktiviert ist\\nrepeat <on|off>           -- Aktiviert\/deaktiviert die Wiederholung im GDB-Stil\\n# <Befehl>               -- Verwerfen (kein Vorgang)\\nhelp (oder ?)               -- Listet Befehle auf\\ndbgtrace [flag]           -- Identisch mit der Befehlszeilenoption \\\"dbgtrace\\\"\\nversion                   -- Gibt Versionsinformationen aus\\nexit (oder quit)            -- Beendet den Debugger\\n\\n<Klassen-ID>: Ein vollst\\u00E4ndiger Klassenname mit Package-Qualifiers\\n<Klassenmuster>: Ein Klassenname mit einem Platzhalter am Anfang oder Ende (\\\"*\\\")\\n<Thread-ID>: Threadnummer aus dem Befehl \\\"threads\\\"\\n<Ausdruck>: Ein Ausdruck der Java(TM)-Programmiersprache.\\nDer Gro\\u00DFteil der g\\u00E4ngigen Syntax wird unterst\\u00FCtzt.\\n\\nStartbefehle k\\u00F6nnen in \\\"jdb.ini\\\" oder \\\".jdbrc\\\" abgelegt werden\\nin user.home oder user.dir\"},\n+             \"** Befehlsliste **\\nconnectors                -- Listet verf\\u00FCgbare Connectors und Transporte in dieser VM auf\\n\\nrun [class [args]]        -- Startet die Ausf\\u00FChrung der Hauptklasse der Anwendung\\n\\nthreads [threadgroup]     -- Listet Threads in der Threadgruppe auf. Verwendet die aktuelle Threadgruppe, wenn Sie keine Gruppe angeben.\\nthread <Thread-ID>        -- Legt den Standardthread fest\\nsuspend [thread id(s)]    -- Unterbricht Threads (Standard: all)\\nresume [thread id(s)]    -- Nimmt Threads wieder auf (Standard: all)\\nwhere [<Thread-ID> | all] -- Gibt den Stack eines Threads aus\\nwherei [<Thread-ID> | all] -- Gibt den Stack eines Threads mit PC-Informationen aus\\nup [n frames]             -- Verschiebt den Stack eines Threads nach oben\\ndown [n frames]             -- Verschiebt den Stack eines Threads nach unten\\nkill <Thread-ID> <Ausdruck>   -- Bricht einen Thread mit dem angegebenen Ausnahmeobjekt ab\\ninterrupt <Thread-ID>     -- Unterbricht einen Thread\\n\\nprint <Ausdruck>              -- Gibt den Wert eines Ausdrucks aus\\ndump <Ausdruck>               -- Gibt alle Objektinformationen aus\\neval <Ausdruck>               -- Bewertet einen Ausdruck (wie \\\"print\\\")\\nset <lvalue> = <Ausdruck>     -- Weist einem Feld\/einer Variablen\/einem Arrayelement einen neuen Wert zu\\nlocals                    -- Gibt alle lokalen Variablen im aktuellen Stackframe aus\\n\\nclasses                   -- Listet derzeit bekannte Klassen auf\\nclass <Klassen-ID>          -- Zeigt Details einer benannten Klasse an\\nmethods <Klassen-ID>        -- Listet die Methoden einer Klasse auf\\nfields <Klassen-ID>        -- Listet die Felder einer Klasse auf\\n\\nthreadgroups              -- Listet Threadgruppen auf\\nthreadgroup <name>        -- Setzt die aktuelle Threadgruppe auf <name>\\nthreadgroup               -- Setzt die aktuelle Threadgruppe wieder auf die Threadgruppe der obersten Ebene zur\\u00FCck\\n\\nstop [go|thread] [<thread_id>] <at|in> <Position>\\n                          -- Legt einen Breakpoint fest\\n                          -- Wenn Sie keine Optionen angeben, wird die aktuelle Breakpoint-Liste ausgegeben\\n                          -- Wenn Sie \\\"go\\\" angeben, wird der Vorgang nach dem Stoppen sofort wiederaufgenommen\\n                          -- Wenn Sie \\\"thread\\\" angeben, wird nur der Thread unterbrochen, in dem gestoppt wurde\\n                          -- Wenn Sie weder \\\"go\\\" noch \\\"thread\\\" angeben, werden alle Threads unterbrochen\\n                          -- Wenn Sie eine ganzzahlige <thread_id> angeben, wird der Vorgang nur im angegebenen Thread gestoppt\\n                          -- \\\"at\\\" und \\\"in\\\" haben die gleiche Bedeutung\\n                          -- <Position> kann eine Zeilennummer oder eine Methode sein:\\n                          --   <class_id>:<line_number>\\n                          --   <class_id>.<Methode>[(argument_type,...)]\\nclear <class id>.<Methode>[(argument_type,...)]\\n                          -- L\\u00F6scht einen Breakpoint in einer Methode\\nclear <Klassen-ID>:<Zeile>   -- L\\u00F6scht einen Breakpoint bei einer Zeile\\nclear                     -- Listet Breakpoints auf\\ncatch [uncaught|caught|all] <Klassen-ID>|<Klassenmuster>\\n                          -- Break bei der angegebenen Ausnahme\\nignore [uncaught|caught|all] <Klassen-ID>|<Klassenmuster>\\n                          -- Bricht \\\"catch\\\" f\\u00FCr die angegebene Ausnahme ab\\nwatch [access|all] <Klassen-ID>.<Feldname>\\n                          -- \\u00DCberwacht Zugriffe\/\\u00C4nderungen eines Feldes\\nunwatch [access|all] <Klassen-ID>.<Feldname>\\n                          -- Hebt die \\u00DCberwachung der Zugriffe\/\\u00C4nderungen eines Feldes auf\\ntrace [go] methods [thread]\\n                          -- Verfolgt Methodenstarts und -beendigungen.\\n                          -- Alle Threads werden unterbrochen, es sei denn, \\\"go\\\" ist angegeben\\ntrace [go] method exit | exits [thread]\\n                          -- Verfolgt die Beendigung der aktuellen Methode oder die Beendigungen aller Methoden\\n                          -- Alle Threads werden unterbrochen, es sei denn, \\\"go\\\" ist angegeben\\nuntrace [methods]         -- Stoppt das Tracing von Methodenstarts und\/oder -beendigungen\\nstep                      -- F\\u00FChrt die aktuelle Zeile aus\\nstep up                   -- Ausf\\u00FChren, bis die aktuelle Methode an den Aufrufer zur\\u00FCckgegeben wird\\nstepi                     -- F\\u00FChrt die aktuelle Anweisung aus\\nnext                      -- Eine Zeile weiter (Aufrufe auslassen)\\ncont                      -- Setzt die Ausf\\u00FChrung ab dem Breakpoint fort\\n\\nlist [line number|method] -- Gibt den Quellcode aus\\nuse (or sourcepath) [source file path]\\n                          -- Zeigt den Quellpfad an oder \\u00E4ndert diesen\\nexclude [<Klassenmuster>, ... | \\\"none\\\"]\\n                          -- Meldet keine Schritt- oder Methodenereignisse f\\u00FCr angegebene Klassen\\nclasspath                 -- Gibt Classpath-Informationen aus der Ziel-VM aus\\n\\nmonitor <Befehl>         -- F\\u00FChrt bei jedem Programmstopp einen Befehl aus\\nmonitor                   -- Listet Monitore auf\\nunmonitor <Monitornummer>      -- L\\u00F6scht einen Monitor\\nread <Dateiname>           -- Liest eine Befehlsdatei und f\\u00FChrt diese aus\\n\\nlock <Ausdruck>               -- Gibt Sperrinformationen f\\u00FCr ein Objekt aus\\nthreadlocks [thread id]   -- Gibt Sperrinformationen f\\u00FCr einen Thread aus\\n\\npop                       -- Holt den Stack bis zum aktuellen Frame (einschlie\\u00DFlich)\\nreenter                   -- Wie \\\"pop\\\", aber der aktuelle Frame wird wieder eingegeben\\nredefine <Klassen-ID> <Klassendateiname>\\n                          -- Definiert den Code f\\u00FCr eine Klasse neu\\n\\ndisablegc <Ausdruck>          -- Verhindert die Garbage Collection eines Objekts\\nenablegc <Ausdruck>          -- L\\u00E4sst die Garbage Collection eines Objekts zu\\n\\n!!                        -- Wiederholt den letzten Befehl\\n<n> <Befehl>             -- Wiederholt einen Befehl n-mal\\nrepeat                    -- Zeigt an, ob die Wiederholung durch leeren Befehl im GDB-Stil aktiviert ist\\nrepeat <on|off>           -- Aktiviert\/deaktiviert die Wiederholung im GDB-Stil\\n# <Befehl>               -- Verwerfen (kein Vorgang)\\nhelp (oder ?)               -- Listet Befehle auf\\ndbgtrace [flag]           -- Identisch mit der Befehlszeilenoption \\\"dbgtrace\\\"\\nversion                   -- Gibt Versionsinformationen aus\\nexit (oder quit)            -- Beendet den Debugger\\n\\n<Klassen-ID>: Ein vollst\\u00E4ndiger Klassenname mit Package-Qualifiers\\n<Klassenmuster>: Ein Klassenname mit einem Platzhalter am Anfang oder Ende (\\\"*\\\")\\n<Thread-ID>: Threadnummer aus dem Befehl \\\"threads\\\"\\n<Ausdruck>: Ein Ausdruck der Java(TM)-Programmiersprache.\\nDer Gro\\u00DFteil der g\\u00E4ngigen Syntax wird unterst\\u00FCtzt.\\n\\nStartbefehle k\\u00F6nnen in \\\"jdb.ini\\\" oder \\\".jdbrc\\\" abgelegt werden\\nin user.home oder user.dir\"},\n@@ -344,1 +343,1 @@\n-             \"Verwendung: {0} <Optionen> <Klasse> <Argumente>\\n\\nVerf\\u00FCgbare Optionen:\\n    -? -h --help -help Gibt diese Hilfemeldung aus und beendet den Vorgang\\n    -sourcepath <durch \\\"{1}\\\" getrennte Verzeichnisse>\\n                      Verzeichnisse, in denen nach Quelldateien gesucht werden soll\\n    -attach <Adresse>\\n                      Anh\\u00E4ngen an aktive VM unter der angegebenen Adresse mit Standard-Connector\\n    -listen <Adresse>\\n                      Wartet auf Verbindung der aktiven VM unter der angegebenen Adresse mit Standard-Connector\\n    -listenany\\n                      Wartet auf Verbindung einer aktiven VM unter einer beliebigen verf\\u00FCgbaren Adresse mit Standard-Connector\\n    -launch\\n                      Startet die VM sofort, anstatt auf den Befehl \\\"run\\\" zu warten\\n    -listconnectors   Listet die in dieser VM verf\\u00FCgbaren Connectors auf\\n    -connect <connector-name>:<name1>=<value1>,...\\n                      Stellt die Verbindung zur Ziel-VM mit dem benannten Connector und den aufgelisteten Argumentwerten her\\n    -dbgtrace [flags] Gibt Informationen zum Debugging von {0} aus\\n    -tclient          F\\u00FChrt die Anwendung im HotSpot(TM) Client Compiler aus\\n    -tserver          F\\u00FChrt die Anwendung im HotSpot(TM) Server Compiler aus\\n\\nAn Debuggerprozess weitergeleitete Optionen:\\n    -v -verbose[:class|gc|jni]\\n                      Aktiviert den Verbose-Modus\\n    -D<Name>=<Wert>  Legt eine Systemeigenschaft fest\\n    -classpath <durch \\\"{1}\\\" getrennte Verzeichnisse>\\n                      Listet Verzeichnisse auf, in denen nach Klassen gesucht werden soll\\n    -X<Option>        Nicht standardm\\u00E4\\u00DFige Ziel-VM-Option\\n\\n<Klasse> ist der Name der Klasse zum Start des Debuggings\\n<Argumente> sind die Argumente, die an die main()-Methode der <Klasse> \\u00FCbergeben werden\\n\\nGeben Sie \\\"help\\\" beim {0}-Prompt ein, um Befehlshilfe anzuzeigen\"},\n+             \"Verwendung: {0} <Optionen> <Klasse> <Argumente>\\n\\nVerf\\u00FCgbare Optionen:\\n    -? -h --help -help Gibt diese Hilfemeldung aus und beendet den Vorgang\\n    -sourcepath <durch \\\"{1}\\\" getrennte Verzeichnisse>\\n                      Verzeichnisse, in denen nach Quelldateien gesucht werden soll\\n    -attach <Adresse>\\n                      Anh\\u00E4ngen an aktive VM unter der angegebenen Adresse mit Standard-Connector\\n    -listen <Adresse>\\n                      Wartet auf Verbindung der aktiven VM unter der angegebenen Adresse mit Standard-Connector\\n    -listenany\\n                      Wartet auf Verbindung einer aktiven VM unter einer beliebigen verf\\u00FCgbaren Adresse mit Standard-Connector\\n    -launch\\n                      Startet die VM sofort, anstatt auf den Befehl \\\"run\\\" zu warten\\n    -listconnectors   Listet die in dieser VM verf\\u00FCgbaren Connectors auf\\n    -connect <connector-name>:<name1>=<value1>,...\\n                      Stellt die Verbindung zur Ziel-VM mit dem benannten Connector und den aufgelisteten Argumentwerten her\\n    -dbgtrace [flags] Gibt Informationen zum Debugging von {0} aus\\n    -tclient          F\\u00FChrt die Anwendung im HotSpot(TM) Client Compiler aus\\n    -tserver          F\\u00FChrt die Anwendung im HotSpot(TM) Server Compiler aus\\n     -R<Option>        Leitet <Option> an den zu debuggenden Prozess weiter, wenn von JDB gestartet. Wird andernfalls ignoriert.\\n\\nOptionen, die an den zu debuggenden Prozess weitergeleitet werden, wenn von JDB gestartet (K\\u00FCrzel anstelle von -R):\\n    -v -verbose[:class|gc|jni]\\n                      Aktiviert den Verbose-Modus\\n    -D<Name>=<Wert>  Legt eine Systemeigenschaft fest\\n    -classpath <durch \\\"{1}\\\" getrennte Verzeichnisse>\\n                      Listet Verzeichnisse auf, in denen nach Klassen gesucht werden soll\\n    -X<Option>        Nicht standardm\\u00E4\\u00DFige Ziel-VM-Option\\n\\n<Klasse> ist der Name der Klasse zum Start des Debuggings\\n<Argumente> sind die Argumente, die an die main()-Methode der <Klasse> \\u00FCbergeben werden\\n\\nGeben Sie \\\"help\\\" beim {0}-Prompt ein, um Befehlshilfe anzuzeigen\"},\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/TTYResources_de.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -305,1 +305,0 @@\n-        {\"Threadgroup name not specified.\", \"\\u30B9\\u30EC\\u30C3\\u30C9\\u30B0\\u30EB\\u30FC\\u30D7\\u540D\\u304C\\u6307\\u5B9A\\u3055\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093\\u3002\"},\n@@ -342,1 +341,1 @@\n-             \"** \\u30B3\\u30DE\\u30F3\\u30C9\\u30FB\\u30EA\\u30B9\\u30C8 **\\nconnectors                -- \\u3053\\u306EVM\\u5185\\u306E\\u4F7F\\u7528\\u53EF\\u80FD\\u306A\\u30B3\\u30CD\\u30AF\\u30BF\\u3068\\u30C8\\u30E9\\u30F3\\u30B9\\u30DD\\u30FC\\u30C8\\u3092\\u30EA\\u30B9\\u30C8\\u3057\\u307E\\u3059\\n\\nrun [class [args]]        -- \\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u306E\\u30E1\\u30A4\\u30F3\\u30FB\\u30AF\\u30E9\\u30B9\\u306E\\u5B9F\\u884C\\u3092\\u958B\\u59CB\\u3057\\u307E\\u3059\\n\\nthreads [threadgroup]     -- \\u30B9\\u30EC\\u30C3\\u30C9\\u3092\\u30EA\\u30B9\\u30C8\\u3057\\u307E\\u3059\\nthread <thread id>        -- \\u30C7\\u30D5\\u30A9\\u30EB\\u30C8\\u306E\\u30B9\\u30EC\\u30C3\\u30C9\\u3092\\u8A2D\\u5B9A\\u3057\\u307E\\u3059\\nsuspend [thread id(s)]    -- \\u30B9\\u30EC\\u30C3\\u30C9\\u3092\\u4E2D\\u65AD\\u3057\\u307E\\u3059(\\u30C7\\u30D5\\u30A9\\u30EB\\u30C8: \\u3059\\u3079\\u3066)\\nresume [thread id(s)]     -- \\u30B9\\u30EC\\u30C3\\u30C9\\u3092\\u518D\\u958B\\u3057\\u307E\\u3059(\\u30C7\\u30D5\\u30A9\\u30EB\\u30C8: \\u3059\\u3079\\u3066)\\nwhere [<thread id> | all] -- \\u30B9\\u30EC\\u30C3\\u30C9\\u306E\\u30B9\\u30BF\\u30C3\\u30AF\\u3092\\u30C0\\u30F3\\u30D7\\u3057\\u307E\\u3059\\nwherei [<thread id> | all]-- \\u30B9\\u30EC\\u30C3\\u30C9\\u306E\\u30B9\\u30BF\\u30C3\\u30AF\\u3092pc\\u60C5\\u5831\\u3068\\u3068\\u3082\\u306B\\u30C0\\u30F3\\u30D7\\u3057\\u307E\\u3059\\nup [n frames]             -- \\u30B9\\u30EC\\u30C3\\u30C9\\u306E\\u30B9\\u30BF\\u30C3\\u30AF\\u3092\\u4E0A\\u306B\\u79FB\\u52D5\\u3057\\u307E\\u3059\\ndown [n frames]           -- \\u30B9\\u30EC\\u30C3\\u30C9\\u306E\\u30B9\\u30BF\\u30C3\\u30AF\\u3092\\u4E0B\\u306B\\u79FB\\u52D5\\u3057\\u307E\\u3059\\nkill <thread id> <expr>   -- \\u6307\\u5B9A\\u3055\\u308C\\u305F\\u4F8B\\u5916\\u30AA\\u30D6\\u30B8\\u30A7\\u30AF\\u30C8\\u3067\\u30B9\\u30EC\\u30C3\\u30C9\\u3092\\u5F37\\u5236\\u7D42\\u4E86\\u3057\\u307E\\u3059\\ninterrupt <thread id>     -- \\u30B9\\u30EC\\u30C3\\u30C9\\u3092\\u4E2D\\u65AD\\u3057\\u307E\\u3059\\n\\nprint <expr>              -- \\u5F0F\\u306E\\u5024\\u3092\\u51FA\\u529B\\u3057\\u307E\\u3059\\ndump <expr>               -- \\u3059\\u3079\\u3066\\u306E\\u30AA\\u30D6\\u30B8\\u30A7\\u30AF\\u30C8\\u60C5\\u5831\\u3092\\u51FA\\u529B\\u3057\\u307E\\u3059\\neval <expr>               -- \\u5F0F\\u3092\\u8A55\\u4FA1\\u3057\\u307E\\u3059(print\\u3068\\u540C\\u3058)\\nset <lvalue> = <expr>     -- \\u65B0\\u3057\\u3044\\u5024\\u3092\\u30D5\\u30A3\\u30FC\\u30EB\\u30C9\/\\u5909\\u6570\/\\u914D\\u5217\\u8981\\u7D20\\u306B\\u4EE3\\u5165\\u3057\\u307E\\u3059\\nlocals                    -- \\u73FE\\u5728\\u306E\\u30B9\\u30BF\\u30C3\\u30AF\\u30FB\\u30D5\\u30EC\\u30FC\\u30E0\\u5185\\u306E\\u3059\\u3079\\u3066\\u306E\\u30ED\\u30FC\\u30AB\\u30EB\\u5909\\u6570\\u3092\\u51FA\\u529B\\u3057\\u307E\\u3059\\n\\nclasses                   -- \\u73FE\\u5728\\u65E2\\u77E5\\u306E\\u30AF\\u30E9\\u30B9\\u3092\\u30EA\\u30B9\\u30C8\\u3057\\u307E\\u3059\\nclass <class id>          -- \\u6307\\u5B9A\\u3057\\u305F\\u30AF\\u30E9\\u30B9\\u306E\\u8A73\\u7D30\\u3092\\u8868\\u793A\\u3057\\u307E\\u3059\\nmethods <class id>        -- \\u30AF\\u30E9\\u30B9\\u306E\\u30E1\\u30BD\\u30C3\\u30C9\\u3092\\u30EA\\u30B9\\u30C8\\u3057\\u307E\\u3059\\nfields <class id>         -- \\u30AF\\u30E9\\u30B9\\u306E\\u30D5\\u30A3\\u30FC\\u30EB\\u30C9\\u3092\\u30EA\\u30B9\\u30C8\\u3057\\u307E\\u3059\\n\\nthreadgroups              -- \\u30B9\\u30EC\\u30C3\\u30C9\\u30B0\\u30EB\\u30FC\\u30D7\\u3092\\u30EA\\u30B9\\u30C8\\u3057\\u307E\\u3059\\nthreadgroup <name>        -- \\u73FE\\u5728\\u306E\\u30B9\\u30EC\\u30C3\\u30C9\\u30B0\\u30EB\\u30FC\\u30D7\\u3092\\u8A2D\\u5B9A\\u3057\\u307E\\u3059\\n\\nstop [go|thread] [<thread_id>] <at|in> <location>\\n                          -- \\u30D6\\u30EC\\u30FC\\u30AF\\u30DD\\u30A4\\u30F3\\u30C8\\u3092\\u8A2D\\u5B9A\\u3057\\u307E\\u3059\\n                          -- \\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u304C\\u6307\\u5B9A\\u3055\\u308C\\u3066\\u3044\\u306A\\u3044\\u5834\\u5408\\u306F\\u3001\\u30D6\\u30EC\\u30FC\\u30AF\\u30DD\\u30A4\\u30F3\\u30C8\\u306E\\u73FE\\u5728\\u306E\\u30EA\\u30B9\\u30C8\\u304C\\u51FA\\u529B\\u3055\\u308C\\u307E\\u3059\\n                          -- \\\"go\\\"\\u304C\\u6307\\u5B9A\\u3055\\u308C\\u3066\\u3044\\u308B\\u5834\\u5408\\u306F\\u3001\\u505C\\u6B62\\u5F8C\\u3059\\u3050\\u306B\\u518D\\u958B\\u3057\\u307E\\u3059\\n                          -- \\\"thread\\\"\\u304C\\u6307\\u5B9A\\u3055\\u308C\\u3066\\u3044\\u308B\\u5834\\u5408\\u306F\\u3001\\u505C\\u6B62\\u3057\\u305F\\u30B9\\u30EC\\u30C3\\u30C9\\u306E\\u307F\\u4E2D\\u65AD\\u3057\\u307E\\u3059\\n                          -- \\\"go\\\"\\u3082\\\"thread\\\"\\u3082\\u6307\\u5B9A\\u3055\\u308C\\u3066\\u3044\\u306A\\u3044\\u5834\\u5408\\u306F\\u3001\\u3059\\u3079\\u3066\\u306E\\u30B9\\u30EC\\u30C3\\u30C9\\u3092\\u4E2D\\u65AD\\u3057\\u307E\\u3059\\n                          -- \\u6574\\u6570\\u306E<thread_id>\\u304C\\u6307\\u5B9A\\u3055\\u308C\\u3066\\u3044\\u308B\\u5834\\u5408\\u306F\\u3001\\u6307\\u5B9A\\u3055\\u308C\\u305F\\u30B9\\u30EC\\u30C3\\u30C9\\u3067\\u306E\\u307F\\u505C\\u6B62\\u3057\\u307E\\u3059\\n                          -- \\\"at\\\"\\u3068\\\"in\\\"\\u306F\\u540C\\u3058\\u610F\\u5473\\u3092\\u6301\\u3061\\u307E\\u3059\\n                          -- <location>\\u306F\\u884C\\u756A\\u53F7\\u307E\\u305F\\u306F\\u30E1\\u30BD\\u30C3\\u30C9\\u306B\\u3059\\u308B\\u3053\\u3068\\u304C\\u3067\\u304D\\u307E\\u3059:\\n                          --   <class_id>:<line_number>\\n                          --   <class_id>.<method>[(argument_type,...)]\\nclear <class id>.<method>[(argument_type,...)]\\n                          -- \\u30E1\\u30BD\\u30C3\\u30C9\\u5185\\u306E\\u30D6\\u30EC\\u30FC\\u30AF\\u30DD\\u30A4\\u30F3\\u30C8\\u3092\\u30AF\\u30EA\\u30A2\\u3057\\u307E\\u3059\\nclear <class id>:<line>   -- \\u884C\\u306E\\u30D6\\u30EC\\u30FC\\u30AF\\u30DD\\u30A4\\u30F3\\u30C8\\u3092\\u30AF\\u30EA\\u30A2\\u3057\\u307E\\u3059\\nclear                     -- \\u30D6\\u30EC\\u30FC\\u30AF\\u30DD\\u30A4\\u30F3\\u30C8\\u3092\\u30EA\\u30B9\\u30C8\\u3057\\u307E\\u3059\\ncatch [uncaught|caught|all] <class id>|<class pattern>\\n                          -- \\u6307\\u5B9A\\u3055\\u308C\\u305F\\u4F8B\\u5916\\u304C\\u767A\\u751F\\u3057\\u305F\\u3068\\u304D\\u306B\\u30D6\\u30EC\\u30FC\\u30AF\\u3057\\u307E\\u3059\\nignore [uncaught|caught|all] <class id>|<class pattern>\\n                          -- \\u6307\\u5B9A\\u3055\\u308C\\u305F\\u4F8B\\u5916\\u306E'catch'\\u3092\\u53D6\\u308A\\u6D88\\u3057\\u307E\\u3059\\nwatch [access|all] <class id>.<field name>\\n                          -- \\u30D5\\u30A3\\u30FC\\u30EB\\u30C9\\u3078\\u306E\\u30A2\\u30AF\\u30BB\\u30B9\\u307E\\u305F\\u306F\\u5909\\u66F4\\u3092\\u30A6\\u30A9\\u30C3\\u30C1\\u3057\\u307E\\u3059\\nunwatch [access|all] <class id>.<field name>\\n                          -- \\u30D5\\u30A3\\u30FC\\u30EB\\u30C9\\u3078\\u306E\\u30A2\\u30AF\\u30BB\\u30B9\\u307E\\u305F\\u306F\\u5909\\u66F4\\u306E\\u30A6\\u30A9\\u30C3\\u30C1\\u3092\\u4E2D\\u6B62\\u3057\\u307E\\u3059\\ntrace [go] methods [thread]\\n                          -- \\u30E1\\u30BD\\u30C3\\u30C9\\u306E\\u5165\\u308A\\u53E3\\u3068\\u51FA\\u53E3\\u3092\\u30C8\\u30EC\\u30FC\\u30B9\\u3057\\u307E\\u3059\\u3002\\n                          -- 'go'\\u304C\\u6307\\u5B9A\\u3055\\u308C\\u308B\\u307E\\u3067\\u3059\\u3079\\u3066\\u306E\\u30B9\\u30EC\\u30C3\\u30C9\\u306F\\u4E2D\\u65AD\\u3057\\u307E\\u3059\\ntrace [go] method exit | exits [thread]\\n                          -- \\u73FE\\u5728\\u306E\\u30E1\\u30BD\\u30C3\\u30C9\\u306E\\u51FA\\u53E3\\u307E\\u305F\\u306F\\u3059\\u3079\\u3066\\u306E\\u30E1\\u30BD\\u30C3\\u30C9\\u306E\\u51FA\\u53E3\\u3092\\u30C8\\u30EC\\u30FC\\u30B9\\u3057\\u307E\\u3059\\n                          -- 'go'\\u304C\\u6307\\u5B9A\\u3055\\u308C\\u308B\\u307E\\u3067\\u3059\\u3079\\u3066\\u306E\\u30B9\\u30EC\\u30C3\\u30C9\\u306F\\u4E2D\\u65AD\\u3057\\u307E\\u3059\\nuntrace [methods]         -- \\u30E1\\u30BD\\u30C3\\u30C9\\u306E\\u958B\\u59CB\\u307E\\u305F\\u306F\\u7D42\\u4E86\\u306E\\u30C8\\u30EC\\u30FC\\u30B9\\u3092\\u505C\\u6B62\\u3057\\u307E\\u3059\\nstep                      -- \\u73FE\\u5728\\u306E\\u884C\\u3092\\u5B9F\\u884C\\u3057\\u307E\\u3059\\nstep up                   -- \\u73FE\\u5728\\u306E\\u30E1\\u30BD\\u30C3\\u30C9\\u304C\\u30E1\\u30BD\\u30C3\\u30C9\\u306E\\u547C\\u51FA\\u3057\\u5143\\u306B\\u623B\\u308B\\u307E\\u3067\\u5B9F\\u884C\\u3057\\u307E\\u3059\\nstepi                     -- \\u73FE\\u5728\\u306E\\u547D\\u4EE4\\u3092\\u5B9F\\u884C\\u3057\\u307E\\u3059\\nnext                      -- 1\\u884C\\u3092\\u30B9\\u30C6\\u30C3\\u30D7\\u5B9F\\u884C\\u3057\\u307E\\u3059(\\u547C\\u51FA\\u3057\\u3092\\u30B9\\u30C6\\u30C3\\u30D7\\u30AA\\u30FC\\u30D0\\u30FC)\\ncont                      -- \\u30D6\\u30EC\\u30FC\\u30AF\\u30DD\\u30A4\\u30F3\\u30C8\\u304B\\u3089\\u5B9F\\u884C\\u3092\\u7D9A\\u884C\\u3057\\u307E\\u3059\\n\\nlist [line number|method] -- \\u30BD\\u30FC\\u30B9\\u30FB\\u30B3\\u30FC\\u30C9\\u3092\\u51FA\\u529B\\u3057\\u307E\\u3059\\nuse (or sourcepath) [source file path]\\n                          -- \\u30BD\\u30FC\\u30B9\\u30FB\\u30D1\\u30B9\\u3092\\u8868\\u793A\\u307E\\u305F\\u306F\\u5909\\u66F4\\u3057\\u307E\\u3059\\nexclude [<class pattern>, ... | \\\"none\\\"]\\n                          -- \\u6307\\u5B9A\\u3057\\u305F\\u30AF\\u30E9\\u30B9\\u306E\\u30B9\\u30C6\\u30C3\\u30D7\\u3084\\u30E1\\u30BD\\u30C3\\u30C9\\u30FB\\u30A4\\u30D9\\u30F3\\u30C8\\u3092\\u5831\\u544A\\u3057\\u307E\\u305B\\u3093\\nclasspath                 -- \\u30BF\\u30FC\\u30B2\\u30C3\\u30C8VM\\u304B\\u3089\\u30AF\\u30E9\\u30B9\\u30D1\\u30B9\\u60C5\\u5831\\u3092\\u51FA\\u529B\\u3057\\u307E\\u3059\\n\\nmonitor <command>         -- \\u30D7\\u30ED\\u30B0\\u30E9\\u30E0\\u304C\\u505C\\u6B62\\u3059\\u308B\\u305F\\u3073\\u306B\\u30B3\\u30DE\\u30F3\\u30C9\\u3092\\u5B9F\\u884C\\u3057\\u307E\\u3059\\nmonitor                   -- \\u30E2\\u30CB\\u30BF\\u30FC\\u3092\\u30EA\\u30B9\\u30C8\\u3057\\u307E\\u3059\\nunmonitor <monitor#>      -- \\u30E2\\u30CB\\u30BF\\u30FC\\u3092\\u524A\\u9664\\u3057\\u307E\\u3059\\nread <filename>           -- \\u30B3\\u30DE\\u30F3\\u30C9\\u30FB\\u30D5\\u30A1\\u30A4\\u30EB\\u3092\\u8AAD\\u307F\\u53D6\\u3063\\u3066\\u5B9F\\u884C\\u3057\\u307E\\u3059\\n\\nlock <expr>               -- \\u30AA\\u30D6\\u30B8\\u30A7\\u30AF\\u30C8\\u306E\\u30ED\\u30C3\\u30AF\\u60C5\\u5831\\u3092\\u51FA\\u529B\\u3057\\u307E\\u3059\\nthreadlocks [thread id]   -- \\u30B9\\u30EC\\u30C3\\u30C9\\u306E\\u30ED\\u30C3\\u30AF\\u60C5\\u5831\\u3092\\u51FA\\u529B\\u3057\\u307E\\u3059\\n\\npop                       -- \\u73FE\\u5728\\u306E\\u30D5\\u30EC\\u30FC\\u30E0\\u307E\\u3067\\u306E\\u3059\\u3079\\u3066\\u306E\\u30B9\\u30BF\\u30C3\\u30AF\\u3092\\u30DD\\u30C3\\u30D7\\u3057\\u307E\\u3059\\nreenter                   -- pop\\u3068\\u540C\\u3058\\u3067\\u3059\\u304C\\u3001\\u73FE\\u5728\\u306E\\u30D5\\u30EC\\u30FC\\u30E0\\u304C\\u518D\\u5165\\u529B\\u3055\\u308C\\u307E\\u3059\\nredefine <class id> <class file name>\\n                          -- \\u30AF\\u30E9\\u30B9\\u306E\\u30B3\\u30FC\\u30C9\\u3092\\u518D\\u5B9A\\u7FA9\\u3057\\u307E\\u3059\\n\\ndisablegc <expr>          -- \\u30AA\\u30D6\\u30B8\\u30A7\\u30AF\\u30C8\\u306E\\u30AC\\u30D9\\u30FC\\u30B8\\u30FB\\u30B3\\u30EC\\u30AF\\u30B7\\u30E7\\u30F3\\u3092\\u6291\\u5236\\u3057\\u307E\\u3059\\nenablegc <expr>           -- \\u30AA\\u30D6\\u30B8\\u30A7\\u30AF\\u30C8\\u306E\\u30AC\\u30D9\\u30FC\\u30B8\\u30FB\\u30B3\\u30EC\\u30AF\\u30B7\\u30E7\\u30F3\\u3092\\u8A31\\u53EF\\u3057\\u307E\\u3059\\n\\n!!                        -- \\u6700\\u5F8C\\u306E\\u30B3\\u30DE\\u30F3\\u30C9\\u3092\\u7E70\\u308A\\u8FD4\\u3057\\u307E\\u3059\\n<n> <command>             -- \\u30B3\\u30DE\\u30F3\\u30C9\\u3092n\\u56DE\\u7E70\\u308A\\u8FD4\\u3057\\u307E\\u3059\\nrepeat                    -- GDB\\u5F62\\u5F0F\\u306E\\u7A7A\\u306E\\u30B3\\u30DE\\u30F3\\u30C9\\u306E\\u7E70\\u8FD4\\u3057\\u304C\\u6709\\u52B9\\u306B\\u306A\\u3063\\u3066\\u3044\\u308B\\u304B\\u3069\\u3046\\u304B\\u3092\\u793A\\u3057\\u307E\\u3059\\nrepeat <on|off>           -- GDB\\u5F62\\u5F0F\\u306E\\u7E70\\u8FD4\\u3057\\u3092\\u6709\\u52B9\/\\u7121\\u52B9\\u306B\\u3057\\u307E\\u3059\\n# <command>               -- \\u7834\\u68C4\\u3057\\u307E\\u3059(\\u64CD\\u4F5C\\u306A\\u3057)\\nhelp (\\u307E\\u305F\\u306F?)               -- \\u30B3\\u30DE\\u30F3\\u30C9\\u3092\\u30EA\\u30B9\\u30C8\\u3057\\u307E\\u3059\\ndbgtrace [flag]           -- dbgtrace\\u30B3\\u30DE\\u30F3\\u30C9\\u30FB\\u30E9\\u30A4\\u30F3\\u30FB\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u3068\\u540C\\u3058\\u3067\\u3059\\nversion                   -- \\u30D0\\u30FC\\u30B8\\u30E7\\u30F3\\u60C5\\u5831\\u3092\\u51FA\\u529B\\u3057\\u307E\\u3059\\nexit (\\u307E\\u305F\\u306Fquit)            -- \\u30C7\\u30D0\\u30C3\\u30AC\\u3092\\u7D42\\u4E86\\u3057\\u307E\\u3059\\n\\n<class id>: \\u30D1\\u30C3\\u30B1\\u30FC\\u30B8\\u4FEE\\u98FE\\u5B50\\u3092\\u542B\\u3080\\u5B8C\\u5168\\u30AF\\u30E9\\u30B9\\u540D\\n<class pattern>: \\u5148\\u982D\\u307E\\u305F\\u306F\\u672B\\u5C3E\\u306E\\u30EF\\u30A4\\u30EB\\u30C9\\u30AB\\u30FC\\u30C9('*')\\u3092\\u542B\\u3080\\u30AF\\u30E9\\u30B9\\u540D\\n<thread id>: 'threads'\\u30B3\\u30DE\\u30F3\\u30C9\\u3067\\u5831\\u544A\\u3055\\u308C\\u308B\\u30B9\\u30EC\\u30C3\\u30C9\\u756A\\u53F7\\n<expr>: Java(TM)\\u30D7\\u30ED\\u30B0\\u30E9\\u30DF\\u30F3\\u30B0\\u8A00\\u8A9E\\u306E\\u5F0F\\u3002\\n\\u307B\\u3068\\u3093\\u3069\\u306E\\u4E00\\u822C\\u7684\\u306A\\u69CB\\u6587\\u304C\\u30B5\\u30DD\\u30FC\\u30C8\\u3055\\u308C\\u3066\\u3044\\u307E\\u3059\\u3002\\n\\n\\u8D77\\u52D5\\u30B3\\u30DE\\u30F3\\u30C9\\u306F\\u3001\\\"jdb.ini\\\"\\u307E\\u305F\\u306F\\\".jdbrc\\\"\\u306B\\u914D\\u7F6E\\u3067\\u304D\\u307E\\u3059\\n(user.home\\u307E\\u305F\\u306Fuser.dir\\u5185)\"},\n+             \"** \\u30B3\\u30DE\\u30F3\\u30C9\\u30FB\\u30EA\\u30B9\\u30C8 **\\nconnectors                -- \\u3053\\u306EVM\\u5185\\u306E\\u4F7F\\u7528\\u53EF\\u80FD\\u306A\\u30B3\\u30CD\\u30AF\\u30BF\\u3068\\u30C8\\u30E9\\u30F3\\u30B9\\u30DD\\u30FC\\u30C8\\u3092\\u30EA\\u30B9\\u30C8\\u3057\\u307E\\u3059\\n\\nrun [class [args]]        -- \\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u306E\\u30E1\\u30A4\\u30F3\\u30FB\\u30AF\\u30E9\\u30B9\\u306E\\u5B9F\\u884C\\u3092\\u958B\\u59CB\\u3057\\u307E\\u3059\\n\\nthreads [threadgroup]     -- \\u30B9\\u30EC\\u30C3\\u30C9\\u30B0\\u30EB\\u30FC\\u30D7\\u5185\\u306E\\u30B9\\u30EC\\u30C3\\u30C9\\u3092\\u30EA\\u30B9\\u30C8\\u3057\\u307E\\u3059\\u3002\\u6307\\u5B9A\\u304C\\u306A\\u3044\\u5834\\u5408\\u306F\\u3001\\u73FE\\u5728\\u306E\\u30B9\\u30EC\\u30C3\\u30C9\\u30B0\\u30EB\\u30FC\\u30D7\\u3092\\u4F7F\\u7528\\u3057\\u307E\\u3059\\u3002\\nthread <thread id>        -- \\u30C7\\u30D5\\u30A9\\u30EB\\u30C8\\u306E\\u30B9\\u30EC\\u30C3\\u30C9\\u3092\\u8A2D\\u5B9A\\u3057\\u307E\\u3059\\nsuspend [thread id(s)]    -- \\u30B9\\u30EC\\u30C3\\u30C9\\u3092\\u4E2D\\u65AD\\u3057\\u307E\\u3059(\\u30C7\\u30D5\\u30A9\\u30EB\\u30C8: \\u3059\\u3079\\u3066)\\nresume [thread id(s)]     -- \\u30B9\\u30EC\\u30C3\\u30C9\\u3092\\u518D\\u958B\\u3057\\u307E\\u3059(\\u30C7\\u30D5\\u30A9\\u30EB\\u30C8: \\u3059\\u3079\\u3066)\\nwhere [<thread id> | all] -- \\u30B9\\u30EC\\u30C3\\u30C9\\u306E\\u30B9\\u30BF\\u30C3\\u30AF\\u3092\\u30C0\\u30F3\\u30D7\\u3057\\u307E\\u3059\\nwherei [<thread id> | all]-- \\u30B9\\u30EC\\u30C3\\u30C9\\u306E\\u30B9\\u30BF\\u30C3\\u30AF\\u3092pc\\u60C5\\u5831\\u3068\\u3068\\u3082\\u306B\\u30C0\\u30F3\\u30D7\\u3057\\u307E\\u3059\\nup [n frames]             -- \\u30B9\\u30EC\\u30C3\\u30C9\\u306E\\u30B9\\u30BF\\u30C3\\u30AF\\u3092\\u4E0A\\u306B\\u79FB\\u52D5\\u3057\\u307E\\u3059\\ndown [n frames]           -- \\u30B9\\u30EC\\u30C3\\u30C9\\u306E\\u30B9\\u30BF\\u30C3\\u30AF\\u3092\\u4E0B\\u306B\\u79FB\\u52D5\\u3057\\u307E\\u3059\\nkill <thread id> <expr>   -- \\u6307\\u5B9A\\u3055\\u308C\\u305F\\u4F8B\\u5916\\u30AA\\u30D6\\u30B8\\u30A7\\u30AF\\u30C8\\u3067\\u30B9\\u30EC\\u30C3\\u30C9\\u3092\\u5F37\\u5236\\u7D42\\u4E86\\u3057\\u307E\\u3059\\ninterrupt <thread id>     -- \\u30B9\\u30EC\\u30C3\\u30C9\\u3092\\u4E2D\\u65AD\\u3057\\u307E\\u3059\\n\\nprint <expr>              -- \\u5F0F\\u306E\\u5024\\u3092\\u51FA\\u529B\\u3057\\u307E\\u3059\\ndump <expr>               -- \\u3059\\u3079\\u3066\\u306E\\u30AA\\u30D6\\u30B8\\u30A7\\u30AF\\u30C8\\u60C5\\u5831\\u3092\\u51FA\\u529B\\u3057\\u307E\\u3059\\neval <expr>               -- \\u5F0F\\u3092\\u8A55\\u4FA1\\u3057\\u307E\\u3059(print\\u3068\\u540C\\u3058)\\nset <lvalue> = <expr>     -- \\u65B0\\u3057\\u3044\\u5024\\u3092\\u30D5\\u30A3\\u30FC\\u30EB\\u30C9\/\\u5909\\u6570\/\\u914D\\u5217\\u8981\\u7D20\\u306B\\u4EE3\\u5165\\u3057\\u307E\\u3059\\nlocals                    -- \\u73FE\\u5728\\u306E\\u30B9\\u30BF\\u30C3\\u30AF\\u30FB\\u30D5\\u30EC\\u30FC\\u30E0\\u5185\\u306E\\u3059\\u3079\\u3066\\u306E\\u30ED\\u30FC\\u30AB\\u30EB\\u5909\\u6570\\u3092\\u51FA\\u529B\\u3057\\u307E\\u3059\\n\\nclasses                   -- \\u73FE\\u5728\\u65E2\\u77E5\\u306E\\u30AF\\u30E9\\u30B9\\u3092\\u30EA\\u30B9\\u30C8\\u3057\\u307E\\u3059\\nclass <class id>          -- \\u6307\\u5B9A\\u3057\\u305F\\u30AF\\u30E9\\u30B9\\u306E\\u8A73\\u7D30\\u3092\\u8868\\u793A\\u3057\\u307E\\u3059\\nmethods <class id>        -- \\u30AF\\u30E9\\u30B9\\u306E\\u30E1\\u30BD\\u30C3\\u30C9\\u3092\\u30EA\\u30B9\\u30C8\\u3057\\u307E\\u3059\\nfields <class id>         -- \\u30AF\\u30E9\\u30B9\\u306E\\u30D5\\u30A3\\u30FC\\u30EB\\u30C9\\u3092\\u30EA\\u30B9\\u30C8\\u3057\\u307E\\u3059\\n\\nthreadgroups              -- \\u30B9\\u30EC\\u30C3\\u30C9\\u30B0\\u30EB\\u30FC\\u30D7\\u3092\\u30EA\\u30B9\\u30C8\\u3057\\u307E\\u3059\\nthreadgroup <name>        -- \\u73FE\\u5728\\u306E\\u30B9\\u30EC\\u30C3\\u30C9\\u30B0\\u30EB\\u30FC\\u30D7\\u3092<name>\\u306B\\u8A2D\\u5B9A\\u3057\\u307E\\u3059\\nthreadgroup               -- \\u73FE\\u5728\\u306E\\u30B9\\u30EC\\u30C3\\u30C9\\u30B0\\u30EB\\u30FC\\u30D7\\u3092\\u6700\\u4E0A\\u4F4D\\u30EC\\u30D9\\u30EB\\u306E\\u30B9\\u30EC\\u30C3\\u30C9\\u30B0\\u30EB\\u30FC\\u30D7\\u306B\\u8A2D\\u5B9A\\u3057\\u307E\\u3059\\n\\nstop [go|thread] [<thread_id>] <at|in> <location>\\n                          -- \\u30D6\\u30EC\\u30FC\\u30AF\\u30DD\\u30A4\\u30F3\\u30C8\\u3092\\u8A2D\\u5B9A\\u3057\\u307E\\u3059\\n                          -- \\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u304C\\u6307\\u5B9A\\u3055\\u308C\\u3066\\u3044\\u306A\\u3044\\u5834\\u5408\\u306F\\u3001\\u30D6\\u30EC\\u30FC\\u30AF\\u30DD\\u30A4\\u30F3\\u30C8\\u306E\\u73FE\\u5728\\u306E\\u30EA\\u30B9\\u30C8\\u304C\\u51FA\\u529B\\u3055\\u308C\\u307E\\u3059\\n                          -- \\\"go\\\"\\u304C\\u6307\\u5B9A\\u3055\\u308C\\u3066\\u3044\\u308B\\u5834\\u5408\\u306F\\u3001\\u505C\\u6B62\\u5F8C\\u3059\\u3050\\u306B\\u518D\\u958B\\u3057\\u307E\\u3059\\n                          -- \\\"thread\\\"\\u304C\\u6307\\u5B9A\\u3055\\u308C\\u3066\\u3044\\u308B\\u5834\\u5408\\u306F\\u3001\\u505C\\u6B62\\u3057\\u305F\\u30B9\\u30EC\\u30C3\\u30C9\\u306E\\u307F\\u4E2D\\u65AD\\u3057\\u307E\\u3059\\n                          -- \\\"go\\\"\\u3082\\\"thread\\\"\\u3082\\u6307\\u5B9A\\u3055\\u308C\\u3066\\u3044\\u306A\\u3044\\u5834\\u5408\\u306F\\u3001\\u3059\\u3079\\u3066\\u306E\\u30B9\\u30EC\\u30C3\\u30C9\\u3092\\u4E2D\\u65AD\\u3057\\u307E\\u3059\\n                          -- \\u6574\\u6570\\u306E<thread_id>\\u304C\\u6307\\u5B9A\\u3055\\u308C\\u3066\\u3044\\u308B\\u5834\\u5408\\u306F\\u3001\\u6307\\u5B9A\\u3055\\u308C\\u305F\\u30B9\\u30EC\\u30C3\\u30C9\\u3067\\u306E\\u307F\\u505C\\u6B62\\u3057\\u307E\\u3059\\n                          -- \\\"at\\\"\\u3068\\\"in\\\"\\u306F\\u540C\\u3058\\u610F\\u5473\\u3092\\u6301\\u3061\\u307E\\u3059\\n                          -- <location>\\u306F\\u884C\\u756A\\u53F7\\u307E\\u305F\\u306F\\u30E1\\u30BD\\u30C3\\u30C9\\u306B\\u3059\\u308B\\u3053\\u3068\\u304C\\u3067\\u304D\\u307E\\u3059:\\n                          --   <class_id>:<line_number>\\n                          --   <class_id>.<method>[(argument_type,...)]\\nclear <class id>.<method>[(argument_type,...)]\\n                          -- \\u30E1\\u30BD\\u30C3\\u30C9\\u5185\\u306E\\u30D6\\u30EC\\u30FC\\u30AF\\u30DD\\u30A4\\u30F3\\u30C8\\u3092\\u30AF\\u30EA\\u30A2\\u3057\\u307E\\u3059\\nclear <class id>:<line>   -- \\u884C\\u306E\\u30D6\\u30EC\\u30FC\\u30AF\\u30DD\\u30A4\\u30F3\\u30C8\\u3092\\u30AF\\u30EA\\u30A2\\u3057\\u307E\\u3059\\nclear                     -- \\u30D6\\u30EC\\u30FC\\u30AF\\u30DD\\u30A4\\u30F3\\u30C8\\u3092\\u30EA\\u30B9\\u30C8\\u3057\\u307E\\u3059\\ncatch [uncaught|caught|all] <class id>|<class pattern>\\n                          -- \\u6307\\u5B9A\\u3055\\u308C\\u305F\\u4F8B\\u5916\\u304C\\u767A\\u751F\\u3057\\u305F\\u3068\\u304D\\u306B\\u30D6\\u30EC\\u30FC\\u30AF\\u3057\\u307E\\u3059\\nignore [uncaught|caught|all] <class id>|<class pattern>\\n                          -- \\u6307\\u5B9A\\u3055\\u308C\\u305F\\u4F8B\\u5916\\u306E'catch'\\u3092\\u53D6\\u308A\\u6D88\\u3057\\u307E\\u3059\\nwatch [access|all] <class id>.<field name>\\n                          -- \\u30D5\\u30A3\\u30FC\\u30EB\\u30C9\\u3078\\u306E\\u30A2\\u30AF\\u30BB\\u30B9\\u307E\\u305F\\u306F\\u5909\\u66F4\\u3092\\u30A6\\u30A9\\u30C3\\u30C1\\u3057\\u307E\\u3059\\nunwatch [access|all] <class id>.<field name>\\n                          -- \\u30D5\\u30A3\\u30FC\\u30EB\\u30C9\\u3078\\u306E\\u30A2\\u30AF\\u30BB\\u30B9\\u307E\\u305F\\u306F\\u5909\\u66F4\\u306E\\u30A6\\u30A9\\u30C3\\u30C1\\u3092\\u4E2D\\u6B62\\u3057\\u307E\\u3059\\ntrace [go] methods [thread]\\n                          -- \\u30E1\\u30BD\\u30C3\\u30C9\\u306E\\u5165\\u308A\\u53E3\\u3068\\u51FA\\u53E3\\u3092\\u30C8\\u30EC\\u30FC\\u30B9\\u3057\\u307E\\u3059\\u3002\\n                          -- 'go'\\u304C\\u6307\\u5B9A\\u3055\\u308C\\u308B\\u307E\\u3067\\u3059\\u3079\\u3066\\u306E\\u30B9\\u30EC\\u30C3\\u30C9\\u306F\\u4E2D\\u65AD\\u3057\\u307E\\u3059\\ntrace [go] method exit | exits [thread]\\n                          -- \\u73FE\\u5728\\u306E\\u30E1\\u30BD\\u30C3\\u30C9\\u306E\\u51FA\\u53E3\\u307E\\u305F\\u306F\\u3059\\u3079\\u3066\\u306E\\u30E1\\u30BD\\u30C3\\u30C9\\u306E\\u51FA\\u53E3\\u3092\\u30C8\\u30EC\\u30FC\\u30B9\\u3057\\u307E\\u3059\\n                          -- 'go'\\u304C\\u6307\\u5B9A\\u3055\\u308C\\u308B\\u307E\\u3067\\u3059\\u3079\\u3066\\u306E\\u30B9\\u30EC\\u30C3\\u30C9\\u306F\\u4E2D\\u65AD\\u3057\\u307E\\u3059\\nuntrace [methods]         -- \\u30E1\\u30BD\\u30C3\\u30C9\\u306E\\u958B\\u59CB\\u307E\\u305F\\u306F\\u7D42\\u4E86\\u306E\\u30C8\\u30EC\\u30FC\\u30B9\\u3092\\u505C\\u6B62\\u3057\\u307E\\u3059\\nstep                      -- \\u73FE\\u5728\\u306E\\u884C\\u3092\\u5B9F\\u884C\\u3057\\u307E\\u3059\\nstep up                   -- \\u73FE\\u5728\\u306E\\u30E1\\u30BD\\u30C3\\u30C9\\u304C\\u30E1\\u30BD\\u30C3\\u30C9\\u306E\\u547C\\u51FA\\u3057\\u5143\\u306B\\u623B\\u308B\\u307E\\u3067\\u5B9F\\u884C\\u3057\\u307E\\u3059\\nstepi                     -- \\u73FE\\u5728\\u306E\\u547D\\u4EE4\\u3092\\u5B9F\\u884C\\u3057\\u307E\\u3059\\nnext                      -- 1\\u884C\\u3092\\u30B9\\u30C6\\u30C3\\u30D7\\u5B9F\\u884C\\u3057\\u307E\\u3059(\\u547C\\u51FA\\u3057\\u3092\\u30B9\\u30C6\\u30C3\\u30D7\\u30AA\\u30FC\\u30D0\\u30FC)\\ncont                      -- \\u30D6\\u30EC\\u30FC\\u30AF\\u30DD\\u30A4\\u30F3\\u30C8\\u304B\\u3089\\u5B9F\\u884C\\u3092\\u7D9A\\u884C\\u3057\\u307E\\u3059\\n\\nlist [line number|method] -- \\u30BD\\u30FC\\u30B9\\u30FB\\u30B3\\u30FC\\u30C9\\u3092\\u51FA\\u529B\\u3057\\u307E\\u3059\\nuse (or sourcepath) [source file path]\\n                          -- \\u30BD\\u30FC\\u30B9\\u30FB\\u30D1\\u30B9\\u3092\\u8868\\u793A\\u307E\\u305F\\u306F\\u5909\\u66F4\\u3057\\u307E\\u3059\\nexclude [<class pattern>, ... | \\\"none\\\"]\\n                          -- \\u6307\\u5B9A\\u3057\\u305F\\u30AF\\u30E9\\u30B9\\u306E\\u30B9\\u30C6\\u30C3\\u30D7\\u3084\\u30E1\\u30BD\\u30C3\\u30C9\\u30FB\\u30A4\\u30D9\\u30F3\\u30C8\\u3092\\u5831\\u544A\\u3057\\u307E\\u305B\\u3093\\nclasspath                 -- \\u30BF\\u30FC\\u30B2\\u30C3\\u30C8VM\\u304B\\u3089\\u30AF\\u30E9\\u30B9\\u30D1\\u30B9\\u60C5\\u5831\\u3092\\u51FA\\u529B\\u3057\\u307E\\u3059\\n\\nmonitor <command>         -- \\u30D7\\u30ED\\u30B0\\u30E9\\u30E0\\u304C\\u505C\\u6B62\\u3059\\u308B\\u305F\\u3073\\u306B\\u30B3\\u30DE\\u30F3\\u30C9\\u3092\\u5B9F\\u884C\\u3057\\u307E\\u3059\\nmonitor                   -- \\u30E2\\u30CB\\u30BF\\u30FC\\u3092\\u30EA\\u30B9\\u30C8\\u3057\\u307E\\u3059\\nunmonitor <monitor#>      -- \\u30E2\\u30CB\\u30BF\\u30FC\\u3092\\u524A\\u9664\\u3057\\u307E\\u3059\\nread <filename>           -- \\u30B3\\u30DE\\u30F3\\u30C9\\u30FB\\u30D5\\u30A1\\u30A4\\u30EB\\u3092\\u8AAD\\u307F\\u53D6\\u3063\\u3066\\u5B9F\\u884C\\u3057\\u307E\\u3059\\n\\nlock <expr>               -- \\u30AA\\u30D6\\u30B8\\u30A7\\u30AF\\u30C8\\u306E\\u30ED\\u30C3\\u30AF\\u60C5\\u5831\\u3092\\u51FA\\u529B\\u3057\\u307E\\u3059\\nthreadlocks [thread id]   -- \\u30B9\\u30EC\\u30C3\\u30C9\\u306E\\u30ED\\u30C3\\u30AF\\u60C5\\u5831\\u3092\\u51FA\\u529B\\u3057\\u307E\\u3059\\n\\npop                       -- \\u73FE\\u5728\\u306E\\u30D5\\u30EC\\u30FC\\u30E0\\u307E\\u3067\\u306E\\u3059\\u3079\\u3066\\u306E\\u30B9\\u30BF\\u30C3\\u30AF\\u3092\\u30DD\\u30C3\\u30D7\\u3057\\u307E\\u3059\\nreenter                   -- pop\\u3068\\u540C\\u3058\\u3067\\u3059\\u304C\\u3001\\u73FE\\u5728\\u306E\\u30D5\\u30EC\\u30FC\\u30E0\\u304C\\u518D\\u5165\\u529B\\u3055\\u308C\\u307E\\u3059\\nredefine <class id> <class file name>\\n                          -- \\u30AF\\u30E9\\u30B9\\u306E\\u30B3\\u30FC\\u30C9\\u3092\\u518D\\u5B9A\\u7FA9\\u3057\\u307E\\u3059\\n\\ndisablegc <expr>          -- \\u30AA\\u30D6\\u30B8\\u30A7\\u30AF\\u30C8\\u306E\\u30AC\\u30D9\\u30FC\\u30B8\\u30FB\\u30B3\\u30EC\\u30AF\\u30B7\\u30E7\\u30F3\\u3092\\u6291\\u5236\\u3057\\u307E\\u3059\\nenablegc <expr>           -- \\u30AA\\u30D6\\u30B8\\u30A7\\u30AF\\u30C8\\u306E\\u30AC\\u30D9\\u30FC\\u30B8\\u30FB\\u30B3\\u30EC\\u30AF\\u30B7\\u30E7\\u30F3\\u3092\\u8A31\\u53EF\\u3057\\u307E\\u3059\\n\\n!!                        -- \\u6700\\u5F8C\\u306E\\u30B3\\u30DE\\u30F3\\u30C9\\u3092\\u7E70\\u308A\\u8FD4\\u3057\\u307E\\u3059\\n<n> <command>             -- \\u30B3\\u30DE\\u30F3\\u30C9\\u3092n\\u56DE\\u7E70\\u308A\\u8FD4\\u3057\\u307E\\u3059\\nrepeat                    -- GDB\\u5F62\\u5F0F\\u306E\\u7A7A\\u306E\\u30B3\\u30DE\\u30F3\\u30C9\\u306E\\u7E70\\u8FD4\\u3057\\u304C\\u6709\\u52B9\\u306B\\u306A\\u3063\\u3066\\u3044\\u308B\\u304B\\u3069\\u3046\\u304B\\u3092\\u793A\\u3057\\u307E\\u3059\\nrepeat <on|off>           -- GDB\\u5F62\\u5F0F\\u306E\\u7E70\\u8FD4\\u3057\\u3092\\u6709\\u52B9\/\\u7121\\u52B9\\u306B\\u3057\\u307E\\u3059\\n# <command>               -- \\u7834\\u68C4\\u3057\\u307E\\u3059(\\u64CD\\u4F5C\\u306A\\u3057)\\nhelp (\\u307E\\u305F\\u306F?)               -- \\u30B3\\u30DE\\u30F3\\u30C9\\u3092\\u30EA\\u30B9\\u30C8\\u3057\\u307E\\u3059\\ndbgtrace [flag]           -- dbgtrace\\u30B3\\u30DE\\u30F3\\u30C9\\u30FB\\u30E9\\u30A4\\u30F3\\u30FB\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u3068\\u540C\\u3058\\u3067\\u3059\\nversion                   -- \\u30D0\\u30FC\\u30B8\\u30E7\\u30F3\\u60C5\\u5831\\u3092\\u51FA\\u529B\\u3057\\u307E\\u3059\\nexit (\\u307E\\u305F\\u306Fquit)            -- \\u30C7\\u30D0\\u30C3\\u30AC\\u3092\\u7D42\\u4E86\\u3057\\u307E\\u3059\\n\\n<class id>: \\u30D1\\u30C3\\u30B1\\u30FC\\u30B8\\u4FEE\\u98FE\\u5B50\\u3092\\u542B\\u3080\\u5B8C\\u5168\\u30AF\\u30E9\\u30B9\\u540D\\n<class pattern>: \\u5148\\u982D\\u307E\\u305F\\u306F\\u672B\\u5C3E\\u306E\\u30EF\\u30A4\\u30EB\\u30C9\\u30AB\\u30FC\\u30C9('*')\\u3092\\u542B\\u3080\\u30AF\\u30E9\\u30B9\\u540D\\n<thread id>: 'threads'\\u30B3\\u30DE\\u30F3\\u30C9\\u3067\\u5831\\u544A\\u3055\\u308C\\u308B\\u30B9\\u30EC\\u30C3\\u30C9\\u756A\\u53F7\\n<expr>: Java(TM)\\u30D7\\u30ED\\u30B0\\u30E9\\u30DF\\u30F3\\u30B0\\u8A00\\u8A9E\\u306E\\u5F0F\\u3002\\n\\u307B\\u3068\\u3093\\u3069\\u306E\\u4E00\\u822C\\u7684\\u306A\\u69CB\\u6587\\u304C\\u30B5\\u30DD\\u30FC\\u30C8\\u3055\\u308C\\u3066\\u3044\\u307E\\u3059\\u3002\\n\\n\\u8D77\\u52D5\\u30B3\\u30DE\\u30F3\\u30C9\\u306F\\u3001\\\"jdb.ini\\\"\\u307E\\u305F\\u306F\\\".jdbrc\\\"\\u306B\\u914D\\u7F6E\\u3067\\u304D\\u307E\\u3059\\n(user.home\\u307E\\u305F\\u306Fuser.dir\\u5185)\"},\n@@ -344,1 +343,1 @@\n-             \"\\u4F7F\\u7528\\u65B9\\u6CD5: {0} <options> <class> <arguments>\\n\\n\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u306F\\u6B21\\u306E\\u3068\\u304A\\u308A\\u3067\\u3059:\\n    -? -h --help -help \\u3053\\u306E\\u30D8\\u30EB\\u30D7\\u30FB\\u30E1\\u30C3\\u30BB\\u30FC\\u30B8\\u3092\\u51FA\\u529B\\u3057\\u3066\\u7D42\\u4E86\\u3059\\u308B\\n    -sourcepath <directories separated by \\\"{1}\\\">\\n                      \\u30BD\\u30FC\\u30B9\\u30FB\\u30D5\\u30A1\\u30A4\\u30EB\\u3092\\u691C\\u7D22\\u3059\\u308B\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA\\n    -attach <address>\\n                      \\u6A19\\u6E96\\u30B3\\u30CD\\u30AF\\u30BF\\u3092\\u4F7F\\u7528\\u3057\\u3066\\u3001\\u6307\\u5B9A\\u3055\\u308C\\u305F\\u30A2\\u30C9\\u30EC\\u30B9\\u3067\\u5B9F\\u884C\\u4E2D\\u306EVM\\u306B\\u63A5\\u7D9A\\u3059\\u308B\\n    -listen <address>\\n                      \\u6A19\\u6E96\\u30B3\\u30CD\\u30AF\\u30BF\\u3092\\u4F7F\\u7528\\u3057\\u3066\\u3001\\u6307\\u5B9A\\u3055\\u308C\\u305F\\u30A2\\u30C9\\u30EC\\u30B9\\u3067\\u5B9F\\u884C\\u4E2D\\u306EVM\\u306E\\u63A5\\u7D9A\\u3092\\u5F85\\u6A5F\\u3059\\u308B\\n    -listenany\\n                      \\u6A19\\u6E96\\u30B3\\u30CD\\u30AF\\u30BF\\u3092\\u4F7F\\u7528\\u3057\\u3066\\u3001\\u4F7F\\u7528\\u53EF\\u80FD\\u306A\\u4EFB\\u610F\\u306E\\u30A2\\u30C9\\u30EC\\u30B9\\u3067\\u5B9F\\u884C\\u4E2D\\u306EVM\\u306E\\u63A5\\u7D9A\\u3092\\u5F85\\u6A5F\\u3059\\u308B\\n    -launch\\n                      ''run''\\u30B3\\u30DE\\u30F3\\u30C9\\u3092\\u5F85\\u6A5F\\u305B\\u305A\\u306BVM\\u3092\\u5373\\u6642\\u306B\\u8D77\\u52D5\\u3059\\u308B\\n    -listconnectors   \\u3053\\u306EVM\\u3067\\u4F7F\\u7528\\u53EF\\u80FD\\u306A\\u30B3\\u30CD\\u30AF\\u30BF\\u3092\\u30EA\\u30B9\\u30C8\\u3059\\u308B\\n    -connect <connector-name>:<name1>=<value1>,...\\n                      \\u6307\\u5B9A\\u3055\\u308C\\u305F\\u30B3\\u30CD\\u30AF\\u30BF\\u3092\\u4F7F\\u7528\\u3057\\u3066\\u3001\\u30EA\\u30B9\\u30C8\\u3055\\u308C\\u305F\\u5F15\\u6570\\u5024\\u3067\\u30BF\\u30FC\\u30B2\\u30C3\\u30C8VM\\u306B\\u63A5\\u7D9A\\u3059\\u308B\\n    -dbgtrace [flags] {0}\\u306E\\u30C7\\u30D0\\u30C3\\u30B0\\u306E\\u60C5\\u5831\\u3092\\u51FA\\u529B\\u3059\\u308B\\n    -tclient          \\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u3092HotSpot(TM) Client Compiler\\u3067\\u5B9F\\u884C\\u3059\\u308B\\n    -tserver          \\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u3092HotSpot(TM) Server Compiler\\u3067\\u5B9F\\u884C\\u3059\\u308B\\n\\n\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u306F\\u30C7\\u30D0\\u30C3\\u30B0\\u3059\\u308B\\u30D7\\u30ED\\u30BB\\u30B9\\u306B\\u8EE2\\u9001\\u3055\\u308C\\u307E\\u3059:\\n    -v -verbose[:class|gc|jni]\\n                      \\u8A73\\u7D30\\u30E2\\u30FC\\u30C9\\u3092\\u30AA\\u30F3\\u306B\\u3059\\u308B\\n    -D<name>=<value>  \\u30B7\\u30B9\\u30C6\\u30E0\\u30FB\\u30D7\\u30ED\\u30D1\\u30C6\\u30A3\\u3092\\u8A2D\\u5B9A\\u3059\\u308B\\n    -classpath <directories separated by \\\"{1}\\\">\\n                      \\u30AF\\u30E9\\u30B9\\u3092\\u691C\\u7D22\\u3059\\u308B\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA\\u3092\\u30EA\\u30B9\\u30C8\\u3059\\u308B\\n    -X<option>        \\u975E\\u6A19\\u6E96\\u306E\\u30BF\\u30FC\\u30B2\\u30C3\\u30C8VM\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\n\\n<class>\\u306F\\u30C7\\u30D0\\u30C3\\u30B0\\u3092\\u958B\\u59CB\\u3059\\u308B\\u30AF\\u30E9\\u30B9\\u306E\\u540D\\u524D\\u3067\\u3059\\n<arguments>\\u306F<class>\\u306Emain()\\u30E1\\u30BD\\u30C3\\u30C9\\u306B\\u6E21\\u3055\\u308C\\u308B\\u5F15\\u6570\\u3067\\u3059\\n\\n\\u30B3\\u30DE\\u30F3\\u30C9\\u306E\\u30D8\\u30EB\\u30D7\\u306B\\u3064\\u3044\\u3066\\u306F{0}\\u30D7\\u30ED\\u30F3\\u30D7\\u30C8\\u3067''help''\\u3092\\u5165\\u529B\\u3057\\u3066\\u304F\\u3060\\u3055\\u3044\"},\n+             \"\\u4F7F\\u7528\\u65B9\\u6CD5: {0} <options> <class> <arguments>\\n\\n\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u306F\\u6B21\\u306E\\u3068\\u304A\\u308A\\u3067\\u3059:\\n    -? -h --help -help \\u3053\\u306E\\u30D8\\u30EB\\u30D7\\u30FB\\u30E1\\u30C3\\u30BB\\u30FC\\u30B8\\u3092\\u51FA\\u529B\\u3057\\u3066\\u7D42\\u4E86\\u3059\\u308B\\n    -sourcepath <directories separated by \\\"{1}\\\">\\n                      \\u30BD\\u30FC\\u30B9\\u30FB\\u30D5\\u30A1\\u30A4\\u30EB\\u3092\\u691C\\u7D22\\u3059\\u308B\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA\\n    -attach <address>\\n                      \\u6A19\\u6E96\\u30B3\\u30CD\\u30AF\\u30BF\\u3092\\u4F7F\\u7528\\u3057\\u3066\\u3001\\u6307\\u5B9A\\u3055\\u308C\\u305F\\u30A2\\u30C9\\u30EC\\u30B9\\u3067\\u5B9F\\u884C\\u4E2D\\u306EVM\\u306B\\u63A5\\u7D9A\\u3059\\u308B\\n    -listen <address>\\n                      \\u6A19\\u6E96\\u30B3\\u30CD\\u30AF\\u30BF\\u3092\\u4F7F\\u7528\\u3057\\u3066\\u3001\\u6307\\u5B9A\\u3055\\u308C\\u305F\\u30A2\\u30C9\\u30EC\\u30B9\\u3067\\u5B9F\\u884C\\u4E2D\\u306EVM\\u306E\\u63A5\\u7D9A\\u3092\\u5F85\\u6A5F\\u3059\\u308B\\n    -listenany\\n                      \\u6A19\\u6E96\\u30B3\\u30CD\\u30AF\\u30BF\\u3092\\u4F7F\\u7528\\u3057\\u3066\\u3001\\u4F7F\\u7528\\u53EF\\u80FD\\u306A\\u4EFB\\u610F\\u306E\\u30A2\\u30C9\\u30EC\\u30B9\\u3067\\u5B9F\\u884C\\u4E2D\\u306EVM\\u306E\\u63A5\\u7D9A\\u3092\\u5F85\\u6A5F\\u3059\\u308B\\n    -launch\\n                      ''run''\\u30B3\\u30DE\\u30F3\\u30C9\\u3092\\u5F85\\u6A5F\\u305B\\u305A\\u306BVM\\u3092\\u5373\\u6642\\u306B\\u8D77\\u52D5\\u3059\\u308B\\n    -listconnectors   \\u3053\\u306EVM\\u3067\\u4F7F\\u7528\\u53EF\\u80FD\\u306A\\u30B3\\u30CD\\u30AF\\u30BF\\u3092\\u30EA\\u30B9\\u30C8\\u3059\\u308B\\n    -connect <connector-name>:<name1>=<value1>,...\\n                      \\u6307\\u5B9A\\u3055\\u308C\\u305F\\u30B3\\u30CD\\u30AF\\u30BF\\u3092\\u4F7F\\u7528\\u3057\\u3066\\u3001\\u30EA\\u30B9\\u30C8\\u3055\\u308C\\u305F\\u5F15\\u6570\\u5024\\u3067\\u30BF\\u30FC\\u30B2\\u30C3\\u30C8VM\\u306B\\u63A5\\u7D9A\\u3059\\u308B\\n    -dbgtrace [flags] {0}\\u306E\\u30C7\\u30D0\\u30C3\\u30B0\\u306E\\u60C5\\u5831\\u3092\\u51FA\\u529B\\u3059\\u308B\\n    -tclient          \\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u3092HotSpot(TM) Client Compiler\\u3067\\u5B9F\\u884C\\u3059\\u308B\\n    -tserver          \\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u3092HotSpot(TM) Server Compiler\\u3067\\u5B9F\\u884C\\u3059\\u308B\\n    -R<option>        jdb\\u306B\\u3088\\u3063\\u3066\\u8D77\\u52D5\\u3055\\u308C\\u305F\\u5834\\u5408\\u306B\\u3001\\u30C7\\u30D0\\u30C3\\u30B0\\u3059\\u308B\\u30D7\\u30ED\\u30BB\\u30B9\\u306B<option>\\u3092\\u8EE2\\u9001\\u3059\\u308B\\u3002\\u305D\\u308C\\u4EE5\\u5916\\u306E\\u5834\\u5408\\u306F\\u7121\\u8996\\u3055\\u308C\\u308B\\n\\njdb\\u306B\\u3088\\u3063\\u3066\\u8D77\\u52D5\\u3055\\u308C\\u305F\\u5834\\u5408\\u306B\\u3001\\u30C7\\u30D0\\u30C3\\u30B0\\u3059\\u308B\\u30D7\\u30ED\\u30BB\\u30B9\\u306B\\u8EE2\\u9001\\u3055\\u308C\\u308B\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3(-R\\u3092\\u4F7F\\u7528\\u3057\\u306A\\u3044\\u7701\\u7565\\u8868\\u8A18):\\n    -v -verbose[:class|gc|jni]\\n                      \\u8A73\\u7D30\\u30E2\\u30FC\\u30C9\\u3092\\u30AA\\u30F3\\u306B\\u3059\\u308B\\n    -D<name>=<value>  \\u30B7\\u30B9\\u30C6\\u30E0\\u30FB\\u30D7\\u30ED\\u30D1\\u30C6\\u30A3\\u3092\\u8A2D\\u5B9A\\u3059\\u308B\\n    -classpath <directories separated by \\\"{1}\\\">\\n                      \\u30AF\\u30E9\\u30B9\\u3092\\u691C\\u7D22\\u3059\\u308B\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA\\u3092\\u30EA\\u30B9\\u30C8\\u3059\\u308B\\n    -X<option>        \\u975E\\u6A19\\u6E96\\u306E\\u30BF\\u30FC\\u30B2\\u30C3\\u30C8VM\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\n\\n<class>\\u306F\\u30C7\\u30D0\\u30C3\\u30B0\\u3092\\u958B\\u59CB\\u3059\\u308B\\u30AF\\u30E9\\u30B9\\u306E\\u540D\\u524D\\u3067\\u3059\\n<arguments>\\u306F<class>\\u306Emain()\\u30E1\\u30BD\\u30C3\\u30C9\\u306B\\u6E21\\u3055\\u308C\\u308B\\u5F15\\u6570\\u3067\\u3059\\n\\n\\u30B3\\u30DE\\u30F3\\u30C9\\u306E\\u30D8\\u30EB\\u30D7\\u306B\\u3064\\u3044\\u3066\\u306F{0}\\u30D7\\u30ED\\u30F3\\u30D7\\u30C8\\u3067''help''\\u3092\\u5165\\u529B\\u3057\\u3066\\u304F\\u3060\\u3055\\u3044\"},\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/TTYResources_ja.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -305,1 +305,0 @@\n-        {\"Threadgroup name not specified.\", \"\\u672A\\u6307\\u5B9A\\u7EBF\\u7A0B\\u7EC4\\u540D\\u3002\"},\n@@ -342,1 +341,1 @@\n-             \"** \\u547D\\u4EE4\\u5217\\u8868 **\\nconnectors                -- \\u5217\\u51FA\\u6B64 VM \\u4E2D\\u53EF\\u7528\\u7684\\u8FDE\\u63A5\\u5668\\u548C\\u4F20\\u8F93\\n\\nrun [class [args]]        -- \\u5F00\\u59CB\\u6267\\u884C\\u5E94\\u7528\\u7A0B\\u5E8F\\u7684\\u4E3B\\u7C7B\\n\\nthreads [threadgroup]     -- \\u5217\\u51FA\\u7EBF\\u7A0B\\nthread <thread id>        -- \\u8BBE\\u7F6E\\u9ED8\\u8BA4\\u7EBF\\u7A0B\\nsuspend [thread id(s)]    -- \\u6302\\u8D77\\u7EBF\\u7A0B (\\u9ED8\\u8BA4\\u503C: all)\\nresume [thread id(s)]     -- \\u6062\\u590D\\u7EBF\\u7A0B (\\u9ED8\\u8BA4\\u503C: all)\\nwhere [<thread id> | all] -- \\u8F6C\\u50A8\\u7EBF\\u7A0B\\u7684\\u5806\\u6808\\nwherei [<thread id> | all]-- \\u8F6C\\u50A8\\u7EBF\\u7A0B\\u7684\\u5806\\u6808, \\u4EE5\\u53CA pc \\u4FE1\\u606F\\nup [n frames]             -- \\u4E0A\\u79FB\\u7EBF\\u7A0B\\u7684\\u5806\\u6808\\ndown [n frames]           -- \\u4E0B\\u79FB\\u7EBF\\u7A0B\\u7684\\u5806\\u6808\\nkill <thread id> <expr>   -- \\u7EC8\\u6B62\\u5177\\u6709\\u7ED9\\u5B9A\\u7684\\u5F02\\u5E38\\u9519\\u8BEF\\u5BF9\\u8C61\\u7684\\u7EBF\\u7A0B\\ninterrupt <thread id>     -- \\u4E2D\\u65AD\\u7EBF\\u7A0B\\n\\nprint <expr>              -- \\u8F93\\u51FA\\u8868\\u8FBE\\u5F0F\\u7684\\u503C\\ndump <expr>               -- \\u8F93\\u51FA\\u6240\\u6709\\u5BF9\\u8C61\\u4FE1\\u606F\\neval <expr>               -- \\u5BF9\\u8868\\u8FBE\\u5F0F\\u6C42\\u503C (\\u4E0E print \\u76F8\\u540C)\\nset <lvalue> = <expr>     -- \\u5411\\u5B57\\u6BB5\/\\u53D8\\u91CF\/\\u6570\\u7EC4\\u5143\\u7D20\\u5206\\u914D\\u65B0\\u503C\\nlocals                    -- \\u8F93\\u51FA\\u5F53\\u524D\\u5806\\u6808\\u5E27\\u4E2D\\u7684\\u6240\\u6709\\u672C\\u5730\\u53D8\\u91CF\\n\\nclasses                   -- \\u5217\\u51FA\\u5F53\\u524D\\u5DF2\\u77E5\\u7684\\u7C7B\\nclass <class id>          -- \\u663E\\u793A\\u5DF2\\u547D\\u540D\\u7C7B\\u7684\\u8BE6\\u7EC6\\u8D44\\u6599\\nmethods <class id>        -- \\u5217\\u51FA\\u7C7B\\u7684\\u65B9\\u6CD5\\nfields <class id>         -- \\u5217\\u51FA\\u7C7B\\u7684\\u5B57\\u6BB5\\n\\nthreadgroups              -- \\u5217\\u51FA\\u7EBF\\u7A0B\\u7EC4\\nthreadgroup <name>        -- \\u8BBE\\u7F6E\\u5F53\\u524D\\u7EBF\\u7A0B\\u7EC4\\n\\nstop [go|thread] [<thread_id>] <at|in> <location>\\n                          -- \\u8BBE\\u7F6E\\u65AD\\u70B9\\n                          -- \\u5982\\u679C\\u672A\\u63D0\\u4F9B\\u4EFB\\u4F55\\u9009\\u9879\\uFF0C\\u5219\\u5C06\\u6253\\u5370\\u5F53\\u524D\\u65AD\\u70B9\\u5217\\u8868\\n                          -- \\u5982\\u679C\\u6307\\u5B9A \\\"go\\\"\\uFF0C\\u5219\\u5728\\u505C\\u6B62\\u540E\\u7ACB\\u5373\\u6062\\u590D\\n                          -- \\u5982\\u679C\\u6307\\u5B9A \\\"thread\\\"\\uFF0C\\u5219\\u4EC5\\u6302\\u8D77\\u5728\\u5176\\u4E2D\\u505C\\u6B62\\u7684\\u7EBF\\u7A0B\\n                          -- \\u5982\\u679C\\u65E2\\u672A\\u6307\\u5B9A \\\"go\\\" \\u4E5F\\u672A\\u6307\\u5B9A \\\"thread\\\"\\uFF0C\\u5219\\u6302\\u8D77\\u6240\\u6709\\u7EBF\\u7A0B\\n                          -- \\u5982\\u679C\\u6307\\u5B9A\\u4EE5\\u6574\\u6570\\u8868\\u793A\\u7684 <thread_id>\\uFF0C\\u5219\\u4EC5\\u5728\\u6307\\u5B9A\\u7684\\u7EBF\\u7A0B\\u4E2D\\u505C\\u6B62\\n                          -- \\\"at\\\" \\u548C \\\"in\\\" \\u7684\\u542B\\u4E49\\u76F8\\u540C\\n                          -- <location> \\u53EF\\u4EE5\\u662F\\u884C\\u53F7\\u6216\\u65B9\\u6CD5\\uFF1A\\n                          --   <class_id>:<line_number>\\n                          --   <class_id>.<method>[(argument_type,...)]\\nclear <class id>.<method>[(argument_type,...)]\\n                          -- \\u6E05\\u9664\\u65B9\\u6CD5\\u4E2D\\u7684\\u65AD\\u70B9\\nclear <class id>:<line>   -- \\u6E05\\u9664\\u884C\\u4E2D\\u7684\\u65AD\\u70B9\\nclear                     -- \\u5217\\u51FA\\u65AD\\u70B9\\ncatch [uncaught|caught|all] <class id>|<class pattern>\\n                          -- \\u51FA\\u73B0\\u6307\\u5B9A\\u7684\\u5F02\\u5E38\\u9519\\u8BEF\\u65F6\\u4E2D\\u65AD\\nignore [uncaught|caught|all] <class id>|<class pattern>\\n                          -- \\u5BF9\\u4E8E\\u6307\\u5B9A\\u7684\\u5F02\\u5E38\\u9519\\u8BEF, \\u53D6\\u6D88 'catch'\\nwatch [access|all] <class id>.<field name>\\n                          -- \\u76D1\\u89C6\\u5BF9\\u5B57\\u6BB5\\u7684\\u8BBF\\u95EE\/\\u4FEE\\u6539\\nunwatch [access|all] <class id>.<field name>\\n                          -- \\u505C\\u6B62\\u76D1\\u89C6\\u5BF9\\u5B57\\u6BB5\\u7684\\u8BBF\\u95EE\/\\u4FEE\\u6539\\ntrace [go] methods [thread]\\n                          -- \\u8DDF\\u8E2A\\u65B9\\u6CD5\\u8FDB\\u5165\\u548C\\u9000\\u51FA\\u3002\\n                          -- \\u9664\\u975E\\u6307\\u5B9A 'go', \\u5426\\u5219\\u6302\\u8D77\\u6240\\u6709\\u7EBF\\u7A0B\\ntrace [go] method exit | exits [thread]\\n                          -- \\u8DDF\\u8E2A\\u5F53\\u524D\\u65B9\\u6CD5\\u7684\\u9000\\u51FA, \\u6216\\u8005\\u6240\\u6709\\u65B9\\u6CD5\\u7684\\u9000\\u51FA\\n                          -- \\u9664\\u975E\\u6307\\u5B9A 'go', \\u5426\\u5219\\u6302\\u8D77\\u6240\\u6709\\u7EBF\\u7A0B\\nuntrace [methods]         -- \\u505C\\u6B62\\u8DDF\\u8E2A\\u65B9\\u6CD5\\u8FDB\\u5165\\u548C\/\\u6216\\u9000\\u51FA\\nstep                      -- \\u6267\\u884C\\u5F53\\u524D\\u884C\\nstep up                   -- \\u4E00\\u76F4\\u6267\\u884C, \\u76F4\\u5230\\u5F53\\u524D\\u65B9\\u6CD5\\u8FD4\\u56DE\\u5230\\u5176\\u8C03\\u7528\\u65B9\\nstepi                     -- \\u6267\\u884C\\u5F53\\u524D\\u6307\\u4EE4\\n\\u4E0B\\u4E00\\u6B65                      -- \\u6B65\\u8FDB\\u4E00\\u884C (\\u6B65\\u8FC7\\u8C03\\u7528)\\ncont                      -- \\u4ECE\\u65AD\\u70B9\\u5904\\u7EE7\\u7EED\\u6267\\u884C\\n\\nlist [line number|method] -- \\u8F93\\u51FA\\u6E90\\u4EE3\\u7801\\nuse (\\u6216 sourcepath) [source file path]\\n                          -- \\u663E\\u793A\\u6216\\u66F4\\u6539\\u6E90\\u8DEF\\u5F84\\nexclude [<class pattern>, ... | \\\"none\\\"]\\n                          -- \\u5BF9\\u4E8E\\u6307\\u5B9A\\u7684\\u7C7B, \\u4E0D\\u62A5\\u544A\\u6B65\\u9AA4\\u6216\\u65B9\\u6CD5\\u4E8B\\u4EF6\\nclasspath                 -- \\u4ECE\\u76EE\\u6807 VM \\u8F93\\u51FA\\u7C7B\\u8DEF\\u5F84\\u4FE1\\u606F\\n\\nmonitor <command>         -- \\u6BCF\\u6B21\\u7A0B\\u5E8F\\u505C\\u6B62\\u65F6\\u6267\\u884C\\u547D\\u4EE4\\nmonitor                   -- \\u5217\\u51FA\\u76D1\\u89C6\\u5668\\nunmonitor <monitor#>      -- \\u5220\\u9664\\u76D1\\u89C6\\u5668\\nread <filename>           -- \\u8BFB\\u53D6\\u5E76\\u6267\\u884C\\u547D\\u4EE4\\u6587\\u4EF6\\n\\nlock <expr>               -- \\u8F93\\u51FA\\u5BF9\\u8C61\\u7684\\u9501\\u4FE1\\u606F\\nthreadlocks [thread id]   -- \\u8F93\\u51FA\\u7EBF\\u7A0B\\u7684\\u9501\\u4FE1\\u606F\\n\\npop                       -- \\u901A\\u8FC7\\u5F53\\u524D\\u5E27\\u51FA\\u6808, \\u4E14\\u5305\\u542B\\u5F53\\u524D\\u5E27\\nreenter                   -- \\u4E0E pop \\u76F8\\u540C, \\u4F46\\u91CD\\u65B0\\u8FDB\\u5165\\u5F53\\u524D\\u5E27\\nredefine <class id> <class file name>\\n                          -- \\u91CD\\u65B0\\u5B9A\\u4E49\\u7C7B\\u7684\\u4EE3\\u7801\\n\\ndisablegc <expr>          -- \\u7981\\u6B62\\u5BF9\\u8C61\\u7684\\u5783\\u573E\\u6536\\u96C6\\nenablegc <expr>           -- \\u5141\\u8BB8\\u5BF9\\u8C61\\u7684\\u5783\\u573E\\u6536\\u96C6\\n\\n!!                        -- \\u91CD\\u590D\\u6267\\u884C\\u6700\\u540E\\u4E00\\u4E2A\\u547D\\u4EE4\\n<n> <command>             -- \\u5C06\\u547D\\u4EE4\\u91CD\\u590D\\u6267\\u884C n \\u6B21\\nrepeat                    -- \\u663E\\u793A\\u662F\\u5426\\u542F\\u7528\\u4E86 GDB \\u6837\\u5F0F\\u7684\\u7A7A\\u547D\\u4EE4\\u91CD\\u590D\\nrepeat <on|off>           -- \\u542F\\u7528\/\\u7981\\u7528 GDB \\u6837\\u5F0F\\u7684\\u91CD\\u590D\\n# <command>               -- \\u653E\\u5F03 (\\u65E0\\u64CD\\u4F5C)\\nhelp (\\u6216 ?)               -- \\u5217\\u51FA\\u547D\\u4EE4\\ndbgtrace [flag]           -- \\u4E0E dbgtrace \\u547D\\u4EE4\\u884C\\u9009\\u9879\\u76F8\\u540C\\nversion                   -- \\u8F93\\u51FA\\u7248\\u672C\\u4FE1\\u606F\\nexit (\\u6216 quit)            -- \\u9000\\u51FA\\u8C03\\u8BD5\\u5668\\n\\n<class id>: \\u5E26\\u6709\\u7A0B\\u5E8F\\u5305\\u9650\\u5B9A\\u7B26\\u7684\\u5B8C\\u6574\\u7C7B\\u540D\\n<class pattern>: \\u5E26\\u6709\\u524D\\u5BFC\\u6216\\u5C3E\\u968F\\u901A\\u914D\\u7B26 ('*') \\u7684\\u7C7B\\u540D\\n<thread id>: 'threads' \\u547D\\u4EE4\\u4E2D\\u62A5\\u544A\\u7684\\u7EBF\\u7A0B\\u7F16\\u53F7\\n<expr>: Java(TM) \\u7F16\\u7A0B\\u8BED\\u8A00\\u8868\\u8FBE\\u5F0F\\u3002\\n\\u652F\\u6301\\u5927\\u591A\\u6570\\u5E38\\u89C1\\u8BED\\u6CD5\\u3002\\n\\n\\u53EF\\u4EE5\\u5C06\\u542F\\u52A8\\u547D\\u4EE4\\u7F6E\\u4E8E \\\"jdb.ini\\\" \\u6216 \\\".jdbrc\\\" \\u4E2D\\n\\u4F4D\\u4E8E user.home \\u6216 user.dir \\u4E2D\"},\n+             \"** \\u547D\\u4EE4\\u5217\\u8868 **\\nconnectors                -- \\u5217\\u51FA\\u6B64 VM \\u4E2D\\u53EF\\u7528\\u7684\\u8FDE\\u63A5\\u5668\\u548C\\u4F20\\u8F93\\n\\nrun [class [args]]        -- \\u5F00\\u59CB\\u6267\\u884C\\u5E94\\u7528\\u7A0B\\u5E8F\\u7684\\u4E3B\\u7C7B\\n\\nthreads [threadgroup]     -- \\u5217\\u51FA\\u7EBF\\u7A0B\\u7EC4\\u4E2D\\u7684\\u7EBF\\u7A0B\\u3002\\u5982\\u679C\\u672A\\u6307\\u5B9A\\uFF0C\\u5219\\u4F7F\\u7528\\u5F53\\u524D\\u7EBF\\u7A0B\\u7EC4\\u3002\\nthread <thread id>        -- \\u8BBE\\u7F6E\\u9ED8\\u8BA4\\u7EBF\\u7A0B\\nsuspend [thread id(s)]    -- \\u6302\\u8D77\\u7EBF\\u7A0B (\\u9ED8\\u8BA4\\u503C: all)\\nresume [thread id(s)]     -- \\u6062\\u590D\\u7EBF\\u7A0B (\\u9ED8\\u8BA4\\u503C: all)\\nwhere [<thread id> | all] -- \\u8F6C\\u50A8\\u7EBF\\u7A0B\\u7684\\u5806\\u6808\\nwherei [<thread id> | all]-- \\u8F6C\\u50A8\\u7EBF\\u7A0B\\u7684\\u5806\\u6808, \\u4EE5\\u53CA pc \\u4FE1\\u606F\\nup [n frames]             -- \\u4E0A\\u79FB\\u7EBF\\u7A0B\\u7684\\u5806\\u6808\\ndown [n frames]           -- \\u4E0B\\u79FB\\u7EBF\\u7A0B\\u7684\\u5806\\u6808\\nkill <thread id> <expr>   -- \\u7EC8\\u6B62\\u5177\\u6709\\u7ED9\\u5B9A\\u7684\\u5F02\\u5E38\\u9519\\u8BEF\\u5BF9\\u8C61\\u7684\\u7EBF\\u7A0B\\ninterrupt <thread id>     -- \\u4E2D\\u65AD\\u7EBF\\u7A0B\\n\\nprint <expr>              -- \\u8F93\\u51FA\\u8868\\u8FBE\\u5F0F\\u7684\\u503C\\ndump <expr>               -- \\u8F93\\u51FA\\u6240\\u6709\\u5BF9\\u8C61\\u4FE1\\u606F\\neval <expr>               -- \\u5BF9\\u8868\\u8FBE\\u5F0F\\u6C42\\u503C (\\u4E0E print \\u76F8\\u540C)\\nset <lvalue> = <expr>     -- \\u5411\\u5B57\\u6BB5\/\\u53D8\\u91CF\/\\u6570\\u7EC4\\u5143\\u7D20\\u5206\\u914D\\u65B0\\u503C\\nlocals                    -- \\u8F93\\u51FA\\u5F53\\u524D\\u5806\\u6808\\u5E27\\u4E2D\\u7684\\u6240\\u6709\\u672C\\u5730\\u53D8\\u91CF\\n\\nclasses                   -- \\u5217\\u51FA\\u5F53\\u524D\\u5DF2\\u77E5\\u7684\\u7C7B\\nclass <class id>          -- \\u663E\\u793A\\u5DF2\\u547D\\u540D\\u7C7B\\u7684\\u8BE6\\u7EC6\\u8D44\\u6599\\nmethods <class id>        -- \\u5217\\u51FA\\u7C7B\\u7684\\u65B9\\u6CD5\\nfields <class id>         -- \\u5217\\u51FA\\u7C7B\\u7684\\u5B57\\u6BB5\\n\\nthreadgroups              -- \\u5217\\u51FA\\u7EBF\\u7A0B\\u7EC4\\nthreadgroup <name>        -- \\u5C06\\u5F53\\u524D\\u7EBF\\u7A0B\\u7EC4\\u8BBE\\u7F6E\\u4E3A <name>\\nthreadgroup               -- \\u5C06\\u5F53\\u524D\\u7EBF\\u7A0B\\u7EC4\\u8BBE\\u7F6E\\u56DE\\u9876\\u7EA7\\u7EBF\\u7A0B\\u7EC4\\n\\nstop [go|thread] [<thread_id>] <at|in> <location>\\n                          -- \\u8BBE\\u7F6E\\u65AD\\u70B9\\n                          -- \\u5982\\u679C\\u672A\\u63D0\\u4F9B\\u4EFB\\u4F55\\u9009\\u9879\\uFF0C\\u5219\\u5C06\\u6253\\u5370\\u5F53\\u524D\\u65AD\\u70B9\\u5217\\u8868\\n                          -- \\u5982\\u679C\\u6307\\u5B9A \\\"go\\\"\\uFF0C\\u5219\\u5728\\u505C\\u6B62\\u540E\\u7ACB\\u5373\\u6062\\u590D\\n                          -- \\u5982\\u679C\\u6307\\u5B9A \\\"thread\\\"\\uFF0C\\u5219\\u4EC5\\u6302\\u8D77\\u5728\\u5176\\u4E2D\\u505C\\u6B62\\u7684\\u7EBF\\u7A0B\\n                          -- \\u5982\\u679C\\u65E2\\u672A\\u6307\\u5B9A \\\"go\\\" \\u4E5F\\u672A\\u6307\\u5B9A \\\"thread\\\"\\uFF0C\\u5219\\u6302\\u8D77\\u6240\\u6709\\u7EBF\\u7A0B\\n                          -- \\u5982\\u679C\\u6307\\u5B9A\\u4EE5\\u6574\\u6570\\u8868\\u793A\\u7684 <thread_id>\\uFF0C\\u5219\\u4EC5\\u5728\\u6307\\u5B9A\\u7684\\u7EBF\\u7A0B\\u4E2D\\u505C\\u6B62\\n                          -- \\\"at\\\" \\u548C \\\"in\\\" \\u7684\\u542B\\u4E49\\u76F8\\u540C\\n                          -- <location> \\u53EF\\u4EE5\\u662F\\u884C\\u53F7\\u6216\\u65B9\\u6CD5\\uFF1A\\n                          --   <class_id>:<line_number>\\n                          --   <class_id>.<method>[(argument_type,...)]\\nclear <class id>.<method>[(argument_type,...)]\\n                          -- \\u6E05\\u9664\\u65B9\\u6CD5\\u4E2D\\u7684\\u65AD\\u70B9\\nclear <class id>:<line>   -- \\u6E05\\u9664\\u884C\\u4E2D\\u7684\\u65AD\\u70B9\\nclear                     -- \\u5217\\u51FA\\u65AD\\u70B9\\ncatch [uncaught|caught|all] <class id>|<class pattern>\\n                          -- \\u51FA\\u73B0\\u6307\\u5B9A\\u7684\\u5F02\\u5E38\\u9519\\u8BEF\\u65F6\\u4E2D\\u65AD\\nignore [uncaught|caught|all] <class id>|<class pattern>\\n                          -- \\u5BF9\\u4E8E\\u6307\\u5B9A\\u7684\\u5F02\\u5E38\\u9519\\u8BEF, \\u53D6\\u6D88 'catch'\\nwatch [access|all] <class id>.<field name>\\n                          -- \\u76D1\\u89C6\\u5BF9\\u5B57\\u6BB5\\u7684\\u8BBF\\u95EE\/\\u4FEE\\u6539\\nunwatch [access|all] <class id>.<field name>\\n                          -- \\u505C\\u6B62\\u76D1\\u89C6\\u5BF9\\u5B57\\u6BB5\\u7684\\u8BBF\\u95EE\/\\u4FEE\\u6539\\ntrace [go] methods [thread]\\n                          -- \\u8DDF\\u8E2A\\u65B9\\u6CD5\\u8FDB\\u5165\\u548C\\u9000\\u51FA\\u3002\\n                          -- \\u9664\\u975E\\u6307\\u5B9A 'go', \\u5426\\u5219\\u6302\\u8D77\\u6240\\u6709\\u7EBF\\u7A0B\\ntrace [go] method exit | exits [thread]\\n                          -- \\u8DDF\\u8E2A\\u5F53\\u524D\\u65B9\\u6CD5\\u7684\\u9000\\u51FA, \\u6216\\u8005\\u6240\\u6709\\u65B9\\u6CD5\\u7684\\u9000\\u51FA\\n                          -- \\u9664\\u975E\\u6307\\u5B9A 'go', \\u5426\\u5219\\u6302\\u8D77\\u6240\\u6709\\u7EBF\\u7A0B\\nuntrace [methods]         -- \\u505C\\u6B62\\u8DDF\\u8E2A\\u65B9\\u6CD5\\u8FDB\\u5165\\u548C\/\\u6216\\u9000\\u51FA\\nstep                      -- \\u6267\\u884C\\u5F53\\u524D\\u884C\\nstep up                   -- \\u4E00\\u76F4\\u6267\\u884C, \\u76F4\\u5230\\u5F53\\u524D\\u65B9\\u6CD5\\u8FD4\\u56DE\\u5230\\u5176\\u8C03\\u7528\\u65B9\\nstepi                     -- \\u6267\\u884C\\u5F53\\u524D\\u6307\\u4EE4\\n\\u4E0B\\u4E00\\u6B65                      -- \\u6B65\\u8FDB\\u4E00\\u884C (\\u6B65\\u8FC7\\u8C03\\u7528)\\ncont                      -- \\u4ECE\\u65AD\\u70B9\\u5904\\u7EE7\\u7EED\\u6267\\u884C\\n\\nlist [line number|method] -- \\u8F93\\u51FA\\u6E90\\u4EE3\\u7801\\nuse (\\u6216 sourcepath) [source file path]\\n                          -- \\u663E\\u793A\\u6216\\u66F4\\u6539\\u6E90\\u8DEF\\u5F84\\nexclude [<class pattern>, ... | \\\"none\\\"]\\n                          -- \\u5BF9\\u4E8E\\u6307\\u5B9A\\u7684\\u7C7B, \\u4E0D\\u62A5\\u544A\\u6B65\\u9AA4\\u6216\\u65B9\\u6CD5\\u4E8B\\u4EF6\\nclasspath                 -- \\u4ECE\\u76EE\\u6807 VM \\u8F93\\u51FA\\u7C7B\\u8DEF\\u5F84\\u4FE1\\u606F\\n\\nmonitor <command>         -- \\u6BCF\\u6B21\\u7A0B\\u5E8F\\u505C\\u6B62\\u65F6\\u6267\\u884C\\u547D\\u4EE4\\nmonitor                   -- \\u5217\\u51FA\\u76D1\\u89C6\\u5668\\nunmonitor <monitor#>      -- \\u5220\\u9664\\u76D1\\u89C6\\u5668\\nread <filename>           -- \\u8BFB\\u53D6\\u5E76\\u6267\\u884C\\u547D\\u4EE4\\u6587\\u4EF6\\n\\nlock <expr>               -- \\u8F93\\u51FA\\u5BF9\\u8C61\\u7684\\u9501\\u4FE1\\u606F\\nthreadlocks [thread id]   -- \\u8F93\\u51FA\\u7EBF\\u7A0B\\u7684\\u9501\\u4FE1\\u606F\\n\\npop                       -- \\u901A\\u8FC7\\u5F53\\u524D\\u5E27\\u51FA\\u6808, \\u4E14\\u5305\\u542B\\u5F53\\u524D\\u5E27\\nreenter                   -- \\u4E0E pop \\u76F8\\u540C, \\u4F46\\u91CD\\u65B0\\u8FDB\\u5165\\u5F53\\u524D\\u5E27\\nredefine <class id> <class file name>\\n                          -- \\u91CD\\u65B0\\u5B9A\\u4E49\\u7C7B\\u7684\\u4EE3\\u7801\\n\\ndisablegc <expr>          -- \\u7981\\u6B62\\u5BF9\\u8C61\\u7684\\u5783\\u573E\\u6536\\u96C6\\nenablegc <expr>           -- \\u5141\\u8BB8\\u5BF9\\u8C61\\u7684\\u5783\\u573E\\u6536\\u96C6\\n\\n!!                        -- \\u91CD\\u590D\\u6267\\u884C\\u6700\\u540E\\u4E00\\u4E2A\\u547D\\u4EE4\\n<n> <command>             -- \\u5C06\\u547D\\u4EE4\\u91CD\\u590D\\u6267\\u884C n \\u6B21\\nrepeat                    -- \\u663E\\u793A\\u662F\\u5426\\u542F\\u7528\\u4E86 GDB \\u6837\\u5F0F\\u7684\\u7A7A\\u547D\\u4EE4\\u91CD\\u590D\\nrepeat <on|off>           -- \\u542F\\u7528\/\\u7981\\u7528 GDB \\u6837\\u5F0F\\u7684\\u91CD\\u590D\\n# <command>               -- \\u653E\\u5F03 (\\u65E0\\u64CD\\u4F5C)\\nhelp (\\u6216 ?)               -- \\u5217\\u51FA\\u547D\\u4EE4\\ndbgtrace [flag]           -- \\u4E0E dbgtrace \\u547D\\u4EE4\\u884C\\u9009\\u9879\\u76F8\\u540C\\nversion                   -- \\u8F93\\u51FA\\u7248\\u672C\\u4FE1\\u606F\\nexit (\\u6216 quit)            -- \\u9000\\u51FA\\u8C03\\u8BD5\\u5668\\n\\n<class id>: \\u5E26\\u6709\\u7A0B\\u5E8F\\u5305\\u9650\\u5B9A\\u7B26\\u7684\\u5B8C\\u6574\\u7C7B\\u540D\\n<class pattern>: \\u5E26\\u6709\\u524D\\u5BFC\\u6216\\u5C3E\\u968F\\u901A\\u914D\\u7B26 ('*') \\u7684\\u7C7B\\u540D\\n<thread id>: 'threads' \\u547D\\u4EE4\\u4E2D\\u62A5\\u544A\\u7684\\u7EBF\\u7A0B\\u7F16\\u53F7\\n<expr>: Java(TM) \\u7F16\\u7A0B\\u8BED\\u8A00\\u8868\\u8FBE\\u5F0F\\u3002\\n\\u652F\\u6301\\u5927\\u591A\\u6570\\u5E38\\u89C1\\u8BED\\u6CD5\\u3002\\n\\n\\u53EF\\u4EE5\\u5C06\\u542F\\u52A8\\u547D\\u4EE4\\u7F6E\\u4E8E \\\"jdb.ini\\\" \\u6216 \\\".jdbrc\\\" \\u4E2D\\n\\u4F4D\\u4E8E user.home \\u6216 user.dir \\u4E2D\"},\n@@ -344,1 +343,1 @@\n-             \"\\u7528\\u6CD5\\uFF1A{0} <\\u9009\\u9879> <\\u7C7B> <\\u53C2\\u6570>\\n\\n\\u5176\\u4E2D\\uFF0C\\u9009\\u9879\\u5305\\u62EC\\uFF1A\\n    -? -h --help -help \\u8F93\\u51FA\\u6B64\\u6D88\\u606F\\u5E76\\u9000\\u51FA\\n    -sourcepath <\\u7531 \\\"{1}\\\" \\u5206\\u9694\\u7684\\u76EE\\u5F55>\\n                      \\u8981\\u5728\\u5176\\u4E2D\\u67E5\\u627E\\u6E90\\u6587\\u4EF6\\u7684\\u76EE\\u5F55\\n    -attach <\\u5730\\u5740>\\n                      \\u4F7F\\u7528\\u6807\\u51C6\\u8FDE\\u63A5\\u5668\\u9644\\u52A0\\u5230\\u6307\\u5B9A\\u5730\\u5740\\u5904\\u6B63\\u5728\\u8FD0\\u884C\\u7684 VM\\n    -listen <\\u5730\\u5740>\\n                      \\u7B49\\u5F85\\u6B63\\u5728\\u8FD0\\u884C\\u7684 VM \\u4F7F\\u7528\\u6807\\u51C6\\u8FDE\\u63A5\\u5668\\u5728\\u6307\\u5B9A\\u5730\\u5740\\u5904\\u8FDE\\u63A5\\n    -listenany\\n                      \\u7B49\\u5F85\\u6B63\\u5728\\u8FD0\\u884C\\u7684 VM \\u4F7F\\u7528\\u6807\\u51C6\\u8FDE\\u63A5\\u5668\\u5728\\u4EFB\\u4F55\\u53EF\\u7528\\u5730\\u5740\\u5904\\u8FDE\\u63A5\\n    -launch\\n                      \\u7ACB\\u5373\\u542F\\u52A8 VM \\u800C\\u4E0D\\u662F\\u7B49\\u5F85 ''run'' \\u547D\\u4EE4\\n    -listconnectors   \\u5217\\u51FA\\u6B64 VM \\u4E2D\\u7684\\u53EF\\u7528\\u8FDE\\u63A5\\u5668\\n    -connect <\\u8FDE\\u63A5\\u5668\\u540D\\u79F0>:<\\u540D\\u79F0 1>=<\\u503C 1>,...\\n                      \\u4F7F\\u7528\\u6240\\u5217\\u53C2\\u6570\\u503C\\u901A\\u8FC7\\u6307\\u5B9A\\u7684\\u8FDE\\u63A5\\u5668\\u8FDE\\u63A5\\u5230\\u76EE\\u6807 VM\\n    -dbgtrace [flags] \\u8F93\\u51FA\\u8C03\\u8BD5 {0} \\u7684\\u4FE1\\u606F\\n    -tclient          \\u5728 HotSpot(TM) \\u5BA2\\u6237\\u673A\\u7F16\\u8BD1\\u5668\\u4E2D\\u8FD0\\u884C\\u5E94\\u7528\\u7A0B\\u5E8F\\n    -tserver          \\u5728 HotSpot(TM) \\u670D\\u52A1\\u5668\\u7F16\\u8BD1\\u5668\\u4E2D\\u8FD0\\u884C\\u5E94\\u7528\\u7A0B\\u5E8F\\n\\n\\u8F6C\\u53D1\\u5230\\u88AB\\u8C03\\u8BD5\\u8FDB\\u7A0B\\u7684\\u9009\\u9879\\uFF1A\\n    -v -verbose[:class|gc|jni]\\n                      \\u542F\\u7528\\u8BE6\\u7EC6\\u6A21\\u5F0F\\n    -D<\\u540D\\u79F0>=<\\u503C>  \\u8BBE\\u7F6E\\u7CFB\\u7EDF\\u5C5E\\u6027\\n    -classpath <\\u7531 \\\"{1}\\\" \\u5206\\u9694\\u7684\\u76EE\\u5F55>\\n                      \\u5217\\u51FA\\u8981\\u5728\\u5176\\u4E2D\\u67E5\\u627E\\u7C7B\\u7684\\u76EE\\u5F55\\n    -X<\\u9009\\u9879>        \\u975E\\u6807\\u51C6\\u76EE\\u6807 VM \\u9009\\u9879\\n\\n<\\u7C7B> \\u662F\\u8981\\u5F00\\u59CB\\u8C03\\u8BD5\\u7684\\u7C7B\\u7684\\u540D\\u79F0\\n<\\u53C2\\u6570> \\u662F\\u4F20\\u9012\\u5230 <\\u7C7B> \\u7684 main() \\u65B9\\u6CD5\\u7684\\u53C2\\u6570\\n\\n\\u8981\\u83B7\\u5F97\\u547D\\u4EE4\\u7684\\u5E2E\\u52A9\\uFF0C\\u8BF7\\u5728 {0} \\u63D0\\u793A\\u4E0B\\u952E\\u5165 ''help''\"},\n+             \"\\u7528\\u6CD5\\uFF1A{0} <options> <class> <arguments>\\n\\n\\u5176\\u4E2D\\uFF0C\\u9009\\u9879\\u5305\\u62EC\\uFF1A\\n    -? -h --help -help \\u8F93\\u51FA\\u6B64\\u5E2E\\u52A9\\u6D88\\u606F\\u5E76\\u9000\\u51FA\\n    -sourcepath <\\u7531 \\\"{1}\\\" \\u5206\\u9694\\u7684\\u76EE\\u5F55>\\n                      \\u8981\\u5728\\u5176\\u4E2D\\u67E5\\u627E\\u6E90\\u6587\\u4EF6\\u7684\\u76EE\\u5F55\\n    -attach <address>\\n                      \\u4F7F\\u7528\\u6807\\u51C6\\u8FDE\\u63A5\\u5668\\u9644\\u52A0\\u5230\\u5728\\u6307\\u5B9A\\u5730\\u5740\\u8FD0\\u884C\\u7684 VM\\n    -listen <address>\\n                      \\u7B49\\u5F85\\u6B63\\u5728\\u8FD0\\u884C\\u7684 VM \\u4F7F\\u7528\\u6807\\u51C6\\u8FDE\\u63A5\\u5668\\u5728\\u6307\\u5B9A\\u5730\\u5740\\u5904\\u8FDE\\u63A5\\n    -listenany\\n                      \\u7B49\\u5F85\\u6B63\\u5728\\u8FD0\\u884C\\u7684 VM \\u4F7F\\u7528\\u6807\\u51C6\\u8FDE\\u63A5\\u5668\\u5728\\u4EFB\\u4F55\\u53EF\\u7528\\u5730\\u5740\\u5904\\u8FDE\\u63A5\\n    -launch\\n                      \\u7ACB\\u5373\\u542F\\u52A8 VM \\u800C\\u4E0D\\u662F\\u7B49\\u5F85 ''run'' \\u547D\\u4EE4\\n    -listconnectors   \\u5217\\u51FA\\u6B64 VM \\u4E2D\\u7684\\u53EF\\u7528\\u8FDE\\u63A5\\u5668\\n    -connect <connector-name>:<name1>=<value1>,...\\n                      \\u4F7F\\u7528\\u6240\\u5217\\u53C2\\u6570\\u503C\\u901A\\u8FC7\\u6307\\u5B9A\\u7684\\u8FDE\\u63A5\\u5668\\u8FDE\\u63A5\\u5230\\u76EE\\u6807 VM\\n    -dbgtrace [flags] \\u8F93\\u51FA\\u7528\\u4E8E\\u8C03\\u8BD5 {0} \\u7684\\u4FE1\\u606F\\n    -tclient          \\u5728 HotSpot(TM) \\u5BA2\\u6237\\u7AEF\\u7F16\\u8BD1\\u5668\\u4E2D\\u8FD0\\u884C\\u5E94\\u7528\\u7A0B\\u5E8F\\n    -tserver          \\u5728 HotSpot(TM) \\u670D\\u52A1\\u5668\\u7F16\\u8BD1\\u5668\\u4E2D\\u8FD0\\u884C\\u5E94\\u7528\\u7A0B\\u5E8F\\n    -R<option>        \\u5982\\u679C\\u7531 jdb \\u542F\\u52A8\\uFF0C\\u5219\\u5C06 <option> \\u8F6C\\u53D1\\u5230\\u88AB\\u8C03\\u8BD5\\u8FDB\\u7A0B\\uFF0C\\u5426\\u5219\\u5FFD\\u7565\\n\\n\\u7531 jdb \\u542F\\u52A8\\u65F6\\u8F6C\\u53D1\\u5230\\u88AB\\u8C03\\u8BD5\\u8FDB\\u7A0B\\u7684\\u9009\\u9879\\uFF08\\u4F7F\\u7528\\u901F\\u8BB0\\u7B26\\uFF0C\\u800C\\u4E0D\\u4F7F\\u7528 -R\\uFF09\\uFF1A\\n    -v -verbose[:class|gc|jni]\\n                      \\u542F\\u7528\\u8BE6\\u7EC6\\u6A21\\u5F0F\\n    -D<name>=<value>  \\u8BBE\\u7F6E\\u7CFB\\u7EDF\\u5C5E\\u6027\\n    -classpath <\\u7531 \\\"{1}\\\" \\u5206\\u9694\\u7684\\u76EE\\u5F55>\\n                      \\u5217\\u51FA\\u8981\\u5728\\u5176\\u4E2D\\u67E5\\u627E\\u7C7B\\u7684\\u76EE\\u5F55\\n    -X<option>        \\u975E\\u6807\\u51C6\\u76EE\\u6807 VM \\u9009\\u9879\\n\\n<class> \\u662F\\u8981\\u5F00\\u59CB\\u8C03\\u8BD5\\u7684\\u7C7B\\u7684\\u540D\\u79F0\\n<arguments> \\u662F\\u4F20\\u9012\\u5230 <class> \\u7684 main() \\u65B9\\u6CD5\\u7684\\u53C2\\u6570\\n\\n\\u8981\\u83B7\\u5F97\\u547D\\u4EE4\\u7684\\u5E2E\\u52A9\\uFF0C\\u8BF7\\u5728 {0} \\u63D0\\u793A\\u4E0B\\u952E\\u5165 ''help''\"},\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/TTYResources_zh_CN.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    \/\/ commit(... , long, String, String, String, long, long, long, long, long)\n+    \/\/ commit(... , long, String, String, long, long, long, long, long)\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/ActiveRecordingEvent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-Please file a bug at the Java Bug Database (http:\/\/bugreport.java.com\/bugreport\/) \\\n+Please file a bug at the Java Bug Database (https:\/\/bugreport.java.com\/bugreport\/) \\\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/jlink.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-main.msg.bug=Eine Ausnahme ist in jlink aufgetreten. Melden Sie in der Java-Bugdatenbank (http:\/\/bugreport.java.com\/bugreport\/) einen Bug, nachdem Sie die Bugdatenbank auf Duplikate gepr\\u00FCft haben. Geben Sie in Ihrem Bericht Ihr Programm und die folgende Diagnose an. Vielen Dank.\n+main.msg.bug=Eine Ausnahme ist in jlink aufgetreten. Melden Sie in der Java-Bugdatenbank (https:\/\/bugreport.java.com\/bugreport\/) einen Bug, nachdem Sie die Bugdatenbank auf Duplikate gepr\\u00FCft haben. Geben Sie in Ihrem Bericht Ihr Programm und die folgende Diagnose an. Vielen Dank.\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/jlink_de.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-main.msg.bug=jlink\\u3067\\u4F8B\\u5916\\u304C\\u767A\\u751F\\u3057\\u307E\\u3057\\u305F\\u3002\\u30C7\\u30FC\\u30BF\\u30D9\\u30FC\\u30B9\\u3067\\u91CD\\u8907\\u304C\\u306A\\u3044\\u304B\\u3092\\u3054\\u78BA\\u8A8D\\u306E\\u3046\\u3048\\u3001Java Bug Database (http:\/\/bugreport.java.com\/bugreport\/)\\u3067bug\\u306E\\u767B\\u9332\\u3092\\u304A\\u9858\\u3044\\u3044\\u305F\\u3057\\u307E\\u3059\\u3002\\u30EC\\u30DD\\u30FC\\u30C8\\u306B\\u306F\\u3001\\u305D\\u306E\\u30D7\\u30ED\\u30B0\\u30E9\\u30E0\\u3068\\u6B21\\u306E\\u8A3A\\u65AD\\u5185\\u5BB9\\u3092\\u542B\\u3081\\u3066\\u304F\\u3060\\u3055\\u3044\\u3002\\u3054\\u5354\\u529B\\u3042\\u308A\\u304C\\u3068\\u3046\\u3054\\u3056\\u3044\\u307E\\u3059\\u3002\n+main.msg.bug=jlink\\u3067\\u4F8B\\u5916\\u304C\\u767A\\u751F\\u3057\\u307E\\u3057\\u305F\\u3002\\u30C7\\u30FC\\u30BF\\u30D9\\u30FC\\u30B9\\u3067\\u91CD\\u8907\\u304C\\u306A\\u3044\\u304B\\u3092\\u3054\\u78BA\\u8A8D\\u306E\\u3046\\u3048\\u3001Java Bug Database (https:\/\/bugreport.java.com\/bugreport\/)\\u3067bug\\u306E\\u767B\\u9332\\u3092\\u304A\\u9858\\u3044\\u3044\\u305F\\u3057\\u307E\\u3059\\u3002\\u30EC\\u30DD\\u30FC\\u30C8\\u306B\\u306F\\u3001\\u305D\\u306E\\u30D7\\u30ED\\u30B0\\u30E9\\u30E0\\u3068\\u6B21\\u306E\\u8A3A\\u65AD\\u5185\\u5BB9\\u3092\\u542B\\u3081\\u3066\\u304F\\u3060\\u3055\\u3044\\u3002\\u3054\\u5354\\u529B\\u3042\\u308A\\u304C\\u3068\\u3046\\u3054\\u3056\\u3044\\u307E\\u3059\\u3002\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/jlink_ja.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-main.msg.bug=jlink \\u4E2D\\u51FA\\u73B0\\u5F02\\u5E38\\u9519\\u8BEF\\u3002\\u5982\\u679C\\u5728 Java Bug Database (http:\/\/bugreport.java.com\/bugreport\/) \\u4E2D\\u6CA1\\u6709\\u627E\\u5230\\u8BE5\\u9519\\u8BEF, \\u8BF7\\u5728\\u8BE5\\u6570\\u636E\\u5E93\\u4E2D\\u5EFA\\u7ACB Bug\\u3002\\u8BF7\\u5728\\u62A5\\u544A\\u4E2D\\u9644\\u4E0A\\u60A8\\u7684\\u7A0B\\u5E8F\\u548C\\u4EE5\\u4E0B\\u8BCA\\u65AD\\u4FE1\\u606F\\u3002\\u8C22\\u8C22\\u3002\n+main.msg.bug=jlink \\u4E2D\\u51FA\\u73B0\\u5F02\\u5E38\\u9519\\u8BEF\\u3002\\u5982\\u679C\\u5728 Java Bug Database (https:\/\/bugreport.java.com\/bugreport\/) \\u4E2D\\u6CA1\\u6709\\u627E\\u5230\\u8BE5\\u9519\\u8BEF, \\u8BF7\\u5728\\u8BE5\\u6570\\u636E\\u5E93\\u4E2D\\u5EFA\\u7ACB Bug\\u3002\\u8BF7\\u5728\\u62A5\\u544A\\u4E2D\\u9644\\u4E0A\\u60A8\\u7684\\u7A0B\\u5E8F\\u548C\\u4EE5\\u4E0B\\u8BCA\\u65AD\\u4FE1\\u606F\\u3002\\u8C22\\u8C22\\u3002\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/jlink_zh_CN.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-resource.runtime-info-plist=Info.plist der Java-Laufzeit\n+resource.runtime-info-plist=Info.plist von Java Runtime\n@@ -84,1 +84,1 @@\n-message.dmg-cannot-be-overwritten=DMG-Datei ({0}) ist vorhanden und kann nicht entfernt werden.\n+message.dmg-cannot-be-overwritten=DMG-Datei [{0}] ist vorhanden und kann nicht entfernt werden.\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/MacResources_de.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,180 +27,3 @@\n-MSG_Help=Usage: jpackage <options>\\n\\\n-\\n\\\n-Sample usages:\\n\\\n---------------\\n\\\n-\\    Generate an application package suitable for the host system:\\n\\\n-\\        For a modular application:\\n\\\n-\\            jpackage -n name -p modulePath -m moduleName\/className\\n\\\n-\\        For a non-modular application:\\n\\\n-\\            jpackage -i inputDir -n name \\\\\\n\\\n-\\                --main-class className --main-jar myJar.jar\\n\\\n-\\        From a pre-built application image:\\n\\\n-\\            jpackage -n name --app-image appImageDir\\n\\\n-\\    Generate an application image:\\n\\\n-\\        For a modular application:\\n\\\n-\\            jpackage --type app-image -n name -p modulePath \\\\\\n\\\n-\\                -m moduleName\/className\\n\\\n-\\        For a non-modular application:\\n\\\n-\\            jpackage --type app-image -i inputDir -n name \\\\\\n\\\n-\\                --main-class className --main-jar myJar.jar\\n\\\n-\\        To provide your own options to jlink, run jlink separately:\\n\\\n-\\            jlink --output appRuntimeImage -p modulePath \\\\\\n\\\n-\\                --add-modules moduleName \\\\\\n\\\n-\\                --no-header-files [<additional jlink options>...]\\n\\\n-\\            jpackage --type app-image -n name \\\\\\n\\\n-\\                -m moduleName\/className --runtime-image appRuntimeImage\\n\\\n-\\    Generate a Java runtime package:\\n\\\n-\\        jpackage -n name --runtime-image <runtime-image>\\n\\\n-\\{6}\\\n-\\n\\\n-Generic Options:\\n\\\n-\\  @<filename> \\n\\\n-\\          Read options and\/or mode from a file \\n\\\n-\\          This option can be used multiple times.\\n\\\n-\\  --type -t <type> \\n\\\n-\\          The type of package to create\\n\\\n-\\          Valid values are: {1} \\n\\\n-\\          If this option is not specified a platform dependent\\n\\\n-\\          default type will be created.\\n\\\n-\\  --app-version <version>\\n\\\n-\\          Version of the application and\/or package\\n\\\n-\\  --copyright <copyright string>\\n\\\n-\\          Copyright for the application\\n\\\n-\\  --description <description string>\\n\\\n-\\          Description of the application\\n\\\n-\\  --help -h \\n\\\n-\\          Print the usage text with a list and description of each valid\\n\\\n-\\          option for the current platform to the output stream, and exit\\n\\\n-\\  --icon <file path>\\n\\\n-\\          Path of the icon of the application package\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\  --name -n <name>\\n\\\n-\\          Name of the application and\/or package\\n\\\n-\\  --dest -d <destination path>\\n\\\n-\\          Path where generated output file is placed\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\          Defaults to the current working directory.\\n\\\n-\\  --temp <directory path>\\n\\\n-\\          Path of a new or empty directory used to create temporary files\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\          If specified, the temp dir will not be removed upon the task\\n\\\n-\\          completion and must be removed manually.\\n\\\n-\\          If not specified, a temporary directory will be created and\\n\\\n-\\          removed upon the task completion.\\n\\\n-\\  --vendor <vendor string>\\n\\\n-\\          Vendor of the application\\n\\\n-\\  --verbose\\n\\\n-\\          Enables verbose output\\n\\\n-\\  --version\\n\\\n-\\          Print the product version to the output stream and exit.\\n\\\n-\\n\\\n-\\Options for creating the runtime image:\\n\\\n-\\  --add-modules <module name>[,<module name>...]\\n\\\n-\\          A comma (\",\") separated list of modules to add\\n\\\n-\\          This module list, along with the main module (if specified)\\n\\\n-\\          will be passed to jlink as the --add-module argument.\\n\\\n-\\          If not specified, either just the main module (if --module is\\n\\\n-\\          specified), or the default set of modules (if --main-jar is \\n\\\n-\\          specified) are used.\\n\\\n-\\          This option can be used multiple times.\\n\\\n-\\  --module-path -p <module path>...\\n\\\n-\\          A {0} separated list of paths\\n\\\n-\\          Each path is either a directory of modules or the path to a\\n\\\n-\\          modular jar.\\n\\\n-\\          (Each path is absolute or relative to the current directory.)\\n\\\n-\\          This option can be used multiple times.\\n\\\n-\\  --jlink-options <jlink options> \\n\\\n-\\          A space separated list of options to pass to jlink \\n\\\n-\\          If not specified, defaults to \"--strip-native-commands \\n\\\n-\\          --strip-debug --no-man-pages --no-header-files\". \\n\\\n-\\          This option can be used multiple times.\\n\\\n-\\  --runtime-image <directory path>\\n\\\n-\\          Path of the predefined runtime image that will be copied into\\n\\\n-\\          the application image\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\          If --runtime-image is not specified, jpackage will run jlink to\\n\\\n-\\          create the runtime image using options:\\n\\\n-\\          --strip-debug, --no-header-files, --no-man-pages, and\\n\\\n-\\          --strip-native-commands.\\n\\\n-\\n\\\n-\\Options for creating the application image:\\n\\\n-\\  --input -i <directory path>\\n\\\n-\\          Path of the input directory that contains the files to be packaged\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\          All files in the input directory will be packaged into the\\n\\\n-\\          application image.\\n\\\n-\\  --app-content <additional content>[,<additional content>...]\\n\\\n-\\          A comma separated list of paths to files and\/or directories\\n\\\n-\\          to add to the application payload.\\n\\\n-\\          This option can be used more than once.\\n\\\n-\\n\\\n-\\Options for creating the application launcher(s):\\n\\\n-\\  --add-launcher <launcher name>=<file path>\\n\\\n-\\          Name of launcher, and a path to a Properties file that contains\\n\\\n-\\          a list of key, value pairs\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\          The keys \"module\", \"main-jar\", \"main-class\", \"description\",\\n\\\n-\\          \"arguments\", \"java-options\", \"app-version\", \"icon\",\\n\\\n-\\          \"launcher-as-service\",\\n\\\n-\\          \"win-console\", \"win-shortcut\", \"win-menu\",\\n\\\n-\\          \"linux-app-category\", and \"linux-shortcut\" can be used.\\n\\\n-\\          These options are added to, or used to overwrite, the original\\n\\\n-\\          command line options to build an additional alternative launcher.\\n\\\n-\\          The main application launcher will be built from the command line\\n\\\n-\\          options. Additional alternative launchers can be built using\\n\\\n-\\          this option, and this option can be used multiple times to\\n\\\n-\\          build multiple additional launchers. \\n\\\n-\\  --arguments <main class arguments>\\n\\\n-\\          Command line arguments to pass to the main class if no command\\n\\\n-\\          line arguments are given to the launcher\\n\\\n-\\          This option can be used multiple times.\\n\\\n-\\  --java-options <java options>\\n\\\n-\\          Options to pass to the Java runtime\\n\\\n-\\          This option can be used multiple times.\\n\\\n-\\  --main-class <class name>\\n\\\n-\\          Qualified name of the application main class to execute\\n\\\n-\\          This option can only be used if --main-jar is specified.\\n\\\n-\\  --main-jar <main jar file>\\n\\\n-\\          The main JAR of the application; containing the main class\\n\\\n-\\          (specified as a path relative to the input path)\\n\\\n-\\          Either --module or --main-jar option can be specified but not\\n\\\n-\\          both.\\n\\\n-\\  --module -m <module name>[\/<main class>]\\n\\\n-\\          The main module (and optionally main class) of the application\\n\\\n-\\          This module must be located on the module path.\\n\\\n-\\          When this option is specified, the main module will be linked\\n\\\n-\\          in the Java runtime image.  Either --module or --main-jar\\n\\\n-\\          option can be specified but not both.\\n\\\n-{2}\\n\\\n-\\Options for creating the application package:\\n\\\n-\\  --about-url <url>\\n\\\n-\\          URL of the application''s home page\\n\\\n-\\  --app-image <directory path>\\n\\\n-\\          {5}\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\  --file-associations <file path>\\n\\\n-\\          Path to a Properties file that contains list of key, value pairs\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\          The keys \"extension\", \"mime-type\", \"icon\", and \"description\"\\n\\\n-\\          can be used to describe the association.\\n\\\n-\\          This option can be used multiple times.\\n\\\n-\\  --install-dir <directory path>\\n\\\n-\\          {4}\\\n-\\  --license-file <file path>\\n\\\n-\\          Path to the license file\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\  --resource-dir <directory path>\\n\\\n-\\          Path to override jpackage resources\\n\\\n-\\          Icons, template files, and other resources of jpackage can be\\n\\\n-\\          over-ridden by adding replacement resources to this directory.\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\  --runtime-image <directory path>\\n\\\n-\\          Path of the predefined runtime image to install\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\          Option is required when creating a runtime package.\\n\\\n-\\  --launcher-as-service\\n\\\n-\\          Request to create an installer that will register the main\\n\\\n-\\          application launcher as a background service-type application.\\n\\\n-\\n\\\n-\\Platform dependent options for creating the application package:\\n\\\n-{3}\n+MSG_Help=Verwendung: jpackage <Optionen>\\n\\nBeispielverwendungen:\\n--------------\\n    Generiert ein f\\u00FCr das Hostsystem geeignetes Anwendungspackage:\\n        F\\u00FCr eine modulare Anwendung:\\n            jpackage -n name -p modulePath -m moduleName\/className\\n        F\\u00FCr eine nicht modulare Anwendung:\\n            jpackage -i inputDir -n name \\\\\\n                --main-class className --main-jar myJar.jar\\n        Aus einem vorab erstellten Anwendungsimage:\\n            jpackage -n name --app-image appImageDir\\n    Generiert ein Anwendungsimage:\\n        F\\u00FCr eine modulare Anwendung:\\n            jpackage --type app-image -n name -p modulePath \\\\\\n                -m moduleName\/className\\n        F\\u00FCr eine nicht modulare Anwendung:\\n            jpackage --type app-image -i inputDir -n name \\\\\\n                --main-class className --main-jar myJar.jar\\n        Um eigene Optionen f\\u00FCr jlink anzugeben, f\\u00FChren Sie jlink separat aus:\\n            jlink --output appRuntimeImage -p modulePath \\\\\\n                --add-modules moduleName \\\\\\n                --no-header-files [<zus\\u00E4tzliche jlink-Optionen>...]\\n            jpackage --type app-image -n name \\\\\\n                -m moduleName\/className --runtime-image appRuntimeImage\\n    Generiert ein Java Runtime-Package:\\n        jpackage -n name --runtime-image <Laufzeitimage>\\n\\nAllgemeine Optionen:\\n  @<Dateiname > \\n          Liest Optionen und\/oder Modus aus einer Datei \\n          Diese Option kann mehrmals verwendet werden.\\n  --type -t <Typ> \\n          Der zu erstellende Packagetyp\\n          G\\u00FCltige Werte: {1} \\n          Bei fehlender Angabe dieser Option wird ein plattformabh\\u00E4ngiger\\n          Standardtyp erstellt.\\n  --app-version <Version>\\n          Version der Anwendung und\/oder des Packages\\n  --copyright <Copyright-Zeichenfolge>\\n          Copyright f\\u00FCr die Anwendung\\n  --description <Zeichenfolge f\\u00FCr Beschreibung>\\n          Beschreibung der Anwendung\\n  --help -h \\n          Gibt den Verwendungstext mit einer Liste und Beschreibung jeder g\\u00FCltigen\\n          Option f\\u00FCr die aktuelle Plattform an den Ausgabestream aus und beendet den Vorgang\\n  --icon <Dateipfad>\\n          Pfad des Symbols f\\u00FCr das Anwendungspackage\\n          (absoluter Pfad oder relativ zum aktuellen Verzeichnis)\\n  --name -n <Name>\\n          Name der Anwendung und\/oder des Packages\\n  --dest -d <Zielpfad>\\n          Pfad, in den die generierte Ausgabedatei abgelegt wird\\n          (absoluter Pfad oder relativ zum aktuellen Verzeichnis)\\n          Standardm\\u00E4\\u00DFig wird das aktuelle Arbeitsverzeichnis verwendet.\\n  --temp <Verzeichnispfad>\\n          Pfad eines neuen oder leeren Verzeichnisses zum Erstellen tempor\\u00E4rer Dateien\\n          (absoluter Pfad oder relativ zum aktuellen Verzeichnis)\\n          Falls angegeben, wird das tempor\\u00E4re Verzeichnis beim Abschlie\\u00DFen der Aufgabe\\n          nicht entfernt und muss manuell entfernt werden.\\n          Bei fehlender Angabe wird ein tempor\\u00E4res Verzeichnis erstellt und\\n          beim Abschlie\\u00DFen der Aufgabe entfernt.\\n  --vendor <Zeichenfolge f\\u00FCr Anbieter>\\n          Anbieter der Anwendung\\n  --verbose\\n          Aktiviert Ausgabe im Verbose-Modus\\n  --version\\n          Gibt die Produktversion an den Outputstream aus und beendet den Vorgang.\\n\\nOptionen f\\u00FCr das Erstellen des Laufzeitimages:\\n  --add-modules <Modulname>[,<Modulname>...]\\n          Eine per Komma (\",\") getrennte Liste hinzuzuf\\u00FCgender Module\\n          Diese Modulliste wird zusammen mit dem Hauptmodul (sofern angegeben)\\n          als Argument --add-module an jlink \\u00FCbergeben.\\n          Bei fehlender Angabe wird entweder nur das Hauptmodul (sofern --module\\n          angegeben ist) oder das Standardset an Modulen (sofern --main-jar \\n          angegeben ist) verwendet.\\n          Diese Option kann mehrmals verwendet werden.\\n  --module-path -p <Modulpfad>...\\n          \\\n+Eine per {0} getrennte Pfadliste\\n          Jeder Pfad ist entweder ein Verzeichnis mit Modulen oder der Pfad zu einer\\n          JAR-Datei eines Moduls.\\n          (Jeder Pfad ist absolut oder relativ zum aktuellen Verzeichnis.)\\n          Diese Option kann mehrmals verwendet werden.\\n  --jlink-options <jlink-Optionen> \\n          Eine per Leerzeichen getrennte Liste mit an jlink zu \\u00FCbergebenden Optionen \\n          Bei fehlender Angabe wird standardm\\u00E4\\u00DFig \"--strip-native-commands \\n          --strip-debug --no-man-pages --no-header-files\" verwendet. \\n          Diese Option kann mehrmals verwendet werden.\\n  --runtime-image <Verzeichnispfad>\\n          Pfad des vordefinierten Laufzeitimages, das in\\n          das Anwendungsimage kopiert wird\\n          (absoluter Pfad oder relativ zum aktuellen Verzeichnis)\\n          Wenn --runtime-image nicht angegeben wird, f\\u00FChrt jpackage jlink aus, um\\n          das Laufzeitimage mit folgenden Optionen zu erstellen:\\n          --strip-debug, --no-header-files, --no-man-pages und\\n          --strip-native-commands.\\n\\nOptionen f\\u00FCr das Erstellen des Anwendungsimages:\\n  --input -i <Verzeichnispfad>\\n          Pfad des Eingabeverzeichnisses mit den in das Package zu integrierenden Dateien\\n          (absoluter Pfad oder relativ zum aktuellen Verzeichnis)\\n          Alle Dateien im Eingabeverzeichnis werden in das Package f\\u00FCr das\\n          Anwendungsimage integriert.\\n  --app-content <zus\\u00E4tzlicher Inhalt>[,<zus\\u00E4tzlicher Inhalt>...]\\n          Eine per Komma getrennte Liste mit Pfaden zu Dateien und\/oder Verzeichnissen,\\n          die zur Anwendungs-Payload hinzugef\\u00FCgt werden sollen.\\n          Diese Option kann mehrmals verwendet werden.\\n\\nOptionen f\\u00FCr das Erstellen des Anwendungs-Launchers:\\n  --add-launcher <Launcher-Name>=<Dateipfad>\\n          Name des Launchers sowie ein Pfad zu einer Eigenschaftendatei mit\\n          einer Liste von Schl\\u00FCssel\/Wert-Paaren\\n          (absoluter Pfad oder relativ zum aktuellen Verzeichnis)\\n          Die Schl\\u00FCssel \"module\", \"main-jar\", \"main-class\", \"description\",\\n          \"arguments\", \"java-options\", \"app-version\", \"icon\",\\n          \"win-console\", \"win-shortcut\", \"win-menu\",\\n          \"linux-app-category\" und \"linux-shortcut\" k\\u00F6nnen verwendet werden.\\n          Diese Optionen werden den urspr\\u00FCnglichen Befehlszeilenoptionen hinzugef\\u00FCgt\\n          (oder \\u00FCberschreiben diese), um einen zus\\u00E4tzlichen, alternativen Launcher zu erstellen.\\n          Der Hauptanwendungs-Launcher wird aus den Befehlszeilenoptionen\\n          erstellt. Mit dieser Option k\\u00F6nnen zus\\u00E4tzliche alternative Launcher\\n          erstellt werden. Au\\u00DFerdem kann diese Option mehrmals verwendet werden,\\n          um mehrere zus\\u00E4tzliche Launcher zu erstellen. \\n  --arguments <Hauptklassenargumente>\\n          Befehlszeilenargumente, die an die Hauptklasse \\u00FCbergeben werden, falls\\n          keine Befehlszeilenargumente an den Launcher \\u00FCbergeben werden\\n          Diese Option kann mehrmals verwendet werden.\\n  --java-options <Java-Optionen>\\n          Optionen, die an Java Runtime \\u00FCbergeben werden\\n          Diese Option kann mehrmals verwendet werden.\\n  --main-class <Klassenname>\\n          Qualifizierter Name der auszuf\\u00FChrenden Anwendungshauptklasse\\n          Diese Option kann nur bei Angabe von --main-jar verwendet werden.\\n  --main-jar <Haupt-JAR-Datei>\\n          Die Haupt-JAR-Datei der Anwendung, die die Hauptklasse enth\\u00E4lt\\n          (angegeben als Pfad relativ zum Eingabepfad)\\n          Es kann entweder die Option --module oder die Option --main-jar angegeben werden, nicht jedoch\\n          beides.\\n  --module -m <Modulname>[\/<Hauptklasse>]\\n          Das Hauptmodul (und optional die Hauptklasse) der Anwendung\\n          Dieses Modul muss unter dem Modulpfad gespeichert sein.\\n          Bei Angabe dieser Option wird das Hauptmodul\\n          im Java \\\n+Runtime-Image verkn\\u00FCpft. Es kann entweder die Option --module oder die Option --main-jar\\n          angegeben werden, nicht jedoch beides.\\n{2}\\nOptionen f\\u00FCr das Erstellen des Anwendungspackages:\\n  --about-url <URL>\\n          URL der Homepage der Anwendung\\n  --app-image <Verzeichnispfad>\\n          Speicherort des vordefinierten Anwendungsimages, mit dem\\n          ein installierbares Package erstellt wird\\n          (absoluter Pfad oder relativ zum aktuellen Verzeichnis)\\n  --file-associations <Dateipfad>\\n          Pfad zu einer Eigenschaftendatei mit einer Liste von Schl\\u00FCssel\/Wert-Paaren\\n          (absoluter Pfad oder relativ zum aktuellen Verzeichnis)\\n          Mit den Schl\\u00FCsseln \"extension\", \"mime-type\", \"icon\" und \"description\"\\n          kann die Verkn\\u00FCpfung beschrieben werden.\\n          Diese Option kann mehrmals verwendet werden.\\n  --install-dir <Verzeichnispfad>\\n          {4}  --license-file <Dateipfad>\\n          Pfad zur Lizenzdatei\\n          (absoluter Pfad oder relativ zum aktuellen Verzeichnis)\\n  --resource-dir <Verzeichnispfad>\\n          Pfad zum \\u00DCberschreiben von jpackage-Ressourcen\\n          Symbole, Vorlagendateien und weitere Ressourcen von jpackage k\\u00F6nnen\\n          durch Hinzuf\\u00FCgen von Ersetzungsressourcen zu diesem Verzeichnis \\u00FCberschrieben werden.\\n          (absoluter Pfad oder relativ zum aktuellen Verzeichnis)\\n  --runtime-image <Verzeichnispfad>\\n          Pfad des zu installierenden vordefinierten Laufzeitimages\\n          (absoluter Pfad oder relativ zum aktuellen Verzeichnis)\\n          Option muss beim Erstellen eines Laufzeitpackages angegeben werden.\\n\\nPlattformabh\\u00E4ngige Optionen f\\u00FCr das Erstellen des Anwendungspackages:\\n{3}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/HelpResources_de.properties","additions":4,"deletions":181,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -27,180 +27,5 @@\n-MSG_Help=Usage: jpackage <options>\\n\\\n-\\n\\\n-Sample usages:\\n\\\n---------------\\n\\\n-\\    Generate an application package suitable for the host system:\\n\\\n-\\        For a modular application:\\n\\\n-\\            jpackage -n name -p modulePath -m moduleName\/className\\n\\\n-\\        For a non-modular application:\\n\\\n-\\            jpackage -i inputDir -n name \\\\\\n\\\n-\\                --main-class className --main-jar myJar.jar\\n\\\n-\\        From a pre-built application image:\\n\\\n-\\            jpackage -n name --app-image appImageDir\\n\\\n-\\    Generate an application image:\\n\\\n-\\        For a modular application:\\n\\\n-\\            jpackage --type app-image -n name -p modulePath \\\\\\n\\\n-\\                -m moduleName\/className\\n\\\n-\\        For a non-modular application:\\n\\\n-\\            jpackage --type app-image -i inputDir -n name \\\\\\n\\\n-\\                --main-class className --main-jar myJar.jar\\n\\\n-\\        To provide your own options to jlink, run jlink separately:\\n\\\n-\\            jlink --output appRuntimeImage -p modulePath \\\\\\n\\\n-\\                --add-modules moduleName \\\\\\n\\\n-\\                --no-header-files [<additional jlink options>...]\\n\\\n-\\            jpackage --type app-image -n name \\\\\\n\\\n-\\                -m moduleName\/className --runtime-image appRuntimeImage\\n\\\n-\\    Generate a Java runtime package:\\n\\\n-\\        jpackage -n name --runtime-image <runtime-image>\\n\\\n-\\{6}\\\n-\\n\\\n-Generic Options:\\n\\\n-\\  @<filename> \\n\\\n-\\          Read options and\/or mode from a file \\n\\\n-\\          This option can be used multiple times.\\n\\\n-\\  --type -t <type> \\n\\\n-\\          The type of package to create\\n\\\n-\\          Valid values are: {1} \\n\\\n-\\          If this option is not specified a platform dependent\\n\\\n-\\          default type will be created.\\n\\\n-\\  --app-version <version>\\n\\\n-\\          Version of the application and\/or package\\n\\\n-\\  --copyright <copyright string>\\n\\\n-\\          Copyright for the application\\n\\\n-\\  --description <description string>\\n\\\n-\\          Description of the application\\n\\\n-\\  --help -h \\n\\\n-\\          Print the usage text with a list and description of each valid\\n\\\n-\\          option for the current platform to the output stream, and exit\\n\\\n-\\  --icon <file path>\\n\\\n-\\          Path of the icon of the application package\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\  --name -n <name>\\n\\\n-\\          Name of the application and\/or package\\n\\\n-\\  --dest -d <destination path>\\n\\\n-\\          Path where generated output file is placed\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\          Defaults to the current working directory.\\n\\\n-\\  --temp <directory path>\\n\\\n-\\          Path of a new or empty directory used to create temporary files\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\          If specified, the temp dir will not be removed upon the task\\n\\\n-\\          completion and must be removed manually.\\n\\\n-\\          If not specified, a temporary directory will be created and\\n\\\n-\\          removed upon the task completion.\\n\\\n-\\  --vendor <vendor string>\\n\\\n-\\          Vendor of the application\\n\\\n-\\  --verbose\\n\\\n-\\          Enables verbose output\\n\\\n-\\  --version\\n\\\n-\\          Print the product version to the output stream and exit.\\n\\\n-\\n\\\n-\\Options for creating the runtime image:\\n\\\n-\\  --add-modules <module name>[,<module name>...]\\n\\\n-\\          A comma (\",\") separated list of modules to add\\n\\\n-\\          This module list, along with the main module (if specified)\\n\\\n-\\          will be passed to jlink as the --add-module argument.\\n\\\n-\\          If not specified, either just the main module (if --module is\\n\\\n-\\          specified), or the default set of modules (if --main-jar is \\n\\\n-\\          specified) are used.\\n\\\n-\\          This option can be used multiple times.\\n\\\n-\\  --module-path -p <module path>...\\n\\\n-\\          A {0} separated list of paths\\n\\\n-\\          Each path is either a directory of modules or the path to a\\n\\\n-\\          modular jar.\\n\\\n-\\          (Each path is absolute or relative to the current directory.)\\n\\\n-\\          This option can be used multiple times.\\n\\\n-\\  --jlink-options <jlink options> \\n\\\n-\\          A space separated list of options to pass to jlink \\n\\\n-\\          If not specified, defaults to \"--strip-native-commands \\n\\\n-\\          --strip-debug --no-man-pages --no-header-files\". \\n\\\n-\\          This option can be used multiple times.\\n\\\n-\\  --runtime-image <directory path>\\n\\\n-\\          Path of the predefined runtime image that will be copied into\\n\\\n-\\          the application image\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\          If --runtime-image is not specified, jpackage will run jlink to\\n\\\n-\\          create the runtime image using options:\\n\\\n-\\          --strip-debug, --no-header-files, --no-man-pages, and\\n\\\n-\\          --strip-native-commands.\\n\\\n-\\n\\\n-\\Options for creating the application image:\\n\\\n-\\  --input -i <directory path>\\n\\\n-\\          Path of the input directory that contains the files to be packaged\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\          All files in the input directory will be packaged into the\\n\\\n-\\          application image.\\n\\\n-\\  --app-content <additional content>[,<additional content>...]\\n\\\n-\\          A comma separated list of paths to files and\/or directories\\n\\\n-\\          to add to the application payload.\\n\\\n-\\          This option can be used more than once.\\n\\\n-\\n\\\n-\\Options for creating the application launcher(s):\\n\\\n-\\  --add-launcher <launcher name>=<file path>\\n\\\n-\\          Name of launcher, and a path to a Properties file that contains\\n\\\n-\\          a list of key, value pairs\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\          The keys \"module\", \"main-jar\", \"main-class\", \"description\",\\n\\\n-\\          \"arguments\", \"java-options\", \"app-version\", \"icon\",\\n\\\n-\\          \"launcher-as-service\",\\n\\\n-\\          \"win-console\", \"win-shortcut\", \"win-menu\",\\n\\\n-\\          \"linux-app-category\", and \"linux-shortcut\" can be used.\\n\\\n-\\          These options are added to, or used to overwrite, the original\\n\\\n-\\          command line options to build an additional alternative launcher.\\n\\\n-\\          The main application launcher will be built from the command line\\n\\\n-\\          options. Additional alternative launchers can be built using\\n\\\n-\\          this option, and this option can be used multiple times to\\n\\\n-\\          build multiple additional launchers. \\n\\\n-\\  --arguments <main class arguments>\\n\\\n-\\          Command line arguments to pass to the main class if no command\\n\\\n-\\          line arguments are given to the launcher\\n\\\n-\\          This option can be used multiple times.\\n\\\n-\\  --java-options <java options>\\n\\\n-\\          Options to pass to the Java runtime\\n\\\n-\\          This option can be used multiple times.\\n\\\n-\\  --main-class <class name>\\n\\\n-\\          Qualified name of the application main class to execute\\n\\\n-\\          This option can only be used if --main-jar is specified.\\n\\\n-\\  --main-jar <main jar file>\\n\\\n-\\          The main JAR of the application; containing the main class\\n\\\n-\\          (specified as a path relative to the input path)\\n\\\n-\\          Either --module or --main-jar option can be specified but not\\n\\\n-\\          both.\\n\\\n-\\  --module -m <module name>[\/<main class>]\\n\\\n-\\          The main module (and optionally main class) of the application\\n\\\n-\\          This module must be located on the module path.\\n\\\n-\\          When this option is specified, the main module will be linked\\n\\\n-\\          in the Java runtime image.  Either --module or --main-jar\\n\\\n-\\          option can be specified but not both.\\n\\\n-{2}\\n\\\n-\\Options for creating the application package:\\n\\\n-\\  --about-url <url>\\n\\\n-\\          URL of the application''s home page\\n\\\n-\\  --app-image <directory path>\\n\\\n-\\          {5}\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\  --file-associations <file path>\\n\\\n-\\          Path to a Properties file that contains list of key, value pairs\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\          The keys \"extension\", \"mime-type\", \"icon\", and \"description\"\\n\\\n-\\          can be used to describe the association.\\n\\\n-\\          This option can be used multiple times.\\n\\\n-\\  --install-dir <directory path>\\n\\\n-\\          {4}\\\n-\\  --license-file <file path>\\n\\\n-\\          Path to the license file\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\  --resource-dir <directory path>\\n\\\n-\\          Path to override jpackage resources\\n\\\n-\\          Icons, template files, and other resources of jpackage can be\\n\\\n-\\          over-ridden by adding replacement resources to this directory.\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\  --runtime-image <directory path>\\n\\\n-\\          Path of the predefined runtime image to install\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\          Option is required when creating a runtime package.\\n\\\n-\\  --launcher-as-service\\n\\\n-\\          Request to create an installer that will register the main\\n\\\n-\\          application launcher as a background service-type application.\\n\\\n-\\n\\\n-\\Platform dependent options for creating the application package:\\n\\\n-{3}\n+MSG_Help=\\u4F7F\\u7528\\u65B9\\u6CD5: jpackage <options>\\n\\n\\u4F7F\\u7528\\u4F8B:\\n--------------\\n    \\u30DB\\u30B9\\u30C8\\u30FB\\u30B7\\u30B9\\u30C6\\u30E0\\u306B\\u9069\\u3057\\u305F\\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u30FB\\u30D1\\u30C3\\u30B1\\u30FC\\u30B8\\u3092\\u751F\\u6210\\u3057\\u307E\\u3059\\u3002\\n        \\u30E2\\u30B8\\u30E5\\u30E9\\u30FB\\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u306E\\u5834\\u5408:\\n            jpackage -n name -p modulePath -m moduleName\/className\\n        \\u975E\\u30E2\\u30B8\\u30E5\\u30E9\\u30FB\\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u306E\\u5834\\u5408:\\n            jpackage -i inputDir -n name \\\\\\n                --main-class className --main-jar myJar.jar\\n        \\u4E8B\\u524D\\u4F5C\\u6210\\u3055\\u308C\\u305F\\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u30FB\\u30A4\\u30E1\\u30FC\\u30B8\\u304B\\u3089:\\n            jpackage -n name --app-image appImageDir\\n    \\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u30FB\\u30A4\\u30E1\\u30FC\\u30B8\\u306E\\u751F\\u6210:\\n        \\u30E2\\u30B8\\u30E5\\u30E9\\u30FB\\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u306E\\u5834\\u5408:\\n            jpackage --type app-image -n name -p modulePath \\\\\\n                -m moduleName\/className\\n        \\u975E\\u30E2\\u30B8\\u30E5\\u30E9\\u30FB\\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u306E\\u5834\\u5408:\\n            jpackage --type app-image -i inputDir -n name \\\\\\n                --main-class className --main-jar myJar.jar\\n        jlink\\u306B\\u72EC\\u81EA\\u306E\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u3092\\u6307\\u5B9A\\u3059\\u308B\\u306B\\u306F\\u3001jlink\\u3092\\u5225\\u500B\\u306B\\u5B9F\\u884C\\u3057\\u307E\\u3059\\u3002\\n            jlink --output appRuntimeImage -p modulePath \\\\\\n                --add-modules moduleName \\\\\\n                --no-header-files [<additional jlink options>...]\\n            jpackage --type app-image -n name \\\\\\n                -m moduleName\/className --runtime-image appRuntimeImage\\n    Java\\u30E9\\u30F3\\u30BF\\u30A4\\u30E0\\u30FB\\u30D1\\u30C3\\u30B1\\u30FC\\u30B8\\u3092\\u751F\\u6210\\u3057\\u307E\\u3059\\u3002\\n        jpackage -n name --runtime-image <runtime-image>\\n\\n\\u4E00\\u822C\\u7684\\u306A\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3:\\n  @<filename> \\n          \\u30D5\\u30A1\\u30A4\\u30EB\\u304B\\u3089\\u306E\\u8AAD\\u53D6\\u308A\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u304A\\u3088\\u3073\\u30E2\\u30FC\\u30C9 \\n          \\u3053\\u306E\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u306F\\u8907\\u6570\\u56DE\\u4F7F\\u7528\\u3067\\u304D\\u307E\\u3059\\u3002\\n  --type -t <type> \\n          \\u4F5C\\u6210\\u3059\\u308B\\u30D1\\u30C3\\u30B1\\u30FC\\u30B8\\u306E\\u30BF\\u30A4\\u30D7\\n          \\u6709\\u52B9\\u306A\\u5024: {1} \\n          \\u3053\\u306E\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u304C\\u6307\\u5B9A\\u3055\\u308C\\u3066\\u3044\\u306A\\u3044\\u5834\\u5408\\u3001\\u30D7\\u30E9\\u30C3\\u30C8\\u30D5\\u30A9\\u30FC\\u30E0\\u4F9D\\u5B58\\u306E\\n          \\u30C7\\u30D5\\u30A9\\u30EB\\u30C8\\u30FB\\u30BF\\u30A4\\u30D7\\u304C\\u4F5C\\u6210\\u3055\\u308C\\u307E\\u3059\\n  --app-version <version>\\n          \\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u304A\\u3088\\u3073\\u30D1\\u30C3\\u30B1\\u30FC\\u30B8\\u306E\\u30D0\\u30FC\\u30B8\\u30E7\\u30F3\\n  --copyright <copyright string>\\n          \\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u306E\\u30B3\\u30D4\\u30FC\\u30E9\\u30A4\\u30C8\\n  --description <description string>\\n          \\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u306E\\u8AAC\\u660E\\n  --help -h \\n          \\u4F7F\\u7528\\u65B9\\u6CD5\\u30C6\\u30AD\\u30B9\\u30C8\\u3068\\u73FE\\u5728\\u306E\\u30D7\\u30E9\\u30C3\\u30C8\\u30D5\\u30A9\\u30FC\\u30E0\\u306E\\u6709\\u52B9\\u306A\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u306E\\u30EA\\u30B9\\u30C8\\u3068\\u8AAC\\u660E\\u3092\\n          \\u51FA\\u529B\\u30B9\\u30C8\\u30EA\\u30FC\\u30E0\\u306B\\u51FA\\u529B\\u3057\\u3066\\u3001\\u7D42\\u4E86\\u3057\\u307E\\u3059\\n  --icon <file path>\\n          \\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u30FB\\u30D1\\u30C3\\u30B1\\u30FC\\u30B8\\u306E\\u30A2\\u30A4\\u30B3\\u30F3\\u306E\\u30D1\\u30B9\\n          (\\u7D76\\u5BFE\\u30D1\\u30B9\\u307E\\u305F\\u306F\\u73FE\\u5728\\u306E\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA\\u304B\\u3089\\u306E\\u76F8\\u5BFE\\u30D1\\u30B9)\\n  --name \\\n+-n <name>\\n          \\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u304A\\u3088\\u3073\\u30D1\\u30C3\\u30B1\\u30FC\\u30B8\\u306E\\u540D\\u524D\\n  --dest -d <destination path>\\n          \\u751F\\u6210\\u3055\\u308C\\u305F\\u51FA\\u529B\\u30D5\\u30A1\\u30A4\\u30EB\\u304C\\u914D\\u7F6E\\u3055\\u308C\\u308B\\u30D1\\u30B9\\n          (\\u7D76\\u5BFE\\u30D1\\u30B9\\u307E\\u305F\\u306F\\u73FE\\u5728\\u306E\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA\\u304B\\u3089\\u306E\\u76F8\\u5BFE\\u30D1\\u30B9)\\n          \\u30C7\\u30D5\\u30A9\\u30EB\\u30C8\\u306F\\u73FE\\u5728\\u306E\\u4F5C\\u696D\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA\\u3067\\u3059\\u3002\\n  --temp <directory path>\\n          \\u4E00\\u6642\\u30D5\\u30A1\\u30A4\\u30EB\\u306E\\u4F5C\\u6210\\u306B\\u4F7F\\u7528\\u3055\\u308C\\u308B\\u65B0\\u898F\\u307E\\u305F\\u306F\\u7A7A\\u306E\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA\\u306E\\u30D1\\u30B9\\n          (\\u7D76\\u5BFE\\u30D1\\u30B9\\u307E\\u305F\\u306F\\u73FE\\u5728\\u306E\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA\\u304B\\u3089\\u306E\\u76F8\\u5BFE\\u30D1\\u30B9)\\n          \\u6307\\u5B9A\\u3057\\u305F\\u5834\\u5408\\u3001\\u30BF\\u30B9\\u30AF\\u5B8C\\u4E86\\u6642\\u306B\\u4E00\\u6642\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA\\u306F\\u524A\\u9664\\u3055\\u308C\\u306A\\u3044\\u305F\\u3081\\n          \\u624B\\u52D5\\u3067\\u524A\\u9664\\u3059\\u308B\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059\\n          \\u6307\\u5B9A\\u3057\\u306A\\u304B\\u3063\\u305F\\u5834\\u5408\\u3001\\u4E00\\u6642\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA\\u304C\\u4F5C\\u6210\\u3055\\u308C\\n          \\u30BF\\u30B9\\u30AF\\u5B8C\\u4E86\\u6642\\u306B\\u524A\\u9664\\u3055\\u308C\\u307E\\u3059\\u3002\\n  --vendor <vendor string>\\n          \\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u306E\\u30D9\\u30F3\\u30C0\\u30FC\\n  --verbose\\n          \\u8A73\\u7D30\\u306A\\u51FA\\u529B\\u3092\\u6709\\u52B9\\u306B\\u3057\\u307E\\u3059\\n  --version\\n          \\u88FD\\u54C1\\u30D0\\u30FC\\u30B8\\u30E7\\u30F3\\u3092\\u51FA\\u529B\\u30B9\\u30C8\\u30EA\\u30FC\\u30E0\\u306B\\u51FA\\u529B\\u3057\\u3066\\u7D42\\u4E86\\u3057\\u307E\\u3059\\n\\n\\u30E9\\u30F3\\u30BF\\u30A4\\u30E0\\u30FB\\u30A4\\u30E1\\u30FC\\u30B8\\u3092\\u4F5C\\u6210\\u3059\\u308B\\u305F\\u3081\\u306E\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3:\\n  --add-modules <module name>[,<module name>...]\\n          \\u8FFD\\u52A0\\u3059\\u308B\\u30E2\\u30B8\\u30E5\\u30FC\\u30EB\\u306E\\u30AB\\u30F3\\u30DE(\",\")\\u533A\\u5207\\u308A\\u30EA\\u30B9\\u30C8\\n          \\u3053\\u306E\\u30E2\\u30B8\\u30E5\\u30FC\\u30EB\\u30FB\\u30EA\\u30B9\\u30C8\\u3068\\u30E1\\u30A4\\u30F3\\u30FB\\u30E2\\u30B8\\u30E5\\u30FC\\u30EB(\\u6307\\u5B9A\\u3057\\u305F\\u5834\\u5408)\\n          \\u304C--add-module\\u5F15\\u6570\\u3068\\u3057\\u3066jlink\\u306B\\u6E21\\u3055\\u308C\\u307E\\u3059\\u3002\\n          \\u6307\\u5B9A\\u3057\\u306A\\u304B\\u3063\\u305F\\u5834\\u5408\\u3001\\u30E1\\u30A4\\u30F3\\u30FB\\u30E2\\u30B8\\u30E5\\u30FC\\u30EB\\u306E\\u307F(--module\\u304C\\n          \\u6307\\u5B9A\\u3055\\u308C\\u305F\\u5834\\u5408)\\u3001\\u307E\\u305F\\u306F\\u30C7\\u30D5\\u30A9\\u30EB\\u30C8\\u306E\\u30E2\\u30B8\\u30E5\\u30FC\\u30EB\\u30FB\\u30BB\\u30C3\\u30C8(--main-jar\\u304C \\n          \\u6307\\u5B9A\\u3055\\u308C\\u305F\\u5834\\u5408)\\u304C\\u4F7F\\u7528\\u3055\\u308C\\u307E\\u3059\\u3002\\n          \\u3053\\u306E\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u306F\\u8907\\u6570\\u56DE\\u4F7F\\u7528\\u3067\\u304D\\u307E\\u3059\\u3002\\n  --module-path -p <module path>...\\n          \\u30D1\\u30B9\\u306E{0}\\u533A\\u5207\\u308A\\u30EA\\u30B9\\u30C8\\n          \\u5404\\u30D1\\u30B9\\u306F\\u3001\\u30E2\\u30B8\\u30E5\\u30FC\\u30EB\\u306E\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA\\u307E\\u305F\\u306F\\n          \\u30E2\\u30B8\\u30E5\\u30E9jar\\u3078\\u306E\\u30D1\\u30B9\\u3067\\u3059\\u3002\\n          (\\u5404\\u30D1\\u30B9\\u306F\\u3001\\u7D76\\u5BFE\\u30D1\\u30B9\\u307E\\u305F\\u306F\\u73FE\\u5728\\u306E\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA\\u304B\\u3089\\u306E\\u76F8\\u5BFE\\u30D1\\u30B9\\u3067\\u3059\\u3002)\\n          \\u3053\\u306E\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u306F\\u8907\\u6570\\u56DE\\u4F7F\\u7528\\u3067\\u304D\\u307E\\u3059\\u3002\\n  --jlink-options <jlink options> \\n          jlink\\u306B\\u6E21\\u3059\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u306E\\u30B9\\u30DA\\u30FC\\u30B9\\u533A\\u5207\\u308A\\u306E\\u30EA\\u30B9\\u30C8 \\n          \\u6307\\u5B9A\\u3057\\u306A\\u3044\\u5834\\u5408\\u3001\"--strip-native-commands \\n          --strip-debug --no-man-pages \\\n+--no-header-files\"\\u3002 \\n          \\u3053\\u306E\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u306F\\u8907\\u6570\\u56DE\\u4F7F\\u7528\\u3067\\u304D\\u307E\\u3059\\u3002\\n  --runtime-image <directory path>\\n          \\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u30FB\\u30A4\\u30E1\\u30FC\\u30B8\\u306B\\u30B3\\u30D4\\u30FC\\u3055\\u308C\\u308B\\u3001\\u4E8B\\u524D\\u5B9A\\u7FA9\\u6E08\\u307F\\u306E\\u30E9\\u30F3\\u30BF\\u30A4\\u30E0\\u30FB\\u30A4\\u30E1\\u30FC\\u30B8\\n          \\u306E\\u30D1\\u30B9\\n          (\\u7D76\\u5BFE\\u30D1\\u30B9\\u307E\\u305F\\u306F\\u73FE\\u5728\\u306E\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA\\u304B\\u3089\\u306E\\u76F8\\u5BFE\\u30D1\\u30B9)\\n          --runtime-image\\u304C\\u6307\\u5B9A\\u3055\\u308C\\u3066\\u3044\\u306A\\u3044\\u5834\\u5408\\u3001jpackage\\u306Fjlink\\u3092\\u5B9F\\u884C\\u3057\\u3001\\n          \\u6B21\\u306E\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u3092\\u4F7F\\u7528\\u3057\\u3066\\u30E9\\u30F3\\u30BF\\u30A4\\u30E0\\u30FB\\u30A4\\u30E1\\u30FC\\u30B8\\u3092\\u4F5C\\u6210\\u3057\\u307E\\u3059:\\n          --strip-debug\\u3001--no-header-files\\u3001--no-man-pages\\u304A\\u3088\\u3073\\n          --strip-native-commands\\u3002\\n\\n\\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u30FB\\u30A4\\u30E1\\u30FC\\u30B8\\u3092\\u4F5C\\u6210\\u3059\\u308B\\u305F\\u3081\\u306E\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3:\\n  --input -i <directory path>\\n          \\u30D1\\u30C3\\u30B1\\u30FC\\u30B8\\u5316\\u3059\\u308B\\u30D5\\u30A1\\u30A4\\u30EB\\u3092\\u542B\\u3080\\u5165\\u529B\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA\\u3078\\u306E\\u30D1\\u30B9\\n          (\\u7D76\\u5BFE\\u30D1\\u30B9\\u307E\\u305F\\u306F\\u73FE\\u5728\\u306E\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA\\u304B\\u3089\\u306E\\u76F8\\u5BFE\\u30D1\\u30B9)\\n          \\u5165\\u529B\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA\\u306E\\u3059\\u3079\\u3066\\u306E\\u30D5\\u30A1\\u30A4\\u30EB\\u306F\\u3001\\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u30FB\\u30A4\\u30E1\\u30FC\\u30B8\\u306B\\n          \\u30D1\\u30C3\\u30B1\\u30FC\\u30B8\\u5316\\u3055\\u308C\\u307E\\u3059\\u3002\\n  --app-content <additional content>[,<additional content>...]\\n          \\u30D5\\u30A1\\u30A4\\u30EB\\u307E\\u305F\\u306F\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA(\\u3042\\u308B\\u3044\\u306F\\u4E21\\u65B9)\\u306E\\u30D1\\u30B9\\u306E\\u30AB\\u30F3\\u30DE\\u533A\\u5207\\u308A\\u306E\\u30EA\\u30B9\\u30C8\\n          \\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u30FB\\u30DA\\u30A4\\u30ED\\u30FC\\u30C9\\u306B\\u8FFD\\u52A0\\u3057\\u307E\\u3059\\u3002\\n          \\u3053\\u306E\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u306F\\u8907\\u6570\\u56DE\\u4F7F\\u7528\\u3067\\u304D\\u307E\\u3059\\u3002\\n\\n\\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u30FB\\u30E9\\u30F3\\u30C1\\u30E3\\u3092\\u4F5C\\u6210\\u3059\\u308B\\u305F\\u3081\\u306E\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3:\\n  --add-launcher <launcher name>=<file path>\\n          \\u30E9\\u30F3\\u30C1\\u30E3\\u306E\\u540D\\u524D\\u3001\\u304A\\u3088\\u3073\\u30AD\\u30FC\\u3001\\u5024\\u306E\\u30DA\\u30A2\\u306E\\u30EA\\u30B9\\u30C8\\n          \\u3092\\u542B\\u3080\\u30D7\\u30ED\\u30D1\\u30C6\\u30A3\\u30FB\\u30D5\\u30A1\\u30A4\\u30EB\\u3078\\u306E\\u30D1\\u30B9\\n          (\\u7D76\\u5BFE\\u30D1\\u30B9\\u307E\\u305F\\u306F\\u73FE\\u5728\\u306E\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA\\u304B\\u3089\\u306E\\u76F8\\u5BFE\\u30D1\\u30B9)\\n          \\u30AD\\u30FC\"module\"\\u3001\"main-jar\"\\u3001\"main-class\"\\u3001\"description\"\\u3001\\n          \"arguments\"\\u3001\"java-options\"\\u3001\"app-version\"\\u3001\"icon\"\\u3001\\n          \"win-console\"\\u3001\"win-shortcut\"\\u3001\"win-menu\"\\u3001\\n          \"linux-app-category\"\\u304A\\u3088\\u3073\"linux-shortcut\"\\u3092\\u4F7F\\u7528\\u3067\\u304D\\u307E\\u3059\\u3002\\n          \\u3053\\u308C\\u3089\\u306E\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u3092\\u5143\\u306E\\u30B3\\u30DE\\u30F3\\u30C9\\u30E9\\u30A4\\u30F3\\u30FB\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u306B\\u8FFD\\u52A0\\u3059\\u308B\\u304B\\u3001\\u3053\\u308C\\u3089\\u306E\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u3092\\n          \\u4F7F\\u7528\\u3057\\u3066\\u5143\\u306E\\u30B3\\u30DE\\u30F3\\u30C9\\u30E9\\u30A4\\u30F3\\u30FB\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u3092\\u4E0A\\u66F8\\u304D\\u3057\\u3066\\u3001\\u8FFD\\u52A0\\u306E\\u4EE3\\u66FF\\u30E9\\u30F3\\u30C1\\u30E3\\u3092\\u4F5C\\u6210\\u3057\\u307E\\u3059\\u3002\\n          \\\n+\\u30E1\\u30A4\\u30F3\\u30FB\\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u30FB\\u30E9\\u30F3\\u30C1\\u30E3\\u306F\\u30B3\\u30DE\\u30F3\\u30C9\\u30E9\\u30A4\\u30F3\\u30FB\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u304B\\u3089\\u4F5C\\u6210\\u3055\\u308C\\u307E\\u3059\\u3002\\n          \\u3053\\u306E\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u3092\\u4F7F\\u7528\\u3057\\u3066\\u8FFD\\u52A0\\u306E\\u4EE3\\u66FF\\u30E9\\u30F3\\u30C1\\u30E3\\u3092\\u4F5C\\u6210\\u3067\\u304D\\u3001\\n          \\u3053\\u306E\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u3092\\u8907\\u6570\\u56DE\\u4F7F\\u7528\\u3057\\u3066\\n          \\u8907\\u6570\\u306E\\u8FFD\\u52A0\\u306E\\u30E9\\u30F3\\u30C1\\u30E3\\u3092\\u4F5C\\u6210\\u3067\\u304D\\u307E\\u3059\\u3002 \\n  --arguments <main class arguments>\\n          \\u30E9\\u30F3\\u30C1\\u30E3\\u306B\\u30B3\\u30DE\\u30F3\\u30C9\\u30FB\\u30E9\\u30A4\\u30F3\\u5F15\\u6570\\u304C\\u6307\\u5B9A\\u3055\\u308C\\u3066\\u3044\\u306A\\u3044\\u5834\\u5408\\u306B\\u30E1\\u30A4\\u30F3\\u30FB\\u30AF\\u30E9\\u30B9\\u306B\\u6E21\\u3059\\n          \\u30B3\\u30DE\\u30F3\\u30C9\\u30FB\\u30E9\\u30A4\\u30F3\\u5F15\\u6570\\n          \\u3053\\u306E\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u306F\\u8907\\u6570\\u56DE\\u4F7F\\u7528\\u3067\\u304D\\u307E\\u3059\\u3002\\n  --java-options <java options>\\n          Java\\u30E9\\u30F3\\u30BF\\u30A4\\u30E0\\u306B\\u6E21\\u3059\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\n          \\u3053\\u306E\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u306F\\u8907\\u6570\\u56DE\\u4F7F\\u7528\\u3067\\u304D\\u307E\\u3059\\u3002\\n  --main-class <class name>\\n          \\u5B9F\\u884C\\u3059\\u308B\\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u30FB\\u30E1\\u30A4\\u30F3\\u30FB\\u30AF\\u30E9\\u30B9\\u306E\\u4FEE\\u98FE\\u540D\\n          \\u3053\\u306E\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u3092\\u4F7F\\u7528\\u3067\\u304D\\u308B\\u306E\\u306F\\u3001--main-jar\\u304C\\u6307\\u5B9A\\u3055\\u308C\\u3066\\u3044\\u308B\\u5834\\u5408\\u3060\\u3051\\u3067\\u3059\\u3002\\n  --main-jar <main jar file>\\n          \\u30E1\\u30A4\\u30F3\\u30FB\\u30AF\\u30E9\\u30B9\\u3092\\u542B\\u3080\\u3001\\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u306E\\u30E1\\u30A4\\u30F3JAR\\n          (\\u5165\\u529B\\u30D1\\u30B9\\u304B\\u3089\\u306E\\u76F8\\u5BFE\\u30D1\\u30B9\\u3068\\u3057\\u3066\\u6307\\u5B9A)\\n          --module\\u307E\\u305F\\u306F--main-jar\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u3092\\u6307\\u5B9A\\u3067\\u304D\\u307E\\u3059\\u304C\\u3001\\u4E21\\u65B9\\u306F\\n          \\u6307\\u5B9A\\u3067\\u304D\\u307E\\u305B\\u3093\\u3002\\n  --module -m <module name>[\/<main class>]\\n          \\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u306E\\u30E1\\u30A4\\u30F3\\u30FB\\u30E2\\u30B8\\u30E5\\u30FC\\u30EB(\\u304A\\u3088\\u3073\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u3067\\u30E1\\u30A4\\u30F3\\u30FB\\u30AF\\u30E9\\u30B9)\\n          \\u3053\\u306E\\u30E2\\u30B8\\u30E5\\u30FC\\u30EB\\u306F\\u3001\\u30E2\\u30B8\\u30E5\\u30FC\\u30EB\\u30FB\\u30D1\\u30B9\\u306B\\u7F6E\\u304B\\u308C\\u3066\\u3044\\u308B\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059\\u3002\\n          \\u3053\\u306E\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u304C\\u6307\\u5B9A\\u3055\\u308C\\u3066\\u3044\\u308B\\u5834\\u5408\\u3001\\u30E1\\u30A4\\u30F3\\u30FB\\u30E2\\u30B8\\u30E5\\u30FC\\u30EB\\u306F\\n          Java\\u30E9\\u30F3\\u30BF\\u30A4\\u30E0\\u30FB\\u30A4\\u30E1\\u30FC\\u30B8\\u5185\\u3067\\u30EA\\u30F3\\u30AF\\u3055\\u308C\\u307E\\u3059\\u3002--module\\u307E\\u305F\\u306F--main-jar\\n          \\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u3092\\u6307\\u5B9A\\u3067\\u304D\\u307E\\u3059\\u304C\\u3001\\u4E21\\u65B9\\u306F\\u6307\\u5B9A\\u3067\\u304D\\u307E\\u305B\\u3093\\u3002\\n{2}\\n\\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u30FB\\u30D1\\u30C3\\u30B1\\u30FC\\u30B8\\u3092\\u4F5C\\u6210\\u3059\\u308B\\u305F\\u3081\\u306E\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3:\\n  --about-url <url>\\n          \\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u306E\\u30DB\\u30FC\\u30E0\\u30DA\\u30FC\\u30B8\\u306EURL\\n  --app-image <directory path>\\n          \\u30A4\\u30F3\\u30B9\\u30C8\\u30FC\\u30EB\\u53EF\\u80FD\\u306A\\u30D1\\u30C3\\u30B1\\u30FC\\u30B8\\u306E\\u4F5C\\u6210\\u306B\\u4F7F\\u7528\\u3059\\u308B\\u3001\\u4E8B\\u524D\\u5B9A\\u7FA9\\u6E08\\u307F\\n          \\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u30FB\\u30A4\\u30E1\\u30FC\\u30B8\\u306E\\u5834\\u6240\\n          \\\n+(\\u7D76\\u5BFE\\u30D1\\u30B9\\u307E\\u305F\\u306F\\u73FE\\u5728\\u306E\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA\\u304B\\u3089\\u306E\\u76F8\\u5BFE\\u30D1\\u30B9)\\n  --file-associations <file path>\\n          \\u30AD\\u30FC\\u3001\\u5024\\u306E\\u30DA\\u30A2\\u306E\\u30EA\\u30B9\\u30C8\\u3092\\u542B\\u3080\\u30D7\\u30ED\\u30D1\\u30C6\\u30A3\\u30FB\\u30D5\\u30A1\\u30A4\\u30EB\\u3078\\u306E\\u30D1\\u30B9\\n          (\\u7D76\\u5BFE\\u30D1\\u30B9\\u307E\\u305F\\u306F\\u73FE\\u5728\\u306E\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA\\u304B\\u3089\\u306E\\u76F8\\u5BFE\\u30D1\\u30B9)\\n          \\u30AD\\u30FC\"extension\"\\u3001\"mime-type\"\\u3001\"icon\"\\u3001\"description\"\\n          \\u3092\\u4F7F\\u7528\\u3057\\u3066\\u95A2\\u9023\\u4ED8\\u3051\\u3092\\u8A18\\u8FF0\\u3067\\u304D\\u307E\\u3059\\u3002\\n          \\u3053\\u306E\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u306F\\u8907\\u6570\\u56DE\\u4F7F\\u7528\\u3067\\u304D\\u307E\\u3059\\u3002\\n  --install-dir <directory path>\\n          {4}  --license-file <file path>\\n          \\u30E9\\u30A4\\u30BB\\u30F3\\u30B9\\u30FB\\u30D5\\u30A1\\u30A4\\u30EB\\u3078\\u306E\\u30D1\\u30B9\\n          (\\u7D76\\u5BFE\\u30D1\\u30B9\\u307E\\u305F\\u306F\\u73FE\\u5728\\u306E\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA\\u304B\\u3089\\u306E\\u76F8\\u5BFE\\u30D1\\u30B9)\\n  --resource-dir <directory path>\\n          \\u30AA\\u30FC\\u30D0\\u30FC\\u30E9\\u30A4\\u30C9jpackage\\u30EA\\u30BD\\u30FC\\u30B9\\u3078\\u306E\\u30D1\\u30B9\\n          \\u30A2\\u30A4\\u30B3\\u30F3\\u3001\\u30C6\\u30F3\\u30D7\\u30EC\\u30FC\\u30C8\\u30FB\\u30D5\\u30A1\\u30A4\\u30EB\\u304A\\u3088\\u3073jpackage\\u306E\\u305D\\u306E\\u4ED6\\u306E\\u30EA\\u30BD\\u30FC\\u30B9\\u306F\\u3001\\n          \\u3053\\u306E\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA\\u306B\\u7F6E\\u63DB\\u30EA\\u30BD\\u30FC\\u30B9\\u3092\\u8FFD\\u52A0\\u3059\\u308B\\u3053\\u3068\\u3067\\u30AA\\u30FC\\u30D0\\u30FC\\u30E9\\u30A4\\u30C9\\u3067\\u304D\\u307E\\u3059\\u3002\\n          (\\u7D76\\u5BFE\\u30D1\\u30B9\\u307E\\u305F\\u306F\\u73FE\\u5728\\u306E\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA\\u304B\\u3089\\u306E\\u76F8\\u5BFE\\u30D1\\u30B9)\\n  --runtime-image <directory path>\\n          \\u30A4\\u30F3\\u30B9\\u30C8\\u30FC\\u30EB\\u3059\\u308B\\u4E8B\\u524D\\u5B9A\\u7FA9\\u6E08\\u307F\\u306E\\u30E9\\u30F3\\u30BF\\u30A4\\u30E0\\u30FB\\u30A4\\u30E1\\u30FC\\u30B8\\u306E\\u30D1\\u30B9\\n          (\\u7D76\\u5BFE\\u30D1\\u30B9\\u307E\\u305F\\u306F\\u73FE\\u5728\\u306E\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA\\u304B\\u3089\\u306E\\u76F8\\u5BFE\\u30D1\\u30B9)\\n          \\u30E9\\u30F3\\u30BF\\u30A4\\u30E0\\u30FB\\u30D1\\u30C3\\u30B1\\u30FC\\u30B8\\u306E\\u4F5C\\u6210\\u6642\\u306B\\u306F\\u3001\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u304C\\u5FC5\\u8981\\u3067\\u3059\\u3002\\n\\n\\u30A2\\u30D7\\u30EA\\u30B1\\u30FC\\u30B7\\u30E7\\u30F3\\u30FB\\u30D1\\u30C3\\u30B1\\u30FC\\u30B8\\u3092\\u4F5C\\u6210\\u3059\\u308B\\u305F\\u3081\\u306E\\u30D7\\u30E9\\u30C3\\u30C8\\u30D5\\u30A9\\u30FC\\u30E0\\u4F9D\\u5B58\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3:\\n{3}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/HelpResources_ja.properties","additions":5,"deletions":180,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -27,180 +27,4 @@\n-MSG_Help=Usage: jpackage <options>\\n\\\n-\\n\\\n-Sample usages:\\n\\\n---------------\\n\\\n-\\    Generate an application package suitable for the host system:\\n\\\n-\\        For a modular application:\\n\\\n-\\            jpackage -n name -p modulePath -m moduleName\/className\\n\\\n-\\        For a non-modular application:\\n\\\n-\\            jpackage -i inputDir -n name \\\\\\n\\\n-\\                --main-class className --main-jar myJar.jar\\n\\\n-\\        From a pre-built application image:\\n\\\n-\\            jpackage -n name --app-image appImageDir\\n\\\n-\\    Generate an application image:\\n\\\n-\\        For a modular application:\\n\\\n-\\            jpackage --type app-image -n name -p modulePath \\\\\\n\\\n-\\                -m moduleName\/className\\n\\\n-\\        For a non-modular application:\\n\\\n-\\            jpackage --type app-image -i inputDir -n name \\\\\\n\\\n-\\                --main-class className --main-jar myJar.jar\\n\\\n-\\        To provide your own options to jlink, run jlink separately:\\n\\\n-\\            jlink --output appRuntimeImage -p modulePath \\\\\\n\\\n-\\                --add-modules moduleName \\\\\\n\\\n-\\                --no-header-files [<additional jlink options>...]\\n\\\n-\\            jpackage --type app-image -n name \\\\\\n\\\n-\\                -m moduleName\/className --runtime-image appRuntimeImage\\n\\\n-\\    Generate a Java runtime package:\\n\\\n-\\        jpackage -n name --runtime-image <runtime-image>\\n\\\n-\\{6}\\\n-\\n\\\n-Generic Options:\\n\\\n-\\  @<filename> \\n\\\n-\\          Read options and\/or mode from a file \\n\\\n-\\          This option can be used multiple times.\\n\\\n-\\  --type -t <type> \\n\\\n-\\          The type of package to create\\n\\\n-\\          Valid values are: {1} \\n\\\n-\\          If this option is not specified a platform dependent\\n\\\n-\\          default type will be created.\\n\\\n-\\  --app-version <version>\\n\\\n-\\          Version of the application and\/or package\\n\\\n-\\  --copyright <copyright string>\\n\\\n-\\          Copyright for the application\\n\\\n-\\  --description <description string>\\n\\\n-\\          Description of the application\\n\\\n-\\  --help -h \\n\\\n-\\          Print the usage text with a list and description of each valid\\n\\\n-\\          option for the current platform to the output stream, and exit\\n\\\n-\\  --icon <file path>\\n\\\n-\\          Path of the icon of the application package\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\  --name -n <name>\\n\\\n-\\          Name of the application and\/or package\\n\\\n-\\  --dest -d <destination path>\\n\\\n-\\          Path where generated output file is placed\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\          Defaults to the current working directory.\\n\\\n-\\  --temp <directory path>\\n\\\n-\\          Path of a new or empty directory used to create temporary files\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\          If specified, the temp dir will not be removed upon the task\\n\\\n-\\          completion and must be removed manually.\\n\\\n-\\          If not specified, a temporary directory will be created and\\n\\\n-\\          removed upon the task completion.\\n\\\n-\\  --vendor <vendor string>\\n\\\n-\\          Vendor of the application\\n\\\n-\\  --verbose\\n\\\n-\\          Enables verbose output\\n\\\n-\\  --version\\n\\\n-\\          Print the product version to the output stream and exit.\\n\\\n-\\n\\\n-\\Options for creating the runtime image:\\n\\\n-\\  --add-modules <module name>[,<module name>...]\\n\\\n-\\          A comma (\",\") separated list of modules to add\\n\\\n-\\          This module list, along with the main module (if specified)\\n\\\n-\\          will be passed to jlink as the --add-module argument.\\n\\\n-\\          If not specified, either just the main module (if --module is\\n\\\n-\\          specified), or the default set of modules (if --main-jar is \\n\\\n-\\          specified) are used.\\n\\\n-\\          This option can be used multiple times.\\n\\\n-\\  --module-path -p <module path>...\\n\\\n-\\          A {0} separated list of paths\\n\\\n-\\          Each path is either a directory of modules or the path to a\\n\\\n-\\          modular jar.\\n\\\n-\\          (Each path is absolute or relative to the current directory.)\\n\\\n-\\          This option can be used multiple times.\\n\\\n-\\  --jlink-options <jlink options> \\n\\\n-\\          A space separated list of options to pass to jlink \\n\\\n-\\          If not specified, defaults to \"--strip-native-commands \\n\\\n-\\          --strip-debug --no-man-pages --no-header-files\". \\n\\\n-\\          This option can be used multiple times.\\n\\\n-\\  --runtime-image <directory path>\\n\\\n-\\          Path of the predefined runtime image that will be copied into\\n\\\n-\\          the application image\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\          If --runtime-image is not specified, jpackage will run jlink to\\n\\\n-\\          create the runtime image using options:\\n\\\n-\\          --strip-debug, --no-header-files, --no-man-pages, and\\n\\\n-\\          --strip-native-commands.\\n\\\n-\\n\\\n-\\Options for creating the application image:\\n\\\n-\\  --input -i <directory path>\\n\\\n-\\          Path of the input directory that contains the files to be packaged\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\          All files in the input directory will be packaged into the\\n\\\n-\\          application image.\\n\\\n-\\  --app-content <additional content>[,<additional content>...]\\n\\\n-\\          A comma separated list of paths to files and\/or directories\\n\\\n-\\          to add to the application payload.\\n\\\n-\\          This option can be used more than once.\\n\\\n-\\n\\\n-\\Options for creating the application launcher(s):\\n\\\n-\\  --add-launcher <launcher name>=<file path>\\n\\\n-\\          Name of launcher, and a path to a Properties file that contains\\n\\\n-\\          a list of key, value pairs\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\          The keys \"module\", \"main-jar\", \"main-class\", \"description\",\\n\\\n-\\          \"arguments\", \"java-options\", \"app-version\", \"icon\",\\n\\\n-\\          \"launcher-as-service\",\\n\\\n-\\          \"win-console\", \"win-shortcut\", \"win-menu\",\\n\\\n-\\          \"linux-app-category\", and \"linux-shortcut\" can be used.\\n\\\n-\\          These options are added to, or used to overwrite, the original\\n\\\n-\\          command line options to build an additional alternative launcher.\\n\\\n-\\          The main application launcher will be built from the command line\\n\\\n-\\          options. Additional alternative launchers can be built using\\n\\\n-\\          this option, and this option can be used multiple times to\\n\\\n-\\          build multiple additional launchers. \\n\\\n-\\  --arguments <main class arguments>\\n\\\n-\\          Command line arguments to pass to the main class if no command\\n\\\n-\\          line arguments are given to the launcher\\n\\\n-\\          This option can be used multiple times.\\n\\\n-\\  --java-options <java options>\\n\\\n-\\          Options to pass to the Java runtime\\n\\\n-\\          This option can be used multiple times.\\n\\\n-\\  --main-class <class name>\\n\\\n-\\          Qualified name of the application main class to execute\\n\\\n-\\          This option can only be used if --main-jar is specified.\\n\\\n-\\  --main-jar <main jar file>\\n\\\n-\\          The main JAR of the application; containing the main class\\n\\\n-\\          (specified as a path relative to the input path)\\n\\\n-\\          Either --module or --main-jar option can be specified but not\\n\\\n-\\          both.\\n\\\n-\\  --module -m <module name>[\/<main class>]\\n\\\n-\\          The main module (and optionally main class) of the application\\n\\\n-\\          This module must be located on the module path.\\n\\\n-\\          When this option is specified, the main module will be linked\\n\\\n-\\          in the Java runtime image.  Either --module or --main-jar\\n\\\n-\\          option can be specified but not both.\\n\\\n-{2}\\n\\\n-\\Options for creating the application package:\\n\\\n-\\  --about-url <url>\\n\\\n-\\          URL of the application''s home page\\n\\\n-\\  --app-image <directory path>\\n\\\n-\\          {5}\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\  --file-associations <file path>\\n\\\n-\\          Path to a Properties file that contains list of key, value pairs\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\          The keys \"extension\", \"mime-type\", \"icon\", and \"description\"\\n\\\n-\\          can be used to describe the association.\\n\\\n-\\          This option can be used multiple times.\\n\\\n-\\  --install-dir <directory path>\\n\\\n-\\          {4}\\\n-\\  --license-file <file path>\\n\\\n-\\          Path to the license file\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\  --resource-dir <directory path>\\n\\\n-\\          Path to override jpackage resources\\n\\\n-\\          Icons, template files, and other resources of jpackage can be\\n\\\n-\\          over-ridden by adding replacement resources to this directory.\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\  --runtime-image <directory path>\\n\\\n-\\          Path of the predefined runtime image to install\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\          Option is required when creating a runtime package.\\n\\\n-\\  --launcher-as-service\\n\\\n-\\          Request to create an installer that will register the main\\n\\\n-\\          application launcher as a background service-type application.\\n\\\n-\\n\\\n-\\Platform dependent options for creating the application package:\\n\\\n-{3}\n+MSG_Help=\\u7528\\u6CD5\\uFF1Ajpackage <options>\\n\\n\\u793A\\u4F8B\\u7528\\u6CD5:\\n--------------\\n    \\u751F\\u6210\\u9002\\u5408\\u4E3B\\u673A\\u7CFB\\u7EDF\\u7684\\u5E94\\u7528\\u7A0B\\u5E8F\\u5305\\uFF1A\\n        \\u5BF9\\u4E8E\\u6A21\\u5757\\u5316\\u5E94\\u7528\\u7A0B\\u5E8F\\uFF1A\\n            jpackage -n name -p modulePath -m moduleName\/className\\n        \\u5BF9\\u4E8E\\u975E\\u6A21\\u5757\\u5316\\u5E94\\u7528\\u7A0B\\u5E8F\\uFF1A\\n            jpackage -i inputDir -n name \\\\\\n                --main-class className --main-jar myJar.jar\\n        \\u4ECE\\u9884\\u6784\\u5EFA\\u7684\\u5E94\\u7528\\u7A0B\\u5E8F\\u6620\\u50CF\\uFF1A\\n            jpackage -n name --app-image appImageDir\\n    \\u751F\\u6210\\u5E94\\u7528\\u7A0B\\u5E8F\\u6620\\u50CF\\uFF1A\\n        \\u5BF9\\u4E8E\\u6A21\\u5757\\u5316\\u5E94\\u7528\\u7A0B\\u5E8F\\uFF1A\\n            jpackage --type app-image -n name -p modulePath \\\\\\n                -m moduleName\/className\\n        \\u5BF9\\u4E8E\\u975E\\u6A21\\u5757\\u5316\\u5E94\\u7528\\u7A0B\\u5E8F\\uFF1A\\n            jpackage --type app-image -i inputDir -n name \\\\\\n                --main-class className --main-jar myJar.jar\\n        \\u8981\\u4E3A jlink \\u63D0\\u4F9B\\u60A8\\u81EA\\u5DF1\\u7684\\u9009\\u9879\\uFF0C\\u8BF7\\u5355\\u72EC\\u8FD0\\u884C jlink\\uFF1A\\n            jlink --output appRuntimeImage -p modulePath \\\\\\n                --add-modules moduleName \\\\\\n                --no-header-files [<additional jlink options>...]\\n            jpackage --type app-image -n name \\\\\\n                -m moduleName\/className --runtime-image appRuntimeImage\\n    \\u751F\\u6210 Java \\u8FD0\\u884C\\u65F6\\u7A0B\\u5E8F\\u5305\\uFF1A\\n        jpackage -n name --runtime-image <runtime-image>\\n\\n\\u4E00\\u822C\\u9009\\u9879\\uFF1A\\n  @<filename> \\n          \\u4ECE\\u6587\\u4EF6\\u8BFB\\u53D6\\u9009\\u9879\\u548C\/\\u6216\\u6A21\\u5F0F \\n          \\u53EF\\u4EE5\\u591A\\u6B21\\u4F7F\\u7528\\u6B64\\u9009\\u9879\\u3002\\n  --type -t <type> \\n          \\u8981\\u521B\\u5EFA\\u7684\\u7A0B\\u5E8F\\u5305\\u7684\\u7C7B\\u578B\\n          \\u6709\\u6548\\u503C\\u4E3A\\uFF1A{1} \\n          \\u5982\\u679C\\u672A\\u6307\\u5B9A\\u6B64\\u9009\\u9879\\uFF0C\\u5219\\u5C06\\u521B\\u5EFA\\u4E0E\\u5E73\\u53F0\\u76F8\\u5173\\u7684\\n          \\u9ED8\\u8BA4\\u7C7B\\u578B\\u3002\\n  --app-version <version>\\n          \\u5E94\\u7528\\u7A0B\\u5E8F\\u548C\/\\u6216\\u7A0B\\u5E8F\\u5305\\u7684\\u7248\\u672C\\n  --copyright <copyright string>\\n          \\u5E94\\u7528\\u7A0B\\u5E8F\\u7684\\u7248\\u6743\\n  --description <description string>\\n          \\u5E94\\u7528\\u7A0B\\u5E8F\\u7684\\u8BF4\\u660E\\n  --help -h \\n          \\u5C06\\u7528\\u6CD5\\u6587\\u672C\\u8F93\\u51FA\\u5230\\u8F93\\u51FA\\u6D41\\u5E76\\u9000\\u51FA\\uFF0C\\u7528\\u6CD5\\u6587\\u672C\\u4E2D\\u5305\\u542B\\n          \\u9002\\u7528\\u4E8E\\u5F53\\u524D\\u5E73\\u53F0\\u7684\\u6BCF\\u4E2A\\u6709\\u6548\\u9009\\u9879\\u7684\\u5217\\u8868\\u548C\\u8BF4\\u660E\\n  --icon <file path>\\n          \\u5E94\\u7528\\u7A0B\\u5E8F\\u5305\\u56FE\\u6807\\u7684\\u8DEF\\u5F84\\n          \\uFF08\\u7EDD\\u5BF9\\u8DEF\\u5F84\\u6216\\u76F8\\u5BF9\\u4E8E\\u5F53\\u524D\\u76EE\\u5F55\\u7684\\u8DEF\\u5F84\\uFF09\\n  --name -n <name>\\n          \\u5E94\\u7528\\u7A0B\\u5E8F\\u548C\/\\u6216\\u7A0B\\u5E8F\\u5305\\u7684\\u540D\\u79F0\\n  --dest -d <destination path>\\n          \\u7528\\u6765\\u653E\\u7F6E\\u6240\\u751F\\u6210\\u7684\\u8F93\\u51FA\\u6587\\u4EF6\\u7684\\u8DEF\\u5F84\\n          \\uFF08\\u7EDD\\u5BF9\\u8DEF\\u5F84\\u6216\\u76F8\\u5BF9\\u4E8E\\u5F53\\u524D\\u76EE\\u5F55\\u7684\\u8DEF\\u5F84\\uFF09\\n          \\u9ED8\\u8BA4\\u4E3A\\u5F53\\u524D\\u7684\\u5DE5\\u4F5C\\u76EE\\u5F55\\u3002\\n  --temp <directory path>\\n          \\u7528\\u6765\\u521B\\u5EFA\\u4E34\\u65F6\\u6587\\u4EF6\\u7684\\u65B0\\u76EE\\u5F55\\u6216\\u7A7A\\u767D\\u76EE\\u5F55\\u7684\\u8DEF\\u5F84\\n          \\uFF08\\u7EDD\\u5BF9\\u8DEF\\u5F84\\u6216\\u76F8\\u5BF9\\u4E8E\\u5F53\\u524D\\u76EE\\u5F55\\u7684\\u8DEF\\u5F84\\uFF09\\n          \\u5982\\u679C\\u6307\\u5B9A\\uFF0C\\u5219\\u5728\\u4EFB\\u52A1\\u5B8C\\u6210\\u65F6\\u5C06\\u4E0D\\u5220\\u9664\\u4E34\\u65F6\\u76EE\\u5F55\\uFF0C\\n          \\u5FC5\\u987B\\u624B\\u52A8\\u5220\\u9664\\u4E34\\u65F6\\u76EE\\u5F55\\u3002\\n          \\u5982\\u679C\\u672A\\u6307\\u5B9A\\uFF0C\\u5219\\u5C06\\u521B\\u5EFA\\u4E00\\u4E2A\\u4E34\\u65F6\\u76EE\\u5F55\\uFF0C\\n          \\\n+\\u5E76\\u5728\\u4EFB\\u52A1\\u5B8C\\u6210\\u65F6\\u5220\\u9664\\u8BE5\\u4E34\\u65F6\\u76EE\\u5F55\\u3002\\n  --vendor <vendor string>\\n          \\u5E94\\u7528\\u7A0B\\u5E8F\\u7684\\u4F9B\\u5E94\\u5546\\n  --verbose\\n          \\u542F\\u7528\\u8BE6\\u7EC6\\u7684\\u8F93\\u51FA\\n  --version\\n          \\u5C06\\u4EA7\\u54C1\\u7248\\u672C\\u8F93\\u51FA\\u5230\\u8F93\\u51FA\\u6D41\\u5E76\\u9000\\u51FA\\u3002\\n\\n\\u7528\\u6765\\u521B\\u5EFA\\u8FD0\\u884C\\u65F6\\u6620\\u50CF\\u7684\\u9009\\u9879\\uFF1A\\n  --add-modules <\\u6A21\\u5757\\u540D\\u79F0>[,<\\u6A21\\u5757\\u540D\\u79F0>...]\\n          \\u8981\\u6DFB\\u52A0\\u7684\\u6A21\\u5757\\u7684\\u9017\\u53F7 (\",\") \\u5206\\u9694\\u5217\\u8868\\n          \\u6B64\\u6A21\\u5757\\u5217\\u8868\\u8FDE\\u540C\\u4E3B\\u6A21\\u5757\\uFF08\\u5982\\u679C\\u6307\\u5B9A\\uFF09\\n          \\u5C06\\u4F5C\\u4E3A --add-module \\u53C2\\u6570\\u4F20\\u9012\\u5230 jlink\\u3002\\n          \\u5982\\u679C\\u672A\\u6307\\u5B9A\\uFF0C\\u5219\\u4EC5\\u4F7F\\u7528\\u4E3B\\u6A21\\u5757\\uFF08\\u5982\\u679C\\u6307\\u5B9A\\u4E86 --module\\uFF09\\uFF0C\\n          \\u6216\\u8005\\u4F7F\\u7528\\u9ED8\\u8BA4\\u7684\\u6A21\\u5757\\u96C6\\uFF08\\u5982\\u679C\\u6307\\u5B9A\\u4E86  \\n          --main-jar\\uFF09\\u3002\\n          \\u53EF\\u4EE5\\u591A\\u6B21\\u4F7F\\u7528\\u6B64\\u9009\\u9879\\u3002\\n  --module-path -p <module path>...\\n          \\u8DEF\\u5F84\\u7684 {0} \\u5206\\u9694\\u5217\\u8868\\n          \\u6BCF\\u4E2A\\u8DEF\\u5F84\\u8981\\u4E48\\u662F\\u6A21\\u5757\\u7684\\u76EE\\u5F55\\uFF0C\\u8981\\u4E48\\u662F\\n          \\u6A21\\u5757 jar \\u7684\\u8DEF\\u5F84\\u3002\\n          \\uFF08\\u6BCF\\u4E2A\\u8DEF\\u5F84\\u53EF\\u4EE5\\u662F\\u7EDD\\u5BF9\\u8DEF\\u5F84\\uFF0C\\u4E5F\\u53EF\\u4EE5\\u662F\\u76F8\\u5BF9\\u4E8E\\u5F53\\u524D\\u76EE\\u5F55\\u7684\\u8DEF\\u5F84\\u3002\\uFF09\\n          \\u53EF\\u4EE5\\u591A\\u6B21\\u4F7F\\u7528\\u6B64\\u9009\\u9879\\u3002\\n  --jlink-options <jlink \\u9009\\u9879> \\n          \\u8981\\u4F20\\u9012\\u7ED9 jlink \\u7684\\u9009\\u9879\\u5217\\u8868\\uFF08\\u7528\\u7A7A\\u683C\\u5206\\u9694\\uFF09 \\n          \\u5982\\u679C\\u672A\\u6307\\u5B9A\\uFF0C\\u5219\\u9ED8\\u8BA4\\u4E3A \"--strip-native-commands \\n          --strip-debug --no-man-pages --no-header-files\"\\u3002 \\n          \\u53EF\\u4EE5\\u591A\\u6B21\\u4F7F\\u7528\\u6B64\\u9009\\u9879\\u3002\\n  --runtime-image <directory path>\\n          \\u5C06\\u590D\\u5236\\u5230\\u5E94\\u7528\\u7A0B\\u5E8F\\u6620\\u50CF\\u7684\\u9884\\u5B9A\\u4E49\\n          \\u8FD0\\u884C\\u65F6\\u6620\\u50CF\\u7684\\u8DEF\\u5F84\\n          \\uFF08\\u7EDD\\u5BF9\\u8DEF\\u5F84\\u6216\\u76F8\\u5BF9\\u4E8E\\u5F53\\u524D\\u76EE\\u5F55\\u7684\\u8DEF\\u5F84\\uFF09\\n          \\u5982\\u679C\\u672A\\u6307\\u5B9A --runtime-image\\uFF0Cjpackage \\u5C06\\u8FD0\\u884C jlink \\u4EE5\\n          \\u4F7F\\u7528\\u5982\\u4E0B\\u9009\\u9879\\u521B\\u5EFA\\u8FD0\\u884C\\u65F6\\u6620\\u50CF\\uFF1A\\n          --strip-debug\\u3001--no-header-files\\u3001--no-man-pages \\u548C \\n          --strip-native-commands\\u3002\\n\\n\\u7528\\u6765\\u521B\\u5EFA\\u5E94\\u7528\\u7A0B\\u5E8F\\u6620\\u50CF\\u7684\\u9009\\u9879\\uFF1A\\n  --input -i <directory path>\\n          \\u5305\\u542B\\u8981\\u6253\\u5305\\u7684\\u6587\\u4EF6\\u7684\\u8F93\\u5165\\u76EE\\u5F55\\u7684\\u8DEF\\u5F84\\n          \\uFF08\\u7EDD\\u5BF9\\u8DEF\\u5F84\\u6216\\u76F8\\u5BF9\\u4E8E\\u5F53\\u524D\\u76EE\\u5F55\\u7684\\u8DEF\\u5F84\\uFF09\\n          \\u8F93\\u5165\\u76EE\\u5F55\\u4E2D\\u7684\\u6240\\u6709\\u6587\\u4EF6\\u5C06\\u6253\\u5305\\u5230\\n          \\u5E94\\u7528\\u7A0B\\u5E8F\\u6620\\u50CF\\u4E2D\\u3002\\n  --app-content <additional content>[,<additional content>...]\\n          \\u8981\\u6DFB\\u52A0\\u5230\\u5E94\\u7528\\u7A0B\\u5E8F\\u6709\\u6548\\u8D1F\\u8F7D\\u4E2D\\u7684\\u6587\\u4EF6\\u548C\/\\u6216\\n          \\u76EE\\u5F55\\u7684\\u9017\\u53F7\\u5206\\u9694\\u8DEF\\u5F84\\u5217\\u8868\\u3002\\n          \\u6B64\\u9009\\u9879\\u53EF\\u4EE5\\u591A\\u6B21\\u4F7F\\u7528\\u3002\\n\\n\\u7528\\u6765\\u521B\\u5EFA\\u5E94\\u7528\\u7A0B\\u5E8F\\u542F\\u52A8\\u7A0B\\u5E8F\\u7684\\u9009\\u9879\\uFF1A\\n  --add-launcher <launcher name>=<file path>\\n          \\u542F\\u52A8\\u7A0B\\u5E8F\\u7684\\u540D\\u79F0\\u548C\\u5305\\u542B\\u5173\\u952E\\u5B57-\\u503C\\u5BF9\\u5217\\u8868\\u7684\\n          \\u5C5E\\u6027\\u6587\\u4EF6\\u7684\\u8DEF\\u5F84\\n          \\uFF08\\u7EDD\\u5BF9\\u8DEF\\u5F84\\u6216\\u76F8\\u5BF9\\u4E8E\\u5F53\\u524D\\u76EE\\u5F55\\u7684\\u8DEF\\u5F84\\uFF09\\n          \\\n+\\u53EF\\u4EE5\\u4F7F\\u7528\\u5173\\u952E\\u5B57 \"module\"\\u3001\"main-jar\"\\u3001\"main-class\"\\u3001\"description\"\\u3001\\n          \"arguments\"\\u3001\"java-options\"\\u3001\"app-version\"\\u3001\"icon\"\\u3001\\n          \"win-console\"\\u3001\"win-shortcut\"\\u3001\"win-menu\"\\u3001\\n          \"linux-app-category\" \\u548C \"linux-shortcut\"\\u3002\\n          \\u8FD9\\u4E9B\\u9009\\u9879\\u5C06\\u6DFB\\u52A0\\u5230\\u539F\\u59CB\\u547D\\u4EE4\\u884C\\u9009\\u9879\\u4E2D\\u6216\\u8005\\u7528\\u6765\\u8986\\u76D6\\n          \\u539F\\u59CB\\u547D\\u4EE4\\u884C\\u9009\\u9879\\uFF0C\\u4EE5\\u6784\\u5EFA\\u989D\\u5916\\u7684\\u66FF\\u4EE3\\u542F\\u52A8\\u7A0B\\u5E8F\\u3002\\n          \\u5C06\\u4ECE\\u547D\\u4EE4\\u884C\\u9009\\u9879\\u6784\\u5EFA\\u4E3B\\u5E94\\u7528\\u7A0B\\u5E8F\\u542F\\u52A8\\u7A0B\\u5E8F\\u3002\\n          \\u53EF\\u4EE5\\u4F7F\\u7528\\u6B64\\u9009\\u9879\\u6784\\u5EFA\\u989D\\u5916\\u7684\\u66FF\\u4EE3\\u542F\\u52A8\\u7A0B\\u5E8F\\uFF0C\\n          \\u53EF\\u4EE5\\u591A\\u6B21\\u4F7F\\u7528\\u6B64\\u9009\\u9879\\u6765\\u6784\\u5EFA\\n          \\u591A\\u4E2A\\u989D\\u5916\\u7684\\u542F\\u52A8\\u7A0B\\u5E8F\\u3002 \\n  --arguments <main class arguments>\\n          \\u5728\\u6CA1\\u6709\\u4E3A\\u542F\\u52A8\\u7A0B\\u5E8F\\u63D0\\u4F9B\\u547D\\u4EE4\\u884C\\u53C2\\u6570\\u65F6\\uFF0C\\n          \\u8981\\u4F20\\u9012\\u5230\\u4E3B\\u7C7B\\u7684\\u547D\\u4EE4\\u884C\\u53C2\\u6570\\n          \\u53EF\\u4EE5\\u591A\\u6B21\\u4F7F\\u7528\\u6B64\\u9009\\u9879\\u3002\\n  --java-options <java options>\\n          \\u8981\\u4F20\\u9012\\u5230 Java \\u8FD0\\u884C\\u65F6\\u7684\\u9009\\u9879\\n          \\u53EF\\u4EE5\\u591A\\u6B21\\u4F7F\\u7528\\u6B64\\u9009\\u9879\\u3002\\n  --main-class <class name>\\n          \\u8981\\u6267\\u884C\\u7684\\u5E94\\u7528\\u7A0B\\u5E8F\\u4E3B\\u7C7B\\u7684\\u9650\\u5B9A\\u540D\\u79F0\\n          \\u53EA\\u6709\\u5728\\u6307\\u5B9A\\u4E86 --main-jar \\u65F6\\u624D\\u80FD\\u4F7F\\u7528\\u6B64\\u9009\\u9879\\u3002\\n  --main-jar <main jar file>\\n          \\u5E94\\u7528\\u7A0B\\u5E8F\\u7684\\u4E3B JAR\\uFF1B\\u5305\\u542B\\u4E3B\\u7C7B\\n          \\uFF08\\u6307\\u5B9A\\u4E3A\\u76F8\\u5BF9\\u4E8E\\u8F93\\u5165\\u8DEF\\u5F84\\u7684\\u8DEF\\u5F84\\uFF09\\n          \\u53EF\\u4EE5\\u6307\\u5B9A --module \\u6216 --main-jar \\u9009\\u9879\\uFF0C\\u4F46\\u662F\\u4E0D\\u80FD\\u540C\\u65F6\\u6307\\u5B9A\\n          \\u4E24\\u8005\\u3002\\n  --module -m <module name>[\/<main class>]\\n          \\u5E94\\u7528\\u7A0B\\u5E8F\\u7684\\u4E3B\\u6A21\\u5757\\uFF08\\u4EE5\\u53CA\\u53EF\\u9009\\u7684\\u4E3B\\u7C7B\\uFF09\\n          \\u6B64\\u6A21\\u5757\\u5FC5\\u987B\\u4F4D\\u4E8E\\u6A21\\u5757\\u8DEF\\u5F84\\u4E2D\\u3002\\n          \\u5982\\u679C\\u6307\\u5B9A\\u4E86\\u6B64\\u9009\\u9879\\uFF0C\\u5219\\u5C06\\u5728 Java \\u8FD0\\u884C\\u65F6\\u6620\\u50CF\\u4E2D\\n          \\u94FE\\u63A5\\u4E3B\\u6A21\\u5757\\u3002\\u53EF\\u4EE5\\u6307\\u5B9A --module \\u6216 --main-jar \\u9009\\u9879\\uFF0C\\n          \\u4F46\\u662F\\u4E0D\\u80FD\\u540C\\u65F6\\u6307\\u5B9A\\u8FD9\\u4E24\\u4E2A\\u9009\\u9879\\u3002\\n{2}\\n\\u7528\\u6765\\u521B\\u5EFA\\u5E94\\u7528\\u7A0B\\u5E8F\\u5305\\u7684\\u9009\\u9879\\uFF1A\\n  --about-url <url>\\n          \\u5E94\\u7528\\u7A0B\\u5E8F\\u4E3B\\u9875\\u7684 URL\\n  --app-image <directory path>\\n          \\u7528\\u6765\\u6784\\u5EFA\\u53EF\\u5B89\\u88C5\\u7A0B\\u5E8F\\u5305\\u7684\\n          \\u9884\\u5B9A\\u4E49\\u5E94\\u7528\\u7A0B\\u5E8F\\u6620\\u50CF\\u7684\\u4F4D\\u7F6E\\n          \\uFF08\\u7EDD\\u5BF9\\u8DEF\\u5F84\\u6216\\u76F8\\u5BF9\\u4E8E\\u5F53\\u524D\\u76EE\\u5F55\\u7684\\u8DEF\\u5F84\\uFF09\\n  --file-associations <file path>\\n          \\u5305\\u542B\\u5173\\u952E\\u5B57-\\u503C\\u5BF9\\u5217\\u8868\\u7684\\u5C5E\\u6027\\u6587\\u4EF6\\u7684\\u8DEF\\u5F84\\n          \\uFF08\\u7EDD\\u5BF9\\u8DEF\\u5F84\\u6216\\u76F8\\u5BF9\\u4E8E\\u5F53\\u524D\\u76EE\\u5F55\\u7684\\u8DEF\\u5F84\\uFF09\\n          \\u53EF\\u4EE5\\u4F7F\\u7528\\u5173\\u952E\\u5B57 \"extension\"\\u3001\"mime-type\"\\u3001\"icon\" \\u548C \"description\" \\n          \\u6765\\u63CF\\u8FF0\\u6B64\\u5173\\u8054\\u3002\\n          \\u53EF\\u4EE5\\u591A\\u6B21\\u4F7F\\u7528\\u6B64\\u9009\\u9879\\u3002\\n  --install-dir <directory path>\\n          {4}  --license-file <file path>\\n          \\u8BB8\\u53EF\\u8BC1\\u6587\\u4EF6\\u7684\\u8DEF\\u5F84\\n          \\uFF08\\u7EDD\\u5BF9\\u8DEF\\u5F84\\u6216\\u76F8\\u5BF9\\u4E8E\\u5F53\\u524D\\u76EE\\u5F55\\u7684\\u8DEF\\u5F84\\uFF09\\n  --resource-dir <directory path>\\n          \\u8986\\u76D6 \\\n+jpackage \\u8D44\\u6E90\\u7684\\u8DEF\\u5F84\\n          \\u53EF\\u4EE5\\u901A\\u8FC7\\u5411\\u8BE5\\u76EE\\u5F55\\u4E2D\\u6DFB\\u52A0\\u66FF\\u4EE3\\u8D44\\u6E90\\u6765\\u8986\\u76D6 jpackage \\u7684\\n          \\u56FE\\u6807\\u3001\\u6A21\\u677F\\u6587\\u4EF6\\u548C\\u5176\\u4ED6\\u8D44\\u6E90\\u3002\\n          \\uFF08\\u7EDD\\u5BF9\\u8DEF\\u5F84\\u6216\\u76F8\\u5BF9\\u4E8E\\u5F53\\u524D\\u76EE\\u5F55\\u7684\\u8DEF\\u5F84\\uFF09\\n  --runtime-image <directory path>\\n          \\u8981\\u5B89\\u88C5\\u7684\\u9884\\u5B9A\\u4E49\\u8FD0\\u884C\\u65F6\\u6620\\u50CF\\u7684\\u8DEF\\u5F84\\n          \\uFF08\\u7EDD\\u5BF9\\u8DEF\\u5F84\\u6216\\u76F8\\u5BF9\\u4E8E\\u5F53\\u524D\\u76EE\\u5F55\\u7684\\u8DEF\\u5F84\\uFF09\\n          \\u5728\\u521B\\u5EFA\\u8FD0\\u884C\\u65F6\\u7A0B\\u5E8F\\u5305\\u65F6\\u9700\\u8981\\u4F7F\\u7528\\u9009\\u9879\\u3002\\n\\n\\u7528\\u6765\\u521B\\u5EFA\\u5E94\\u7528\\u7A0B\\u5E8F\\u5305\\u7684\\u4E0E\\u5E73\\u53F0\\u76F8\\u5173\\u7684\\u9009\\u9879\\uFF1A\\n{3}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/HelpResources_zh_CN.properties","additions":4,"deletions":180,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -516,1 +516,1 @@\n-        for (String loc : Arrays.asList(\"en\", \"ja\", \"zh_CN\")) {\n+        for (String loc : Arrays.asList(\"de\", \"en\", \"ja\", \"zh_CN\")) {\n@@ -518,3 +518,3 @@\n-            try (InputStream is = OverridableResource.readDefault(fname)) {\n-                Files.copy(is, CONFIG_ROOT.fetchFrom(params).resolve(fname));\n-            }\n+            createResource(fname, params)\n+                    .setCategory(I18N.getString(\"resource.wxl-file\"))\n+                    .saveToFile(configDir.resolve(fname));\n@@ -566,4 +566,20 @@\n-        final Path primaryWxlFile = CONFIG_ROOT.fetchFrom(params).resolve(\n-                I18N.getString(\"resource.wxl-file-name\")).toAbsolutePath();\n-\n-        wixPipeline.addLightOptions(\"-loc\", primaryWxlFile.toString());\n+        \/\/ Filter out custom l10n files that were already used to\n+        \/\/ override primary l10n files. Ignore case filename comparison,\n+        \/\/ both lists are expected to be short.\n+        List<Path> primaryWxlFiles = getWxlFilesFromDir(params, CONFIG_ROOT);\n+        List<Path> customWxlFiles = getWxlFilesFromDir(params, RESOURCE_DIR).stream()\n+                .filter(custom -> primaryWxlFiles.stream().noneMatch(primary ->\n+                        primary.getFileName().toString().equalsIgnoreCase(\n+                                custom.getFileName().toString())))\n+                .peek(custom -> Log.verbose(MessageFormat.format(\n+                        I18N.getString(\"message.using-custom-resource\"),\n+                                String.format(\"[%s]\", I18N.getString(\"resource.wxl-file\")),\n+                                custom.getFileName().toString())))\n+                .toList();\n+\n+        \/\/ All l10n files are supplied to WiX with \"-loc\", but only\n+        \/\/ Cultures from custom files and a single primary Culture are\n+        \/\/ included into \"-cultures\" list\n+        for (var wxl : primaryWxlFiles) {\n+            wixPipeline.addLightOptions(\"-loc\", wxl.toAbsolutePath().normalize().toString());\n+        }\n@@ -572,2 +588,2 @@\n-        for (var wxl : getCustomWxlFiles(params)) {\n-            wixPipeline.addLightOptions(\"-loc\", wxl.toAbsolutePath().toString());\n+        for (var wxl : customWxlFiles) {\n+            wixPipeline.addLightOptions(\"-loc\", wxl.toAbsolutePath().normalize().toString());\n@@ -576,0 +592,4 @@\n+\n+        \/\/ Append a primary culture bases on runtime locale.\n+        final Path primaryWxlFile = CONFIG_ROOT.fetchFrom(params).resolve(\n+                I18N.getString(\"resource.wxl-file-name\"));\n@@ -589,4 +609,4 @@\n-    private static List<Path> getCustomWxlFiles(Map<String, ? super Object> params)\n-            throws IOException {\n-        Path resourceDir = RESOURCE_DIR.fetchFrom(params);\n-        if (resourceDir == null) {\n+    private static List<Path> getWxlFilesFromDir(Map<String, ? super Object> params,\n+            StandardBundlerParam<Path> pathParam) throws IOException {\n+        Path dir = pathParam.fetchFrom(params);\n+        if (dir == null) {\n@@ -600,1 +620,1 @@\n-        try (var walk = Files.walk(resourceDir, 1)) {\n+        try (var walk = Files.walk(dir, 1)) {\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinMsiBundler.java","additions":35,"deletions":15,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -531,1 +531,1 @@\n-                xml.writeAttribute(\"Command\", \"Open\");\n+                xml.writeAttribute(\"Command\", \"!(loc.ContextMenuCommandLabel)\");\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixAppImageFragmentBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-<WixLocalization Culture=\"de\" xmlns=\"http:\/\/schemas.microsoft.com\/wix\/2006\/localization\" Codepage=\"1252\">\r\n+<WixLocalization Culture=\"de-de\" xmlns=\"http:\/\/schemas.microsoft.com\/wix\/2006\/localization\" Codepage=\"1252\">\r\n@@ -15,0 +15,1 @@\n+  <String Id=\"ContextMenuCommandLabel\">Open with [ProductName]<\/String>\r\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/MsiInstallerStrings_de.wxl","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -15,0 +15,1 @@\n+  <String Id=\"ContextMenuCommandLabel\">Open with [ProductName]<\/String>\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/MsiInstallerStrings_en.wxl","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-<WixLocalization Culture=\"ja\" xmlns=\"http:\/\/schemas.microsoft.com\/wix\/2006\/localization\" Codepage=\"932\">\r\n+<WixLocalization Culture=\"ja-jp\" xmlns=\"http:\/\/schemas.microsoft.com\/wix\/2006\/localization\" Codepage=\"932\">\r\n@@ -15,0 +15,1 @@\n+  <String Id=\"ContextMenuCommandLabel\">Open with [ProductName]<\/String>\r\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/MsiInstallerStrings_ja.wxl","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-<WixLocalization Culture=\"zh-CN\" xmlns=\"http:\/\/schemas.microsoft.com\/wix\/2006\/localization\" Codepage=\"936\">\r\n+<WixLocalization Culture=\"zh-cn\" xmlns=\"http:\/\/schemas.microsoft.com\/wix\/2006\/localization\" Codepage=\"936\">\r\n@@ -15,0 +15,1 @@\n+  <String Id=\"ContextMenuCommandLabel\">Open with [ProductName]<\/String>\r\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/MsiInstallerStrings_zh_CN.wxl","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+resource.wxl-file=WiX localization file\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResources.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-resource.wxl-file-name=MsiInstallerStrings_en.wxl\n+resource.wxl-file-name=MsiInstallerStrings_de.wxl\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResources_de.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-resource.wxl-file-name=MsiInstallerStrings_en.wxl\n+resource.wxl-file-name=MsiInstallerStrings_ja.wxl\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResources_ja.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-resource.wxl-file-name=MsiInstallerStrings_en.wxl\n+resource.wxl-file-name=MsiInstallerStrings_zh_CN.wxl\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResources_zh_CN.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -221,0 +221,1 @@\n+sle=Sierra-leonischer Leone\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_de.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -223,0 +223,1 @@\n+sle=\\u30B7\\u30A8\\u30E9\\u30EC\\u30AA\\u30CD\\u30FB\\u30EC\\u30AA\\u30F3\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_ja.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -224,0 +224,1 @@\n+sle=\\u585E\\u62C9\\u5229\\u6602\\u5229\\u6602\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_zh_CN.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -444,1 +444,1 @@\n-        if (pos <= 0 || pos == syntaxAndInput.length()) {\n+        if (pos <= 0) {\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipFileSystem.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.hotspot.igv.util;\n+\n+import com.sun.hotspot.igv.data.Properties;\n+import com.sun.hotspot.igv.data.Property;\n+import com.sun.hotspot.igv.util.StringUtils;\n+\n+\/**\n+ *\n+ * @author ksakata\n+ *\/\n+public class PropertiesConverter {\n+    public static String convertToHTML(final Properties properties) {\n+        StringBuilder sb = new StringBuilder(\"<html><body><table cellpadding=\\\"0\\\" cellspacing=\\\"0\\\">\");\n+        for (Property p : properties) {\n+            sb.append(\"<tr><td>\")\n+              .append(StringUtils.escapeHTML(p.getName()))\n+              .append(\"<\/td><td width=\\\"10\\\"><\/td><td>\")\n+              .append(StringUtils.escapeHTML(p.getValue()))\n+              .append(\"<\/td><\/tr>\");\n+        }\n+        sb.append(\"<\/table><\/body><\/html>\");\n+        return sb.toString();\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/PropertiesConverter.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -61,1 +61,1 @@\n-                            str.append(\"&apos;\");\n+                            str.append(\"&#39;\");\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/StringUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import com.sun.hotspot.igv.util.PropertiesConverter;\n@@ -182,0 +183,2 @@\n+\n+        this.setToolTipText(PropertiesConverter.convertToHTML(f.getProperties()));\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/FigureWidget.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1616,0 +1616,2 @@\n+          [\"facgt\", \"facgt\", \"2S\"], [\"facgt\", \"facgt\", \"4S\"],\n+          [\"facgt\", \"facgt\", \"2D\"],\n@@ -1825,0 +1827,6 @@\n+                        [\"facgt\",    \"__ sve_fac(Assembler::GT, p1, __ H, p2, z4, z5);\",   \"facgt\\tp1.h, p2\/z, z4.h, z5.h\"],\n+                        [\"facgt\",    \"__ sve_fac(Assembler::GT, p1, __ S, p2, z4, z5);\",   \"facgt\\tp1.s, p2\/z, z4.s, z5.s\"],\n+                        [\"facgt\",    \"__ sve_fac(Assembler::GT, p1, __ D, p2, z4, z5);\",   \"facgt\\tp1.d, p2\/z, z4.d, z5.d\"],\n+                        [\"facge\",    \"__ sve_fac(Assembler::GE, p1, __ H, p2, z4, z5);\",   \"facge\\tp1.h, p2\/z, z4.h, z5.h\"],\n+                        [\"facge\",    \"__ sve_fac(Assembler::GE, p1, __ S, p2, z4, z5);\",   \"facge\\tp1.s, p2\/z, z4.s, z5.s\"],\n+                        [\"facge\",    \"__ sve_fac(Assembler::GE, p1, __ D, p2, z4, z5);\",   \"facge\\tp1.d, p2\/z, z4.d, z5.d\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -755,0 +755,3 @@\n+    __ facgt(v2, __ T2S, v3, v4);                      \/\/       facgt   v2.2S, v3.2S, v4.2S\n+    __ facgt(v6, __ T4S, v7, v8);                      \/\/       facgt   v6.4S, v7.4S, v8.4S\n+    __ facgt(v19, __ T2D, v20, v21);                   \/\/       facgt   v19.2D, v20.2D, v21.2D\n@@ -757,6 +760,6 @@\n-    __ sve_fcm(Assembler::EQ, p1, __ D, p6, z6, 0.0);  \/\/       fcmeq   p1.d, p6\/z, z6.d, #0.0\n-    __ sve_fcm(Assembler::GT, p8, __ S, p1, z4, 0.0);  \/\/       fcmgt   p8.s, p1\/z, z4.s, #0.0\n-    __ sve_fcm(Assembler::GE, p6, __ D, p4, z17, 0.0); \/\/       fcmge   p6.d, p4\/z, z17.d, #0.0\n-    __ sve_fcm(Assembler::LT, p9, __ D, p5, z10, 0.0); \/\/       fcmlt   p9.d, p5\/z, z10.d, #0.0\n-    __ sve_fcm(Assembler::LE, p6, __ D, p7, z25, 0.0); \/\/       fcmle   p6.d, p7\/z, z25.d, #0.0\n-    __ sve_fcm(Assembler::NE, p7, __ D, p0, z10, 0.0); \/\/       fcmne   p7.d, p0\/z, z10.d, #0.0\n+    __ sve_fcm(Assembler::EQ, p13, __ S, p0, z15, 0.0); \/\/      fcmeq   p13.s, p0\/z, z15.s, #0.0\n+    __ sve_fcm(Assembler::GT, p2, __ D, p5, z11, 0.0); \/\/       fcmgt   p2.d, p5\/z, z11.d, #0.0\n+    __ sve_fcm(Assembler::GE, p8, __ S, p5, z17, 0.0); \/\/       fcmge   p8.s, p5\/z, z17.s, #0.0\n+    __ sve_fcm(Assembler::LT, p11, __ D, p5, z12, 0.0); \/\/      fcmlt   p11.d, p5\/z, z12.d, #0.0\n+    __ sve_fcm(Assembler::LE, p14, __ S, p6, z14, 0.0); \/\/      fcmle   p14.s, p6\/z, z14.s, #0.0\n+    __ sve_fcm(Assembler::NE, p0, __ D, p2, z11, 0.0); \/\/       fcmne   p0.d, p2\/z, z11.d, #0.0\n@@ -969,0 +972,6 @@\n+    __ sve_fac(Assembler::GT, p1, __ H, p2, z4, z5);   \/\/       facgt   p1.h, p2\/z, z4.h, z5.h\n+    __ sve_fac(Assembler::GT, p1, __ S, p2, z4, z5);   \/\/       facgt   p1.s, p2\/z, z4.s, z5.s\n+    __ sve_fac(Assembler::GT, p1, __ D, p2, z4, z5);   \/\/       facgt   p1.d, p2\/z, z4.d, z5.d\n+    __ sve_fac(Assembler::GE, p1, __ H, p2, z4, z5);   \/\/       facge   p1.h, p2\/z, z4.h, z5.h\n+    __ sve_fac(Assembler::GE, p1, __ S, p2, z4, z5);   \/\/       facge   p1.s, p2\/z, z4.s, z5.s\n+    __ sve_fac(Assembler::GE, p1, __ D, p2, z4, z5);   \/\/       facge   p1.d, p2\/z, z4.d, z5.d\n@@ -1007,9 +1016,9 @@\n-    __ swp(Assembler::xword, r12, zr, r10);            \/\/       swp     x12, xzr, [x10]\n-    __ ldadd(Assembler::xword, r16, r7, r2);           \/\/       ldadd   x16, x7, [x2]\n-    __ ldbic(Assembler::xword, r3, r13, r19);          \/\/       ldclr   x3, x13, [x19]\n-    __ ldeor(Assembler::xword, r17, r16, r3);          \/\/       ldeor   x17, x16, [x3]\n-    __ ldorr(Assembler::xword, r1, r11, r30);          \/\/       ldset   x1, x11, [x30]\n-    __ ldsmin(Assembler::xword, r5, r8, r15);          \/\/       ldsmin  x5, x8, [x15]\n-    __ ldsmax(Assembler::xword, r29, r30, r0);         \/\/       ldsmax  x29, x30, [x0]\n-    __ ldumin(Assembler::xword, r20, r7, r20);         \/\/       ldumin  x20, x7, [x20]\n-    __ ldumax(Assembler::xword, r23, r28, r21);        \/\/       ldumax  x23, x28, [x21]\n+    __ swp(Assembler::xword, r16, r7, r2);             \/\/       swp     x16, x7, [x2]\n+    __ ldadd(Assembler::xword, r3, r13, r19);          \/\/       ldadd   x3, x13, [x19]\n+    __ ldbic(Assembler::xword, r17, r16, r3);          \/\/       ldclr   x17, x16, [x3]\n+    __ ldeor(Assembler::xword, r1, r11, r30);          \/\/       ldeor   x1, x11, [x30]\n+    __ ldorr(Assembler::xword, r5, r8, r15);           \/\/       ldset   x5, x8, [x15]\n+    __ ldsmin(Assembler::xword, r29, r30, r0);         \/\/       ldsmin  x29, x30, [x0]\n+    __ ldsmax(Assembler::xword, r20, r7, r20);         \/\/       ldsmax  x20, x7, [x20]\n+    __ ldumin(Assembler::xword, r23, r28, r21);        \/\/       ldumin  x23, x28, [x21]\n+    __ ldumax(Assembler::xword, r27, r25, r5);         \/\/       ldumax  x27, x25, [x5]\n@@ -1018,9 +1027,9 @@\n-    __ swpa(Assembler::xword, r27, r25, r5);           \/\/       swpa    x27, x25, [x5]\n-    __ ldadda(Assembler::xword, r1, r23, r16);         \/\/       ldadda  x1, x23, [x16]\n-    __ ldbica(Assembler::xword, zr, r5, r12);          \/\/       ldclra  xzr, x5, [x12]\n-    __ ldeora(Assembler::xword, r9, r28, r15);         \/\/       ldeora  x9, x28, [x15]\n-    __ ldorra(Assembler::xword, r29, r22, sp);         \/\/       ldseta  x29, x22, [sp]\n-    __ ldsmina(Assembler::xword, r19, zr, r5);         \/\/       ldsmina x19, xzr, [x5]\n-    __ ldsmaxa(Assembler::xword, r14, r16, sp);        \/\/       ldsmaxa x14, x16, [sp]\n-    __ ldumina(Assembler::xword, r16, r27, r20);       \/\/       ldumina x16, x27, [x20]\n-    __ ldumaxa(Assembler::xword, r16, r12, r11);       \/\/       ldumaxa x16, x12, [x11]\n+    __ swpa(Assembler::xword, r1, r23, r16);           \/\/       swpa    x1, x23, [x16]\n+    __ ldadda(Assembler::xword, zr, r5, r12);          \/\/       ldadda  xzr, x5, [x12]\n+    __ ldbica(Assembler::xword, r9, r28, r15);         \/\/       ldclra  x9, x28, [x15]\n+    __ ldeora(Assembler::xword, r29, r22, sp);         \/\/       ldeora  x29, x22, [sp]\n+    __ ldorra(Assembler::xword, r19, zr, r5);          \/\/       ldseta  x19, xzr, [x5]\n+    __ ldsmina(Assembler::xword, r14, r16, sp);        \/\/       ldsmina x14, x16, [sp]\n+    __ ldsmaxa(Assembler::xword, r16, r27, r20);       \/\/       ldsmaxa x16, x27, [x20]\n+    __ ldumina(Assembler::xword, r16, r12, r11);       \/\/       ldumina x16, x12, [x11]\n+    __ ldumaxa(Assembler::xword, r9, r6, r30);         \/\/       ldumaxa x9, x6, [x30]\n@@ -1029,9 +1038,9 @@\n-    __ swpal(Assembler::xword, r9, r6, r30);           \/\/       swpal   x9, x6, [x30]\n-    __ ldaddal(Assembler::xword, r17, r27, r28);       \/\/       ldaddal x17, x27, [x28]\n-    __ ldbical(Assembler::xword, r30, r7, r10);        \/\/       ldclral x30, x7, [x10]\n-    __ ldeoral(Assembler::xword, r20, r10, r4);        \/\/       ldeoral x20, x10, [x4]\n-    __ ldorral(Assembler::xword, r24, r17, r17);       \/\/       ldsetal x24, x17, [x17]\n-    __ ldsminal(Assembler::xword, r22, r3, r29);       \/\/       ldsminal        x22, x3, [x29]\n-    __ ldsmaxal(Assembler::xword, r15, r22, r19);      \/\/       ldsmaxal        x15, x22, [x19]\n-    __ lduminal(Assembler::xword, r19, r22, r2);       \/\/       lduminal        x19, x22, [x2]\n-    __ ldumaxal(Assembler::xword, r15, r6, r12);       \/\/       ldumaxal        x15, x6, [x12]\n+    __ swpal(Assembler::xword, r17, r27, r28);         \/\/       swpal   x17, x27, [x28]\n+    __ ldaddal(Assembler::xword, r30, r7, r10);        \/\/       ldaddal x30, x7, [x10]\n+    __ ldbical(Assembler::xword, r20, r10, r4);        \/\/       ldclral x20, x10, [x4]\n+    __ ldeoral(Assembler::xword, r24, r17, r17);       \/\/       ldeoral x24, x17, [x17]\n+    __ ldorral(Assembler::xword, r22, r3, r29);        \/\/       ldsetal x22, x3, [x29]\n+    __ ldsminal(Assembler::xword, r15, r22, r19);      \/\/       ldsminal        x15, x22, [x19]\n+    __ ldsmaxal(Assembler::xword, r19, r22, r2);       \/\/       ldsmaxal        x19, x22, [x2]\n+    __ lduminal(Assembler::xword, r15, r6, r12);       \/\/       lduminal        x15, x6, [x12]\n+    __ ldumaxal(Assembler::xword, r16, r11, r13);      \/\/       ldumaxal        x16, x11, [x13]\n@@ -1040,9 +1049,9 @@\n-    __ swpl(Assembler::xword, r16, r11, r13);          \/\/       swpl    x16, x11, [x13]\n-    __ ldaddl(Assembler::xword, r23, r1, r30);         \/\/       ldaddl  x23, x1, [x30]\n-    __ ldbicl(Assembler::xword, r19, r5, r17);         \/\/       ldclrl  x19, x5, [x17]\n-    __ ldeorl(Assembler::xword, r2, r16, r22);         \/\/       ldeorl  x2, x16, [x22]\n-    __ ldorrl(Assembler::xword, r13, r10, r21);        \/\/       ldsetl  x13, x10, [x21]\n-    __ ldsminl(Assembler::xword, r29, r27, r12);       \/\/       ldsminl x29, x27, [x12]\n-    __ ldsmaxl(Assembler::xword, r27, r3, r1);         \/\/       ldsmaxl x27, x3, [x1]\n-    __ lduminl(Assembler::xword, zr, r24, r19);        \/\/       lduminl xzr, x24, [x19]\n-    __ ldumaxl(Assembler::xword, r17, r9, r28);        \/\/       ldumaxl x17, x9, [x28]\n+    __ swpl(Assembler::xword, r23, r1, r30);           \/\/       swpl    x23, x1, [x30]\n+    __ ldaddl(Assembler::xword, r19, r5, r17);         \/\/       ldaddl  x19, x5, [x17]\n+    __ ldbicl(Assembler::xword, r2, r16, r22);         \/\/       ldclrl  x2, x16, [x22]\n+    __ ldeorl(Assembler::xword, r13, r10, r21);        \/\/       ldeorl  x13, x10, [x21]\n+    __ ldorrl(Assembler::xword, r29, r27, r12);        \/\/       ldsetl  x29, x27, [x12]\n+    __ ldsminl(Assembler::xword, r27, r3, r1);         \/\/       ldsminl x27, x3, [x1]\n+    __ ldsmaxl(Assembler::xword, zr, r24, r19);        \/\/       ldsmaxl xzr, x24, [x19]\n+    __ lduminl(Assembler::xword, r17, r9, r28);        \/\/       lduminl x17, x9, [x28]\n+    __ ldumaxl(Assembler::xword, r27, r15, r7);        \/\/       ldumaxl x27, x15, [x7]\n@@ -1051,9 +1060,9 @@\n-    __ swp(Assembler::word, r27, r15, r7);             \/\/       swp     w27, w15, [x7]\n-    __ ldadd(Assembler::word, r21, r23, sp);           \/\/       ldadd   w21, w23, [sp]\n-    __ ldbic(Assembler::word, r25, r2, sp);            \/\/       ldclr   w25, w2, [sp]\n-    __ ldeor(Assembler::word, r27, r16, r10);          \/\/       ldeor   w27, w16, [x10]\n-    __ ldorr(Assembler::word, r23, r19, r3);           \/\/       ldset   w23, w19, [x3]\n-    __ ldsmin(Assembler::word, r16, r0, r25);          \/\/       ldsmin  w16, w0, [x25]\n-    __ ldsmax(Assembler::word, r26, r23, r2);          \/\/       ldsmax  w26, w23, [x2]\n-    __ ldumin(Assembler::word, r16, r12, r4);          \/\/       ldumin  w16, w12, [x4]\n-    __ ldumax(Assembler::word, r28, r30, r29);         \/\/       ldumax  w28, w30, [x29]\n+    __ swp(Assembler::word, r21, r23, sp);             \/\/       swp     w21, w23, [sp]\n+    __ ldadd(Assembler::word, r25, r2, sp);            \/\/       ldadd   w25, w2, [sp]\n+    __ ldbic(Assembler::word, r27, r16, r10);          \/\/       ldclr   w27, w16, [x10]\n+    __ ldeor(Assembler::word, r23, r19, r3);           \/\/       ldeor   w23, w19, [x3]\n+    __ ldorr(Assembler::word, r16, r0, r25);           \/\/       ldset   w16, w0, [x25]\n+    __ ldsmin(Assembler::word, r26, r23, r2);          \/\/       ldsmin  w26, w23, [x2]\n+    __ ldsmax(Assembler::word, r16, r12, r4);          \/\/       ldsmax  w16, w12, [x4]\n+    __ ldumin(Assembler::word, r28, r30, r29);         \/\/       ldumin  w28, w30, [x29]\n+    __ ldumax(Assembler::word, r16, r27, r6);          \/\/       ldumax  w16, w27, [x6]\n@@ -1062,9 +1071,9 @@\n-    __ swpa(Assembler::word, r16, r27, r6);            \/\/       swpa    w16, w27, [x6]\n-    __ ldadda(Assembler::word, r9, r29, r15);          \/\/       ldadda  w9, w29, [x15]\n-    __ ldbica(Assembler::word, r7, r4, r7);            \/\/       ldclra  w7, w4, [x7]\n-    __ ldeora(Assembler::word, r15, r9, r23);          \/\/       ldeora  w15, w9, [x23]\n-    __ ldorra(Assembler::word, r8, r2, r28);           \/\/       ldseta  w8, w2, [x28]\n-    __ ldsmina(Assembler::word, r21, zr, r5);          \/\/       ldsmina w21, wzr, [x5]\n-    __ ldsmaxa(Assembler::word, r27, r0, r17);         \/\/       ldsmaxa w27, w0, [x17]\n-    __ ldumina(Assembler::word, r15, r4, r26);         \/\/       ldumina w15, w4, [x26]\n-    __ ldumaxa(Assembler::word, r8, r28, r22);         \/\/       ldumaxa w8, w28, [x22]\n+    __ swpa(Assembler::word, r9, r29, r15);            \/\/       swpa    w9, w29, [x15]\n+    __ ldadda(Assembler::word, r7, r4, r7);            \/\/       ldadda  w7, w4, [x7]\n+    __ ldbica(Assembler::word, r15, r9, r23);          \/\/       ldclra  w15, w9, [x23]\n+    __ ldeora(Assembler::word, r8, r2, r28);           \/\/       ldeora  w8, w2, [x28]\n+    __ ldorra(Assembler::word, r21, zr, r5);           \/\/       ldseta  w21, wzr, [x5]\n+    __ ldsmina(Assembler::word, r27, r0, r17);         \/\/       ldsmina w27, w0, [x17]\n+    __ ldsmaxa(Assembler::word, r15, r4, r26);         \/\/       ldsmaxa w15, w4, [x26]\n+    __ ldumina(Assembler::word, r8, r28, r22);         \/\/       ldumina w8, w28, [x22]\n+    __ ldumaxa(Assembler::word, r27, r27, r25);        \/\/       ldumaxa w27, w27, [x25]\n@@ -1073,9 +1082,9 @@\n-    __ swpal(Assembler::word, r27, r27, r25);          \/\/       swpal   w27, w27, [x25]\n-    __ ldaddal(Assembler::word, r23, r0, r4);          \/\/       ldaddal w23, w0, [x4]\n-    __ ldbical(Assembler::word, r6, r16, r0);          \/\/       ldclral w6, w16, [x0]\n-    __ ldeoral(Assembler::word, r4, r15, r1);          \/\/       ldeoral w4, w15, [x1]\n-    __ ldorral(Assembler::word, r10, r7, r5);          \/\/       ldsetal w10, w7, [x5]\n-    __ ldsminal(Assembler::word, r10, r28, r7);        \/\/       ldsminal        w10, w28, [x7]\n-    __ ldsmaxal(Assembler::word, r20, r23, r21);       \/\/       ldsmaxal        w20, w23, [x21]\n-    __ lduminal(Assembler::word, r6, r11, r8);         \/\/       lduminal        w6, w11, [x8]\n-    __ ldumaxal(Assembler::word, r17, zr, r6);         \/\/       ldumaxal        w17, wzr, [x6]\n+    __ swpal(Assembler::word, r23, r0, r4);            \/\/       swpal   w23, w0, [x4]\n+    __ ldaddal(Assembler::word, r6, r16, r0);          \/\/       ldaddal w6, w16, [x0]\n+    __ ldbical(Assembler::word, r4, r15, r1);          \/\/       ldclral w4, w15, [x1]\n+    __ ldeoral(Assembler::word, r10, r7, r5);          \/\/       ldeoral w10, w7, [x5]\n+    __ ldorral(Assembler::word, r10, r28, r7);         \/\/       ldsetal w10, w28, [x7]\n+    __ ldsminal(Assembler::word, r20, r23, r21);       \/\/       ldsminal        w20, w23, [x21]\n+    __ ldsmaxal(Assembler::word, r6, r11, r8);         \/\/       ldsmaxal        w6, w11, [x8]\n+    __ lduminal(Assembler::word, r17, zr, r6);         \/\/       lduminal        w17, wzr, [x6]\n+    __ ldumaxal(Assembler::word, r17, r2, r12);        \/\/       ldumaxal        w17, w2, [x12]\n@@ -1084,9 +1093,9 @@\n-    __ swpl(Assembler::word, r17, r2, r12);            \/\/       swpl    w17, w2, [x12]\n-    __ ldaddl(Assembler::word, r30, r29, r3);          \/\/       ldaddl  w30, w29, [x3]\n-    __ ldbicl(Assembler::word, r27, r22, r29);         \/\/       ldclrl  w27, w22, [x29]\n-    __ ldeorl(Assembler::word, r14, r13, r28);         \/\/       ldeorl  w14, w13, [x28]\n-    __ ldorrl(Assembler::word, r17, r24, r5);          \/\/       ldsetl  w17, w24, [x5]\n-    __ ldsminl(Assembler::word, r2, r14, r10);         \/\/       ldsminl w2, w14, [x10]\n-    __ ldsmaxl(Assembler::word, r16, r11, r27);        \/\/       ldsmaxl w16, w11, [x27]\n-    __ lduminl(Assembler::word, r23, r12, r4);         \/\/       lduminl w23, w12, [x4]\n-    __ ldumaxl(Assembler::word, r22, r17, r4);         \/\/       ldumaxl w22, w17, [x4]\n+    __ swpl(Assembler::word, r30, r29, r3);            \/\/       swpl    w30, w29, [x3]\n+    __ ldaddl(Assembler::word, r27, r22, r29);         \/\/       ldaddl  w27, w22, [x29]\n+    __ ldbicl(Assembler::word, r14, r13, r28);         \/\/       ldclrl  w14, w13, [x28]\n+    __ ldeorl(Assembler::word, r17, r24, r5);          \/\/       ldeorl  w17, w24, [x5]\n+    __ ldorrl(Assembler::word, r2, r14, r10);          \/\/       ldsetl  w2, w14, [x10]\n+    __ ldsminl(Assembler::word, r16, r11, r27);        \/\/       ldsminl w16, w11, [x27]\n+    __ ldsmaxl(Assembler::word, r23, r12, r4);         \/\/       ldsmaxl w23, w12, [x4]\n+    __ lduminl(Assembler::word, r22, r17, r4);         \/\/       lduminl w22, w17, [x4]\n+    __ ldumaxl(Assembler::word, r1, r19, r16);         \/\/       ldumaxl w1, w19, [x16]\n@@ -1095,4 +1104,4 @@\n-    __ bcax(v1, __ T16B, v19, v16, v17);               \/\/       bcax            v1.16B, v19.16B, v16.16B, v17.16B\n-    __ eor3(v12, __ T16B, v14, v12, v2);               \/\/       eor3            v12.16B, v14.16B, v12.16B, v2.16B\n-    __ rax1(v16, __ T2D, v3, v20);                     \/\/       rax1            v16.2D, v3.2D, v20.2D\n-    __ xar(v23, __ T2D, v5, v6, 15);                   \/\/       xar             v23.2D, v5.2D, v6.2D, #15\n+    __ bcax(v17, __ T16B, v12, v14, v12);              \/\/       bcax            v17.16B, v12.16B, v14.16B, v12.16B\n+    __ eor3(v2, __ T16B, v16, v3, v20);                \/\/       eor3            v2.16B, v16.16B, v3.16B, v20.16B\n+    __ rax1(v23, __ T2D, v5, v6);                      \/\/       rax1            v23.2D, v5.2D, v6.2D\n+    __ xar(v7, __ T2D, v17, v12, 56);                  \/\/       xar             v7.2D, v17.2D, v12.2D, #56\n@@ -1101,4 +1110,4 @@\n-    __ sha512h(v17, __ T2D, v12, v27);                 \/\/       sha512h         q17, q12, v27.2D\n-    __ sha512h2(v16, __ T2D, v16, v6);                 \/\/       sha512h2                q16, q16, v6.2D\n-    __ sha512su0(v2, __ T2D, v28);                     \/\/       sha512su0               v2.2D, v28.2D\n-    __ sha512su1(v3, __ T2D, v4, v6);                  \/\/       sha512su1               v3.2D, v4.2D, v6.2D\n+    __ sha512h(v16, __ T2D, v16, v6);                  \/\/       sha512h         q16, q16, v6.2D\n+    __ sha512h2(v2, __ T2D, v28, v3);                  \/\/       sha512h2                q2, q28, v3.2D\n+    __ sha512su0(v4, __ T2D, v6);                      \/\/       sha512su0               v4.2D, v6.2D\n+    __ sha512su1(v17, __ T2D, v19, v13);               \/\/       sha512su1               v17.2D, v19.2D, v13.2D\n@@ -1107,5 +1116,5 @@\n-    __ sve_add(z17, __ S, 110u);                       \/\/       add     z17.s, z17.s, #0x6e\n-    __ sve_sub(z12, __ S, 67u);                        \/\/       sub     z12.s, z12.s, #0x43\n-    __ sve_and(z24, __ S, 63u);                        \/\/       and     z24.s, z24.s, #0x3f\n-    __ sve_eor(z10, __ D, 18374686479671656447u);      \/\/       eor     z10.d, z10.d, #0xff00000000007fff\n-    __ sve_orr(z30, __ H, 511u);                       \/\/       orr     z30.h, z30.h, #0x1ff\n+    __ sve_add(z12, __ S, 67u);                        \/\/       add     z12.s, z12.s, #0x43\n+    __ sve_sub(z24, __ S, 154u);                       \/\/       sub     z24.s, z24.s, #0x9a\n+    __ sve_and(z0, __ H, 511u);                        \/\/       and     z0.h, z0.h, #0x1ff\n+    __ sve_eor(z19, __ D, 9241386433220968447u);       \/\/       eor     z19.d, z19.d, #0x803fffff803fffff\n+    __ sve_orr(z6, __ B, 128u);                        \/\/       orr     z6.b, z6.b, #0x80\n@@ -1114,5 +1123,5 @@\n-    __ sve_add(z0, __ B, 120u);                        \/\/       add     z0.b, z0.b, #0x78\n-    __ sve_sub(z17, __ D, 74u);                        \/\/       sub     z17.d, z17.d, #0x4a\n-    __ sve_and(z10, __ S, 4261413375u);                \/\/       and     z10.s, z10.s, #0xfe0001ff\n-    __ sve_eor(z27, __ B, 128u);                       \/\/       eor     z27.b, z27.b, #0x80\n-    __ sve_orr(z17, __ S, 253952u);                    \/\/       orr     z17.s, z17.s, #0x3e000\n+    __ sve_add(z17, __ D, 74u);                        \/\/       add     z17.d, z17.d, #0x4a\n+    __ sve_sub(z10, __ S, 170u);                       \/\/       sub     z10.s, z10.s, #0xaa\n+    __ sve_and(z22, __ D, 17179852800u);               \/\/       and     z22.d, z22.d, #0x3ffffc000\n+    __ sve_eor(z15, __ S, 8388600u);                   \/\/       eor     z15.s, z15.s, #0x7ffff8\n+    __ sve_orr(z4, __ D, 8064u);                       \/\/       orr     z4.d, z4.d, #0x1f80\n@@ -1121,5 +1130,5 @@\n-    __ sve_add(z28, __ B, 4u);                         \/\/       add     z28.b, z28.b, #0x4\n-    __ sve_sub(z8, __ S, 162u);                        \/\/       sub     z8.s, z8.s, #0xa2\n-    __ sve_and(z22, __ B, 96u);                        \/\/       and     z22.b, z22.b, #0x60\n-    __ sve_eor(z22, __ H, 511u);                       \/\/       eor     z22.h, z22.h, #0x1ff\n-    __ sve_orr(z30, __ S, 4261413375u);                \/\/       orr     z30.s, z30.s, #0xfe0001ff\n+    __ sve_add(z8, __ S, 162u);                        \/\/       add     z8.s, z8.s, #0xa2\n+    __ sve_sub(z22, __ B, 130u);                       \/\/       sub     z22.b, z22.b, #0x82\n+    __ sve_and(z9, __ S, 4292870159u);                 \/\/       and     z9.s, z9.s, #0xffe0000f\n+    __ sve_eor(z5, __ D, 1150687262887383032u);        \/\/       eor     z5.d, z5.d, #0xff80ff80ff80ff8\n+    __ sve_orr(z22, __ H, 32256u);                     \/\/       orr     z22.h, z22.h, #0x7e00\n@@ -1128,5 +1137,5 @@\n-    __ sve_add(z11, __ B, 112u);                       \/\/       add     z11.b, z11.b, #0x70\n-    __ sve_sub(z8, __ S, 134u);                        \/\/       sub     z8.s, z8.s, #0x86\n-    __ sve_and(z25, __ H, 508u);                       \/\/       and     z25.h, z25.h, #0x1fc\n-    __ sve_eor(z17, __ H, 65283u);                     \/\/       eor     z17.h, z17.h, #0xff03\n-    __ sve_orr(z4, __ D, 18446744073172942847u);       \/\/       orr     z4.d, z4.d, #0xffffffffe003ffff\n+    __ sve_add(z8, __ S, 134u);                        \/\/       add     z8.s, z8.s, #0x86\n+    __ sve_sub(z25, __ H, 39u);                        \/\/       sub     z25.h, z25.h, #0x27\n+    __ sve_and(z4, __ S, 4186112u);                    \/\/       and     z4.s, z4.s, #0x3fe000\n+    __ sve_eor(z29, __ B, 131u);                       \/\/       eor     z29.b, z29.b, #0x83\n+    __ sve_orr(z29, __ D, 4611685469745315712u);       \/\/       orr     z29.d, z29.d, #0x3fffff803fffff80\n@@ -1135,5 +1144,5 @@\n-    __ sve_add(z26, __ H, 120u);                       \/\/       add     z26.h, z26.h, #0x78\n-    __ sve_sub(z2, __ H, 237u);                        \/\/       sub     z2.h, z2.h, #0xed\n-    __ sve_and(z3, __ B, 243u);                        \/\/       and     z3.b, z3.b, #0xf3\n-    __ sve_eor(z21, __ S, 25166208u);                  \/\/       eor     z21.s, z21.s, #0x1800180\n-    __ sve_orr(z17, __ S, 917504u);                    \/\/       orr     z17.s, z17.s, #0xe0000\n+    __ sve_add(z2, __ H, 237u);                        \/\/       add     z2.h, z2.h, #0xed\n+    __ sve_sub(z3, __ B, 10u);                         \/\/       sub     z3.b, z3.b, #0xa\n+    __ sve_and(z26, __ S, 1610637312u);                \/\/       and     z26.s, z26.s, #0x60006000\n+    __ sve_eor(z8, __ S, 4290777087u);                 \/\/       eor     z8.s, z8.s, #0xffc00fff\n+    __ sve_orr(z5, __ S, 3758096384u);                 \/\/       orr     z5.s, z5.s, #0xe0000000\n@@ -1142,5 +1151,5 @@\n-    __ sve_add(z19, __ S, 148u);                       \/\/       add     z19.s, z19.s, #0x94\n-    __ sve_sub(z22, __ S, 244u);                       \/\/       sub     z22.s, z22.s, #0xf4\n-    __ sve_and(z20, __ S, 491520u);                    \/\/       and     z20.s, z20.s, #0x78000\n-    __ sve_eor(z17, __ D, 18302628885642084351u);      \/\/       eor     z17.d, z17.d, #0xfe000000007fffff\n-    __ sve_orr(z4, __ D, 18158513714670600195u);       \/\/       orr     z4.d, z4.d, #0xfc000003fc000003\n+    __ sve_add(z22, __ S, 244u);                       \/\/       add     z22.s, z22.s, #0xf4\n+    __ sve_sub(z20, __ S, 3u);                         \/\/       sub     z20.s, z20.s, #0x3\n+    __ sve_and(z4, __ S, 491520u);                     \/\/       and     z4.s, z4.s, #0x78000\n+    __ sve_eor(z19, __ B, 239u);                       \/\/       eor     z19.b, z19.b, #0xef\n+    __ sve_orr(z19, __ B, 96u);                        \/\/       orr     z19.b, z19.b, #0x60\n@@ -1149,54 +1158,54 @@\n-    __ sve_add(z2, __ H, z8, z8);                      \/\/       add     z2.h, z8.h, z8.h\n-    __ sve_sub(z24, __ S, z17, z30);                   \/\/       sub     z24.s, z17.s, z30.s\n-    __ sve_fadd(z4, __ S, z30, z1);                    \/\/       fadd    z4.s, z30.s, z1.s\n-    __ sve_fmul(z19, __ S, z12, z0);                   \/\/       fmul    z19.s, z12.s, z0.s\n-    __ sve_fsub(z7, __ S, z24, z17);                   \/\/       fsub    z7.s, z24.s, z17.s\n-    __ sve_abs(z27, __ D, p1, z9);                     \/\/       abs     z27.d, p1\/m, z9.d\n-    __ sve_add(z23, __ D, p3, z16);                    \/\/       add     z23.d, p3\/m, z23.d, z16.d\n-    __ sve_and(z22, __ D, p5, z20);                    \/\/       and     z22.d, p5\/m, z22.d, z20.d\n-    __ sve_asr(z28, __ S, p2, z13);                    \/\/       asr     z28.s, p2\/m, z28.s, z13.s\n-    __ sve_bic(z7, __ H, p5, z28);                     \/\/       bic     z7.h, p5\/m, z7.h, z28.h\n-    __ sve_clz(z11, __ S, p3, z11);                    \/\/       clz     z11.s, p3\/m, z11.s\n-    __ sve_cnt(z1, __ S, p6, z8);                      \/\/       cnt     z1.s, p6\/m, z8.s\n-    __ sve_eor(z13, __ S, p4, z17);                    \/\/       eor     z13.s, p4\/m, z13.s, z17.s\n-    __ sve_lsl(z4, __ H, p0, z3);                      \/\/       lsl     z4.h, p0\/m, z4.h, z3.h\n-    __ sve_lsr(z7, __ S, p3, z14);                     \/\/       lsr     z7.s, p3\/m, z7.s, z14.s\n-    __ sve_mul(z4, __ B, p3, z29);                     \/\/       mul     z4.b, p3\/m, z4.b, z29.b\n-    __ sve_neg(z0, __ D, p2, z21);                     \/\/       neg     z0.d, p2\/m, z21.d\n-    __ sve_not(z3, __ S, p0, z9);                      \/\/       not     z3.s, p0\/m, z9.s\n-    __ sve_orr(z28, __ B, p2, z24);                    \/\/       orr     z28.b, p2\/m, z28.b, z24.b\n-    __ sve_rbit(z19, __ D, p1, z23);                   \/\/       rbit    z19.d, p1\/m, z23.d\n-    __ sve_revb(z13, __ D, p5, z10);                   \/\/       revb    z13.d, p5\/m, z10.d\n-    __ sve_smax(z12, __ S, p4, z30);                   \/\/       smax    z12.s, p4\/m, z12.s, z30.s\n-    __ sve_smin(z14, __ S, p0, z29);                   \/\/       smin    z14.s, p0\/m, z14.s, z29.s\n-    __ sve_sub(z21, __ S, p5, z7);                     \/\/       sub     z21.s, p5\/m, z21.s, z7.s\n-    __ sve_fabs(z2, __ D, p0, z26);                    \/\/       fabs    z2.d, p0\/m, z26.d\n-    __ sve_fadd(z9, __ D, p4, z17);                    \/\/       fadd    z9.d, p4\/m, z9.d, z17.d\n-    __ sve_fdiv(z0, __ D, p1, z2);                     \/\/       fdiv    z0.d, p1\/m, z0.d, z2.d\n-    __ sve_fmax(z14, __ D, p1, z11);                   \/\/       fmax    z14.d, p1\/m, z14.d, z11.d\n-    __ sve_fmin(z14, __ S, p4, z29);                   \/\/       fmin    z14.s, p4\/m, z14.s, z29.s\n-    __ sve_fmul(z3, __ S, p0, z22);                    \/\/       fmul    z3.s, p0\/m, z3.s, z22.s\n-    __ sve_fneg(z3, __ S, p6, z27);                    \/\/       fneg    z3.s, p6\/m, z27.s\n-    __ sve_frintm(z19, __ D, p5, z7);                  \/\/       frintm  z19.d, p5\/m, z7.d\n-    __ sve_frintn(z21, __ S, p3, z5);                  \/\/       frintn  z21.s, p3\/m, z5.s\n-    __ sve_frintp(z25, __ D, p1, z21);                 \/\/       frintp  z25.d, p1\/m, z21.d\n-    __ sve_fsqrt(z17, __ S, p0, z3);                   \/\/       fsqrt   z17.s, p0\/m, z3.s\n-    __ sve_fsub(z19, __ S, p3, z7);                    \/\/       fsub    z19.s, p3\/m, z19.s, z7.s\n-    __ sve_fmad(z14, __ S, p4, z17, z11);              \/\/       fmad    z14.s, p4\/m, z17.s, z11.s\n-    __ sve_fmla(z24, __ S, p4, z30, z17);              \/\/       fmla    z24.s, p4\/m, z30.s, z17.s\n-    __ sve_fmls(z15, __ D, p3, z26, z22);              \/\/       fmls    z15.d, p3\/m, z26.d, z22.d\n-    __ sve_fmsb(z22, __ D, p2, z8, z5);                \/\/       fmsb    z22.d, p2\/m, z8.d, z5.d\n-    __ sve_fnmad(z27, __ D, p2, z0, z14);              \/\/       fnmad   z27.d, p2\/m, z0.d, z14.d\n-    __ sve_fnmsb(z21, __ D, p5, z0, z3);               \/\/       fnmsb   z21.d, p5\/m, z0.d, z3.d\n-    __ sve_fnmla(z25, __ D, p1, z25, z29);             \/\/       fnmla   z25.d, p1\/m, z25.d, z29.d\n-    __ sve_fnmls(z17, __ D, p0, z12, z14);             \/\/       fnmls   z17.d, p0\/m, z12.d, z14.d\n-    __ sve_mla(z13, __ D, p0, z17, z2);                \/\/       mla     z13.d, p0\/m, z17.d, z2.d\n-    __ sve_mls(z20, __ H, p5, z21, z29);               \/\/       mls     z20.h, p5\/m, z21.h, z29.h\n-    __ sve_and(z8, z2, z0);                            \/\/       and     z8.d, z2.d, z0.d\n-    __ sve_eor(z23, z22, z0);                          \/\/       eor     z23.d, z22.d, z0.d\n-    __ sve_orr(z25, z26, z23);                         \/\/       orr     z25.d, z26.d, z23.d\n-    __ sve_bic(z21, z21, z1);                          \/\/       bic     z21.d, z21.d, z1.d\n-    __ sve_uzp1(z10, __ S, z19, z11);                  \/\/       uzp1    z10.s, z19.s, z11.s\n-    __ sve_uzp2(z23, __ D, z23, z8);                   \/\/       uzp2    z23.d, z23.d, z8.d\n-    __ sve_bext(z17, __ S, z19, z19);                  \/\/       bext    z17.s, z19.s, z19.s\n-    __ sve_bdep(z4, __ D, z20, z13);                   \/\/       bdep    z4.d, z20.d, z13.d\n+    __ sve_add(z14, __ D, z24, z17);                   \/\/       add     z14.d, z24.d, z17.d\n+    __ sve_sub(z21, __ B, z4, z30);                    \/\/       sub     z21.b, z4.b, z30.b\n+    __ sve_fadd(z10, __ S, z19, z12);                  \/\/       fadd    z10.s, z19.s, z12.s\n+    __ sve_fmul(z9, __ D, z7, z24);                    \/\/       fmul    z9.d, z7.d, z24.d\n+    __ sve_fsub(z4, __ S, z27, z6);                    \/\/       fsub    z4.s, z27.s, z6.s\n+    __ sve_abs(z27, __ S, p6, z13);                    \/\/       abs     z27.s, p6\/m, z13.s\n+    __ sve_add(z30, __ S, p5, z22);                    \/\/       add     z30.s, p5\/m, z30.s, z22.s\n+    __ sve_and(z30, __ H, p7, z9);                     \/\/       and     z30.h, p7\/m, z30.h, z9.h\n+    __ sve_asr(z19, __ D, p1, z20);                    \/\/       asr     z19.d, p1\/m, z19.d, z20.d\n+    __ sve_bic(z9, __ H, p2, z13);                     \/\/       bic     z9.h, p2\/m, z9.h, z13.h\n+    __ sve_clz(z19, __ H, p0, z24);                    \/\/       clz     z19.h, p0\/m, z24.h\n+    __ sve_cnt(z19, __ S, p3, z17);                    \/\/       cnt     z19.s, p3\/m, z17.s\n+    __ sve_eor(z16, __ B, p1, z0);                     \/\/       eor     z16.b, p1\/m, z16.b, z0.b\n+    __ sve_lsl(z11, __ H, p2, z15);                    \/\/       lsl     z11.h, p2\/m, z11.h, z15.h\n+    __ sve_lsr(z15, __ D, p1, z15);                    \/\/       lsr     z15.d, p1\/m, z15.d, z15.d\n+    __ sve_mul(z5, __ S, p0, z10);                     \/\/       mul     z5.s, p0\/m, z5.s, z10.s\n+    __ sve_neg(z26, __ H, p0, z0);                     \/\/       neg     z26.h, p0\/m, z0.h\n+    __ sve_not(z19, __ D, p7, z10);                    \/\/       not     z19.d, p7\/m, z10.d\n+    __ sve_orr(z3, __ D, p5, z7);                      \/\/       orr     z3.d, p5\/m, z3.d, z7.d\n+    __ sve_rbit(z28, __ H, p3, z21);                   \/\/       rbit    z28.h, p3\/m, z21.h\n+    __ sve_revb(z26, __ D, p3, z17);                   \/\/       revb    z26.d, p3\/m, z17.d\n+    __ sve_smax(z17, __ D, p3, z2);                    \/\/       smax    z17.d, p3\/m, z17.d, z2.d\n+    __ sve_smin(z16, __ B, p5, z20);                   \/\/       smin    z16.b, p5\/m, z16.b, z20.b\n+    __ sve_sub(z19, __ D, p0, z1);                     \/\/       sub     z19.d, p0\/m, z19.d, z1.d\n+    __ sve_fabs(z17, __ D, p2, z16);                   \/\/       fabs    z17.d, p2\/m, z16.d\n+    __ sve_fadd(z21, __ S, p0, z4);                    \/\/       fadd    z21.s, p0\/m, z21.s, z4.s\n+    __ sve_fdiv(z23, __ S, p3, z6);                    \/\/       fdiv    z23.s, p3\/m, z23.s, z6.s\n+    __ sve_fmax(z20, __ D, p3, z16);                   \/\/       fmax    z20.d, p3\/m, z20.d, z16.d\n+    __ sve_fmin(z12, __ D, p0, z3);                    \/\/       fmin    z12.d, p0\/m, z12.d, z3.d\n+    __ sve_fmul(z9, __ D, p0, z24);                    \/\/       fmul    z9.d, p0\/m, z9.d, z24.d\n+    __ sve_fneg(z3, __ S, p4, z22);                    \/\/       fneg    z3.s, p4\/m, z22.s\n+    __ sve_frintm(z25, __ S, p5, z13);                 \/\/       frintm  z25.s, p5\/m, z13.s\n+    __ sve_frintn(z7, __ D, p6, z5);                   \/\/       frintn  z7.d, p6\/m, z5.d\n+    __ sve_frintp(z17, __ S, p4, z0);                  \/\/       frintp  z17.s, p4\/m, z0.s\n+    __ sve_fsqrt(z9, __ S, p5, z11);                   \/\/       fsqrt   z9.s, p5\/m, z11.s\n+    __ sve_fsub(z11, __ D, p3, z17);                   \/\/       fsub    z11.d, p3\/m, z11.d, z17.d\n+    __ sve_fmad(z11, __ D, p3, z24, z17);              \/\/       fmad    z11.d, p3\/m, z24.d, z17.d\n+    __ sve_fmla(z17, __ D, p2, z15, z14);              \/\/       fmla    z17.d, p2\/m, z15.d, z14.d\n+    __ sve_fmls(z22, __ S, p7, z22, z7);               \/\/       fmls    z22.s, p7\/m, z22.s, z7.s\n+    __ sve_fmsb(z5, __ S, p7, z27, z10);               \/\/       fmsb    z5.s, p7\/m, z27.s, z10.s\n+    __ sve_fnmad(z14, __ S, p6, z21, z20);             \/\/       fnmad   z14.s, p6\/m, z21.s, z20.s\n+    __ sve_fnmsb(z3, __ D, p5, z25, z5);               \/\/       fnmsb   z3.d, p5\/m, z25.d, z5.d\n+    __ sve_fnmla(z29, __ S, p4, z17, z1);              \/\/       fnmla   z29.s, p4\/m, z17.s, z1.s\n+    __ sve_fnmls(z14, __ D, p7, z13, z0);              \/\/       fnmls   z14.d, p7\/m, z13.d, z0.d\n+    __ sve_mla(z2, __ S, p7, z20, z22);                \/\/       mla     z2.s, p7\/m, z20.s, z22.s\n+    __ sve_mls(z29, __ B, p3, z8, z2);                 \/\/       mls     z29.b, p3\/m, z8.b, z2.b\n+    __ sve_and(z14, z23, z22);                         \/\/       and     z14.d, z23.d, z22.d\n+    __ sve_eor(z19, z25, z26);                         \/\/       eor     z19.d, z25.d, z26.d\n+    __ sve_orr(z12, z21, z21);                         \/\/       orr     z12.d, z21.d, z21.d\n+    __ sve_bic(z1, z10, z19);                          \/\/       bic     z1.d, z10.d, z19.d\n+    __ sve_uzp1(z19, __ H, z23, z23);                  \/\/       uzp1    z19.h, z23.h, z23.h\n+    __ sve_uzp2(z30, __ S, z17, z19);                  \/\/       uzp2    z30.s, z17.s, z19.s\n+    __ sve_bext(z20, __ H, z4, z20);                   \/\/       bext    z20.h, z4.h, z20.h\n+    __ sve_bdep(z30, __ D, z22, z30);                  \/\/       bdep    z30.d, z22.d, z30.d\n@@ -1205,9 +1214,9 @@\n-    __ sve_andv(v22, __ D, p7, z30);                   \/\/       andv d22, p7, z30.d\n-    __ sve_orv(v17, __ H, p4, z14);                    \/\/       orv h17, p4, z14.h\n-    __ sve_eorv(v12, __ B, p7, z20);                   \/\/       eorv b12, p7, z20.b\n-    __ sve_smaxv(v1, __ B, p3, z13);                   \/\/       smaxv b1, p3, z13.b\n-    __ sve_sminv(v7, __ S, p2, z11);                   \/\/       sminv s7, p2, z11.s\n-    __ sve_fminv(v4, __ S, p6, z15);                   \/\/       fminv s4, p6, z15.s\n-    __ sve_fmaxv(v3, __ D, p7, z0);                    \/\/       fmaxv d3, p7, z0.d\n-    __ sve_fadda(v5, __ D, p5, z30);                   \/\/       fadda d5, p5, d5, z30.d\n-    __ sve_uaddv(v13, __ H, p3, z8);                   \/\/       uaddv d13, p3, z8.h\n+    __ sve_andv(v25, __ H, p4, z17);                   \/\/       andv h25, p4, z17.h\n+    __ sve_orv(v11, __ S, p3, z28);                    \/\/       orv s11, p3, z28.s\n+    __ sve_eorv(v5, __ H, p0, z13);                    \/\/       eorv h5, p0, z13.h\n+    __ sve_smaxv(v2, __ H, p1, z10);                   \/\/       smaxv h2, p1, z10.h\n+    __ sve_sminv(v19, __ H, p1, z25);                  \/\/       sminv h19, p1, z25.h\n+    __ sve_fminv(v2, __ S, p0, z29);                   \/\/       fminv s2, p0, z29.s\n+    __ sve_fmaxv(v20, __ D, p1, z20);                  \/\/       fmaxv d20, p1, z20.d\n+    __ sve_fadda(v28, __ S, p3, z13);                  \/\/       fadda s28, p3, s28, z13.s\n+    __ sve_uaddv(v13, __ H, p7, z1);                   \/\/       uaddv d13, p7, z1.h\n@@ -1232,7 +1241,7 @@\n-    0x14000000,     0x17ffffd7,     0x140003f5,     0x94000000,\n-    0x97ffffd4,     0x940003f2,     0x3400000a,     0x34fffa2a,\n-    0x34007dea,     0x35000008,     0x35fff9c8,     0x35007d88,\n-    0xb400000b,     0xb4fff96b,     0xb4007d2b,     0xb500001d,\n-    0xb5fff91d,     0xb5007cdd,     0x10000013,     0x10fff8b3,\n-    0x10007c73,     0x90000013,     0x36300016,     0x3637f836,\n-    0x36307bf6,     0x3758000c,     0x375ff7cc,     0x37587b8c,\n+    0x14000000,     0x17ffffd7,     0x140003fe,     0x94000000,\n+    0x97ffffd4,     0x940003fb,     0x3400000a,     0x34fffa2a,\n+    0x34007f0a,     0x35000008,     0x35fff9c8,     0x35007ea8,\n+    0xb400000b,     0xb4fff96b,     0xb4007e4b,     0xb500001d,\n+    0xb5fff91d,     0xb5007dfd,     0x10000013,     0x10fff8b3,\n+    0x10007d93,     0x90000013,     0x36300016,     0x3637f836,\n+    0x36307d16,     0x3758000c,     0x375ff7cc,     0x37587cac,\n@@ -1243,13 +1252,13 @@\n-    0x54007960,     0x54000001,     0x54fff541,     0x54007901,\n-    0x54000002,     0x54fff4e2,     0x540078a2,     0x54000002,\n-    0x54fff482,     0x54007842,     0x54000003,     0x54fff423,\n-    0x540077e3,     0x54000003,     0x54fff3c3,     0x54007783,\n-    0x54000004,     0x54fff364,     0x54007724,     0x54000005,\n-    0x54fff305,     0x540076c5,     0x54000006,     0x54fff2a6,\n-    0x54007666,     0x54000007,     0x54fff247,     0x54007607,\n-    0x54000008,     0x54fff1e8,     0x540075a8,     0x54000009,\n-    0x54fff189,     0x54007549,     0x5400000a,     0x54fff12a,\n-    0x540074ea,     0x5400000b,     0x54fff0cb,     0x5400748b,\n-    0x5400000c,     0x54fff06c,     0x5400742c,     0x5400000d,\n-    0x54fff00d,     0x540073cd,     0x5400000e,     0x54ffefae,\n-    0x5400736e,     0x5400000f,     0x54ffef4f,     0x5400730f,\n+    0x54007a80,     0x54000001,     0x54fff541,     0x54007a21,\n+    0x54000002,     0x54fff4e2,     0x540079c2,     0x54000002,\n+    0x54fff482,     0x54007962,     0x54000003,     0x54fff423,\n+    0x54007903,     0x54000003,     0x54fff3c3,     0x540078a3,\n+    0x54000004,     0x54fff364,     0x54007844,     0x54000005,\n+    0x54fff305,     0x540077e5,     0x54000006,     0x54fff2a6,\n+    0x54007786,     0x54000007,     0x54fff247,     0x54007727,\n+    0x54000008,     0x54fff1e8,     0x540076c8,     0x54000009,\n+    0x54fff189,     0x54007669,     0x5400000a,     0x54fff12a,\n+    0x5400760a,     0x5400000b,     0x54fff0cb,     0x540075ab,\n+    0x5400000c,     0x54fff06c,     0x5400754c,     0x5400000d,\n+    0x54fff00d,     0x540074ed,     0x5400000e,     0x54ffefae,\n+    0x5400748e,     0x5400000f,     0x54ffef4f,     0x5400742f,\n@@ -1381,105 +1390,108 @@\n-    0x6e30e5ee,     0x6e6fe5cd,     0x65d238c1,     0x65902498,\n-    0x65d03226,     0x65d13549,     0x65d13f36,     0x65d32147,\n-    0xba5fd3e3,     0x3a5f03e5,     0xfa411be4,     0x7a42cbe2,\n-    0x93df03ff,     0xc820ffff,     0x8822fc7f,     0xc8247cbf,\n-    0x88267fff,     0x4e010fe0,     0x5e040420,     0x4e081fe1,\n-    0x4e0c1fe1,     0x4e0a1fe1,     0x4e071fe1,     0x4e042c20,\n-    0x4e062c20,     0x4e052c20,     0x4e083c20,     0x0e0c3c20,\n-    0x0e0a3c20,     0x0e073c20,     0x9eae0020,     0x0f03f409,\n-    0x6f03f40e,     0x4cc0ac3f,     0x0ea1b820,     0x4e21c862,\n-    0x4e61b8a4,     0x05a08020,     0x05104fe0,     0x05505001,\n-    0x05906fe2,     0x05d03005,     0x05101fea,     0x05901feb,\n-    0x04b0e3e0,     0x0470e7e1,     0x042f9c20,     0x043f9c35,\n-    0x047f9c20,     0x04ff9c20,     0x04299420,     0x04319160,\n-    0x0461943e,     0x04a19020,     0x04038100,     0x040381a0,\n-    0x040387e1,     0x04438be2,     0x04c38fe3,     0x040181e0,\n-    0x04018100,     0x04018621,     0x04418b22,     0x04418822,\n-    0x04818c23,     0x040081e0,     0x04008120,     0x04008761,\n-    0x04008621,     0x04408822,     0x04808c23,     0x042053ff,\n-    0x047f5401,     0x25208028,     0x2538cfe0,     0x2578d001,\n-    0x25b8efe2,     0x25f8f007,     0x2538dfea,     0x25b8dfeb,\n-    0xa400a3e0,     0xa420a7e0,     0xa4484be0,     0xa467afe0,\n-    0xa4a8a7ea,     0xa547a814,     0xa4084ffe,     0xa55c53e0,\n-    0xa5e1540b,     0xe400fbf6,     0xe408ffff,     0xe420e7e0,\n-    0xe4484be0,     0xe460efe0,     0xe547e400,     0xe4014be0,\n-    0xe4a84fe0,     0xe5f15000,     0x858043e0,     0x85a043ff,\n-    0xe59f5d08,     0x0420e3e9,     0x0460e3ea,     0x04a0e3eb,\n-    0x04e0e3ec,     0x25104042,     0x25104871,     0x25904861,\n-    0x25904c92,     0x05344020,     0x05744041,     0x05b44062,\n-    0x05f44083,     0x252c8840,     0x253c1420,     0x25681572,\n-    0x25a21ce3,     0x25ea1e34,     0x253c0421,     0x25680572,\n-    0x25a20ce3,     0x25ea0e34,     0x0522c020,     0x05e6c0a4,\n-    0x2401a001,     0x2443a051,     0x24858881,     0x24c78cd1,\n-    0x24850891,     0x24c70cc1,     0x250f9001,     0x25508051,\n-    0x25802491,     0x25df28c1,     0x25850c81,     0x251e10d1,\n-    0x65816001,     0x65c36051,     0x65854891,     0x65c74cc1,\n-    0x05733820,     0x05b238a4,     0x05f138e6,     0x0570396a,\n-    0x65d0a001,     0x65d6a443,     0x65d4a826,     0x6594ac26,\n-    0x6554ac26,     0x6556ac26,     0x6552ac26,     0x65cbac85,\n-    0x65caac01,     0x65dea833,     0x659ca509,     0x65d8a801,\n-    0x65dcac01,     0x655cb241,     0x0520a1e0,     0x0521a601,\n-    0x052281e0,     0x05238601,     0x04a14026,     0x042244a6,\n-    0x046344a6,     0x04a444a6,     0x04e544a7,     0x0568aca7,\n-    0x05b23230,     0x853040af,     0xc5b040af,     0xe57080af,\n-    0xe5b080af,     0x25034440,     0x254054c4,     0x25034640,\n-    0x25415a05,     0x25834440,     0x25c54489,     0x250b5d3a,\n-    0x2550dc20,     0x2518e3e1,     0x2518e021,     0x2518e0a1,\n-    0x2518e121,     0x2518e1a1,     0x2558e3e2,     0x2558e042,\n-    0x2558e0c2,     0x2558e142,     0x2598e3e3,     0x2598e063,\n-    0x2598e0e3,     0x2598e163,     0x25d8e3e4,     0x25d8e084,\n-    0x25d8e104,     0x25d8e184,     0x2518e407,     0x05214800,\n-    0x05614800,     0x05a14800,     0x05e14800,     0x05214c00,\n-    0x05614c00,     0x05a14c00,     0x05e14c00,     0x05304001,\n-    0x05314001,     0x05a18610,     0x05e18610,     0x05271e11,\n-    0x45b0c210,     0x45f1c231,     0x1e601000,     0x1e603000,\n-    0x1e621000,     0x1e623000,     0x1e641000,     0x1e643000,\n-    0x1e661000,     0x1e663000,     0x1e681000,     0x1e683000,\n-    0x1e6a1000,     0x1e6a3000,     0x1e6c1000,     0x1e6c3000,\n-    0x1e6e1000,     0x1e6e3000,     0x1e701000,     0x1e703000,\n-    0x1e721000,     0x1e723000,     0x1e741000,     0x1e743000,\n-    0x1e761000,     0x1e763000,     0x1e781000,     0x1e783000,\n-    0x1e7a1000,     0x1e7a3000,     0x1e7c1000,     0x1e7c3000,\n-    0x1e7e1000,     0x1e7e3000,     0xf82c815f,     0xf8300047,\n-    0xf823126d,     0xf8312070,     0xf82133cb,     0xf82551e8,\n-    0xf83d401e,     0xf8347287,     0xf83762bc,     0xf8bb80b9,\n-    0xf8a10217,     0xf8bf1185,     0xf8a921fc,     0xf8bd33f6,\n-    0xf8b350bf,     0xf8ae43f0,     0xf8b0729b,     0xf8b0616c,\n-    0xf8e983c6,     0xf8f1039b,     0xf8fe1147,     0xf8f4208a,\n-    0xf8f83231,     0xf8f653a3,     0xf8ef4276,     0xf8f37056,\n-    0xf8ef6186,     0xf87081ab,     0xf87703c1,     0xf8731225,\n-    0xf86222d0,     0xf86d32aa,     0xf87d519b,     0xf87b4023,\n-    0xf87f7278,     0xf8716389,     0xb83b80ef,     0xb83503f7,\n-    0xb83913e2,     0xb83b2150,     0xb8373073,     0xb8305320,\n-    0xb83a4057,     0xb830708c,     0xb83c63be,     0xb8b080db,\n-    0xb8a901fd,     0xb8a710e4,     0xb8af22e9,     0xb8a83382,\n-    0xb8b550bf,     0xb8bb4220,     0xb8af7344,     0xb8a862dc,\n-    0xb8fb833b,     0xb8f70080,     0xb8e61010,     0xb8e4202f,\n-    0xb8ea30a7,     0xb8ea50fc,     0xb8f442b7,     0xb8e6710b,\n-    0xb8f160df,     0xb8718182,     0xb87e007d,     0xb87b13b6,\n-    0xb86e238d,     0xb87130b8,     0xb862514e,     0xb870436b,\n-    0xb877708c,     0xb8766091,     0xce304661,     0xce0c09cc,\n-    0xce748c70,     0xce863cb7,     0xce7b8191,     0xce668610,\n-    0xcec08382,     0xce668883,     0x25a0cdd1,     0x25a1c86c,\n-    0x058000b8,     0x054242ca,     0x0500051e,     0x2520cf00,\n-    0x25e1c951,     0x058039ea,     0x05400e1b,     0x05009891,\n-    0x2520c09c,     0x25a1d448,     0x05801e36,     0x05400516,\n-    0x050039fe,     0x2520ce0b,     0x25a1d0c8,     0x058074d9,\n-    0x05404531,     0x05031e84,     0x2560cf1a,     0x2561dda2,\n-    0x058026a3,     0x05404c35,     0x05007851,     0x25a0d293,\n-    0x25a1de96,     0x05808874,     0x05423bb1,     0x050030e4,\n-    0x04680102,     0x04be0638,     0x658103c4,     0x65800993,\n-    0x65910707,     0x04d6a53b,     0x04c00e17,     0x04da1696,\n-    0x049089bc,     0x045b1787,     0x0499ad6b,     0x049ab901,\n-    0x0499122d,     0x04538064,     0x04918dc7,     0x04100fa4,\n-    0x04d7aaa0,     0x049ea123,     0x04180b1c,     0x05e786f3,\n-    0x05e4954d,     0x048813cc,     0x048a03ae,     0x048114f5,\n-    0x04dca342,     0x65c09229,     0x65cd8440,     0x65c6856e,\n-    0x658793ae,     0x658282c3,     0x049dbb63,     0x65c2b4f3,\n-    0x6580acb5,     0x65c1a6b9,     0x658da071,     0x65818cf3,\n-    0x65ab922e,     0x65b113d8,     0x65f62f4f,     0x65e5a916,\n-    0x65eec81b,     0x65e3f415,     0x65fd4739,     0x65ee6191,\n-    0x04c2422d,     0x045d76b4,     0x04203048,     0x04a032d7,\n-    0x04773359,     0x04e132b5,     0x05ab6a6a,     0x05e86ef7,\n-    0x4593b271,     0x45cdb684,     0x04da3fd6,     0x045831d1,\n-    0x04193e8c,     0x04082da1,     0x048a2967,     0x658739e4,\n-    0x65c63c03,     0x65d837c5,     0x04412d0d,\n+    0x6e30e5ee,     0x6e6fe5cd,     0x2ea4ec62,     0x6ea8ece6,\n+    0x6ef5ee93,     0x659221ed,     0x65d03572,     0x65903628,\n+    0x65d1358b,     0x659139de,     0x65d32960,     0xba5fd3e3,\n+    0x3a5f03e5,     0xfa411be4,     0x7a42cbe2,     0x93df03ff,\n+    0xc820ffff,     0x8822fc7f,     0xc8247cbf,     0x88267fff,\n+    0x4e010fe0,     0x5e040420,     0x4e081fe1,     0x4e0c1fe1,\n+    0x4e0a1fe1,     0x4e071fe1,     0x4e042c20,     0x4e062c20,\n+    0x4e052c20,     0x4e083c20,     0x0e0c3c20,     0x0e0a3c20,\n+    0x0e073c20,     0x9eae0020,     0x0f03f409,     0x6f03f40e,\n+    0x4cc0ac3f,     0x0ea1b820,     0x4e21c862,     0x4e61b8a4,\n+    0x05a08020,     0x05104fe0,     0x05505001,     0x05906fe2,\n+    0x05d03005,     0x05101fea,     0x05901feb,     0x04b0e3e0,\n+    0x0470e7e1,     0x042f9c20,     0x043f9c35,     0x047f9c20,\n+    0x04ff9c20,     0x04299420,     0x04319160,     0x0461943e,\n+    0x04a19020,     0x04038100,     0x040381a0,     0x040387e1,\n+    0x04438be2,     0x04c38fe3,     0x040181e0,     0x04018100,\n+    0x04018621,     0x04418b22,     0x04418822,     0x04818c23,\n+    0x040081e0,     0x04008120,     0x04008761,     0x04008621,\n+    0x04408822,     0x04808c23,     0x042053ff,     0x047f5401,\n+    0x25208028,     0x2538cfe0,     0x2578d001,     0x25b8efe2,\n+    0x25f8f007,     0x2538dfea,     0x25b8dfeb,     0xa400a3e0,\n+    0xa420a7e0,     0xa4484be0,     0xa467afe0,     0xa4a8a7ea,\n+    0xa547a814,     0xa4084ffe,     0xa55c53e0,     0xa5e1540b,\n+    0xe400fbf6,     0xe408ffff,     0xe420e7e0,     0xe4484be0,\n+    0xe460efe0,     0xe547e400,     0xe4014be0,     0xe4a84fe0,\n+    0xe5f15000,     0x858043e0,     0x85a043ff,     0xe59f5d08,\n+    0x0420e3e9,     0x0460e3ea,     0x04a0e3eb,     0x04e0e3ec,\n+    0x25104042,     0x25104871,     0x25904861,     0x25904c92,\n+    0x05344020,     0x05744041,     0x05b44062,     0x05f44083,\n+    0x252c8840,     0x253c1420,     0x25681572,     0x25a21ce3,\n+    0x25ea1e34,     0x253c0421,     0x25680572,     0x25a20ce3,\n+    0x25ea0e34,     0x0522c020,     0x05e6c0a4,     0x2401a001,\n+    0x2443a051,     0x24858881,     0x24c78cd1,     0x24850891,\n+    0x24c70cc1,     0x250f9001,     0x25508051,     0x25802491,\n+    0x25df28c1,     0x25850c81,     0x251e10d1,     0x65816001,\n+    0x65c36051,     0x65854891,     0x65c74cc1,     0x05733820,\n+    0x05b238a4,     0x05f138e6,     0x0570396a,     0x65d0a001,\n+    0x65d6a443,     0x65d4a826,     0x6594ac26,     0x6554ac26,\n+    0x6556ac26,     0x6552ac26,     0x65cbac85,     0x65caac01,\n+    0x65dea833,     0x659ca509,     0x65d8a801,     0x65dcac01,\n+    0x655cb241,     0x0520a1e0,     0x0521a601,     0x052281e0,\n+    0x05238601,     0x04a14026,     0x042244a6,     0x046344a6,\n+    0x04a444a6,     0x04e544a7,     0x0568aca7,     0x05b23230,\n+    0x853040af,     0xc5b040af,     0xe57080af,     0xe5b080af,\n+    0x25034440,     0x254054c4,     0x25034640,     0x25415a05,\n+    0x25834440,     0x25c54489,     0x250b5d3a,     0x2550dc20,\n+    0x2518e3e1,     0x2518e021,     0x2518e0a1,     0x2518e121,\n+    0x2518e1a1,     0x2558e3e2,     0x2558e042,     0x2558e0c2,\n+    0x2558e142,     0x2598e3e3,     0x2598e063,     0x2598e0e3,\n+    0x2598e163,     0x25d8e3e4,     0x25d8e084,     0x25d8e104,\n+    0x25d8e184,     0x2518e407,     0x05214800,     0x05614800,\n+    0x05a14800,     0x05e14800,     0x05214c00,     0x05614c00,\n+    0x05a14c00,     0x05e14c00,     0x05304001,     0x05314001,\n+    0x05a18610,     0x05e18610,     0x05271e11,     0x6545e891,\n+    0x6585e891,     0x65c5e891,     0x6545c891,     0x6585c891,\n+    0x65c5c891,     0x45b0c210,     0x45f1c231,     0x1e601000,\n+    0x1e603000,     0x1e621000,     0x1e623000,     0x1e641000,\n+    0x1e643000,     0x1e661000,     0x1e663000,     0x1e681000,\n+    0x1e683000,     0x1e6a1000,     0x1e6a3000,     0x1e6c1000,\n+    0x1e6c3000,     0x1e6e1000,     0x1e6e3000,     0x1e701000,\n+    0x1e703000,     0x1e721000,     0x1e723000,     0x1e741000,\n+    0x1e743000,     0x1e761000,     0x1e763000,     0x1e781000,\n+    0x1e783000,     0x1e7a1000,     0x1e7a3000,     0x1e7c1000,\n+    0x1e7c3000,     0x1e7e1000,     0x1e7e3000,     0xf8308047,\n+    0xf823026d,     0xf8311070,     0xf82123cb,     0xf82531e8,\n+    0xf83d501e,     0xf8344287,     0xf83772bc,     0xf83b60b9,\n+    0xf8a18217,     0xf8bf0185,     0xf8a911fc,     0xf8bd23f6,\n+    0xf8b330bf,     0xf8ae53f0,     0xf8b0429b,     0xf8b0716c,\n+    0xf8a963c6,     0xf8f1839b,     0xf8fe0147,     0xf8f4108a,\n+    0xf8f82231,     0xf8f633a3,     0xf8ef5276,     0xf8f34056,\n+    0xf8ef7186,     0xf8f061ab,     0xf87783c1,     0xf8730225,\n+    0xf86212d0,     0xf86d22aa,     0xf87d319b,     0xf87b5023,\n+    0xf87f4278,     0xf8717389,     0xf87b60ef,     0xb83583f7,\n+    0xb83903e2,     0xb83b1150,     0xb8372073,     0xb8303320,\n+    0xb83a5057,     0xb830408c,     0xb83c73be,     0xb83060db,\n+    0xb8a981fd,     0xb8a700e4,     0xb8af12e9,     0xb8a82382,\n+    0xb8b530bf,     0xb8bb5220,     0xb8af4344,     0xb8a872dc,\n+    0xb8bb633b,     0xb8f78080,     0xb8e60010,     0xb8e4102f,\n+    0xb8ea20a7,     0xb8ea30fc,     0xb8f452b7,     0xb8e6410b,\n+    0xb8f170df,     0xb8f16182,     0xb87e807d,     0xb87b03b6,\n+    0xb86e138d,     0xb87120b8,     0xb862314e,     0xb870536b,\n+    0xb877408c,     0xb8767091,     0xb8616213,     0xce2e3191,\n+    0xce035202,     0xce668cb7,     0xce8ce227,     0xce668210,\n+    0xce638782,     0xcec080c4,     0xce6d8a71,     0x25a0c86c,\n+    0x25a1d358,     0x05800500,     0x05400ad3,     0x05000e06,\n+    0x25e0c951,     0x25a1d54a,     0x05839276,     0x0540ea6f,\n+    0x0503c8a4,     0x25a0d448,     0x2521d056,     0x058059c9,\n+    0x05406d05,     0x05003cb6,     0x25a0d0c8,     0x2561c4f9,\n+    0x05809904,     0x05400e5d,     0x0500cadd,     0x2560dda2,\n+    0x2521c143,     0x05801c3a,     0x054052a8,     0x05001845,\n+    0x25a0de96,     0x25a1c074,     0x05808864,     0x05401ed3,\n+    0x05001e33,     0x04f1030e,     0x043e0495,     0x658c026a,\n+    0x65d808e9,     0x65860764,     0x0496b9bb,     0x048016de,\n+    0x045a1d3e,     0x04d08693,     0x045b09a9,     0x0459a313,\n+    0x049aae33,     0x04190410,     0x045389eb,     0x04d185ef,\n+    0x04900145,     0x0457a01a,     0x04debd53,     0x04d814e3,\n+    0x05678ebc,     0x05e48e3a,     0x04c80c51,     0x040a1690,\n+    0x04c10033,     0x04dcaa11,     0x65808095,     0x658d8cd7,\n+    0x65c68e14,     0x65c7806c,     0x65c28309,     0x049db2c3,\n+    0x6582b5b9,     0x65c0b8a7,     0x6581b011,     0x658db569,\n+    0x65c18e2b,     0x65f18f0b,     0x65ee09f1,     0x65a73ed6,\n+    0x65aabf65,     0x65b4daae,     0x65e5f723,     0x65a1523d,\n+    0x65e07dae,     0x04965e82,     0x04026d1d,     0x043632ee,\n+    0x04ba3333,     0x047532ac,     0x04f33141,     0x05776af3,\n+    0x05b36e3e,     0x4554b094,     0x45deb6de,     0x045a3239,\n+    0x04982f8b,     0x045921a5,     0x04482542,     0x044a2733,\n+    0x658723a2,     0x65c62694,     0x65982dbc,     0x04413c2d,\n+\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":316,"deletions":304,"binary":false,"changes":620,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -174,0 +174,17 @@\n+\n+TEST(PrimitiveConversionsTranslateTest, unscoped_enum) {\n+  enum TestEnum : int { A, B, C };\n+\n+  EXPECT_TRUE(PrimitiveConversions::Translate<TestEnum>::value);\n+  EXPECT_EQ(PrimitiveConversions::Translate<TestEnum>::decay(B), 1);\n+  EXPECT_EQ(PrimitiveConversions::Translate<TestEnum>::recover(1), B);\n+}\n+\n+TEST(PrimitiveConversionsTranslateTest, scoped_enum) {\n+  enum class TestEnum { A, B, C };\n+\n+  EXPECT_TRUE(PrimitiveConversions::Translate<TestEnum>::value);\n+  EXPECT_EQ(PrimitiveConversions::Translate<TestEnum>::decay(TestEnum::B), 1);\n+  EXPECT_EQ(PrimitiveConversions::Translate<TestEnum>::recover(1), TestEnum::B);\n+}\n+\n","filename":"test\/hotspot\/gtest\/metaprogramming\/test_primitiveConversions.cpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"services\/mallocTracker.hpp\"\n+#include \"services\/memTracker.hpp\"\n+#include \"unittest.hpp\"\n+\n+\/\/ convenience log. switch on if debugging tests. Don't use tty, plain stdio only.\n+#define LOG(...) { printf(__VA_ARGS__); printf(\"\\n\"); fflush(stdout); }\n+\/\/#define LOG(...)\n+\n+static size_t get_total_malloc_invocs() {\n+  return MallocMemorySummary::as_snapshot()->total_count();\n+}\n+\n+static size_t get_total_malloc_size() {\n+  return MallocMemorySummary::as_snapshot()->total();\n+}\n+\n+static size_t get_malloc_overhead() {\n+  return MallocMemorySummary::as_snapshot()->malloc_overhead();\n+}\n+\n+struct totals_t { size_t n; size_t s; size_t ovrh; };\n+\n+static totals_t get_totals() {\n+  totals_t tot;\n+  tot.n = get_total_malloc_invocs();\n+  tot.s = get_total_malloc_size();\n+  tot.ovrh = get_malloc_overhead();\n+  return tot;\n+}\n+\n+\/\/ Concurrent code can malloc and free too, therefore we need to compare with a leeway factor\n+#define compare_totals(t_real, t_expected) {                                  \\\n+  double leeway_factor = 0.33;                                                \\\n+  size_t leeway_n = (size_t)(((double)t_expected.n) * leeway_factor);         \\\n+  size_t leeway_s = (size_t)(((double)t_expected.s) * leeway_factor);         \\\n+  EXPECT_GE(t_real.n, t_expected.n - leeway_n);                               \\\n+  EXPECT_LE(t_real.n, t_expected.n + leeway_n);                               \\\n+  EXPECT_GE(t_real.s, t_expected.s - leeway_s);                               \\\n+  EXPECT_LE(t_real.s, t_expected.s + leeway_s);                               \\\n+  EXPECT_GE(t_real.ovrh, t_expected.ovrh - (leeway_n * sizeof(MallocHeader)));   \\\n+  EXPECT_LE(t_real.ovrh, t_expected.ovrh + (leeway_n * sizeof(MallocHeader)));   \\\n+  LOG(\"Deviation: n=\" SSIZE_FORMAT \", s=\" SSIZE_FORMAT \", ovrh=\" SSIZE_FORMAT,   \\\n+      (ssize_t)t_real.n - (ssize_t)t_expected.n,                                 \\\n+      (ssize_t)t_real.s - (ssize_t)t_expected.s,                                 \\\n+      (ssize_t)t_real.ovrh - (ssize_t)t_expected.ovrh);                          \\\n+}\n+\n+TEST_VM(NMTNumbers, totals) {\n+\n+  if (!MemTracker::enabled()) {\n+    \/\/ Skip test if NMT is disabled\n+    return;\n+  }\n+\n+  const totals_t t1 = get_totals();\n+\n+  LOG(\"t1: \" SIZE_FORMAT \" - \" SIZE_FORMAT \" - \" SIZE_FORMAT, t1.n, t1.s, t1.ovrh);\n+\n+  static const int NUM_ALLOCS = 1024 * 16;\n+  static const int ALLOC_SIZE = 1024;\n+\n+  void* p[NUM_ALLOCS];\n+  for (int i = 0; i < NUM_ALLOCS; i ++) {\n+    \/\/ spread over categories\n+    int category = i % (mt_number_of_types - 1);\n+    p[i] = NEW_C_HEAP_ARRAY(char, ALLOC_SIZE, (MEMFLAGS)category);\n+  }\n+\n+  const totals_t t2 = get_totals();\n+  LOG(\"t2: \" SIZE_FORMAT \" - \" SIZE_FORMAT \" - \" SIZE_FORMAT, t2.n, t2.s, t2.ovrh);\n+\n+  totals_t t2_expected;\n+  t2_expected.n = t1.n + NUM_ALLOCS;\n+  t2_expected.s = t1.s + ALLOC_SIZE * NUM_ALLOCS;\n+  t2_expected.ovrh = (t1.n + NUM_ALLOCS) * sizeof(MallocHeader);\n+\n+  LOG(\"t2 expected: \" SIZE_FORMAT \" - \" SIZE_FORMAT \" - \" SIZE_FORMAT, t2_expected.n, t2_expected.s, t2_expected.ovrh);\n+\n+  compare_totals(t2, t2_expected);\n+\n+  for (int i = 0; i < NUM_ALLOCS; i ++) {\n+    os::free(p[i]);\n+  }\n+\n+  const totals_t t3 = get_totals();\n+  LOG(\"t3: \" SIZE_FORMAT \" - \" SIZE_FORMAT \" - \" SIZE_FORMAT, t3.n, t3.s, t3.ovrh);\n+\n+  compare_totals(t3, t1);\n+\n+}\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_totals.cpp","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"unittest.hpp\"\n+\n+\/\/ These tests of Atomic only verify functionality.  They don't verify atomicity.\n+\n+template<typename T>\n+struct AtomicEnumTestSupport {\n+  volatile T _test_value;\n+\n+  AtomicEnumTestSupport() : _test_value{} {}\n+\n+  void test_store_load(T value) {\n+    EXPECT_NE(value, Atomic::load(&_test_value));\n+    Atomic::store(&_test_value, value);\n+    EXPECT_EQ(value, Atomic::load(&_test_value));\n+  }\n+\n+  void test_cmpxchg(T value1, T value2) {\n+    EXPECT_NE(value1, Atomic::load(&_test_value));\n+    Atomic::store(&_test_value, value1);\n+    EXPECT_EQ(value1, Atomic::cmpxchg(&_test_value, value2, value2));\n+    EXPECT_EQ(value1, Atomic::load(&_test_value));\n+    EXPECT_EQ(value1, Atomic::cmpxchg(&_test_value, value1, value2));\n+    EXPECT_EQ(value2, Atomic::load(&_test_value));\n+  }\n+\n+  void test_xchg(T value1, T value2) {\n+    EXPECT_NE(value1, Atomic::load(&_test_value));\n+    Atomic::store(&_test_value, value1);\n+    EXPECT_EQ(value1, Atomic::xchg(&_test_value, value2));\n+    EXPECT_EQ(value2, Atomic::load(&_test_value));\n+  }\n+};\n+\n+namespace AtomicEnumTestUnscoped {       \/\/ Scope the enumerators.\n+  enum TestEnum { A, B, C };\n+}\n+\n+TEST(AtomicEnumTest, unscoped_enum) {\n+  using namespace AtomicEnumTestUnscoped;\n+  using Support = AtomicEnumTestSupport<TestEnum>;\n+\n+  Support().test_store_load(B);\n+  Support().test_cmpxchg(B, C);\n+  Support().test_xchg(B, C);\n+}\n+\n+enum class AtomicEnumTestScoped { A, B, C };\n+\n+TEST(AtomicEnumTest, scoped_enum) {\n+  const AtomicEnumTestScoped B = AtomicEnumTestScoped::B;\n+  const AtomicEnumTestScoped C = AtomicEnumTestScoped::C;\n+  using Support = AtomicEnumTestSupport<AtomicEnumTestScoped>;\n+\n+  Support().test_store_load(B);\n+  Support().test_cmpxchg(B, C);\n+  Support().test_xchg(B, C);\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_atomic.cpp","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#ifndef _WIN32\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"unittest.hpp\"\n+\n+#include <errno.h>\n+#include <signal.h>\n+#include <stdio.h>\n+#include <sys\/ucontext.h>\n+#include <string.h>\n+\n+extern \"C\" {\n+  static void sig_handler(int sig, siginfo_t *info, ucontext_t *context) {\n+    printf( \" HANDLER (1) \" );\n+  }\n+}\n+\n+class PosixSignalTest : public ::testing::Test {\n+  public:\n+\n+  static void check_handlers() {\n+    struct sigaction act, old_SIGFPE_act, old_SIGILL_act;\n+    act.sa_handler = (void (*)(int))sig_handler;\n+    sigemptyset(&act.sa_mask);\n+    act.sa_flags = 0;\n+    ASSERT_NE(sigaction(SIGFPE, &act, &old_SIGFPE_act), -1) << \"Setting SIGFPE handler failed: \" << os::strerror(errno) << \" (\" << errno << \")\";\n+    ASSERT_NE(sigaction(SIGILL, &act, &old_SIGILL_act), -1) << \"Setting SIGILL handler failed: \" <<  os::strerror(errno) << \" (\" << errno << \")\";\n+\n+    \/\/ Use local stringStream to capture output from run_periodic_checks() calls to\n+    \/\/ print_signal_handlers().\n+    stringStream st;\n+    os::run_periodic_checks(&st);\n+    char* res = (char *)st.base(); \/\/ res can't be const because some strstr()'s have non-const first args.\n+\n+    \/\/ Restore signal handlers.\n+    ASSERT_NE(sigaction(SIGFPE, &act, &old_SIGFPE_act), -1) << \"Restoring SIGFPE handler failed: \" << os::strerror(errno) << \" (\" << errno << \")\";\n+    ASSERT_NE(sigaction(SIGILL, &act, &old_SIGILL_act), -1) << \"Restoring SIGILL handler failed: \" << os::strerror(errno) << \" (\" << errno << \")\";\n+\n+    \/\/ Check that \"Handler was modified\" occurs exactly twice in the tty output.\n+    char* modified = strstr(res, \"Handler was modified!\");\n+    ASSERT_NE(modified, nullptr) << \"No message found\";\n+\n+    modified = strstr(modified + 1, \"Handler was modified!\");\n+    ASSERT_NE(modified, nullptr) << \"Only one message found\";\n+    ASSERT_EQ(strstr(modified + 1, \"Handler was modified!\"), nullptr) << \"Too many messages found\";\n+  }\n+};\n+\n+\/\/ This tests the fix for JDK-8285792.\n+TEST_OTHER_VM(PosixSignalTest, check_handlers) {\n+  PosixSignalTest::check_handlers();\n+}\n+\n+#endif\n","filename":"test\/hotspot\/gtest\/runtime\/test_signals.cpp","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -449,0 +449,43 @@\n+\n+class ResourceHashtablePrintTest : public ::testing::Test {\n+ public:\n+    class TestValue {\n+      int _i;\n+      int _j;\n+      int _k;\n+     public:\n+      TestValue(int i) : _i(i), _j(i+1), _k(i+2) {}\n+    };\n+    ResourceHashtable<int, TestValue*, 30, ResourceObj::C_HEAP, mtTest> _test_table;\n+\n+    class TableDeleter {\n+     public:\n+      bool do_entry(int& key, TestValue*& val) {\n+        delete val;\n+        return true;\n+      }\n+    };\n+};\n+\n+TEST_VM_F(ResourceHashtablePrintTest, print_test) {\n+  for (int i = 0; i < 300; i++) {\n+    TestValue* tv = new TestValue(i);\n+    _test_table.put(i, tv);  \/\/ all the entries can be the same.\n+  }\n+  auto printer = [&] (int& key, TestValue*& val) {\n+    return sizeof(*val);\n+  };\n+  TableStatistics ts = _test_table.statistics_calculate(printer);\n+  ResourceMark rm;\n+  stringStream st;\n+  ts.print(&st, \"TestTable\");\n+  \/\/ Verify output in string\n+  const char* strings[] = {\n+      \"Number of buckets\", \"Number of entries\", \"300\", \"Number of literals\", \"Average bucket size\", \"Maximum bucket size\" };\n+  for (const auto& str : strings) {\n+    ASSERT_TRUE(strstr(st.as_string(), str) != nullptr) << \"string not present \" << str;\n+  }\n+  \/\/ Cleanup: need to delete pointers in entries\n+  TableDeleter deleter;\n+  _test_table.unlink(&deleter);\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_resourceHash.cpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-compiler\/rangechecks\/TestRangeCheckHoistingScaledIV.java 8291474 generic-ppc64le\n@@ -124,0 +123,1 @@\n+serviceability\/attach\/ConcAttachTest.java 8290043 linux-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8279125\n- * @summary fatal error: no reachable node should have no use\n- * @requires vm.flavor == \"server\"\n- *\n- * @run main\/othervm -XX:-BackgroundCompilation -XX:-DoEscapeAnalysis TestAllocArrayAfterAllocNoUse\n- *\n- *\/\n-\n-public class TestAllocArrayAfterAllocNoUse {\n-    private static Object field;\n-\n-    public static void main(String[] args) {\n-        for (int i = 0; i < 20_000; i++) {\n-            test();\n-        }\n-    }\n-\n-    private static void test() {\n-        try {\n-            final TestAllocArrayAfterAllocNoUse o = new TestAllocArrayAfterAllocNoUse();\n-        } catch (Exception e) {\n-            final int[] array = new int[100];\n-            field = array;\n-        }\n-\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/allocation\/TestAllocArrayAfterAllocNoUse.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8279062\n- * @summary C2: assert(t->meet(t0) == t) failed: Not monotonic after JDK-8278413\n- *\n- * @run main\/othervm -XX:-BackgroundCompilation TestCCPAllocateArray\n- *\n- *\/\n-\n-public class TestCCPAllocateArray {\n-    public static void main(String[] args) {\n-        for (int i = 0; i < 20_000; i++) {\n-            try {\n-                test();\n-            } catch (OutOfMemoryError e) {\n-            }\n-            length(42);\n-        }\n-    }\n-\n-    private static int[] test() {\n-        int i = 2;\n-        for (; i < 4; i *= 2);\n-        return new int[length(i)];\n-    }\n-\n-    private static int length(int i) {\n-        return i == 4 ? Integer.MAX_VALUE : 0;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/allocation\/TestCCPAllocateArray.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -1,80 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * bug 8279219\n- * @summary C2 crash when allocating array of size too large\n- * @requires vm.compiler2.enabled\n- * @library \/test\/lib \/\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm -ea -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:-BackgroundCompilation TestFailedAllocationBadGraph\n- *\/\n-\n-import jdk.test.whitebox.WhiteBox;\n-import java.lang.reflect.Method;\n-import compiler.whitebox.CompilerWhiteBoxTest;\n-\n-public class TestFailedAllocationBadGraph {\n-    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n-\n-    private static long[] array;\n-    private static int field;\n-    private static volatile int barrier;\n-\n-    public static void main(String[] args) throws Exception {\n-        run(\"test1\");\n-        run(\"test2\");\n-    }\n-\n-    private static void run(String method) throws Exception {\n-        Method m = TestFailedAllocationBadGraph.class.getDeclaredMethod(method);\n-        WHITE_BOX.enqueueMethodForCompilation(m, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n-        if (!WHITE_BOX.isMethodCompiled(m) || WHITE_BOX.getMethodCompilationLevel(m) != CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION) {\n-            throw new RuntimeException(\"should still be compiled\");\n-        }\n-    }\n-\n-    private static int test1() {\n-        int length = Integer.MAX_VALUE;\n-        try {\n-            array = new long[length];\n-        } catch (OutOfMemoryError outOfMemoryError) {\n-            barrier = 0x42;\n-            length = field;\n-        }\n-        return length;\n-    }\n-\n-    private static int test2() {\n-        int length = -1;\n-        try {\n-            array = new long[length];\n-        } catch (OutOfMemoryError outOfMemoryError) {\n-            barrier = 0x42;\n-            length = field;\n-        }\n-        return length;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/allocation\/TestFailedAllocationBadGraph.java","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -34,0 +34,3 @@\n+ * @run main\/othervm -Xbatch -XX:+IgnoreUnrecognizedVMOptions -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+StressIGVN -XX:+AlwaysIncrementalInline\n+ *      compiler.c2.Test7179138_1\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/Test7179138_1.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,4 +29,4 @@\n- * @run main\/othervm -Xbatch -XX:CompileCommand=exclude,*::test() -Xmx128m compiler.c2.cr6340864.TestDoubleVect\n- * @run main\/othervm -Xbatch -XX:CompileCommand=exclude,*::test() -Xmx128m -XX:MaxVectorSize=8 compiler.c2.cr6340864.TestDoubleVect\n- * @run main\/othervm -Xbatch -XX:CompileCommand=exclude,*::test() -Xmx128m -XX:MaxVectorSize=16 compiler.c2.cr6340864.TestDoubleVect\n- * @run main\/othervm -Xbatch -XX:CompileCommand=exclude,*::test() -Xmx128m -XX:MaxVectorSize=32 compiler.c2.cr6340864.TestDoubleVect\n+ * @run main\/othervm -Xbatch -XX:CompileCommand=exclude,*::test() -Xmx128m -XX:+UnlockDiagnosticVMOptions -XX:+UseSignumIntrinsic compiler.c2.cr6340864.TestDoubleVect\n+ * @run main\/othervm -Xbatch -XX:CompileCommand=exclude,*::test() -Xmx128m -XX:+UnlockDiagnosticVMOptions -XX:+UseSignumIntrinsic -XX:MaxVectorSize=8 compiler.c2.cr6340864.TestDoubleVect\n+ * @run main\/othervm -Xbatch -XX:CompileCommand=exclude,*::test() -Xmx128m -XX:+UnlockDiagnosticVMOptions -XX:+UseSignumIntrinsic -XX:MaxVectorSize=16 compiler.c2.cr6340864.TestDoubleVect\n+ * @run main\/othervm -Xbatch -XX:CompileCommand=exclude,*::test() -Xmx128m -XX:+UnlockDiagnosticVMOptions -XX:+UseSignumIntrinsic -XX:MaxVectorSize=32 compiler.c2.cr6340864.TestDoubleVect\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/cr6340864\/TestDoubleVect.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,4 +29,4 @@\n- * @run main\/othervm -Xbatch -XX:CompileCommand=exclude,*::test() -Xmx128m compiler.c2.cr6340864.TestFloatVect\n- * @run main\/othervm -Xbatch -XX:CompileCommand=exclude,*::test() -Xmx128m -XX:MaxVectorSize=8 compiler.c2.cr6340864.TestFloatVect\n- * @run main\/othervm -Xbatch -XX:CompileCommand=exclude,*::test() -Xmx128m -XX:MaxVectorSize=16 compiler.c2.cr6340864.TestFloatVect\n- * @run main\/othervm -Xbatch -XX:CompileCommand=exclude,*::test() -Xmx128m -XX:MaxVectorSize=32 compiler.c2.cr6340864.TestFloatVect\n+ * @run main\/othervm -Xbatch -XX:CompileCommand=exclude,*::test() -Xmx128m -XX:+UnlockDiagnosticVMOptions -XX:+UseSignumIntrinsic compiler.c2.cr6340864.TestFloatVect\n+ * @run main\/othervm -Xbatch -XX:CompileCommand=exclude,*::test() -Xmx128m -XX:+UnlockDiagnosticVMOptions -XX:+UseSignumIntrinsic -XX:MaxVectorSize=8 compiler.c2.cr6340864.TestFloatVect\n+ * @run main\/othervm -Xbatch -XX:CompileCommand=exclude,*::test() -Xmx128m -XX:+UnlockDiagnosticVMOptions -XX:+UseSignumIntrinsic -XX:MaxVectorSize=16 compiler.c2.cr6340864.TestFloatVect\n+ * @run main\/othervm -Xbatch -XX:CompileCommand=exclude,*::test() -Xmx128m -XX:+UnlockDiagnosticVMOptions -XX:+UseSignumIntrinsic -XX:MaxVectorSize=32 compiler.c2.cr6340864.TestFloatVect\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/cr6340864\/TestFloatVect.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @summary Test that VM rejects and invalid replay file.\n+ * @library \/test\/lib\n+ * @requires vm.compMode != \"Xint\"\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver TestInvalidReplayFile\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+\n+public class TestInvalidReplayFile {\n+\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ This test also serves as a very basic sanity test for release VMs (accepting the replay options and\n+        \/\/ attempting to read the replay file). Most of the tests in ciReplay use -XX:CICrashAt to induce artificial\n+        \/\/ crashes into the compiler, and that option is not available for release VMs. Therefore we cannot generate\n+        \/\/ replay files as a test in release builds.\n+\n+        File f = new File(\"bogus-replay-file.txt\");\n+        FileWriter w = new FileWriter(f);\n+        w.write(\"Bogus 123\");\n+        w.flush();\n+        w.close();\n+\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+                \"-XX:+UnlockDiagnosticVMOptions\",\n+                \"-Xmx100M\",\n+                \"-XX:+ReplayCompiles\", \"-XX:ReplayDataFile=.\/bogus-replay-file.txt\");\n+\n+        OutputAnalyzer output_detail = new OutputAnalyzer(pb.start());\n+        output_detail.shouldNotHaveExitValue(0);\n+        output_detail.shouldContain(\"Error while parsing\");\n+\n+    }\n+}\n+\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/TestInvalidReplayFile.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.regex.MatchResult;\n@@ -35,0 +36,1 @@\n+import java.util.stream.Collectors;\n@@ -56,1 +58,1 @@\n-            Comparison<Long> comparison = parseComparison(irRule, node, countConstraint);\n+            Comparison<Integer> comparison = parseComparison(irRule, node, countConstraint);\n@@ -66,1 +68,1 @@\n-    private static Comparison<Long> parseComparison(IRRule irRule, String node, String constraint) {\n+    private static Comparison<Integer> parseComparison(IRRule irRule, String node, String constraint) {\n@@ -68,1 +70,1 @@\n-        return ComparisonConstraintParser.parse(constraint, Long::parseLong, postfixErrorMsg);\n+        return ComparisonConstraintParser.parse(constraint, Integer::parseInt, postfixErrorMsg);\n@@ -85,4 +87,4 @@\n-        long foundCount = getFoundCount(compilation, constraint);\n-        Comparison<Long> comparison = constraint.comparison;\n-        if (!comparison.compare(foundCount)) {\n-            result.addFailure(createRegexFailure(compilation, constraint, foundCount));\n+        List<String> countsMatches = getCountsMatches(compilation, constraint);\n+        Comparison<Integer> comparison = constraint.comparison;\n+        if (!comparison.compare(countsMatches.size())) {\n+            result.addFailure(createRegexFailure(countsMatches, constraint));\n@@ -92,1 +94,1 @@\n-    private long getFoundCount(String compilation, Constraint constraint) {\n+    private List<String> getCountsMatches(String compilation, Constraint constraint) {\n@@ -95,1 +97,1 @@\n-        return matcher.results().count();\n+        return matcher.results().map(MatchResult::group).collect(Collectors.toList());\n@@ -98,10 +100,3 @@\n-    private CountsRegexFailure createRegexFailure(String compilation, Constraint constraint, long foundCount) {\n-        Pattern p = Pattern.compile(constraint.nodeRegex);\n-        Matcher m = p.matcher(compilation);\n-        List<String> matches;\n-        if (m.find()) {\n-            matches = getMatchedNodes(m);\n-        } else {\n-            matches = new ArrayList<>();\n-        }\n-        return new CountsRegexFailure(constraint.nodeRegex, constraint.nodeId, foundCount, constraint.comparison, matches);\n+    private CountsRegexFailure createRegexFailure(List<String> countsMatches, Constraint constraint) {\n+        return new CountsRegexFailure(constraint.nodeRegex, constraint.nodeId, countsMatches.size(), constraint.comparison,\n+                                      countsMatches);\n@@ -112,1 +107,1 @@\n-        final Comparison<Long> comparison;\n+        final Comparison<Integer> comparison;\n@@ -115,1 +110,1 @@\n-        Constraint(String nodeRegex, Comparison<Long> comparison, int nodeId) {\n+        Constraint(String nodeRegex, Comparison<Integer> comparison, int nodeId) {\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/Counts.java","additions":16,"deletions":21,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -38,1 +38,2 @@\n-    public CountsRegexFailure(String nodeRegex, int nodeId, long foundValue, Comparison<Long> comparison, List<String> matches) {\n+    public CountsRegexFailure(String nodeRegex, int nodeId, int foundValue, Comparison<Integer> comparison,\n+                              List<String> matches) {\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/CountsRegexFailure.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * @test SharedTrampolineTest\n+ * @summary Checks that trampolines can be shared for static method.\n+ * @bug 8280152\n+ * @library \/test\/lib\n+ *\n+ * @requires vm.debug & os.arch==\"aarch64\"\n+ *\n+ * @run driver compiler.sharedstubs.SharedTrampolineTest\n+ *\/\n+\n+package compiler.sharedstubs;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.regex.Pattern;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class SharedTrampolineTest {\n+    private final static int ITERATIONS_TO_HEAT_LOOP = 20_000;\n+\n+    private static void runTest(String compiler, String test) throws Exception {\n+        String testClassName = SharedTrampolineTest.class.getName() + \"$\" + test;\n+        ArrayList<String> command = new ArrayList<String>();\n+        command.add(compiler);\n+        command.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+        command.add(\"-Xbatch\");\n+        command.add(\"-XX:+PrintRelocations\");\n+        command.add(\"-XX:CompileCommand=compileonly,\" + testClassName + \"::\" + \"test\");\n+        command.add(\"-XX:CompileCommand=dontinline,\" + testClassName + \"::\" + \"test\");\n+        command.add(\"-XX:CompileCommand=dontinline,\" + testClassName + \"::\" + \"log\");\n+        command.add(testClassName);\n+        command.add(\"a\");\n+\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(command);\n+\n+        OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n+\n+        analyzer.shouldHaveExitValue(0);\n+\n+        System.out.println(analyzer.getOutput());\n+\n+        checkOutput(analyzer);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        List<String> compilers = List.of(\"-XX:-TieredCompilation\" \/* C2 *\/);\n+        List<String> tests = List.of(\"StaticMethodTest\");\n+        for (String compiler : compilers) {\n+            for (String test : tests) {\n+                runTest(compiler, test);\n+            }\n+        }\n+    }\n+\n+    private static String skipTo(Iterator<String> iter, String substring) {\n+        while (iter.hasNext()) {\n+            String nextLine = iter.next();\n+            if (nextLine.contains(substring)) {\n+                return nextLine;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static void checkOutput(OutputAnalyzer output) {\n+        List<String> addrs = Pattern.compile(\"\\\\(trampoline_stub\\\\) addr=(\\\\w+) .*\\\\[trampoline owner\")\n+            .matcher(output.getStdout())\n+            .results()\n+            .map(m -> m.group(1))\n+            .collect(Collectors.toList());\n+        if (addrs.stream().distinct().count() >= addrs.size()) {\n+            throw new RuntimeException(\"No stubs reused\");\n+        }\n+    }\n+\n+    public static class StaticMethodTest {\n+        private static void log(int i, String msg) {\n+        }\n+\n+        static void test(int i, String[] args) {\n+            if (i % args.length == 0) {\n+                log(i, \"args[0] = \" + args[0]);\n+            } else {\n+                log(i, \"No args\");\n+            }\n+        }\n+\n+        public static void main(String[] args) {\n+            for (int i = 1; i < ITERATIONS_TO_HEAT_LOOP; ++i) {\n+                test(i, args);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/sharedstubs\/SharedTrampolineTest.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,1 +215,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain boolean\");\n@@ -217,1 +217,8 @@\n-            assertEquals(x, false, \"weakCompareAndSetPlain boolean value\");\n+            assertEquals(x, false, \"success weakCompareAndSetPlain boolean value\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetBooleanPlain(base, offset, true, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain boolean\");\n+            boolean x = UNSAFE.getBoolean(base, offset);\n+            assertEquals(x, false, \"failing weakCompareAndSetPlain boolean value\");\n@@ -225,1 +232,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire boolean\");\n+            boolean x = UNSAFE.getBoolean(base, offset);\n+            assertEquals(x, true, \"success weakCompareAndSetAcquire boolean\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetBooleanAcquire(base, offset, false, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire boolean\");\n@@ -227,1 +241,1 @@\n-            assertEquals(x, true, \"weakCompareAndSetAcquire boolean\");\n+            assertEquals(x, true, \"failing weakCompareAndSetAcquire boolean value\");\n@@ -235,1 +249,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease boolean\");\n@@ -237,1 +251,8 @@\n-            assertEquals(x, false, \"weakCompareAndSetRelease boolean\");\n+            assertEquals(x, false, \"success weakCompareAndSetRelease boolean\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetBooleanRelease(base, offset, true, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease boolean\");\n+            boolean x = UNSAFE.getBoolean(base, offset);\n+            assertEquals(x, false, \"failing weakCompareAndSetRelease boolean value\");\n@@ -245,1 +266,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSet boolean\");\n+            boolean x = UNSAFE.getBoolean(base, offset);\n+            assertEquals(x, true, \"success weakCompareAndSet boolean\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetBoolean(base, offset, false, false);\n+            assertEquals(success, false, \"failing weakCompareAndSet boolean\");\n@@ -247,1 +275,1 @@\n-            assertEquals(x, true, \"weakCompareAndSet boolean\");\n+            assertEquals(x, true, \"failing weakCompareAndSet boolean value\");\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/JdkInternalMiscUnsafeAccessTestBoolean.java","additions":37,"deletions":9,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -244,1 +244,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain byte\");\n@@ -246,1 +246,8 @@\n-            assertEquals(x, (byte)0x23, \"weakCompareAndSetPlain byte value\");\n+            assertEquals(x, (byte)0x23, \"success weakCompareAndSetPlain byte value\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetBytePlain(base, offset, (byte)0x01, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain byte\");\n+            byte x = UNSAFE.getByte(base, offset);\n+            assertEquals(x, (byte)0x23, \"failing weakCompareAndSetPlain byte value\");\n@@ -254,1 +261,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire byte\");\n+            byte x = UNSAFE.getByte(base, offset);\n+            assertEquals(x, (byte)0x01, \"success weakCompareAndSetAcquire byte\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetByteAcquire(base, offset, (byte)0x23, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire byte\");\n@@ -256,1 +270,1 @@\n-            assertEquals(x, (byte)0x01, \"weakCompareAndSetAcquire byte\");\n+            assertEquals(x, (byte)0x01, \"failing weakCompareAndSetAcquire byte value\");\n@@ -264,1 +278,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease byte\");\n@@ -266,1 +280,8 @@\n-            assertEquals(x, (byte)0x23, \"weakCompareAndSetRelease byte\");\n+            assertEquals(x, (byte)0x23, \"success weakCompareAndSetRelease byte\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetByteRelease(base, offset, (byte)0x01, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease byte\");\n+            byte x = UNSAFE.getByte(base, offset);\n+            assertEquals(x, (byte)0x23, \"failing weakCompareAndSetRelease byte value\");\n@@ -274,1 +295,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet byte\");\n+            assertEquals(success, true, \"success weakCompareAndSet byte\");\n+            byte x = UNSAFE.getByte(base, offset);\n+            assertEquals(x, (byte)0x01, \"success weakCompareAndSet byte\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetByte(base, offset, (byte)0x23, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSet byte\");\n@@ -276,1 +304,1 @@\n-            assertEquals(x, (byte)0x01, \"weakCompareAndSet byte\");\n+            assertEquals(x, (byte)0x01, \"failing weakCompareAndSet byte value\");\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/JdkInternalMiscUnsafeAccessTestByte.java","additions":37,"deletions":9,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -262,1 +262,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain char\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain char\");\n@@ -264,1 +264,8 @@\n-            assertEquals(x, '\\u4567', \"weakCompareAndSetPlain char value\");\n+            assertEquals(x, '\\u4567', \"success weakCompareAndSetPlain char value\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetCharPlain(base, offset, '\\u0123', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain char\");\n+            char x = UNSAFE.getChar(base, offset);\n+            assertEquals(x, '\\u4567', \"failing weakCompareAndSetPlain char value\");\n@@ -272,1 +279,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire char\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire char\");\n+            char x = UNSAFE.getChar(base, offset);\n+            assertEquals(x, '\\u0123', \"success weakCompareAndSetAcquire char\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetCharAcquire(base, offset, '\\u4567', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire char\");\n@@ -274,1 +288,1 @@\n-            assertEquals(x, '\\u0123', \"weakCompareAndSetAcquire char\");\n+            assertEquals(x, '\\u0123', \"failing weakCompareAndSetAcquire char value\");\n@@ -282,1 +296,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease char\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease char\");\n@@ -284,1 +298,8 @@\n-            assertEquals(x, '\\u4567', \"weakCompareAndSetRelease char\");\n+            assertEquals(x, '\\u4567', \"success weakCompareAndSetRelease char\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetCharRelease(base, offset, '\\u0123', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease char\");\n+            char x = UNSAFE.getChar(base, offset);\n+            assertEquals(x, '\\u4567', \"failing weakCompareAndSetRelease char value\");\n@@ -292,1 +313,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet char\");\n+            assertEquals(success, true, \"success weakCompareAndSet char\");\n+            char x = UNSAFE.getChar(base, offset);\n+            assertEquals(x, '\\u0123', \"success weakCompareAndSet char\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetChar(base, offset, '\\u4567', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSet char\");\n@@ -294,1 +322,1 @@\n-            assertEquals(x, '\\u0123', \"weakCompareAndSet char\");\n+            assertEquals(x, '\\u0123', \"failing weakCompareAndSet char value\");\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/JdkInternalMiscUnsafeAccessTestChar.java","additions":37,"deletions":9,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -244,1 +244,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain double\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain double\");\n@@ -246,1 +246,8 @@\n-            assertEquals(x, 2.0d, \"weakCompareAndSetPlain double value\");\n+            assertEquals(x, 2.0d, \"success weakCompareAndSetPlain double value\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetDoublePlain(base, offset, 1.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain double\");\n+            double x = UNSAFE.getDouble(base, offset);\n+            assertEquals(x, 2.0d, \"failing weakCompareAndSetPlain double value\");\n@@ -254,1 +261,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire double\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire double\");\n+            double x = UNSAFE.getDouble(base, offset);\n+            assertEquals(x, 1.0d, \"success weakCompareAndSetAcquire double\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetDoubleAcquire(base, offset, 2.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire double\");\n@@ -256,1 +270,1 @@\n-            assertEquals(x, 1.0d, \"weakCompareAndSetAcquire double\");\n+            assertEquals(x, 1.0d, \"failing weakCompareAndSetAcquire double value\");\n@@ -264,1 +278,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease double\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease double\");\n@@ -266,1 +280,8 @@\n-            assertEquals(x, 2.0d, \"weakCompareAndSetRelease double\");\n+            assertEquals(x, 2.0d, \"success weakCompareAndSetRelease double\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetDoubleRelease(base, offset, 1.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease double\");\n+            double x = UNSAFE.getDouble(base, offset);\n+            assertEquals(x, 2.0d, \"failing weakCompareAndSetRelease double value\");\n@@ -274,1 +295,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet double\");\n+            assertEquals(success, true, \"success weakCompareAndSet double\");\n+            double x = UNSAFE.getDouble(base, offset);\n+            assertEquals(x, 1.0d, \"success weakCompareAndSet double\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetDouble(base, offset, 2.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSet double\");\n@@ -276,1 +304,1 @@\n-            assertEquals(x, 1.0d, \"weakCompareAndSet double\");\n+            assertEquals(x, 1.0d, \"failing weakCompareAndSet double value\");\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/JdkInternalMiscUnsafeAccessTestDouble.java","additions":37,"deletions":9,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -244,1 +244,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain float\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain float\");\n@@ -246,1 +246,8 @@\n-            assertEquals(x, 2.0f, \"weakCompareAndSetPlain float value\");\n+            assertEquals(x, 2.0f, \"success weakCompareAndSetPlain float value\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetFloatPlain(base, offset, 1.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain float\");\n+            float x = UNSAFE.getFloat(base, offset);\n+            assertEquals(x, 2.0f, \"failing weakCompareAndSetPlain float value\");\n@@ -254,1 +261,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire float\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire float\");\n+            float x = UNSAFE.getFloat(base, offset);\n+            assertEquals(x, 1.0f, \"success weakCompareAndSetAcquire float\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetFloatAcquire(base, offset, 2.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire float\");\n@@ -256,1 +270,1 @@\n-            assertEquals(x, 1.0f, \"weakCompareAndSetAcquire float\");\n+            assertEquals(x, 1.0f, \"failing weakCompareAndSetAcquire float value\");\n@@ -264,1 +278,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease float\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease float\");\n@@ -266,1 +280,8 @@\n-            assertEquals(x, 2.0f, \"weakCompareAndSetRelease float\");\n+            assertEquals(x, 2.0f, \"success weakCompareAndSetRelease float\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetFloatRelease(base, offset, 1.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease float\");\n+            float x = UNSAFE.getFloat(base, offset);\n+            assertEquals(x, 2.0f, \"failing weakCompareAndSetRelease float value\");\n@@ -274,1 +295,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet float\");\n+            assertEquals(success, true, \"success weakCompareAndSet float\");\n+            float x = UNSAFE.getFloat(base, offset);\n+            assertEquals(x, 1.0f, \"success weakCompareAndSet float\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetFloat(base, offset, 2.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSet float\");\n@@ -276,1 +304,1 @@\n-            assertEquals(x, 1.0f, \"weakCompareAndSet float\");\n+            assertEquals(x, 1.0f, \"failing weakCompareAndSet float value\");\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/JdkInternalMiscUnsafeAccessTestFloat.java","additions":37,"deletions":9,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -262,1 +262,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain int\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain int\");\n@@ -264,1 +264,8 @@\n-            assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetPlain int value\");\n+            assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetPlain int value\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetIntPlain(base, offset, 0x01234567, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain int\");\n+            int x = UNSAFE.getInt(base, offset);\n+            assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetPlain int value\");\n@@ -272,1 +279,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire int\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire int\");\n+            int x = UNSAFE.getInt(base, offset);\n+            assertEquals(x, 0x01234567, \"success weakCompareAndSetAcquire int\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetIntAcquire(base, offset, 0x89ABCDEF, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire int\");\n@@ -274,1 +288,1 @@\n-            assertEquals(x, 0x01234567, \"weakCompareAndSetAcquire int\");\n+            assertEquals(x, 0x01234567, \"failing weakCompareAndSetAcquire int value\");\n@@ -282,1 +296,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease int\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease int\");\n@@ -284,1 +298,8 @@\n-            assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetRelease int\");\n+            assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetRelease int\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetIntRelease(base, offset, 0x01234567, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease int\");\n+            int x = UNSAFE.getInt(base, offset);\n+            assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetRelease int value\");\n@@ -292,1 +313,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet int\");\n+            assertEquals(success, true, \"success weakCompareAndSet int\");\n+            int x = UNSAFE.getInt(base, offset);\n+            assertEquals(x, 0x01234567, \"success weakCompareAndSet int\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetInt(base, offset, 0x89ABCDEF, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSet int\");\n@@ -294,1 +322,1 @@\n-            assertEquals(x, 0x01234567, \"weakCompareAndSet int\");\n+            assertEquals(x, 0x01234567, \"failing weakCompareAndSet int value\");\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/JdkInternalMiscUnsafeAccessTestInt.java","additions":37,"deletions":9,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -262,1 +262,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain long\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain long\");\n@@ -264,1 +264,8 @@\n-            assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetPlain long value\");\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetPlain long value\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetLongPlain(base, offset, 0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain long\");\n+            long x = UNSAFE.getLong(base, offset);\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetPlain long value\");\n@@ -272,1 +279,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire long\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire long\");\n+            long x = UNSAFE.getLong(base, offset);\n+            assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSetAcquire long\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetLongAcquire(base, offset, 0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire long\");\n@@ -274,1 +288,1 @@\n-            assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSetAcquire long\");\n+            assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSetAcquire long value\");\n@@ -282,1 +296,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease long\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease long\");\n@@ -284,1 +298,8 @@\n-            assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetRelease long\");\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetRelease long\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetLongRelease(base, offset, 0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease long\");\n+            long x = UNSAFE.getLong(base, offset);\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetRelease long value\");\n@@ -292,1 +313,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet long\");\n+            assertEquals(success, true, \"success weakCompareAndSet long\");\n+            long x = UNSAFE.getLong(base, offset);\n+            assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSet long\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetLong(base, offset, 0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSet long\");\n@@ -294,1 +322,1 @@\n-            assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSet long\");\n+            assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSet long value\");\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/JdkInternalMiscUnsafeAccessTestLong.java","additions":37,"deletions":9,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,1 +215,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain Object\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain Object\");\n@@ -217,1 +217,8 @@\n-            assertEquals(x, \"bar\", \"weakCompareAndSetPlain Object value\");\n+            assertEquals(x, \"bar\", \"success weakCompareAndSetPlain Object value\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetReferencePlain(base, offset, \"foo\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain Object\");\n+            Object x = UNSAFE.getReference(base, offset);\n+            assertEquals(x, \"bar\", \"failing weakCompareAndSetPlain Object value\");\n@@ -225,1 +232,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire Object\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire Object\");\n+            Object x = UNSAFE.getReference(base, offset);\n+            assertEquals(x, \"foo\", \"success weakCompareAndSetAcquire Object\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetReferenceAcquire(base, offset, \"bar\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire Object\");\n@@ -227,1 +241,1 @@\n-            assertEquals(x, \"foo\", \"weakCompareAndSetAcquire Object\");\n+            assertEquals(x, \"foo\", \"failing weakCompareAndSetAcquire Object value\");\n@@ -235,1 +249,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease Object\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease Object\");\n@@ -237,1 +251,8 @@\n-            assertEquals(x, \"bar\", \"weakCompareAndSetRelease Object\");\n+            assertEquals(x, \"bar\", \"success weakCompareAndSetRelease Object\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetReferenceRelease(base, offset, \"foo\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease Object\");\n+            Object x = UNSAFE.getReference(base, offset);\n+            assertEquals(x, \"bar\", \"failing weakCompareAndSetRelease Object value\");\n@@ -245,1 +266,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet Object\");\n+            assertEquals(success, true, \"success weakCompareAndSet Object\");\n+            Object x = UNSAFE.getReference(base, offset);\n+            assertEquals(x, \"foo\", \"success weakCompareAndSet Object\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetReference(base, offset, \"bar\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSet Object\");\n@@ -247,1 +275,1 @@\n-            assertEquals(x, \"foo\", \"weakCompareAndSet Object\");\n+            assertEquals(x, \"foo\", \"failing weakCompareAndSet Object value\");\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/JdkInternalMiscUnsafeAccessTestObject.java","additions":37,"deletions":9,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -262,1 +262,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain short\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain short\");\n@@ -264,1 +264,8 @@\n-            assertEquals(x, (short)0x4567, \"weakCompareAndSetPlain short value\");\n+            assertEquals(x, (short)0x4567, \"success weakCompareAndSetPlain short value\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetShortPlain(base, offset, (short)0x0123, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain short\");\n+            short x = UNSAFE.getShort(base, offset);\n+            assertEquals(x, (short)0x4567, \"failing weakCompareAndSetPlain short value\");\n@@ -272,1 +279,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire short\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire short\");\n+            short x = UNSAFE.getShort(base, offset);\n+            assertEquals(x, (short)0x0123, \"success weakCompareAndSetAcquire short\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetShortAcquire(base, offset, (short)0x4567, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire short\");\n@@ -274,1 +288,1 @@\n-            assertEquals(x, (short)0x0123, \"weakCompareAndSetAcquire short\");\n+            assertEquals(x, (short)0x0123, \"failing weakCompareAndSetAcquire short value\");\n@@ -282,1 +296,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease short\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease short\");\n@@ -284,1 +298,8 @@\n-            assertEquals(x, (short)0x4567, \"weakCompareAndSetRelease short\");\n+            assertEquals(x, (short)0x4567, \"success weakCompareAndSetRelease short\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetShortRelease(base, offset, (short)0x0123, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease short\");\n+            short x = UNSAFE.getShort(base, offset);\n+            assertEquals(x, (short)0x4567, \"failing weakCompareAndSetRelease short value\");\n@@ -292,1 +313,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet short\");\n+            assertEquals(success, true, \"success weakCompareAndSet short\");\n+            short x = UNSAFE.getShort(base, offset);\n+            assertEquals(x, (short)0x0123, \"success weakCompareAndSet short\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetShort(base, offset, (short)0x4567, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSet short\");\n@@ -294,1 +322,1 @@\n-            assertEquals(x, (short)0x0123, \"weakCompareAndSet short\");\n+            assertEquals(x, (short)0x0123, \"failing weakCompareAndSet short value\");\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/JdkInternalMiscUnsafeAccessTestShort.java","additions":37,"deletions":9,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/SunMiscUnsafeAccessTestBoolean.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/SunMiscUnsafeAccessTestByte.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/SunMiscUnsafeAccessTestChar.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/SunMiscUnsafeAccessTestDouble.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/SunMiscUnsafeAccessTestFloat.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/SunMiscUnsafeAccessTestInt.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/SunMiscUnsafeAccessTestLong.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/SunMiscUnsafeAccessTestObject.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/SunMiscUnsafeAccessTestShort.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -306,1 +306,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain $type$\");\n@@ -308,1 +308,8 @@\n-            assertEquals(x, $value2$, \"weakCompareAndSetPlain $type$ value\");\n+            assertEquals(x, $value2$, \"success weakCompareAndSetPlain $type$ value\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSet$MethodAffix$Plain(base, offset, $value1$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain $type$\");\n+            $type$ x = UNSAFE.get$MethodAffix$(base, offset);\n+            assertEquals(x, $value2$, \"failing weakCompareAndSetPlain $type$ value\");\n@@ -316,1 +323,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire $type$\");\n+            $type$ x = UNSAFE.get$MethodAffix$(base, offset);\n+            assertEquals(x, $value1$, \"success weakCompareAndSetAcquire $type$\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSet$MethodAffix$Acquire(base, offset, $value2$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire $type$\");\n@@ -318,1 +332,1 @@\n-            assertEquals(x, $value1$, \"weakCompareAndSetAcquire $type$\");\n+            assertEquals(x, $value1$, \"failing weakCompareAndSetAcquire $type$ value\");\n@@ -326,1 +340,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease $type$\");\n@@ -328,1 +342,8 @@\n-            assertEquals(x, $value2$, \"weakCompareAndSetRelease $type$\");\n+            assertEquals(x, $value2$, \"success weakCompareAndSetRelease $type$\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSet$MethodAffix$Release(base, offset, $value1$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease $type$\");\n+            $type$ x = UNSAFE.get$MethodAffix$(base, offset);\n+            assertEquals(x, $value2$, \"failing weakCompareAndSetRelease $type$ value\");\n@@ -336,1 +357,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSet $type$\");\n+            $type$ x = UNSAFE.get$MethodAffix$(base, offset);\n+            assertEquals(x, $value1$, \"success weakCompareAndSet $type$\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSet$MethodAffix$(base, offset, $value2$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSet $type$\");\n@@ -338,1 +366,1 @@\n-            assertEquals(x, $value1$, \"weakCompareAndSet $type$\");\n+            assertEquals(x, $value1$, \"failing weakCompareAndSet $type$ value\");\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/X-UnsafeAccessTest.java.template","additions":37,"deletions":9,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- * @requires vm.cpu.features ~= \".*simd.*\"\n+ * @requires vm.cpu.features ~= \".*asimd.*\"\n@@ -87,1 +87,1 @@\n-    @IR(counts = { \"bic\", \" >= 1\" })\n+    @IR(counts = { \"vand_notI\", \" >= 1\" })\n@@ -101,1 +101,1 @@\n-    @IR(counts = { \"bic\", \" >= 1\" })\n+    @IR(counts = { \"and_notL\", \" >= 1\" })\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/AllBitsSetVectorMatchRuleTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"simd\", \"true\", \"avx2\", \"true\"}, counts = {IRNode.REVERSE_BYTES_V , \" > 0 \"})\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\"}, counts = {IRNode.REVERSE_BYTES_V , \" > 0 \"})\n@@ -99,1 +99,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"simd\", \"true\", \"avx2\", \"true\"}, counts = {IRNode.REVERSE_BYTES_V , \" > 0 \"})\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\"}, counts = {IRNode.REVERSE_BYTES_V , \" > 0 \"})\n@@ -119,1 +119,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"simd\", \"true\", \"avx2\", \"true\"}, failOn = {IRNode.REVERSE_BYTES_V})\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\"}, failOn = {IRNode.REVERSE_BYTES_V})\n@@ -137,1 +137,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"simd\", \"true\", \"avx2\", \"true\"}, counts = {IRNode.REVERSE_BYTES_V , \" > 0 \"})\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\"}, counts = {IRNode.REVERSE_BYTES_V , \" > 0 \"})\n@@ -156,1 +156,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"simd\", \"true\", \"avx2\", \"true\"}, counts = {IRNode.REVERSE_BYTES_V , \" > 0 \"})\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\"}, counts = {IRNode.REVERSE_BYTES_V , \" > 0 \"})\n@@ -176,1 +176,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"simd\", \"true\", \"avx2\", \"true\"}, failOn = {IRNode.REVERSE_BYTES_V})\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\"}, failOn = {IRNode.REVERSE_BYTES_V})\n@@ -194,1 +194,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"simd\", \"true\", \"avx2\", \"true\"}, counts = {IRNode.REVERSE_BYTES_V , \" > 0 \"})\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\"}, counts = {IRNode.REVERSE_BYTES_V , \" > 0 \"})\n@@ -213,1 +213,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"simd\", \"true\", \"avx2\", \"true\"}, counts = {IRNode.REVERSE_BYTES_V , \" > 0 \"})\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\"}, counts = {IRNode.REVERSE_BYTES_V , \" > 0 \"})\n@@ -233,1 +233,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"simd\", \"true\", \"avx2\", \"true\"}, failOn = {IRNode.REVERSE_BYTES_V})\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\"}, failOn = {IRNode.REVERSE_BYTES_V})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestReverseByteTransforms.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -227,1 +227,1 @@\n-    @IR(counts = { \"sve_mla\", \">= 1\" })\n+    @IR(counts = { \"vmla_masked\", \">= 1\" })\n@@ -240,1 +240,1 @@\n-    @IR(counts = { \"sve_mls\", \">= 1\" })\n+    @IR(counts = { \"vmls_masked\", \">= 1\" })\n@@ -253,1 +253,1 @@\n-    @IR(counts = { \"sve_mla\", \">= 1\" })\n+    @IR(counts = { \"vmla_masked\", \">= 1\" })\n@@ -266,1 +266,1 @@\n-    @IR(counts = { \"sve_mls\", \">= 1\" })\n+    @IR(counts = { \"vmls_masked\", \">= 1\" })\n@@ -279,1 +279,1 @@\n-    @IR(counts = { \"sve_mla\", \">= 1\" })\n+    @IR(counts = { \"vmla_masked\", \">= 1\" })\n@@ -292,1 +292,1 @@\n-    @IR(counts = { \"sve_mls\", \">= 1\" })\n+    @IR(counts = { \"vmls_masked\", \">= 1\" })\n@@ -305,1 +305,1 @@\n-    @IR(counts = { \"sve_mla\", \">= 1\" })\n+    @IR(counts = { \"vmla_masked\", \">= 1\" })\n@@ -318,1 +318,1 @@\n-    @IR(counts = { \"sve_mls\", \">= 1\" })\n+    @IR(counts = { \"vmls_masked\", \">= 1\" })\n@@ -331,1 +331,1 @@\n-    @IR(counts = { \"sve_fmsb\", \">= 1\" })\n+    @IR(counts = { \"vfmsb_masked\", \">= 1\" })\n@@ -344,1 +344,1 @@\n-    @IR(counts = { \"sve_fnmad\", \">= 1\" })\n+    @IR(counts = { \"vfnmad_masked\", \">= 1\" })\n@@ -357,1 +357,1 @@\n-    @IR(counts = { \"sve_fnmsb\", \">= 1\" })\n+    @IR(counts = { \"vfnmsb_masked\", \">= 1\" })\n@@ -370,1 +370,1 @@\n-    @IR(counts = { \"sve_fmsb\", \">= 1\" })\n+    @IR(counts = { \"vfmsb_masked\", \">= 1\" })\n@@ -383,1 +383,1 @@\n-    @IR(counts = { \"sve_fnmad\", \">= 1\" })\n+    @IR(counts = { \"vfnmad_masked\", \">= 1\" })\n@@ -396,1 +396,1 @@\n-    @IR(counts = { \"sve_fnmsb\", \">= 1\" })\n+    @IR(counts = { \"vfnmsb_masked\", \">= 1\" })\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorFusedMultiplyAddSubTest.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- * @requires vm.cpu.features ~= \".*sve.*\"\n+ * @requires vm.cpu.features ~= \".*sve.*\" & (vm.opt.MaxVectorSize == \"null\" | vm.opt.MaxVectorSize >= 16)\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorGatherScatterTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-    @IR(failOn = IRNode.AND_V, applyIfCPUFeatureAnd = {\"simd\", \"true\", \"sve\", \"false\"})\n+    @IR(failOn = IRNode.AND_V, applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -181,1 +181,1 @@\n-    @IR(failOn = IRNode.AND_V, applyIfCPUFeatureAnd = {\"simd\", \"true\", \"sve\", \"false\"})\n+    @IR(failOn = IRNode.AND_V, applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -282,1 +282,1 @@\n-    @IR(failOn = IRNode.OR_V, applyIfCPUFeatureAnd = {\"simd\", \"true\", \"sve\", \"false\"})\n+    @IR(failOn = IRNode.OR_V, applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -341,1 +341,1 @@\n-    @IR(failOn = IRNode.OR_V, applyIfCPUFeatureAnd = {\"simd\", \"true\", \"sve\", \"false\"})\n+    @IR(failOn = IRNode.OR_V, applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -397,1 +397,1 @@\n-    @IR(failOn = IRNode.XOR_V, applyIfCPUFeatureAnd = {\"simd\", \"true\", \"sve\", \"false\"})\n+    @IR(failOn = IRNode.XOR_V, applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorLogicalOpIdentityTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-    @IR(counts = { \"sve_not\", \">= 1\" })\n+    @IR(counts = { \"vnotI_masked\", \">= 1\" })\n@@ -98,1 +98,1 @@\n-    @IR(counts = { \"sve_not\", \">= 1\" })\n+    @IR(counts = { \"vnotL_masked\", \">= 1\" })\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskedNotTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @requires vm.cpu.features ~= \".*simd.*\"\n+ * @requires vm.cpu.features ~= \".*asimd.*\"\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastNeon.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,2 @@\n- * @bug 8282711\n- * @summary Accelerate Math.signum function for AVX and AVX512.\n+ * @bug 8282711 8290249\n+ * @summary Accelerate Math.signum function for AVX, AVX512 and aarch64 (Neon and SVE)\n@@ -29,2 +29,1 @@\n- * @requires vm.cpu.features ~= \".*avx.*\"\n- * @requires os.simpleArch == \"x64\"\n+ * @requires (os.simpleArch == \"x64\" & vm.cpu.features ~= \".*avx.*\") | os.arch == \"aarch64\"\n@@ -49,2 +48,2 @@\n-      TestFramework.runWithFlags(\"-XX:-TieredCompilation\",\n-                                  \"-XX:CompileThresholdScaling=0.3\");\n+      TestFramework.runWithFlags(\"-XX:-TieredCompilation\", \"-XX:+UnlockDiagnosticVMOptions\",\n+                                 \"-XX:+UseSignumIntrinsic\", \"-XX:CompileThresholdScaling=0.3\");\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestSignumVector.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @compile --enable-preview -source ${jdk.version} ClassFileVersionTest.java\n@@ -37,1 +38,8 @@\n-\n+    public static final int LOWER_16 = 0x0000_FFFF;\n+    \/*\n+     * Include a use of a preview API so that the minor class file\n+     * version of the class file for this class gets set during\n+     * compilation. If a particular class becomes non-preview, any\n+     * currently preview class can be substituted in.\n+     *\/\n+    private static final Class<?> PREVIEW_API = java.lang.foreign.MemoryAddress.class;\n@@ -41,1 +49,4 @@\n-        Class<?> testClass = Class.forName(className);\n+        testIt(Class.forName(className), expectedResult);\n+    }\n+\n+    public static void testIt(Class<?> testClass, int expectedResult) throws Exception {\n@@ -44,4 +55,4 @@\n-            int exp_minor = (expectedResult >> 16) & 0x0000FFFF;\n-            int exp_major = expectedResult & 0x0000FFFF;\n-            int got_minor = (ver >> 16) & 0x0000FFFF;\n-            int got_major = ver & 0x0000FFFF;\n+            int exp_minor = (expectedResult >> 16) & LOWER_16;\n+            int exp_major = expectedResult & LOWER_16;\n+            int got_minor = (ver >> 16) & LOWER_16;\n+            int got_major = ver & LOWER_16;\n@@ -58,0 +69,5 @@\n+        int latestMajor = ClassFileFormatVersion.latest().major();\n+\n+        testIt(Object.class, latestMajor);\n+        \/\/ ClassFileVersionTest use preview features so its minor version should be 0xFFFF\n+        testIt(ClassFileVersionTest.class, (~LOWER_16) | latestMajor);\n@@ -60,3 +76,1 @@\n-        testIt(\"Version45_3\", 0x3002D);  \/\/ 3:45\n-        \/\/ test minor version of 65535.\n-        testIt(\"Version64_65535\", 0xFFFF0040);  \/\/ 0xFFFF0040 = 65535:64\n+        testIt(\"Version45_3\", 0x0003_002D);  \/\/ 3:45\n@@ -67,2 +81,2 @@\n-            int got_minor = (ver >> 16) & 0x0000FFFF;\n-            int got_major = ver & 0x0000FFFF;\n+            int got_minor = (ver >> 16) & LOWER_16;\n+            int got_major = ver & LOWER_16;\n@@ -76,2 +90,2 @@\n-            int got_minor = (ver >> 16) & 0x0000FFFF;\n-            int got_major = ver & 0x0000FFFF;\n+            int got_minor = (ver >> 16) & LOWER_16;\n+            int got_major = ver & LOWER_16;\n@@ -85,2 +99,2 @@\n-            int got_minor = (ver >> 16) & 0x0000FFFF;\n-            int got_major = ver & 0x0000FFFF;\n+            int got_minor = (ver >> 16) & LOWER_16;\n+            int got_major = ver & LOWER_16;\n","filename":"test\/hotspot\/jtreg\/runtime\/ClassFile\/ClassFileVersionTest.java","additions":29,"deletions":15,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -204,91 +204,0 @@\n-\n-\/\/ Class with major version 64 and minor version 65535\n-class Version64_65535 {\n-  0xCAFEBABE;\n-  65535; \/\/ minor version\n-  64; \/\/ version\n-  [14] { \/\/ Constant Pool\n-    ; \/\/ first element is empty\n-    Method #2 #3; \/\/ #1     at 0x0A\n-    class #4; \/\/ #2     at 0x0F\n-    NameAndType #5 #6; \/\/ #3     at 0x12\n-    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n-    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n-    Utf8 \"()V\"; \/\/ #6     at 0x33\n-    class #8; \/\/ #7     at 0x39\n-    Utf8 \"Version64_65535\"; \/\/ #8     at 0x3C\n-    Utf8 \"Code\"; \/\/ #9     at 0x48\n-    Utf8 \"LineNumberTable\"; \/\/ #10     at 0x4F\n-    Utf8 \"hi\"; \/\/ #11     at 0x61\n-    Utf8 \"SourceFile\"; \/\/ #12     at 0x66\n-    Utf8 \"Version64_65535.java\"; \/\/ #13     at 0x73\n-  } \/\/ Constant Pool\n-\n-  0x0021; \/\/ access [ ACC_PUBLIC ACC_SUPER ]\n-  #7;\/\/ this_cpx\n-  #2;\/\/ super_cpx\n-\n-  [0] { \/\/ Interfaces\n-  } \/\/ Interfaces\n-\n-  [0] { \/\/ Fields\n-  } \/\/ Fields\n-\n-  [2] { \/\/ Methods\n-    {  \/\/ method at 0x90\n-      0x0001; \/\/ access\n-      #5; \/\/ name_index       : <init>\n-      #6; \/\/ descriptor_index : ()V\n-      [1] { \/\/ Attributes\n-        Attr(#9, 29) { \/\/ Code at 0x98\n-          1; \/\/ max_stack\n-          1; \/\/ max_locals\n-          Bytes[5]{\n-            0x2AB70001B1;\n-          }\n-          [0] { \/\/ Traps\n-          } \/\/ end Traps\n-          [1] { \/\/ Attributes\n-            Attr(#10, 6) { \/\/ LineNumberTable at 0xAF\n-              [1] { \/\/ line_number_table\n-                0  1; \/\/  at 0xBB\n-              }\n-            } \/\/ end LineNumberTable\n-          } \/\/ Attributes\n-        } \/\/ end Code\n-      } \/\/ Attributes\n-    }\n-    ;\n-    {  \/\/ method at 0xBB\n-      0x0009; \/\/ access\n-      #11; \/\/ name_index       : hi\n-      #6; \/\/ descriptor_index : ()V\n-      [1] { \/\/ Attributes\n-        Attr(#9, 25) { \/\/ Code at 0xC3\n-          0; \/\/ max_stack\n-          0; \/\/ max_locals\n-          Bytes[1]{\n-            0xB1;\n-          }\n-          [0] { \/\/ Traps\n-          } \/\/ end Traps\n-          [1] { \/\/ Attributes\n-            Attr(#10, 6) { \/\/ LineNumberTable at 0xD6\n-              [1] { \/\/ line_number_table\n-                0  2; \/\/  at 0xE2\n-              }\n-            } \/\/ end LineNumberTable\n-          } \/\/ Attributes\n-        } \/\/ end Code\n-      } \/\/ Attributes\n-    }\n-  } \/\/ Methods\n-\n-  [1] { \/\/ Attributes\n-    Attr(#12, 2) { \/\/ SourceFile at 0xE4\n-      #13;\n-    } \/\/ end SourceFile\n-  } \/\/ Attributes\n-} \/\/ end class Version64_65535\n-\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/ClassFile\/classFileVersions.jcod","additions":0,"deletions":91,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-        \".*Hashtable.*new_entry.*\\n\" +\n-        \".*ModuleEntryTable.*new_entry.*\\n\" +\n@@ -70,9 +68,0 @@\n-    \/* Alternate stacktrace that we check if the default fails, because\n-       new_entry may be inlined.\n-    *\/\n-    private static String stackTraceAlternate =\n-        \".*Hashtable.*new_entry.*\\n\" +\n-        \".*ModuleEntryTable.*locked_create_entry.*\\n\" +\n-        \".*Modules.*define_module.*\\n\" +\n-        \".*JVM_DefineModule.*\\n\";\n-\n@@ -86,1 +75,0 @@\n-        \".*ModuleEntryTable.*new_entry.*\\n\" +\n@@ -152,7 +140,1 @@\n-            if (!stackTraceMatches(stackTraceDefault, output)) {\n-                System.out.println(\"Looking for alternate stack matching:\");\n-                System.out.print(stackTraceAlternate);\n-                if (stackTraceMatches(stackTraceAlternate, output)) {\n-                    return;\n-                }\n-            } else {\n+            if (stackTraceMatches(stackTraceDefault, output)) {\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/CheckForProperDetailStackTrace.java","additions":1,"deletions":19,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-    String msg = \"OutOfMemoryError: Metaspace\";\n+    String msg = \"OutOfMemoryError: ((Metaspace)|(Compressed class space))\";\n@@ -56,1 +56,1 @@\n-    CDSTestUtils.executeAndLog(pb, \"dump\").shouldContain(msg).shouldHaveExitValue(1);\n+    CDSTestUtils.executeAndLog(pb, \"dump\").shouldMatch(msg).shouldHaveExitValue(1);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/MaxMetaspaceSize.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,2 @@\n+    String unableToUseMsg = \"Unable to use shared archive\";\n+    String mismatchMsg = \"shared class paths mismatch (hint: enable -Xlog:class+path=info to diagnose the failure)\";\n@@ -52,2 +54,6 @@\n-        .assertAbnormalExit(\"Unable to use shared archive\",\n-                            \"shared class paths mismatch\");\n+        .assertAbnormalExit(unableToUseMsg, mismatchMsg);\n+\n+    \/\/ Run with -Xshare:auto and without CDS logging enabled, the mismatch message\n+    \/\/ should still be there.\n+    OutputAnalyzer output = TestCommon.execAuto(\"Hello\");\n+    output.shouldContain(mismatchMsg);\n@@ -63,2 +69,11 @@\n-        .assertAbnormalExit(\"Unable to use shared archive\",\n-                            \"shared class paths mismatch\");\n+        .assertAbnormalExit(unableToUseMsg, mismatchMsg);\n+\n+    \/\/ modify the timestamp of the jar2\n+    (new File(jar2.toString())).setLastModified(System.currentTimeMillis() + 2000);\n+\n+    \/\/ Run with -Xshare:auto and without CDS logging enabled, the \"timestamp has changed\"\n+    \/\/ message should be there.\n+    output = TestCommon.execAuto(\n+        \"-cp\", jars, \"Hello\");\n+    output.shouldMatch(\"A jar file is not the one used while building the shared archive file:.*jar2.jar\")\n+          .shouldMatch(\".warning..cds.*jar2.jar timestamp has changed.\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/WrongClasspath.java","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.nio.file.Path;\n@@ -52,1 +53,0 @@\n-    private static final String javaClassPath = System.getProperty(\"java.class.path\");\n@@ -60,8 +60,1 @@\n-        String[] classPaths = javaClassPath.split(File.pathSeparator);\n-        String testngJar = null;\n-        for (String path : classPaths) {\n-            if (path.endsWith(\"testng.jar\")) {\n-                testngJar = path;\n-                break;\n-            }\n-        }\n+        String testngJar = Path.of(Test.class.getProtectionDomain().getCodeSource().getLocation().toURI()).toString();\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/CDSStreamTestDriver.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @requires vm.cds\n+ * @requires vm.cds & vm.hasJFR\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/JFRDynamicCDS.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -105,6 +105,4 @@\n-        \/\/ Now rename classes.jsa to old-classes.jsa\n-        String dstDir = java_home_dst + File.separator + \"lib\" + File.separator + \"server\";\n-        CDSTestUtils.rename(new File(dstDir + File.separator +  \"classes.jsa\"),\n-                            new File(dstDir + File.separator +  \"old-classes.jsa\"));\n-        System.out.println(\"======= renamed classes.jsa to old-classes.jsa\");\n-\n+        \/\/ Remove all possible default archives\n+        removeDefaultArchives(java_home_dst, \"zero\");\n+        removeDefaultArchives(java_home_dst, \"server\");\n+        removeDefaultArchives(java_home_dst, \"client\");\n@@ -119,1 +117,0 @@\n-                      .shouldContain(\"mixed mode\")\n@@ -145,0 +142,1 @@\n+    }\n@@ -146,0 +144,12 @@\n+    private static void removeDefaultArchives(String java_home_dst, String variant) {\n+        removeDefaultArchive(java_home_dst, variant, \"\");\n+        removeDefaultArchive(java_home_dst, variant, \"_nocoops\");\n+    }\n+\n+    private static void removeDefaultArchive(String java_home_dst, String variant, String suffix) {\n+        String fileName = java_home_dst + File.separator + \"lib\" + File.separator + variant +\n+                          File.separator +  \"classes\" + suffix + \".jsa\";\n+        File f = new File(fileName);\n+        if (f.delete()) {\n+            System.out.println(\"======= removed \" + fileName);\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/TestAutoCreateSharedArchiveNoDefaultArchive.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+        String topArchiveMsg = \"The top archive failed to load\";\n+\n@@ -74,1 +76,26 @@\n-          .assertNormalExit(\"The top archive failed to load\");\n+          .assertNormalExit(topArchiveMsg);\n+\n+        \/\/ Turn off all CDS logging, the \"shared class paths mismatch\" warning\n+        \/\/ message should still be there.\n+        run2_WB(baseArchiveName, topArchiveName,\n+                \"-Xshare:auto\",\n+                \"-cp\", wrongJar, mainClass,\n+                \"assertShared:java.lang.Object\",  \/\/ base archive still useable\n+                \"assertNotShared:GenericTestApp\") \/\/ but top archive is not useable\n+          .assertNormalExit(topArchiveMsg,\n+                            \"shared class paths mismatch (hint: enable -Xlog:class+path=info to diagnose the failure)\");\n+\n+        \/\/ modify the timestamp of appJar\n+        (new File(appJar.toString())).setLastModified(System.currentTimeMillis() + 2000);\n+\n+        \/\/ Without CDS logging enabled, the \"timestamp has changed\" message should\n+        \/\/ be there.\n+        run2_WB(baseArchiveName, topArchiveName,\n+                \"-Xshare:auto\",\n+                \"-cp\", appJar, mainClass,\n+                \"assertShared:java.lang.Object\",  \/\/ base archive still useable\n+                \"assertNotShared:GenericTestApp\") \/\/ but top archive is not useable\n+          .assertNormalExit(output -> {\n+              output.shouldContain(topArchiveMsg);\n+              output.shouldMatch(\"A jar file is not the one used while building the shared archive file:.*GenericTestApp.jar\");\n+              output.shouldMatch(\".warning..cds.*GenericTestApp.jar timestamp has changed.\");});\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/WrongTopClasspath.java","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * Simple application that checks that shutdown does not commence until\n+ * after the last non-daemon thread has terminated. Reporting failure is\n+ * tricky because we can't uses exceptions (as they are ignored from Shutdown\n+ * hooks) and we can't call System.exit. So we rely on System.out being checked\n+ * in the TestDaemonDestroy application.\n+ *\/\n+public class Main {\n+\n+    static volatile Thread t1;\n+\n+    public static void main() {\n+        t1 = new Thread(() -> {\n+                System.out.println(\"T1 started\");\n+                try {\n+                    Thread.sleep(5000);\n+                } catch (InterruptedException ignore) { }\n+                System.out.println(\"T1 finished\");\n+            }, \"T1\");\n+\n+        t1.setDaemon(false);\n+\n+        Thread hook = new Thread(() -> {\n+                System.out.println(\"HOOK started\");\n+                if (t1.isAlive()) {\n+                    System.out.println(\"Error: T1 isAlive\");\n+                }\n+            }, \"HOOK\");\n+        Runtime.getRuntime().addShutdownHook(hook);\n+        t1.start();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/daemonDestroy\/Main.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8290732\n+ * @comment Test uses custom launcher that attempts to destroy the VM on both\n+ *          a daemon and non-daemon thread. The result should be the same in\n+ *          both cases.\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @build Main\n+ * @run main\/native TestDaemonDestroy\n+ * @run main\/native TestDaemonDestroy daemon\n+ *\/\n+\n+\/\/ Logic copied from SigTestDriver\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class TestDaemonDestroy {\n+\n+    public static void main(String[] args) throws IOException {\n+        Path launcher = Paths.get(Utils.TEST_NATIVE_PATH)\n+            .resolve(\"daemonDestroy\" + (Platform.isWindows() ? \".exe\" : \"\"))\n+            .toAbsolutePath();\n+\n+        System.out.println(\"Launcher = \" + launcher +\n+                           (Files.exists(launcher) ? \" (exists)\" : \" (missing)\"));\n+\n+        List<String> cmd = new ArrayList<>();\n+        cmd.add(launcher.toString());\n+        cmd.add(\"-Djava.class.path=\" + Utils.TEST_CLASS_PATH);\n+        if (args.length > 0) {\n+            cmd.add(\"daemon\");\n+        }\n+        ProcessBuilder pb = new ProcessBuilder(cmd);\n+\n+        \/\/ Need to add libjvm location to LD_LIBRARY_PATH\n+        String envVar = Platform.sharedLibraryPathVariableName();\n+        pb.environment().merge(envVar, Platform.jvmLibDir().toString(),\n+                               (x, y) -> y + File.pathSeparator + x);\n+\n+        OutputAnalyzer oa = new OutputAnalyzer(pb.start());\n+        oa.shouldHaveExitValue(0);\n+        oa.shouldNotContain(\"Error: T1 isAlive\");\n+        oa.shouldContain(\"T1 finished\");\n+        oa.reportDiagnosticSummary();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/daemonDestroy\/TestDaemonDestroy.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+#include <stdlib.h>\n+\n+static JavaVMOption options[] = {\n+  { \"-Djava.class.path=.\", NULL }, \/\/ gets overwritten with real value\n+};\n+\n+static JavaVMInitArgs vm_args = {\n+  JNI_VERSION_19,\n+  sizeof(options) \/ sizeof(JavaVMOption),\n+  options,\n+  JNI_FALSE\n+};\n+\n+int main(int argc, char *argv[]) {\n+  JavaVM *jvm;\n+  JNIEnv *env;\n+\n+  if (argc < 2) {\n+    fprintf(stderr, \"Usage: main <classpath property> [daemon]\\n\");\n+    exit(1);\n+  }\n+\n+  char* cp = argv[1];\n+\n+  printf(\"Test using classpath: %s\\n\", cp);\n+\n+  options[0].optionString = cp;\n+\n+  jint res = JNI_CreateJavaVM(&jvm, (void**)&env, &vm_args);\n+  if (res != JNI_OK) {\n+    fprintf(stderr, \"Test Error: JNI_CreateJavaVM failed: %d\\n\", res);\n+    exit(1);\n+  }\n+\n+  jclass cls = (*env)->FindClass(env, \"Main\");\n+  if (cls == NULL) {\n+    fprintf(stderr, \"Test Error. Can't load class Main\\n\");\n+    (*env)->ExceptionDescribe(env);\n+    exit(1);\n+  }\n+\n+  jmethodID mid = (*env)->GetStaticMethodID(env, cls, \"main\", \"()V\");\n+  if (mid == NULL) {\n+    fprintf(stderr, \"Test Error. Can't find method main\\n\");\n+    (*env)->ExceptionDescribe(env);\n+    exit(1);\n+  }\n+\n+  (*env)->CallStaticVoidMethod(env, cls, mid);\n+\n+  res = (*jvm)->DetachCurrentThread(jvm);\n+  if (res != JNI_OK) {\n+    fprintf(stderr, \"Test Error: DetachCurrentThread failed: %d\\n\", res);\n+    exit(1);\n+  }\n+\n+  \/\/ Any additional arg implies to use a daemon thread.\n+  if (argc > 2) {\n+    res = (*jvm)->AttachCurrentThreadAsDaemon(jvm, (void **)&env, NULL);\n+    if (res != JNI_OK) {\n+      fprintf(stderr, \"Test Error: AttachCurrentThreadAsDaemon failed: %d\\n\", res);\n+      exit(1);\n+    }\n+    puts(\"Test: attached as daemon\");\n+  } else {\n+    res = (*jvm)->AttachCurrentThread(jvm, (void **)&env, NULL);\n+    if (res != JNI_OK) {\n+      fprintf(stderr, \"Test Error: AttachCurrentThread failed: %d\\n\", res);\n+      exit(1);\n+    }\n+    puts(\"Test: attached as non-daemon\");\n+  }\n+\n+  puts(\"Test: calling DestroyJavaVM\");\n+  res = (*jvm)->DestroyJavaVM(jvm);\n+  if (res != JNI_OK) {\n+    fprintf(stderr, \"Test Error: DestroyJavaVM failed: %d\\n\", res);\n+    exit(1);\n+  }\n+  puts(\"Test: DestroyJavaVM returned\");\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/daemonDestroy\/exedaemonDestroy.c","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -26,2 +26,2 @@\n- * @bug 8285792\n- * @summary fix issues with signal handler modification checks\n+ * @bug 8292559\n+ * @summary test that -XX:+CheckJNICalss displays changed signal handlers.\n@@ -38,7 +38,0 @@\n-    \/\/ Check that a substring occurs exactly once.\n-    public static boolean occursOnce(String source, String substring) {\n-        int index = source.indexOf(substring);\n-        if (index == -1) return false;\n-        return (source.indexOf(substring, index + 1) == -1);\n-    }\n-\n@@ -53,1 +46,1 @@\n-            \/\/ Create a new java process for the TestPsig Java\/JNI test\n+            \/\/ Create a new java process for the TestPsig Java\/JNI test.\n@@ -59,1 +52,1 @@\n-            \/\/ Start the process and check the output\n+            \/\/ Start the process and check the output.\n@@ -62,2 +55,2 @@\n-            if (!occursOnce(outputString, \"SIGFPE: sig_handler in \") ||\n-                !occursOnce(outputString, \"SIGILL: sig_handler in \")) {\n+            if (!outputString.contains(\"Warning: SIGILL handler modified!\") ||\n+                !outputString.contains(\"Warning: SIGFPE handler modified!\")) {\n@@ -65,1 +58,1 @@\n-                throw new RuntimeException(\"Test failed, bad output.\");\n+                throw new RuntimeException(\"Test failed, missing signal Warning\");\n","filename":"test\/hotspot\/jtreg\/runtime\/posixSig\/TestPosixSig.java","additions":7,"deletions":14,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -31,6 +31,1 @@\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-void sig_handler(int sig, siginfo_t *info, ucontext_t *context) {\n-\n+static void sig_handler(int sig, siginfo_t *info, ucontext_t *context) {\n@@ -50,5 +45,0 @@\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/posixSig\/libTestPsig.c","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,3 @@\n- * @run main\/othervm -XX:-UseGCOverheadLimit gc.gctests.LoadUnloadGC2.LoadUnloadGC2\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI gc.gctests.LoadUnloadGC2.LoadUnloadGC2\n@@ -39,0 +41,1 @@\n+import jdk.test.whitebox.WhiteBox;\n@@ -47,0 +50,1 @@\n+        private static int CYCLE = 1000;\n@@ -50,0 +54,1 @@\n+                int iteration = 0;\n@@ -51,0 +56,1 @@\n+                        GarbageProducer garbageProducer = new GeneratedClassProducer();\n@@ -52,4 +58,10 @@\n-                                GarbageProducer garbageProducer = new GeneratedClassProducer();\n-                                log.info(\"Iteration: \" + stresser.getIteration());\n-                                GarbageUtils.eatMemory(stresser, garbageProducer, 0);\n-                                garbageProducer = null;\n+                                garbageProducer.create(512L);\n+                                if(iteration++ > CYCLE) {\n+                                    \/\/ Unload once every cycle.\n+                                    iteration = 0;\n+                                    garbageProducer = null;\n+                                    \/\/ Perform GC so that\n+                                    \/\/ class gets unloaded\n+                                    WhiteBox.getWhiteBox().fullGC();\n+                                    garbageProducer = new GeneratedClassProducer();\n+                               }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/LoadUnloadGC2\/LoadUnloadGC2.java","additions":18,"deletions":6,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-    private static final int INCREMENT = 100 * 1024; \/\/ 100kb\n+    private static final int INCREMENT = 100 * 1024 * 1024 ; \/\/ 100MB\n@@ -57,3 +57,3 @@\n-            log.display(i + \" pool \" + monitor.getName(pool) + \" of type: \" + monitor.getType(pool));\n-            if (!monitor.isUsageThresholdSupported(pool)) {\n-                log.display(\"  does not support usage thresholds: skip\");\n+            \/\/ Skip non-heap pools, as they have unpredictable behaviour, or if\n+            \/\/ usage threshold not supported:\n+            if (monitor.getType(pool) != MemoryType.HEAP  || !monitor.isUsageThresholdSupported(pool)) {\n@@ -62,0 +62,1 @@\n+            log.display(i + \" pool \" + monitor.getName(pool) + \" of type: \" + monitor.getType(pool));\n@@ -65,0 +66,1 @@\n+            MemoryUsage peakUsage = monitor.getPeakUsage(pool);\n@@ -68,0 +70,1 @@\n+            long peakUsed = peakUsage.getUsed();\n@@ -79,0 +82,1 @@\n+            log.display(\"peak used value is \" + peakUsed);\n@@ -98,1 +102,1 @@\n-            MemoryUsage peakUsage = monitor.getPeakUsage(pool);\n+            peakUsage = monitor.getPeakUsage(pool);\n@@ -101,2 +105,1 @@\n-            long peakUsed = usage.getUsed();\n-            long peakMax = usage.getMax();\n+            peakUsed = peakUsage.getUsed();\n@@ -105,2 +108,1 @@\n-            log.display(\"peak used value is \" + peakUsed + \" peak max is \" + peakMax);\n-            log.display(\"  threshold set to \" + threshold);\n+            log.display(\"peak used value is \" + peakUsed);\n@@ -110,6 +112,0 @@\n-            \/\/ Test can be imprecise, particularly with CodeHeap: usage changes outside our control.\n-            if (thresholdCount > 0 && monitor.getType(pool) != MemoryType.HEAP) {\n-                log.display(\"  thresholdCount increasing outside our control for non-heap Pool: skip\");\n-                continue;\n-            }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/MemoryPoolMBean\/isUsageThresholdExceeded\/isexceeded001.java","additions":11,"deletions":15,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import java.net.URI;\n@@ -27,0 +28,1 @@\n+import java.nio.file.Path;\n@@ -164,1 +166,1 @@\n-         Set.of(\"jtreg.jar\", \"javatest.jar\", \"testng.jar\", \"jcommander.jar\");\n+         Set.of(\"jtreg.*jar\", \"javatest.*jar\", \"testng.*jar\", \"jcommander.*jar\");\n@@ -216,3 +218,4 @@\n-        String path = (loc == null) ? null : loc.getPath();\n-        return path != null && TEST_JARS.stream()\n-                                .filter(path::endsWith)\n+        URI uri = (loc == null) ? null : URI.create(loc.toString());\n+        String name = (uri == null) ? null : Path.of(uri).getFileName().toString();\n+        return name != null && TEST_JARS.stream()\n+                                .filter(name::matches)\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/libs\/jaxp\/library\/JAXPPolicyManager.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package xpath;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import org.w3c.dom.Document;\n+\n+import javax.xml.xpath.XPathExpressionException;\n+\n+\/*\n+ * @test\n+ * @bug 8290837\n+ * @library \/javax\/xml\/jaxp\/unittest\n+ * @run testng xpath.XPathBooleanFnTest\n+ * @summary Tests the XPath Boolean Functions\n+ *\/\n+public class XPathBooleanFnTest extends XPathTestBase {\n+\n+    private static final Document doc = getDtdDocument();\n+\n+    \/*\n+     * DataProvider for testing the boolean, not, true, false and lang\n+     * functions.\n+     * Data columns:\n+     *  see parameters of the test \"testBooleanFn\"\n+     *\/\n+    @DataProvider(name = \"booleanExpTestCases\")\n+    public Object[][] getBooleanExp() {\n+        return new Object[][]{\n+                {\"true()\", true},\n+                {\"false()\", false},\n+\n+                {\"boolean(true())\", true},\n+                {\"boolean(false())\", false},\n+                {\"boolean(1)\", true},\n+                {\"boolean(0)\", false},\n+                {\"boolean(-1)\", true},\n+                {\"boolean(1+1)\", true},\n+                {\"boolean(1-1)\", false},\n+                {\"boolean(1+'abc')\", false},\n+                {\"boolean('abc')\", true},\n+                {\"boolean('')\", false},\n+                {\"boolean(\/\/Name)\", true},\n+                {\"boolean(\/\/LastName)\", false},\n+                {\"boolean(\/\/Customer[1]\/ClubMember)\", true},\n+                {\"boolean(\/\/Customer[2]\/ClubMember)\", true},\n+                {\"boolean(\/\/Customer[2]\/ClubMember='true')\", false},\n+                {\"boolean(\/\/Customer[1]\/ClubMember or \" +\n+                        \"\/\/Customer[2]\/ClubMember)\", true},\n+                {\"boolean(\/\/Customer[1]\/ClubMember and \" +\n+                        \"\/\/Customer[2]\/ClubMember)\", true},\n+                {\"boolean(\/\/*[boolean(.)=true()])\", true},\n+                {\"boolean(\/\/*[boolean(.)=false()])\", false},\n+\n+                {\"not(1)\", false},\n+                {\"not(-1)\", false},\n+                {\"not(0)\", true},\n+                {\"not(true())\", false},\n+                {\"not(false())\", true},\n+                {\"not(\/\/Customer[1]\/ClubMember)\", false},\n+                {\"not(\/\/Customer[2]\/ClubMember)\", false},\n+                {\"not(\/\/Customer[2]\/ClubMember='true')\", true},\n+                {\"boolean(\/\/*[not(.)=true()])\", false},\n+                {\"boolean(\/\/*[not(.)=false()])\", true},\n+\n+                {\"boolean(\/\/*[lang('en')])\", true},\n+                {\"boolean(\/\/*[lang('es')])\", false},\n+        };\n+    }\n+\n+    \/*\n+     * DataProvider for testing XPathExpressionException being thrown on\n+     * invalid boolean function usage.\n+     * Data columns:\n+     *  see parameters of the test \"testExceptionOnEval\"\n+     *\/\n+    @DataProvider(name = \"exceptionExpTestCases\")\n+    public Object[][] getExceptionExp() {\n+        return new Object[][]{\n+                \/\/ Argument is required for these functions\n+                {\"boolean()\"},\n+                {\"\/\/*[boolean()=true()]\"},\n+                {\"not()\"},\n+                {\"\/\/*[not()=true()]\"},\n+                {\"lang()\"},\n+                {\"\/*[lang()=true()]\"},\n+\n+                \/\/ No arguments should be passed to these functions\n+                {\"true(1)\"},\n+                {\"false(0)\"},\n+                {\"\/\/*[true(.)=true()]\"},\n+                {\"\/\/*[false(.)=false()]\"},\n+        };\n+    }\n+\n+    \/**\n+     * Verifies that the result of evaluating the boolean, not, true, false\n+     * and lang functions matches the expected result.\n+     *\n+     * @param exp      XPath expression\n+     * @param expected expected result\n+     * @throws Exception if test fails\n+     *\/\n+    @Test(dataProvider = \"booleanExpTestCases\")\n+    void testBooleanFn(String exp, boolean expected) throws Exception {\n+        testExp(doc, exp, expected, Boolean.class);\n+    }\n+\n+    \/**\n+     * Verifies that XPathExpressionException is thrown on xpath evaluation.\n+     *\n+     * @param exp XPath expression\n+     *\/\n+    @Test(dataProvider = \"exceptionExpTestCases\")\n+    void testExceptionOnEval(String exp) {\n+        Assert.assertThrows(XPathExpressionException.class, () -> testEval(doc,\n+                exp));\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/xpath\/XPathBooleanFnTest.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -72,1 +72,2 @@\n-                {\"count(\/\/@*)\", ID_ATTRIBUTES + FOO_ID_ATTRIBUTES},\n+                {\"count(\/\/@*)\",\n+                        LANG_ATTRIBUTES + ID_ATTRIBUTES + FOO_ID_ATTRIBUTES},\n@@ -76,1 +77,1 @@\n-                                        CUSTOMER_ELEMENTS},\n+                                        (CUSTOMER_ELEMENTS + ADDRESS_ELEMENTS)},\n@@ -79,0 +80,1 @@\n+                {\"count(.)\", ROOT},\n@@ -82,1 +84,1 @@\n-                                        CUSTOMER_ELEMENTS},\n+                                        (CUSTOMER_ELEMENTS + ADDRESS_ELEMENTS)},\n@@ -86,1 +88,2 @@\n-                        CUSTOMERS - 1 + (CUSTOMERS - 1) * CUSTOMER_ELEMENTS},\n+                        CUSTOMERS - 1 + (CUSTOMERS - 1) *\n+                                (CUSTOMER_ELEMENTS + ADDRESS_ELEMENTS)},\n@@ -90,1 +93,2 @@\n-                {\"count(\/\/Customer[1]\/descendant::*)\", CUSTOMER_ELEMENTS},\n+                {\"count(\/\/Customer[1]\/descendant::*)\",\n+                        CUSTOMER_ELEMENTS + ADDRESS_ELEMENTS},\n@@ -92,1 +96,3 @@\n-                        CUSTOMER_ELEMENTS + 1},\n+                        CUSTOMER_ELEMENTS + ADDRESS_ELEMENTS + 1},\n+                \/\/ node() returns all children of the context node including\n+                \/\/ element nodes and text nodes.\n@@ -94,1 +100,1 @@\n-                        ID_ATTRIBUTES + CUSTOMERS * CUSTOMER_ELEMENTS},\n+                        CUSTOMERS + CUSTOMERS * (CUSTOMER_ELEMENTS * 2)},\n@@ -107,0 +113,1 @@\n+                {\"\/\/Customer[position()]\", \"Customer_x1\"},\n@@ -128,0 +135,1 @@\n+                {\"local-name(\/\/*[local-name(.)='Customer'])\", \"Customer\"},\n@@ -135,0 +143,1 @@\n+                {\"name(\/\/*[namespace-uri(.)=\\\"foo\\\"])\", \"foo:Customer\"},\n@@ -140,0 +149,42 @@\n+                {\"name(\/\/*[name(.)='foo:Customer'])\", \"foo:Customer\"},\n+        };\n+    }\n+\n+    \/*\n+     * DataProvider for testing XPathExpressionException being thrown on\n+     * invalid node set function usage.\n+     * Data columns:\n+     *  see parameters of the test \"testExceptionOnEval\"\n+     *\/\n+    @DataProvider(name = \"exceptionExpTestCases\")\n+    public Object[][] getExceptionExp() {\n+        return new Object[][]{\n+                \/\/ Argument is required for these functions\n+                {\"\/\/Customer[id()]\"},\n+                {\"\/\/Customer[id()='x1']\"},\n+                {\"\/\/Customer[count()]\"},\n+                {\"\/\/*[count()=3]\"},\n+\n+                \/\/ No argument should be passed to these functions\n+                {\"\/\/Customer[position(.)]\"},\n+                {\"\/\/*[position(\/\/Customer[1])]\"},\n+                {\"\/\/Customer[last(.)]\"},\n+                {\"\/\/*[last(\/\/Customer[1])]\"},\n+\n+                \/\/ Node-set argument is required for these functions\n+                {\"count(1)\"},\n+                {\"count(true())\"},\n+                {\"count('')\"},\n+                {\"count('abc')\"},\n+                {\"local-name(1)\"},\n+                {\"local-name(true())\"},\n+                {\"local-name('')\"},\n+                {\"local-name('abc')\"},\n+                {\"name(1)\"},\n+                {\"name(true())\"},\n+                {\"name('')\"},\n+                {\"name('abc')\"},\n+                {\"namespace-uri(1)\"},\n+                {\"namespace-uri(true())\"},\n+                {\"namespace-uri('')\"},\n+                {\"namespace-uri('abc')\"},\n@@ -222,0 +273,11 @@\n+\n+    \/**\n+     * Verifies that XPathExpressionException is thrown on xpath evaluation.\n+     *\n+     * @param exp XPath expression\n+     *\/\n+    @Test(dataProvider = \"exceptionExpTestCases\")\n+    void testExceptionOnEval(String exp) {\n+        Assert.assertThrows(XPathExpressionException.class, () -> testEval(doc,\n+                exp));\n+    }\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/xpath\/XPathNodeSetFnTest.java","additions":69,"deletions":7,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package xpath;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import org.w3c.dom.Document;\n+\n+import javax.xml.xpath.XPathExpressionException;\n+import java.util.stream.IntStream;\n+\n+\/*\n+ * @test\n+ * @bug 8290838\n+ * @library \/javax\/xml\/jaxp\/unittest\n+ * @run testng xpath.XPathNumberFnTest\n+ * @summary Tests the XPath Number Functions\n+ *\/\n+public class XPathNumberFnTest extends XPathTestBase {\n+\n+    private static final Document doc = getDtdDocument();\n+\n+    \/*\n+     * DataProvider for testing the number, sum, floor, ceiling and round\n+     * functions.\n+     * Data columns:\n+     *  see parameters of the test \"testNumberFn\"\n+     *\/\n+    @DataProvider(name = \"numberExpTestCases\")\n+    public Object[][] getNumberExp() {\n+        return new Object[][]{\n+                {\"number(1)\", 1.0},\n+                {\"number(-1)\", -1.0},\n+                {\"number(0)\", 0},\n+                {\"number(\/\/Customer[2]\/Age)\", CUSTOMER_AGES[1]},\n+                {\"number(\/\/Customer[1]\/Age + \/\/Customer[2]\/Age)\",\n+                        CUSTOMER_AGES[0] + CUSTOMER_AGES[1]},\n+                {\"number('abc')\", Double.NaN},\n+                {\"number('')\", Double.NaN},\n+                {String.format(\"number(\/\/Age[number()=%d])\", CUSTOMER_AGES[1]),\n+                        CUSTOMER_AGES[1]},\n+                {String.format(\"number(\/\/Age[number(.)=%d])\", CUSTOMER_AGES[1]),\n+                        CUSTOMER_AGES[1]},\n+                {\"number(\/\/Customer[1]\/Name)\", Double.NaN},\n+                {\"number(\/\/Customer[2]\/Age + \/\/Customer[1]\/Name)\", Double.NaN},\n+                {\"number(true())\", 1},\n+                {\"number(false())\", 0},\n+\n+                {\"sum(\/\/Age)\", IntStream.of(CUSTOMER_AGES).sum()},\n+                {\"sum(\/\/Customer[2]\/Age)\", CUSTOMER_AGES[1]},\n+\n+                {\"floor(1.1)\", 1.0},\n+                {\"floor(-1.6)\", -2.0},\n+                {\"floor(1.0 div 0)\", Double.POSITIVE_INFINITY},\n+                {\"floor(-1.0 div 0)\", Double.NEGATIVE_INFINITY},\n+                {\"floor(true())\", 1},\n+                {\"floor(false())\", 0},\n+                {\"floor(abc)\", Double.NaN},\n+                {\"floor('')\", Double.NaN},\n+                {\"floor(\/\/Customer[2]\/Age)\", CUSTOMER_AGES[1]},\n+                {\"floor(\/\/Customer[1]\/Name)\", Double.NaN},\n+                {String.format(\"number(\/\/Age[floor(.)=%d])\", CUSTOMER_AGES[1]),\n+                        CUSTOMER_AGES[1]},\n+\n+                {\"ceiling(1.1)\", 2.0},\n+                {\"ceiling(-1.4)\", -1.0},\n+                {\"ceiling(1.0 div 0)\", Double.POSITIVE_INFINITY},\n+                {\"ceiling(-1.0 div 0)\", Double.NEGATIVE_INFINITY},\n+                {\"ceiling(true())\", 1},\n+                {\"ceiling(false())\", 0},\n+                {\"ceiling(abc)\", Double.NaN},\n+                {\"ceiling('')\", Double.NaN},\n+                {\"ceiling(\/\/Customer[2]\/Age)\", CUSTOMER_AGES[1]},\n+                {\"ceiling(\/\/Customer[1]\/Name)\", Double.NaN},\n+                {String.format(\"number(\/\/Age[ceiling(.)=%d])\",\n+                        CUSTOMER_AGES[1]), CUSTOMER_AGES[1]},\n+\n+                {\"round(1.49)\", 1.0},\n+                {\"round(1.5)\", 2.0},\n+                {\"round(-1.5)\", -1.0},\n+                {\"round(-1.51)\", -2.0},\n+                {\"round(1.0 div 0)\", Double.POSITIVE_INFINITY},\n+                {\"round(-1.0 div 0)\", Double.NEGATIVE_INFINITY},\n+                {\"round(true())\", 1},\n+                {\"round(false())\", 0},\n+                {\"round(abc)\", Double.NaN},\n+                {\"round('')\", Double.NaN},\n+                {\"round(\/\/Customer[2]\/Age)\", CUSTOMER_AGES[1]},\n+                {\"round(\/\/Customer[1]\/Name)\", Double.NaN},\n+                {String.format(\"number(\/\/Age[round(.)=%d])\",\n+                        CUSTOMER_AGES[1]), CUSTOMER_AGES[1]},\n+        };\n+    }\n+\n+    \/*\n+     * DataProvider for testing XPathExpressionException being thrown on\n+     * invalid number function usage.\n+     * Data columns:\n+     *  see parameters of the test \"testExceptionOnEval\"\n+     *\/\n+    @DataProvider(name = \"exceptionExpTestCases\")\n+    public Object[][] getExceptionExp() {\n+        return new Object[][]{\n+                \/\/ Argument is required for these functions\n+                {\"\/\/Age[floor()=1.0]\"},\n+                {\"(\/Age[ceiling()=1.0]\"},\n+                {\"\/\/Age[round()=1.0]\"},\n+                {\"\/\/Age[sum()]\"},\n+\n+                \/\/ Node-set argument is required for these functions\n+                {\"sum(1)\"},\n+                {\"sum(true())\"},\n+                {\"sum('')\"},\n+                {\"sum('abc')\"},\n+        };\n+    }\n+\n+    \/**\n+     * Verifies that the result of evaluating the number, sum, floor, ceiling\n+     * and round functions matches the expected result.\n+     *\n+     * @param exp      XPath expression\n+     * @param expected expected result\n+     * @throws Exception if test fails\n+     *\/\n+    @Test(dataProvider = \"numberExpTestCases\")\n+    void testNumberFn(String exp, double expected) throws Exception {\n+        testExp(doc, exp, expected, Double.class);\n+    }\n+\n+    \/**\n+     * Verifies that XPathExpressionException is thrown on xpath evaluation.\n+     *\n+     * @param exp XPath expression\n+     *\/\n+    @Test(dataProvider = \"exceptionExpTestCases\")\n+    void testExceptionOnEval(String exp) {\n+        Assert.assertThrows(XPathExpressionException.class, () -> testEval(doc,\n+                exp));\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/xpath\/XPathNumberFnTest.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -0,0 +1,384 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package xpath;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import org.w3c.dom.Document;\n+\n+import javax.xml.xpath.XPathExpressionException;\n+\n+\/*\n+ * @test\n+ * @bug 8290836\n+ * @library \/javax\/xml\/jaxp\/unittest\n+ * @run testng xpath.XPathStringFnTest\n+ * @summary Tests the XPath String Functions\n+ *\/\n+public class XPathStringFnTest extends XPathTestBase {\n+\n+    private static final Document doc = getDtdDocument();\n+\n+    \/*\n+     * DataProvider for testing the string function.\n+     * Data columns:\n+     *  see parameters of the test \"testStringFn\"\n+     *\/\n+    @DataProvider(name = \"stringExpTestCases\")\n+    public Object[][] getStringExp() {\n+        return new Object[][]{\n+                {\"string(-0.0)\", \"0\"},\n+                {\"string(0-1)\", \"-1\"},\n+                {\"string(1=1)\", \"true\"},\n+                {\"string(1>2)\", \"false\"},\n+                {\"string(1+a)\", \"NaN\"},\n+                {\"string(1.0 div 0)\", \"Infinity\"},\n+                {\"string(-1.0 div 0)\", \"-Infinity\"},\n+                {\"string(\/\/Customer\/Name)\", \"name1\"},\n+                {\"string(\/\/Customer[1]\/@id)\", \"x1\"},\n+                {\"string(\/\/Customer\/LastName)\", \"\"},\n+                {\"string(\/\/Customer[1]\/Age)\",\n+                        Integer.toString(CUSTOMER_AGES[0])},\n+                {\"string(number(\/\/Customer[2]\/Age))\",\n+                        Integer.toString(CUSTOMER_AGES[1])},\n+                {\"string(\/\/Customer[1]\/Age + \/\/Customer[2]\/Age)\",\n+                        Integer.toString(CUSTOMER_AGES[0] + CUSTOMER_AGES[1])},\n+                {\"string(\/\/Customer[1]\/Age + \/\/Customer[1]\/Name)\", \"NaN\"},\n+                {\"string(\/\/Customer[1]\/ClubMember='true')\", \"true\"},\n+                {\"string(\/\/Customer[2]\/ClubMember='true')\", \"false\"},\n+                {\"string(\/\/Customer[1]\/ClubMember or \" +\n+                        \"\/\/Customer[2]\/ClubMember)\", \"true\"},\n+                {\"string(\/\/Customer[1]\/ClubMember and \" +\n+                        \"\/\/Customer[2]\/ClubMember='true')\", \"false\"},\n+                {\"string(\/\/*[string()='name2'])\", \"name2\"},\n+                {\"string(\/\/*[string(.)='name2'])\", \"name2\"},\n+                {\"string(\/\/*[string(Name)='name2']\/Name)\", \"name2\"},\n+                {\"string(\/\/*[string(@id)='x1']\/\/Street)\", \"1111 111st ave\"},\n+                {\"string(\/\/*[string(..\/@id)='x1']\/Street)\", \"1111 111st ave\"},\n+        };\n+    }\n+\n+    \/*\n+     * DataProvider for testing the concat function.\n+     * Data columns:\n+     *  see parameters of the test \"testConcatFn\"\n+     *\/\n+    @DataProvider(name = \"concatExpTestCases\")\n+    public Object[][] getConcatExp() {\n+        return new Object[][]{\n+                {\"concat('Hello', ' name', 1, true())\", \"Hello name1true\"},\n+                {\"concat('Hello ', \/\/Customer\/Name)\", \"Hello name1\"},\n+                {\"concat('Hello ', \/\/Customer\/LastName)\", \"Hello \"},\n+                {\"concat('(', \/\/@id, ')')\", \"(x1)\"},\n+        };\n+    }\n+\n+    \/*\n+     * DataProvider for testing the substring, substring-before and\n+     * substring-after functions.\n+     * Data columns:\n+     *  see parameters of the test \"testSubstringFn\"\n+     *\/\n+    @DataProvider(name = \"substringExpTestCases\")\n+    public Object[][] getSubstringExp() {\n+\n+        return new Object[][]{\n+                {\"substring('123@xyz.com', 5, 7)\", \"xyz.com\"},\n+                {\"substring('123@xyz.com', 5, 10)\", \"xyz.com\"},\n+                {\"substring(\/\/Email, 5, 7)\", \"xyz.com\"},\n+                {\"substring(\/\/Email, 5)\", \"xyz.com\"},\n+                {\"substring(\/\/Email, 1, string-length(.))\", \"123@xyz.com\"},\n+                {\"substring(\/\/Email, 1, string-length(.)+1)\", \"123@xyz.com\"},\n+                {\"substring(\/\/LastName, 1)\", \"\"},\n+                {\"string(\/\/*[substring(., 1)='name2'])\", \"name2\"},\n+\n+                {\"substring-before('123@xyz.com', '@')\", \"123\"},\n+                {\"substring-before(\/\/Email, '@')\", \"123\"},\n+                {\"substring-before(\/\/Email, '?')\", \"\"},\n+                {\"substring-before(\/\/Email, '')\", \"\"},\n+                {\"substring-before(\/\/LastName, '')\", \"\"},\n+                {\"string(\/\/*[substring-before(., ' ')='1111'])\", \"1111 111st \" +\n+                        \"ave\"},\n+\n+                {\"substring-after('123@xyz.com', '@')\", \"xyz.com\"},\n+                {\"substring-after(\/\/Email, '@')\", \"xyz.com\"},\n+                {\"substring-after(\/\/Email, '?')\", \"\"},\n+                {\"substring-after(\/\/Email, '')\", \"123@xyz.com\"},\n+                {\"substring-after(\/\/LastName, '')\", \"\"},\n+                {\"string(\/\/*[substring-after(., ' ')='111st ave'])\", \"1111 \" +\n+                        \"111st ave\"},\n+        };\n+    }\n+\n+    \/*\n+     * DataProvider for testing the normalize-space function.\n+     * Data columns:\n+     *  see parameters of the test \"testNormalizeSpaceFn\"\n+     *\/\n+    @DataProvider(name = \"normalizeExpTestCases\")\n+    public Object[][] getNormalizeExp() {\n+        return new Object[][]{\n+                {\"normalize-space('  1111   111st   ave  ')\", \"1111 111st ave\"},\n+                {\"normalize-space(true())\", \"true\"},\n+                {\"normalize-space(1.234)\", \"1.234\"},\n+                {\"normalize-space(\/\/Customer[1]\/\/Street)\", \"1111 111st ave\"},\n+                {\"normalize-space(\/\/Customer[2]\/\/Street)\", \"2222 222nd ave\"},\n+                {\"normalize-space(\/\/LastName)\", \"\"},\n+                {\"string(\/\/*[normalize-space()='name1'])\", \"name1\"},\n+                {\"string(\/\/*[normalize-space(.)='name1'])\", \"name1\"},\n+                {\"string(\/\/*[normalize-space(Name)='name2']\/Name)\", \"name2\"},\n+                {\"string(\/\/*[normalize-space(@id)='x1']\/\/Street)\", \"1111 \" +\n+                        \"111st ave\"},\n+                {\"string(\/\/*[normalize-space(..\/@id)='x1']\/Street)\", \"1111 \" +\n+                        \"111st ave\"},\n+        };\n+    }\n+\n+    \/*\n+     * DataProvider for testing the translate function.\n+     * Data columns:\n+     *  see parameters of the test \"testTranslateFn\"\n+     *\/\n+    @DataProvider(name = \"translateExpTestCases\")\n+    public Object[][] getTranslateExp() {\n+        return new Object[][]{\n+                {\"translate('1111 111st ave', ' ', '')\", \"1111111stave\"},\n+                {\"translate('1111 111st ave', '', '')\", \"1111 111st ave\"},\n+                {\"translate('1111 111st ave', '1 ', '')\", \"stave\"},\n+                {\"translate('abcabcdcd', 'abcd', 'xyz')\", \"xyzxyzz\"},\n+                {\"translate('abcabcdcd', 'bcd', 'uvwxyz')\", \"auvauvwvw\"},\n+                {\"translate('aabccdacbabcb', 'aaccbbdd', 'wxyz')\", \"wwyywywy\"},\n+                {\"translate(\/\/Customer[1]\/\/Street, \" +\n+                        \"'abcdefghijklmnopqrstuvwxyz', \" +\n+                        \"'ABCDEFGHIJKLMNOPQRSTUVWXYZ')\",\n+                        \"1111 111ST AVE\"},\n+                {\"translate(\/\/LastName, 'name', 'NAME')\", \"\"},\n+                {\"translate(true(), true(), false())\", \"fals\"},\n+                {\"translate(123, 2, 3)\", \"133\"},\n+        };\n+    }\n+\n+    \/*\n+     * DataProvider for testing the string-length function.\n+     * Data columns:\n+     *  see parameters of the test \"testStringLengthFn\"\n+     *\/\n+    @DataProvider(name = \"stringLengthExpTestCases\")\n+    public Object[][] getStringLengthExp() {\n+        return new Object[][]{\n+                {\"string-length('')\", 0},\n+                {\"string-length(123)\", 3},\n+                {\"string-length(true())\", 4},\n+                {\"string-length('1111 111st ave')\", 14.0},\n+                {\"string-length(\/\/Customer[1]\/\/Street)\", 14.0},\n+                {\"string-length(\/\/LastName)\", 0},\n+                {\"string-length(\/\/Customer[1]\/Name)\", 5},\n+                {\"string-length(\/\/Customer[1]\/@id)\", 2},\n+                {\"string-length(name(\/\/*[string-length()=10]))\", 5},\n+                {\"string-length(name(\/\/*[string-length(.)=10]))\", 5},\n+        };\n+    }\n+\n+    \/*\n+     * DataProvider for testing the starts-with function.\n+     * Data columns:\n+     *  see parameters of the test \"testStartsWithFn\"\n+     *\/\n+    @DataProvider(name = \"startsWithExpTestCases\")\n+    public Object[][] getStartsWithExp() {\n+        return new Object[][]{\n+                {\"starts-with(\/\/Email, '123')\", true},\n+                {\"starts-with(\/\/Email, 123)\", true},\n+                {\"starts-with(\/\/Email, '?')\", false},\n+                {\"starts-with(\/\/Email, '')\", true},\n+                {\"starts-with(\/\/Customer\/@id, 'x')\", true},\n+                {\"starts-with(\/\/LastName, '')\", true},\n+                {\"boolean(\/\/*[starts-with(., 'name2')]='name2')\", true},\n+                {\"boolean(\/\/*[starts-with(text(), 'name')]='name2')\", true},\n+                {\"boolean(\/\/*[starts-with(., 'name1')]\/.='name2')\", false},\n+        };\n+    }\n+\n+    \/*\n+     * DataProvider for testing the contains function.\n+     * Data columns:\n+     *  see parameters of the test \"testContainsFn\"\n+     *\/\n+    @DataProvider(name = \"containsExpTestCases\")\n+    public Object[][] getContainsExp() {\n+        return new Object[][]{\n+                {\"contains(\/\/Email, '123')\", true},\n+                {\"contains(\/\/Email, 123)\", true},\n+                {\"contains(\/\/Email, '?')\", false},\n+                {\"contains(\/\/Email, '')\", true},\n+                {\"contains(\/\/Customer\/@id, 'x')\", true},\n+                {\"contains(\/\/LastName, '')\", true},\n+                {\"boolean(\/\/*[contains(., 'name2')]='name2')\", true},\n+                {\"boolean(\/\/*[contains(text(), 'name')]='name2')\", true},\n+                {\"boolean(\/\/*[contains(., 'name1')]\/.='name2')\", false},\n+        };\n+    }\n+\n+    \/*\n+     * DataProvider for testing XPathExpressionException being thrown on\n+     * invalid string function usage.\n+     * Data columns:\n+     *  see parameters of the test \"testExceptionOnEval\"\n+     *\/\n+    @DataProvider(name = \"exceptionExpTestCases\")\n+    public Object[][] getExceptionExp() {\n+        return new Object[][]{\n+                \/\/ At least two arguments are required for these functions\n+                {\"\/\/*[concat()='name2']\"},\n+                {\"\/\/*[concat(.)='name2']\"},\n+                {\"\/\/*[substring()='name2']\"},\n+                {\"\/\/*[substring(.)='name2']\"},\n+                {\"\/\/*[substring-before()='name2']\"},\n+                {\"\/\/*[substring-before(.)='name2']\"},\n+                {\"\/\/*[substring-after()='name2']\"},\n+                {\"\/\/*[substring-after(.)='name2']\"},\n+                {\"\/\/*[translate()='name2']\"},\n+                {\"\/\/*[translate(.)='name2']\"},\n+                {\"\/\/*[contains()]\"},\n+                {\"\/\/*[contains(.)]\"},\n+                {\"\/\/*[starts-with()]\"},\n+                {\"\/\/*[starts-with(.)]\"},\n+        };\n+    }\n+\n+    \/**\n+     * Verifies that the result of evaluating the string function matches\n+     * the expected result.\n+     *\n+     * @param exp      XPath expression\n+     * @param expected expected result\n+     * @throws Exception if test fails\n+     *\/\n+    @Test(dataProvider = \"stringExpTestCases\")\n+    void testStringFn(String exp, String expected) throws Exception {\n+        testExp(doc, exp, expected, String.class);\n+    }\n+\n+    \/**\n+     * Verifies that the result of evaluating the concat function matches\n+     * the expected result.\n+     *\n+     * @param exp      XPath expression\n+     * @param expected expected result\n+     * @throws Exception if test fails\n+     *\/\n+    @Test(dataProvider = \"concatExpTestCases\")\n+    void testConcatFn(String exp, String expected) throws Exception {\n+        testExp(doc, exp, expected, String.class);\n+    }\n+\n+    \/**\n+     * Verifies that the result of evaluating the substring, substring-before\n+     * and substring-after functions matches the expected result.\n+     *\n+     * @param exp      XPath expression\n+     * @param expected expected result\n+     * @throws Exception if test fails\n+     *\/\n+    @Test(dataProvider = \"substringExpTestCases\")\n+    void testSubstringFn(String exp, String expected) throws Exception {\n+        testExp(doc, exp, expected, String.class);\n+    }\n+\n+    \/**\n+     * Verifies that the result of evaluating the normalize-space function\n+     * matches the expected result.\n+     *\n+     * @param exp      XPath expression\n+     * @param expected expected result\n+     * @throws Exception if test fails\n+     *\/\n+    @Test(dataProvider = \"normalizeExpTestCases\")\n+    void testNormalizeSpaceFn(String exp, String expected) throws Exception {\n+        testExp(doc, exp, expected, String.class);\n+    }\n+\n+    \/**\n+     * Verifies that the result of evaluating the translate function matches\n+     * the expected result.\n+     *\n+     * @param exp      XPath expression\n+     * @param expected expected result\n+     * @throws Exception if test fails\n+     *\/\n+    @Test(dataProvider = \"translateExpTestCases\")\n+    void testTranslateFn(String exp, String expected) throws Exception {\n+        testExp(doc, exp, expected, String.class);\n+    }\n+\n+    \/**\n+     * Verifies that the result of evaluating the string-length function matches\n+     * the expected result.\n+     *\n+     * @param exp      XPath expression\n+     * @param expected expected result\n+     * @throws Exception if test fails\n+     *\/\n+    @Test(dataProvider = \"stringLengthExpTestCases\")\n+    void testStringLengthFn(String exp, double expected) throws Exception {\n+        testExp(doc, exp, expected, Double.class);\n+    }\n+\n+    \/**\n+     * Verifies that the result of evaluating the starts-with function\n+     * matches the expected result.\n+     *\n+     * @param exp      XPath expression\n+     * @param expected expected result\n+     * @throws Exception if test fails\n+     *\/\n+    @Test(dataProvider = \"startsWithExpTestCases\")\n+    void testStartsWithFn(String exp, boolean expected) throws Exception {\n+        testExp(doc, exp, expected, Boolean.class);\n+    }\n+\n+    \/**\n+     * Verifies that the result of evaluating the contains function matches\n+     * the expected result.\n+     *\n+     * @param exp      XPath expression\n+     * @param expected expected result\n+     * @throws Exception if test fails\n+     *\/\n+    @Test(dataProvider = \"containsExpTestCases\")\n+    void testContainsFn(String exp, Boolean expected) throws Exception {\n+        testExp(doc, exp, expected, Boolean.class);\n+    }\n+\n+    \/**\n+     * Verifies that XPathExpressionException is thrown on xpath evaluation.\n+     *\n+     * @param exp XPath expression\n+     *\/\n+    @Test(dataProvider = \"exceptionExpTestCases\")\n+    void testExceptionOnEval(String exp) {\n+        Assert.assertThrows(XPathExpressionException.class, () -> testEval(doc,\n+                exp));\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/xpath\/XPathStringFnTest.java","additions":384,"deletions":0,"binary":false,"changes":384,"status":"added"},{"patch":"@@ -32,4 +32,1 @@\n-import javax.xml.xpath.XPath;\n-import javax.xml.xpath.XPathFactory;\n-import javax.xml.xpath.XPathNodes;\n-import javax.xml.xpath.XPathEvaluationResult;\n+import javax.xml.xpath.*;\n@@ -41,0 +38,1 @@\n+import org.testng.Assert;\n@@ -55,1 +53,1 @@\n-               <!ELEMENT Customer (Name, Phone, Email, Address)>\n+               <!ELEMENT Customer (Name, Phone, Email, Address, Age, ClubMember)>\n@@ -60,0 +58,2 @@\n+               <!ELEMENT Age (#PCDATA)>\n+               <!ELEMENT ClubMember (#PCDATA)>\n@@ -70,1 +70,1 @@\n-            = \"<Customers xmlns:foo=\\\"foo\\\">\"\n+            = \"<Customers xmlns:foo=\\\"foo\\\" xml:lang=\\\"en\\\">\"\n@@ -80,0 +80,2 @@\n+            + \"        <Age>0<\/Age>\"\n+            + \"        <ClubMember>true<\/ClubMember>\"\n@@ -86,1 +88,1 @@\n-            + \"            <Street>2222 222nd ave<\/Street>\"\n+            + \"            <Street>  2222 222nd ave  <\/Street>\"\n@@ -90,0 +92,2 @@\n+            + \"        <Age>100<\/Age>\"\n+            + \"        <ClubMember>false<\/ClubMember>\"\n@@ -100,0 +104,2 @@\n+            + \"        <Age>-100<\/Age>\"\n+            + \"        <ClubMember>false<\/ClubMember>\"\n@@ -110,0 +116,2 @@\n+            + \"        <foo:Age>0<\/foo:Age>\"\n+            + \"        <foo:ClubMember>true<\/foo:ClubMember>\"\n@@ -116,0 +124,1 @@\n+    final int LANG_ATTRIBUTES = 1;\n@@ -120,1 +129,3 @@\n-    final int CUSTOMER_ELEMENTS = 7;\n+    final int CUSTOMER_ELEMENTS = 6;\n+    \/\/ Number of Address elements.\n+    final int ADDRESS_ELEMENTS = 3;\n@@ -125,0 +136,2 @@\n+    \/\/ Customer Ages\n+    final int[] CUSTOMER_AGES = {0, 100, -100, 0};\n@@ -190,0 +203,41 @@\n+    \/**\n+     * Evaluates XPath expression and checks if it matches the expected result.\n+     *\n+     * @param doc xml document {@link org.w3c.dom.Document}\n+     * @param exp xpath expression string\n+     * @param expected expected result\n+     * @param clazz expected result type for evaluation.\n+     * @param <T> expected result type\n+     *\n+     * @throws Exception if test fails\n+     *\/\n+    static <T> void testExp(Document doc, String exp, T expected,\n+                          Class<T> clazz) throws Exception {\n+        XPath xPath = XPathFactory.newInstance().newXPath();\n+\n+        T result = xPath.evaluateExpression(exp, doc, clazz);\n+        T result2 = (T) xPath.evaluate(exp, doc,\n+                XPathEvaluationResult.XPathResultType.getQNameType(clazz));\n+\n+        Assert.assertEquals(result, expected);\n+        Assert.assertEquals(result2, result);\n+    }\n+\n+    \/**\n+     * Evaluates XPath expression.\n+     *\n+     * @param doc xml document {@link org.w3c.dom.Document}\n+     * @param exp xpath expression string\n+     *\n+     * @throws Exception if test fails\n+     *\/\n+    static void testEval(Document doc, String exp) throws Exception {\n+        XPath xPath = XPathFactory.newInstance().newXPath();\n+\n+        try {\n+            xPath.evaluateExpression(exp, doc);\n+        } catch (XPathExpressionException e) {\n+            xPath.evaluate(exp, doc);\n+        }\n+    }\n+\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/xpath\/XPathTestBase.java","additions":62,"deletions":8,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -471,0 +471,1 @@\n+java\/awt\/image\/multiresolution\/MultiresolutionIconTest.java 8291979 linux-x64,windows-all\n@@ -512,0 +513,1 @@\n+java\/io\/File\/GetXSpace.java                                     8291911 windows-all\n@@ -557,1 +559,1 @@\n-java\/nio\/channels\/DatagramChannel\/Unref.java                    8233519 generic-all\n+java\/nio\/channels\/DatagramChannel\/Unref.java                    8233437 generic-all\n@@ -596,3 +598,0 @@\n-sun\/security\/tools\/jarsigner\/warnings\/BadKeyUsageTest.java      8026393 generic-all\n-\n-javax\/net\/ssl\/ServerName\/SSLEngineExplorerMatchedSNI.java       8212096 generic-all\n@@ -619,2 +618,0 @@\n-javax\/security\/auth\/kerberos\/KerberosHashEqualsTest.java        8039280 generic-all\n-javax\/security\/auth\/kerberos\/KerberosTixDateTest.java           8039280 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- *\n+ * @test\n@@ -29,8 +29,3 @@\n- *\/\n-\n-\/*\n- * This test is just a sanity check and does not check for the correct\n- * value.  The correct value should be checked manually:\n- * Solaris\/Linux:\n- *   1. In a shell, as user who started java process, enter the command\n- *      \"limit -h descriptors\"\n+ * @requires os.family != \"windows\"\n+ *\n+ * @run main GetMaxFileDescriptorCount\n@@ -45,1 +40,1 @@\n-        (UnixOperatingSystemMXBean)ManagementFactory.getOperatingSystemMXBean();\n+        (UnixOperatingSystemMXBean) ManagementFactory.getOperatingSystemMXBean();\n@@ -47,3 +42,1 @@\n-    \/\/ Careful with these values.\n-    \/\/ Min count for pass dynamically determined below.\n-    private static long       min_count_for_pass = 1;\n+    private static long       minCountForPass = 1;\n@@ -52,2 +45,0 @@\n-    private static boolean trace = false;\n-\n@@ -55,3 +46,0 @@\n-        if (args.length > 0 && args[0].equals(\"trace\")) {\n-            trace = true;\n-        }\n@@ -59,3 +47,3 @@\n-        long min_count = mbean.getOpenFileDescriptorCount();\n-        if (min_count > 0) {\n-            min_count_for_pass = min_count;\n+        long minCount = mbean.getOpenFileDescriptorCount();\n+        if (minCount > 0) {\n+            minCountForPass = minCount;\n@@ -66,3 +54,1 @@\n-        if (trace) {\n-            System.out.println(\"Max file descriptor count: \" + count);\n-        }\n+        System.out.println(\"Max file descriptor count: \" + count);\n@@ -70,1 +56,1 @@\n-        if (count < min_count_for_pass || count > MAX_COUNT_FOR_PASS) {\n+        if (count < minCountForPass || count > MAX_COUNT_FOR_PASS) {\n@@ -73,1 +59,1 @@\n-                                       \"(MIN = \" + min_count_for_pass + \"; \" +\n+                                       \"(MIN = \" + minCountForPass + \"; \" +\n","filename":"test\/jdk\/com\/sun\/management\/UnixOperatingSystemMXBean\/GetMaxFileDescriptorCount.java","additions":13,"deletions":27,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1,60 +0,0 @@\n-#\n-# Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#\n-# @test\n-# @bug     4858522\n-# @summary\n-# @author  Steve Bohne\n-#\n-# @run shell GetMaxFileDescriptorCount.sh\n-#\n-\n-if [ \"${TESTJAVA}\" = \"\" ] ; then\n-     echo \"--Error: TESTJAVA must be defined as the pathname of a jdk to test.\"\n-     exit 1\n-fi\n-if [ \"${COMPILEJAVA}\" = \"\" ]; then\n-    COMPILEJAVA=\"${TESTJAVA}\"\n-fi\n-\n-runOne()\n-{\n-   echo \"runOne $@\"\n-   $COMPILEJAVA\/bin\/javac ${TESTJAVACOPTS} ${TESTTOOLVMOPTS} -d $TESTCLASSES \\\n-       $TESTSRC\/$@.java || exit 2\n-   $TESTJAVA\/bin\/java ${TESTVMOPTS} -classpath $TESTCLASSES $@        || exit 3\n-}\n-\n-# Test GetMaxFileDescriptorCount if we are running on Unix\n-case `uname -s` in\n-    Linux )\n-       runOne GetMaxFileDescriptorCount\n-       ;;\n-    * )\n-       echo \"Ignore test when not run on Linux\"\n-       exit 0\n-       ;;\n-esac\n-\n-exit 0\n","filename":"test\/jdk\/com\/sun\/management\/UnixOperatingSystemMXBean\/GetMaxFileDescriptorCount.sh","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+ * @test\n@@ -28,8 +29,3 @@\n- *\/\n-\n-\/*\n- * This test is just a sanity check and does not check for the correct\n- * value.  The correct value should be checked manually:\n- * Solaris\/Linux:\n- *   1. Find the pid of the java process.\n- *   2. In a shell, enter the command: \"ls -1 \/proc\/<pid>\/fd | wc -l\"\n+ * @requires os.family != \"windows\"\n+ *\n+ * @run main GetOpenFileDescriptorCount\n@@ -44,1 +40,1 @@\n-        (UnixOperatingSystemMXBean)ManagementFactory.getOperatingSystemMXBean();\n+        (UnixOperatingSystemMXBean) ManagementFactory.getOperatingSystemMXBean();\n@@ -46,1 +42,0 @@\n-    \/\/ Careful with these values.\n@@ -48,4 +43,1 @@\n-    \/\/ Max count for pass dynamically determined below\n-    private static long       max_count_for_pass = Long.MAX_VALUE;\n-\n-    private static boolean trace = false;\n+    private static long       maxCountForPass = Long.MAX_VALUE;\n@@ -54,3 +46,0 @@\n-        if (args.length > 0 && args[0].equals(\"trace\")) {\n-            trace = true;\n-        }\n@@ -58,3 +47,3 @@\n-        long max_count = mbean.getMaxFileDescriptorCount();\n-        if (max_count > 0) {\n-            max_count_for_pass = max_count;\n+        long maxCount = mbean.getMaxFileDescriptorCount();\n+        if (maxCount > 0) {\n+            maxCountForPass = maxCount;\n@@ -65,3 +54,1 @@\n-        if (trace) {\n-            System.out.println(\"Open file descriptor count: \" + count);\n-        }\n+        System.out.println(\"Open file descriptor count: \" + count);\n@@ -69,1 +56,1 @@\n-        if (count < MIN_COUNT_FOR_PASS || count > max_count_for_pass) {\n+        if (count < MIN_COUNT_FOR_PASS || count > maxCountForPass) {\n@@ -73,1 +60,1 @@\n-                                       \"MAX = \" + max_count_for_pass + \")\");\n+                                       \"MAX = \" + maxCountForPass + \")\");\n","filename":"test\/jdk\/com\/sun\/management\/UnixOperatingSystemMXBean\/GetOpenFileDescriptorCount.java","additions":13,"deletions":26,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -1,59 +0,0 @@\n-#\n-# Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#\n-# @test\n-# @bug     4858522\n-# @summary\n-# @author  Steve Bohne\n-#\n-# @run shell GetOpenFileDescriptorCount.sh\n-#\n-\n-if [ \"${TESTJAVA}\" = \"\" ] ; then\n-     echo \"--Error: TESTJAVA must be defined as the pathname of a jdk to test.\"\n-     exit 1\n-fi\n-if [ \"${COMPILEJAVA}\" = \"\" ]; then\n-    COMPILEJAVA=\"${TESTJAVA}\"\n-fi\n-runOne()\n-{\n-   echo \"runOne $@\"\n-   $COMPILEJAVA\/bin\/javac ${TESTJAVACOPTS} ${TESTTOOLVMOPTS} -d $TESTCLASSES \\\n-       $TESTSRC\/$@.java || exit 2\n-   $TESTJAVA\/bin\/java ${TESTVMOPTS} -classpath $TESTCLASSES $@        || exit 3\n-}\n-\n-# Test GetOpenFileDescriptorCount if we are running on Unix\n-case `uname -s` in\n-    Linux )\n-       runOne GetOpenFileDescriptorCount\n-       ;;\n-    * )\n-       echo \"Ignore test when not run on Linux\"\n-       exit 0\n-       ;;\n-esac\n-\n-exit 0\n","filename":"test\/jdk\/com\/sun\/management\/UnixOperatingSystemMXBean\/GetOpenFileDescriptorCount.sh","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -1,77 +0,0 @@\n-\/*\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.awt.AWTException;\n-import java.awt.Frame;\n-import java.awt.Robot;\n-\n-import sun.awt.AppContext;\n-import sun.awt.SunToolkit;\n-\n-\/**\n- * @test\n- * @key headful\n- * @bug 8136858\n- * @modules java.desktop\/sun.awt\n- * @run main\/othervm\/java.security.policy=java.policy -Djava.security.manager ApplicationThreadsStop\n- *\/\n-public final class ApplicationThreadsStop implements Runnable {\n-\n-    private static AppContext contextToDispose;\n-    private static Thread thread;\n-\n-    public static void main(final String[] args) throws Exception {\n-        ThreadGroup tg = new ThreadGroup(\"TestThreadGroup\");\n-        Thread t = new Thread(tg, new ApplicationThreadsStop());\n-        t.start();\n-        t.join();\n-        contextToDispose.dispose();\n-        \/\/ wait for appcontext to be destroyed\n-        Thread.sleep(10000);\n-        if(thread.isAlive()){\n-            throw new RuntimeException(\"Thread is alive\");\n-        }\n-    }\n-\n-    @Override\n-    public void run() {\n-        contextToDispose = SunToolkit.createNewAppContext();\n-        Frame f = new Frame();\n-        f.setSize(300, 300);\n-        f.setLocationRelativeTo(null);\n-        f.setVisible(true);\n-        thread = new Thread(() -> {\n-            while(true);\n-        });\n-        thread.start();\n-        sync();\n-    }\n-\n-    private static void sync() {\n-        try {\n-            new Robot().waitForIdle();\n-        } catch (AWTException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/awt\/AppContext\/ApplicationThreadsStop\/ApplicationThreadsStop.java","additions":0,"deletions":77,"binary":false,"changes":77,"status":"deleted"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, JetBrains s.r.o.. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @key headful\n+ * @bug 8287600 8291266\n+ * @requires os.family == \"mac\"\n+ * @summary [macosx] Some primitives do not render in metal pipeline\n+ * @run main DrawPrimitivesTest\n+ *\/\n+\n+import java.awt.AWTException;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.RenderingHints;\n+import java.awt.Robot;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.concurrent.CountDownLatch;\n+import javax.swing.JFrame;\n+import javax.swing.JPanel;\n+import javax.swing.SwingUtilities;\n+\n+public abstract class DrawPrimitivesTest extends JFrame {\n+    private final static int W = 800;\n+    private final static int H = 800;\n+    private final static Color[] color = { Color.RED, Color.BLUE, Color.GREEN};\n+    private final static int COLOR_TOLERANCE = 10;\n+    private final CountDownLatch latchRender = new CountDownLatch(1);\n+    private volatile int frameX0 = 0;\n+    private volatile int frameY0 = 0;\n+    private final String name;\n+\n+\n+    private static boolean isAlmostEqual(Color c1, Color c2) {\n+        return Math.abs(c1.getRed() - c2.getRed()) < COLOR_TOLERANCE &&\n+                Math.abs(c1.getGreen() - c2.getGreen()) < COLOR_TOLERANCE &&\n+                Math.abs(c1.getBlue() - c2.getBlue()) < COLOR_TOLERANCE;\n+\n+    }\n+\n+    public static void main(String[] args) throws InterruptedException, AWTException, InvocationTargetException {\n+        new DrawPrimitivesTest(\"drawLine\") {\n+            public void renderPrimitive(Graphics2D g2d, int x0, int y0, int w, int h) {\n+                g2d.drawLine(x0, y0, x0+w, y0+h);\n+            }\n+        }.runTest();\n+\n+        new DrawPrimitivesTest(\"fillRect\") {\n+            public void renderPrimitive(Graphics2D g2d, int x0, int y0, int w, int h) {\n+                g2d.fillRect(x0, y0, w, h);\n+            }\n+        }.runTest();\n+\n+        new DrawPrimitivesTest(\"fillOvalAA\") {\n+            public void renderPrimitive(Graphics2D g2d, int x0, int y0, int w, int h) {\n+                g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n+                g2d.fillOval(x0, y0, w, h);\n+            }\n+        }.runTest();\n+    }\n+\n+    public abstract void renderPrimitive(Graphics2D g2d, int x0, int y0, int w, int h);\n+\n+    public DrawPrimitivesTest(String name) {\n+        super();\n+        this.name = name;\n+    }\n+\n+    public void runTest() throws InterruptedException, InvocationTargetException, AWTException {\n+        SwingUtilities.invokeLater(() -> {\n+            add(new JPanel() {\n+                @Override\n+                public Dimension getPreferredSize() {\n+                    return new Dimension(W, H);\n+                }\n+\n+                @Override\n+                public void paintComponent(Graphics g) {\n+                    Graphics2D g2d = (Graphics2D) g;\n+                    g2d.setColor(Color.YELLOW);\n+                    int c = 0;\n+                    for (int i = 0; i < W; i += 10) {\n+                        for (int j = 0; j < H; j += 10) {\n+                            c = (c + 1) % color.length;\n+                            g2d.setColor(color[c]);\n+                            renderPrimitive(g2d, i, j, 10, 10);\n+                        }\n+                    }\n+                    Point p = getLocationOnScreen();\n+                    frameX0 = p.x;\n+                    frameY0 = p.y - getInsets().top;\n+\n+                    latchRender.countDown();\n+                }\n+            });\n+            setPreferredSize(new Dimension(W, H));\n+            pack();\n+            setVisible(true);\n+        });\n+\n+        latchRender.await();\n+        Thread.sleep(1000);\n+\n+        Robot robot = new Robot();\n+\n+        boolean hasEmptyContent = true;\n+        l:for (int i = frameX0 + W\/3; i < frameX0 + (2*W)\/3; i++) {\n+            for (int j = 0; j < 10; j += 2) {\n+                if (isAlmostEqual(robot.getPixelColor(i, frameY0 + H \/ 2 + j), Color.RED)) {\n+                    hasEmptyContent = false;\n+                    break l;\n+                }\n+            }\n+        }\n+\n+        SwingUtilities.invokeAndWait(() -> {\n+            setVisible(false);\n+            dispose();\n+        });\n+\n+        if (hasEmptyContent) {\n+            throw new RuntimeException(name + \": Empty content\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Graphics2D\/DrawPrimitivesTest.java","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.color.ColorSpace;\n+import java.util.Arrays;\n+\n+\/**\n+ * @test\n+ * @bug 8288633\n+ * @summary Verifies precision of ICC_ColorSpace.toCIEXYZ\/fromCIEXYZ\n+ *\/\n+public final class ToFromCIEXYZRoundTrip {\n+\n+    private static volatile boolean failed;\n+\n+    public static void main(String[] args) throws InterruptedException {\n+        int[] css = {\n+            ColorSpace.CS_CIEXYZ, ColorSpace.CS_GRAY, ColorSpace.CS_LINEAR_RGB,\n+            ColorSpace.CS_PYCC, ColorSpace.CS_sRGB\n+        };\n+        Thread[] threads = new Thread[css.length];\n+        for (int i = 0; i < threads.length; i++) {\n+            int finalI = i;\n+            threads[i] = new Thread(() -> {\n+                test(ColorSpace.getInstance(css[finalI]));\n+            });\n+            threads[i].start();\n+        }\n+        for (Thread thread : threads) {\n+            thread.join();\n+        }\n+        if (failed) {\n+            throw new RuntimeException(\"Too many errors\");\n+        }\n+    }\n+\n+    private static void test(ColorSpace cs) {\n+        ColorSpace rgb = ColorSpace.getInstance(ColorSpace.CS_sRGB);\n+        float[] color = new float[3];\n+        int equal = 0;\n+        int all = 0;\n+        for (int r = 0; r < 256; ++r) {\n+            for (int g = 0; g < 256; ++g) {\n+                for (int b = 0; b < 256; ++b) {\n+                    all++;\n+                    color[0] = r \/ 255.0f;\n+                    color[1] = g \/ 255.0f;\n+                    color[2] = b \/ 255.0f;\n+                    \/\/ Convert some values from srgb to ciexyz. We assume the\n+                    \/\/ result will be a \"good\" point in the ciexyz color space.\n+                    float[] good = rgb.toCIEXYZ(color);\n+                    \/\/ Round trip the \"good\" point, assuming that some results\n+                    \/\/ will be equal to the \"good\" point.\n+                    \/\/ If toCIEXYZ and fromCIEXYZ use different rendering\n+                    \/\/ intents then equal results are unlikely.\n+                    float[] rel = cs.toCIEXYZ(cs.fromCIEXYZ(good));\n+                    if (Arrays.equals(good, rel)) {\n+                        equal++;\n+                    }\n+                }\n+            }\n+        }\n+        int percent = (int) (equal \/ (all \/ 100.0f));\n+        System.err.println(\"All = \" + all);\n+        System.err.println(\"Equal = \" + equal);\n+        System.err.println(\"Percent = \" + percent);\n+        if (equal < 100) {\n+            \/\/ the number 100 is based on the experiments, it was 0 before fix\n+            failed = true;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/color\/ICC_ColorSpace\/ToFromCIEXYZRoundTrip.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,0 +133,1 @@\n+        ClassLoader scl = ClassLoader.getSystemClassLoader();\n@@ -134,1 +135,1 @@\n-            classes.add(Class.forName(name));\n+            classes.add(Class.forName(name, false, scl));\n","filename":"test\/jdk\/java\/beans\/XMLDecoder\/8028054\/Task.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @run main\/othervm --enable-preview TestConstructorFinder\n+ * @run main TestConstructorFinder\n","filename":"test\/jdk\/java\/beans\/XMLDecoder\/8028054\/TestConstructorFinder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @run main\/othervm --enable-preview TestMethodFinder\n+ * @run main TestMethodFinder\n","filename":"test\/jdk\/java\/beans\/XMLDecoder\/8028054\/TestMethodFinder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 6479237\n+ * @bug 6479237 8291641\n","filename":"test\/jdk\/java\/lang\/StackTraceElement\/SerialTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,7 @@\n-        Linker abi = Linker.nativeLinker();\n+        Linker abi;\n+        try {\n+            abi = Linker.nativeLinker();\n+        } catch (UnsupportedOperationException e) {\n+            System.out.println(\"Test skipped, no native linker on this platform\");\n+            return;\n+        }\n","filename":"test\/jdk\/java\/lang\/Thread\/jni\/AttachCurrentThread\/ImplicitAttach.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -509,1 +509,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain boolean\");\n@@ -511,1 +511,8 @@\n-            assertEquals(x, false, \"weakCompareAndSetPlain boolean value\");\n+            assertEquals(x, false, \"success weakCompareAndSetPlain boolean value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(recv, true, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain boolean\");\n+            boolean x = (boolean) vh.get(recv);\n+            assertEquals(x, false, \"failing weakCompareAndSetPlain boolean value\");\n@@ -519,1 +526,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire boolean\");\n+            boolean x = (boolean) vh.get(recv);\n+            assertEquals(x, true, \"success weakCompareAndSetAcquire boolean\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(recv, false, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire boolean\");\n@@ -521,1 +535,1 @@\n-            assertEquals(x, true, \"weakCompareAndSetAcquire boolean\");\n+            assertEquals(x, true, \"failing weakCompareAndSetAcquire boolean value\");\n@@ -529,1 +543,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease boolean\");\n+            boolean x = (boolean) vh.get(recv);\n+            assertEquals(x, false, \"success weakCompareAndSetRelease boolean\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(recv, true, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease boolean\");\n@@ -531,1 +552,1 @@\n-            assertEquals(x, false, \"weakCompareAndSetRelease boolean\");\n+            assertEquals(x, false, \"failing weakCompareAndSetRelease boolean value\");\n@@ -539,1 +560,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSet boolean\");\n@@ -541,1 +562,8 @@\n-            assertEquals(x, true, \"weakCompareAndSet boolean value\");\n+            assertEquals(x, true, \"success weakCompareAndSet boolean value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(recv, false, false);\n+            assertEquals(success, false, \"failing weakCompareAndSet boolean\");\n+            boolean x = (boolean) vh.get(recv);\n+            assertEquals(x, true, \"failing weakCompareAndSet boolean value\");\n@@ -769,1 +797,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain boolean\");\n+            boolean x = (boolean) vh.get();\n+            assertEquals(x, false, \"success weakCompareAndSetPlain boolean value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(true, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain boolean\");\n@@ -771,1 +806,1 @@\n-            assertEquals(x, false, \"weakCompareAndSetPlain boolean value\");\n+            assertEquals(x, false, \"failing weakCompareAndSetPlain boolean value\");\n@@ -779,1 +814,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire boolean\");\n+            boolean x = (boolean) vh.get();\n+            assertEquals(x, true, \"success weakCompareAndSetAcquire boolean\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(false, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire boolean\");\n@@ -781,1 +823,1 @@\n-            assertEquals(x, true, \"weakCompareAndSetAcquire boolean\");\n+            assertEquals(x, true, \"failing weakCompareAndSetAcquire boolean value\");\n@@ -789,1 +831,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease boolean\");\n@@ -791,1 +833,8 @@\n-            assertEquals(x, false, \"weakCompareAndSetRelease boolean\");\n+            assertEquals(x, false, \"success weakCompareAndSetRelease boolean\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(true, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease boolean\");\n+            boolean x = (boolean) vh.get();\n+            assertEquals(x, false, \"failing weakCompareAndSetRelease boolean value\");\n@@ -799,1 +848,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSet boolean\");\n+            boolean x = (boolean) vh.get();\n+            assertEquals(x, true, \"success weakCompareAndSet boolean\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(false, false);\n+            assertEquals(success, false, \"failing weakCompareAndSet boolean\");\n@@ -801,1 +857,1 @@\n-            assertEquals(x, true, \"weakCompareAndSet boolean\");\n+            assertEquals(x, true, \"failing weakCompareAndSet boolean value\");\n@@ -1032,1 +1088,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain boolean\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain boolean\");\n+                boolean x = (boolean) vh.get(array, i);\n+                assertEquals(x, false, \"success weakCompareAndSetPlain boolean value\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetPlain(array, i, true, false);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain boolean\");\n@@ -1034,1 +1097,1 @@\n-                assertEquals(x, false, \"weakCompareAndSetPlain boolean value\");\n+                assertEquals(x, false, \"failing weakCompareAndSetPlain boolean value\");\n@@ -1042,1 +1105,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire boolean\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire boolean\");\n@@ -1044,1 +1107,8 @@\n-                assertEquals(x, true, \"weakCompareAndSetAcquire boolean\");\n+                assertEquals(x, true, \"success weakCompareAndSetAcquire boolean\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetAcquire(array, i, false, false);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire boolean\");\n+                boolean x = (boolean) vh.get(array, i);\n+                assertEquals(x, true, \"failing weakCompareAndSetAcquire boolean value\");\n@@ -1052,1 +1122,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease boolean\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease boolean\");\n+                boolean x = (boolean) vh.get(array, i);\n+                assertEquals(x, false, \"success weakCompareAndSetRelease boolean\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetRelease(array, i, true, false);\n+                assertEquals(success, false, \"failing weakCompareAndSetRelease boolean\");\n@@ -1054,1 +1131,1 @@\n-                assertEquals(x, false, \"weakCompareAndSetRelease boolean\");\n+                assertEquals(x, false, \"failing weakCompareAndSetRelease boolean value\");\n@@ -1062,1 +1139,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet boolean\");\n+                assertEquals(success, true, \"success weakCompareAndSet boolean\");\n+                boolean x = (boolean) vh.get(array, i);\n+                assertEquals(x, true, \"success weakCompareAndSet boolean\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSet(array, i, false, false);\n+                assertEquals(success, false, \"failing weakCompareAndSet boolean\");\n@@ -1064,1 +1148,1 @@\n-                assertEquals(x, true, \"weakCompareAndSet boolean\");\n+                assertEquals(x, true, \"failing weakCompareAndSet boolean value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessBoolean.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -487,1 +487,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain byte\");\n@@ -489,1 +489,8 @@\n-            assertEquals(x, (byte)0x23, \"weakCompareAndSetPlain byte value\");\n+            assertEquals(x, (byte)0x23, \"success weakCompareAndSetPlain byte value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(recv, (byte)0x01, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain byte\");\n+            byte x = (byte) vh.get(recv);\n+            assertEquals(x, (byte)0x23, \"failing weakCompareAndSetPlain byte value\");\n@@ -497,1 +504,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire byte\");\n+            byte x = (byte) vh.get(recv);\n+            assertEquals(x, (byte)0x01, \"success weakCompareAndSetAcquire byte\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(recv, (byte)0x23, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire byte\");\n@@ -499,1 +513,1 @@\n-            assertEquals(x, (byte)0x01, \"weakCompareAndSetAcquire byte\");\n+            assertEquals(x, (byte)0x01, \"failing weakCompareAndSetAcquire byte value\");\n@@ -507,1 +521,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease byte\");\n+            byte x = (byte) vh.get(recv);\n+            assertEquals(x, (byte)0x23, \"success weakCompareAndSetRelease byte\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(recv, (byte)0x01, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease byte\");\n@@ -509,1 +530,1 @@\n-            assertEquals(x, (byte)0x23, \"weakCompareAndSetRelease byte\");\n+            assertEquals(x, (byte)0x23, \"failing weakCompareAndSetRelease byte value\");\n@@ -517,1 +538,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet byte\");\n+            assertEquals(success, true, \"success weakCompareAndSet byte\");\n@@ -519,1 +540,8 @@\n-            assertEquals(x, (byte)0x01, \"weakCompareAndSet byte value\");\n+            assertEquals(x, (byte)0x01, \"success weakCompareAndSet byte value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(recv, (byte)0x23, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSet byte\");\n+            byte x = (byte) vh.get(recv);\n+            assertEquals(x, (byte)0x01, \"failing weakCompareAndSet byte value\");\n@@ -763,1 +791,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain byte\");\n+            byte x = (byte) vh.get();\n+            assertEquals(x, (byte)0x23, \"success weakCompareAndSetPlain byte value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain((byte)0x01, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain byte\");\n@@ -765,1 +800,1 @@\n-            assertEquals(x, (byte)0x23, \"weakCompareAndSetPlain byte value\");\n+            assertEquals(x, (byte)0x23, \"failing weakCompareAndSetPlain byte value\");\n@@ -773,1 +808,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire byte\");\n+            byte x = (byte) vh.get();\n+            assertEquals(x, (byte)0x01, \"success weakCompareAndSetAcquire byte\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire((byte)0x23, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire byte\");\n@@ -775,1 +817,1 @@\n-            assertEquals(x, (byte)0x01, \"weakCompareAndSetAcquire byte\");\n+            assertEquals(x, (byte)0x01, \"failing weakCompareAndSetAcquire byte value\");\n@@ -783,1 +825,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease byte\");\n@@ -785,1 +827,8 @@\n-            assertEquals(x, (byte)0x23, \"weakCompareAndSetRelease byte\");\n+            assertEquals(x, (byte)0x23, \"success weakCompareAndSetRelease byte\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease((byte)0x01, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease byte\");\n+            byte x = (byte) vh.get();\n+            assertEquals(x, (byte)0x23, \"failing weakCompareAndSetRelease byte value\");\n@@ -793,1 +842,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet byte\");\n+            assertEquals(success, true, \"success weakCompareAndSet byte\");\n+            byte x = (byte) vh.get();\n+            assertEquals(x, (byte)0x01, \"success weakCompareAndSet byte\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet((byte)0x23, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSet byte\");\n@@ -795,1 +851,1 @@\n-            assertEquals(x, (byte)0x01, \"weakCompareAndSet byte\");\n+            assertEquals(x, (byte)0x01, \"failing weakCompareAndSet byte value\");\n@@ -1042,1 +1098,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain byte\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain byte\");\n+                byte x = (byte) vh.get(array, i);\n+                assertEquals(x, (byte)0x23, \"success weakCompareAndSetPlain byte value\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetPlain(array, i, (byte)0x01, (byte)0x45);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain byte\");\n@@ -1044,1 +1107,1 @@\n-                assertEquals(x, (byte)0x23, \"weakCompareAndSetPlain byte value\");\n+                assertEquals(x, (byte)0x23, \"failing weakCompareAndSetPlain byte value\");\n@@ -1052,1 +1115,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire byte\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire byte\");\n@@ -1054,1 +1117,8 @@\n-                assertEquals(x, (byte)0x01, \"weakCompareAndSetAcquire byte\");\n+                assertEquals(x, (byte)0x01, \"success weakCompareAndSetAcquire byte\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetAcquire(array, i, (byte)0x23, (byte)0x45);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire byte\");\n+                byte x = (byte) vh.get(array, i);\n+                assertEquals(x, (byte)0x01, \"failing weakCompareAndSetAcquire byte value\");\n@@ -1062,1 +1132,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease byte\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease byte\");\n+                byte x = (byte) vh.get(array, i);\n+                assertEquals(x, (byte)0x23, \"success weakCompareAndSetRelease byte\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetRelease(array, i, (byte)0x01, (byte)0x45);\n+                assertEquals(success, false, \"failing weakCompareAndSetRelease byte\");\n@@ -1064,1 +1141,1 @@\n-                assertEquals(x, (byte)0x23, \"weakCompareAndSetRelease byte\");\n+                assertEquals(x, (byte)0x23, \"failing weakCompareAndSetRelease byte value\");\n@@ -1072,1 +1149,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet byte\");\n+                assertEquals(success, true, \"success weakCompareAndSet byte\");\n+                byte x = (byte) vh.get(array, i);\n+                assertEquals(x, (byte)0x01, \"success weakCompareAndSet byte\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSet(array, i, (byte)0x23, (byte)0x45);\n+                assertEquals(success, false, \"failing weakCompareAndSet byte\");\n@@ -1074,1 +1158,1 @@\n-                assertEquals(x, (byte)0x01, \"weakCompareAndSet byte\");\n+                assertEquals(x, (byte)0x01, \"failing weakCompareAndSet byte value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessByte.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -487,1 +487,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain char\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain char\");\n@@ -489,1 +489,8 @@\n-            assertEquals(x, '\\u4567', \"weakCompareAndSetPlain char value\");\n+            assertEquals(x, '\\u4567', \"success weakCompareAndSetPlain char value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(recv, '\\u0123', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain char\");\n+            char x = (char) vh.get(recv);\n+            assertEquals(x, '\\u4567', \"failing weakCompareAndSetPlain char value\");\n@@ -497,1 +504,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire char\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire char\");\n+            char x = (char) vh.get(recv);\n+            assertEquals(x, '\\u0123', \"success weakCompareAndSetAcquire char\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(recv, '\\u4567', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire char\");\n@@ -499,1 +513,1 @@\n-            assertEquals(x, '\\u0123', \"weakCompareAndSetAcquire char\");\n+            assertEquals(x, '\\u0123', \"failing weakCompareAndSetAcquire char value\");\n@@ -507,1 +521,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease char\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease char\");\n+            char x = (char) vh.get(recv);\n+            assertEquals(x, '\\u4567', \"success weakCompareAndSetRelease char\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(recv, '\\u0123', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease char\");\n@@ -509,1 +530,1 @@\n-            assertEquals(x, '\\u4567', \"weakCompareAndSetRelease char\");\n+            assertEquals(x, '\\u4567', \"failing weakCompareAndSetRelease char value\");\n@@ -517,1 +538,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet char\");\n+            assertEquals(success, true, \"success weakCompareAndSet char\");\n@@ -519,1 +540,8 @@\n-            assertEquals(x, '\\u0123', \"weakCompareAndSet char value\");\n+            assertEquals(x, '\\u0123', \"success weakCompareAndSet char value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(recv, '\\u4567', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSet char\");\n+            char x = (char) vh.get(recv);\n+            assertEquals(x, '\\u0123', \"failing weakCompareAndSet char value\");\n@@ -763,1 +791,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain char\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain char\");\n+            char x = (char) vh.get();\n+            assertEquals(x, '\\u4567', \"success weakCompareAndSetPlain char value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain('\\u0123', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain char\");\n@@ -765,1 +800,1 @@\n-            assertEquals(x, '\\u4567', \"weakCompareAndSetPlain char value\");\n+            assertEquals(x, '\\u4567', \"failing weakCompareAndSetPlain char value\");\n@@ -773,1 +808,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire char\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire char\");\n+            char x = (char) vh.get();\n+            assertEquals(x, '\\u0123', \"success weakCompareAndSetAcquire char\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire('\\u4567', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire char\");\n@@ -775,1 +817,1 @@\n-            assertEquals(x, '\\u0123', \"weakCompareAndSetAcquire char\");\n+            assertEquals(x, '\\u0123', \"failing weakCompareAndSetAcquire char value\");\n@@ -783,1 +825,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease char\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease char\");\n@@ -785,1 +827,8 @@\n-            assertEquals(x, '\\u4567', \"weakCompareAndSetRelease char\");\n+            assertEquals(x, '\\u4567', \"success weakCompareAndSetRelease char\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease('\\u0123', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease char\");\n+            char x = (char) vh.get();\n+            assertEquals(x, '\\u4567', \"failing weakCompareAndSetRelease char value\");\n@@ -793,1 +842,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet char\");\n+            assertEquals(success, true, \"success weakCompareAndSet char\");\n+            char x = (char) vh.get();\n+            assertEquals(x, '\\u0123', \"success weakCompareAndSet char\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet('\\u4567', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSet char\");\n@@ -795,1 +851,1 @@\n-            assertEquals(x, '\\u0123', \"weakCompareAndSet char\");\n+            assertEquals(x, '\\u0123', \"failing weakCompareAndSet char value\");\n@@ -1042,1 +1098,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain char\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain char\");\n+                char x = (char) vh.get(array, i);\n+                assertEquals(x, '\\u4567', \"success weakCompareAndSetPlain char value\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetPlain(array, i, '\\u0123', '\\u89AB');\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain char\");\n@@ -1044,1 +1107,1 @@\n-                assertEquals(x, '\\u4567', \"weakCompareAndSetPlain char value\");\n+                assertEquals(x, '\\u4567', \"failing weakCompareAndSetPlain char value\");\n@@ -1052,1 +1115,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire char\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire char\");\n@@ -1054,1 +1117,8 @@\n-                assertEquals(x, '\\u0123', \"weakCompareAndSetAcquire char\");\n+                assertEquals(x, '\\u0123', \"success weakCompareAndSetAcquire char\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetAcquire(array, i, '\\u4567', '\\u89AB');\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire char\");\n+                char x = (char) vh.get(array, i);\n+                assertEquals(x, '\\u0123', \"failing weakCompareAndSetAcquire char value\");\n@@ -1062,1 +1132,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease char\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease char\");\n+                char x = (char) vh.get(array, i);\n+                assertEquals(x, '\\u4567', \"success weakCompareAndSetRelease char\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetRelease(array, i, '\\u0123', '\\u89AB');\n+                assertEquals(success, false, \"failing weakCompareAndSetRelease char\");\n@@ -1064,1 +1141,1 @@\n-                assertEquals(x, '\\u4567', \"weakCompareAndSetRelease char\");\n+                assertEquals(x, '\\u4567', \"failing weakCompareAndSetRelease char value\");\n@@ -1072,1 +1149,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet char\");\n+                assertEquals(success, true, \"success weakCompareAndSet char\");\n+                char x = (char) vh.get(array, i);\n+                assertEquals(x, '\\u0123', \"success weakCompareAndSet char\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSet(array, i, '\\u4567', '\\u89AB');\n+                assertEquals(success, false, \"failing weakCompareAndSet char\");\n@@ -1074,1 +1158,1 @@\n-                assertEquals(x, '\\u0123', \"weakCompareAndSet char\");\n+                assertEquals(x, '\\u0123', \"failing weakCompareAndSet char value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessChar.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -557,1 +557,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain double\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain double\");\n@@ -559,1 +559,8 @@\n-            assertEquals(x, 2.0d, \"weakCompareAndSetPlain double value\");\n+            assertEquals(x, 2.0d, \"success weakCompareAndSetPlain double value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(recv, 1.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain double\");\n+            double x = (double) vh.get(recv);\n+            assertEquals(x, 2.0d, \"failing weakCompareAndSetPlain double value\");\n@@ -567,1 +574,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire double\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire double\");\n+            double x = (double) vh.get(recv);\n+            assertEquals(x, 1.0d, \"success weakCompareAndSetAcquire double\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(recv, 2.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire double\");\n@@ -569,1 +583,1 @@\n-            assertEquals(x, 1.0d, \"weakCompareAndSetAcquire double\");\n+            assertEquals(x, 1.0d, \"failing weakCompareAndSetAcquire double value\");\n@@ -577,1 +591,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease double\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease double\");\n+            double x = (double) vh.get(recv);\n+            assertEquals(x, 2.0d, \"success weakCompareAndSetRelease double\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(recv, 1.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease double\");\n@@ -579,1 +600,1 @@\n-            assertEquals(x, 2.0d, \"weakCompareAndSetRelease double\");\n+            assertEquals(x, 2.0d, \"failing weakCompareAndSetRelease double value\");\n@@ -587,1 +608,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet double\");\n+            assertEquals(success, true, \"success weakCompareAndSet double\");\n@@ -589,1 +610,8 @@\n-            assertEquals(x, 1.0d, \"weakCompareAndSet double value\");\n+            assertEquals(x, 1.0d, \"success weakCompareAndSet double value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(recv, 2.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSet double\");\n+            double x = (double) vh.get(recv);\n+            assertEquals(x, 1.0d, \"failing weakCompareAndSet double value\");\n@@ -785,1 +813,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain double\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain double\");\n+            double x = (double) vh.get();\n+            assertEquals(x, 2.0d, \"success weakCompareAndSetPlain double value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(1.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain double\");\n@@ -787,1 +822,1 @@\n-            assertEquals(x, 2.0d, \"weakCompareAndSetPlain double value\");\n+            assertEquals(x, 2.0d, \"failing weakCompareAndSetPlain double value\");\n@@ -795,1 +830,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire double\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire double\");\n+            double x = (double) vh.get();\n+            assertEquals(x, 1.0d, \"success weakCompareAndSetAcquire double\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(2.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire double\");\n@@ -797,1 +839,1 @@\n-            assertEquals(x, 1.0d, \"weakCompareAndSetAcquire double\");\n+            assertEquals(x, 1.0d, \"failing weakCompareAndSetAcquire double value\");\n@@ -805,1 +847,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease double\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease double\");\n@@ -807,1 +849,8 @@\n-            assertEquals(x, 2.0d, \"weakCompareAndSetRelease double\");\n+            assertEquals(x, 2.0d, \"success weakCompareAndSetRelease double\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(1.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease double\");\n+            double x = (double) vh.get();\n+            assertEquals(x, 2.0d, \"failing weakCompareAndSetRelease double value\");\n@@ -815,1 +864,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet double\");\n+            assertEquals(success, true, \"success weakCompareAndSet double\");\n+            double x = (double) vh.get();\n+            assertEquals(x, 1.0d, \"success weakCompareAndSet double\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(2.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSet double\");\n@@ -817,1 +873,1 @@\n-            assertEquals(x, 1.0d, \"weakCompareAndSet double\");\n+            assertEquals(x, 1.0d, \"failing weakCompareAndSet double value\");\n@@ -1016,1 +1072,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain double\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain double\");\n+                double x = (double) vh.get(array, i);\n+                assertEquals(x, 2.0d, \"success weakCompareAndSetPlain double value\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetPlain(array, i, 1.0d, 3.0d);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain double\");\n@@ -1018,1 +1081,1 @@\n-                assertEquals(x, 2.0d, \"weakCompareAndSetPlain double value\");\n+                assertEquals(x, 2.0d, \"failing weakCompareAndSetPlain double value\");\n@@ -1026,1 +1089,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire double\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire double\");\n@@ -1028,1 +1091,8 @@\n-                assertEquals(x, 1.0d, \"weakCompareAndSetAcquire double\");\n+                assertEquals(x, 1.0d, \"success weakCompareAndSetAcquire double\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetAcquire(array, i, 2.0d, 3.0d);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire double\");\n+                double x = (double) vh.get(array, i);\n+                assertEquals(x, 1.0d, \"failing weakCompareAndSetAcquire double value\");\n@@ -1036,1 +1106,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease double\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease double\");\n+                double x = (double) vh.get(array, i);\n+                assertEquals(x, 2.0d, \"success weakCompareAndSetRelease double\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetRelease(array, i, 1.0d, 3.0d);\n+                assertEquals(success, false, \"failing weakCompareAndSetRelease double\");\n@@ -1038,1 +1115,1 @@\n-                assertEquals(x, 2.0d, \"weakCompareAndSetRelease double\");\n+                assertEquals(x, 2.0d, \"failing weakCompareAndSetRelease double value\");\n@@ -1046,1 +1123,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet double\");\n+                assertEquals(success, true, \"success weakCompareAndSet double\");\n+                double x = (double) vh.get(array, i);\n+                assertEquals(x, 1.0d, \"success weakCompareAndSet double\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSet(array, i, 2.0d, 3.0d);\n+                assertEquals(success, false, \"failing weakCompareAndSet double\");\n@@ -1048,1 +1132,1 @@\n-                assertEquals(x, 1.0d, \"weakCompareAndSet double\");\n+                assertEquals(x, 1.0d, \"failing weakCompareAndSet double value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessDouble.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -557,1 +557,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain float\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain float\");\n@@ -559,1 +559,8 @@\n-            assertEquals(x, 2.0f, \"weakCompareAndSetPlain float value\");\n+            assertEquals(x, 2.0f, \"success weakCompareAndSetPlain float value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(recv, 1.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain float\");\n+            float x = (float) vh.get(recv);\n+            assertEquals(x, 2.0f, \"failing weakCompareAndSetPlain float value\");\n@@ -567,1 +574,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire float\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire float\");\n+            float x = (float) vh.get(recv);\n+            assertEquals(x, 1.0f, \"success weakCompareAndSetAcquire float\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(recv, 2.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire float\");\n@@ -569,1 +583,1 @@\n-            assertEquals(x, 1.0f, \"weakCompareAndSetAcquire float\");\n+            assertEquals(x, 1.0f, \"failing weakCompareAndSetAcquire float value\");\n@@ -577,1 +591,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease float\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease float\");\n+            float x = (float) vh.get(recv);\n+            assertEquals(x, 2.0f, \"success weakCompareAndSetRelease float\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(recv, 1.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease float\");\n@@ -579,1 +600,1 @@\n-            assertEquals(x, 2.0f, \"weakCompareAndSetRelease float\");\n+            assertEquals(x, 2.0f, \"failing weakCompareAndSetRelease float value\");\n@@ -587,1 +608,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet float\");\n+            assertEquals(success, true, \"success weakCompareAndSet float\");\n@@ -589,1 +610,8 @@\n-            assertEquals(x, 1.0f, \"weakCompareAndSet float value\");\n+            assertEquals(x, 1.0f, \"success weakCompareAndSet float value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(recv, 2.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSet float\");\n+            float x = (float) vh.get(recv);\n+            assertEquals(x, 1.0f, \"failing weakCompareAndSet float value\");\n@@ -785,1 +813,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain float\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain float\");\n+            float x = (float) vh.get();\n+            assertEquals(x, 2.0f, \"success weakCompareAndSetPlain float value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(1.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain float\");\n@@ -787,1 +822,1 @@\n-            assertEquals(x, 2.0f, \"weakCompareAndSetPlain float value\");\n+            assertEquals(x, 2.0f, \"failing weakCompareAndSetPlain float value\");\n@@ -795,1 +830,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire float\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire float\");\n+            float x = (float) vh.get();\n+            assertEquals(x, 1.0f, \"success weakCompareAndSetAcquire float\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(2.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire float\");\n@@ -797,1 +839,1 @@\n-            assertEquals(x, 1.0f, \"weakCompareAndSetAcquire float\");\n+            assertEquals(x, 1.0f, \"failing weakCompareAndSetAcquire float value\");\n@@ -805,1 +847,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease float\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease float\");\n@@ -807,1 +849,8 @@\n-            assertEquals(x, 2.0f, \"weakCompareAndSetRelease float\");\n+            assertEquals(x, 2.0f, \"success weakCompareAndSetRelease float\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(1.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease float\");\n+            float x = (float) vh.get();\n+            assertEquals(x, 2.0f, \"failing weakCompareAndSetRelease float value\");\n@@ -815,1 +864,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet float\");\n+            assertEquals(success, true, \"success weakCompareAndSet float\");\n+            float x = (float) vh.get();\n+            assertEquals(x, 1.0f, \"success weakCompareAndSet float\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(2.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSet float\");\n@@ -817,1 +873,1 @@\n-            assertEquals(x, 1.0f, \"weakCompareAndSet float\");\n+            assertEquals(x, 1.0f, \"failing weakCompareAndSet float value\");\n@@ -1016,1 +1072,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain float\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain float\");\n+                float x = (float) vh.get(array, i);\n+                assertEquals(x, 2.0f, \"success weakCompareAndSetPlain float value\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetPlain(array, i, 1.0f, 3.0f);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain float\");\n@@ -1018,1 +1081,1 @@\n-                assertEquals(x, 2.0f, \"weakCompareAndSetPlain float value\");\n+                assertEquals(x, 2.0f, \"failing weakCompareAndSetPlain float value\");\n@@ -1026,1 +1089,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire float\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire float\");\n@@ -1028,1 +1091,8 @@\n-                assertEquals(x, 1.0f, \"weakCompareAndSetAcquire float\");\n+                assertEquals(x, 1.0f, \"success weakCompareAndSetAcquire float\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetAcquire(array, i, 2.0f, 3.0f);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire float\");\n+                float x = (float) vh.get(array, i);\n+                assertEquals(x, 1.0f, \"failing weakCompareAndSetAcquire float value\");\n@@ -1036,1 +1106,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease float\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease float\");\n+                float x = (float) vh.get(array, i);\n+                assertEquals(x, 2.0f, \"success weakCompareAndSetRelease float\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetRelease(array, i, 1.0f, 3.0f);\n+                assertEquals(success, false, \"failing weakCompareAndSetRelease float\");\n@@ -1038,1 +1115,1 @@\n-                assertEquals(x, 2.0f, \"weakCompareAndSetRelease float\");\n+                assertEquals(x, 2.0f, \"failing weakCompareAndSetRelease float value\");\n@@ -1046,1 +1123,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet float\");\n+                assertEquals(success, true, \"success weakCompareAndSet float\");\n+                float x = (float) vh.get(array, i);\n+                assertEquals(x, 1.0f, \"success weakCompareAndSet float\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSet(array, i, 2.0f, 3.0f);\n+                assertEquals(success, false, \"failing weakCompareAndSet float\");\n@@ -1048,1 +1132,1 @@\n-                assertEquals(x, 1.0f, \"weakCompareAndSet float\");\n+                assertEquals(x, 1.0f, \"failing weakCompareAndSet float value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessFloat.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -487,1 +487,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain int\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain int\");\n@@ -489,1 +489,8 @@\n-            assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetPlain int value\");\n+            assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetPlain int value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(recv, 0x01234567, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain int\");\n+            int x = (int) vh.get(recv);\n+            assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetPlain int value\");\n@@ -497,1 +504,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire int\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire int\");\n+            int x = (int) vh.get(recv);\n+            assertEquals(x, 0x01234567, \"success weakCompareAndSetAcquire int\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(recv, 0x89ABCDEF, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire int\");\n@@ -499,1 +513,1 @@\n-            assertEquals(x, 0x01234567, \"weakCompareAndSetAcquire int\");\n+            assertEquals(x, 0x01234567, \"failing weakCompareAndSetAcquire int value\");\n@@ -507,1 +521,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease int\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease int\");\n+            int x = (int) vh.get(recv);\n+            assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetRelease int\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(recv, 0x01234567, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease int\");\n@@ -509,1 +530,1 @@\n-            assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetRelease int\");\n+            assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetRelease int value\");\n@@ -517,1 +538,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet int\");\n+            assertEquals(success, true, \"success weakCompareAndSet int\");\n@@ -519,1 +540,8 @@\n-            assertEquals(x, 0x01234567, \"weakCompareAndSet int value\");\n+            assertEquals(x, 0x01234567, \"success weakCompareAndSet int value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(recv, 0x89ABCDEF, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSet int\");\n+            int x = (int) vh.get(recv);\n+            assertEquals(x, 0x01234567, \"failing weakCompareAndSet int value\");\n@@ -763,1 +791,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain int\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain int\");\n+            int x = (int) vh.get();\n+            assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetPlain int value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(0x01234567, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain int\");\n@@ -765,1 +800,1 @@\n-            assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetPlain int value\");\n+            assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetPlain int value\");\n@@ -773,1 +808,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire int\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire int\");\n+            int x = (int) vh.get();\n+            assertEquals(x, 0x01234567, \"success weakCompareAndSetAcquire int\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(0x89ABCDEF, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire int\");\n@@ -775,1 +817,1 @@\n-            assertEquals(x, 0x01234567, \"weakCompareAndSetAcquire int\");\n+            assertEquals(x, 0x01234567, \"failing weakCompareAndSetAcquire int value\");\n@@ -783,1 +825,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease int\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease int\");\n@@ -785,1 +827,8 @@\n-            assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetRelease int\");\n+            assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetRelease int\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(0x01234567, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease int\");\n+            int x = (int) vh.get();\n+            assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetRelease int value\");\n@@ -793,1 +842,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet int\");\n+            assertEquals(success, true, \"success weakCompareAndSet int\");\n+            int x = (int) vh.get();\n+            assertEquals(x, 0x01234567, \"success weakCompareAndSet int\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(0x89ABCDEF, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSet int\");\n@@ -795,1 +851,1 @@\n-            assertEquals(x, 0x01234567, \"weakCompareAndSet int\");\n+            assertEquals(x, 0x01234567, \"failing weakCompareAndSet int value\");\n@@ -1042,1 +1098,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain int\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain int\");\n+                int x = (int) vh.get(array, i);\n+                assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetPlain int value\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetPlain(array, i, 0x01234567, 0xCAFEBABE);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain int\");\n@@ -1044,1 +1107,1 @@\n-                assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetPlain int value\");\n+                assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetPlain int value\");\n@@ -1052,1 +1115,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire int\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire int\");\n@@ -1054,1 +1117,8 @@\n-                assertEquals(x, 0x01234567, \"weakCompareAndSetAcquire int\");\n+                assertEquals(x, 0x01234567, \"success weakCompareAndSetAcquire int\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetAcquire(array, i, 0x89ABCDEF, 0xCAFEBABE);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire int\");\n+                int x = (int) vh.get(array, i);\n+                assertEquals(x, 0x01234567, \"failing weakCompareAndSetAcquire int value\");\n@@ -1062,1 +1132,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease int\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease int\");\n+                int x = (int) vh.get(array, i);\n+                assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetRelease int\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetRelease(array, i, 0x01234567, 0xCAFEBABE);\n+                assertEquals(success, false, \"failing weakCompareAndSetRelease int\");\n@@ -1064,1 +1141,1 @@\n-                assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetRelease int\");\n+                assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetRelease int value\");\n@@ -1072,1 +1149,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet int\");\n+                assertEquals(success, true, \"success weakCompareAndSet int\");\n+                int x = (int) vh.get(array, i);\n+                assertEquals(x, 0x01234567, \"success weakCompareAndSet int\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSet(array, i, 0x89ABCDEF, 0xCAFEBABE);\n+                assertEquals(success, false, \"failing weakCompareAndSet int\");\n@@ -1074,1 +1158,1 @@\n-                assertEquals(x, 0x01234567, \"weakCompareAndSet int\");\n+                assertEquals(x, 0x01234567, \"failing weakCompareAndSet int value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessInt.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -487,1 +487,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain long\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain long\");\n@@ -489,1 +489,8 @@\n-            assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetPlain long value\");\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetPlain long value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(recv, 0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain long\");\n+            long x = (long) vh.get(recv);\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetPlain long value\");\n@@ -497,1 +504,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire long\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire long\");\n+            long x = (long) vh.get(recv);\n+            assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSetAcquire long\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(recv, 0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire long\");\n@@ -499,1 +513,1 @@\n-            assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSetAcquire long\");\n+            assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSetAcquire long value\");\n@@ -507,1 +521,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease long\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease long\");\n+            long x = (long) vh.get(recv);\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetRelease long\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(recv, 0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease long\");\n@@ -509,1 +530,1 @@\n-            assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetRelease long\");\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetRelease long value\");\n@@ -517,1 +538,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet long\");\n+            assertEquals(success, true, \"success weakCompareAndSet long\");\n@@ -519,1 +540,8 @@\n-            assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSet long value\");\n+            assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSet long value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(recv, 0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSet long\");\n+            long x = (long) vh.get(recv);\n+            assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSet long value\");\n@@ -763,1 +791,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain long\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain long\");\n+            long x = (long) vh.get();\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetPlain long value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain long\");\n@@ -765,1 +800,1 @@\n-            assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetPlain long value\");\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetPlain long value\");\n@@ -773,1 +808,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire long\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire long\");\n+            long x = (long) vh.get();\n+            assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSetAcquire long\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire long\");\n@@ -775,1 +817,1 @@\n-            assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSetAcquire long\");\n+            assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSetAcquire long value\");\n@@ -783,1 +825,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease long\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease long\");\n@@ -785,1 +827,8 @@\n-            assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetRelease long\");\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetRelease long\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease long\");\n+            long x = (long) vh.get();\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetRelease long value\");\n@@ -793,1 +842,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet long\");\n+            assertEquals(success, true, \"success weakCompareAndSet long\");\n+            long x = (long) vh.get();\n+            assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSet long\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSet long\");\n@@ -795,1 +851,1 @@\n-            assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSet long\");\n+            assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSet long value\");\n@@ -1042,1 +1098,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain long\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain long\");\n+                long x = (long) vh.get(array, i);\n+                assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetPlain long value\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetPlain(array, i, 0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain long\");\n@@ -1044,1 +1107,1 @@\n-                assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetPlain long value\");\n+                assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetPlain long value\");\n@@ -1052,1 +1115,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire long\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire long\");\n@@ -1054,1 +1117,8 @@\n-                assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSetAcquire long\");\n+                assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSetAcquire long\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetAcquire(array, i, 0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire long\");\n+                long x = (long) vh.get(array, i);\n+                assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSetAcquire long value\");\n@@ -1062,1 +1132,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease long\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease long\");\n+                long x = (long) vh.get(array, i);\n+                assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetRelease long\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetRelease(array, i, 0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+                assertEquals(success, false, \"failing weakCompareAndSetRelease long\");\n@@ -1064,1 +1141,1 @@\n-                assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetRelease long\");\n+                assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetRelease long value\");\n@@ -1072,1 +1149,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet long\");\n+                assertEquals(success, true, \"success weakCompareAndSet long\");\n+                long x = (long) vh.get(array, i);\n+                assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSet long\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSet(array, i, 0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+                assertEquals(success, false, \"failing weakCompareAndSet long\");\n@@ -1074,1 +1158,1 @@\n-                assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSet long\");\n+                assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSet long value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessLong.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -487,1 +487,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain short\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain short\");\n@@ -489,1 +489,8 @@\n-            assertEquals(x, (short)0x4567, \"weakCompareAndSetPlain short value\");\n+            assertEquals(x, (short)0x4567, \"success weakCompareAndSetPlain short value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(recv, (short)0x0123, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain short\");\n+            short x = (short) vh.get(recv);\n+            assertEquals(x, (short)0x4567, \"failing weakCompareAndSetPlain short value\");\n@@ -497,1 +504,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire short\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire short\");\n+            short x = (short) vh.get(recv);\n+            assertEquals(x, (short)0x0123, \"success weakCompareAndSetAcquire short\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(recv, (short)0x4567, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire short\");\n@@ -499,1 +513,1 @@\n-            assertEquals(x, (short)0x0123, \"weakCompareAndSetAcquire short\");\n+            assertEquals(x, (short)0x0123, \"failing weakCompareAndSetAcquire short value\");\n@@ -507,1 +521,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease short\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease short\");\n+            short x = (short) vh.get(recv);\n+            assertEquals(x, (short)0x4567, \"success weakCompareAndSetRelease short\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(recv, (short)0x0123, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease short\");\n@@ -509,1 +530,1 @@\n-            assertEquals(x, (short)0x4567, \"weakCompareAndSetRelease short\");\n+            assertEquals(x, (short)0x4567, \"failing weakCompareAndSetRelease short value\");\n@@ -517,1 +538,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet short\");\n+            assertEquals(success, true, \"success weakCompareAndSet short\");\n@@ -519,1 +540,8 @@\n-            assertEquals(x, (short)0x0123, \"weakCompareAndSet short value\");\n+            assertEquals(x, (short)0x0123, \"success weakCompareAndSet short value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(recv, (short)0x4567, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSet short\");\n+            short x = (short) vh.get(recv);\n+            assertEquals(x, (short)0x0123, \"failing weakCompareAndSet short value\");\n@@ -763,1 +791,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain short\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain short\");\n+            short x = (short) vh.get();\n+            assertEquals(x, (short)0x4567, \"success weakCompareAndSetPlain short value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain((short)0x0123, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain short\");\n@@ -765,1 +800,1 @@\n-            assertEquals(x, (short)0x4567, \"weakCompareAndSetPlain short value\");\n+            assertEquals(x, (short)0x4567, \"failing weakCompareAndSetPlain short value\");\n@@ -773,1 +808,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire short\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire short\");\n+            short x = (short) vh.get();\n+            assertEquals(x, (short)0x0123, \"success weakCompareAndSetAcquire short\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire((short)0x4567, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire short\");\n@@ -775,1 +817,1 @@\n-            assertEquals(x, (short)0x0123, \"weakCompareAndSetAcquire short\");\n+            assertEquals(x, (short)0x0123, \"failing weakCompareAndSetAcquire short value\");\n@@ -783,1 +825,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease short\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease short\");\n@@ -785,1 +827,8 @@\n-            assertEquals(x, (short)0x4567, \"weakCompareAndSetRelease short\");\n+            assertEquals(x, (short)0x4567, \"success weakCompareAndSetRelease short\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease((short)0x0123, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease short\");\n+            short x = (short) vh.get();\n+            assertEquals(x, (short)0x4567, \"failing weakCompareAndSetRelease short value\");\n@@ -793,1 +842,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet short\");\n+            assertEquals(success, true, \"success weakCompareAndSet short\");\n+            short x = (short) vh.get();\n+            assertEquals(x, (short)0x0123, \"success weakCompareAndSet short\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet((short)0x4567, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSet short\");\n@@ -795,1 +851,1 @@\n-            assertEquals(x, (short)0x0123, \"weakCompareAndSet short\");\n+            assertEquals(x, (short)0x0123, \"failing weakCompareAndSet short value\");\n@@ -1042,1 +1098,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain short\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain short\");\n+                short x = (short) vh.get(array, i);\n+                assertEquals(x, (short)0x4567, \"success weakCompareAndSetPlain short value\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetPlain(array, i, (short)0x0123, (short)0x89AB);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain short\");\n@@ -1044,1 +1107,1 @@\n-                assertEquals(x, (short)0x4567, \"weakCompareAndSetPlain short value\");\n+                assertEquals(x, (short)0x4567, \"failing weakCompareAndSetPlain short value\");\n@@ -1052,1 +1115,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire short\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire short\");\n@@ -1054,1 +1117,8 @@\n-                assertEquals(x, (short)0x0123, \"weakCompareAndSetAcquire short\");\n+                assertEquals(x, (short)0x0123, \"success weakCompareAndSetAcquire short\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetAcquire(array, i, (short)0x4567, (short)0x89AB);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire short\");\n+                short x = (short) vh.get(array, i);\n+                assertEquals(x, (short)0x0123, \"failing weakCompareAndSetAcquire short value\");\n@@ -1062,1 +1132,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease short\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease short\");\n+                short x = (short) vh.get(array, i);\n+                assertEquals(x, (short)0x4567, \"success weakCompareAndSetRelease short\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetRelease(array, i, (short)0x0123, (short)0x89AB);\n+                assertEquals(success, false, \"failing weakCompareAndSetRelease short\");\n@@ -1064,1 +1141,1 @@\n-                assertEquals(x, (short)0x4567, \"weakCompareAndSetRelease short\");\n+                assertEquals(x, (short)0x4567, \"failing weakCompareAndSetRelease short value\");\n@@ -1072,1 +1149,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet short\");\n+                assertEquals(success, true, \"success weakCompareAndSet short\");\n+                short x = (short) vh.get(array, i);\n+                assertEquals(x, (short)0x0123, \"success weakCompareAndSet short\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSet(array, i, (short)0x4567, (short)0x89AB);\n+                assertEquals(success, false, \"failing weakCompareAndSet short\");\n@@ -1074,1 +1158,1 @@\n-                assertEquals(x, (short)0x0123, \"weakCompareAndSet short\");\n+                assertEquals(x, (short)0x0123, \"failing weakCompareAndSet short value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessShort.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -586,1 +586,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain String\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain String\");\n@@ -588,1 +588,8 @@\n-            assertEquals(x, \"bar\", \"weakCompareAndSetPlain String value\");\n+            assertEquals(x, \"bar\", \"success weakCompareAndSetPlain String value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(recv, \"foo\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain String\");\n+            String x = (String) vh.get(recv);\n+            assertEquals(x, \"bar\", \"failing weakCompareAndSetPlain String value\");\n@@ -596,1 +603,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire String\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire String\");\n+            String x = (String) vh.get(recv);\n+            assertEquals(x, \"foo\", \"success weakCompareAndSetAcquire String\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(recv, \"bar\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire String\");\n@@ -598,1 +612,1 @@\n-            assertEquals(x, \"foo\", \"weakCompareAndSetAcquire String\");\n+            assertEquals(x, \"foo\", \"failing weakCompareAndSetAcquire String value\");\n@@ -606,1 +620,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease String\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease String\");\n+            String x = (String) vh.get(recv);\n+            assertEquals(x, \"bar\", \"success weakCompareAndSetRelease String\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(recv, \"foo\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease String\");\n@@ -608,1 +629,1 @@\n-            assertEquals(x, \"bar\", \"weakCompareAndSetRelease String\");\n+            assertEquals(x, \"bar\", \"failing weakCompareAndSetRelease String value\");\n@@ -616,1 +637,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet String\");\n+            assertEquals(success, true, \"success weakCompareAndSet String\");\n@@ -618,1 +639,8 @@\n-            assertEquals(x, \"foo\", \"weakCompareAndSet String value\");\n+            assertEquals(x, \"foo\", \"success weakCompareAndSet String value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(recv, \"bar\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSet String\");\n+            String x = (String) vh.get(recv);\n+            assertEquals(x, \"foo\", \"failing weakCompareAndSet String value\");\n@@ -798,1 +826,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain String\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain String\");\n+            String x = (String) vh.get();\n+            assertEquals(x, \"bar\", \"success weakCompareAndSetPlain String value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(\"foo\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain String\");\n@@ -800,1 +835,1 @@\n-            assertEquals(x, \"bar\", \"weakCompareAndSetPlain String value\");\n+            assertEquals(x, \"bar\", \"failing weakCompareAndSetPlain String value\");\n@@ -808,1 +843,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire String\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire String\");\n+            String x = (String) vh.get();\n+            assertEquals(x, \"foo\", \"success weakCompareAndSetAcquire String\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(\"bar\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire String\");\n@@ -810,1 +852,1 @@\n-            assertEquals(x, \"foo\", \"weakCompareAndSetAcquire String\");\n+            assertEquals(x, \"foo\", \"failing weakCompareAndSetAcquire String value\");\n@@ -818,1 +860,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease String\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease String\");\n@@ -820,1 +862,8 @@\n-            assertEquals(x, \"bar\", \"weakCompareAndSetRelease String\");\n+            assertEquals(x, \"bar\", \"success weakCompareAndSetRelease String\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(\"foo\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease String\");\n+            String x = (String) vh.get();\n+            assertEquals(x, \"bar\", \"failing weakCompareAndSetRelease String value\");\n@@ -828,1 +877,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet String\");\n+            assertEquals(success, true, \"success weakCompareAndSet String\");\n+            String x = (String) vh.get();\n+            assertEquals(x, \"foo\", \"success weakCompareAndSet String\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(\"bar\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSet String\");\n@@ -830,1 +886,1 @@\n-            assertEquals(x, \"foo\", \"weakCompareAndSet String\");\n+            assertEquals(x, \"foo\", \"failing weakCompareAndSet String value\");\n@@ -1013,1 +1069,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain String\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain String\");\n+                String x = (String) vh.get(array, i);\n+                assertEquals(x, \"bar\", \"success weakCompareAndSetPlain String value\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetPlain(array, i, \"foo\", \"baz\");\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain String\");\n@@ -1015,1 +1078,1 @@\n-                assertEquals(x, \"bar\", \"weakCompareAndSetPlain String value\");\n+                assertEquals(x, \"bar\", \"failing weakCompareAndSetPlain String value\");\n@@ -1023,1 +1086,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire String\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire String\");\n@@ -1025,1 +1088,8 @@\n-                assertEquals(x, \"foo\", \"weakCompareAndSetAcquire String\");\n+                assertEquals(x, \"foo\", \"success weakCompareAndSetAcquire String\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetAcquire(array, i, \"bar\", \"baz\");\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire String\");\n+                String x = (String) vh.get(array, i);\n+                assertEquals(x, \"foo\", \"failing weakCompareAndSetAcquire String value\");\n@@ -1033,1 +1103,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease String\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease String\");\n+                String x = (String) vh.get(array, i);\n+                assertEquals(x, \"bar\", \"success weakCompareAndSetRelease String\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetRelease(array, i, \"foo\", \"baz\");\n+                assertEquals(success, false, \"failing weakCompareAndSetRelease String\");\n@@ -1035,1 +1112,1 @@\n-                assertEquals(x, \"bar\", \"weakCompareAndSetRelease String\");\n+                assertEquals(x, \"bar\", \"failing weakCompareAndSetRelease String value\");\n@@ -1043,1 +1120,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet String\");\n+                assertEquals(success, true, \"success weakCompareAndSet String\");\n+                String x = (String) vh.get(array, i);\n+                assertEquals(x, \"foo\", \"success weakCompareAndSet String\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSet(array, i, \"bar\", \"baz\");\n+                assertEquals(success, false, \"failing weakCompareAndSet String\");\n@@ -1045,1 +1129,1 @@\n-                assertEquals(x, \"foo\", \"weakCompareAndSet String\");\n+                assertEquals(x, \"foo\", \"failing weakCompareAndSet String value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessString.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestByteArrayAsChar.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1085,1 +1085,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetPlain double\");\n+                    assertEquals(success, true, \"success weakCompareAndSetPlain double\");\n@@ -1087,1 +1087,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetPlain double value\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetPlain double value\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetPlain double\");\n+                    double x = (double) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetPlain double value\");\n@@ -1095,1 +1102,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSetAcquire double\");\n+                    assertEquals(success, true, \"success weakCompareAndSetAcquire double\");\n+                    double x = (double) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSetAcquire double\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetAcquire double\");\n@@ -1097,1 +1111,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSetAcquire double\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSetAcquire double value\");\n@@ -1105,1 +1119,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetRelease double\");\n+                    assertEquals(success, true, \"success weakCompareAndSetRelease double\");\n@@ -1107,1 +1121,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetRelease double\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetRelease double\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetRelease double\");\n+                    double x = (double) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetRelease double value\");\n@@ -1115,1 +1136,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSet double\");\n+                    assertEquals(success, true, \"success weakCompareAndSet double\");\n+                    double x = (double) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSet double\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSet double\");\n@@ -1117,1 +1145,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSet double\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSet double value\");\n@@ -1258,1 +1286,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetPlain double\");\n+                    assertEquals(success, true, \"success weakCompareAndSetPlain double\");\n@@ -1260,1 +1288,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetPlain double value\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetPlain double value\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetPlain double\");\n+                    double x = (double) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetPlain double value\");\n@@ -1268,1 +1303,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSetAcquire double\");\n+                    assertEquals(success, true, \"success weakCompareAndSetAcquire double\");\n+                    double x = (double) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSetAcquire double\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetAcquire double\");\n@@ -1270,1 +1312,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSetAcquire double\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSetAcquire double value\");\n@@ -1278,1 +1320,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetRelease double\");\n+                    assertEquals(success, true, \"success weakCompareAndSetRelease double\");\n@@ -1280,1 +1322,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetRelease double\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetRelease double\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetRelease double\");\n+                    double x = (double) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetRelease double value\");\n@@ -1288,1 +1337,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSet double\");\n+                    assertEquals(success, true, \"success weakCompareAndSet double\");\n+                    double x = (double) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSet double\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSet double\");\n@@ -1290,1 +1346,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSet double\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSet double value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestByteArrayAsDouble.java","additions":73,"deletions":17,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1085,1 +1085,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetPlain float\");\n+                    assertEquals(success, true, \"success weakCompareAndSetPlain float\");\n@@ -1087,1 +1087,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetPlain float value\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetPlain float value\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetPlain float\");\n+                    float x = (float) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetPlain float value\");\n@@ -1095,1 +1102,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSetAcquire float\");\n+                    assertEquals(success, true, \"success weakCompareAndSetAcquire float\");\n+                    float x = (float) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSetAcquire float\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetAcquire float\");\n@@ -1097,1 +1111,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSetAcquire float\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSetAcquire float value\");\n@@ -1105,1 +1119,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetRelease float\");\n+                    assertEquals(success, true, \"success weakCompareAndSetRelease float\");\n@@ -1107,1 +1121,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetRelease float\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetRelease float\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetRelease float\");\n+                    float x = (float) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetRelease float value\");\n@@ -1115,1 +1136,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSet float\");\n+                    assertEquals(success, true, \"success weakCompareAndSet float\");\n+                    float x = (float) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSet float\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSet float\");\n@@ -1117,1 +1145,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSet float\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSet float value\");\n@@ -1258,1 +1286,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetPlain float\");\n+                    assertEquals(success, true, \"success weakCompareAndSetPlain float\");\n@@ -1260,1 +1288,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetPlain float value\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetPlain float value\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetPlain float\");\n+                    float x = (float) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetPlain float value\");\n@@ -1268,1 +1303,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSetAcquire float\");\n+                    assertEquals(success, true, \"success weakCompareAndSetAcquire float\");\n+                    float x = (float) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSetAcquire float\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetAcquire float\");\n@@ -1270,1 +1312,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSetAcquire float\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSetAcquire float value\");\n@@ -1278,1 +1320,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetRelease float\");\n+                    assertEquals(success, true, \"success weakCompareAndSetRelease float\");\n@@ -1280,1 +1322,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetRelease float\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetRelease float\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetRelease float\");\n+                    float x = (float) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetRelease float value\");\n@@ -1288,1 +1337,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSet float\");\n+                    assertEquals(success, true, \"success weakCompareAndSet float\");\n+                    float x = (float) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSet float\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSet float\");\n@@ -1290,1 +1346,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSet float\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSet float value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestByteArrayAsFloat.java","additions":73,"deletions":17,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1269,1 +1269,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetPlain int\");\n+                    assertEquals(success, true, \"success weakCompareAndSetPlain int\");\n@@ -1271,1 +1271,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetPlain int value\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetPlain int value\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetPlain int\");\n+                    int x = (int) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetPlain int value\");\n@@ -1279,1 +1286,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSetAcquire int\");\n+                    assertEquals(success, true, \"success weakCompareAndSetAcquire int\");\n+                    int x = (int) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSetAcquire int\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetAcquire int\");\n@@ -1281,1 +1295,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSetAcquire int\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSetAcquire int value\");\n@@ -1289,1 +1303,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetRelease int\");\n+                    assertEquals(success, true, \"success weakCompareAndSetRelease int\");\n@@ -1291,1 +1305,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetRelease int\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetRelease int\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetRelease int\");\n+                    int x = (int) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetRelease int value\");\n@@ -1299,1 +1320,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSet int\");\n+                    assertEquals(success, true, \"success weakCompareAndSet int\");\n+                    int x = (int) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSet int\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSet int\");\n@@ -1301,1 +1329,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSet int\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSet int value\");\n@@ -1552,1 +1580,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetPlain int\");\n+                    assertEquals(success, true, \"success weakCompareAndSetPlain int\");\n@@ -1554,1 +1582,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetPlain int value\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetPlain int value\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetPlain int\");\n+                    int x = (int) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetPlain int value\");\n@@ -1562,1 +1597,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSetAcquire int\");\n+                    assertEquals(success, true, \"success weakCompareAndSetAcquire int\");\n+                    int x = (int) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSetAcquire int\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetAcquire int\");\n@@ -1564,1 +1606,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSetAcquire int\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSetAcquire int value\");\n@@ -1572,1 +1614,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetRelease int\");\n+                    assertEquals(success, true, \"success weakCompareAndSetRelease int\");\n@@ -1574,1 +1616,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetRelease int\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetRelease int\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetRelease int\");\n+                    int x = (int) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetRelease int value\");\n@@ -1582,1 +1631,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSet int\");\n+                    assertEquals(success, true, \"success weakCompareAndSet int\");\n+                    int x = (int) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSet int\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSet int\");\n@@ -1584,1 +1640,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSet int\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSet int value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestByteArrayAsInt.java","additions":73,"deletions":17,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1269,1 +1269,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetPlain long\");\n+                    assertEquals(success, true, \"success weakCompareAndSetPlain long\");\n@@ -1271,1 +1271,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetPlain long value\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetPlain long value\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetPlain long\");\n+                    long x = (long) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetPlain long value\");\n@@ -1279,1 +1286,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSetAcquire long\");\n+                    assertEquals(success, true, \"success weakCompareAndSetAcquire long\");\n+                    long x = (long) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSetAcquire long\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetAcquire long\");\n@@ -1281,1 +1295,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSetAcquire long\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSetAcquire long value\");\n@@ -1289,1 +1303,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetRelease long\");\n+                    assertEquals(success, true, \"success weakCompareAndSetRelease long\");\n@@ -1291,1 +1305,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetRelease long\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetRelease long\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetRelease long\");\n+                    long x = (long) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetRelease long value\");\n@@ -1299,1 +1320,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSet long\");\n+                    assertEquals(success, true, \"success weakCompareAndSet long\");\n+                    long x = (long) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSet long\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSet long\");\n@@ -1301,1 +1329,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSet long\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSet long value\");\n@@ -1552,1 +1580,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetPlain long\");\n+                    assertEquals(success, true, \"success weakCompareAndSetPlain long\");\n@@ -1554,1 +1582,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetPlain long value\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetPlain long value\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetPlain long\");\n+                    long x = (long) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetPlain long value\");\n@@ -1562,1 +1597,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSetAcquire long\");\n+                    assertEquals(success, true, \"success weakCompareAndSetAcquire long\");\n+                    long x = (long) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSetAcquire long\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetAcquire long\");\n@@ -1564,1 +1606,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSetAcquire long\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSetAcquire long value\");\n@@ -1572,1 +1614,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetRelease long\");\n+                    assertEquals(success, true, \"success weakCompareAndSetRelease long\");\n@@ -1574,1 +1616,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetRelease long\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetRelease long\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetRelease long\");\n+                    long x = (long) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetRelease long value\");\n@@ -1582,1 +1631,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSet long\");\n+                    assertEquals(success, true, \"success weakCompareAndSet long\");\n+                    long x = (long) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSet long\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSet long\");\n@@ -1584,1 +1640,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSet long\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSet long value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestByteArrayAsLong.java","additions":73,"deletions":17,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestByteArrayAsShort.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,1 +215,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain boolean\");\n@@ -217,1 +217,8 @@\n-            assertEquals(x, false, \"weakCompareAndSetPlain boolean value\");\n+            assertEquals(x, false, \"success weakCompareAndSetPlain boolean value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, true, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain boolean\");\n+            boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, false, \"failing weakCompareAndSetPlain boolean value\");\n@@ -225,1 +232,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire boolean\");\n+            boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, true, \"success weakCompareAndSetAcquire boolean\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, false, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire boolean\");\n@@ -227,1 +241,1 @@\n-            assertEquals(x, true, \"weakCompareAndSetAcquire boolean\");\n+            assertEquals(x, true, \"failing weakCompareAndSetAcquire boolean value\");\n@@ -235,1 +249,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease boolean\");\n+            boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, false, \"success weakCompareAndSetRelease boolean\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, true, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease boolean\");\n@@ -237,1 +258,1 @@\n-            assertEquals(x, false, \"weakCompareAndSetRelease boolean\");\n+            assertEquals(x, false, \"failing weakCompareAndSetRelease boolean value\");\n@@ -245,1 +266,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSet boolean\");\n@@ -247,1 +268,8 @@\n-            assertEquals(x, true, \"weakCompareAndSet boolean\");\n+            assertEquals(x, true, \"success weakCompareAndSet boolean\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, false, false);\n+            assertEquals(success, false, \"failing weakCompareAndSet boolean\");\n+            boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, true, \"failing weakCompareAndSet boolean value\");\n@@ -449,1 +477,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain boolean\");\n+            boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, false, \"success weakCompareAndSetPlain boolean value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(true, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain boolean\");\n@@ -451,1 +486,1 @@\n-            assertEquals(x, false, \"weakCompareAndSetPlain boolean value\");\n+            assertEquals(x, false, \"failing weakCompareAndSetPlain boolean value\");\n@@ -459,1 +494,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire boolean\");\n+            boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, true, \"success weakCompareAndSetAcquire boolean\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(false, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire boolean\");\n@@ -461,1 +503,1 @@\n-            assertEquals(x, true, \"weakCompareAndSetAcquire boolean\");\n+            assertEquals(x, true, \"failing weakCompareAndSetAcquire boolean value\");\n@@ -469,1 +511,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease boolean\");\n@@ -471,1 +513,8 @@\n-            assertEquals(x, false, \"weakCompareAndSetRelease boolean\");\n+            assertEquals(x, false, \"success weakCompareAndSetRelease boolean\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(true, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease boolean\");\n+            boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, false, \"failing weakCompareAndSetRelease boolean value\");\n@@ -479,1 +528,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSet boolean\");\n+            boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, true, \"success weakCompareAndSet boolean\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(false, false);\n+            assertEquals(success, false, \"failing weakCompareAndSet boolean\");\n@@ -481,1 +537,1 @@\n-            assertEquals(x, true, \"weakCompareAndSet boolean\");\n+            assertEquals(x, true, \"failing weakCompareAndSetRe boolean value\");\n@@ -708,1 +764,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain boolean\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain boolean\");\n+                boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, false, \"success weakCompareAndSetPlain boolean value\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, true, false);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain boolean\");\n@@ -710,1 +773,1 @@\n-                assertEquals(x, false, \"weakCompareAndSetPlain boolean value\");\n+                assertEquals(x, false, \"failing weakCompareAndSetPlain boolean value\");\n@@ -718,1 +781,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire boolean\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire boolean\");\n@@ -720,1 +783,8 @@\n-                assertEquals(x, true, \"weakCompareAndSetAcquire boolean\");\n+                assertEquals(x, true, \"success weakCompareAndSetAcquire boolean\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, false, false);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire boolean\");\n+                boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, true, \"failing weakCompareAndSetAcquire boolean value\");\n@@ -728,1 +798,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease boolean\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease boolean\");\n+                boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, false, \"success weakCompareAndSetRelease boolean\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, true, false);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire boolean\");\n@@ -730,1 +807,1 @@\n-                assertEquals(x, false, \"weakCompareAndSetRelease boolean\");\n+                assertEquals(x, false, \"failing weakCompareAndSetAcquire boolean value\");\n@@ -738,1 +815,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet boolean\");\n+                assertEquals(success, true, \"success weakCompareAndSet boolean\");\n+                boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, true, \"success weakCompareAndSet boolean\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, false, false);\n+                assertEquals(success, false, \"failing weakCompareAndSet boolean\");\n@@ -740,1 +824,1 @@\n-                assertEquals(x, true, \"weakCompareAndSet boolean\");\n+                assertEquals(x, true, \"failing weakCompareAndSet boolean value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessBoolean.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,1 +215,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain byte\");\n@@ -217,1 +217,8 @@\n-            assertEquals(x, (byte)0x23, \"weakCompareAndSetPlain byte value\");\n+            assertEquals(x, (byte)0x23, \"success weakCompareAndSetPlain byte value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, (byte)0x01, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain byte\");\n+            byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, (byte)0x23, \"failing weakCompareAndSetPlain byte value\");\n@@ -225,1 +232,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire byte\");\n+            byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, (byte)0x01, \"success weakCompareAndSetAcquire byte\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, (byte)0x23, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire byte\");\n@@ -227,1 +241,1 @@\n-            assertEquals(x, (byte)0x01, \"weakCompareAndSetAcquire byte\");\n+            assertEquals(x, (byte)0x01, \"failing weakCompareAndSetAcquire byte value\");\n@@ -235,1 +249,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease byte\");\n+            byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, (byte)0x23, \"success weakCompareAndSetRelease byte\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, (byte)0x01, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease byte\");\n@@ -237,1 +258,1 @@\n-            assertEquals(x, (byte)0x23, \"weakCompareAndSetRelease byte\");\n+            assertEquals(x, (byte)0x23, \"failing weakCompareAndSetRelease byte value\");\n@@ -245,1 +266,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet byte\");\n+            assertEquals(success, true, \"success weakCompareAndSet byte\");\n@@ -247,1 +268,8 @@\n-            assertEquals(x, (byte)0x01, \"weakCompareAndSet byte\");\n+            assertEquals(x, (byte)0x01, \"success weakCompareAndSet byte\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, (byte)0x23, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSet byte\");\n+            byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, (byte)0x01, \"failing weakCompareAndSet byte value\");\n@@ -471,1 +499,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain byte\");\n+            byte x = (byte) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, (byte)0x23, \"success weakCompareAndSetPlain byte value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact((byte)0x01, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain byte\");\n@@ -473,1 +508,1 @@\n-            assertEquals(x, (byte)0x23, \"weakCompareAndSetPlain byte value\");\n+            assertEquals(x, (byte)0x23, \"failing weakCompareAndSetPlain byte value\");\n@@ -481,1 +516,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire byte\");\n+            byte x = (byte) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, (byte)0x01, \"success weakCompareAndSetAcquire byte\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact((byte)0x23, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire byte\");\n@@ -483,1 +525,1 @@\n-            assertEquals(x, (byte)0x01, \"weakCompareAndSetAcquire byte\");\n+            assertEquals(x, (byte)0x01, \"failing weakCompareAndSetAcquire byte value\");\n@@ -491,1 +533,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease byte\");\n@@ -493,1 +535,8 @@\n-            assertEquals(x, (byte)0x23, \"weakCompareAndSetRelease byte\");\n+            assertEquals(x, (byte)0x23, \"success weakCompareAndSetRelease byte\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact((byte)0x01, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease byte\");\n+            byte x = (byte) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, (byte)0x23, \"failing weakCompareAndSetRelease byte value\");\n@@ -501,1 +550,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet byte\");\n+            assertEquals(success, true, \"success weakCompareAndSet byte\");\n+            byte x = (byte) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, (byte)0x01, \"success weakCompareAndSet byte\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact((byte)0x23, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSet byte\");\n@@ -503,1 +559,1 @@\n-            assertEquals(x, (byte)0x01, \"weakCompareAndSet byte\");\n+            assertEquals(x, (byte)0x01, \"failing weakCompareAndSetRe byte value\");\n@@ -752,1 +808,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain byte\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain byte\");\n+                byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, (byte)0x23, \"success weakCompareAndSetPlain byte value\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, (byte)0x01, (byte)0x45);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain byte\");\n@@ -754,1 +817,1 @@\n-                assertEquals(x, (byte)0x23, \"weakCompareAndSetPlain byte value\");\n+                assertEquals(x, (byte)0x23, \"failing weakCompareAndSetPlain byte value\");\n@@ -762,1 +825,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire byte\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire byte\");\n@@ -764,1 +827,8 @@\n-                assertEquals(x, (byte)0x01, \"weakCompareAndSetAcquire byte\");\n+                assertEquals(x, (byte)0x01, \"success weakCompareAndSetAcquire byte\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, (byte)0x23, (byte)0x45);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire byte\");\n+                byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, (byte)0x01, \"failing weakCompareAndSetAcquire byte value\");\n@@ -772,1 +842,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease byte\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease byte\");\n+                byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, (byte)0x23, \"success weakCompareAndSetRelease byte\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, (byte)0x01, (byte)0x45);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire byte\");\n@@ -774,1 +851,1 @@\n-                assertEquals(x, (byte)0x23, \"weakCompareAndSetRelease byte\");\n+                assertEquals(x, (byte)0x23, \"failing weakCompareAndSetAcquire byte value\");\n@@ -782,1 +859,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet byte\");\n+                assertEquals(success, true, \"success weakCompareAndSet byte\");\n+                byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, (byte)0x01, \"success weakCompareAndSet byte\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, (byte)0x23, (byte)0x45);\n+                assertEquals(success, false, \"failing weakCompareAndSet byte\");\n@@ -784,1 +868,1 @@\n-                assertEquals(x, (byte)0x01, \"weakCompareAndSet byte\");\n+                assertEquals(x, (byte)0x01, \"failing weakCompareAndSet byte value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessByte.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,1 +215,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain char\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain char\");\n@@ -217,1 +217,8 @@\n-            assertEquals(x, '\\u4567', \"weakCompareAndSetPlain char value\");\n+            assertEquals(x, '\\u4567', \"success weakCompareAndSetPlain char value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, '\\u0123', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain char\");\n+            char x = (char) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, '\\u4567', \"failing weakCompareAndSetPlain char value\");\n@@ -225,1 +232,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire char\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire char\");\n+            char x = (char) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, '\\u0123', \"success weakCompareAndSetAcquire char\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, '\\u4567', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire char\");\n@@ -227,1 +241,1 @@\n-            assertEquals(x, '\\u0123', \"weakCompareAndSetAcquire char\");\n+            assertEquals(x, '\\u0123', \"failing weakCompareAndSetAcquire char value\");\n@@ -235,1 +249,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease char\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease char\");\n+            char x = (char) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, '\\u4567', \"success weakCompareAndSetRelease char\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, '\\u0123', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease char\");\n@@ -237,1 +258,1 @@\n-            assertEquals(x, '\\u4567', \"weakCompareAndSetRelease char\");\n+            assertEquals(x, '\\u4567', \"failing weakCompareAndSetRelease char value\");\n@@ -245,1 +266,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet char\");\n+            assertEquals(success, true, \"success weakCompareAndSet char\");\n@@ -247,1 +268,8 @@\n-            assertEquals(x, '\\u0123', \"weakCompareAndSet char\");\n+            assertEquals(x, '\\u0123', \"success weakCompareAndSet char\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, '\\u4567', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSet char\");\n+            char x = (char) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, '\\u0123', \"failing weakCompareAndSet char value\");\n@@ -471,1 +499,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain char\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain char\");\n+            char x = (char) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, '\\u4567', \"success weakCompareAndSetPlain char value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact('\\u0123', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain char\");\n@@ -473,1 +508,1 @@\n-            assertEquals(x, '\\u4567', \"weakCompareAndSetPlain char value\");\n+            assertEquals(x, '\\u4567', \"failing weakCompareAndSetPlain char value\");\n@@ -481,1 +516,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire char\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire char\");\n+            char x = (char) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, '\\u0123', \"success weakCompareAndSetAcquire char\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact('\\u4567', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire char\");\n@@ -483,1 +525,1 @@\n-            assertEquals(x, '\\u0123', \"weakCompareAndSetAcquire char\");\n+            assertEquals(x, '\\u0123', \"failing weakCompareAndSetAcquire char value\");\n@@ -491,1 +533,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease char\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease char\");\n@@ -493,1 +535,8 @@\n-            assertEquals(x, '\\u4567', \"weakCompareAndSetRelease char\");\n+            assertEquals(x, '\\u4567', \"success weakCompareAndSetRelease char\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact('\\u0123', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease char\");\n+            char x = (char) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, '\\u4567', \"failing weakCompareAndSetRelease char value\");\n@@ -501,1 +550,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet char\");\n+            assertEquals(success, true, \"success weakCompareAndSet char\");\n+            char x = (char) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, '\\u0123', \"success weakCompareAndSet char\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact('\\u4567', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSet char\");\n@@ -503,1 +559,1 @@\n-            assertEquals(x, '\\u0123', \"weakCompareAndSet char\");\n+            assertEquals(x, '\\u0123', \"failing weakCompareAndSetRe char value\");\n@@ -752,1 +808,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain char\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain char\");\n+                char x = (char) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, '\\u4567', \"success weakCompareAndSetPlain char value\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, '\\u0123', '\\u89AB');\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain char\");\n@@ -754,1 +817,1 @@\n-                assertEquals(x, '\\u4567', \"weakCompareAndSetPlain char value\");\n+                assertEquals(x, '\\u4567', \"failing weakCompareAndSetPlain char value\");\n@@ -762,1 +825,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire char\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire char\");\n@@ -764,1 +827,8 @@\n-                assertEquals(x, '\\u0123', \"weakCompareAndSetAcquire char\");\n+                assertEquals(x, '\\u0123', \"success weakCompareAndSetAcquire char\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, '\\u4567', '\\u89AB');\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire char\");\n+                char x = (char) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, '\\u0123', \"failing weakCompareAndSetAcquire char value\");\n@@ -772,1 +842,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease char\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease char\");\n+                char x = (char) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, '\\u4567', \"success weakCompareAndSetRelease char\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, '\\u0123', '\\u89AB');\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire char\");\n@@ -774,1 +851,1 @@\n-                assertEquals(x, '\\u4567', \"weakCompareAndSetRelease char\");\n+                assertEquals(x, '\\u4567', \"failing weakCompareAndSetAcquire char value\");\n@@ -782,1 +859,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet char\");\n+                assertEquals(success, true, \"success weakCompareAndSet char\");\n+                char x = (char) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, '\\u0123', \"success weakCompareAndSet char\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, '\\u4567', '\\u89AB');\n+                assertEquals(success, false, \"failing weakCompareAndSet char\");\n@@ -784,1 +868,1 @@\n-                assertEquals(x, '\\u0123', \"weakCompareAndSet char\");\n+                assertEquals(x, '\\u0123', \"failing weakCompareAndSet char value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessChar.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,1 +215,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain double\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain double\");\n@@ -217,1 +217,8 @@\n-            assertEquals(x, 2.0d, \"weakCompareAndSetPlain double value\");\n+            assertEquals(x, 2.0d, \"success weakCompareAndSetPlain double value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, 1.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain double\");\n+            double x = (double) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 2.0d, \"failing weakCompareAndSetPlain double value\");\n@@ -225,1 +232,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire double\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire double\");\n+            double x = (double) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 1.0d, \"success weakCompareAndSetAcquire double\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, 2.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire double\");\n@@ -227,1 +241,1 @@\n-            assertEquals(x, 1.0d, \"weakCompareAndSetAcquire double\");\n+            assertEquals(x, 1.0d, \"failing weakCompareAndSetAcquire double value\");\n@@ -235,1 +249,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease double\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease double\");\n+            double x = (double) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 2.0d, \"success weakCompareAndSetRelease double\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, 1.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease double\");\n@@ -237,1 +258,1 @@\n-            assertEquals(x, 2.0d, \"weakCompareAndSetRelease double\");\n+            assertEquals(x, 2.0d, \"failing weakCompareAndSetRelease double value\");\n@@ -245,1 +266,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet double\");\n+            assertEquals(success, true, \"success weakCompareAndSet double\");\n@@ -247,1 +268,8 @@\n-            assertEquals(x, 1.0d, \"weakCompareAndSet double\");\n+            assertEquals(x, 1.0d, \"success weakCompareAndSet double\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, 2.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSet double\");\n+            double x = (double) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 1.0d, \"failing weakCompareAndSet double value\");\n@@ -393,1 +421,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain double\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain double\");\n+            double x = (double) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 2.0d, \"success weakCompareAndSetPlain double value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(1.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain double\");\n@@ -395,1 +430,1 @@\n-            assertEquals(x, 2.0d, \"weakCompareAndSetPlain double value\");\n+            assertEquals(x, 2.0d, \"failing weakCompareAndSetPlain double value\");\n@@ -403,1 +438,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire double\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire double\");\n+            double x = (double) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 1.0d, \"success weakCompareAndSetAcquire double\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(2.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire double\");\n@@ -405,1 +447,1 @@\n-            assertEquals(x, 1.0d, \"weakCompareAndSetAcquire double\");\n+            assertEquals(x, 1.0d, \"failing weakCompareAndSetAcquire double value\");\n@@ -413,1 +455,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease double\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease double\");\n@@ -415,1 +457,8 @@\n-            assertEquals(x, 2.0d, \"weakCompareAndSetRelease double\");\n+            assertEquals(x, 2.0d, \"success weakCompareAndSetRelease double\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(1.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease double\");\n+            double x = (double) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 2.0d, \"failing weakCompareAndSetRelease double value\");\n@@ -423,1 +472,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet double\");\n+            assertEquals(success, true, \"success weakCompareAndSet double\");\n+            double x = (double) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 1.0d, \"success weakCompareAndSet double\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(2.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSet double\");\n@@ -425,1 +481,1 @@\n-            assertEquals(x, 1.0d, \"weakCompareAndSet double\");\n+            assertEquals(x, 1.0d, \"failing weakCompareAndSetRe double value\");\n@@ -596,1 +652,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain double\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain double\");\n+                double x = (double) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 2.0d, \"success weakCompareAndSetPlain double value\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, 1.0d, 3.0d);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain double\");\n@@ -598,1 +661,1 @@\n-                assertEquals(x, 2.0d, \"weakCompareAndSetPlain double value\");\n+                assertEquals(x, 2.0d, \"failing weakCompareAndSetPlain double value\");\n@@ -606,1 +669,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire double\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire double\");\n@@ -608,1 +671,8 @@\n-                assertEquals(x, 1.0d, \"weakCompareAndSetAcquire double\");\n+                assertEquals(x, 1.0d, \"success weakCompareAndSetAcquire double\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, 2.0d, 3.0d);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire double\");\n+                double x = (double) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 1.0d, \"failing weakCompareAndSetAcquire double value\");\n@@ -616,1 +686,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease double\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease double\");\n+                double x = (double) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 2.0d, \"success weakCompareAndSetRelease double\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, 1.0d, 3.0d);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire double\");\n@@ -618,1 +695,1 @@\n-                assertEquals(x, 2.0d, \"weakCompareAndSetRelease double\");\n+                assertEquals(x, 2.0d, \"failing weakCompareAndSetAcquire double value\");\n@@ -626,1 +703,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet double\");\n+                assertEquals(success, true, \"success weakCompareAndSet double\");\n+                double x = (double) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 1.0d, \"success weakCompareAndSet double\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, 2.0d, 3.0d);\n+                assertEquals(success, false, \"failing weakCompareAndSet double\");\n@@ -628,1 +712,1 @@\n-                assertEquals(x, 1.0d, \"weakCompareAndSet double\");\n+                assertEquals(x, 1.0d, \"failing weakCompareAndSet double value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessDouble.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,1 +215,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain float\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain float\");\n@@ -217,1 +217,8 @@\n-            assertEquals(x, 2.0f, \"weakCompareAndSetPlain float value\");\n+            assertEquals(x, 2.0f, \"success weakCompareAndSetPlain float value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, 1.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain float\");\n+            float x = (float) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 2.0f, \"failing weakCompareAndSetPlain float value\");\n@@ -225,1 +232,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire float\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire float\");\n+            float x = (float) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 1.0f, \"success weakCompareAndSetAcquire float\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, 2.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire float\");\n@@ -227,1 +241,1 @@\n-            assertEquals(x, 1.0f, \"weakCompareAndSetAcquire float\");\n+            assertEquals(x, 1.0f, \"failing weakCompareAndSetAcquire float value\");\n@@ -235,1 +249,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease float\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease float\");\n+            float x = (float) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 2.0f, \"success weakCompareAndSetRelease float\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, 1.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease float\");\n@@ -237,1 +258,1 @@\n-            assertEquals(x, 2.0f, \"weakCompareAndSetRelease float\");\n+            assertEquals(x, 2.0f, \"failing weakCompareAndSetRelease float value\");\n@@ -245,1 +266,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet float\");\n+            assertEquals(success, true, \"success weakCompareAndSet float\");\n@@ -247,1 +268,8 @@\n-            assertEquals(x, 1.0f, \"weakCompareAndSet float\");\n+            assertEquals(x, 1.0f, \"success weakCompareAndSet float\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, 2.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSet float\");\n+            float x = (float) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 1.0f, \"failing weakCompareAndSet float value\");\n@@ -393,1 +421,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain float\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain float\");\n+            float x = (float) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 2.0f, \"success weakCompareAndSetPlain float value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(1.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain float\");\n@@ -395,1 +430,1 @@\n-            assertEquals(x, 2.0f, \"weakCompareAndSetPlain float value\");\n+            assertEquals(x, 2.0f, \"failing weakCompareAndSetPlain float value\");\n@@ -403,1 +438,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire float\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire float\");\n+            float x = (float) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 1.0f, \"success weakCompareAndSetAcquire float\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(2.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire float\");\n@@ -405,1 +447,1 @@\n-            assertEquals(x, 1.0f, \"weakCompareAndSetAcquire float\");\n+            assertEquals(x, 1.0f, \"failing weakCompareAndSetAcquire float value\");\n@@ -413,1 +455,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease float\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease float\");\n@@ -415,1 +457,8 @@\n-            assertEquals(x, 2.0f, \"weakCompareAndSetRelease float\");\n+            assertEquals(x, 2.0f, \"success weakCompareAndSetRelease float\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(1.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease float\");\n+            float x = (float) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 2.0f, \"failing weakCompareAndSetRelease float value\");\n@@ -423,1 +472,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet float\");\n+            assertEquals(success, true, \"success weakCompareAndSet float\");\n+            float x = (float) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 1.0f, \"success weakCompareAndSet float\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(2.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSet float\");\n@@ -425,1 +481,1 @@\n-            assertEquals(x, 1.0f, \"weakCompareAndSet float\");\n+            assertEquals(x, 1.0f, \"failing weakCompareAndSetRe float value\");\n@@ -596,1 +652,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain float\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain float\");\n+                float x = (float) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 2.0f, \"success weakCompareAndSetPlain float value\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, 1.0f, 3.0f);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain float\");\n@@ -598,1 +661,1 @@\n-                assertEquals(x, 2.0f, \"weakCompareAndSetPlain float value\");\n+                assertEquals(x, 2.0f, \"failing weakCompareAndSetPlain float value\");\n@@ -606,1 +669,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire float\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire float\");\n@@ -608,1 +671,8 @@\n-                assertEquals(x, 1.0f, \"weakCompareAndSetAcquire float\");\n+                assertEquals(x, 1.0f, \"success weakCompareAndSetAcquire float\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, 2.0f, 3.0f);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire float\");\n+                float x = (float) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 1.0f, \"failing weakCompareAndSetAcquire float value\");\n@@ -616,1 +686,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease float\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease float\");\n+                float x = (float) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 2.0f, \"success weakCompareAndSetRelease float\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, 1.0f, 3.0f);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire float\");\n@@ -618,1 +695,1 @@\n-                assertEquals(x, 2.0f, \"weakCompareAndSetRelease float\");\n+                assertEquals(x, 2.0f, \"failing weakCompareAndSetAcquire float value\");\n@@ -626,1 +703,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet float\");\n+                assertEquals(success, true, \"success weakCompareAndSet float\");\n+                float x = (float) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 1.0f, \"success weakCompareAndSet float\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, 2.0f, 3.0f);\n+                assertEquals(success, false, \"failing weakCompareAndSet float\");\n@@ -628,1 +712,1 @@\n-                assertEquals(x, 1.0f, \"weakCompareAndSet float\");\n+                assertEquals(x, 1.0f, \"failing weakCompareAndSet float value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessFloat.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,1 +215,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain int\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain int\");\n@@ -217,1 +217,8 @@\n-            assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetPlain int value\");\n+            assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetPlain int value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, 0x01234567, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain int\");\n+            int x = (int) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetPlain int value\");\n@@ -225,1 +232,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire int\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire int\");\n+            int x = (int) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 0x01234567, \"success weakCompareAndSetAcquire int\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, 0x89ABCDEF, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire int\");\n@@ -227,1 +241,1 @@\n-            assertEquals(x, 0x01234567, \"weakCompareAndSetAcquire int\");\n+            assertEquals(x, 0x01234567, \"failing weakCompareAndSetAcquire int value\");\n@@ -235,1 +249,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease int\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease int\");\n+            int x = (int) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetRelease int\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, 0x01234567, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease int\");\n@@ -237,1 +258,1 @@\n-            assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetRelease int\");\n+            assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetRelease int value\");\n@@ -245,1 +266,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet int\");\n+            assertEquals(success, true, \"success weakCompareAndSet int\");\n@@ -247,1 +268,8 @@\n-            assertEquals(x, 0x01234567, \"weakCompareAndSet int\");\n+            assertEquals(x, 0x01234567, \"success weakCompareAndSet int\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, 0x89ABCDEF, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSet int\");\n+            int x = (int) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 0x01234567, \"failing weakCompareAndSet int value\");\n@@ -471,1 +499,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain int\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain int\");\n+            int x = (int) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetPlain int value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(0x01234567, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain int\");\n@@ -473,1 +508,1 @@\n-            assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetPlain int value\");\n+            assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetPlain int value\");\n@@ -481,1 +516,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire int\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire int\");\n+            int x = (int) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 0x01234567, \"success weakCompareAndSetAcquire int\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(0x89ABCDEF, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire int\");\n@@ -483,1 +525,1 @@\n-            assertEquals(x, 0x01234567, \"weakCompareAndSetAcquire int\");\n+            assertEquals(x, 0x01234567, \"failing weakCompareAndSetAcquire int value\");\n@@ -491,1 +533,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease int\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease int\");\n@@ -493,1 +535,8 @@\n-            assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetRelease int\");\n+            assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetRelease int\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(0x01234567, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease int\");\n+            int x = (int) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetRelease int value\");\n@@ -501,1 +550,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet int\");\n+            assertEquals(success, true, \"success weakCompareAndSet int\");\n+            int x = (int) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 0x01234567, \"success weakCompareAndSet int\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(0x89ABCDEF, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSet int\");\n@@ -503,1 +559,1 @@\n-            assertEquals(x, 0x01234567, \"weakCompareAndSet int\");\n+            assertEquals(x, 0x01234567, \"failing weakCompareAndSetRe int value\");\n@@ -752,1 +808,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain int\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain int\");\n+                int x = (int) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetPlain int value\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, 0x01234567, 0xCAFEBABE);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain int\");\n@@ -754,1 +817,1 @@\n-                assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetPlain int value\");\n+                assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetPlain int value\");\n@@ -762,1 +825,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire int\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire int\");\n@@ -764,1 +827,8 @@\n-                assertEquals(x, 0x01234567, \"weakCompareAndSetAcquire int\");\n+                assertEquals(x, 0x01234567, \"success weakCompareAndSetAcquire int\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, 0x89ABCDEF, 0xCAFEBABE);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire int\");\n+                int x = (int) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 0x01234567, \"failing weakCompareAndSetAcquire int value\");\n@@ -772,1 +842,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease int\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease int\");\n+                int x = (int) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetRelease int\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, 0x01234567, 0xCAFEBABE);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire int\");\n@@ -774,1 +851,1 @@\n-                assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetRelease int\");\n+                assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetAcquire int value\");\n@@ -782,1 +859,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet int\");\n+                assertEquals(success, true, \"success weakCompareAndSet int\");\n+                int x = (int) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 0x01234567, \"success weakCompareAndSet int\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, 0x89ABCDEF, 0xCAFEBABE);\n+                assertEquals(success, false, \"failing weakCompareAndSet int\");\n@@ -784,1 +868,1 @@\n-                assertEquals(x, 0x01234567, \"weakCompareAndSet int\");\n+                assertEquals(x, 0x01234567, \"failing weakCompareAndSet int value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessInt.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,1 +215,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain long\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain long\");\n@@ -217,1 +217,8 @@\n-            assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetPlain long value\");\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetPlain long value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, 0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain long\");\n+            long x = (long) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetPlain long value\");\n@@ -225,1 +232,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire long\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire long\");\n+            long x = (long) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSetAcquire long\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, 0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire long\");\n@@ -227,1 +241,1 @@\n-            assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSetAcquire long\");\n+            assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSetAcquire long value\");\n@@ -235,1 +249,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease long\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease long\");\n+            long x = (long) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetRelease long\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, 0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease long\");\n@@ -237,1 +258,1 @@\n-            assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetRelease long\");\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetRelease long value\");\n@@ -245,1 +266,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet long\");\n+            assertEquals(success, true, \"success weakCompareAndSet long\");\n@@ -247,1 +268,8 @@\n-            assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSet long\");\n+            assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSet long\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, 0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSet long\");\n+            long x = (long) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSet long value\");\n@@ -471,1 +499,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain long\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain long\");\n+            long x = (long) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetPlain long value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain long\");\n@@ -473,1 +508,1 @@\n-            assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetPlain long value\");\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetPlain long value\");\n@@ -481,1 +516,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire long\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire long\");\n+            long x = (long) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSetAcquire long\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire long\");\n@@ -483,1 +525,1 @@\n-            assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSetAcquire long\");\n+            assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSetAcquire long value\");\n@@ -491,1 +533,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease long\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease long\");\n@@ -493,1 +535,8 @@\n-            assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetRelease long\");\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetRelease long\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease long\");\n+            long x = (long) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetRelease long value\");\n@@ -501,1 +550,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet long\");\n+            assertEquals(success, true, \"success weakCompareAndSet long\");\n+            long x = (long) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSet long\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSet long\");\n@@ -503,1 +559,1 @@\n-            assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSet long\");\n+            assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSetRe long value\");\n@@ -752,1 +808,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain long\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain long\");\n+                long x = (long) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetPlain long value\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, 0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain long\");\n@@ -754,1 +817,1 @@\n-                assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetPlain long value\");\n+                assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetPlain long value\");\n@@ -762,1 +825,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire long\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire long\");\n@@ -764,1 +827,8 @@\n-                assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSetAcquire long\");\n+                assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSetAcquire long\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, 0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire long\");\n+                long x = (long) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSetAcquire long value\");\n@@ -772,1 +842,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease long\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease long\");\n+                long x = (long) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetRelease long\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, 0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire long\");\n@@ -774,1 +851,1 @@\n-                assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetRelease long\");\n+                assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetAcquire long value\");\n@@ -782,1 +859,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet long\");\n+                assertEquals(success, true, \"success weakCompareAndSet long\");\n+                long x = (long) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSet long\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, 0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+                assertEquals(success, false, \"failing weakCompareAndSet long\");\n@@ -784,1 +868,1 @@\n-                assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSet long\");\n+                assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSet long value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessLong.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,1 +215,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain short\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain short\");\n@@ -217,1 +217,8 @@\n-            assertEquals(x, (short)0x4567, \"weakCompareAndSetPlain short value\");\n+            assertEquals(x, (short)0x4567, \"success weakCompareAndSetPlain short value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, (short)0x0123, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain short\");\n+            short x = (short) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, (short)0x4567, \"failing weakCompareAndSetPlain short value\");\n@@ -225,1 +232,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire short\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire short\");\n+            short x = (short) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, (short)0x0123, \"success weakCompareAndSetAcquire short\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, (short)0x4567, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire short\");\n@@ -227,1 +241,1 @@\n-            assertEquals(x, (short)0x0123, \"weakCompareAndSetAcquire short\");\n+            assertEquals(x, (short)0x0123, \"failing weakCompareAndSetAcquire short value\");\n@@ -235,1 +249,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease short\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease short\");\n+            short x = (short) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, (short)0x4567, \"success weakCompareAndSetRelease short\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, (short)0x0123, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease short\");\n@@ -237,1 +258,1 @@\n-            assertEquals(x, (short)0x4567, \"weakCompareAndSetRelease short\");\n+            assertEquals(x, (short)0x4567, \"failing weakCompareAndSetRelease short value\");\n@@ -245,1 +266,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet short\");\n+            assertEquals(success, true, \"success weakCompareAndSet short\");\n@@ -247,1 +268,8 @@\n-            assertEquals(x, (short)0x0123, \"weakCompareAndSet short\");\n+            assertEquals(x, (short)0x0123, \"success weakCompareAndSet short\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, (short)0x4567, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSet short\");\n+            short x = (short) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, (short)0x0123, \"failing weakCompareAndSet short value\");\n@@ -471,1 +499,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain short\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain short\");\n+            short x = (short) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, (short)0x4567, \"success weakCompareAndSetPlain short value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact((short)0x0123, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain short\");\n@@ -473,1 +508,1 @@\n-            assertEquals(x, (short)0x4567, \"weakCompareAndSetPlain short value\");\n+            assertEquals(x, (short)0x4567, \"failing weakCompareAndSetPlain short value\");\n@@ -481,1 +516,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire short\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire short\");\n+            short x = (short) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, (short)0x0123, \"success weakCompareAndSetAcquire short\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact((short)0x4567, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire short\");\n@@ -483,1 +525,1 @@\n-            assertEquals(x, (short)0x0123, \"weakCompareAndSetAcquire short\");\n+            assertEquals(x, (short)0x0123, \"failing weakCompareAndSetAcquire short value\");\n@@ -491,1 +533,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease short\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease short\");\n@@ -493,1 +535,8 @@\n-            assertEquals(x, (short)0x4567, \"weakCompareAndSetRelease short\");\n+            assertEquals(x, (short)0x4567, \"success weakCompareAndSetRelease short\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact((short)0x0123, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease short\");\n+            short x = (short) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, (short)0x4567, \"failing weakCompareAndSetRelease short value\");\n@@ -501,1 +550,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet short\");\n+            assertEquals(success, true, \"success weakCompareAndSet short\");\n+            short x = (short) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, (short)0x0123, \"success weakCompareAndSet short\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact((short)0x4567, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSet short\");\n@@ -503,1 +559,1 @@\n-            assertEquals(x, (short)0x0123, \"weakCompareAndSet short\");\n+            assertEquals(x, (short)0x0123, \"failing weakCompareAndSetRe short value\");\n@@ -752,1 +808,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain short\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain short\");\n+                short x = (short) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, (short)0x4567, \"success weakCompareAndSetPlain short value\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, (short)0x0123, (short)0x89AB);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain short\");\n@@ -754,1 +817,1 @@\n-                assertEquals(x, (short)0x4567, \"weakCompareAndSetPlain short value\");\n+                assertEquals(x, (short)0x4567, \"failing weakCompareAndSetPlain short value\");\n@@ -762,1 +825,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire short\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire short\");\n@@ -764,1 +827,8 @@\n-                assertEquals(x, (short)0x0123, \"weakCompareAndSetAcquire short\");\n+                assertEquals(x, (short)0x0123, \"success weakCompareAndSetAcquire short\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, (short)0x4567, (short)0x89AB);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire short\");\n+                short x = (short) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, (short)0x0123, \"failing weakCompareAndSetAcquire short value\");\n@@ -772,1 +842,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease short\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease short\");\n+                short x = (short) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, (short)0x4567, \"success weakCompareAndSetRelease short\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, (short)0x0123, (short)0x89AB);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire short\");\n@@ -774,1 +851,1 @@\n-                assertEquals(x, (short)0x4567, \"weakCompareAndSetRelease short\");\n+                assertEquals(x, (short)0x4567, \"failing weakCompareAndSetAcquire short value\");\n@@ -782,1 +859,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet short\");\n+                assertEquals(success, true, \"success weakCompareAndSet short\");\n+                short x = (short) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, (short)0x0123, \"success weakCompareAndSet short\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, (short)0x4567, (short)0x89AB);\n+                assertEquals(success, false, \"failing weakCompareAndSet short\");\n@@ -784,1 +868,1 @@\n-                assertEquals(x, (short)0x0123, \"weakCompareAndSet short\");\n+                assertEquals(x, (short)0x0123, \"failing weakCompareAndSet short value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessShort.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,1 +215,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain String\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain String\");\n@@ -217,1 +217,8 @@\n-            assertEquals(x, \"bar\", \"weakCompareAndSetPlain String value\");\n+            assertEquals(x, \"bar\", \"success weakCompareAndSetPlain String value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, \"foo\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain String\");\n+            String x = (String) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, \"bar\", \"failing weakCompareAndSetPlain String value\");\n@@ -225,1 +232,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire String\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire String\");\n+            String x = (String) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, \"foo\", \"success weakCompareAndSetAcquire String\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, \"bar\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire String\");\n@@ -227,1 +241,1 @@\n-            assertEquals(x, \"foo\", \"weakCompareAndSetAcquire String\");\n+            assertEquals(x, \"foo\", \"failing weakCompareAndSetAcquire String value\");\n@@ -235,1 +249,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease String\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease String\");\n+            String x = (String) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, \"bar\", \"success weakCompareAndSetRelease String\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, \"foo\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease String\");\n@@ -237,1 +258,1 @@\n-            assertEquals(x, \"bar\", \"weakCompareAndSetRelease String\");\n+            assertEquals(x, \"bar\", \"failing weakCompareAndSetRelease String value\");\n@@ -245,1 +266,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet String\");\n+            assertEquals(success, true, \"success weakCompareAndSet String\");\n@@ -247,1 +268,8 @@\n-            assertEquals(x, \"foo\", \"weakCompareAndSet String\");\n+            assertEquals(x, \"foo\", \"success weakCompareAndSet String\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, \"bar\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSet String\");\n+            String x = (String) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, \"foo\", \"failing weakCompareAndSet String value\");\n@@ -371,1 +399,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain String\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain String\");\n+            String x = (String) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, \"bar\", \"success weakCompareAndSetPlain String value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(\"foo\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain String\");\n@@ -373,1 +408,1 @@\n-            assertEquals(x, \"bar\", \"weakCompareAndSetPlain String value\");\n+            assertEquals(x, \"bar\", \"failing weakCompareAndSetPlain String value\");\n@@ -381,1 +416,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire String\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire String\");\n+            String x = (String) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, \"foo\", \"success weakCompareAndSetAcquire String\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(\"bar\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire String\");\n@@ -383,1 +425,1 @@\n-            assertEquals(x, \"foo\", \"weakCompareAndSetAcquire String\");\n+            assertEquals(x, \"foo\", \"failing weakCompareAndSetAcquire String value\");\n@@ -391,1 +433,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease String\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease String\");\n@@ -393,1 +435,8 @@\n-            assertEquals(x, \"bar\", \"weakCompareAndSetRelease String\");\n+            assertEquals(x, \"bar\", \"success weakCompareAndSetRelease String\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(\"foo\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease String\");\n+            String x = (String) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, \"bar\", \"failing weakCompareAndSetRelease String value\");\n@@ -401,1 +450,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet String\");\n+            assertEquals(success, true, \"success weakCompareAndSet String\");\n+            String x = (String) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, \"foo\", \"success weakCompareAndSet String\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(\"bar\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSet String\");\n@@ -403,1 +459,1 @@\n-            assertEquals(x, \"foo\", \"weakCompareAndSet String\");\n+            assertEquals(x, \"foo\", \"failing weakCompareAndSetRe String value\");\n@@ -552,1 +608,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain String\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain String\");\n+                String x = (String) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, \"bar\", \"success weakCompareAndSetPlain String value\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, \"foo\", \"baz\");\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain String\");\n@@ -554,1 +617,1 @@\n-                assertEquals(x, \"bar\", \"weakCompareAndSetPlain String value\");\n+                assertEquals(x, \"bar\", \"failing weakCompareAndSetPlain String value\");\n@@ -562,1 +625,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire String\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire String\");\n@@ -564,1 +627,8 @@\n-                assertEquals(x, \"foo\", \"weakCompareAndSetAcquire String\");\n+                assertEquals(x, \"foo\", \"success weakCompareAndSetAcquire String\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, \"bar\", \"baz\");\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire String\");\n+                String x = (String) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, \"foo\", \"failing weakCompareAndSetAcquire String value\");\n@@ -572,1 +642,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease String\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease String\");\n+                String x = (String) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, \"bar\", \"success weakCompareAndSetRelease String\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, \"foo\", \"baz\");\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire String\");\n@@ -574,1 +651,1 @@\n-                assertEquals(x, \"bar\", \"weakCompareAndSetRelease String\");\n+                assertEquals(x, \"bar\", \"failing weakCompareAndSetAcquire String value\");\n@@ -582,1 +659,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet String\");\n+                assertEquals(success, true, \"success weakCompareAndSet String\");\n+                String x = (String) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, \"foo\", \"success weakCompareAndSet String\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, \"bar\", \"baz\");\n+                assertEquals(success, false, \"failing weakCompareAndSet String\");\n@@ -584,1 +668,1 @@\n-                assertEquals(x, \"foo\", \"weakCompareAndSet String\");\n+                assertEquals(x, \"foo\", \"failing weakCompareAndSet String value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessString.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -729,1 +729,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain $type$\");\n@@ -731,1 +731,8 @@\n-            assertEquals(x, $value2$, \"weakCompareAndSetPlain $type$ value\");\n+            assertEquals(x, $value2$, \"success weakCompareAndSetPlain $type$ value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(recv, $value1$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain $type$\");\n+            $type$ x = ($type$) vh.get(recv);\n+            assertEquals(x, $value2$, \"failing weakCompareAndSetPlain $type$ value\");\n@@ -739,1 +746,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire $type$\");\n+            $type$ x = ($type$) vh.get(recv);\n+            assertEquals(x, $value1$, \"success weakCompareAndSetAcquire $type$\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(recv, $value2$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire $type$\");\n@@ -741,1 +755,1 @@\n-            assertEquals(x, $value1$, \"weakCompareAndSetAcquire $type$\");\n+            assertEquals(x, $value1$, \"failing weakCompareAndSetAcquire $type$ value\");\n@@ -749,1 +763,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease $type$\");\n+            $type$ x = ($type$) vh.get(recv);\n+            assertEquals(x, $value2$, \"success weakCompareAndSetRelease $type$\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(recv, $value1$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease $type$\");\n@@ -751,1 +772,1 @@\n-            assertEquals(x, $value2$, \"weakCompareAndSetRelease $type$\");\n+            assertEquals(x, $value2$, \"failing weakCompareAndSetRelease $type$ value\");\n@@ -759,1 +780,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSet $type$\");\n@@ -761,1 +782,8 @@\n-            assertEquals(x, $value1$, \"weakCompareAndSet $type$ value\");\n+            assertEquals(x, $value1$, \"success weakCompareAndSet $type$ value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(recv, $value2$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSet $type$\");\n+            $type$ x = ($type$) vh.get(recv);\n+            assertEquals(x, $value1$, \"failing weakCompareAndSet $type$ value\");\n@@ -1106,1 +1134,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain $type$\");\n+            $type$ x = ($type$) vh.get();\n+            assertEquals(x, $value2$, \"success weakCompareAndSetPlain $type$ value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain($value1$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain $type$\");\n@@ -1108,1 +1143,1 @@\n-            assertEquals(x, $value2$, \"weakCompareAndSetPlain $type$ value\");\n+            assertEquals(x, $value2$, \"failing weakCompareAndSetPlain $type$ value\");\n@@ -1116,1 +1151,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire $type$\");\n+            $type$ x = ($type$) vh.get();\n+            assertEquals(x, $value1$, \"success weakCompareAndSetAcquire $type$\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire($value2$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire $type$\");\n@@ -1118,1 +1160,1 @@\n-            assertEquals(x, $value1$, \"weakCompareAndSetAcquire $type$\");\n+            assertEquals(x, $value1$, \"failing weakCompareAndSetAcquire $type$ value\");\n@@ -1126,1 +1168,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease $type$\");\n@@ -1128,1 +1170,8 @@\n-            assertEquals(x, $value2$, \"weakCompareAndSetRelease $type$\");\n+            assertEquals(x, $value2$, \"success weakCompareAndSetRelease $type$\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease($value1$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease $type$\");\n+            $type$ x = ($type$) vh.get();\n+            assertEquals(x, $value2$, \"failing weakCompareAndSetRelease $type$ value\");\n@@ -1136,1 +1185,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSet $type$\");\n+            $type$ x = ($type$) vh.get();\n+            assertEquals(x, $value1$, \"success weakCompareAndSet $type$\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet($value2$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSet $type$\");\n@@ -1138,1 +1194,1 @@\n-            assertEquals(x, $value1$, \"weakCompareAndSet $type$\");\n+            assertEquals(x, $value1$, \"failing weakCompareAndSet $type$ value\");\n@@ -1486,1 +1542,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain $type$\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain $type$\");\n+                $type$ x = ($type$) vh.get(array, i);\n+                assertEquals(x, $value2$, \"success weakCompareAndSetPlain $type$ value\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetPlain(array, i, $value1$, $value3$);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain $type$\");\n@@ -1488,1 +1551,1 @@\n-                assertEquals(x, $value2$, \"weakCompareAndSetPlain $type$ value\");\n+                assertEquals(x, $value2$, \"failing weakCompareAndSetPlain $type$ value\");\n@@ -1496,1 +1559,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire $type$\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire $type$\");\n@@ -1498,1 +1561,8 @@\n-                assertEquals(x, $value1$, \"weakCompareAndSetAcquire $type$\");\n+                assertEquals(x, $value1$, \"success weakCompareAndSetAcquire $type$\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetAcquire(array, i, $value2$, $value3$);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire $type$\");\n+                $type$ x = ($type$) vh.get(array, i);\n+                assertEquals(x, $value1$, \"failing weakCompareAndSetAcquire $type$ value\");\n@@ -1506,1 +1576,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease $type$\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease $type$\");\n+                $type$ x = ($type$) vh.get(array, i);\n+                assertEquals(x, $value2$, \"success weakCompareAndSetRelease $type$\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetRelease(array, i, $value1$, $value3$);\n+                assertEquals(success, false, \"failing weakCompareAndSetRelease $type$\");\n@@ -1508,1 +1585,1 @@\n-                assertEquals(x, $value2$, \"weakCompareAndSetRelease $type$\");\n+                assertEquals(x, $value2$, \"failing weakCompareAndSetRelease $type$ value\");\n@@ -1516,1 +1593,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet $type$\");\n+                assertEquals(success, true, \"success weakCompareAndSet $type$\");\n+                $type$ x = ($type$) vh.get(array, i);\n+                assertEquals(x, $value1$, \"success weakCompareAndSet $type$\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSet(array, i, $value2$, $value3$);\n+                assertEquals(success, false, \"failing weakCompareAndSet $type$\");\n@@ -1518,1 +1602,1 @@\n-                assertEquals(x, $value1$, \"weakCompareAndSet $type$\");\n+                assertEquals(x, $value1$, \"failing weakCompareAndSet $type$ value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/X-VarHandleTestAccess.java.template","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1630,1 +1630,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetPlain $type$\");\n+                    assertEquals(success, true, \"success weakCompareAndSetPlain $type$\");\n@@ -1632,1 +1632,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetPlain $type$ value\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetPlain $type$ value\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetPlain $type$\");\n+                    $type$ x = ($type$) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetPlain $type$ value\");\n@@ -1640,1 +1647,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSetAcquire $type$\");\n+                    assertEquals(success, true, \"success weakCompareAndSetAcquire $type$\");\n+                    $type$ x = ($type$) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSetAcquire $type$\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetAcquire $type$\");\n@@ -1642,1 +1656,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSetAcquire $type$\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSetAcquire $type$ value\");\n@@ -1650,1 +1664,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetRelease $type$\");\n+                    assertEquals(success, true, \"success weakCompareAndSetRelease $type$\");\n@@ -1652,1 +1666,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetRelease $type$\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetRelease $type$\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetRelease $type$\");\n+                    $type$ x = ($type$) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetRelease $type$ value\");\n@@ -1660,1 +1681,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSet $type$\");\n+                    assertEquals(success, true, \"success weakCompareAndSet $type$\");\n+                    $type$ x = ($type$) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSet $type$\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSet $type$\");\n@@ -1662,1 +1690,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSet $type$\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSet $type$ value\");\n@@ -1919,1 +1947,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetPlain $type$\");\n+                    assertEquals(success, true, \"success weakCompareAndSetPlain $type$\");\n@@ -1921,1 +1949,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetPlain $type$ value\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetPlain $type$ value\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetPlain $type$\");\n+                    $type$ x = ($type$) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetPlain $type$ value\");\n@@ -1929,1 +1964,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSetAcquire $type$\");\n+                    assertEquals(success, true, \"success weakCompareAndSetAcquire $type$\");\n+                    $type$ x = ($type$) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSetAcquire $type$\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetAcquire $type$\");\n@@ -1931,1 +1973,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSetAcquire $type$\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSetAcquire $type$ value\");\n@@ -1939,1 +1981,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetRelease $type$\");\n+                    assertEquals(success, true, \"success weakCompareAndSetRelease $type$\");\n@@ -1941,1 +1983,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetRelease $type$\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetRelease $type$\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetRelease $type$\");\n+                    $type$ x = ($type$) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetRelease $type$ value\");\n@@ -1949,1 +1998,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSet $type$\");\n+                    assertEquals(success, true, \"success weakCompareAndSet $type$\");\n+                    $type$ x = ($type$) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSet $type$\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSet $type$\");\n@@ -1951,1 +2007,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSet $type$\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSet $type$ value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/X-VarHandleTestByteArrayView.java.template","additions":73,"deletions":17,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -216,1 +216,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain $type$\");\n@@ -218,1 +218,8 @@\n-            assertEquals(x, $value2$, \"weakCompareAndSetPlain $type$ value\");\n+            assertEquals(x, $value2$, \"success weakCompareAndSetPlain $type$ value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, $value1$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain $type$\");\n+            $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, $value2$, \"failing weakCompareAndSetPlain $type$ value\");\n@@ -226,1 +233,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire $type$\");\n+            $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, $value1$, \"success weakCompareAndSetAcquire $type$\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, $value2$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire $type$\");\n@@ -228,1 +242,1 @@\n-            assertEquals(x, $value1$, \"weakCompareAndSetAcquire $type$\");\n+            assertEquals(x, $value1$, \"failing weakCompareAndSetAcquire $type$ value\");\n@@ -236,1 +250,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease $type$\");\n+            $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, $value2$, \"success weakCompareAndSetRelease $type$\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, $value1$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease $type$\");\n@@ -238,1 +259,1 @@\n-            assertEquals(x, $value2$, \"weakCompareAndSetRelease $type$\");\n+            assertEquals(x, $value2$, \"failing weakCompareAndSetRelease $type$ value\");\n@@ -246,1 +267,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSet $type$\");\n@@ -248,1 +269,8 @@\n-            assertEquals(x, $value1$, \"weakCompareAndSet $type$\");\n+            assertEquals(x, $value1$, \"success weakCompareAndSet $type$\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, $value2$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSet $type$\");\n+            $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, $value1$, \"failing weakCompareAndSet $type$ value\");\n@@ -511,1 +539,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain $type$\");\n+            $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, $value2$, \"success weakCompareAndSetPlain $type$ value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact($value1$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain $type$\");\n@@ -513,1 +548,1 @@\n-            assertEquals(x, $value2$, \"weakCompareAndSetPlain $type$ value\");\n+            assertEquals(x, $value2$, \"failing weakCompareAndSetPlain $type$ value\");\n@@ -521,1 +556,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire $type$\");\n+            $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, $value1$, \"success weakCompareAndSetAcquire $type$\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact($value2$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire $type$\");\n@@ -523,1 +565,1 @@\n-            assertEquals(x, $value1$, \"weakCompareAndSetAcquire $type$\");\n+            assertEquals(x, $value1$, \"failing weakCompareAndSetAcquire $type$ value\");\n@@ -531,1 +573,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease $type$\");\n@@ -533,1 +575,8 @@\n-            assertEquals(x, $value2$, \"weakCompareAndSetRelease $type$\");\n+            assertEquals(x, $value2$, \"success weakCompareAndSetRelease $type$\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact($value1$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease $type$\");\n+            $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, $value2$, \"failing weakCompareAndSetRelease $type$ value\");\n@@ -541,1 +590,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSet $type$\");\n+            $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, $value1$, \"success weakCompareAndSet $type$\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact($value2$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSet $type$\");\n@@ -543,1 +599,1 @@\n-            assertEquals(x, $value1$, \"weakCompareAndSet $type$\");\n+            assertEquals(x, $value1$, \"failing weakCompareAndSetRe $type$ value\");\n@@ -831,1 +887,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain $type$\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain $type$\");\n+                $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, $value2$, \"success weakCompareAndSetPlain $type$ value\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, $value1$, $value3$);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain $type$\");\n@@ -833,1 +896,1 @@\n-                assertEquals(x, $value2$, \"weakCompareAndSetPlain $type$ value\");\n+                assertEquals(x, $value2$, \"failing weakCompareAndSetPlain $type$ value\");\n@@ -841,1 +904,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire $type$\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire $type$\");\n@@ -843,1 +906,8 @@\n-                assertEquals(x, $value1$, \"weakCompareAndSetAcquire $type$\");\n+                assertEquals(x, $value1$, \"success weakCompareAndSetAcquire $type$\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, $value2$, $value3$);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire $type$\");\n+                $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, $value1$, \"failing weakCompareAndSetAcquire $type$ value\");\n@@ -851,1 +921,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease $type$\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease $type$\");\n+                $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, $value2$, \"success weakCompareAndSetRelease $type$\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, $value1$, $value3$);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire $type$\");\n@@ -853,1 +930,1 @@\n-                assertEquals(x, $value2$, \"weakCompareAndSetRelease $type$\");\n+                assertEquals(x, $value2$, \"failing weakCompareAndSetAcquire $type$ value\");\n@@ -861,1 +938,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet $type$\");\n+                assertEquals(success, true, \"success weakCompareAndSet $type$\");\n+                $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, $value1$, \"success weakCompareAndSet $type$\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, $value2$, $value3$);\n+                assertEquals(success, false, \"failing weakCompareAndSet $type$\");\n@@ -863,1 +947,1 @@\n-                assertEquals(x, $value1$, \"weakCompareAndSet $type$\");\n+                assertEquals(x, $value1$, \"failing weakCompareAndSet $type$ value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/X-VarHandleTestMethodHandleAccess.java.template","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,18 @@\n+\/*\n+ * @test\n+ * @bug     4982128\n+ * @summary Test low memory detection of non-heap memory pool\n+ *\n+ * @run main\/othervm\/timeout=600 -noclassgc -XX:MaxMetaspaceSize=32m\n+ * LowMemoryTest2\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug     4982128\n+ * @summary Test low memory detection of non-heap memory pool\n+ *\n+ * @run main\/othervm\/timeout=600 -noclassgc -XX:MaxMetaspaceSize=16m\n+ * -XX:CompressedClassSpaceSize=4m LowMemoryTest2\n+ *\/\n+\n","filename":"test\/jdk\/java\/lang\/management\/MemoryMXBean\/LowMemoryTest2.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1,80 +0,0 @@\n-#\n-# Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#\n-# @test\n-# @bug     4982128\n-# @summary Test low memory detection of non-heap memory pool\n-#\n-# @requires vm.gc==\"null\"\n-#\n-# @run build LowMemoryTest2 MemoryUtil\n-# @run shell\/timeout=600 LowMemoryTest2.sh\n-#\n-\n-if [ ! -z \"${TESTJAVA}\" ] ; then\n-     JAVA=${TESTJAVA}\/bin\/java\n-     CLASSPATH=${TESTCLASSES}\n-     export CLASSPATH\n-else\n-     echo \"--Error: TESTJAVA must be defined as the pathname of a jdk to test.\"\n-     exit 1\n-fi\n-\n-# Test execution\n-\n-failures=0\n-\n-go() {\n-    echo ''\n-    sh -xc \"$JAVA $TESTVMOPTS $*\" 2>&1\n-    if [ $? != 0 ]; then failures=`expr $failures + 1`; fi\n-}\n-\n-# Run test with each GC configuration\n-#\n-# Notes: To ensure that metaspace fills up we disable class unloading.\n-# Also we set the max metaspace to 16MB\/32MB - otherwise the test takes too\n-# long to run. The 32MB setting is required for running with CDS archive.\n-\n-go -noclassgc -XX:MaxMetaspaceSize=32m -XX:+UseSerialGC LowMemoryTest2\n-go -noclassgc -XX:MaxMetaspaceSize=32m -XX:+UseParallelGC LowMemoryTest2\n-\n-# Test class metaspace - might hit MaxMetaspaceSize instead if\n-# UseCompressedClassPointers is off or if 32 bit.\n-#\n-# (note: This is very shaky and that shakiness exposes a problem with MemoryMXBean:\n-#\n-#  MemoryMXBean defines \"used\" \"committed\" and \"max\" (see java\/lang\/management\/MemoryUsage.java)\n-#  This abstraction misses a definition for \"address space exhausted\" which with the new Metaspace (jep387)\n-#  can happen before committed\/used hits any trigger. We now commit only on demand and therefore class loaders\n-#  can sit atop of uncommitted address space, denying new loaders address space. In the old Metaspace,\n-#  we would have committed the space right away and therefore the MemoryMXBean \"committed\" trigger\n-#  would have fired. In the new Metaspace, we don't commit, so the MemoryMXBean does not fire.\n-go -noclassgc -XX:MaxMetaspaceSize=16m -XX:CompressedClassSpaceSize=4m LowMemoryTest2\n-\n-echo ''\n-if [ $failures -gt 0 ];\n-  then echo \"$failures test(s) failed\";\n-  else echo \"All test(s) passed\"; fi\n-exit $failures\n","filename":"test\/jdk\/java\/lang\/management\/MemoryMXBean\/LowMemoryTest2.sh","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+ * @requires vm.gc == null | vm.gc == \"G1\"\n+ *\n@@ -34,2 +36,17 @@\n- * @build MemoryManagement MemoryUtil\n- * @run main\/othervm\/timeout=600 -Xmn8m -XX:+IgnoreUnrecognizedVMOptions -XX:G1HeapRegionSize=1 -XX:-UseLargePages MemoryManagement\n+ *\n+ * @run main\/othervm\/timeout=600 -Xmn8m -XX:+IgnoreUnrecognizedVMOptions\n+ * -XX:G1HeapRegionSize=1 -XX:-UseLargePages MemoryManagement\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug     4530538 6980984\n+ * @summary Basic unit test of memory management testing:\n+ *          1) setUsageThreshold() and getUsageThreshold()\n+ *          2) test low memory detection on the old generation.\n+ *\n+ * @author  Mandy Chung\n+ *\n+ * @modules jdk.management\n+ *\n+ * @run main\/timeout=600 MemoryManagement\n","filename":"test\/jdk\/java\/lang\/management\/MemoryMXBean\/MemoryManagement.java","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1,54 +0,0 @@\n-#\n-# Copyright (c) 2003, 2015, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#\n-# @test\n-# @bug     4530538\n-# @summary Run MemoryManagement test with parallel GC\n-# @author  Mandy Chung\n-#\n-# @requires vm.gc==\"Parallel\" | vm.gc==\"null\"\n-#\n-# @run build MemoryManagement\n-# @run shell\/timeout=600 MemoryManagementParallelGC.sh\n-#\n-\n-#Set appropriate jdk\n-\n-if [ ! -z \"${TESTJAVA}\" ] ; then\n-     jdk=\"$TESTJAVA\"\n-else\n-     echo \"--Error: TESTJAVA must be defined as the pathname of a jdk to test.\"\n-     exit 1\n-fi\n-\n-runOne()\n-{\n-   echo \"runOne $@\"\n-   $TESTJAVA\/bin\/java ${TESTVMOPTS} -classpath $TESTCLASSES $@ || exit 2\n-}\n-\n-# Test MemoryManagement with parallel collector\n-runOne -XX:+UseParallelGC MemoryManagement\n-\n-exit 0\n","filename":"test\/jdk\/java\/lang\/management\/MemoryMXBean\/MemoryManagementParallelGC.sh","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -1,54 +0,0 @@\n-#\n-# Copyright (c) 2003, 2015, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#\n-# @test\n-# @bug     4530538\n-# @summary Run MemoryManagement test with serial GC\n-# @author  Mandy Chung\n-#\n-# @requires vm.gc==\"Serial\" | vm.gc==\"null\"\n-#\n-# @run build MemoryManagement\n-# @run shell\/timeout=600 MemoryManagementSerialGC.sh\n-#\n-\n-#Set appropriate jdk\n-\n-if [ ! -z \"${TESTJAVA}\" ] ; then\n-     jdk=\"$TESTJAVA\"\n-else\n-     echo \"--Error: TESTJAVA must be defined as the pathname of a jdk to test.\"\n-     exit 1\n-fi\n-\n-runOne()\n-{\n-   echo \"runOne $@\"\n-   $TESTJAVA\/bin\/java ${TESTVMOPTS} -classpath $TESTCLASSES $@ || exit 2\n-}\n-\n-# Test MemoryManagement with serial collector\n-runOne -XX:+UseSerialGC MemoryManagement\n-\n-exit 0\n","filename":"test\/jdk\/java\/lang\/management\/MemoryMXBean\/MemoryManagementSerialGC.sh","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/management\/MemoryMXBean\/MemoryTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,58 +0,0 @@\n-#\n-# Copyright (c) 2003, 2015, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#\n-# @test\n-# @bug     4530538\n-# @summary\n-# @author  Mandy Chung\n-#\n-# @requires vm.gc==\"Parallel\" | vm.gc==\"null\"\n-#\n-# @run compile MemoryTest.java\n-# @run shell MemoryTestAllGC.sh\n-#\n-\n-#Set appropriate jdk\n-\n-if [ ! -z \"${TESTJAVA}\" ] ; then\n-     jdk=\"$TESTJAVA\"\n-else\n-     echo \"--Error: TESTJAVA must be defined as the pathname of a jdk to test.\"\n-     exit 1\n-fi\n-\n-runOne()\n-{\n-   echo \"runOne $@\"\n-   $TESTJAVA\/bin\/java ${TESTVMOPTS} -classpath $TESTCLASSES $@ || exit 2\n-}\n-\n-# Test MemoryTest with default collector\n-runOne MemoryTest 2 3\n-\n-# Test MemoryTest with parallel scavenger collector\n-runOne -XX:+UseParallelGC MemoryTest 2 3\n-\n-\n-exit 0\n","filename":"test\/jdk\/java\/lang\/management\/MemoryMXBean\/MemoryTestAllGC.sh","additions":0,"deletions":58,"binary":false,"changes":58,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,2 @@\n+ *\n+ * @run main Pending\n","filename":"test\/jdk\/java\/lang\/management\/MemoryMXBean\/Pending.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,57 +0,0 @@\n-#\n-# Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#\n-# @test\n-# @bug     4530538\n-# @summary \n-# @author  Mandy Chung\n-# @requires vm.gc==\"null\"\n-# @modules java.base\/jdk.internal.misc\n-#          java.management\n-# @run compile Pending.java\n-# @run shell PendingAllGC.sh\n-#\n-\n-#Set appropriate jdk\n-\n-if [ ! -z \"${TESTJAVA}\" ] ; then\n-     jdk=\"$TESTJAVA\"\n-else\n-     echo \"--Error: TESTJAVA must be defined as the pathname of a jdk to test.\"\n-     exit 1\n-fi\n-\n-runOne()\n-{ \n-   echo \"runOne $@\"\n-   $TESTJAVA\/bin\/java ${TESTVMOPTS} -classpath $TESTCLASSES $@ || exit 2\n-}\n-\n-# Test Pending with default collector\n-runOne Pending\n-\n-# Test Pending with parallel scavenger collector\n-runOne -XX:+UseParallelGC Pending \n-\n-exit 0\n","filename":"test\/jdk\/java\/lang\/management\/MemoryMXBean\/PendingAllGC.sh","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,0 @@\n-import org.testng.annotations.Test;\n-\n@@ -29,0 +27,3 @@\n+import java.lang.module.ModuleDescriptor.Exports;\n+import java.lang.module.ModuleDescriptor.Opens;\n+import java.lang.module.ModuleDescriptor.Requires;\n@@ -31,0 +32,1 @@\n+import org.testng.annotations.Test;\n@@ -36,1 +38,2 @@\n- * @bug 8275509\n+ * @bug 8275509 8290041\n+ * @summary Tests the ModuleDescriptor.hashCode()\n@@ -39,1 +42,0 @@\n- * @summary Tests the ModuleDescriptor.hashCode() for boot layer modules\n@@ -66,0 +68,93 @@\n+    \/**\n+     * Verifies that two \"equal\" module descriptors which only differ in the order of\n+     * {@link ModuleDescriptor.Opens.Modifier opens modifiers}, that were used to construct the\n+     * descriptors, have the same hashcode.\n+     *\/\n+    @Test\n+    public void testOpensModifiersOrdering() throws Exception {\n+        \/\/ important to use Set.of() (i.e. backed by immutable set) to reproduce the issue\n+        final Set<Opens.Modifier> mods1 = Set.of(Opens.Modifier.SYNTHETIC, Opens.Modifier.MANDATED);\n+        final ModuleDescriptor desc1 = createModuleDescriptor(mods1, null, null);\n+\n+        \/\/ create the same module descriptor again and this time just change the order of the\n+        \/\/ \"opens\" modifiers' Set.\n+\n+        \/\/ important to use Set.of() (i.e. backed by immutable set) to reproduce the issue\n+        final Set<Opens.Modifier> mods2 = Set.of(Opens.Modifier.MANDATED, Opens.Modifier.SYNTHETIC);\n+        final ModuleDescriptor desc2 = createModuleDescriptor(mods2, null, null);\n+\n+        \/\/ basic verification of the modifiers themselves before we check the module descriptors\n+        assertEquals(mods1, mods2, \"Modifiers were expected to be equal\");\n+\n+        \/\/ now verify the module descriptors\n+        assertEquals(desc1, desc2, \"Module descriptors were expected to be equal\");\n+        assertEquals(desc1.compareTo(desc2), 0, \"compareTo was expected to return\" +\n+                \" 0 for module descriptors that are equal\");\n+        System.out.println(desc1 + \" hashcode = \" + desc1.hashCode());\n+        System.out.println(desc2 + \" hashcode = \" + desc2.hashCode());\n+        assertEquals(desc1.hashCode(), desc2.hashCode(), \"Module descriptor hashcodes\" +\n+                \" were expected to be equal\");\n+    }\n+\n+    \/**\n+     * Verifies that two \"equal\" module descriptors which only differ in the order of\n+     * {@link ModuleDescriptor.Exports.Modifier exports modifiers}, that were used to construct the\n+     * descriptors, have the same hashcode.\n+     *\/\n+    @Test\n+    public void testExportsModifiersOrdering() throws Exception {\n+        \/\/ important to use Set.of() (i.e. backed by immutable set) to reproduce the issue\n+        final Set<Exports.Modifier> mods1 = Set.of(Exports.Modifier.SYNTHETIC, Exports.Modifier.MANDATED);\n+        final ModuleDescriptor desc1 = createModuleDescriptor(null, null, mods1);\n+\n+        \/\/ create the same module descriptor again and this time just change the order of the\n+        \/\/ \"exports\" modifiers' Set.\n+\n+        \/\/ important to use Set.of() (i.e. backed by immutable set) to reproduce the issue\n+        final Set<Exports.Modifier> mods2 = Set.of(Exports.Modifier.MANDATED, Exports.Modifier.SYNTHETIC);\n+        final ModuleDescriptor desc2 = createModuleDescriptor(null, null, mods2);\n+\n+        \/\/ basic verification of the modifiers themselves before we check the module descriptors\n+        assertEquals(mods1, mods2, \"Modifiers were expected to be equal\");\n+\n+        \/\/ now verify the module descriptors\n+        assertEquals(desc1, desc2, \"Module descriptors were expected to be equal\");\n+        assertEquals(desc1.compareTo(desc2), 0, \"compareTo was expected to return\" +\n+                \" 0 for module descriptors that are equal\");\n+        System.out.println(desc1 + \" hashcode = \" + desc1.hashCode());\n+        System.out.println(desc2 + \" hashcode = \" + desc2.hashCode());\n+        assertEquals(desc1.hashCode(), desc2.hashCode(), \"Module descriptor hashcodes\" +\n+                \" were expected to be equal\");\n+    }\n+\n+    \/**\n+     * Verifies that two \"equal\" module descriptors which only differ in the order of\n+     * {@link ModuleDescriptor.Requires.Modifier requires modifiers}, that were used to construct the\n+     * descriptors, have the same hashcode.\n+     *\/\n+    @Test\n+    public void testRequiresModifiersOrdering() throws Exception {\n+        \/\/ important to use Set.of() (i.e. backed by immutable set) to reproduce the issue\n+        final Set<Requires.Modifier> mods1 = Set.of(Requires.Modifier.SYNTHETIC, Requires.Modifier.MANDATED);\n+        final ModuleDescriptor desc1 = createModuleDescriptor(null, mods1, null);\n+\n+        \/\/ create the same module descriptor again and this time just change the order of the\n+        \/\/ \"exports\" modifiers' Set.\n+\n+        \/\/ important to use Set.of() (i.e. backed by immutable set) to reproduce the issue\n+        final Set<Requires.Modifier> mods2 = Set.of(Requires.Modifier.MANDATED, Requires.Modifier.SYNTHETIC);\n+        final ModuleDescriptor desc2 = createModuleDescriptor(null, mods2, null);\n+\n+        \/\/ basic verification of the modifiers themselves before we check the module descriptors\n+        assertEquals(mods1, mods2, \"Modifiers were expected to be equal\");\n+\n+        \/\/ now verify the module descriptors\n+        assertEquals(desc1, desc2, \"Module descriptors were expected to be equal\");\n+        assertEquals(desc1.compareTo(desc2), 0, \"compareTo was expected to return\" +\n+                \" 0 for module descriptors that are equal\");\n+        System.out.println(desc1 + \" hashcode = \" + desc1.hashCode());\n+        System.out.println(desc2 + \" hashcode = \" + desc2.hashCode());\n+        assertEquals(desc1.hashCode(), desc2.hashCode(), \"Module descriptor hashcodes\" +\n+                \" were expected to be equal\");\n+    }\n+\n@@ -76,0 +171,19 @@\n+\n+    \/\/ creates a module descriptor with passed (optional) opens\/exports\/requires modifiers\n+    private static ModuleDescriptor createModuleDescriptor(\n+            Set<Opens.Modifier> opensModifiers,\n+            Set<Requires.Modifier> reqsModifiers,\n+            Set<Exports.Modifier> expsModifiers) {\n+\n+        final ModuleDescriptor.Builder builder = ModuleDescriptor.newModule(\"foobar\");\n+        if (opensModifiers != null) {\n+            builder.opens(opensModifiers, \"a.p1\", Set.of(\"a.m1\"));\n+        }\n+        if (reqsModifiers != null) {\n+            builder.requires(reqsModifiers, \"a.m2\");\n+        }\n+        if (expsModifiers != null) {\n+            builder.exports(expsModifiers, \"a.b.c\", Set.of(\"a.m3\"));\n+        }\n+        return builder.build();\n+    }\n","filename":"test\/jdk\/java\/lang\/module\/ModuleDescriptorHashCodeTest.java","additions":119,"deletions":5,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8266670\n+ * @bug 8266670 8291734\n@@ -49,5 +49,0 @@\n- *\n- * For a class, the VM must treat the class as if the ACC_SUPER bit\n- * were set, but that bit is cleared by HotSpot when it is passed out\n- * to the core reflection libraries. Therefore, this test does not\n- * attempt to check whether or not AccessFlag.SUPER is set.\n@@ -55,1 +50,1 @@\n-@ExpectedClassFlags(\"[PUBLIC, FINAL]\")\n+@ExpectedClassFlags(\"[PUBLIC, FINAL, SUPER]\")\n@@ -58,1 +53,1 @@\n-        \/\/ Top-level and axuillary classes; i.e. non-inner classes\n+        \/\/ Top-level and auxiliary classes; i.e. non-inner classes\n@@ -229,1 +224,1 @@\n-@ExpectedClassFlags(\"[FINAL, ENUM]\")\n+@ExpectedClassFlags(\"[FINAL, SUPER, ENUM]\")\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/ClassAccessFlagTest.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * Additionall, the access flags enum and synthetic cannot be\n+ * Additionally, the access flags enum and synthetic cannot be\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/FieldAccessFlagTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,272 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8289106\n+ * @summary Tests of AccessFlag.locations(ClassFileFormatVersion)\n+ *\/\n+\n+import java.lang.reflect.AccessFlag;\n+import static java.lang.reflect.AccessFlag.*;\n+import java.lang.reflect.ClassFileFormatVersion;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+\/*\n+ * There are several patterns of access flag applicability. First, an\n+ * access flag can be applied to the same set of locations for each\n+ * class file format version. This is \"invariant\" usage. Second, an\n+ * access flag can be defined for version N, therefore inapplicable\n+ * for earlier versions, and then applied to the same locations for\n+ * all subsequent versions. This is \"step\" usage. Finally, an access\n+ * flag to have a more complicated pattern, having multiple steps of\n+ * being allowed at more locations or even having locations removed if\n+ * the access flag is retired.\n+ *\n+ * List of access flags and how they are tested:\n+ *\n+ * PUBLIC       step\n+ * PRIVATE      step\n+ * PROTECTED    step\n+ * STATIC       step\n+ * FINAL        two-step\n+ * SUPER        invariant\n+ * OPEN         step\n+ * TRANSITIVE   step\n+ * SYNCHRONIZED invariant\n+ * STATIC_PHASE step\n+ * VOLATILE     invariant\n+ * BRIDGE       step\n+ * TRANSIENT    invariant\n+ * VARARGS      step\n+ * NATIVE       invariant\n+ * INTERFACE    step\n+ * ABSTRACT     step\n+ * STRICT       other\n+ * SYNTHETIC    other (three-step)\n+ * ANNOTATION   step\n+ * ENUM         step\n+ * MANDATED     two-step\n+ * MODULE       step\n+ *\/\n+\n+public class VersionedLocationsTest {\n+    public static void main(String... args) throws Exception {\n+        testInvariantAccessFlags();\n+        testStepFunctionAccessFlags();\n+        testTwoStepAccessFlags();\n+        testSynthetic();\n+        testStrict();\n+    }\n+\n+    \/**\n+     * Invariant access flags have the same set of locations for each\n+     * class file format version.\n+     *\/\n+    private static void testInvariantAccessFlags() {\n+        Set<AccessFlag> invariantAccessFlags =\n+            Set.of(SUPER, SYNCHRONIZED, VOLATILE, TRANSIENT, NATIVE);\n+        for(var accessFlag : invariantAccessFlags) {\n+            Set<AccessFlag.Location> expected = accessFlag.locations();\n+\n+            for(var cffv : ClassFileFormatVersion.values()) {\n+                compareLocations(accessFlag.locations(), accessFlag, cffv);\n+            }\n+        }\n+    }\n+\n+    private static void testStepFunctionAccessFlags() {\n+        StepFunctionTC[] testCases = {\n+            new StepFunctionTC(PUBLIC,\n+                               removeInnerClass(PUBLIC.locations()),\n+                               ClassFileFormatVersion.RELEASE_1),\n+\n+            new StepFunctionTC(PRIVATE,\n+                               removeInnerClass(PRIVATE.locations()),\n+                               ClassFileFormatVersion.RELEASE_1),\n+\n+            new StepFunctionTC(PROTECTED,\n+                               removeInnerClass(PROTECTED.locations()),\n+                               ClassFileFormatVersion.RELEASE_1),\n+\n+            new StepFunctionTC(STATIC,\n+                               removeInnerClass(STATIC.locations()),\n+                               ClassFileFormatVersion.RELEASE_1),\n+\n+            new StepFunctionTC(OPEN,\n+                               Set.of(),\n+                               ClassFileFormatVersion.RELEASE_9),\n+\n+            new StepFunctionTC(TRANSITIVE,\n+                               Set.of(),\n+                               ClassFileFormatVersion.RELEASE_9),\n+\n+            new StepFunctionTC(STATIC_PHASE,\n+                               Set.of(),\n+                               ClassFileFormatVersion.RELEASE_9),\n+\n+            new StepFunctionTC(BRIDGE,\n+                               Set.of(),\n+                               ClassFileFormatVersion.RELEASE_5),\n+\n+            new StepFunctionTC(VARARGS,\n+                               Set.of(),\n+                               ClassFileFormatVersion.RELEASE_5),\n+\n+            new StepFunctionTC(INTERFACE,\n+                               removeInnerClass(INTERFACE.locations()),\n+                               ClassFileFormatVersion.RELEASE_1),\n+\n+            new StepFunctionTC(ABSTRACT,\n+                               removeInnerClass(ABSTRACT.locations()),\n+                               ClassFileFormatVersion.RELEASE_1),\n+\n+            new StepFunctionTC(ANNOTATION,\n+                               Set.of(),\n+                               ClassFileFormatVersion.RELEASE_5),\n+\n+            new StepFunctionTC(ENUM,\n+                               Set.of(),\n+                               ClassFileFormatVersion.RELEASE_5),\n+\n+            new StepFunctionTC(MODULE,\n+                               Set.of(),\n+                               ClassFileFormatVersion.RELEASE_9)\n+        };\n+\n+        for (var testCase : testCases) {\n+            for (var cffv : ClassFileFormatVersion.values()) {\n+                compareLocations(cffv.compareTo(testCase.transition()) >= 0 ?\n+                                 testCase.finalLocs() :\n+                                 testCase.initialLocs(),\n+                                 testCase.accessFlag, cffv);\n+            }\n+        }\n+    }\n+\n+    private static void compareLocations(Set<AccessFlag.Location> expected,\n+                                         AccessFlag accessFlag,\n+                                         ClassFileFormatVersion cffv) {\n+        var actual = accessFlag.locations(cffv);\n+        if (!expected.equals(actual)) {\n+            throw new RuntimeException(\"Unexpected locations for \" +\n+                                       accessFlag  + \" on \" + cffv + \"\\n\" +\n+                                       \"Expected \" + expected + \"; got \\t\" + actual);\n+        }\n+    }\n+\n+    private static Set<AccessFlag.Location> removeInnerClass(Set<AccessFlag.Location> locations) {\n+        var s = new HashSet<>(locations);\n+        s.remove(Location.INNER_CLASS);\n+        return s;\n+    }\n+\n+    private record StepFunctionTC(AccessFlag accessFlag,\n+                                  Set<AccessFlag.Location> initialLocs,\n+                                  ClassFileFormatVersion transition) {\n+\n+        public Set<AccessFlag.Location> finalLocs() {\n+            return accessFlag.locations();\n+        }\n+    }\n+\n+\n+    private record TwoStepFunctionTC(AccessFlag accessFlag,\n+                                     Set<AccessFlag.Location> initialLocs,\n+                                     ClassFileFormatVersion transition1,\n+                                     Set<AccessFlag.Location> firstLocs,\n+                                     ClassFileFormatVersion transition2) {\n+\n+        public Set<AccessFlag.Location> secondLocs() {\n+            return accessFlag.locations();\n+        }\n+    }\n+\n+    private static void testTwoStepAccessFlags() {\n+        TwoStepFunctionTC[] testCases = {\n+            new TwoStepFunctionTC(FINAL,\n+                                  Set.of(Location.CLASS, Location.FIELD, Location.METHOD),\n+                                  ClassFileFormatVersion.RELEASE_1,\n+                                  Set.of(Location.CLASS, Location.FIELD, Location.METHOD, Location.INNER_CLASS),\n+                                  ClassFileFormatVersion.RELEASE_8),\n+\n+            new TwoStepFunctionTC(MANDATED,\n+                                  Set.of(),\n+                                  ClassFileFormatVersion.RELEASE_8,\n+                                  Set.of(Location.METHOD_PARAMETER),\n+                                  ClassFileFormatVersion.RELEASE_9),\n+        };\n+\n+        for (var testCase : testCases) {\n+            for (var cffv : ClassFileFormatVersion.values()) {\n+                var transition1 = testCase.transition1();\n+                var transition2 = testCase.transition2();\n+                Set<AccessFlag.Location> expected;\n+                if (cffv.compareTo(transition1) < 0) {\n+                    expected = testCase.initialLocs();\n+                } else if (cffv.compareTo(transition1) >= 0 &&\n+                           cffv.compareTo(transition2) < 0) {\n+                    expected = testCase.firstLocs();\n+                } else { \/\/ cffv >= transition2\n+                    expected = testCase.secondLocs();\n+                }\n+\n+                compareLocations(expected, testCase.accessFlag(), cffv);\n+            }\n+        }\n+    }\n+\n+    private static void testSynthetic() {\n+        for (var cffv : ClassFileFormatVersion.values()) {\n+            Set<AccessFlag.Location> expected;\n+            if (cffv.compareTo(ClassFileFormatVersion.RELEASE_6) <= 0) {\n+                expected = Set.of();\n+            } else {\n+                expected =\n+                    switch(cffv) {\n+                        case RELEASE_7 -> Set.of(Location.CLASS, Location.FIELD,\n+                                                 Location.METHOD,\n+                                                 Location.INNER_CLASS);\n+                        case RELEASE_8 -> Set.of(Location.CLASS, Location.FIELD,\n+                                                 Location.METHOD,\n+                                                 Location.INNER_CLASS,\n+                                                 Location.METHOD_PARAMETER);\n+                        default        -> SYNTHETIC.locations();\n+                    };\n+            }\n+        compareLocations(expected, SYNTHETIC, cffv);\n+        }\n+    }\n+\n+    private static void testStrict() {\n+        for (var cffv : ClassFileFormatVersion.values()) {\n+            Set<AccessFlag.Location> expected =\n+                (cffv.compareTo(ClassFileFormatVersion.RELEASE_2)  >= 0 &&\n+                 cffv.compareTo(ClassFileFormatVersion.RELEASE_16) <= 0) ?\n+                Set.of(Location.METHOD) :\n+                Set.of();\n+            compareLocations(expected, STRICT, cffv);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/VersionedLocationsTest.java","additions":272,"deletions":0,"binary":false,"changes":272,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 4313887 6866397 8073445\n+ * @bug 4313887 6866397 8073445 8290047\n@@ -87,0 +87,1 @@\n+        assertMatch(\"\", \"\");\n@@ -140,0 +141,7 @@\n+        try {\n+            FileSystems.getDefault().getPathMatcher(\":glob\");\n+            System.err.println(\"No IllegalArgumentException for \\\":glob\\\"\");\n+            failures++;\n+        } catch (IllegalArgumentException iae) {\n+            System.out.println(\"IllegalArgumentException for \\\":glob\\\" OKAY\");\n+        }\n","filename":"test\/jdk\/java\/nio\/file\/PathMatcher\/Basic.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 8011536\n+ * @bug 8011536 8151430\n@@ -28,1 +28,3 @@\n- * @library ..\/..\n+ * @library  ..\/.. \/test\/lib\n+ * @build jdk.test.lib.Platform\n+ * @run main CreationTime\n@@ -37,0 +39,2 @@\n+import jdk.test.lib.Platform;\n+\n@@ -75,4 +79,7 @@\n-        String os = System.getProperty(\"os.name\");\n-        if (os.contains(\"OS X\") && Files.getFileStore(file).type().equals(\"hfs\")) {\n-            supportsCreationTimeRead = true;\n-        } else if (os.startsWith(\"Windows\")) {\n+        if (Platform.isOSX()) {\n+            String type = Files.getFileStore(file).type();\n+            if (type.equals(\"apfs\") || type.equals(\"hfs\")) {\n+                supportsCreationTimeRead = true;\n+                supportsCreationTimeWrite = true;\n+            }\n+        } else if (Platform.isWindows()) {\n","filename":"test\/jdk\/java\/nio\/file\/attribute\/BasicFileAttributeView\/CreationTime.java","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.security.DigestInputStream;\n+import java.security.MessageDigest;\n+\n+\/**\n+ * @test\n+ * @bug 6587699\n+ * @summary Document DigestInputStream behavior when skip() or mark() \/ reset() is used\n+ * @library \/test\/lib\n+ *\/\n+\n+public class TestSkipAndReset {\n+    public static void main(String[] args) throws Exception {\n+        byte[] data = \"1234567890\".getBytes(StandardCharsets.UTF_8);\n+        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n+        DigestInputStream dis = new DigestInputStream(new ByteArrayInputStream(data), md);\n+\n+        dis.read(); \/\/ read 1\n+        dis.read(new byte[2], 0, 1); \/\/ read 2\n+        dis.skip(3); \/\/ skip 3 4 5\n+        dis.mark(10); \/\/ remember 5\n+        dis.read(new byte[2]); \/\/ read 6 7\n+        dis.skip(1); \/\/ skip 8\n+        dis.read(); \/\/ read 9\n+        dis.reset(); \/\/ back to 5\n+        dis.readNBytes(3); \/\/ read 6 7 8\n+        dis.reset(); \/\/ back to 5\n+        dis.skip(2); \/\/ skip 6 7\n+        dis.readAllBytes(); \/\/ read 8 9 0\n+        dis.reset(); \/\/ back to 5\n+        dis.skip(3); \/\/ skip 6 7 8\n+        dis.transferTo(new ByteArrayOutputStream()); \/\/ read 9 0\n+\n+        byte[] hash = md.digest();\n+        byte[] directHash = md.digest(\"1267967889090\".getBytes(StandardCharsets.UTF_8));\n+\n+        Asserts.assertTrue(MessageDigest.isEqual(hash, directHash));\n+    }\n+}\n","filename":"test\/jdk\/java\/security\/DigestInputStream\/TestSkipAndReset.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.*;\n+\n+import java.security.Security;\n+import java.util.Arrays;\n+import java.util.Optional;\n+\n+\/*\n+ * @test\n+ * @summary Throw error if default java.security file is missing\n+ * @bug 8155246\n+ * @library \/test\/lib\n+ * @run main ConfigFileTest\n+ *\/\n+public class ConfigFileTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        Path copyJdkDir = Path.of(\".\/jdk-8155246-tmpdir\");\n+        Path copiedJava = Optional.of(\n+                        Path.of(copyJdkDir.toString(), \"bin\", \"java\"))\n+                .orElseThrow(() -> new RuntimeException(\"Unable to locate new JDK\")\n+                );\n+\n+        if (args.length == 1) {\n+            \/\/ set up is complete. Run code to exercise loading of java.security\n+            System.out.println(Arrays.toString(Security.getProviders()));\n+        } else {\n+            Files.createDirectory(copyJdkDir);\n+            Path jdkTestDir = Path.of(Optional.of(System.getProperty(\"test.jdk\"))\n+                            .orElseThrow(() -> new RuntimeException(\"Couldn't load JDK Test Dir\"))\n+            );\n+\n+            copyJDKMinusJavaSecurity(jdkTestDir, copyJdkDir);\n+            String extraPropsFile = Path.of(System.getProperty(\"test.src\"), \"override.props\").toString();\n+\n+            \/\/ exercise some debug flags while we're here\n+            \/\/ launch JDK without java.security file being present or specified\n+            exerciseSecurity(copiedJava.toString(), \"-cp\", System.getProperty(\"test.classes\"),\n+                    \"-Djava.security.debug=all\", \"-Djavax.net.debug=all\", \"ConfigFileTest\", \"runner\");\n+\n+            \/\/ test the override functionality also. Should not be allowed since\n+            \/\/ \"security.overridePropertiesFile=true\" Security property is missing.\n+            exerciseSecurity(copiedJava.toString(), \"-cp\", System.getProperty(\"test.classes\"),\n+                    \"-Djava.security.debug=all\", \"-Djavax.net.debug=all\",\n+                    \"-Djava.security.properties==file:\/\/\" + extraPropsFile, \"ConfigFileTest\", \"runner\");\n+        }\n+    }\n+\n+    private static void exerciseSecurity(String... args) throws Exception {\n+        ProcessBuilder process = new ProcessBuilder(args);\n+        OutputAnalyzer oa = ProcessTools.executeProcess(process);\n+        oa.shouldHaveExitValue(1).shouldContain(\"java.security file missing\");\n+    }\n+\n+    private static void copyJDKMinusJavaSecurity(Path src, Path dst) throws Exception {\n+        Files.walk(src)\n+            .skip(1)\n+            .filter(p -> !p.toString().endsWith(\"java.security\"))\n+            .forEach(file -> {\n+                try {\n+                    Files.copy(file, dst.resolve(src.relativize(file)), StandardCopyOption.COPY_ATTRIBUTES);\n+                } catch (IOException ioe) {\n+                    throw new UncheckedIOException(ioe);\n+                }\n+            });\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/security\/Security\/ConfigFileTest.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+security.provider.1=sun.security.provider.Sun\n+security.provider.2=sun.security.rsa.SunRsaSign\n+security.provider.3=sun.security.ssl.SunJSSE\n+security.provider.4=com.sun.crypto.provider.SunJCE\n+security.provider.5=sun.security.jgss.SunProvider\n+security.provider.6=com.sun.security.sasl.Provider\n+\n","filename":"test\/jdk\/java\/security\/Security\/override.props","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.reflect.Field;\n@@ -47,0 +46,1 @@\n+import java.util.function.IntFunction;\n@@ -51,0 +51,1 @@\n+import static org.testng.Assert.assertThrows;\n@@ -429,0 +430,23 @@\n+    @DataProvider(name = \"negativeNumMappings\")\n+    public Iterator<Object[]> negativeNumMappings() {\n+        final List<Object[]> methods = new ArrayList<>();\n+        methods.add(new Object[] {(IntFunction<?>) HashMap::newHashMap, \"HashMap::newHashMap\"});\n+        methods.add(new Object[] {(IntFunction<?>) LinkedHashMap::newLinkedHashMap,\n+                \"LinkedHashMap::newLinkedHashMap\"});\n+        methods.add(new Object[] {(IntFunction<?>) WeakHashMap::newWeakHashMap,\n+                \"WeakHashMap::newWeakHashMap\"});\n+        methods.add(new Object[] {(IntFunction<?>) HashSet::newHashSet, \"HashSet::newHashSet\"});\n+        methods.add(new Object[] {(IntFunction<?>) LinkedHashSet::newLinkedHashSet,\n+                \"LinkedHashSet::newLinkedHashSet\"});\n+        return methods.iterator();\n+    }\n+\n+    \/**\n+     * Tests that the APIs that take {@code numMappings} or {@code numElements} as a parameter for\n+     * creating the collection instance (for example: {@link HashMap#newHashMap(int)}), throw\n+     * an {@code IllegalArgumentException} when a negative value is passed to them\n+     *\/\n+    @Test(dataProvider = \"negativeNumMappings\")\n+    public void testNegativeNumMappings(final IntFunction<?> method, final String methodName) {\n+        assertThrows(IllegalArgumentException.class, () -> method.apply(-1));\n+    }\n","filename":"test\/jdk\/java\/util\/HashMap\/WhiteBoxResizeTest.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8292327\n+ * @summary Test the case where Inflater.needsInput() is true but the native\n+ *          inflater still has unwritten output in its internal buffer.\n+ *\/\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.zip.Deflater;\n+import java.util.zip.DeflaterInputStream;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+\n+public class UnexpectedEndOfZlibStream {\n+    public static void main(String[] args) throws Exception {\n+        String original = \"Readsuncompresseddataintoanarrayofbytes0123456789Ifcodelenis\" +\n+            \"notzerothemethodwillblockReadsuncompresseddataintoanarrayofbytes123456789\";\n+        byte[] deflated =\n+            new DeflaterInputStream(\n+                new ByteArrayInputStream(original.getBytes(\"US-ASCII\")),\n+                new Deflater(Deflater.DEFAULT_COMPRESSION, \/*nowrap=*\/ true)\n+            ).readAllBytes();\n+\n+        \/\/ using readAllBytes succeeds, the underlying gzip data seems to be well-formed\n+        byte[] inflated =\n+            new InflaterInputStream(\n+                new ByteArrayInputStream(deflated),\n+                new Inflater(\/*nowrap=*\/ true)\n+            ).readAllBytes();\n+\n+        if (!original.equals(new String(inflated, \"US-ASCII\"))) {\n+            throw new Exception(\"Inflated output differs from original\");\n+        }\n+\n+        \/\/ a 128 byte read followed by a 512 byte read fails after JDK-8281962\n+        InflaterInputStream is =\n+            new InflaterInputStream(\n+                new ByteArrayInputStream(deflated),\n+                new Inflater(\/*nowrap=*\/ true));\n+        byte[] buf = new byte[512];\n+        int n = is.read(buf, 0, 128);\n+        int pos = n;\n+        while (n > 0) {\n+            if ((n = is.read(buf, pos, 1)) > 0) { \/\/ Unexpected end of ZLIB input stream\n+                pos+= n;\n+            }\n+        }\n+        if (!original.equals(new String(buf, 0, pos, \"US-ASCII\"))) {\n+            throw new Exception(\"Inflated output differs from original\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/InflaterInputStream\/UnexpectedEndOfZlibStream.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -41,0 +41,1 @@\n+import java.nio.ByteBuffer;\n@@ -96,1 +97,1 @@\n-        handshaking(ssle, sc, null);\n+        ByteBuffer peerNetData = handshaking(ssle, sc, null);\n@@ -99,1 +100,1 @@\n-        receive(ssle, sc);\n+        receive(ssle, sc, peerNetData);\n@@ -139,1 +140,1 @@\n-        handshaking(ssle, sc, null);\n+        ByteBuffer peerNetData = handshaking(ssle, sc, null);\n@@ -145,1 +146,1 @@\n-        receive(ssle, sc);\n+        receive(ssle, sc, peerNetData);\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLEngine\/LargePacket.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-        \/\/ create buufer.\n+        \/\/ create buffer.\n@@ -131,1 +131,1 @@\n-                    System.out.println(\"resize destination buffer upto \" +\n+                    System.out.println(\"send: resize destination buffer upto \" +\n@@ -146,2 +146,2 @@\n-    protected static void receive(SSLEngine ssle, SocketChannel sc)\n-        throws Exception {\n+    protected static void receive(SSLEngine ssle, SocketChannel sc,\n+            ByteBuffer peerNetData) throws Exception {\n@@ -149,1 +149,1 @@\n-        \/\/ create buufers.\n+        \/\/ create buffer.\n@@ -151,1 +151,0 @@\n-        int netBufferMax = ssle.getSession().getPacketBufferSize();\n@@ -153,1 +152,1 @@\n-        \/\/ allocate less in order to check BUFFER_OVERFLOW\/BUFFER_UNDERFLOW\n+        \/\/ allocate less in order to check BUFFER_OVERFLOW\n@@ -155,1 +154,0 @@\n-        ByteBuffer peerNetData = ByteBuffer.allocate(netBufferMax\/2);\n@@ -192,2 +190,2 @@\n-                System.out.println(\"\\tcomsumed \" + res.bytesConsumed() +\n-                        \" byes network data\");\n+                System.out.println(\"\\tconsumed \" + res.bytesConsumed() +\n+                        \" bytes network data\");\n@@ -212,1 +210,1 @@\n-                    System.out.println(\"resize destination buffer upto \" +\n+                    System.out.println(\"recv: resize destination buffer upto \" +\n@@ -222,2 +220,2 @@\n-                    System.out.println(\"resize source buffer upto \" + size +\n-                        \" bytes for BUFFER_UNDERFLOW\");\n+                    System.out.println(\"recv: resize source buffer upto \" +\n+                        size + \" bytes for BUFFER_UNDERFLOW\");\n@@ -237,1 +235,1 @@\n-    protected static void handshaking(SSLEngine ssle, SocketChannel sc,\n+    protected static ByteBuffer handshaking(SSLEngine ssle, SocketChannel sc,\n@@ -243,0 +241,3 @@\n+        \/\/ zero-byte app buffers - we do not want to exchange app data here\n+        ByteBuffer localAppData = ByteBuffer.allocate(0);\n+        ByteBuffer peerAppData = ByteBuffer.allocate(0);\n@@ -244,2 +245,0 @@\n-        ByteBuffer localAppData = ByteBuffer.allocate(appBufferMax\/10);\n-        ByteBuffer peerAppData = ByteBuffer.allocate(appBufferMax\/10);\n@@ -275,1 +274,1 @@\n-                            return;\n+                            throw new EOFException();\n@@ -283,1 +282,1 @@\n-                        return;\n+                        throw new EOFException();\n@@ -301,1 +300,1 @@\n-                        System.out.println(\"resize source buffer upto \" +\n+                        System.out.println(\"hs recv: resize source buffer upto \" +\n@@ -312,1 +311,1 @@\n-                        System.out.println(\"resize destination buffer upto \" +\n+                        System.out.println(\"hs recv: resize destination buffer upto \" +\n@@ -349,1 +348,1 @@\n-                        System.out.println(\"resize destination buffer upto \" +\n+                        System.out.println(\"hs send: resize destination buffer upto \" +\n@@ -374,0 +373,1 @@\n+        return peerNetData;\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLEngine\/SSLEngineService.java","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-        handshaking(ssle, sc, buffer);\n+        ByteBuffer peerNetData = handshaking(ssle, sc, buffer);\n@@ -151,1 +151,1 @@\n-        receive(ssle, sc);\n+        receive(ssle, sc, peerNetData);\n@@ -198,1 +198,1 @@\n-        handshaking(ssle, sc, null);\n+        ByteBuffer peerNetData = handshaking(ssle, sc, null);\n@@ -204,1 +204,1 @@\n-        receive(ssle, sc);\n+        receive(ssle, sc, peerNetData);\n","filename":"test\/jdk\/javax\/net\/ssl\/ServerName\/SSLEngineExplorer.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-        handshaking(ssle, sc, buffer);\n+        ByteBuffer peerNetData = handshaking(ssle, sc, buffer);\n@@ -160,1 +160,1 @@\n-        receive(ssle, sc);\n+        receive(ssle, sc, peerNetData);\n@@ -212,1 +212,1 @@\n-        handshaking(ssle, sc, null);\n+        ByteBuffer peerNetData = handshaking(ssle, sc, null);\n@@ -218,1 +218,1 @@\n-        receive(ssle, sc);\n+        receive(ssle, sc, peerNetData);\n","filename":"test\/jdk\/javax\/net\/ssl\/ServerName\/SSLEngineExplorerMatchedSNI.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-            handshaking(ssle, sc, buffer);\n+            ByteBuffer peerNetData = handshaking(ssle, sc, buffer);\n@@ -154,1 +154,1 @@\n-            receive(ssle, sc);\n+            receive(ssle, sc, peerNetData);\n@@ -216,1 +216,1 @@\n-            handshaking(ssle, sc, null);\n+            ByteBuffer peerNetData = handshaking(ssle, sc, null);\n@@ -222,1 +222,1 @@\n-            receive(ssle, sc);\n+            receive(ssle, sc, peerNetData);\n","filename":"test\/jdk\/javax\/net\/ssl\/ServerName\/SSLEngineExplorerUnmatchedSNI.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -139,1 +139,1 @@\n-        handshaking(ssle, sc, buffer);\n+        ByteBuffer peerNetData = handshaking(ssle, sc, buffer);\n@@ -142,1 +142,1 @@\n-        receive(ssle, sc);\n+        receive(ssle, sc, peerNetData);\n@@ -193,1 +193,1 @@\n-        handshaking(ssle, sc, null);\n+        ByteBuffer peerNetData = handshaking(ssle, sc, null);\n@@ -199,1 +199,1 @@\n-        receive(ssle, sc);\n+        receive(ssle, sc, peerNetData);\n","filename":"test\/jdk\/javax\/net\/ssl\/ServerName\/SSLEngineExplorerWithCli.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-        handshaking(ssle, sc, buffer);\n+        ByteBuffer peerNetData = handshaking(ssle, sc, buffer);\n@@ -151,1 +151,1 @@\n-        receive(ssle, sc);\n+        receive(ssle, sc, peerNetData);\n@@ -196,1 +196,1 @@\n-        handshaking(ssle, sc, null);\n+        ByteBuffer peerNetData = handshaking(ssle, sc, null);\n@@ -202,1 +202,1 @@\n-        receive(ssle, sc);\n+        receive(ssle, sc, peerNetData);\n","filename":"test\/jdk\/javax\/net\/ssl\/ServerName\/SSLEngineExplorerWithSrv.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"filename":"test\/jdk\/javax\/swing\/AbstractButton\/5049549\/DE1.gif","binary":true,"status":"added"},{"filename":"test\/jdk\/javax\/swing\/AbstractButton\/5049549\/DI1.gif","binary":true,"status":"added"},{"filename":"test\/jdk\/javax\/swing\/AbstractButton\/5049549\/DS1.gif","binary":true,"status":"added"},{"filename":"test\/jdk\/javax\/swing\/AbstractButton\/5049549\/PR1.gif","binary":true,"status":"added"},{"filename":"test\/jdk\/javax\/swing\/AbstractButton\/5049549\/RO1.gif","binary":true,"status":"added"},{"filename":"test\/jdk\/javax\/swing\/AbstractButton\/5049549\/RS1.gif","binary":true,"status":"added"},{"filename":"test\/jdk\/javax\/swing\/AbstractButton\/5049549\/SE1.gif","binary":true,"status":"added"},{"patch":"@@ -0,0 +1,234 @@\n+\/*\n+ * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+   @bug 5049549 7132413\n+   @summary Tests that the proper icon is used for different states.\n+   @library ..\/..\/regtesthelpers\n+   @build Blocker\n+   @run main\/manual bug5049549\n+*\/\n+\n+import javax.swing.BoxLayout;\n+import javax.swing.Icon;\n+import javax.swing.ImageIcon;\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+import javax.swing.JLabel;\n+import javax.swing.JPanel;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+\n+public class bug5049549 {\n+\n+    private static ImageIcon DE = new ImageIcon(bug5049549.class.getResource(\"DE1.GIF\"));\n+    private static ImageIcon DI = new ImageIcon(bug5049549.class.getResource(\"DI1.GIF\"));\n+    private static ImageIcon DS = new ImageIcon(bug5049549.class.getResource(\"DS1.GIF\"));\n+    private static ImageIcon RO = new ImageIcon(bug5049549.class.getResource(\"RO1.GIF\"));\n+    private static ImageIcon RS = new ImageIcon(bug5049549.class.getResource(\"RS1.GIF\"));\n+    private static ImageIcon SE = new ImageIcon(bug5049549.class.getResource(\"SE1.GIF\"));\n+    private static ImageIcon PR = new ImageIcon(bug5049549.class.getResource(\"PR1.GIF\"));\n+\n+    private static Blocker blocker = new Blocker();\n+\n+    private static class KButton extends JButton {\n+\n+            KButton(String ex) {\n+                super(ex);\n+            }\n+\n+            private Icon disabledIcon;\n+            private Icon disabledSelectedIcon;\n+\n+            public Icon getDisabledIcon() {\n+                return disabledIcon;\n+            }\n+\n+            public Icon getDisabledSelectedIcon() {\n+                return disabledSelectedIcon;\n+            }\n+\n+            public void setDisabledIcon(Icon icon) {\n+                disabledIcon = icon;\n+            }\n+\n+            public void setDisabledSelectedIcon(Icon icon) {\n+                disabledSelectedIcon = icon;\n+            }\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        SwingUtilities.invokeLater(new Runnable() {\n+            public void run() {\n+                UIManager.put(\"swing.boldMetal\", Boolean.FALSE);\n+                runTest();\n+            }\n+        });\n+\n+        blocker.blockTillDone();\n+    }\n+\n+    private static void runTest() {\n+        JFrame frame = blocker.createFrameWithPassFailButtons(\"Wrong icon is used.\");\n+\n+        JPanel panel = new JPanel();\n+        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));\n+\n+        JLabel label = new JLabel(\"The following disabled buttons should have white icons\");\n+        panel.add(label);\n+        label = new JLabel(\"with red text that matches the button text.\");\n+        panel.add(label);\n+\n+        KButton button;\n+\n+        \/* disabled: default icon *\/\n+        button = new KButton(\"DE\");\n+        button.setEnabled(false);\n+        button.setIcon(DE);\n+        panel.add(button);\n+\n+        \/* disabled-selected: default icon *\/\n+        button = new KButton(\"DE\");\n+        button.setEnabled(false);\n+        button.setSelected(true);\n+        button.setIcon(DE);\n+        panel.add(button);\n+\n+        \/* disabled: default and disabled icons *\/\n+        button = new KButton(\"DI\");\n+        button.setEnabled(false);\n+        button.setIcon(DE);\n+        button.setDisabledIcon(DI);\n+        panel.add(button);\n+\n+        \/* disabled-selected: default and disabled icons *\/\n+        button = new KButton(\"DI\");\n+        button.setEnabled(false);\n+        button.setSelected(true);\n+        button.setIcon(DE);\n+        button.setDisabledIcon(DI);\n+        panel.add(button);\n+\n+        \/* disabled-selected: default, selected and disabled icons *\/\n+        button = new KButton(\"SE\");\n+        button.setEnabled(false);\n+        button.setSelected(true);\n+        button.setIcon(DE);\n+        button.setSelectedIcon(SE);\n+        button.setDisabledIcon(DI);\n+        panel.add(button);\n+\n+        \/* disabled-selected: default, disabled-selected, selected and disabled icons *\/\n+        button = new KButton(\"DS\");\n+        button.setEnabled(false);\n+        button.setSelected(true);\n+        button.setIcon(DE);\n+        button.setSelectedIcon(SE);\n+        button.setDisabledIcon(DI);\n+        button.setDisabledSelectedIcon(DS);\n+        panel.add(button);\n+\n+        label = new JLabel(\"The following buttons have a white icon with red text,\");\n+        panel.add(label);\n+        label = new JLabel(\"and a triplet of strings separated by commas. The first\");\n+        panel.add(label);\n+        label = new JLabel(\"string says what the icon text should show in the normal\");\n+        panel.add(label);\n+        label = new JLabel(\"state. The second the rollover state. And the third shows\");\n+        panel.add(label);\n+        label = new JLabel(\"what it should show when pressed. Verify each of these\");\n+        panel.add(label);\n+        label = new JLabel(\"states for each button.\");\n+        panel.add(label);\n+\n+        \/* normal: default, rollover icons *\/\n+        button = new KButton(\"DE, RO, DE\");\n+        button.setIcon(DE);\n+        button.setRolloverIcon(RO);\n+        panel.add(button);\n+\n+        \/* normal: default, rollover, pressed icons *\/\n+        button = new KButton(\"DE, RO, PR\");\n+        button.setIcon(DE);\n+        button.setRolloverIcon(RO);\n+        button.setPressedIcon(PR);\n+        panel.add(button);\n+\n+        \/* selected: default, rollover, pressed icons *\/\n+        button = new KButton(\"DE, RO, PR\");\n+        button.setSelected(true);\n+        button.setIcon(DE);\n+        button.setRolloverIcon(RO);\n+        button.setPressedIcon(PR);\n+        panel.add(button);\n+\n+        \/* selected: default, rollover, pressed icons *\/\n+        button = new KButton(\"DE, DE, PR\");\n+        button.setSelected(true);\n+        button.setIcon(DE);\n+        button.setPressedIcon(PR);\n+        panel.add(button);\n+\n+        \/* selected: default, selected, rollover, pressed icons *\/\n+        button = new KButton(\"SE, SE, PR\");\n+        button.setSelected(true);\n+        button.setIcon(DE);\n+        button.setSelectedIcon(SE);\n+        button.setRolloverIcon(RO);\n+        button.setPressedIcon(PR);\n+        panel.add(button);\n+\n+        \/* selected: default, selected, rollover, rollover-selected, pressed icons *\/\n+        button = new KButton(\"SE, RS, PR\");\n+        button.setSelected(true);\n+        button.setIcon(DE);\n+        button.setRolloverSelectedIcon(RS);\n+        button.setSelectedIcon(SE);\n+        button.setRolloverIcon(RO);\n+        button.setPressedIcon(PR);\n+        panel.add(button);\n+\n+        \/* selected: default, selected, rollover, rollover-selected icons *\/\n+        button = new KButton(\"SE, RS, SE\");\n+        button.setSelected(true);\n+        button.setIcon(DE);\n+        button.setRolloverSelectedIcon(RS);\n+        button.setSelectedIcon(SE);\n+        button.setRolloverIcon(RO);\n+        panel.add(button);\n+\n+        \/* selected: default, selected icons *\/\n+        button = new KButton(\"SE, SE, SE\");\n+        button.setSelected(true);\n+        button.setIcon(DE);\n+        button.setSelectedIcon(SE);\n+        button.setRolloverIcon(RO);\n+        panel.add(button);\n+\n+        frame.add(panel);\n+\n+        frame.pack();\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/AbstractButton\/5049549\/bug5049549.java","additions":234,"deletions":0,"binary":false,"changes":234,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Font;\n+import javax.swing.DebugGraphics;\n+\n+\/* @test\n+ * @bug 6521141\n+ * @summary Test to check if NPE does not occur when graphics is not\n+ *  initialized and DebugGraphics instance is created with default\n+ *  Constructor and used.\n+ * @run main DebugGraphicsNPETest\n+ *\/\n+public class DebugGraphicsNPETest {\n+    public static void main(String[] args) throws Exception {\n+        DebugGraphics dg = new DebugGraphics();\n+        Font font = new Font(Font.SERIF, Font.PLAIN, 10);\n+        dg.setFont(font);\n+        System.out.println(\"Test Pass!\");\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/DebugGraphics\/DebugGraphicsNPETest.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.io.File;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Arrays;\n+\n+import javax.swing.JCheckBox;\n+import javax.swing.JFileChooser;\n+import javax.swing.JFrame;\n+import javax.swing.JPanel;\n+import javax.swing.JTextArea;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+import javax.swing.WindowConstants;\n+\n+\/*\n+ * @test\n+ * @bug 8281966\n+ * @key headful\n+ * @requires (os.family == \"windows\")\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @summary Test to check if the absolute path of Symbolic Link folder\n+ *          is valid on ValueChanged property listener.\n+ * @run main\/manual FileChooserSymLinkTest\n+ *\/\n+public class FileChooserSymLinkTest {\n+    static JFrame frame;\n+    static JFileChooser jfc;\n+    static JPanel panel;\n+    static JTextArea pathList;\n+    static JCheckBox multiSelection;\n+    static PassFailJFrame passFailJFrame;\n+\n+    public static void main(String[] args) throws Exception {\n+        SwingUtilities.invokeAndWait(new Runnable() {\n+            public void run() {\n+                try {\n+                    initialize();\n+                } catch (InterruptedException | InvocationTargetException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        });\n+        passFailJFrame.awaitAndCheck();\n+    }\n+\n+    static void initialize() throws InterruptedException, InvocationTargetException {\n+        \/\/Initialize the components\n+        final String INSTRUCTIONS = \"\"\"\n+                Instructions to Test:\n+                1. Open an elevated Command Prompt.\n+                2. Paste the following commands:\n+                cd \/d C:\\\\\n+                mkdir FileChooserTest\n+                cd FileChooserTest\n+                mkdir target\n+                mklink \/d link target\n+\n+                3. Navigate to C:\\\\FileChooserTest in the JFileChooser.\n+                4. Use \"Enable Multi-Selection\" checkbox to enable\/disable\n+                   MultiSelection Mode\n+                5. Single-selection:\n+                   Click \"link\" directory, the absolute path of the symbolic\n+                   link should be displayed. If it's null, click FAIL.\n+                   Click \"target\" directory, its absolute path should be\n+                   displayed.\n+\n+                   Enable multiple selection by clicking the checkbox.\n+                   Multi-selection:\n+                   Click \"link\", press Ctrl and then click \"target\".\n+                   Both should be selected and their absolute paths should be\n+                   displayed.\n+\n+                   If \"link\" can't be selected or if its absolute path is null,\n+                   click FAIL.\n+\n+                   If \"link\" can be selected in both single- and multi-selection modes,\n+                   click PASS.\n+                6. When done with testing, paste the following commands to\n+                   remove the 'FileChooserTest' directory:\n+                cd \\\\\n+                rmdir \/s \/q C:\\\\FileChooserTest\n+\n+                or use File Explorer to clean it up.\n+                \"\"\";\n+        frame = new JFrame(\"JFileChooser Symbolic Link test\");\n+        panel = new JPanel(new BorderLayout());\n+        multiSelection = new JCheckBox(\"Enable Multi-Selection\");\n+        pathList = new JTextArea(10, 50);\n+        jfc = new JFileChooser(new File(\"C:\\\\\"));\n+        passFailJFrame = new PassFailJFrame(\"Test Instructions\", INSTRUCTIONS, 5L, 35, 40);\n+\n+        PassFailJFrame.addTestWindow(frame);\n+        PassFailJFrame.positionTestWindow(frame, PassFailJFrame.Position.HORIZONTAL);\n+        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n+        panel.add(multiSelection, BorderLayout.EAST);\n+        panel.add(new JScrollPane(pathList), BorderLayout.WEST);\n+        jfc.setDialogType(JFileChooser.CUSTOM_DIALOG);\n+        jfc.setControlButtonsAreShown(false);\n+        jfc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);\n+        jfc.setMultiSelectionEnabled(multiSelection.isSelected());\n+        pathList.append(\"Path List\\n\");\n+\n+        multiSelection.addActionListener(new ActionListener() {\n+            @Override\n+            public void actionPerformed(ActionEvent e) {\n+                Object source = e.getSource();\n+                jfc.setMultiSelectionEnabled(((JCheckBox)source).isSelected());\n+            }\n+        });\n+        jfc.addPropertyChangeListener(new PropertyChangeListener() {\n+            public void propertyChange(PropertyChangeEvent evt) {\n+                String msg = null;\n+                if (JFileChooser.SELECTED_FILE_CHANGED_PROPERTY.equals(evt.getPropertyName())) {\n+                    msg = \"Absolute Path : \" + evt.getNewValue();\n+                } else if (JFileChooser.SELECTED_FILES_CHANGED_PROPERTY.equals(evt.getPropertyName())) {\n+                    msg = \"Selected Files : \" + Arrays.toString((File[]) evt.getNewValue());\n+                }\n+\n+                if (msg != null) {\n+                    System.out.println(msg);\n+                    pathList.append(msg + \"\\n\");\n+                }\n+            }\n+        });\n+        frame.add(panel, BorderLayout.NORTH);\n+        frame.add(jfc, BorderLayout.CENTER);\n+        frame.pack();\n+        frame.setVisible(true);\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/FileChooserSymLinkTest.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -53,1 +53,1 @@\n- * @bug 4618767\n+ * @bug 4618767 8292062\n@@ -120,2 +120,2 @@\n-                \/\/ For most OSes it's ALT+F; on macOS it's ALT+CNTRL+F except for Nimbus LaF.\n-                if (isMac && !laf.contains(\"Nimbus\")) {\n+                \/\/ For most OSes it's ALT+F; on macOS it's ALT+CNTRL+F.\n+                if (isMac) {\n","filename":"test\/jdk\/javax\/swing\/JList\/4618767\/JListSelectedElementTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n- * @bug 4618767\n+ * @bug 4618767 8292062\n@@ -110,2 +110,2 @@\n-                \/\/ For most OSes it's ALT+F; on macOS it's ALT+CNTRL+F except for Nimbus LaF.\n-                if (isMac && !laf.contains(\"Nimbus\")) {\n+                \/\/ For most OSes it's ALT+F; on macOS it's ALT+CNTRL+F.\n+                if (isMac) {\n","filename":"test\/jdk\/javax\/swing\/JTree\/4618767\/JTreeSelectedElementTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @bug 8194873\n+ * @bug 8194873 8292062\n","filename":"test\/jdk\/javax\/swing\/event\/RightAltKeyTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Blocker can be used to block a thread until another thread\n+ * messages the blocker to stop. This is useful for regression\n+ * tests that use swing, as most of the work for testing a swing component\n+ * is done in the event dispatching thread and the testing harness ends when\n+ * main returns.\n+ * <p>The following shows the typical usable of this class:\n+ * <pre>\n+     public static void main(String[] args) throws Throwable {\n+         ... set up the gui ...\n+         Blocker blocker = new Blocker();\n+         blocker.blockTillDone();\n+     }\n+\n+     public void actionPerformed(ActionEvent ae) {\n+         if (failed) {\n+             blocker.testFailed(new RuntimeException(\"FAILED!\"));\n+         }\n+         else {\n+             blocker.testPassed();\n+         }\n+     }\n+   <\/pre>\n+ * When using jtreg you would include this class via something like:\n+ * <pre>\n+     @library ..\/..\/..\/regtesthelpers\n+     @build Blocker\n+     @run main YourTest\n+   <\/pre>\n+ *\n+ * <p>You can also use the method <code>createFrameWithPassFailButtons<\/code>\n+ * that will create a JFrame containing two buttons (pass and fail), with\n+ * the two buttons wired to pass\/fail the test. Refer to the javadoc for\n+ * more info.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import javax.swing.Box;\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+\n+public class Blocker {\n+    private boolean       done;\n+    private Throwable     error;\n+\n+    \/**\n+     * Call this from the main thread to block the reciever. Then call\n+     * either <code>testPassed<\/code> or <code>testFailed<\/code>, from\n+     * another thread to unblock the receiver. This will only throw an\n+     * exception if <code>testFailed<\/code> is invoked.\n+     *\/\n+    public void blockTillDone() throws Throwable {\n+        synchronized(this) {\n+            while (!done) {\n+                wait();\n+            }\n+        }\n+        if (error != null) {\n+            throw error;\n+        }\n+    }\n+\n+    \/**\n+     * Invoke this to stop the blocker thread.  This does not change the\n+     * status of the test.  This is intended for cases where you don't\n+     * know if you've failed, but want to stop the test.\n+     *\/\n+    public void stopTest() {\n+        synchronized(this) {\n+            done = true;\n+            notifyAll();\n+        }\n+    }\n+\n+    \/**\n+     * Invoke if the test has suceeded. This will notify the main thread\n+     * causing it to stop waiting and continue, which will\n+     * cause the test to finish.\n+     *\/\n+    public void testPassed() {\n+        stopTest(null);\n+    }\n+\n+    \/**\n+     * Invoke if the test has failed. <code>error<\/code> gives the\n+     * exception that will be thrown from the main thread. This will notify\n+     * the main thread causing it to stop waiting and continue, which will\n+     * cause the test to finish. If <code>error<\/code> is null, this has\n+     * The same effect as calling <code>testPassed<\/code>.\n+     *\/\n+    public void testFailed(Throwable error) {\n+        stopTest(error);\n+    }\n+\n+    \/**\n+     * Both <code>testPassed<\/code> and <code>testFailed<\/code> call into\n+     * this. Sets the ivar, <code>done<\/code>, and notifies listeners\n+     * which will unblock the caller of <code>blockTillDone<\/code>.\n+     *\/\n+    protected void stopTest(Throwable error) {\n+        synchronized(this) {\n+            this.error = error;\n+            done = true;\n+            notify();\n+        }\n+    }\n+\n+    \/**\n+     * Creates and returns a JFrame with two button, one that says pass,\n+     * another that says fail. The fail button is wired to call\n+     * <code>uiTestFailed<\/code> with <code>failString<\/code> and the pass\n+     * button is wired to invoked <code>uiTestPassed<\/code>.\n+     * <p>The content pane of the JFrame uses a BorderLayout with the\n+     * buttons inside a horizontal box with filler between them and the\n+     * pass button on the left.\n+     * <p>The returned frame has not been packed, or made visible, it is\n+     * up to the caller to do that (after putting in some useful components).\n+     *\/\n+    public JFrame createFrameWithPassFailButtons(final String failString) {\n+        JFrame         retFrame = new JFrame(\"TEST\");\n+        Box            buttonBox = Box.createHorizontalBox();\n+        JButton        passButton = new JButton(\"Pass\");\n+        JButton        failButton = new JButton(\"Fail\");\n+\n+        passButton.addActionListener(new ActionListener() {\n+            public void actionPerformed(ActionEvent ae) {\n+                uiTestPassed();\n+            }\n+        });\n+        failButton.addActionListener(new ActionListener() {\n+            public void actionPerformed(ActionEvent ae) {\n+                uiTestFailed(failString);\n+            }\n+        });\n+        retFrame.getContentPane().setLayout(new BorderLayout());\n+        buttonBox.add(passButton);\n+        buttonBox.add(Box.createGlue());\n+        buttonBox.add(failButton);\n+        retFrame.getContentPane().add(buttonBox, BorderLayout.SOUTH);\n+        retFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);\n+        return retFrame;\n+    }\n+\n+    \/**\n+     * This is invoked from the pass button. It in turn invokes\n+     * <code>testPassed<\/code>.\n+     *\/\n+    protected void uiTestPassed() {\n+        testPassed();\n+    }\n+\n+    \/**\n+     * This is invoked from the fail button. It in turn invokes\n+     * <code>testFailed<\/code> with a RuntimeException, the contents of\n+     * which are <code>failString<\/code>.\n+     *\/\n+    protected void uiTestFailed(String failString) {\n+        testFailed(new RuntimeException(failString));\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/regtesthelpers\/Blocker.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8141521 8216553 8266291 8290047\n@@ -777,0 +778,14 @@\n+\n+    @DataProvider(name = \"badSyntaxAndPattern\")\n+    private Object[][] badSyntaxAndPattern() {\n+        return new Object[][] {\n+            { \":glob\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"badSyntaxAndPattern\",\n+          expectedExceptions = IllegalArgumentException.class)\n+    public void badSyntaxAndPatternTest(String syntaxAndPattern) {\n+        FileSystem fs = FileSystems.getFileSystem(URI.create(\"jrt:\/\"));\n+        PathMatcher pm = fs.getPathMatcher(syntaxAndPattern);\n+    }\n","filename":"test\/jdk\/jdk\/internal\/jrtfs\/Basic.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n@@ -29,1 +31,3 @@\n-import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n@@ -31,0 +35,6 @@\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n@@ -36,1 +46,1 @@\n- * @modules java.base\/jdk.internal.misc\n+ * @modules java.base\/java.lang:+open java.base\/jdk.internal.misc\n@@ -39,1 +49,1 @@\n- * @run main\/othervm -Djdk.virtualThreadScheduler.parallelism=1 -Djdk.virtualThreadScheduler.maxPoolSize=2 TestTerminatingThreadLocal\n+ * @run testng\/othervm TestTerminatingThreadLocal\n@@ -43,6 +53,5 @@\n-    public static void main(String[] args) {\n-        ttlTestSet(42, 112);\n-        ttlTestSet(null, 112);\n-        ttlTestSet(42, null);\n-\n-        ttlTestVirtual(666, ThreadLocal::get, 666);\n+    @SafeVarargs\n+    static <T> Object[] testCase(T initialValue,\n+                                 Consumer<? super TerminatingThreadLocal<T>> ttlOps,\n+                                 T... expectedTerminatedValues) {\n+        return new Object[] {initialValue, ttlOps, Arrays.asList(expectedTerminatedValues)};\n@@ -51,9 +60,11 @@\n-    static <T> void ttlTestSet(T v0, T v1) {\n-        ttlTestPlatform(v0, ttl -> {                                         }    );\n-        ttlTestPlatform(v0, ttl -> { ttl.get();                              }, v0);\n-        ttlTestPlatform(v0, ttl -> { ttl.get();   ttl.remove();              }    );\n-        ttlTestPlatform(v0, ttl -> { ttl.get();   ttl.set(v1);               }, v1);\n-        ttlTestPlatform(v0, ttl -> { ttl.set(v1);                            }, v1);\n-        ttlTestPlatform(v0, ttl -> { ttl.set(v1); ttl.remove();              }    );\n-        ttlTestPlatform(v0, ttl -> { ttl.set(v1); ttl.remove(); ttl.get();   }, v0);\n-        ttlTestPlatform(v0, ttl -> { ttl.get();   ttl.remove(); ttl.set(v1); }, v1);\n+    static <T> Stream<Object[]> testCases(T v0, T v1) {\n+        return Stream.of(\n+            testCase(v0, ttl -> {                                         }    ),\n+            testCase(v0, ttl -> { ttl.get();                              }, v0),\n+            testCase(v0, ttl -> { ttl.get();   ttl.remove();              }    ),\n+            testCase(v0, ttl -> { ttl.get();   ttl.set(v1);               }, v1),\n+            testCase(v0, ttl -> { ttl.set(v1);                            }, v1),\n+            testCase(v0, ttl -> { ttl.set(v1); ttl.remove();              }    ),\n+            testCase(v0, ttl -> { ttl.set(v1); ttl.remove(); ttl.get();   }, v0),\n+            testCase(v0, ttl -> { ttl.get();   ttl.remove(); ttl.set(v1); }, v1)\n+        );\n@@ -62,0 +73,8 @@\n+    @DataProvider\n+    public Object[][] testCases() {\n+        return Stream.of(\n+            testCases(42, 112),\n+            testCases(null, new Object()),\n+            testCases(\"abc\", null)\n+        ).flatMap(Function.identity()).toArray(Object[][]::new);\n+    }\n@@ -63,2 +82,5 @@\n-    @SafeVarargs\n-    static <T> void ttlTestPlatform(T initialValue,\n+    \/**\n+     * Test TerminatingThreadLocal with a platform thread.\n+     *\/\n+    @Test(dataProvider = \"testCases\")\n+    public <T> void ttlTestPlatform(T initialValue,\n@@ -66,1 +88,1 @@\n-                                    T... expectedTerminatedValues) {\n+                                    List<T> expectedTerminatedValues) throws Exception {\n@@ -83,5 +105,1 @@\n-        try {\n-            thread.join();\n-        } catch (InterruptedException e) {\n-            throw new RuntimeException(e);\n-        }\n+        thread.join();\n@@ -89,5 +107,1 @@\n-        if (!terminatedValues.equals(Arrays.asList(expectedTerminatedValues))) {\n-            throw new AssertionError(\"Expected terminated values: \" +\n-                                     Arrays.toString(expectedTerminatedValues) +\n-                                     \" but got: \" + terminatedValues);\n-        }\n+        assertEquals(terminatedValues, expectedTerminatedValues);\n@@ -96,2 +110,7 @@\n-    @SafeVarargs\n-    static <T> void ttlTestVirtual(T initialValue,\n+    \/**\n+     * Test TerminatingThreadLocal with a virtual thread. The thread local should be\n+     * carrier thread local but accessible to the virtual thread. The threadTerminated\n+     * method should be invoked when the carrier thread terminates.\n+     *\/\n+    @Test(dataProvider = \"testCases\")\n+    public <T> void ttlTestVirtual(T initialValue,\n@@ -99,1 +118,1 @@\n-                                   T... expectedTerminatedValues) {\n+                                   List<T> expectedTerminatedValues) throws Exception {\n@@ -114,33 +133,1 @@\n-        var lock = new Lock();\n-\n-        var blockerThread = Thread.startVirtualThread(() -> {\n-            \/\/ force compensation in carrier thread pool which will spin another\n-            \/\/ carrier thread so that we can later observe it being terminated...\n-            synchronized (lock) {\n-                while (!lock.unblock) {\n-                    try {\n-                        lock.wait();\n-                    } catch (InterruptedException e) {\n-                        throw new RuntimeException(e);\n-                    }\n-                }\n-            }\n-            \/\/ keep thread running in a non-blocking-fashion which keeps\n-            \/\/ it bound to carrier thread\n-            while (!lock.unspin) {\n-                Thread.onSpinWait();\n-            }\n-        });\n-\n-        Thread thread = Thread\n-            .ofVirtual()\n-            .allowSetThreadLocals(false)\n-            .inheritInheritableThreadLocals(false)\n-            .name(\"ttl-test-virtual\")\n-            .unstarted(() -> ttlOps.accept(ttl));\n-        thread.start();\n-        try {\n-            thread.join();\n-        } catch (InterruptedException e) {\n-            throw new RuntimeException(e);\n-        }\n+        Thread carrier;\n@@ -148,4 +135,2 @@\n-        if (!terminatedValues.isEmpty()) {\n-            throw new AssertionError(\"Unexpected terminated values after virtual thread.join(): \" +\n-                                     terminatedValues);\n-        }\n+        \/\/ use a single worker thread pool for the cheduler\n+        try (var pool = Executors.newSingleThreadExecutor()) {\n@@ -153,5 +138,2 @@\n-        \/\/ we now unblock the blocker thread but keep it running\n-        synchronized (lock) {\n-            lock.unblock = true;\n-            lock.notify();\n-        }\n+            \/\/ capture carrier Thread\n+            carrier = pool.submit(Thread::currentThread).get();\n@@ -159,8 +141,7 @@\n-        \/\/ carrier thread pool has a 30 second keep-alive time to terminate excessive carrier\n-        \/\/ threads. Since blockerThread is still pinning one of them we hope for the other\n-        \/\/ thread to be terminated...\n-        try {\n-            TimeUnit.SECONDS.sleep(31);\n-        } catch (InterruptedException e) {\n-            throw new RuntimeException(e);\n-        }\n+            ThreadFactory factory = virtualThreadBuilder(pool)\n+                    .name(\"ttl-test-virtual-\", 0)\n+                    .allowSetThreadLocals(false)\n+                    .factory();\n+            try (var executor = Executors.newThreadPerTaskExecutor(factory)) {\n+                executor.submit(() -> ttlOps.accept(ttl)).get();\n+            }\n@@ -168,4 +149,2 @@\n-        if (!terminatedValues.equals(Arrays.asList(expectedTerminatedValues))) {\n-            throw new AssertionError(\"Expected terminated values: \" +\n-                                     Arrays.toString(expectedTerminatedValues) +\n-                                     \" but got: \" + terminatedValues);\n+            assertTrue(terminatedValues.isEmpty(),\n+                       \"Unexpected terminated values after virtual thread terminated\");\n@@ -174,2 +153,10 @@\n-        \/\/ we now terminate the blocker thread\n-        lock.unspin = true;\n+        \/\/ wait for carrier to terminate\n+        carrier.join();\n+\n+        assertEquals(terminatedValues, expectedTerminatedValues);\n+    }\n+\n+    \/**\n+     * Returns a builder to create virtual threads that use the given scheduler.\n+     *\/\n+    static Thread.Builder.OfVirtual virtualThreadBuilder(Executor scheduler) {\n@@ -177,2 +164,11 @@\n-            blockerThread.join();\n-        } catch (InterruptedException e) {\n+            Class<?> clazz = Class.forName(\"java.lang.ThreadBuilders$VirtualThreadBuilder\");\n+            Constructor<?> ctor = clazz.getDeclaredConstructor(Executor.class);\n+            ctor.setAccessible(true);\n+            return (Thread.Builder.OfVirtual) ctor.newInstance(scheduler);\n+        } catch (InvocationTargetException e) {\n+            Throwable cause = e.getCause();\n+            if (cause instanceof RuntimeException re) {\n+                throw re;\n+            }\n+            throw new RuntimeException(e);\n+        } catch (Exception e) {\n@@ -182,5 +178,0 @@\n-\n-    static class Lock {\n-        boolean unblock;\n-        volatile boolean unspin;\n-    }\n","filename":"test\/jdk\/jdk\/internal\/misc\/TerminatingThreadLocal\/TestTerminatingThreadLocal.java","additions":88,"deletions":97,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -0,0 +1,359 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8292278\n+ * @summary Basic tests where jit compilation of test methods is controlled with a compilation policy\n+ * @requires vm.continuations\n+ * @modules java.base\/jdk.internal.vm\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm   --enable-preview\n+ *                     -XX:+UnlockDiagnosticVMOptions   -XX:+WhiteBoxAPI\n+ *                     -Xbootclasspath\/a:.\n+ *                     -Xbatch\n+ *                     -XX:-TieredCompilation\n+ *                     -XX:CompileCommand=dontinline,*::*dontinline*\n+ *                     -XX:CompileCommand=dontinline,*::*dontjit*\n+ *                     -XX:CompileCommand=exclude,*::*dontjit*\n+ *                     -XX:CompileCommand=dontinline,java\/lang\/String*.*\n+ *                     MovingCompWindow\n+ *\/\n+\n+import java.lang.reflect.Method;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.regex.Pattern;\n+\n+import jdk.internal.vm.Continuation;\n+import jdk.internal.vm.ContinuationScope;\n+import static jdk.test.lib.Asserts.*;\n+\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class MovingCompWindow {\n+    static final ContinuationScope THE_SCOPE = new ContinuationScope() {};\n+\n+    public static final Pattern COMP_NONE  = Pattern.compile(\"COMP_NONE\");\n+    public static final Pattern COMP_ALL   = Pattern.compile(\"COMP_ALL\");\n+    public static final Pattern CONT_METHS = Pattern.compile(\"^(enter|enter0|yield|yield0)$\");\n+\n+    public static boolean callSystemGC;\n+    public static int compLevel;\n+\n+    public static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    public static void main(String[] args) {\n+        \/\/ Run tests with C2 compilations\n+        compLevel = CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION;\n+\n+        \/\/ Run tests, call System.GC().\n+        \/\/ GC forces allocation of new StackChunk because the existing will get FLAG_GC_MODE set.\n+        callSystemGC = true;\n+        runTests();\n+    }\n+\n+    public static void runTests() {\n+        System.out.println(\"$$$0 Running test cases with the following settings:\");\n+        System.out.println(\"compLevel=\" + compLevel);\n+        System.out.println(\"callSystemGC=\" + callSystemGC);\n+        System.out.println();\n+\n+        runTests(new CompilationPolicy(7 \/*warmup*\/, 1 \/* length comp. window *\/));\n+    }\n+\n+    public static void runTests(CompilationPolicy compPolicy) {\n+        System.out.println(\"$$$1 Running test cases with the following policy:\");\n+        compPolicy.print(); System.out.println();\n+\n+        new ContinuationRunYieldRunTest().runTestCase(3, compPolicy);\n+    }\n+\n+    \/\/ Control which frames are compiled\/interpreted when calling Continuation.yield()\n+    \/\/ With COMP_WINDOW the methods in the window are supposed to be compiled and others\n+    \/\/ are interpreted. With DEOPT_WINDOW vice versa.\n+    \/\/ The methods that are subject to the CompilationPolicy are set with setMethods().\n+    \/\/ Their order has to correspond to the stack order when calling yield().\n+    public static class CompilationPolicy {\n+        public int warmupIterations;\n+        public Pattern methodPattern;\n+        public Pattern contMethPattern;\n+\n+        public CompWindowMode compWindowMode;\n+        public int winPos;\n+        public int winLen;\n+\n+        public Method[] methods;\n+\n+        public enum CompWindowMode {\n+            NO_COMP_WINDOW, COMP_WINDOW, DEOPT_WINDOW\n+        }\n+\n+        public CompilationPolicy(int warmupIterations, Pattern methodPattern, Pattern contMethPattern) {\n+            this(warmupIterations, 0, methodPattern, contMethPattern, CompWindowMode.NO_COMP_WINDOW);\n+        }\n+\n+        public CompilationPolicy(int warmupIterations, int windowLength, Pattern methodPattern, Pattern contMethPattern) {\n+            this(warmupIterations, windowLength, methodPattern, contMethPattern, CompWindowMode.COMP_WINDOW);\n+        }\n+\n+        public CompilationPolicy(int warmupIterations, int windowLength, Pattern methodPattern, Pattern contMethPattern,\n+                                 CompWindowMode startMode) {\n+            this.warmupIterations = warmupIterations;\n+            this.methodPattern = methodPattern;\n+            this.contMethPattern = contMethPattern;\n+            this.winPos = 0;\n+            this.winLen = windowLength;\n+            this.compWindowMode = startMode;\n+        }\n+\n+        public CompilationPolicy(int warmupIterations, int windowLength) {\n+            this(warmupIterations, windowLength, COMP_ALL, CONT_METHS);\n+        }\n+\n+        public int warmupIterations() {\n+            return this.warmupIterations;\n+        }\n+\n+        public void compileMethods() {\n+            log(\"Compilation window mode: \" + compWindowMode + \" winPos=\" + winPos + \" winLen=\" + winLen);\n+            for (int i = 0; i < methods.length; i++) {\n+                Method meth = methods[i];\n+                boolean inWindow = i >= winPos && i < (winPos+winLen);\n+                boolean shouldBeCompiled = compWindowMode == CompWindowMode.NO_COMP_WINDOW\n+                    || (inWindow && compWindowMode == CompWindowMode.COMP_WINDOW)\n+                    || (!inWindow && compWindowMode == CompWindowMode.DEOPT_WINDOW);\n+                boolean isCompiled = WB.isMethodCompiled(meth);\n+                log(\"methods[\"+i+\"] inWindow=\"+inWindow + \" isCompiled=\"+isCompiled+\" shouldBeCompiled=\"+shouldBeCompiled+\" method=`\"+meth+\"`\");\n+                if (isCompiled != shouldBeCompiled) {\n+                    if (shouldBeCompiled) {\n+                        log(\"           Compiling methods[\"+i+\"]\");\n+                        enqForCompilation(meth);\n+                        assertTrue(WB.isMethodCompiled(meth), \"Run with -Xbatch\");\n+                    } else {\n+                        assertFalse(WB.isMethodQueuedForCompilation(meth), \"Run with -Xbatch\");\n+                        log(\"           Deoptimizing methods[\"+i+\"]\");\n+                        WB.deoptimizeMethod(meth);\n+                    }\n+                }\n+            }\n+        }\n+\n+        @SuppressWarnings(\"deprecation\")\n+        public boolean enqForCompilation(Method meth) {\n+            return WB.enqueueMethodForCompilation(meth, compLevel);\n+        }\n+\n+        public void log(String m) {\n+            System.out.println(m);\n+        }\n+\n+        public void print() {\n+            log(\"warmupIterations=\" + warmupIterations);\n+            log(\"methodPattern=\" + methodPattern);\n+            log(\"continuationMethPattern=\" + contMethPattern);\n+            log(\"compWindowMode=\" + compWindowMode);\n+            log(\"winLen=\" + winLen);\n+        }\n+\n+        public void setMethods(Method[] methods) {\n+            this.methods = methods;\n+            if (compWindowMode == CompWindowMode.NO_COMP_WINDOW) {\n+                winLen = methods.length;\n+            }\n+        }\n+\n+        public boolean shiftWindow() {\n+            if(compWindowMode == CompWindowMode.NO_COMP_WINDOW) return false;\n+            if (++winPos == methods.length) {\n+                winPos = 0;\n+                if (compWindowMode == CompWindowMode.DEOPT_WINDOW) {\n+                    compWindowMode = CompWindowMode.COMP_WINDOW;\n+                    return false; \/\/ we're done\n+                }\n+                compWindowMode = CompWindowMode.DEOPT_WINDOW;\n+            }\n+            return true; \/\/ continue\n+        }\n+    }\n+\n+    \/**\n+     * Base class for test cases\n+     *\/\n+    public static abstract class TestCaseBase implements Runnable {\n+        public int yieldCalls;\n+        public int warmUpCount;\n+        public CompilationPolicy compPolicy;\n+\n+        public void log_dontjit() {\n+            System.out.println();\n+        }\n+\n+        public void log_dontjit(String m) {\n+            if (warmUpCount > 0) {\n+                System.out.print(\"[\" + warmUpCount + \"] \");\n+            }\n+            System.out.println(m);\n+        }\n+\n+        public void runTestCase(int yieldCalls, CompilationPolicy compPolicy) {\n+            this.yieldCalls = yieldCalls;\n+            log_dontjit(\">>>> Executing test case \" + getClass().getName() + \" (yieldCalls=\" + yieldCalls + \")\");\n+            init(compPolicy);\n+            try {\n+                log_dontjit(\"Warm-up test case\");\n+                for(warmUpCount = 1; warmUpCount <= compPolicy.warmupIterations(); warmUpCount++) {\n+                    testEntry_dontinline();\n+                }\n+                warmUpCount = 0;\n+                log_dontjit(\"Warm-up test case DONE\");\n+\n+                do {\n+                    log_dontjit(\"@@ Compiling test methods according to compilation policy\");\n+                    compPolicy.compileMethods();\n+\n+                    log_dontjit(\"Running test case (Reresolve Call Sites)\");\n+                    testEntry_dontinline();\n+                    log_dontjit(\"Running test case DONE  (Reresolve Call Sites)\");\n+\n+                    log_dontjit(\"Running test case\");\n+                    testEntry_dontinline();\n+                    log_dontjit(\"Running test case DONE\");\n+                } while(compPolicy.shiftWindow());\n+            } finally {\n+                log_dontjit(\"<<<< Finished test case \" + getClass().getName()); log_dontjit();\n+            }\n+        }\n+\n+        public void init(CompilationPolicy compPolicy) {\n+            this.compPolicy = compPolicy;\n+            ArrayList<Method> selectedMethods = new ArrayList<Method>();\n+            Pattern p = compPolicy.methodPattern;\n+            if (p != COMP_NONE) {\n+                Class<? extends TestCaseBase> c = getClass();\n+                Method methods[] = c.getDeclaredMethods();\n+                for (Method meth : methods) {\n+                    if (p == COMP_ALL || p.matcher(meth.getName()).matches()) {\n+                        if (!meth.getName().contains(\"dontjit\")) {\n+                            selectedMethods.add(meth);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            p = compPolicy.contMethPattern;\n+            if (compPolicy.contMethPattern != COMP_NONE) {\n+                Class<?> c = Continuation.class;\n+                Method methods[] = c .getDeclaredMethods();\n+                for (Method meth : methods) {\n+                    if (p.matcher(meth.getName()).matches()) {\n+                        selectedMethods.add(meth);\n+                    }\n+                }\n+            }\n+            \/\/ Sort in caller\/callee order by the \"ord\" method name prefix\n+            selectedMethods.sort(new Comparator<Method>() {\n+                    @Override\n+                    public int compare(Method m1, Method m2) {\n+                        String n1 = m1.getName();\n+                        String n2 = m2.getName();\n+                        \/\/ log_dontjit(\"n1=\" + n1 + \" n2=\" + n2);\n+                        int p1 = -1;\n+                        int p2 = -1;\n+                        int i = n1.indexOf(\"ord\");\n+                        if (i >= 0) {\n+                            p1 = Integer.parseInt(n1.substring(i+3, i+6));\n+                        }\n+                        i = n2.indexOf(\"ord\");\n+                        if (i >= 0) {\n+                            p2 = Integer.parseInt(n2.substring(i+3, i+6));\n+                        }\n+                        if (p1 < 0) p1 = getScoreKnownMethods(n1);\n+                        if (p2 < 0) p2 = getScoreKnownMethods(n2);\n+                        assertFalse(p1 == -1 || p2 == -1, \"Cannot compare \" + n1 + \" with \" + n2);\n+                        return p1 - p2;\n+                    }\n+\n+                    private int getScoreKnownMethods(String n) {\n+                        int p = -1;\n+                        if (n.equals(\"enter\"))  p = 20;   \/\/ Continuation.enter\n+                        if (n.equals(\"enter0\")) p = 30;   \/\/ Continuation.enter0\n+                        if (n.equals(\"run\"))    p = 50;   \/\/ Called by Continuation.enter0\n+                        if (n.equals(\"yield\"))  p = 1000; \/\/ caller of yield0\n+                        if (n.equals(\"yield0\")) p = 2000; \/\/ top frame\n+                        return p;\n+                    }\n+                });\n+            compPolicy.setMethods(selectedMethods.toArray(new Method[selectedMethods.size()]));\n+        }\n+\n+        public void testEntry_dontinline() {\n+            Continuation cont = new Continuation(THE_SCOPE, this);\n+            do {\n+                cont.run();\n+                if (callSystemGC) System.gc();\n+                checkFrames_dontjit(cont);\n+            } while (!cont.isDone());\n+        }\n+\n+        public void checkFrames_dontjit(Continuation cont) {\n+        } \/\/ Override in subclass as appropriate\n+\n+        @Override\n+        public void run() {\n+            fail(\"Should not call TestCaseBase::run\");\n+        }\n+\n+        public void sleep(Duration d) {\n+            try { Thread.sleep(d); }\n+            catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Trivial run\/yield\/run test\n+     *\/\n+    public static class ContinuationRunYieldRunTest extends TestCaseBase {\n+        public String sField;\n+\n+        @Override\n+        public void run() {\n+            log_dontjit(\"Continuation running on thread \" + Thread.currentThread());\n+            for(int i = 0; i < yieldCalls; i++) {\n+                log_dontjit(\"Yield #\" + i);\n+                String s1 = \"str1\";\n+                Continuation.yield(THE_SCOPE);\n+                String s2 = s1+\"str2\";\n+                sField = s2;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/MovingCompWindow.java","additions":359,"deletions":0,"binary":false,"changes":359,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.profiling;\n+\n+import java.time.Duration;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordingStream;\n+import jdk.jfr.internal.JVM;\n+import jdk.test.lib.jfr.EventNames;\n+\n+\/*\n+ * @test\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @modules jdk.jfr\/jdk.jfr.internal\n+ * @run main jdk.jfr.event.profiling.TestNative\n+ *\/\n+public class TestNative {\n+\n+    final static String NATIVE_EVENT = EventNames.NativeMethodSample;\n+\n+    static volatile boolean alive = true;\n+\n+    public static void main(String[] args) throws Exception {\n+        try (RecordingStream rs = new RecordingStream()) {\n+            rs.enable(NATIVE_EVENT).withPeriod(Duration.ofMillis(1));\n+            rs.onEvent(NATIVE_EVENT, e -> {\n+                alive = false;\n+                rs.close();\n+            });\n+            Thread t = new Thread(TestNative::nativeMethod);\n+            t.setDaemon(true);\n+            t.start();\n+            rs.start();\n+        }\n+\n+    }\n+\n+    public static void nativeMethod() {\n+        while (alive) {\n+            JVM.getJVM().getPid();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/TestNative.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.profiling;\n+\n+import java.time.Duration;\n+\n+import jdk.jfr.consumer.RecordingStream;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.RecurseThread;\n+\n+\/*\n+ * @test\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @modules jdk.jfr\/jdk.jfr.internal\n+ * @run main jdk.jfr.event.profiling.TestSamplingLongPeriod\n+ *\/\n+public class TestSamplingLongPeriod {\n+\n+    final static String SAMPLE_EVENT = EventNames.ExecutionSample;\n+\n+    \/\/ The period is set to 1100 ms to provoke the 1000 ms\n+    \/\/ threshold in the JVM for os::naked_short_sleep().\n+    public static void main(String[] args) throws Exception {\n+        RecurseThread t = new RecurseThread(50);\n+        t.setDaemon(true);\n+        try (RecordingStream rs = new RecordingStream()) {\n+            rs.enable(SAMPLE_EVENT).withPeriod(Duration.ofMillis(1100));\n+            rs.onEvent(SAMPLE_EVENT, e -> {\n+                t.quit();\n+                rs.close();\n+            });\n+            t.start();\n+            rs.start();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/TestSamplingLongPeriod.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -1,74 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.event.sampling;\n-\n-import java.time.Duration;\n-import java.util.List;\n-import java.util.concurrent.Semaphore;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import jdk.jfr.Recording;\n-import jdk.jfr.consumer.RecordedFrame;\n-import jdk.jfr.consumer.RecordingStream;\n-import jdk.jfr.internal.JVM;\n-import jdk.test.lib.jfr.EventNames;\n-\n-\/*\n- * @test\n- * @key jfr\n- * @requires vm.hasJFR\n- * @library \/test\/lib\n- * @modules jdk.jfr\/jdk.jfr.internal\n- * @run main jdk.jfr.event.sampling.TestNative\n- *\/\n-public class TestNative {\n-\n-    final static String NATIVE_EVENT = EventNames.NativeMethodSample;\n-\n-    static volatile boolean alive = true;\n-\n-    \/\/ Please resist the temptation to speed up the test by decreasing\n-    \/\/ the period. It is explicity set to 1100 ms to provoke the 1000 ms\n-    \/\/ threshold in the JVM for os::naked_short_sleep().\n-    public static void main(String[] args) throws Exception {\n-        try (RecordingStream rs = new RecordingStream()) {\n-            rs.enable(NATIVE_EVENT).withPeriod(Duration.ofMillis(1100));\n-            rs.onEvent(NATIVE_EVENT, e -> {\n-                alive = false;\n-                rs.close();\n-            });\n-            Thread t = new Thread(TestNative::nativeMethod);\n-            t.setDaemon(true);\n-            t.start();\n-            rs.start();\n-        }\n-\n-    }\n-\n-    public static void nativeMethod() {\n-        while (alive) {\n-            JVM.getJVM().getPid();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/jdk\/jfr\/event\/sampling\/TestNative.java","additions":0,"deletions":74,"binary":false,"changes":74,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-import java.nio.file.Paths;\n+import java.nio.file.PathMatcher;\n@@ -45,1 +45,1 @@\n- * @bug 8038500 8040059 8150366 8150496 8147539\n+ * @bug 8038500 8040059 8150366 8150496 8147539 8290047\n@@ -92,1 +92,1 @@\n-            Path target = Paths.get(source.getFileName().toString());\n+            Path target = Path.of(source.getFileName().toString());\n@@ -116,0 +116,13 @@\n+        \/\/ Test: IllegalArgumentException\n+        try {\n+            PathMatcher pm = fs.getPathMatcher(\":glob\");\n+            throw new RuntimeException(\"IllegalArgumentException not thrown\");\n+        } catch (IllegalArgumentException iae) {\n+        }\n+        try {\n+            PathMatcher pm = fs.getPathMatcher(\"glob:\");\n+        } catch (IllegalArgumentException iae) {\n+            iae.printStackTrace();\n+            throw new RuntimeException(\"Unexpected IllegalArgumentException\");\n+        }\n+\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/Basic.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-        INTEGER, DOUBLE, PERCENTAGE, PERCENTAGE_OR_DASH;\n+        INTEGER, DOUBLE, PERCENTAGE, PERCENTAGE_OR_DASH, INTEGER_OR_DASH, DOUBLE_OR_DASH;\n@@ -52,6 +52,6 @@\n-        YGC(GcStatisticsType.INTEGER),\n-        YGCT(GcStatisticsType.DOUBLE),\n-        FGC(GcStatisticsType.INTEGER),\n-        FGCT(GcStatisticsType.DOUBLE),\n-        CGC(GcStatisticsType.INTEGER),\n-        CGCT(GcStatisticsType.DOUBLE),\n+        YGC(GcStatisticsType.INTEGER_OR_DASH),\n+        YGCT(GcStatisticsType.DOUBLE_OR_DASH),\n+        FGC(GcStatisticsType.INTEGER_OR_DASH),\n+        FGCT(GcStatisticsType.DOUBLE_OR_DASH),\n+        CGC(GcStatisticsType.INTEGER_OR_DASH),\n+        CGCT(GcStatisticsType.DOUBLE_OR_DASH),\n@@ -96,1 +96,8 @@\n-                if (type.equals(GcStatisticsType.INTEGER)) {\n+                if ((type.equals(GcStatisticsType.PERCENTAGE_OR_DASH)\n+                     || type.equals(GcStatisticsType.INTEGER_OR_DASH)\n+                     || type.equals(GcStatisticsType.DOUBLE_OR_DASH))\n+                    && value.equals(\"-\")) {\n+                    continue;\n+                }\n+                if (type.equals(GcStatisticsType.INTEGER)\n+                    || type.equals(GcStatisticsType.INTEGER_OR_DASH)) {\n@@ -98,1 +105,1 @@\n-                    break;\n+                    continue;\n@@ -100,1 +107,2 @@\n-                if (type.equals(GcStatisticsType.DOUBLE)) {\n+                if (type.equals(GcStatisticsType.DOUBLE)\n+                    || type.equals(GcStatisticsType.DOUBLE_OR_DASH)) {\n@@ -102,5 +110,1 @@\n-                    break;\n-                }\n-                if (type.equals(GcStatisticsType.PERCENTAGE_OR_DASH) &&\n-                        value.equals(\"-\")) {\n-                    break;\n+                    continue;\n@@ -110,1 +114,1 @@\n-                        \"Not a percentage: \" + value);\n+                        \"Not a percentage. value: \" + value + \" percentage: \" + percentage);\n","filename":"test\/jdk\/sun\/tools\/jstatd\/JstatGCUtilParser.java","additions":21,"deletions":17,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n- * jstat -J-XX:+UsePerfData -J-Duser.language=en -gcutil pid@hostname 250 5\n+ * jstat -J-XX:+UsePerfData -gcutil pid@hostname 250 5\n@@ -175,4 +175,4 @@\n-     * jstat -J-XX:+UsePerfData -J-Duser.language=en -gcutil pid@hostname 250 5\n-     * jstat -J-XX:+UsePerfData -J-Duser.language=en -gcutil pid@hostname:port 250 5\n-     * jstat -J-XX:+UsePerfData -J-Duser.language=en -gcutil pid@hostname\/serverName 250 5\n-     * jstat -J-XX:+UsePerfData -J-Duser.language=en -gcutil pid@hostname:port\/serverName 250 5\n+     * jstat -J-XX:+UsePerfData -gcutil pid@hostname 250 5\n+     * jstat -J-XX:+UsePerfData -gcutil pid@hostname:port 250 5\n+     * jstat -J-XX:+UsePerfData -gcutil pid@hostname\/serverName 250 5\n+     * jstat -J-XX:+UsePerfData -gcutil pid@hostname:port\/serverName 250 5\n@@ -183,1 +183,0 @@\n-        launcher.addVMArg(\"-Duser.language=en\");\n","filename":"test\/jdk\/sun\/tools\/jstatd\/JstatdTest.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -286,0 +286,12 @@\n+\n+            if (TKit.isWindows()) {\n+                \/\/ Verify context menu label in registry.\n+                String progId = WindowsHelper.queryRegistryValue(\n+                        String.format(\"HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Classes\\\\%s\", fa.getSuffix()), \"\");\n+                TKit.assertNotNull(progId, \"context menu progId found\");\n+                String contextMenuLabel = WindowsHelper.queryRegistryValue(\n+                        String.format(\"HKEY_CLASSES_ROOT\\\\%s\\\\shell\\\\open\", progId), \"\");\n+                TKit.assertNotNull(contextMenuLabel, \"context menu label found\");\n+                String appName = cmd.getArgumentValue(\"--name\");\n+                TKit.assertTrue(String.format(\"Open with %s\", appName).equals(contextMenuLabel), \"context menu label text\");\n+            }\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/PackageTest.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -64,0 +64,16 @@\n+    \/\/ Tests have problems on windows where path in the temp dir are too long\n+    \/\/ for the wix tools.  We can't use a tempDir outside the TKit's WorkDir, so\n+    \/\/ we minimize both the tempRoot directory name (above) and the tempDir name\n+    \/\/ (below) to the extension part (which is necessary to differenciate between\n+    \/\/ the multiple PackageTypes that will be run for one JPackageCommand).\n+    \/\/ It might be beter if the whole work dir name was shortened from:\n+    \/\/ jtreg_open_test_jdk_tools_jpackage_share_jdk_jpackage_tests_BasicTest_java.\n+    public static Path getTempDirectory(JPackageCommand cmd, Path tempRoot) {\n+        String ext = cmd.outputBundle().getFileName().toString();\n+        int i = ext.lastIndexOf(\".\");\n+        if (i > 0 && i < (ext.length() - 1)) {\n+            ext = ext.substring(i+1);\n+        }\n+        return tempRoot.resolve(ext);\n+    }\n+\n@@ -359,1 +375,1 @@\n-    private static String queryRegistryValue(String keyPath, String valueName) {\n+    static String queryRegistryValue(String keyPath, String valueName) {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/WindowsHelper.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+import static jdk.jpackage.test.WindowsHelper.getTempDirectory;\n+\n@@ -276,15 +278,0 @@\n-        \/\/ This Test has problems on windows where path in the temp dir are too long\n-        \/\/ for the wix tools.  We can't use a tempDir outside the TKit's WorkDir, so\n-        \/\/ we minimize both the tempRoot directory name (above) and the tempDir name\n-        \/\/ (below) to the extension part (which is necessary to differenciate between\n-        \/\/ the multiple PackageTypes that will be run for one JPackageCommand).\n-        \/\/ It might be beter if the whole work dir name was shortened from:\n-        \/\/ jtreg_open_test_jdk_tools_jpackage_share_jdk_jpackage_tests_BasicTest_java.\n-        Function<JPackageCommand, Path> getTempDir = cmd -> {\n-            String ext = cmd.outputBundle().getFileName().toString();\n-            int i = ext.lastIndexOf(\".\");\n-            if (i > 0 && i < (ext.length() - 1)) {\n-                ext = ext.substring(i+1);\n-            }\n-            return tempRoot.resolve(ext);\n-        };\n@@ -298,1 +285,1 @@\n-                Path tempDir = getTempDir.apply(cmd);\n+                Path tempDir = getTempDirectory(cmd, tempRoot);\n@@ -311,1 +298,1 @@\n-            Path tempDir = getTempDir.apply(cmd);\n+            Path tempDir = getTempDirectory(cmd, tempRoot);\n","filename":"test\/jdk\/tools\/jpackage\/share\/jdk\/jpackage\/tests\/BasicTest.java","additions":4,"deletions":17,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.nio.file.Files;\n@@ -31,0 +32,2 @@\n+\n+import java.util.Arrays;\n@@ -34,1 +37,0 @@\n-import java.util.stream.Collectors;\n@@ -37,0 +39,2 @@\n+import static jdk.jpackage.test.WindowsHelper.getTempDirectory;\n+\n@@ -54,1 +58,3 @@\n-            String expectedCulture, String expectedErrorMessage) {\n+            String expectedCulture, String expectedErrorMessage,\n+            String userLanguage, String userCountry,\n+            boolean enableWixUIExtension) {\n@@ -58,0 +64,3 @@\n+        this.userLanguage = userLanguage;\n+        this.userCountry = userCountry;\n+        this.enableWixUIExtension = enableWixUIExtension;\n@@ -63,1 +72,9 @@\n-            {null, \"en-us\", null},\n+            {null, \"en-us\", null, null, null, false},\n+            {null, \"en-us\", null, \"en\", \"US\", false},\n+            {null, \"en-us\", null, \"en\", \"US\", true},\n+            {null, \"de-de\", null, \"de\", \"DE\", false},\n+            {null, \"de-de\", null, \"de\", \"DE\", true},\n+            {null, \"ja-jp\", null, \"ja\", \"JP\", false},\n+            {null, \"ja-jp\", null, \"ja\", \"JP\", true},\n+            {null, \"zh-cn\", null, \"zh\", \"CN\", false},\n+            {null, \"zh-cn\", null, \"zh\", \"CN\", true},\n@@ -66,1 +83,1 @@\n-            }, \"en-us\", null},\n+            }, \"en-us\", null, null, null, false},\n@@ -69,1 +86,1 @@\n-            }, \"fr;en-us\", null},\n+            }, \"fr;en-us\", null, null, null, false},\n@@ -73,1 +90,1 @@\n-            }, \"fr;en-us\", null},\n+            }, \"fr;en-us\", null, null, null, false},\n@@ -77,1 +94,1 @@\n-            }, \"it;fr;en-us\", null},\n+            }, \"it;fr;en-us\", null, null, null, false},\n@@ -81,1 +98,1 @@\n-            }, \"fr;it;en-us\", null},\n+            }, \"fr;it;en-us\", null, null, null, false},\n@@ -87,1 +104,1 @@\n-            }, \"fr;it;en-us\", null},\n+            }, \"fr;it;en-us\", null, null, null, false},\n@@ -91,1 +108,4 @@\n-            }, null, null}\n+            }, null, null, null, null, false},\n+            {new WixFileInitializer[] {\n+                WixFileInitializer.create(\"MsiInstallerStrings_de.wxl\", \"de\")\n+            }, \"en-us\", null, null, null, false}\n@@ -95,1 +115,1 @@\n-    private final static Stream<String> getLightCommandLine(\n+    private static Stream<String> getLightCommandLine(\n@@ -104,0 +124,7 @@\n+    private static List<TKit.TextStreamVerifier> createDefaultL10nFilesLocVerifiers(Path tempDir) {\n+        return Arrays.stream(DEFAULT_L10N_FILES).map(loc ->\n+                TKit.assertTextStream(\"-loc \" + tempDir.resolve(\n+                        String.format(\"config\/MsiInstallerStrings_%s.wxl\", loc)).normalize()))\n+                .toList();\n+    }\n+\n@@ -106,0 +133,1 @@\n+        final Path tempRoot = TKit.createTempDirectory(\"tmp\");\n@@ -122,0 +150,20 @@\n+\n+            \/\/ Set JVM default locale that is used to select primary l10n file.\n+            if (userLanguage != null) {\n+                cmd.addArguments(\"-J-Duser.language=\" + userLanguage);\n+            }\n+            if (userCountry != null) {\n+                cmd.addArguments(\"-J-Duser.country=\" + userCountry);\n+            }\n+\n+            \/\/ Cultures handling is affected by the WiX extensions used.\n+            \/\/ By default only WixUtilExtension is used, this flag\n+            \/\/ additionally enables WixUIExtension.\n+            if (enableWixUIExtension) {\n+                cmd.addArgument(\"--win-dir-chooser\");\n+            }\n+\n+            \/\/ Preserve config dir to check the set of copied l10n files.\n+            Path tempDir = getTempDirectory(cmd, tempRoot);\n+            Files.createDirectories(tempDir.getParent());\n+            cmd.addArguments(\"--temp\", tempDir.toString());\n@@ -137,2 +185,8 @@\n-                        v.createCmdOutputVerifier(resourceDir).apply(\n-                                getLightCommandLine(result));\n+                        if (!v.name.startsWith(\"MsiInstallerStrings_\")) {\n+                            v.createCmdOutputVerifier(resourceDir).apply(\n+                                    getLightCommandLine(result));\n+                        }\n+                    }\n+                    Path tempDir = getTempDirectory(cmd, tempRoot).toAbsolutePath();\n+                    for (var v : createDefaultL10nFilesLocVerifiers(tempDir)) {\n+                        v.apply(getLightCommandLine(result));\n@@ -171,1 +225,1 @@\n-    final private WixFileInitializer wxlFileInitializers[];\n+    final private WixFileInitializer[] wxlFileInitializers;\n@@ -174,0 +228,3 @@\n+    final private String userLanguage;\n+    final private String userCountry;\n+    final private boolean enableWixUIExtension;\n@@ -224,1 +281,1 @@\n-                    root.resolve(name).toAbsolutePath().toString());\n+                    \"-loc \" + root.resolve(name).toAbsolutePath().normalize());\n@@ -239,0 +296,2 @@\n+\n+    private static final String[] DEFAULT_L10N_FILES = { \"de\", \"en\", \"ja\", \"zh_CN\" };\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinL10nTest.java","additions":74,"deletions":15,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -54,3 +54,4 @@\n-                \"h1 {\\n\"\n-                + \"    font-size:20px;\\n\"\n-                + \"}\");\n+                \"\"\"\n+                    h1 {\n+                        font-size:1.428em;\n+                    }\"\"\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/AccessH1\/AccessH1.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-                \"ui-autocomplete\", \"ui-autocomplete-category\", \"expanded\",\n+                \"ui-autocomplete\", \"ui-autocomplete-category\", \"ui-state-active\", \"expanded\",\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/checkStylesheetClasses\/CheckStylesheetClasses.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8289332\n+ * @summary Auto-generate ids for user-defined headings\n+ * @library \/tools\/lib ..\/..\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build javadoc.tester.* toolbox.ToolBox\n+ * @run main TestAutoHeaderId\n+ *\/\n+\n+import java.nio.file.Path;\n+\n+import toolbox.ToolBox;\n+\n+import javadoc.tester.JavadocTester;\n+\n+public class TestAutoHeaderId extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        TestAutoHeaderId tester = new TestAutoHeaderId();\n+        tester.runTests();\n+    }\n+\n+    private final ToolBox tb;\n+\n+    TestAutoHeaderId() {\n+        tb = new ToolBox();\n+    }\n+\n+    @Test\n+    public void testAutoHeaderId(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                        package p;\n+                        \/**\n+                         * First sentence.\n+                         *\n+                         * <h2>First Header<\/h2>\n+                         *\n+                         * <h3 id=\"fixed-id-1\">Header with ID<\/h3>\n+                         *\n+                         * <h4><a id=\"fixed-id-2\">Embedded A-Tag with ID<\/a><\/h4>\n+                         *\n+                         * <h5>{@code Embedded Code Tag}<\/h5>\n+                         *\n+                         * <h6>{@linkplain C Embedded Link Tag}<\/h6>\n+                         *\n+                         * <h3>Duplicate Text<\/h3>\n+                         *\n+                         * <h4>Duplicate Text<\/h4>\n+                         *\n+                         * <h2>Extra (#*!. chars<\/h2>\n+                         *\n+                         * <h3 style=\"color: red;\" class=\"some-class\">Other attributes<\/h3>\n+                         *\n+                         * <h4><\/h4>\n+                         *\n+                         * Last sentence.\n+                         *\/\n+                        public class C {\n+                            \/** Comment. *\/\n+                            C() { }\n+                        }\n+                        \"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"--no-platform-links\", \"p\");\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    <h2 id=\"first-header-heading\">First Header<\/h2>\n+                    \"\"\",\n+                \"\"\"\n+                    <h3 id=\"fixed-id-1\">Header with ID<\/h3>\n+                    \"\"\",\n+                \"\"\"\n+                    <h4><a id=\"fixed-id-2\">Embedded A-Tag with ID<\/a><\/h4>\n+                    \"\"\",\n+                \"\"\"\n+                    <h5 id=\"embedded-code-tag-heading\"><code>Embedded Code Tag<\/code><\/h5>\n+                    \"\"\",\n+                \"\"\"\n+                    <h6 id=\"embedded-link-tag-heading\"><a href=\"C.html\" title=\"class in p\">Embedded Link Tag<\/a><\/h6>\n+                    \"\"\",\n+                \"\"\"\n+                    <h3 id=\"duplicate-text-heading\">Duplicate Text<\/h3>\n+                    \"\"\",\n+                \"\"\"\n+                    <h4 id=\"duplicate-text-heading1\">Duplicate Text<\/h4>\n+                    \"\"\",\n+                \"\"\"\n+                    <h2 id=\"extra-chars-heading\">Extra (#*!. chars<\/h2>\n+                    \"\"\",\n+                \"\"\"\n+                    <h3 id=\"other-attributes-heading\" style=\"color: red;\" class=\"some-class\">Other attributes<\/h3>\n+                    \"\"\",\n+                \"\"\"\n+                    <h4 id=\"-heading\"><\/h4>\n+                    \"\"\");\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testAutoHeaderId\/TestAutoHeaderId.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- *           8169819 8074407 8191030 8182765 8184205 8243533 8261976\n+ *           8169819 8074407 8191030 8182765 8184205 8243533 8261976 8273860\n@@ -295,1 +295,1 @@\n-                    <div class=\"deprecation-comment\">enum_test1 passes.<\/div>\n+                    <div class=\"block\">enum_test1 passes.<\/div>\n@@ -305,1 +305,1 @@\n-                    <div class=\"deprecation-comment\">error_test1 passes.<\/div>\n+                    <div class=\"block\">error_test1 passes.<\/div>\n@@ -309,1 +309,1 @@\n-                    <div class=\"deprecation-comment\">exception_test1 passes.<\/div>\n+                    <div class=\"block\">exception_test1 passes.<\/div>\n@@ -321,1 +321,1 @@\n-                    <div class=\"deprecation-comment\">annotation_test4 passes.<\/div>\n+                    <div class=\"block\">annotation_test4 passes.<\/div>\n@@ -325,1 +325,1 @@\n-                    <div class=\"deprecation-comment\">class_test2 passes. This is the second sentence of deprecated description for a field.<\/div>\n+                    <div class=\"block\">class_test2 passes. This is the second sentence of deprecated description for a field.<\/div>\n@@ -329,1 +329,1 @@\n-                    <div class=\"deprecation-comment\">error_test2 passes.<\/div>\n+                    <div class=\"block\">error_test2 passes.<\/div>\n@@ -333,1 +333,1 @@\n-                    <div class=\"deprecation-comment\">exception_test2 passes.<\/div>\n+                    <div class=\"block\">exception_test2 passes.<\/div>\n@@ -337,1 +337,1 @@\n-                    <div class=\"deprecation-comment\">interface_test2 passes.<\/div>\n+                    <div class=\"block\">interface_test2 passes.<\/div>\n@@ -351,1 +351,1 @@\n-                    <div class=\"deprecation-comment\">annotation_test2 passes.<\/div>\n+                    <div class=\"block\">annotation_test2 passes.<\/div>\n@@ -355,1 +355,1 @@\n-                    <div class=\"deprecation-comment\">annotation_test3 passes.<\/div>\n+                    <div class=\"block\">annotation_test3 passes.<\/div>\n@@ -359,1 +359,1 @@\n-                    <div class=\"deprecation-comment\">class_test5 passes. This is the second sentence of deprecated description for a method.<\/div>\n+                    <div class=\"block\">class_test5 passes. This is the second sentence of deprecated description for a method.<\/div>\n@@ -363,1 +363,1 @@\n-                    <div class=\"deprecation-comment\">class_test7 passes. Overloaded method 2.<\/div>\n+                    <div class=\"block\">class_test7 passes. Overloaded method 2.<\/div>\n@@ -367,1 +367,1 @@\n-                    <div class=\"deprecation-comment\">class_test6 passes. Overloaded method 1.<\/div>\n+                    <div class=\"block\">class_test6 passes. Overloaded method 1.<\/div>\n@@ -379,1 +379,1 @@\n-                    <div class=\"deprecation-comment\">class_test3 passes. This is the second sentence of deprecated description for a constructor.<\/div>\n+                    <div class=\"block\">class_test3 passes. This is the second sentence of deprecated description for a constructor.<\/div>\n@@ -383,1 +383,1 @@\n-                    <div class=\"deprecation-comment\">class_test4 passes. Overloaded constructor.<\/div>\n+                    <div class=\"block\">class_test4 passes. Overloaded constructor.<\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testDeprecatedDocs\/TestDeprecatedDocs.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -61,2 +61,2 @@\n-                    body {\n-                        background-color:#ffffff;\"\"\");\n+                body {\n+                    background-color:var(--body-background-color);\"\"\");\n@@ -70,1 +70,1 @@\n-                        background-color:#ffffff;\"\"\");\n+                        background-color:var(--page-bg-color);\"\"\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testDocEncoding\/TestDocEncoding.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,2 +39,0 @@\n-import static jdk.javadoc.internal.doclets.toolkit.util.DocletConstants.NL;\n-\n@@ -59,1 +57,1 @@\n-        String expected = readFile(testSrc, \"testMarkup.html\").replace(\"\\n\", NL);\n+        String expected = readFile(testSrc, \"testMarkup.html\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHtmlDocument\/TestHtmlDocument.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -707,1 +707,1 @@\n-                    <div class=\"deprecation-comment\">don't use this field anymore.<\/div>\n+                    <div class=\"block\">don't use this field anymore.<\/div>\n@@ -713,1 +713,1 @@\n-                    <div class=\"deprecation-comment\">don't use this anymore.<\/div>\n+                    <div class=\"block\">don't use this anymore.<\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHtmlTableTags\/TestHtmlTableTags.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,1 +103,1 @@\n-                    <h1>Package HTML file<\/h1>\n+                    <h1 id=\"package-html-file-heading\">Package HTML file<\/h1>\n@@ -109,1 +109,1 @@\n-                    <h1>Package HTML file<\/h1>\n+                    <h1 id=\"package-html-file-heading\">Package HTML file<\/h1>\n@@ -173,1 +173,1 @@\n-                    <h1>Module HTML file<\/h1>\n+                    <h1 id=\"module-html-file-heading\">Module HTML file<\/h1>\n@@ -179,1 +179,1 @@\n-                    <h1>Package HTML file<\/h1>\n+                    <h1 id=\"package-html-file-heading\">Package HTML file<\/h1>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testIndexInDocFiles\/TestIndexInDocFiles.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1120,1 +1120,1 @@\n-                    <div class=\"deprecation-comment\">This module is deprecated.<\/div>\"\"\");\n+                    <div class=\"block\">This module is deprecated.<\/div>\"\"\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testModules\/TestModules.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -527,1 +527,1 @@\n-                    <div class=\"deprecation-comment\">Do not use.<\/div>\n+                    <div class=\"block\">Do not use.<\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testRecordTypes\/TestRecordTypes.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -698,1 +698,0 @@\n-                \"jquery-ui.overrides.css\",\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSearch\/TestSearch.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- *           8253117 8263528\n+ *           8253117 8263528 8289334\n@@ -71,4 +71,4 @@\n-                        background-color:#ffffff;\n-                        color:#353833;\n-                        font-family:'DejaVu Sans', Arial, Helvetica, sans-serif;\n-                        font-size:14px;\n+                        background-color:var(--body-background-color);\n+                        color:var(--body-text-color);\n+                        font-family:var(--body-font-family);\n+                        font-size:var(--body-font-size);\n@@ -89,3 +89,4 @@\n-                \"ul {\\n\"\n-                + \"    list-style-type:disc;\\n\"\n-                + \"}\",\n+                \"\"\"\n+                    ul {\n+                        list-style-type:disc;\n+                    }\"\"\",\n@@ -106,10 +107,10 @@\n-                .caption span {\n-                    font-weight:bold;\n-                    white-space:nowrap;\n-                    padding:5px 12px 7px 12px;\n-                    display:inline-block;\n-                    float:left;\n-                    background-color:#F8981D;\n-                    border: none;\n-                    height:16px;\n-                }\"\"\",\n+                    .caption span {\n+                        font-weight:bold;\n+                        white-space:nowrap;\n+                        padding:5px 12px 7px 12px;\n+                        display:inline-block;\n+                        float:left;\n+                        background-color:var(--highlight-background-color);\n+                        border: none;\n+                        height:16px;\n+                    }\"\"\",\n@@ -118,5 +119,5 @@\n-                       border: none;\n-                       cursor: pointer;\n-                       padding: 5px 12px 7px 12px;\n-                       font-weight: bold;\n-                       margin-right: 8px;\n+                        border: none;\n+                        cursor: pointer;\n+                        padding: 5px 12px 7px 12px;\n+                        font-weight: bold;\n+                        margin-right: 8px;\n@@ -125,2 +126,2 @@\n-                       background: #F8981D;\n-                       color: #253441;\n+                        background: var(--highlight-background-color);\n+                        color: var(--highlight-text-color);\n@@ -129,2 +130,2 @@\n-                       background: #4D7A97;\n-                       color: #FFFFFF;\n+                        background: var(--navbar-background-color);\n+                        color: var(--navbar-text-color);\n@@ -153,1 +154,1 @@\n-                        color:#bb7a2a;\n+                        color:var(--link-color-active);\n@@ -166,2 +167,2 @@\n-                        font-size:14px;\n-                        font-family:'DejaVu Serif', Georgia, \"Times New Roman\", Times, serif;\n+                        font-size:1em;\n+                        font-family:var(--block-font-family);\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testStylesheet\/TestStylesheet.java","additions":31,"deletions":30,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -221,1 +221,0 @@\n-            \"jquery-ui.overrides.css\",\n@@ -235,1 +234,0 @@\n-                         && !s.equals(\"jquery-ui.overrides.css\")\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/api\/basic\/APITest.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 7194212\n+ * @summary Ensure InnerClasses attribute does not overwrite flags\n+ *          for source based classes\n+ * @library \/tools\/lib\n+ * @modules\n+ *      jdk.compiler\/com.sun.tools.javac.api\n+ *      jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main T7194212\n+ *\/\n+\n+import toolbox.JavacTask;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+public class T7194212 extends TestRunner {\n+\n+    protected ToolBox tb;\n+\n+    T7194212() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        T7194212 t = new T7194212();\n+        t.runTests();\n+    }\n+\n+    \/**\n+     * Run all methods annotated with @Test, and throw an exception if any\n+     * errors are reported..\n+     *\n+     * @throws Exception if any errors occurred\n+     *\/\n+    protected void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testSourceClassFileClash(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                                public class Outer {\n+                                    public class Inner { }\n+                                }\n+                                \"\"\");\n+\n+        Path classes = base.resolve(\"classes\");\n+\n+        Files.createDirectories(classes);\n+\n+        new JavacTask(tb)\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run()\n+                .writeAll();\n+\n+        Path test = base.resolve(\"test\");\n+        tb.writeJavaFiles(test, \"\"\"\n+                                 public class Outer$Inner extends Outer { }\n+                                 \"\"\",\n+                                 \"\"\"\n+                                 public class Test extends Outer { }\n+                                 \"\"\");\n+\n+        Path testClasses = base.resolve(\"test-classes\");\n+\n+        Files.createDirectories(testClasses);\n+\n+        new JavacTask(tb)\n+                .options(\"-classpath\", classes.toString())\n+                .outdir(testClasses)\n+                .files(tb.findJavaFiles(test))\n+                .run()\n+                .writeAll();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/flow\/T7194212.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -755,1 +755,1 @@\n-                Pattern.compile(\"(?:public\\\\s+)?(?:class|enum|interface|record)\\\\s+(\\\\w+)\");\n+                Pattern.compile(\"(?:public\\\\s+)?(?:class|enum|interface|record)\\\\s+((\\\\w|\\\\$)+)\");\n","filename":"test\/langtools\/tools\/lib\/toolbox\/ToolBox.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-static DWORD procedure(_In_ LPVOID ctxt) {\n+DWORD WINAPI procedure(_In_ LPVOID ctxt) {\n","filename":"test\/lib\/native\/testlib_threads.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import java.io.FilterOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+\/**\n+ * Benchmarks for java.lang.StackTraceElement\n+ *\/\n+@State(value = Scope.Benchmark)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(3)\n+public class StackTraceElementBench {\n+\n+    private StackTraceElement element;\n+    private Throwable throwable;\n+\n+    @Setup\n+    public void setup() {\n+        StackTraceElement[] elements = IntStream.range(0, 500)\n+                .mapToObj(i -> new StackTraceElement(\n+                        \"classloader\" + i,\n+                        \"module\" + i,\n+                        \"version\" + i,\n+                        \"class\" + i,\n+                        \"method\" + i,\n+                        \"file\" + i + \".java\",\n+                        i))\n+                .toArray(StackTraceElement[]::new);\n+        this.element = elements[0];\n+        this.throwable = new RuntimeException(\"benchmark\") {\n+            @Override\n+            public synchronized Throwable fillInStackTrace() {\n+                setStackTrace(elements);\n+                return this;\n+            }\n+        };\n+    }\n+\n+    @Benchmark\n+    public String toString() {\n+        return element.toString();\n+    }\n+\n+    @Benchmark\n+    public String printStackTrace() {\n+        StringWriter sw = new StringWriter();\n+        throwable.printStackTrace(new PrintWriter(sw));\n+        return sw.toString();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StackTraceElementBench.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -34,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -46,1 +48,1 @@\n-@Fork(jvmArgsAppend = {\"--add-exports\", \"java.base\/sun.security.util=ALL-UNNAMED\"})\n+@Fork(value = 3, jvmArgsAppend = {\"--add-exports\", \"java.base\/sun.security.util=ALL-UNNAMED\"})\n@@ -48,0 +50,2 @@\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/AlgorithmConstraintsPermits.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -41,0 +42,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -45,1 +47,3 @@\n-@Fork(jvmArgsAppend = {\"--add-exports\", \"java.base\/sun.security.util=ALL-UNNAMED\", \"-Xmx1g\"})\n+@Fork(value = 3, jvmArgsAppend = {\"--add-exports\", \"java.base\/sun.security.util=ALL-UNNAMED\", \"-Xmx1g\"})\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/CacheBench.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-@Fork(jvmArgsAppend = {\"--add-exports\", \"java.base\/sun.security.ssl=ALL-UNNAMED\", \"--add-opens\", \"java.base\/sun.security.ssl=ALL-UNNAMED\"})\n+@Fork(value = 3, jvmArgsAppend = {\"--add-exports\", \"java.base\/sun.security.ssl=ALL-UNNAMED\", \"--add-opens\", \"java.base\/sun.security.ssl=ALL-UNNAMED\"})\n@@ -37,0 +37,2 @@\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n@@ -56,1 +58,1 @@\n-        return nameOf.invoke(null,cipherSuite);\n+        return nameOf.invoke(null, cipherSuite);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/CipherSuiteBench.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -32,0 +34,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -43,0 +46,3 @@\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/DoPrivileged.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -34,0 +36,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -46,0 +49,3 @@\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/GetContext.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-@Measurement(iterations = 10, time = 1)\n+@Measurement(iterations = 5, time = 1)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/GetMessageDigest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,3 +48,3 @@\n-@Warmup(iterations = 10, time = 1, timeUnit = TimeUnit.SECONDS)\n-@Measurement(iterations = 10, time = 1, timeUnit = TimeUnit.SECONDS)\n-@Fork(jvmArgsAppend = {\"-Xms1024m\", \"-Xmx1024m\", \"-Xmn768m\", \"-XX:+UseParallelGC\"}, value = 5)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(jvmArgsAppend = {\"-Xms1024m\", \"-Xmx1024m\", \"-Xmn768m\", \"-XX:+UseParallelGC\"}, value = 3)\n@@ -53,1 +53,1 @@\n-    @Param({\"64\", \"1024\", \"16384\"})\n+    @Param({\"64\", \"16384\"})\n@@ -56,1 +56,1 @@\n-    @Param({\"md2\", \"md5\", \"SHA-1\", \"SHA-224\", \"SHA-256\", \"SHA-384\", \"SHA-512\", \"SHA3-224\", \"SHA3-256\", \"SHA3-384\", \"SHA3-512\"})\n+    @Param({\"md5\", \"SHA-1\", \"SHA-224\", \"SHA-256\", \"SHA-384\", \"SHA-512\", \"SHA3-256\", \"SHA3-512\"})\n@@ -59,1 +59,1 @@\n-    @Param({\"DEFAULT\", \"SUN\"})\n+    @Param({\"DEFAULT\"})\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/MessageDigests.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,2 +41,2 @@\n-@Warmup(iterations = 2)\n-@Measurement(iterations = 10)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n@@ -44,1 +44,1 @@\n-@Fork(jvmArgsAppend = {\"-Xms1024m\", \"-Xmx1024m\", \"-Xmn768m\", \"-XX:+UseParallelGC\"}, value = 5)\n+@Fork(jvmArgsAppend = {\"-Xms1024m\", \"-Xmx1024m\", \"-Xmn768m\", \"-XX:+UseParallelGC\"}, value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/PKCS12KeyStores.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -45,2 +45,2 @@\n-@Warmup(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 5, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/PermissionsImplies.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,0 +54,3 @@\n+@Warmup(iterations = 5, time = 5)\n+@Measurement(iterations = 5, time = 5)\n+@Fork(value = 3)\n@@ -112,3 +115,0 @@\n-    @Warmup(iterations = 5, time = 5, timeUnit = TimeUnit.SECONDS)\n-    @Measurement(iterations = 5, time = 5, timeUnit = TimeUnit.SECONDS)\n-    @Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/SSLHandshake.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -47,3 +47,3 @@\n-@Fork(1)\n-@Warmup(iterations = 1)\n-@Measurement(iterations = 4)\n+@Fork(2)\n+@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/regex\/Exponential.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import org.openjdk.jmh.annotations.Fork;\n@@ -42,0 +43,3 @@\n+@Fork(2)\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n@@ -74,2 +78,0 @@\n-    @Warmup(iterations = 3)\n-    @Measurement(iterations = 3)\n@@ -81,2 +83,0 @@\n-    @Warmup(iterations = 3)\n-    @Measurement(iterations = 3)\n@@ -88,2 +88,0 @@\n-    @Warmup(iterations = 3)\n-    @Measurement(iterations = 3)\n@@ -95,2 +93,0 @@\n-    @Warmup(iterations = 3)\n-    @Measurement(iterations = 3)\n@@ -102,2 +98,0 @@\n-    @Warmup(iterations = 3)\n-    @Measurement(iterations = 3)\n@@ -111,2 +105,0 @@\n-    @Warmup(iterations = 3)\n-    @Measurement(iterations = 3)\n@@ -121,2 +113,0 @@\n-    @Warmup(iterations = 3)\n-    @Measurement(iterations = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/regex\/PatternBench.java","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -48,2 +48,2 @@\n-@Warmup(iterations = 1)\n-@Measurement(iterations = 4)\n+@Warmup(iterations = 2, time = 3, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 3, timeUnit = TimeUnit.SECONDS)\n@@ -53,1 +53,1 @@\n-    @Param({\"16\", \"17\", \"256\", \"257\", \"4096\", \"4099\"})\n+    @Param({\"16\", \"17\", \/* \"256\", \"257\", *\/ \"4096\", \"4099\"})\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/regex\/Primality.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -78,3 +78,3 @@\n-@Fork(1)\n-@Warmup(iterations = 1)\n-@Measurement(iterations = 4)\n+@Fork(2)\n+@Warmup(iterations = 5, time = 3, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 3, timeUnit = TimeUnit.SECONDS)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/regex\/Trim.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -44,0 +47,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/AllMatcher.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -44,0 +47,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/AnyMatcher.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import org.openjdk.jmh.annotations.Fork;\n@@ -28,0 +29,1 @@\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -34,0 +36,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -51,0 +54,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/Decomposition.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -46,0 +49,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/NoneMatcher.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -44,0 +47,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/Reducers.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -42,0 +45,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/AllMatch.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -43,0 +46,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/AllMatchShort.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -42,0 +45,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/AnyMatch.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -43,0 +46,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/AnyMatchShort.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -34,0 +36,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -43,0 +46,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/Filter.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -32,0 +34,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -40,0 +43,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/FindAny.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -32,0 +34,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -40,0 +43,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/FindFirst.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -43,0 +46,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/ForEach.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -41,0 +44,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/Limit.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -34,0 +36,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -43,0 +46,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/Map.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -42,0 +45,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/NoneMatch.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -43,0 +46,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/NoneMatchShort.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -42,1 +45,4 @@\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/Reduce.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -42,0 +45,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/ReduceBase.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -32,0 +34,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -41,0 +44,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/SliceToList.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -34,0 +36,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -43,0 +46,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/Sorted.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -42,0 +45,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/SortedUnique.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -41,0 +44,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/UniqueElements.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -42,0 +45,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/value\/AllMatch.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -43,0 +46,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/value\/AllMatchShort.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -42,0 +45,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/value\/AnyMatch.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -43,0 +46,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/value\/AnyMatchShort.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -34,0 +36,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -43,0 +46,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/value\/Filter.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -32,0 +34,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -40,0 +43,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/value\/FindAny.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -32,0 +34,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -40,0 +43,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/value\/FindFirst.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -43,0 +46,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/value\/ForEach.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -41,0 +44,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/value\/Limit.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -34,0 +36,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -43,0 +46,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/value\/Map.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -42,0 +45,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/value\/NoneMatch.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -43,0 +46,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/value\/NoneMatchShort.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -42,0 +45,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/value\/Reduce.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -42,0 +45,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/value\/ReduceBase.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,3 +46,3 @@\n-@Fork(5)\n-@Warmup(iterations = 10, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 20, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(3)\n+@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/value\/SizedCount.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,3 +46,3 @@\n-@Fork(5)\n-@Warmup(iterations = 10, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 20, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(3)\n+@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/value\/SizedSum.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -32,0 +34,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -41,0 +44,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/value\/SliceToArray.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -41,0 +44,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/value\/Sorted.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -42,0 +45,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/value\/SortedUnique.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -41,0 +44,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/value\/UniqueElements.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -32,0 +34,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -44,0 +47,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/pipeline\/PipelineParMultiple.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -32,0 +34,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -44,0 +47,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/pipeline\/PipelineSeqMultiple.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -32,0 +34,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -42,0 +45,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/pipeline\/PipelineSetup.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -47,0 +50,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/pipeline\/Terminal.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -45,0 +48,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/tasks\/DictionaryWordValue\/Bulk.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -41,0 +44,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/tasks\/DictionaryWordValue\/Lambda.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -32,0 +34,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -45,0 +48,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/tasks\/IntegerDuplicate\/Bulk.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -32,0 +34,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -42,0 +45,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/tasks\/IntegerDuplicate\/Lambda.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -45,0 +48,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/tasks\/IntegerMax\/Bulk.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -43,0 +46,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/tasks\/IntegerMax\/Lambda.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -32,0 +34,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -41,0 +44,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/tasks\/IntegerMax\/Xtras.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -45,0 +48,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/tasks\/IntegerSum\/Bulk.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -43,0 +46,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/tasks\/IntegerSum\/Lambda.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -32,0 +34,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -50,0 +53,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/tasks\/PhoneCode\/Bulk.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -32,0 +34,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -48,0 +51,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/tasks\/PrimesFilter\/t100\/Bulk.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -32,0 +34,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -44,0 +47,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/tasks\/PrimesFilter\/t100\/Lambda.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -32,0 +34,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -48,0 +51,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/tasks\/PrimesFilter\/t10000\/Bulk.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -32,0 +34,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -44,0 +47,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/tasks\/PrimesFilter\/t10000\/Lambda.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -46,0 +49,3 @@\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/tasks\/PrimesSieve\/Bulk.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -31,0 +33,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -46,0 +49,3 @@\n+@Warmup(iterations = 4, time = 2)\n+@Measurement(iterations = 4, time = 2)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lambda\/capture\/Capture0.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -29,0 +31,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -40,0 +43,3 @@\n+@Warmup(iterations = 4, time = 2)\n+@Measurement(iterations = 4, time = 2)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lambda\/capture\/Capture2.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -29,0 +31,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -39,0 +42,3 @@\n+@Warmup(iterations = 4, time = 2)\n+@Measurement(iterations = 4, time = 2)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lambda\/capture\/CaptureMR.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -32,0 +34,3 @@\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n@@ -42,0 +47,3 @@\n+@Warmup(iterations = 4, time = 2)\n+@Measurement(iterations = 4, time = 2)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lambda\/chain\/ChainAnonymCap0.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -32,0 +34,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -42,0 +45,3 @@\n+@Warmup(iterations = 4, time = 2)\n+@Measurement(iterations = 4, time = 2)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lambda\/chain\/ChainAnonymCap1.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -32,0 +34,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -42,0 +45,3 @@\n+@Warmup(iterations = 4, time = 2)\n+@Measurement(iterations = 4, time = 2)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lambda\/chain\/ChainAnonymCap4.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -32,0 +34,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -42,0 +45,3 @@\n+@Warmup(iterations = 4, time = 2)\n+@Measurement(iterations = 4, time = 2)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lambda\/chain\/ChainLambdaCap0.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -32,0 +34,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -42,0 +45,3 @@\n+@Warmup(iterations = 4, time = 2)\n+@Measurement(iterations = 4, time = 2)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lambda\/chain\/ChainLambdaCap1.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -32,0 +34,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -42,0 +45,3 @@\n+@Warmup(iterations = 4, time = 2)\n+@Measurement(iterations = 4, time = 2)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lambda\/chain\/ChainLambdaCap4.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -32,0 +34,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -42,0 +45,3 @@\n+@Warmup(iterations = 4, time = 2)\n+@Measurement(iterations = 4, time = 2)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lambda\/chain\/ChainMrefBound.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -32,0 +34,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -42,0 +45,3 @@\n+@Warmup(iterations = 4, time = 2)\n+@Measurement(iterations = 4, time = 2)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lambda\/chain\/ChainMrefUnbound.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -30,0 +32,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -41,0 +44,3 @@\n+@Warmup(iterations = 4, time = 2)\n+@Measurement(iterations = 4, time = 2)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lambda\/invoke\/AckermannI.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -30,0 +32,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -41,0 +44,3 @@\n+@Warmup(iterations = 4, time = 2)\n+@Measurement(iterations = 4, time = 2)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lambda\/invoke\/AckermannL.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -31,0 +33,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -42,0 +45,3 @@\n+@Warmup(iterations = 4, time = 2)\n+@Measurement(iterations = 4, time = 2)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lambda\/invoke\/Function0.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -34,0 +36,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -47,0 +50,3 @@\n+@Warmup(iterations = 4, time = 2)\n+@Measurement(iterations = 4, time = 2)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lambda\/invoke\/Function1.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import org.openjdk.jmh.annotations.Fork;\n@@ -28,0 +29,1 @@\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -34,0 +36,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -48,0 +51,3 @@\n+@Warmup(iterations = 4, time = 2)\n+@Measurement(iterations = 4, time = 2)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lambda\/invoke\/Morph0.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import org.openjdk.jmh.annotations.Fork;\n@@ -28,0 +29,1 @@\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -34,0 +36,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -48,0 +51,3 @@\n+@Warmup(iterations = 4, time = 2)\n+@Measurement(iterations = 4, time = 2)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lambda\/invoke\/Morph1.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import org.openjdk.jmh.annotations.Fork;\n@@ -28,0 +29,1 @@\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -34,0 +36,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -47,0 +50,3 @@\n+@Warmup(iterations = 4, time = 2)\n+@Measurement(iterations = 4, time = 2)\n+@Fork(value = 3)\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lambda\/invoke\/Morph2.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}