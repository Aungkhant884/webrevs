{"files":[{"patch":"@@ -90,1 +90,1 @@\n-  Thread *thread = Thread::current();\n+  JavaThread *thread = JavaThread::current();\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2203,1 +2203,1 @@\n-  push_jni_handle_block();\n+  JNIHandleMark jhm(thread);\n@@ -2322,3 +2322,0 @@\n-  \/\/ Remove the JNI handle block after the ciEnv destructor has run in\n-  \/\/ the previous block.\n-  pop_jni_handle_block();\n@@ -2485,32 +2482,0 @@\n-\/\/ ------------------------------------------------------------------\n-\/\/ CompileBroker::push_jni_handle_block\n-\/\/\n-\/\/ Push on a new block of JNI handles.\n-void CompileBroker::push_jni_handle_block() {\n-  JavaThread* thread = JavaThread::current();\n-\n-  \/\/ Allocate a new block for JNI handles.\n-  \/\/ Inlined code from jni_PushLocalFrame()\n-  JNIHandleBlock* java_handles = thread->active_handles();\n-  JNIHandleBlock* compile_handles = JNIHandleBlock::allocate_block(thread);\n-  assert(compile_handles != NULL && java_handles != NULL, \"should not be NULL\");\n-  compile_handles->set_pop_frame_link(java_handles);  \/\/ make sure java handles get gc'd.\n-  thread->set_active_handles(compile_handles);\n-}\n-\n-\n-\/\/ ------------------------------------------------------------------\n-\/\/ CompileBroker::pop_jni_handle_block\n-\/\/\n-\/\/ Pop off the current block of JNI handles.\n-void CompileBroker::pop_jni_handle_block() {\n-  JavaThread* thread = JavaThread::current();\n-\n-  \/\/ Release our JNI handle block\n-  JNIHandleBlock* compile_handles = thread->active_handles();\n-  JNIHandleBlock* java_handles = compile_handles->pop_frame_link();\n-  thread->set_active_handles(java_handles);\n-  compile_handles->set_pop_frame_link(NULL);\n-  JNIHandleBlock::release_block(compile_handles, thread); \/\/ may block\n-}\n-\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":1,"deletions":36,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -262,2 +262,0 @@\n-  static void push_jni_handle_block();\n-  static void pop_jni_handle_block();\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,3 +45,0 @@\n-  \/\/ Setup handle area\n-  set_active_handles(JNIHandleBlock::allocate_block());\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/concurrentGCThread.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -58,47 +58,0 @@\n-\/\/ JNIHandle management\n-\n-\/\/ ------------------------------------------------------------------\n-\/\/ push_jni_handle_block\n-\/\/\n-\/\/ Push on a new block of JNI handles.\n-static void push_jni_handle_block(JavaThread* const thread) {\n-  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(thread));\n-\n-  \/\/ Allocate a new block for JNI handles.\n-  \/\/ Inlined code from jni_PushLocalFrame()\n-  JNIHandleBlock* prev_handles = thread->active_handles();\n-  JNIHandleBlock* entry_handles = JNIHandleBlock::allocate_block(thread);\n-  assert(entry_handles != NULL && prev_handles != NULL, \"should not be NULL\");\n-  entry_handles->set_pop_frame_link(prev_handles);  \/\/ make sure prev handles get gc'd.\n-  thread->set_active_handles(entry_handles);\n-}\n-\n-\/\/ ------------------------------------------------------------------\n-\/\/ pop_jni_handle_block\n-\/\/\n-\/\/ Pop off the current block of JNI handles.\n-static void pop_jni_handle_block(JavaThread* const thread) {\n-  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(thread));\n-\n-  \/\/ Release our JNI handle block\n-  JNIHandleBlock* entry_handles = thread->active_handles();\n-  JNIHandleBlock* prev_handles = entry_handles->pop_frame_link();\n-  \/\/ restore\n-  thread->set_active_handles(prev_handles);\n-  entry_handles->set_pop_frame_link(NULL);\n-  JNIHandleBlock::release_block(entry_handles, thread); \/\/ may block\n-}\n-\n-class JNIHandleBlockManager : public StackObj {\n- private:\n-  JavaThread* const _thread;\n- public:\n-  JNIHandleBlockManager(JavaThread* thread) : _thread(thread) {\n-    push_jni_handle_block(_thread);\n-  }\n-\n-  ~JNIHandleBlockManager() {\n-    pop_jni_handle_block(_thread);\n-  }\n-};\n-\n@@ -226,1 +179,1 @@\n-  JNIHandleBlockManager jni_handle_management(THREAD);\n+  JNIHandleMark jni_handle_management(THREAD);\n@@ -497,1 +450,1 @@\n-  JNIHandleBlockManager jni_handle_management(THREAD);\n+  JNIHandleMark jni_handle_management(THREAD);\n","filename":"src\/hotspot\/share\/jfr\/dcmd\/jfrDcmds.cpp","additions":2,"deletions":49,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-  return t->active_handles()->allocate_handle(obj);\n+  return t->active_handles()->allocate_handle(t, obj);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -902,1 +902,1 @@\n-    ScopeValue *klass_sv = new ConstantOopWriteValue(JNIHandles::make_local(Thread::current(), javaMirror));\n+    ScopeValue *klass_sv = new ConstantOopWriteValue(JNIHandles::make_local(javaMirror));\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,23 +89,0 @@\n-void JNIHandleMark::push_jni_handle_block(JavaThread* thread) {\n-  if (thread != NULL) {\n-    \/\/ Allocate a new block for JNI handles.\n-    \/\/ Inlined code from jni_PushLocalFrame()\n-    JNIHandleBlock* java_handles = thread->active_handles();\n-    JNIHandleBlock* compile_handles = JNIHandleBlock::allocate_block(thread);\n-    assert(compile_handles != NULL && java_handles != NULL, \"should not be NULL\");\n-    compile_handles->set_pop_frame_link(java_handles);\n-    thread->set_active_handles(compile_handles);\n-  }\n-}\n-\n-void JNIHandleMark::pop_jni_handle_block(JavaThread* thread) {\n-  if (thread != NULL) {\n-    \/\/ Release our JNI handle block\n-    JNIHandleBlock* compile_handles = thread->active_handles();\n-    JNIHandleBlock* java_handles = compile_handles->pop_frame_link();\n-    thread->set_active_handles(java_handles);\n-    compile_handles->set_pop_frame_link(NULL);\n-    JNIHandleBlock::release_block(compile_handles, thread); \/\/ may block\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -176,11 +176,0 @@\n-class JNIHandleMark : public StackObj {\n-  JavaThread* _thread;\n-  public:\n-    JNIHandleMark(JavaThread* thread) : _thread(thread) { push_jni_handle_block(thread); }\n-    ~JNIHandleMark() { pop_jni_handle_block(_thread); }\n-\n-  private:\n-    static void push_jni_handle_block(JavaThread* thread);\n-    static void pop_jni_handle_block(JavaThread* thread);\n-};\n-\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.hpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -642,5 +642,2 @@\n-  JNIHandleBlock* old_handles = thread->active_handles();\n-  JNIHandleBlock* new_handles = JNIHandleBlock::allocate_block(thread);\n-  assert(new_handles != NULL, \"should not be NULL\");\n-  new_handles->set_pop_frame_link(old_handles);\n-  thread->set_active_handles(new_handles);\n+\n+  thread->push_jni_handle_block();\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1513,1 +1513,1 @@\n-    array[idx] = JNIHandles::make_local(Thread::current(), _tbl->at(idx).resolve());\n+    array[idx] = JNIHandles::make_local(_tbl->at(idx).resolve());\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,3 +144,0 @@\n-#if 0\n-  JNIHandleBlock* _hblock;\n-#endif\n@@ -152,6 +149,0 @@\n-#if 0\n-    _hblock = thread->active_handles();\n-    _hblock->clear_thoroughly(); \/\/ so we can be safe\n-#else\n-    \/\/ we want to use the code above - but that needs the JNIHandle changes - later...\n-    \/\/ for now, steal JNI push local frame code\n@@ -165,6 +156,1 @@\n-    JNIHandleBlock* old_handles = thread->active_handles();\n-    JNIHandleBlock* new_handles = JNIHandleBlock::allocate_block(thread);\n-    assert(new_handles != NULL, \"should not be NULL\");\n-    new_handles->set_pop_frame_link(old_handles);\n-    thread->set_active_handles(new_handles);\n-#endif\n+    thread->push_jni_handle_block();\n@@ -176,14 +162,1 @@\n-#if 0\n-    _hblock->clear(); \/\/ for consistency with future correct behavior\n-#else\n-    \/\/ we want to use the code above - but that needs the JNIHandle changes - later...\n-    \/\/ for now, steal JNI pop local frame code\n-    JNIHandleBlock* old_handles = _thread->active_handles();\n-    JNIHandleBlock* new_handles = old_handles->pop_frame_link();\n-    assert(new_handles != NULL, \"should not be NULL\");\n-    _thread->set_active_handles(new_handles);\n-    \/\/ Note that we set the pop_frame_link to NULL explicitly, otherwise\n-    \/\/ the release_block call will release the blocks.\n-    old_handles->set_pop_frame_link(NULL);\n-    JNIHandleBlock::release_block(old_handles, _thread); \/\/ may block\n-#endif\n+    _thread->pop_jni_handle_block();\n@@ -199,5 +172,0 @@\n-#if 0\n-  jobject to_jobject(oop obj) { return obj == NULL? NULL : _hblock->allocate_handle_fast(obj); }\n-#else\n-  \/\/ we want to use the code above - but that needs the JNIHandle changes - later...\n-  \/\/ for now, use regular make_local\n@@ -205,1 +173,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":2,"deletions":35,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-  return make_local(Thread::current(), obj);\n+  return make_local(JavaThread::current(), obj);\n@@ -63,1 +63,1 @@\n-jobject JNIHandles::make_local(Thread* thread, oop obj, AllocFailType alloc_failmode) {\n+jobject JNIHandles::make_local(JavaThread* thread, oop obj, AllocFailType alloc_failmode) {\n@@ -68,1 +68,0 @@\n-    assert(thread->is_Java_thread(), \"not a Java thread\");\n@@ -70,1 +69,1 @@\n-    return thread->active_handles()->allocate_handle(obj, alloc_failmode);\n+    return thread->active_handles()->allocate_handle(thread, obj, alloc_failmode);\n@@ -190,1 +189,1 @@\n-jobjectRefType JNIHandles::handle_type(Thread* thread, jobject handle) {\n+jobjectRefType JNIHandles::handle_type(JavaThread* thread, jobject handle) {\n@@ -208,3 +207,1 @@\n-      if (is_local_handle(thread, handle) ||\n-          (thread->is_Java_thread() &&\n-           is_frame_handle(JavaThread::cast(thread), handle))) {\n+      if (is_local_handle(thread, handle) || is_frame_handle(thread, handle)) {\n@@ -223,1 +220,1 @@\n-bool JNIHandles::is_local_handle(Thread* thread, jobject handle) {\n+bool JNIHandles::is_local_handle(JavaThread* thread, jobject handle) {\n@@ -308,6 +305,1 @@\n-\n-int             JNIHandleBlock::_blocks_allocated     = 0;\n-JNIHandleBlock* JNIHandleBlock::_block_free_list      = NULL;\n-#ifndef PRODUCT\n-JNIHandleBlock* JNIHandleBlock::_block_list           = NULL;\n-#endif\n+int JNIHandleBlock::_blocks_allocated = 0;\n@@ -346,2 +338,4 @@\n-JNIHandleBlock* JNIHandleBlock::allocate_block(Thread* thread, AllocFailType alloc_failmode)  {\n-  assert(thread == NULL || thread == Thread::current(), \"sanity check\");\n+JNIHandleBlock* JNIHandleBlock::allocate_block(JavaThread* thread, AllocFailType alloc_failmode)  {\n+  \/\/ The VM thread can allocate a handle block in behalf of another thread during a safepoint.\n+  assert(thread == NULL || thread == Thread::current() || SafepointSynchronize::is_at_safepoint(),\n+         \"sanity check\");\n@@ -354,17 +348,6 @@\n-  }\n-  else {\n-    \/\/ locking with safepoint checking introduces a potential deadlock:\n-    \/\/ - we would hold JNIHandleBlockFreeList_lock and then Threads_lock\n-    \/\/ - another would hold Threads_lock (jni_AttachCurrentThread) and then\n-    \/\/   JNIHandleBlockFreeList_lock (JNIHandleBlock::allocate_block)\n-    MutexLocker ml(JNIHandleBlockFreeList_lock,\n-                   Mutex::_no_safepoint_check_flag);\n-    if (_block_free_list == NULL) {\n-      \/\/ Allocate new block\n-      if (alloc_failmode == AllocFailStrategy::RETURN_NULL) {\n-        block = new (std::nothrow) JNIHandleBlock();\n-        if (block == NULL) {\n-          return NULL;\n-        }\n-      } else {\n-        block = new JNIHandleBlock();\n+  } else {\n+    \/\/ Allocate new block\n+    if (alloc_failmode == AllocFailStrategy::RETURN_NULL) {\n+      block = new (std::nothrow) JNIHandleBlock();\n+      if (block == NULL) {\n+        return NULL;\n@@ -372,7 +355,0 @@\n-      _blocks_allocated++;\n-      block->zap();\n-      #ifndef PRODUCT\n-      \/\/ Link new block to list of all allocated blocks\n-      block->_block_list_link = _block_list;\n-      _block_list = block;\n-      #endif\n@@ -380,3 +356,1 @@\n-      \/\/ Get block from free list\n-      block = _block_free_list;\n-      _block_free_list = _block_free_list->_next;\n+      block = new JNIHandleBlock();\n@@ -384,0 +358,2 @@\n+    Atomic::inc(&_blocks_allocated);\n+    block->zap();\n@@ -397,1 +373,1 @@\n-void JNIHandleBlock::release_block(JNIHandleBlock* block, Thread* thread) {\n+void JNIHandleBlock::release_block(JNIHandleBlock* block, JavaThread* thread) {\n@@ -418,14 +394,2 @@\n-    \/\/ Return blocks to free list\n-    \/\/ locking with safepoint checking introduces a potential deadlock:\n-    \/\/ - we would hold JNIHandleBlockFreeList_lock and then Threads_lock\n-    \/\/ - another would hold Threads_lock (jni_AttachCurrentThread) and then\n-    \/\/   JNIHandleBlockFreeList_lock (JNIHandleBlock::allocate_block)\n-    MutexLocker ml(JNIHandleBlockFreeList_lock,\n-                   Mutex::_no_safepoint_check_flag);\n-    while (block != NULL) {\n-      block->zap();\n-      JNIHandleBlock* next = block->_next;\n-      block->_next = _block_free_list;\n-      _block_free_list = block;\n-      block = next;\n-    }\n+    Atomic::dec(&_blocks_allocated);\n+    delete block;\n@@ -471,1 +435,1 @@\n-jobject JNIHandleBlock::allocate_handle(oop obj, AllocFailType alloc_failmode) {\n+jobject JNIHandleBlock::allocate_handle(JavaThread* caller, oop obj, AllocFailType alloc_failmode) {\n@@ -519,1 +483,1 @@\n-    return allocate_handle(obj, alloc_failmode);\n+    return allocate_handle(caller, obj, alloc_failmode);\n@@ -526,5 +490,1 @@\n-    \/\/ Append new block\n-    Thread* thread = Thread::current();\n-    Handle obj_handle(thread, obj);\n-    \/\/ This can block, so we need to preserve obj across call.\n-    _last->_next = JNIHandleBlock::allocate_block(thread, alloc_failmode);\n+    _last->_next = JNIHandleBlock::allocate_block(caller, alloc_failmode);\n@@ -536,1 +496,0 @@\n-    obj = obj_handle();\n@@ -538,1 +497,1 @@\n-  return allocate_handle(obj, alloc_failmode);  \/\/ retry\n+  return allocate_handle(caller, obj, alloc_failmode);  \/\/ retry\n@@ -615,43 +574,0 @@\n-\n-\n-#ifndef PRODUCT\n-\n-bool JNIHandles::is_local_handle(jobject handle) {\n-  return JNIHandleBlock::any_contains(handle);\n-}\n-\n-bool JNIHandleBlock::any_contains(jobject handle) {\n-  assert(handle != NULL, \"precondition\");\n-  for (JNIHandleBlock* current = _block_list; current != NULL; current = current->_block_list_link) {\n-    if (current->contains(handle)) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-void JNIHandleBlock::print_statistics() {\n-  int used_blocks = 0;\n-  int free_blocks = 0;\n-  int used_handles = 0;\n-  int free_handles = 0;\n-  JNIHandleBlock* block = _block_list;\n-  while (block != NULL) {\n-    if (block->_top > 0) {\n-      used_blocks++;\n-    } else {\n-      free_blocks++;\n-    }\n-    used_handles += block->_top;\n-    free_handles += (block_size_in_oops - block->_top);\n-    block = block->_block_list_link;\n-  }\n-  tty->print_cr(\"JNIHandleBlocks statistics\");\n-  tty->print_cr(\"- blocks allocated: %d\", used_blocks + free_blocks);\n-  tty->print_cr(\"- blocks in use:    %d\", used_blocks);\n-  tty->print_cr(\"- blocks free:      %d\", free_blocks);\n-  tty->print_cr(\"- handles in use:   %d\", used_handles);\n-  tty->print_cr(\"- handles free:     %d\", free_handles);\n-}\n-\n-#endif\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.cpp","additions":27,"deletions":111,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n-  static jobject make_local(Thread* thread, oop obj,  \/\/ Faster version when current thread is known\n+  static jobject make_local(JavaThread* thread, oop obj,  \/\/ Faster version when current thread is known\n@@ -107,1 +107,1 @@\n-  static bool is_local_handle(Thread* thread, jobject handle);\n+  static bool is_local_handle(JavaThread* thread, jobject handle);\n@@ -114,5 +114,0 @@\n-#ifndef PRODUCT\n-  \/\/ Is handle from any local block of any thread?\n-  static bool is_local_handle(jobject handle);\n-#endif\n-\n@@ -120,1 +115,1 @@\n-  static jobjectRefType handle_type(Thread* thread, jobject handle);\n+  static jobjectRefType handle_type(JavaThread* thread, jobject handle);\n@@ -148,0 +143,1 @@\n+  int             _allocate_before_rebuild;     \/\/ Number of blocks to allocate before rebuilding free list\n@@ -155,1 +151,0 @@\n-  int             _allocate_before_rebuild;     \/\/ Number of blocks to allocate before rebuilding free list\n@@ -159,7 +154,0 @@\n-\n-  #ifndef PRODUCT\n-  JNIHandleBlock* _block_list_link;             \/\/ Link for list below\n-  static JNIHandleBlock* _block_list;           \/\/ List of all allocated blocks (for debugging only)\n-  #endif\n-\n-  static JNIHandleBlock* _block_free_list;      \/\/ Free list of currently unused blocks\n@@ -179,1 +167,1 @@\n-  jobject allocate_handle(oop obj, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);\n+  jobject allocate_handle(JavaThread* caller, oop obj, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);\n@@ -182,2 +170,2 @@\n-  static JNIHandleBlock* allocate_block(Thread* thread = NULL, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);\n-  static void release_block(JNIHandleBlock* block, Thread* thread = NULL);\n+  static JNIHandleBlock* allocate_block(JavaThread* thread = NULL, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);\n+  static void release_block(JNIHandleBlock* block, JavaThread* thread = NULL);\n@@ -206,4 +194,0 @@\n-  #ifndef PRODUCT\n-  static bool any_contains(jobject handle);     \/\/ Does any block currently in use contain handle\n-  static void print_statistics();\n-  #endif\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.hpp","additions":8,"deletions":24,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-Mutex*   JNIHandleBlockFreeList_lock  = NULL;\n@@ -262,1 +261,0 @@\n-  def(JNIHandleBlockFreeList_lock  , PaddedMutex  , nosafepoint-1);      \/\/ handles are used by VM thread\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-extern Mutex*   JNIHandleBlockFreeList_lock;     \/\/ a lock on the JNI handle block free list\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -237,1 +237,0 @@\n-  this->set_active_handles(JNIHandleBlock::allocate_block());\n","filename":"src\/hotspot\/share\/runtime\/nonJavaThread.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1172,7 +1172,0 @@\n-#ifndef PRODUCT\n-    \/\/ we don't keep the block list in product mode\n-    if (JNIHandles::is_local_handle((jobject) addr)) {\n-      st->print_cr(INTPTR_FORMAT \" is a local jni handle\", p2i(addr));\n-      return;\n-    }\n-#endif\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -223,2 +223,0 @@\n-  set_active_handles(NULL);\n-  set_free_handle_block(NULL);\n@@ -539,3 +537,0 @@\n-  if (active_handles() != NULL) {\n-    active_handles()->oops_do(f);\n-  }\n@@ -1006,0 +1001,2 @@\n+  _active_handles(NULL),\n+  _free_handle_block(NULL),\n@@ -1933,0 +1930,22 @@\n+\/\/ Push on a new block of JNI handles.\n+void JavaThread::push_jni_handle_block() {\n+  \/\/ Allocate a new block for JNI handles.\n+  \/\/ Inlined code from jni_PushLocalFrame()\n+  JNIHandleBlock* old_handles = active_handles();\n+  JNIHandleBlock* new_handles = JNIHandleBlock::allocate_block(this);\n+  assert(old_handles != NULL && new_handles != NULL, \"should not be NULL\");\n+  new_handles->set_pop_frame_link(old_handles);  \/\/ make sure java handles get gc'd.\n+  set_active_handles(new_handles);\n+}\n+\n+\/\/ Pop off the current block of JNI handles.\n+void JavaThread::pop_jni_handle_block() {\n+  \/\/ Release our JNI handle block\n+  JNIHandleBlock* old_handles = active_handles();\n+  JNIHandleBlock* new_handles = old_handles->pop_frame_link();\n+  assert(new_handles != nullptr, \"should never set active handles to null\");\n+  set_active_handles(new_handles);\n+  old_handles->set_pop_frame_link(NULL);\n+  JNIHandleBlock::release_block(old_handles, this);\n+}\n+\n@@ -1940,0 +1959,4 @@\n+  if (active_handles() != NULL) {\n+    active_handles()->oops_do(f);\n+  }\n+\n@@ -2833,1 +2856,1 @@\n-    Thread* vmthread = VMThread::vm_thread();\n+    VMThread* vmthread = VMThread::vm_thread();\n@@ -2845,1 +2868,1 @@\n-      while (vmthread->active_handles() == NULL) {\n+      while (!vmthread->is_running()) {\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":30,"deletions":7,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -241,6 +241,0 @@\n-  \/\/ Active_handles points to a block of handles\n-  JNIHandleBlock* _active_handles;\n-\n-  \/\/ One-element thread local free list\n-  JNIHandleBlock* _free_handle_block;\n-\n@@ -419,6 +413,0 @@\n-  \/\/ JNI handle support\n-  JNIHandleBlock* active_handles() const         { return _active_handles; }\n-  void set_active_handles(JNIHandleBlock* block) { _active_handles = block; }\n-  JNIHandleBlock* free_handle_block() const      { return _free_handle_block; }\n-  void set_free_handle_block(JNIHandleBlock* block) { _free_handle_block = block; }\n-\n@@ -610,1 +598,0 @@\n-  static ByteSize active_handles_offset()        { return byte_offset_of(Thread, _active_handles); }\n@@ -749,0 +736,7 @@\n+\n+  \/\/ Active_handles points to a block of handles\n+  JNIHandleBlock* _active_handles;\n+\n+  \/\/ One-element thread local free list\n+  JNIHandleBlock* _free_handle_block;\n+\n@@ -776,0 +770,9 @@\n+  \/\/ JNI handle support\n+  JNIHandleBlock* active_handles() const         { return _active_handles; }\n+  void set_active_handles(JNIHandleBlock* block) { _active_handles = block; }\n+  JNIHandleBlock* free_handle_block() const      { return _free_handle_block; }\n+  void set_free_handle_block(JNIHandleBlock* block) { _free_handle_block = block; }\n+\n+  void push_jni_handle_block();\n+  void pop_jni_handle_block();\n+\n@@ -1286,0 +1289,2 @@\n+  static ByteSize active_handles_offset()        { return byte_offset_of(JavaThread, _active_handles); }\n+\n@@ -1748,0 +1753,9 @@\n+class JNIHandleMark : public StackObj {\n+  JavaThread* _thread;\n+ public:\n+  JNIHandleMark(JavaThread* thread) : _thread(thread) {\n+    thread->push_jni_handle_block();\n+  }\n+  ~JNIHandleMark() { _thread->pop_jni_handle_block(); }\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":27,"deletions":13,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -707,1 +707,0 @@\n-  nonstatic_field(Thread,                      _active_handles,                               JNIHandleBlock*)                       \\\n@@ -731,0 +730,1 @@\n+  nonstatic_field(JavaThread,                  _active_handles,                               JNIHandleBlock*)                       \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-VMThread::VMThread() : NamedThread() {\n+VMThread::VMThread() : NamedThread(), _is_running(false) {\n@@ -155,1 +155,1 @@\n-  \/\/ Notify_lock wait checks on active_handles() to rewait in\n+  \/\/ Notify_lock wait checks on is_running() to rewait in\n@@ -158,1 +158,1 @@\n-  this->set_active_handles(JNIHandleBlock::allocate_block());\n+  Atomic::store(&_is_running, true);\n","filename":"src\/hotspot\/share\/runtime\/vmThread.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -62,0 +63,2 @@\n+  volatile bool _is_running;\n+\n@@ -87,0 +90,1 @@\n+  bool is_running() const { return Atomic::load(&_is_running); }\n","filename":"src\/hotspot\/share\/runtime\/vmThread.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+  private static AddressField activeHandlesField;\n@@ -98,0 +99,1 @@\n+    activeHandlesField = type.getAddressField(\"_active_handles\");\n@@ -412,0 +414,8 @@\n+  public JNIHandleBlock activeHandles() {\n+    Address a = activeHandlesField.getAddress(addr);\n+    if (a == null) {\n+      return null;\n+    }\n+    return new JNIHandleBlock(a);\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/JavaThread.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-  private static AddressField activeHandlesField;\n@@ -62,1 +61,0 @@\n-    activeHandlesField = typeThread.getAddressField(\"_active_handles\");\n@@ -84,8 +82,0 @@\n-  public JNIHandleBlock activeHandles() {\n-    Address a = activeHandlesField.getAddress(addr);\n-    if (a == null) {\n-      return null;\n-    }\n-    return new JNIHandleBlock(a);\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/Thread.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"}]}