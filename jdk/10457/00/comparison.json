{"files":[{"patch":"@@ -1039,5 +1039,0 @@\n-  vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat001\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat002\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat003\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat004\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat005\/TestDescription.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.quick-groups","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,118 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.GetThreadState;\n-\n-import java.io.PrintStream;\n-\n-public class thrstat001 {\n-\n-    public static final int STATUS_RUNNING = 0;\n-    public static final int STATUS_MONITOR = 1;\n-    public static final int STATUS_WAIT    = 2;\n-\n-    native static void checkStatus(int statInd);\n-    native static int getRes();\n-\n-    public static void main(String[] args) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        System.exit(run(args, System.out) + 95\/*STATUS_TEMP*\/);\n-    }\n-\n-    public static int run(String argv[], PrintStream ref) {\n-        thrstat001 t = new thrstat001();\n-        t.meth();\n-        return getRes();\n-    }\n-\n-    \/\/ barriers for testing thread status values\n-    public static Lock startingMonitor = new Lock();\n-    public static Object blockingMonitor = new Object();\n-    public static Lock endingMonitor = new Lock();\n-\n-    void meth() {\n-        thrstat001a thr = new thrstat001a(\"thr1\");\n-\n-        synchronized (blockingMonitor) {\n-            synchronized (startingMonitor) {\n-                startingMonitor.val = 0;\n-                thr.start();\n-                while (startingMonitor.val == 0) {\n-                    try {\n-                        startingMonitor.wait();\n-                    } catch (InterruptedException e) {\n-                        throw new Error(\"Unexpected: \" + e);\n-                    }\n-                }\n-            }\n-            Thread.yield();\n-            checkStatus(STATUS_MONITOR);\n-        }\n-\n-        synchronized (endingMonitor) {\n-            checkStatus(STATUS_WAIT);\n-            endingMonitor.val++;\n-            endingMonitor.notify();\n-        }\n-\n-        try {\n-            thr.join();\n-        } catch (InterruptedException e) {\n-            throw new Error(\"Unexpected: \" + e);\n-        }\n-   }\n-\n-    static class Lock {\n-        public int val = 0;\n-    }\n-}\n-\n-class thrstat001a extends Thread {\n-\n-    public thrstat001a(String name) {\n-        super(name);\n-    }\n-\n-    public void run() {\n-        synchronized (thrstat001.endingMonitor) {\n-            thrstat001.checkStatus(thrstat001.STATUS_RUNNING);\n-            synchronized (thrstat001.startingMonitor) {\n-                thrstat001.startingMonitor.val++;\n-                thrstat001.startingMonitor.notifyAll();\n-            }\n-\n-            synchronized (thrstat001.blockingMonitor) {\n-            }\n-\n-            thrstat001.endingMonitor.val = 0;\n-            while (thrstat001.endingMonitor.val == 0) {\n-                try {\n-                    thrstat001.endingMonitor.wait();\n-                } catch (InterruptedException e) {\n-                    throw new Error(\"Unexpected: \" + e);\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat001.java","additions":0,"deletions":118,"binary":false,"changes":118,"status":"deleted"},{"patch":"@@ -1,80 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/GetThreadState\/thrstat001.\n- * VM Testbase keywords: [quick, jpda, jvmti, onload_only_logic, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI function GetThreadState.  Java program\n- *     launchs thread and 3 times calls a native method checkStatus. This\n- *     method calls GetThreadState and checks if the returned value is\n- *     correct.\n- *     The test exercises JVMTI function GetThreadState.  Java program\n- *     launches a thread and 3 times calls a native method checkStatus.\n- *     This method calls GetThreadState and checks if the returned value is:\n- *       - JVMTI_THREAD_STATE_RUNNABLE\n- *               if thread is runnable\n- *       - JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER\n- *               if thread is waiting to enter sync. block\n- *       - JVMTI_THREAD_STATE_IN_OBJECT_WAIT\n- *               if thread is waiting by object.wait()\n- *     The test also enables JVMPI_EVENT_METHOD_ENTRY and JVMPI_EVENT_METHOD_EXIT\n- *     events and checks if GetThreadState returns JVMPI_THREAD_RUNNABLE for\n- *     their threads.\n- *     Failing criteria for the test are:\n- *       - value returned by GetThreadState does not match expected value;\n- *       - failures of used JVMTI functions.\n- * COMMENTS\n- *     Converted the test to use GetThreadState instead of GetThreadStatus.\n- *     The test was updated to be more precise in its thread state transitions.\n- *     Fixed according to 4387521 bug.\n- *     To fix bug 4463667,\n- *         1) two code fragments with \"Thread.sleep(500);\" are replaced\n- *            with following ones:\n- *                 Object obj = new Object();\n- *                 *\n- *                 *\n- *                 synchronized (obj) {\n- *                     obj.wait(500);\n- *                 }\n- *         2) extra waiting time\n- *                 synchronized (obj) {\n- *                     obj.wait(500);\n- *                 }\n- *            is added to get waiting time certainly after \"contendCount\"\n- *            is set to 1.\n- *     Fixed according to 4669812 bug.\n- *     Ported from JVMDI.\n- *     Fixed according to 4925857 bug:\n- *       - rearranged synchronization of tested thread\n- *       - enhanced descripton\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:thrstat001 nsk.jvmti.GetThreadState.thrstat001\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat001\/TestDescription.java","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"thrstat001.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat001\/libthrstat001.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,256 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED  0\n-#define STATUS_FAILED  2\n-#define WAIT_START 100\n-#define WAIT_TIME (2*60*1000)\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiCapabilities caps;\n-static jvmtiEventCallbacks callbacks;\n-static jrawMonitorID access_lock;\n-static jrawMonitorID wait_lock;\n-static jint result = PASSED;\n-static jthread thr_ptr = NULL;\n-\n-static jint state[] = {\n-    JVMTI_THREAD_STATE_RUNNABLE,\n-    JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER,\n-    JVMTI_THREAD_STATE_IN_OBJECT_WAIT\n-};\n-\n-static void\n-lock(const char* func_name, jrawMonitorID lock) {\n-    jvmtiError err = jvmti->RawMonitorEnter(lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"%s: unexpected error in RawMonitorEnter: %s (%d)\\n\",\n-               func_name, TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-static void\n-unlock(const char* func_name, jrawMonitorID lock) {\n-    jvmtiError err = jvmti->RawMonitorExit(lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"%s: unexpected error in RawMonitorExit: %s (%d)\\n\",\n-               func_name, TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-static void\n-wait(const char* func_name, jrawMonitorID lock, jint millis) {\n-    jvmtiError err = jvmti->RawMonitorWait(lock, (jlong)millis);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"%s: unexpected error in RawMonitorWait: %s (%d)\\n\",\n-               func_name, TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-static void\n-set_notification_mode(const char* event_name,\n-                      jvmtiEventMode mode,\n-                      jvmtiEvent event_type,\n-                      jthread event_thread) {\n-    const char* action = (mode == JVMTI_ENABLE) ? \"enable\" : \"disable\";\n-    jvmtiError err = jvmti->SetEventNotificationMode(mode, event_type, event_thread);\n-\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to %s %s event: %s (%d)\\n\",\n-               action, event_name, TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-void JNICALL VMInit(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thr) {\n-    set_notification_mode(\"JVMTI_EVENT_THREAD_START\", JVMTI_ENABLE,\n-                          JVMTI_EVENT_THREAD_START, NULL);\n-}\n-\n-void JNICALL\n-ThreadStart(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thread) {\n-    jvmtiError err;\n-    jvmtiThreadInfo thrInfo;\n-\n-    lock(\"ThreadStart\", access_lock);\n-\n-    err = jvmti_env->GetThreadInfo(thread, &thrInfo);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetThreadInfo#TS) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-    if (thrInfo.name != NULL && strcmp(thrInfo.name, \"thr1\") == 0) {\n-        thr_ptr = env->NewGlobalRef(thread);\n-        printf(\">>> ThreadStart: \\\"%s\\\", 0x%p\\n\", thrInfo.name, thr_ptr);\n-        set_notification_mode(\"JVMTI_EVENT_THREAD_START\", JVMTI_DISABLE,\n-                              JVMTI_EVENT_THREAD_START, NULL);\n-    }\n-\n-    unlock(\"ThreadStart\", access_lock);\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_thrstat001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_thrstat001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_thrstat001(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-\n-jint  Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jint res;\n-    jvmtiError err;\n-\n-    printf(\"Agent_Initialize started\\n\");\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetPotentialCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->AddCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->CreateRawMonitor(\"_access_lock\", &access_lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(CreateRawMonitor)#access_lock unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->CreateRawMonitor(\"_wait_lock\", &wait_lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(CreateRawMonitor#wait_lock) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    callbacks.VMInit = &VMInit;\n-    callbacks.ThreadStart = &ThreadStart;\n-    err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    set_notification_mode(\"JVMTI_EVENT_VM_INIT\", JVMTI_ENABLE,\n-                          JVMTI_EVENT_VM_INIT, NULL);\n-\n-    printf(\"Agent_Initialize finished\\n\\n\");\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_GetThreadState_thrstat001_checkStatus(JNIEnv *env,\n-        jclass cls, jint statInd) {\n-    jvmtiError err;\n-    jint thrState;\n-    jint millis;\n-\n-    printf(\"native method checkStatus started\\n\");\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    if (thr_ptr == NULL) {\n-        printf(\"Missing thread \\\"thr1\\\" start event\\n\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    \/* wait until thread gets an expected state *\/\n-    for (millis = WAIT_START; millis < WAIT_TIME; millis <<= 1) {\n-        err = jvmti->GetThreadState(thr_ptr, &thrState);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(GetThreadState#%d) unexpected error: %s (%d)\\n\",\n-                statInd, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-        if ((thrState & state[statInd]) != 0) {\n-            break;\n-        }\n-        lock(\"checkStatus\", wait_lock);\n-        wait(\"checkStatus\", wait_lock, millis);\n-        unlock(\"checkStatus\", wait_lock);\n-    }\n-\n-    printf(\">>> thread \\\"thr1\\\" (0x%p) state: %s (%d)\\n\",\n-            thr_ptr, TranslateState(thrState), thrState);\n-\n-    if ((thrState & state[statInd]) == 0) {\n-        printf(\"Wrong thread \\\"thr1\\\" (0x%p) state:\\n\", thr_ptr);\n-        printf(\"    expected: %s (%d)\\n\",\n-            TranslateState(state[statInd]), state[statInd]);\n-        printf(\"      actual: %s (%d)\\n\",\n-            TranslateState(thrState), thrState);\n-        result = STATUS_FAILED;\n-    }\n-    printf(\"native method checkStatus finished\\n\\n\");\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_GetThreadState_thrstat001_getRes(JNIEnv *env, jclass cls) {\n-    printf(\"native method getRes: result: %d\\n\\n\", result);\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat001\/thrstat001.cpp","additions":0,"deletions":256,"binary":false,"changes":256,"status":"deleted"},{"patch":"@@ -1,194 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.GetThreadState;\n-\n-import nsk.share.Wicket;\n-import java.io.PrintStream;\n-\n-public class thrstat002 {\n-\n-    public static final int STATUS_RUNNING = 0;\n-    public static final int STATUS_MONITOR = 1;\n-    public static final int STATUS_WAIT    = 2;\n-\n-    native static void init(int waitTime);\n-    native static void checkStatus(int statInd, boolean susp);\n-    native static int getRes();\n-\n-    public static void main(String[] args) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        System.exit(run(args, System.out) + 95\/*STATUS_TEMP*\/);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        int waitTime = 2;\n-        if (args.length > 0) {\n-            try {\n-                int i  = Integer.parseInt(args[0]);\n-                waitTime = i;\n-            } catch (NumberFormatException ex) {\n-                out.println(\"# Wrong argument \\\"\" + args[0]\n-                    + \"\\\", the default value is used\");\n-            }\n-        }\n-        out.println(\"# Waiting time = \" + waitTime + \" mins\");\n-        init(waitTime);\n-        new thrstat002().meth();\n-        return getRes();\n-    }\n-\n-    public static Wicket startingBarrier;\n-    public static Wicket runningBarrier;\n-    public static Object blockingMonitor = new Object();\n-    public static Lock endingMonitor = new Lock();\n-\n-    static volatile boolean targetAboutToLock = false;\n-\n-    void meth() {\n-        thrstat002a thr = new thrstat002a(\"thr1\");\n-        startingBarrier = new Wicket();\n-        runningBarrier = new Wicket();\n-\n-        synchronized (blockingMonitor) {\n-            thr.start();\n-            System.out.println(\"thrstat002.meth after thr.start()\");\n-\n-            startingBarrier.waitFor();\n-            System.out.println(\"thrstat002.meth after thr.startingBarrier.waitFor()\");\n-\n-            waitForThreadBlocked(thr);\n-\n-            checkStatus(STATUS_MONITOR, false);\n-            System.out.println(\"thrstat002.meth after checkStatus(STATUS_MONITOR,false)\");\n-\n-            thr.suspend();\n-            System.out.println(\"thrstat002.meth after thr.suspend()\");\n-            checkStatus(STATUS_MONITOR, true);\n-            System.out.println(\"thrstat002.meth after checkStatus(STATUS_MONITOR,true)\");\n-\n-            thr.resume();\n-            System.out.println(\"thrstat002.meth after thr.resume()\");\n-            checkStatus(STATUS_MONITOR, false);\n-            System.out.println(\"thrstat002.meth after checkStatus(STATUS_MONITOR,false)\");\n-        }\n-\n-        runningBarrier.waitFor();\n-        checkStatus(STATUS_RUNNING, false);\n-        thr.suspend();\n-        checkStatus(STATUS_RUNNING, true);\n-        thr.resume();\n-        checkStatus(STATUS_RUNNING, false);\n-        thr.letItGo();\n-\n-        synchronized (endingMonitor) {\n-            checkStatus(STATUS_WAIT, false);\n-            thr.suspend();\n-            checkStatus(STATUS_WAIT, true);\n-            thr.resume();\n-            checkStatus(STATUS_WAIT, false);\n-            endingMonitor.val++;\n-            endingMonitor.notifyAll();\n-        }\n-\n-        try {\n-            thr.join();\n-        } catch (InterruptedException e) {\n-            throw new Error(\"Unexpected: \" + e);\n-        }\n-    }\n-\n-    private static void waitForThreadBlocked(Thread t) {\n-        \/\/ Ensure that the thread is blocked on the right monitor\n-        while (!targetAboutToLock || t.getState() != Thread.State.BLOCKED) {\n-            try {\n-                Thread.sleep(100);\n-            } catch (InterruptedException ex) {\n-                System.out.println(\"thrstat002.waitForThreadBlocked was interrupted: \" + ex.getMessage());\n-            }\n-        }\n-    }\n-\n-    static class Lock {\n-        public int val = 0;\n-    }\n-}\n-\n-class thrstat002a extends Thread {\n-    private volatile boolean flag = true;\n-\n-    public thrstat002a(String name) {\n-        super(name);\n-    }\n-\n-    public void run() {\n-        synchronized (thrstat002.endingMonitor) {\n-            System.out.println(\"thrstat002a.run before startingBarrier.unlock\");\n-            thrstat002.startingBarrier.unlock();\n-\n-            System.out.println(\"thrstat002a.run after  startingBarrier.unlock\");\n-\n-            System.out.println(\"thrstat002a.run before blockingMonitor lock\");\n-\n-            thrstat002.targetAboutToLock = true;\n-\n-            synchronized (thrstat002.blockingMonitor) {\n-               System.out.println(\"thrstat002a.run blockingMonitor locked\");\n-            }\n-            System.out.println(\"thrstat002a.run after blockingMonitor lock\");\n-\n-            System.out.println(\"thrstat002a.run before runningBarrier unlock\");\n-            thrstat002.runningBarrier.unlock();\n-\n-            \/\/ Don't do println's from this point until we have exited the loop,\n-            \/\/ else we can suspend in the println in an unexpected state.\n-            int i = 0;\n-            int n = 1000;\n-            while (flag) {\n-                if (n <= 0) {\n-                    n = 1000;\n-                }\n-                if (i > n) {\n-                    i = 0;\n-                    n--;\n-                }\n-                i++;\n-            }\n-\n-            thrstat002.endingMonitor.val = 0;\n-            while (thrstat002.endingMonitor.val == 0) {\n-                try {\n-                    thrstat002.endingMonitor.wait();\n-                } catch (InterruptedException e) {\n-                    throw new Error(\"Unexpected: \" + e);\n-                }\n-            }\n-            System.out.println(\"thrstat002a.run before endingMonitor unlock\");\n-       }\n-    }\n-\n-    public void letItGo() {\n-        flag = false;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat002.java","additions":0,"deletions":194,"binary":false,"changes":194,"status":"deleted"},{"patch":"@@ -1,63 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/GetThreadState\/thrstat002.\n- * VM Testbase keywords: [quick, jpda, jvmti, onload_only_logic, noras, quarantine]\n- * VM Testbase comments: 6260469\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMDI function GetThreadState.  Java program launches\n- *     a thread and for various thread states calls Thread.suspend()\/resume()\n- *     methods or JVMDI functions SuspendThread\/ResumeThread. Then native method\n- *     checkStatus is invoked. This method calls GetThreadState and checks if\n- *     the returned values are correct and JVMTI_THREAD_STATE_SUSPENDED bit\n- *     is set (or clear after resume).\n- *     The thread statuses are:\n- *       - JVMTI_THREAD_STATE_RUNNABLE\n- *               if thread is runnable\n- *       - JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER\n- *               if thread is waiting to enter sync. block\n- *       - JVMTI_THREAD_STATE_IN_OBJECT_WAIT\n- *               if thread is waiting by object.wait()\n- *     Failing criteria for the test are:\n- *       - values returned by GetThreadState are not the same as expected;\n- *       - failure of used JVMTI functions.\n- * COMMENTS\n- *     Converted the test to use GetThreadState instead of GetThreadStatus.\n- *     Fixed according to 4387521 and 4427103 bugs.\n- *     Fixed according to 4463667 bug.\n- *     Fixed according to 4669812 bug.\n- *     Ported from JVMDI.\n- *     Fixed according to 4925857 bug:\n- *       - rearranged synchronization of tested thread\n- *       - enhanced descripton\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:thrstat002 nsk.jvmti.GetThreadState.thrstat002 5\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat002\/TestDescription.java","additions":0,"deletions":63,"binary":false,"changes":63,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"thrstat002.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat002\/libthrstat002.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,470 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED  0\n-#define STATUS_FAILED  2\n-#define WAIT_START 100\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiCapabilities caps;\n-static jvmtiEventCallbacks callbacks;\n-static jrawMonitorID access_lock, wait_lock;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static jthread thr_ptr = NULL;\n-static jint wait_time = 0;\n-static jint state[] = {\n-    JVMTI_THREAD_STATE_RUNNABLE,\n-    JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER,\n-    JVMTI_THREAD_STATE_IN_OBJECT_WAIT\n-};\n-\n-\n-#if 1 \/\/ support for debug tracing\n-\n-#define LOG(...) \\\n-  { \\\n-    printf(__VA_ARGS__); \\\n-    fflush(stdout); \\\n-  }\n-\n-#define MAX_FRAME_COUNT_PRINT_STACK_TRACE 200\n-\n-static void\n-check_jvmti_status(JNIEnv* jni, jvmtiError err, const char* msg) {\n-  if (err != JVMTI_ERROR_NONE) {\n-    LOG(\"check_jvmti_status: JVMTI function returned error: %s (%d)\\n\", TranslateError(err), err);\n-    jni->FatalError(msg);\n-  }\n-}\n-\n-static void\n-deallocate(jvmtiEnv *jvmti, JNIEnv* jni, void* ptr) {\n-  jvmtiError err;\n-\n-  err = jvmti->Deallocate((unsigned char*)ptr);\n-  check_jvmti_status(jni, err, \"deallocate: error in JVMTI Deallocate call\");\n-}\n-\n-static char*\n-get_method_class_name(jvmtiEnv *jvmti, JNIEnv* jni, jmethodID method) {\n-  jclass klass = NULL;\n-  char*  cname = NULL;\n-  char*  result = NULL;\n-  jvmtiError err;\n-\n-  err = jvmti->GetMethodDeclaringClass(method, &klass);\n-  check_jvmti_status(jni, err, \"get_method_class_name: error in JVMTI GetMethodDeclaringClass\");\n-\n-  err = jvmti->GetClassSignature(klass, &cname, NULL);\n-  check_jvmti_status(jni, err, \"get_method_class_name: error in JVMTI GetClassSignature\");\n-\n-  size_t len = strlen(cname) - 2; \/\/ get rid of leading 'L' and trailing ';'\n-\n-  err = jvmti->Allocate((jlong)(len + 1), (unsigned char**)&result);\n-  check_jvmti_status(jni, err, \"get_method_class_name: error in JVMTI Allocate\");\n-\n-  strncpy(result, cname + 1, len); \/\/ skip leading 'L'\n-  result[len] = '\\0';\n-  deallocate(jvmti, jni, (void*)cname);\n-  return result;\n-}\n-\n-static void\n-print_method(jvmtiEnv *jvmti, JNIEnv* jni, jmethodID method, jint depth) {\n-  char*  cname = NULL;\n-  char*  mname = NULL;\n-  char*  msign = NULL;\n-  jvmtiError err;\n-\n-  cname = get_method_class_name(jvmti, jni, method);\n-\n-  err = jvmti->GetMethodName(method, &mname, &msign, NULL);\n-  check_jvmti_status(jni, err, \"print_method: error in JVMTI GetMethodName\");\n-\n-  LOG(\"%2d: %s: %s%s\\n\", depth, cname, mname, msign);\n-  fflush(0);\n-  deallocate(jvmti, jni, (void*)cname);\n-  deallocate(jvmti, jni, (void*)mname);\n-  deallocate(jvmti, jni, (void*)msign);\n-}\n-\n-static char*\n-get_thread_name(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread) {\n-  jvmtiThreadInfo thr_info;\n-  jvmtiError err;\n-\n-  memset(&thr_info, 0, sizeof(thr_info));\n-  err = jvmti->GetThreadInfo(thread, &thr_info);\n-  check_jvmti_status(jni, err, \"get_thread_name: error in JVMTI GetThreadInfo call\");\n-\n-  return thr_info.name == NULL ? (char*)\"<Unnamed thread>\" : thr_info.name;\n-}\n-\n-static void\n-print_stack_trace(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread) {\n-  jvmtiFrameInfo frames[MAX_FRAME_COUNT_PRINT_STACK_TRACE];\n-  char* tname = get_thread_name(jvmti, jni, thread);\n-  jint count = 0;\n-  jvmtiError err;\n-\n-  err = jvmti->GetStackTrace(thread, 0, MAX_FRAME_COUNT_PRINT_STACK_TRACE, frames, &count);\n-  check_jvmti_status(jni, err, \"print_stack_trace: error in JVMTI GetStackTrace\");\n-\n-  LOG(\"JVMTI Stack Trace for thread %s: frame count: %d\\n\", tname, count);\n-  for (int depth = 0; depth < count; depth++) {\n-    print_method(jvmti, jni, frames[depth].method, depth);\n-  }\n-  deallocate(jvmti, jni, (void*)tname);\n-  LOG(\"\\n\");\n-}\n-#endif \/\/ support for debug tracing\n-\n-void printStateFlags(jint flags) {\n-    if (flags & JVMTI_THREAD_STATE_SUSPENDED)\n-        printf(\" JVMTI_THREAD_STATE_SUSPENDED\");\n-    if (flags & JVMTI_THREAD_STATE_INTERRUPTED)\n-        printf(\" JVMTI_THREAD_STATE_INTERRUPTED\");\n-    if (flags & JVMTI_THREAD_STATE_IN_NATIVE)\n-        printf(\" JVMTI_THREAD_STATE_IN_NATIVE\");\n-    printf(\" (0x%0x)\\n\", flags);\n-}\n-\n-void JNICALL VMInit(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thr) {\n-    jvmtiError err;\n-\n-    err = jvmti_env->SetEventNotificationMode(JVMTI_ENABLE,\n-        JVMTI_EVENT_THREAD_START, NULL);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to enable THREAD_START event: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-void JNICALL\n-ThreadStart(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thread) {\n-    jvmtiThreadInfo thrInfo;\n-    jvmtiError err;\n-\n-    err = jvmti_env->RawMonitorEnter(access_lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(RawMonitorEnter) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    err = jvmti_env->GetThreadInfo(thread, &thrInfo);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetThreadInfo) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-    if (thrInfo.name != NULL && strcmp(thrInfo.name, \"thr1\") == 0) {\n-        thr_ptr = env->NewGlobalRef(thread);\n-        if (printdump == JNI_TRUE) {\n-            printf(\">>> ThreadStart: \\\"%s\\\", 0x%p\\n\", thrInfo.name, thr_ptr);\n-        }\n-    }\n-\n-    err = jvmti_env->RawMonitorExit(access_lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(RawMonitorExit) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_thrstat002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_thrstat002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_thrstat002(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint  Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jint res;\n-    jvmtiError err;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv !\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetPotentialCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->AddCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    if (!caps.can_suspend) {\n-        printf(\"Warning: suspend\/resume is not implemented\\n\");\n-    }\n-\n-    err = jvmti->CreateRawMonitor(\"_access_lock\", &access_lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(CreateRawMonitor) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->CreateRawMonitor(\"_wait_lock\", &wait_lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(CreateRawMonitor) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    callbacks.VMInit = &VMInit;\n-    callbacks.ThreadStart = &ThreadStart;\n-    err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-        JVMTI_EVENT_VM_INIT, NULL);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to enable VM_INIT event: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_GetThreadState_thrstat002_init(JNIEnv *env, jclass cls,\n-        jint waitTime) {\n-    wait_time = waitTime * 60000;\n-}\n-\n-void wait_for(jint millis) {\n-    jvmtiError err;\n-\n-    err = jvmti->RawMonitorEnter(wait_lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(RawMonitorEnter#check) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-    err = jvmti->RawMonitorWait(wait_lock, (jlong)millis);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(RawMonitorWait#check) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-    err = jvmti->RawMonitorExit(wait_lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(RawMonitorExit#check) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_GetThreadState_thrstat002_checkStatus(JNIEnv *env, jclass cls,\n-        jint statInd, jboolean suspended) {\n-    jint thrState;\n-    jint suspState = -1;\n-    jint right_stat = (suspended ? JVMTI_THREAD_STATE_SUSPENDED : 0);\n-    jvmtiError right_ans = (suspended ? JVMTI_ERROR_THREAD_SUSPENDED : JVMTI_ERROR_NONE);\n-    const char *suspStr = (suspended ? \", suspended\" : \"\");\n-    jvmtiError err;\n-    jint millis;\n-    jboolean timeout_is_reached;\n-    unsigned int waited_millis;\n-\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    if (thr_ptr == NULL) {\n-        printf(\"Missing thread \\\"thr1\\\" start event\\n\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    if (!caps.can_suspend) {\n-        return;\n-    }\n-\n-    printf(\"START checkStatus for \\\"thr1\\\" (0x%p%s), check state: %s\\n\",\n-           thr_ptr, suspStr, TranslateState(state[statInd]));\n-\n-    timeout_is_reached = JNI_TRUE;\n-    for (millis = WAIT_START, waited_millis=0; millis < wait_time; millis <<= 1) {\n-        err = jvmti->GetThreadState(thr_ptr, &thrState);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(GetThreadState#%d) unexpected error: %s (%d)\\n\",\n-                statInd, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-            timeout_is_reached = JNI_FALSE;\n-            break;\n-        }\n-        suspState = thrState & JVMTI_THREAD_STATE_SUSPENDED;\n-        if (suspended || (thrState & JVMTI_THREAD_STATE_RUNNABLE) == 0 ||\n-            (state[statInd] == JVMTI_THREAD_STATE_RUNNABLE)) {\n-            timeout_is_reached = JNI_FALSE;\n-            break;\n-        }\n-\n-        waited_millis += millis;\n-        wait_for(millis);\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> thread \\\"thr1\\\" (0x%p) state: %s (%d)\\n\",\n-            thr_ptr, TranslateState(thrState), thrState);\n-        printf(\">>>\\tflags:\");\n-        printStateFlags(suspState);\n-    }\n-\n-    if (timeout_is_reached == JNI_TRUE) {\n-        printf(\"Error: timeout (%d secs) has been reached\\n\", waited_millis\/1000);\n-    }\n-    if ((thrState & state[statInd]) == 0) {\n-        printf(\"Wrong thread \\\"thr1\\\" (0x%p%s) state:\\n\", thr_ptr, suspStr);\n-        printf(\"    expected: %s (%d)\\n\",\n-            TranslateState(state[statInd]), state[statInd]);\n-        printf(\"      actual: %s (%d)\\n\",\n-            TranslateState(thrState), thrState);\n-        result = STATUS_FAILED;\n-    }\n-    if (suspState != right_stat) {\n-        printf(\"Wrong thread \\\"thr1\\\" (0x%p%s) state flags:\\n\",\n-               thr_ptr, suspStr);\n-        printf(\"    expected:\");\n-        printStateFlags(right_stat);\n-        printf(\"    actual:\");\n-        printStateFlags(suspState);\n-        result = STATUS_FAILED;\n-    }\n-\n-    err = jvmti->SuspendThread(thr_ptr);\n-    if (err != right_ans) {\n-        printf(\"Wrong result of SuspendThread() for \\\"thr1\\\" (0x%p%s):\\n\",\n-               thr_ptr, suspStr);\n-        printf(\"    expected: %s (%d), actual: %s (%d)\\n\",\n-            TranslateError(right_ans), right_ans, TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (!suspended) {\n-        \/\/ wait till thread is not suspended\n-        timeout_is_reached = JNI_TRUE;\n-        for (millis = WAIT_START, waited_millis=0; millis < wait_time; millis <<= 1) {\n-            waited_millis += millis;\n-            wait_for(millis);\n-            err = jvmti->GetThreadState(thr_ptr, &thrState);\n-            if (err != JVMTI_ERROR_NONE) {\n-                printf(\"(GetThreadState#%d,after) unexpected error: %s (%d)\\n\",\n-                    statInd, TranslateError(err), err);\n-                timeout_is_reached = JNI_FALSE;\n-                result = STATUS_FAILED;\n-                break;\n-            }\n-            suspState = thrState & JVMTI_THREAD_STATE_SUSPENDED;\n-            if (suspState) {\n-                timeout_is_reached = JNI_FALSE;\n-                break;\n-            }\n-        }\n-\n-        if (timeout_is_reached == JNI_TRUE) {\n-            printf(\"Error: timeout (%d secs) has been reached\\n\", waited_millis\/1000);\n-        }\n-        if ((thrState & state[statInd]) == 0) {\n-            printf(\"Wrong thread \\\"thr1\\\" (0x%p) state after SuspendThread:\\n\",\n-                thr_ptr);\n-            printf(\"    expected: %s (%d)\\n\",\n-                TranslateState(state[statInd]), state[statInd]);\n-            printf(\"      actual: %s (%d)\\n\",\n-                TranslateState(thrState), thrState);\n-#ifdef DBG\n-            print_stack_trace(jvmti, env, thr_ptr);\n-#endif\n-            result = STATUS_FAILED;\n-        }\n-        if (suspState != JVMTI_THREAD_STATE_SUSPENDED) {\n-            printf(\"Wrong thread \\\"thr1\\\" (0x%p) state flags\", thr_ptr);\n-            printf(\" after SuspendThread:\\n\");\n-            printf(\"    expected:\");\n-            printStateFlags(JVMTI_THREAD_STATE_SUSPENDED);\n-            printf(\"    actual:\");\n-            printStateFlags(suspState);\n-            result = STATUS_FAILED;\n-        }\n-        err = jvmti->ResumeThread(thr_ptr);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(ResumeThread#%d) unexpected error: %s (%d)\\n\",\n-                statInd, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-    }\n-    fflush(0);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_GetThreadState_thrstat002_getRes(JNIEnv *env, jclass cls) {\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat002\/thrstat002.cpp","additions":0,"deletions":470,"binary":false,"changes":470,"status":"deleted"},{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.GetThreadState;\n-\n-import java.io.PrintStream;\n-\n-public class thrstat003 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-    static final int NOT_STARTED = 0;\n-    static final int SLEEPING = 1;\n-    static final int ZOMBIE = 2;\n-\n-    native static void init(int waitTime);\n-    native static int check(Thread thread, int status);\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    static int contendCount = 0;\n-    public static Object lock = new Object();\n-    public static int waitTime = 2;\n-\n-    public static int run(String args[], PrintStream out) {\n-        if (args.length > 0) {\n-            try {\n-                int i  = Integer.parseInt(args[0]);\n-                waitTime = i;\n-            } catch (NumberFormatException ex) {\n-                out.println(\"# Wrong argument \\\"\" + args[0]\n-                    + \"\\\", the default value is used\");\n-            }\n-        }\n-        out.println(\"# Waiting time = \" + waitTime + \" mins\");\n-\n-        init(waitTime);\n-\n-        TestThread t = new TestThread();\n-\n-        check(t, NOT_STARTED);\n-\n-        synchronized (lock) {\n-            t.start();\n-            try {\n-                lock.wait();\n-            } catch (InterruptedException e) {\n-                throw new Error(\"Unexpected: \" + e);\n-            }\n-\n-        }\n-\n-        check(t, SLEEPING);\n-\n-        t.interrupt();\n-        try {\n-            t.join();\n-        } catch (InterruptedException e) {\n-            throw new Error(\"Unexpected: \" + e);\n-        }\n-\n-        return check(t, ZOMBIE);\n-    }\n-\n-\n-    static class TestThread extends Thread {\n-        public void run() {\n-            synchronized (lock) {\n-                lock.notify();\n-            }\n-            try {\n-                sleep(waitTime*60000);\n-            } catch (InterruptedException e) {\n-                \/\/ OK, it's expected\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat003.java","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/GetThreadState\/thrstat003.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI function GetThreadState.\n- *     The test checks if the function returns:\n- *       - NEW              if thread has not run yet\n- *       - STATE_SLEEPING   if Thread.sleep() has been called\n- *       - STATE_TERMINATED if thread has exited\n- * COMMENTS\n- *     Converted the test to use GetThreadState instead of GetThreadStatus.\n- *     Ported from JVMDI.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:thrstat003 nsk.jvmti.GetThreadState.thrstat003 5\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat003\/TestDescription.java","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"thrstat003.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat003\/libthrstat003.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,159 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-#define WAIT_START 100\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static jint wait_time = 0;\n-static jint state[] = {\n-    0,                               \/*  JVMTI_THREAD_STATUS_NOT_STARTED, *\/\n-    JVMTI_THREAD_STATE_SLEEPING,\n-    JVMTI_THREAD_STATE_TERMINATED    \/*  JVMTI_THREAD_STATUS_ZOMBIE *\/\n-};\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_GetThreadState_thrstat003_init(JNIEnv *env, jclass cls,\n-        jint waitTime) {\n-    wait_time = waitTime * 60000;\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_thrstat003(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_thrstat003(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_thrstat003(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jint res;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_GetThreadState_thrstat003_check(JNIEnv *env, jclass cls,\n-        jthread thr, jint statInd) {\n-    jvmtiError err;\n-    jrawMonitorID wait_lock;\n-    jint thrState;\n-    jint i;\n-\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        return STATUS_FAILED;\n-    }\n-\n-    err = jvmti->CreateRawMonitor(\"_wait_lock\", &wait_lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(CreateRawMonitor#%d) unexpected error: %s (%d)\\n\",\n-               statInd, TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    for (i = WAIT_START; i < wait_time; i <<= 1) {\n-        err = jvmti->GetThreadState(thr, &thrState);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(GetThreadState#%d) unexpected error: %s (%d)\\n\",\n-                statInd, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-\n-        if (printdump == JNI_TRUE) {\n-            printf(\">>> thread state: %s (%d)\\n\",\n-                TranslateState(thrState), thrState);\n-        }\n-\n-        if ((thrState & JVMTI_THREAD_STATE_RUNNABLE) == 0) {\n-            break;\n-        }\n-\n-        err = jvmti->RawMonitorEnter(wait_lock);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(RawMonitorEnter) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-        err = jvmti->RawMonitorWait(wait_lock, (jlong)i);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(RawMonitorWait) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-        err = jvmti->RawMonitorExit(wait_lock);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(RawMonitorExit) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-    }\n-\n-    err = jvmti->DestroyRawMonitor(wait_lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(DestroyRawMonitor#%d) unexpected error: %s (%d)\\n\",\n-               statInd, TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    \/* We expect that thread is NOT_STARTED if statInd == 0 *\/\n-    if (statInd == 0 && thrState != state[statInd]) {\n-        result = STATUS_FAILED;\n-    } else if (statInd != 0 && (thrState & state[statInd]) == 0) {\n-        result = STATUS_FAILED;\n-    }\n-    if (result == STATUS_FAILED) {\n-        printf(\"Wrong state: %s (%d)\\n\", TranslateState(thrState), thrState);\n-        printf(\"   expected: %s (%d)\\n\",\n-            TranslateState(state[statInd]), state[statInd]);\n-    }\n-\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat003\/thrstat003.cpp","additions":0,"deletions":159,"binary":false,"changes":159,"status":"deleted"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.GetThreadState;\n-\n-import java.io.PrintStream;\n-\n-public class thrstat004 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-\n-    native static int check(Thread thr);\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        return check(Thread.currentThread());\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat004.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/GetThreadState\/thrstat004.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI function\n- *       GetThreadState(thread, threadStatusPtr)\n- *     The test checks if the function returns:\n- *       - JVMTI_ERROR_NULL_POINTER if threadStatusPtr is null\n- *       - JVMTI_ERROR_NULL_POINTER if suspendStatusPtr is null\n- *       - JVMTI_ERROR_INVALID_THREAD if thread is not a thread object\n- * COMMENTS\n- *     Converted the test to use GetThreadState instead of GetThreadStatus.\n- *     Ported from JVMDI.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:thrstat004 nsk.jvmti.GetThreadState.thrstat004\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat004\/TestDescription.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"thrstat004.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat004\/libthrstat004.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,100 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_thrstat004(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_thrstat004(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_thrstat004(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jint res;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_GetThreadState_thrstat004_check(JNIEnv *env, jclass cls, jthread thr) {\n-    jvmtiError err;\n-    jint thrState;\n-\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        return STATUS_FAILED;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> (threadStatePtr) null pointer check ...\\n\");\n-    }\n-    err = jvmti->GetThreadState(thr, NULL);\n-    if (err != JVMTI_ERROR_NULL_POINTER) {\n-        printf(\"(threadStatePtr) error expected: JVMTI_ERROR_NULL_POINTER,\\n\");\n-        printf(\"           got: %s (%d)\\n\", TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> invalid thread check ...\\n\");\n-    }\n-    err = jvmti->GetThreadState(cls, &thrState);\n-    if (err != JVMTI_ERROR_INVALID_THREAD) {\n-        printf(\"Error expected: JVMTI_ERROR_INVALID_THREAD,\\n\");\n-        printf(\"           got: %s (%d)\\n\", TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat004\/thrstat004.cpp","additions":0,"deletions":100,"binary":false,"changes":100,"status":"deleted"},{"patch":"@@ -1,338 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-package nsk.jvmti.GetThreadState;\n-\n-import java.io.PrintStream;\n-import java.util.concurrent.*;\n-import java.util.concurrent.locks.*;\n-\n-public class thrstat005 {\n-    final static int JCK_STATUS_BASE = 95;\n-\n-    public static final int TS_NEW        = 0;\n-    public static final int TS_TERMINATED = 1;\n-\n-    public static final int TS_RUN_RUNNING           = 2;\n-    public static final int TS_RUN_BLOCKED           = 3;\n-    public static final int TS_RUN_WAIT_TIMED        = 4;\n-    public static final int TS_RUN_WAIT_INDEF        = 5;\n-    public static final int TS_RUN_WAIT_PARKED_TIMED = 6;\n-    public static final int TS_RUN_WAIT_PARKED_INDEF = 7;\n-    public static final int TS_RUN_WAIT_SLEEP        = 8; \/* assumes _TIMED *\/\n-\n-    public static final int WAIT_TIME = 250;\n-\n-    public PrintStream _out;\n-    public Thread      _thrMain;\n-    public TestThread  _thrDummy;\n-    public int         _passCnt, _failCnt;\n-\n-    \/**\n-     * Set waiting time for checkThreadState\n-     *\/\n-    native static void setWaitTime(int sec);\n-\n-    \/**\n-     * Check that thread state (TS_xxx) is what we expect\n-     * (for TS_xxx -> JVMTI_THREAD_STATE_xxx mapping see table in thrstat005.c)\n-     *\/\n-    native static boolean checkThreadState(Thread t, int stateIdx);\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        return new thrstat005(out).run();\n-    }\n-\n-    thrstat005(PrintStream out) {\n-        _out = out;\n-        _thrMain = Thread.currentThread();\n-        setWaitTime(WAIT_TIME * 23 \/ 11);\n-    }\n-\n-    public int run() {\n-        _failCnt = 0;\n-        _passCnt = 0;\n-\n-        testAndPrint(\"New\", TS_NEW);\n-        testAndPrint(\"Running\", TS_RUN_RUNNING);\n-        testAndPrint(\"Blocked on monitor\", TS_RUN_BLOCKED);\n-        testAndPrint(\"Waiting with timeout\", TS_RUN_WAIT_TIMED);\n-        testAndPrint(\"Waiting forever\", TS_RUN_WAIT_INDEF);\n-        testAndPrint(\"Parking forever\", TS_RUN_WAIT_PARKED_TIMED);\n-        testAndPrint(\"Parking with timeout\", TS_RUN_WAIT_PARKED_INDEF);\n-        testAndPrint(\"Sleeping\", TS_RUN_WAIT_SLEEP);\n-        testAndPrint(\"Terminating\", TS_TERMINATED);\n-\n-        log(\">>> PASS\/FAIL: \" + _passCnt + \"\/\" + _failCnt);\n-\n-        return _failCnt > 0 ? 2 : 0;\n-    }\n-\n-    public void testAndPrint(String name, int state) {\n-        boolean fPassed;\n-\n-        try {\n-            log(\">>> Testing state: \" + name);\n-            fPassed = test(state);\n-        } catch ( BrokenBarrierException e ) {\n-            log(\"Main: broken barrier exception\");\n-            fPassed = false;\n-        } catch ( InterruptedException e ) {\n-            log(\"Main: interrupted exception\");\n-            fPassed = false;\n-        }\n-\n-        log(\">>> \" + (fPassed ? \"PASSED\" : \"FAILED\") + \" testing state: \" + name);\n-        if ( fPassed )\n-            _passCnt++;\n-        else\n-            _failCnt++;\n-    }\n-\n-    public boolean test(int state) throws BrokenBarrierException, InterruptedException {\n-        boolean fRes;\n-\n-        switch ( state ) {\n-            case TS_NEW:\n-                log(\"Main: Creating new thread\");\n-                _thrDummy = new TestThread();\n-                fRes = checkThreadState(_thrDummy, state);\n-                _thrDummy.start();\n-                return fRes;\n-\n-            case TS_RUN_RUNNING:\n-                log(\"Main: Running thread\");\n-                _thrDummy._fRun = true;\n-                fRes = sendStateAndCheckIt(state);\n-                _thrDummy._fRun = false;\n-                return fRes;\n-\n-            case TS_RUN_BLOCKED:\n-                log(\"Main: Blocking thread\");\n-                synchronized ( _thrDummy._mon ) {\n-                    return sendStateAndCheckIt(state);\n-                }\n-\n-            case TS_RUN_WAIT_TIMED:\n-            case TS_RUN_WAIT_INDEF:\n-                log(\"Main: Thread will wait\");\n-                _thrDummy._fRun = true;\n-                fRes = sendStateAndCheckIt(state);\n-\n-                _thrDummy._fRun = false;\n-                do {\n-                    log(\"Main: Notifying the thread\");\n-                    synchronized ( _thrDummy._mon ) {\n-                        _thrDummy._mon.notify();\n-                    }\n-\n-                    if ( ! _thrDummy._fInTest ) {\n-                        break;\n-                    }\n-\n-                    Thread.sleep(WAIT_TIME \/ 4);\n-                } while ( true );\n-\n-                return fRes;\n-\n-            case TS_RUN_WAIT_PARKED_TIMED:\n-            case TS_RUN_WAIT_PARKED_INDEF:\n-                log(\"Main: Thread will park\");\n-                _thrDummy._fRun = true;\n-                fRes = sendStateAndCheckIt(state);\n-\n-                _thrDummy._fRun = false;\n-                do {\n-                    log(\"Main: Unparking the thread\");\n-                    LockSupport.unpark(_thrDummy);\n-\n-                    if ( ! _thrDummy._fInTest ) {\n-                        break;\n-                    }\n-\n-                    Thread.sleep(WAIT_TIME);\n-                } while ( true );\n-\n-                return fRes;\n-\n-            case TS_RUN_WAIT_SLEEP:\n-                log(\"Main: Thread will sleep\");\n-                _thrDummy._fRun = true;\n-                fRes = sendStateAndCheckIt(state);\n-                _thrDummy._fRun = false;\n-                return fRes;\n-\n-            case TS_TERMINATED:\n-                log(\"Main: Terminating thread\");\n-                _thrDummy.sendTestState(state);\n-\n-                log(\"Main: Waiting for join\");\n-                _thrDummy.join();\n-                return checkThreadState(_thrDummy, state);\n-        }\n-\n-        return false;\n-    }\n-\n-    public boolean sendStateAndCheckIt(int state) throws BrokenBarrierException, InterruptedException {\n-        _thrDummy.sendTestState(state);\n-        while ( ! _thrDummy._fInTest ) {\n-            log(\"Main: Waiting for the thread to start the test\");\n-            Thread.sleep(WAIT_TIME * 29 \/ 7); \/\/ Wait time should not be a multiple of WAIT_TIME\n-        }\n-        return checkThreadState(_thrDummy, state);\n-    }\n-\n-    synchronized void log(String s) {\n-        _out.println(s);\n-        _out.flush();\n-    }\n-\n-    class TestThread extends Thread {\n-\n-        SynchronousQueue<Integer> _taskQueue = new SynchronousQueue<Integer>();\n-\n-        public volatile boolean _fRun = true;\n-        public volatile boolean _fInTest = false;\n-        public Object _mon = new Object();\n-\n-        public void sendTestState(int state) throws BrokenBarrierException, InterruptedException {\n-            _taskQueue.put(state);\n-        }\n-\n-        public int recvTestState() {\n-            int state = TS_NEW;\n-            try {\n-                state = _taskQueue.take();\n-            } catch ( InterruptedException e ) {\n-                log(\"Thread: interrupted exception \" + e);\n-            }\n-            return state;\n-        }\n-\n-        public void run() {\n-            log(\"Thread: started\");\n-\n-            while ( true ) {\n-                int state = recvTestState();\n-                switch ( state ) {\n-                    case TS_NEW:\n-                        log(\"Thread: ERROR IN TEST: TS_NEW\");\n-                        break;\n-\n-                    case TS_RUN_RUNNING:\n-                        int i = 0;\n-                        log(\"Thread: Running...\");\n-                        _fInTest = true;\n-                        while ( _fRun ) i++;\n-                        log(\"Thread: Running: done\");\n-                        _fInTest = false;\n-                        break;\n-\n-                    case TS_RUN_BLOCKED:\n-                        log(\"Thread: Blocking...\");\n-                        _fInTest = true;\n-                        synchronized ( _mon ) {}\n-                        log(\"Thread: Blocking: done\");\n-                        _fInTest = false;\n-                        break;\n-\n-                    case TS_RUN_WAIT_TIMED:\n-                        log(\"Thread: Waiting with timeout...\");\n-                        while ( _fRun ) {\n-                            synchronized ( _mon ) {\n-                                _fInTest = true;\n-                                try {\n-                                    _mon.wait(WAIT_TIME);\n-                                } catch ( InterruptedException e ) {\n-                                    log(\"Thread: Interrupted exception\");\n-                                }\n-                            }\n-                        }\n-                        log(\"Thread: Waiting: done\");\n-                        _fInTest = false;\n-                        break;\n-\n-                    case TS_RUN_WAIT_INDEF:\n-                        log(\"Thread: Waiting indefinitely...\");\n-                        _fInTest = true;\n-                        synchronized ( _mon ) {\n-                            try {\n-                                _mon.wait();\n-                            } catch ( InterruptedException e ) {\n-                                log(\"Thread: Interrupted exception\");\n-                            }\n-                            log(\"Thread: Waiting: done\");\n-                            _fInTest = false;\n-                        }\n-                        break;\n-\n-                    case TS_RUN_WAIT_SLEEP:\n-                        log(\"Thread: Sleeping...\");\n-                        while ( _fRun ) {\n-                            try {\n-                                _fInTest = true;\n-                                Thread.sleep(WAIT_TIME);\n-                            } catch ( InterruptedException e ) {\n-                                log(\"Thread: Interrupted exception\");\n-                            }\n-                        }\n-                        log(\"Thread: Sleeping: done\");\n-                        _fInTest = false;\n-                        break;\n-\n-                    case TS_RUN_WAIT_PARKED_TIMED:\n-                        log(\"Thread: Parking indefinitely...\");\n-                        _fInTest = true;\n-                        while ( _fRun ) {\n-                            LockSupport.park();\n-                        }\n-                        log(\"Thread: Parking: done\");\n-                        _fInTest = false;\n-                        break;\n-\n-                    case TS_RUN_WAIT_PARKED_INDEF:\n-                        log(\"Thread: Parking with timeout...\");\n-                        _fInTest = true;\n-                        while ( _fRun ) {\n-                            LockSupport.parkUntil(System.currentTimeMillis() + WAIT_TIME);\n-                        }\n-                        log(\"Thread: Parking: done\");\n-                        _fInTest = false;\n-                        break;\n-\n-                    case TS_TERMINATED:\n-                        log(\"Thread: terminating\");\n-                        return;\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat005.java","additions":0,"deletions":338,"binary":false,"changes":338,"status":"deleted"},{"patch":"@@ -1,62 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/GetThreadState\/thrstat005.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test verifies that the new hierarchical flags returned by GetThreadState()\n- *     are properly set in various thread states as requested in bug #5041847.\n- *     Flags being tested are:\n- *     JVMTI_THREAD_STATE_ALIVE\n- *     JVMTI_THREAD_STATE_TERMINATED\n- *     JVMTI_THREAD_STATE_RUNNABLE\n- *     JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER\n- *     JVMTI_THREAD_STATE_WAITING\n- *     JVMTI_THREAD_STATE_WAITING_INDEFINITELY\n- *     JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT\n- *     JVMTI_THREAD_STATE_SLEEPING\n- *     JVMTI_THREAD_STATE_IN_OBJECT_WAIT\n- *     JVMTI_THREAD_STATE_PARKED\n- *     The state is checked in the following test cases:\n- *     - A new thread is created\n- *     - Thread is running (doing some computations)\n- *     - Thread is blocked on a monitor (synchronized (...) { ... })\n- *     - Thread is waiting in wait(timeout)\n- *     - Thread is waiting in wait() w\/o a timeout\n- *     - Thread is parked using LockSupport.park()\n- *     - Thread is parked using LockSupport.parkUntil()\n- *     - Thread is in Thread.sleep()\n- *     - Thread has terminated\n- *     For more information see bugs #5041847, #4980307 and J2SE 5.0+ JVMTI spec.\n- * COMMENTS\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:thrstat005 nsk.jvmti.GetThreadState.thrstat005\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat005\/TestDescription.java","additions":0,"deletions":62,"binary":false,"changes":62,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"thrstat005.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat005\/libthrstat005.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,170 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-\n-#ifndef STANDALONE\n-#include \"JVMTITools.h\"\n-#endif\n-\n-extern \"C\" {\n-\n-\n-#define THREAD_STATE_MASK ~(JVMTI_THREAD_STATE_SUSPENDED \\\n-                            | JVMTI_THREAD_STATE_INTERRUPTED \\\n-                            | JVMTI_THREAD_STATE_IN_NATIVE \\\n-                            | JVMTI_THREAD_STATE_VENDOR_1 \\\n-                            | JVMTI_THREAD_STATE_VENDOR_2 \\\n-                            | JVMTI_THREAD_STATE_VENDOR_3)\n-\n-static int g_ThreadState[] = {\n-    0,                                                 \/* TS_NEW *\/\n-    JVMTI_THREAD_STATE_TERMINATED,                     \/* TS_TERMINATED *\/\n-    JVMTI_THREAD_STATE_ALIVE\n-        | JVMTI_THREAD_STATE_RUNNABLE,                 \/* TS_RUN_RUNNING *\/\n-    JVMTI_THREAD_STATE_ALIVE\n-        | JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER, \/* TS_RUN_BLOCKED *\/\n-    JVMTI_THREAD_STATE_ALIVE\n-        | JVMTI_THREAD_STATE_IN_OBJECT_WAIT\n-        | JVMTI_THREAD_STATE_WAITING\n-        | JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT,     \/* TS_RUN_WAIT_TIMED *\/\n-    JVMTI_THREAD_STATE_ALIVE\n-        | JVMTI_THREAD_STATE_IN_OBJECT_WAIT\n-        | JVMTI_THREAD_STATE_WAITING\n-        | JVMTI_THREAD_STATE_WAITING_INDEFINITELY,     \/* TS_RUN_WAIT_INDEF *\/\n-    JVMTI_THREAD_STATE_ALIVE\n-        | JVMTI_THREAD_STATE_PARKED\n-        | JVMTI_THREAD_STATE_WAITING\n-        | JVMTI_THREAD_STATE_WAITING_INDEFINITELY,     \/* TS_RUN_WAIT_PARKED_INDEF *\/\n-    JVMTI_THREAD_STATE_ALIVE\n-        | JVMTI_THREAD_STATE_PARKED\n-        | JVMTI_THREAD_STATE_WAITING\n-        | JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT,     \/* TS_RUN_WAIT_PARKED_TIMED *\/\n-    JVMTI_THREAD_STATE_ALIVE\n-        | JVMTI_THREAD_STATE_SLEEPING\n-        | JVMTI_THREAD_STATE_WAITING\n-        | JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT,     \/* TS_RUN_WAIT_SLEEPING *\/\n-};\n-\n-static jvmtiEnv * g_ppJvmtiEnv = NULL;\n-static int g_waitTime = 1000;\n-jrawMonitorID g_waitMon; \/* Monitor is used just for sleeping *\/\n-\n-void reportError(const char * szErr, jvmtiError res) {\n-#ifndef STANDALONE\n-    printf(\"%s (%d: %s)\\n\", szErr, res, TranslateError(res));\n-#else\n-    printf(\"%s (%d)\\n\", szErr, res);\n-#endif\n-    fflush(stdout);\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_thrstat005(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_thrstat005(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_thrstat005(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiError error;\n-    jint res;\n-\n-    res = jvm->GetEnv((void **) &g_ppJvmtiEnv, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || !g_ppJvmtiEnv) {\n-        printf(\"Agent_OnLoad: Error: GetEnv returned error or NULL\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    error = g_ppJvmtiEnv->CreateRawMonitor(\"beast\", &g_waitMon);\n-    if (error != JVMTI_ERROR_NONE) {\n-        reportError(\"Agent_OnLoad: error creating raw monitor\", error);\n-        return JNI_ERR;\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_GetThreadState_thrstat005_setWaitTime(JNIEnv * pEnv, jclass klass, jint waitTime) {\n-    g_waitTime = waitTime;\n-}\n-\n-JNIEXPORT jboolean JNICALL\n-Java_nsk_jvmti_GetThreadState_thrstat005_checkThreadState(JNIEnv * pEnv, jclass klass, jthread thread, jint stateIdx) {\n-\n-    jint thrState;\n-    jint maskedThrState;\n-    int waitTime = 10;\n-\n-    \/* Repeat querying status until waitTime < g_waitTime *\/\n-    do {\n-        jvmtiError res = g_ppJvmtiEnv->GetThreadState(thread, &thrState);\n-        if (res != JVMTI_ERROR_NONE) {\n-            reportError(\"GetThreadState: unexpected error\", res);\n-            return JNI_FALSE;\n-        }\n-\n-        maskedThrState = thrState & THREAD_STATE_MASK;\n-        printf(\"GetThreadState = %x. Masked: %x. Must be: %x\\n\", thrState, maskedThrState, g_ThreadState[stateIdx]);\n-        fflush(stdout);\n-\n-        if (maskedThrState == g_ThreadState[stateIdx])\n-            return JNI_TRUE;\n-\n-        printf(\"checkThreadState: wait %d ms\\n\", waitTime);\n-        fflush(stdout);\n-        res = g_ppJvmtiEnv->RawMonitorEnter(g_waitMon);\n-        if (res != JVMTI_ERROR_NONE) {\n-            reportError(\"GetThreadState: unexpected error from RawMontiorEnter\", res);\n-            return JNI_FALSE;\n-        }\n-        res = g_ppJvmtiEnv->RawMonitorWait(g_waitMon, waitTime);\n-        if (res != JVMTI_ERROR_NONE) {\n-            reportError(\"GetThreadState: unexpected error from RawMontiorWait\", res);\n-            return JNI_FALSE;\n-        }\n-        res = g_ppJvmtiEnv->RawMonitorExit(g_waitMon);\n-        if (res != JVMTI_ERROR_NONE) {\n-            reportError(\"GetThreadState: unexpected error from RawMonitorExit\", res);\n-            return JNI_FALSE;\n-        }\n-\n-        waitTime <<= 1;\n-\n-    } while (waitTime < g_waitTime);\n-\n-    return JNI_FALSE;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat005\/thrstat005.cpp","additions":0,"deletions":170,"binary":false,"changes":170,"status":"deleted"}]}