{"files":[{"patch":"@@ -190,0 +190,1 @@\n+        jdk.jfr,\n@@ -195,0 +196,1 @@\n+        jdk.jfr,\n@@ -196,0 +198,2 @@\n+    exports jdk.internal.classfile.components to\n+        jdk.jfr;\n@@ -199,0 +203,1 @@\n+        jdk.jfr,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-import jdk.jfr.internal.EventInstrumentation;\n+import jdk.jfr.internal.util.Utils;\n@@ -60,1 +60,1 @@\n-        return getTyped(EventInstrumentation.FIELD_STACK_TRACE, RecordedStackTrace.class, null);\n+        return getTyped(Utils.FIELD_STACK_TRACE, RecordedStackTrace.class, null);\n@@ -70,1 +70,1 @@\n-        return getTyped(EventInstrumentation.FIELD_EVENT_THREAD, RecordedThread.class, null);\n+        return getTyped(Utils.FIELD_EVENT_THREAD, RecordedThread.class, null);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordedEvent.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.PrintWriter;\n-\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.Type;\n-import jdk.internal.org.objectweb.asm.util.TraceClassVisitor;\n-import jdk.jfr.ValueDescriptor;\n-\n-final class ASMToolkit {\n-    public static final Type TYPE_STRING = Type.getType(String.class);\n-    private static final Type TYPE_THREAD = Type.getType(Thread.class);\n-    private static final Type TYPE_CLASS = Type.getType(Class.class);\n-\n-    public static Type toType(ValueDescriptor v) {\n-        return switch (v.getTypeName()) {\n-            case \"byte\" -> Type.BYTE_TYPE;\n-            case \"short\" -> Type.SHORT_TYPE;\n-            case \"int\" ->  Type.INT_TYPE;\n-            case \"long\" ->Type.LONG_TYPE;\n-            case \"double\" -> Type.DOUBLE_TYPE;\n-            case \"float\" -> Type.FLOAT_TYPE;\n-            case \"char\" -> Type.CHAR_TYPE;\n-            case \"boolean\" -> Type.BOOLEAN_TYPE;\n-            case \"java.lang.String\" -> TYPE_STRING;\n-            case \"java.lang.Thread\" -> TYPE_THREAD;\n-            case \"java.lang.Class\" -> TYPE_CLASS;\n-            default -> throw new Error(\"Not a valid type \" + v.getTypeName());\n-        };\n-    }\n-\n-    \/**\n-     * Converts \"int\" into \"I\" and \"java.lang.String\" into \"Ljava\/lang\/String;\"\n-     *\n-     * @param typeName\n-     *            type\n-     *\n-     * @return descriptor\n-     *\/\n-    public static String getDescriptor(String typeName) {\n-        return switch (typeName) {\n-            case \"int\" -> \"I\";\n-            case \"long\" -> \"J\";\n-            case \"boolean\" -> \"Z\";\n-            case \"float\" -> \"F\";\n-            case \"double\" -> \"D\";\n-            case \"short\" -> \"S\";\n-            case \"char\" -> \"C\";\n-            case \"byte\" -> \"B\";\n-            default -> Type.getObjectType(getInternalName(typeName)).getDescriptor();\n-        };\n-    }\n-\n-    \/**\n-     * Converts java.lang.String into java\/lang\/String\n-     *\n-     * @param className\n-     *\n-     * @return internal name\n-     *\/\n-    public static String getInternalName(String className) {\n-        return className.replace(\".\", \"\/\");\n-    }\n-\n-    public static void logASM(String className, byte[] bytes) {\n-        Logger.log(LogTag.JFR_SYSTEM_BYTECODE, LogLevel.INFO, \"Generated bytecode for class \" + className);\n-        if (Logger.shouldLog(LogTag.JFR_SYSTEM_BYTECODE, LogLevel.TRACE)) {\n-            ClassReader cr = new ClassReader(bytes);\n-            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-            PrintWriter w = new PrintWriter(baos);\n-            w.println(\"Bytecode:\");\n-            cr.accept(new TraceClassVisitor(w), 0);\n-            Logger.log(LogTag.JFR_SYSTEM_BYTECODE, LogLevel.TRACE, baos.toString());\n-        };\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/ASMToolkit.java","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,8 @@\n+import static jdk.jfr.internal.util.Bytecode.invokespecial;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.reflect.AccessFlag;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n@@ -31,8 +39,5 @@\n-import jdk.internal.org.objectweb.asm.AnnotationVisitor;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.Label;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n-import jdk.internal.org.objectweb.asm.commons.GeneratorAdapter;\n-import jdk.internal.org.objectweb.asm.commons.Method;\n+import jdk.internal.classfile.AnnotationValue;\n+import jdk.internal.classfile.ClassBuilder;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n@@ -42,1 +47,2 @@\n-\n+import jdk.jfr.internal.util.Bytecode;\n+import jdk.jfr.internal.util.Bytecode.MethodDesc;\n@@ -46,5 +52,4 @@\n-\n-    private static final Type TYPE_EVENT = Type.getType(Event.class);\n-    private static final Type TYPE_IOBE = Type.getType(IndexOutOfBoundsException.class);\n-    private static final Method DEFAULT_CONSTRUCTOR = Method.getMethod(\"void <init> ()\");\n-    private static final Method SET_METHOD = Method.getMethod(\"void set (int, java.lang.Object)\");\n+    private static final ClassDesc TYPE_EVENT = Bytecode.classDesc(Event.class);\n+    private static final ClassDesc TYPE_IOBE = Bytecode.classDesc(IndexOutOfBoundsException.class);\n+    private static final MethodDesc DEFAULT_CONSTRUCTOR = MethodDesc.of(\"<init>\", \"()V\");\n+    private static final MethodDesc SET_METHOD = MethodDesc.of(\"set\", \"(ILjava\/lang\/Object;)V\");\n@@ -52,1 +57,1 @@\n-    private final ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES);\n+\n@@ -54,1 +59,1 @@\n-    private final Type type;\n+    private final ClassDesc type;\n@@ -60,1 +65,1 @@\n-        this.type = Type.getType(\"L\" + fullClassName.replace(\".\", \"\/\") + \";\");\n+        this.type = ClassDesc.of(fullClassName);\n@@ -66,7 +71,7 @@\n-        buildClassInfo();\n-        buildConstructor();\n-        buildFields();\n-        buildSetMethod();\n-        endClass();\n-        byte[] bytes = classWriter.toByteArray();\n-        ASMToolkit.logASM(fullClassName, bytes);\n+        byte[] bytes = Classfile.of().build(ClassDesc.of(fullClassName), cb -> build(cb));\n+        try {\n+            String name = \"\/Users\/egahlin\/DynamicEvent\" + (idCounter.longValue() - 1);\n+            Files.write(Path.of(name + \".class\"), bytes);\n+        } catch (Exception ioe) {\n+\n+        }\n@@ -76,2 +81,5 @@\n-    private void endClass() {\n-        classWriter.visitEnd();\n+    void build(ClassBuilder builder) {\n+        buildClassInfo(builder);\n+        buildConstructor(builder);\n+        buildFields(builder);\n+        buildSetMethod(builder);\n@@ -80,19 +88,20 @@\n-    private void buildSetMethod() {\n-        GeneratorAdapter ga = new GeneratorAdapter(Opcodes.ACC_PUBLIC, SET_METHOD, null, null, classWriter);\n-        int index = 0;\n-        for (ValueDescriptor v : fields) {\n-            ga.loadArg(0);\n-            ga.visitLdcInsn(index);\n-            Label notEqual = new Label();\n-            ga.ifICmp(GeneratorAdapter.NE, notEqual);\n-            ga.loadThis();\n-            ga.loadArg(1);\n-            Type fieldType = ASMToolkit.toType(v);\n-            ga.unbox(ASMToolkit.toType(v));\n-            ga.putField(type, v.getName(), fieldType);\n-            ga.visitInsn(Opcodes.RETURN);\n-            ga.visitLabel(notEqual);\n-            index++;\n-        }\n-        ga.throwException(TYPE_IOBE, \"Index must between 0 and \" + fields.size());\n-        ga.endMethod();\n+    private void buildSetMethod(ClassBuilder builder) {\n+        \/\/ void Event::set(int index, Object value);\n+        builder.withMethod(SET_METHOD.name(), SET_METHOD.descriptor(), Classfile.ACC_PUBLIC, methodBuilder -> methodBuilder.withCode(codeBuilder -> {\n+            int index = 0;\n+            for (ValueDescriptor v : fields) {\n+                codeBuilder.iload(1);\n+                codeBuilder.ldc(index);\n+                Label notEqual = codeBuilder.newLabel();\n+                codeBuilder.if_icmpne(notEqual);\n+                codeBuilder.aload(0); \/\/ this\n+                codeBuilder.aload(2); \/\/ value\n+                ClassDesc cd = Bytecode.classDesc(v);\n+                Bytecode.unbox(codeBuilder, cd);\n+                codeBuilder.putfield(type, v.getName(), cd);\n+                codeBuilder.return_();\n+                codeBuilder.labelBinding(notEqual);\n+                index++;\n+            }\n+            Bytecode.throwException(codeBuilder, TYPE_IOBE, \"Index must between 0 and \" + fields.size());\n+        }));\n@@ -101,6 +110,6 @@\n-    private void buildConstructor() {\n-        MethodVisitor mv = classWriter.visitMethod(Opcodes.ACC_PUBLIC, DEFAULT_CONSTRUCTOR.getName(), DEFAULT_CONSTRUCTOR.getDescriptor(), null, null);\n-        mv.visitIntInsn(Opcodes.ALOAD, 0);\n-        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, TYPE_EVENT.getInternalName(), DEFAULT_CONSTRUCTOR.getName(), DEFAULT_CONSTRUCTOR.getDescriptor(), false);\n-        mv.visitInsn(Opcodes.RETURN);\n-        mv.visitMaxs(0, 0);\n+    private void buildConstructor(ClassBuilder builder) {\n+        builder.withMethod(ConstantDescs.INIT_NAME, ConstantDescs.MTD_void, Classfile.ACC_PUBLIC, methodBuilder -> methodBuilder.withCode(codeBuilder -> {\n+            codeBuilder.aload(0);\n+            invokespecial(codeBuilder, TYPE_EVENT, DEFAULT_CONSTRUCTOR);\n+            codeBuilder.return_();\n+        }));\n@@ -109,8 +118,6 @@\n-    private void buildClassInfo() {\n-        String internalSuperName = ASMToolkit.getInternalName(Event.class.getName());\n-        String internalClassName = type.getInternalName();\n-        classWriter.visit(52, Opcodes.ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_SUPER, internalClassName, null, internalSuperName, null);\n-\n-        for (AnnotationElement a : annotationElements) {\n-            String descriptor = ASMToolkit.getDescriptor(a.getTypeName());\n-            AnnotationVisitor av = classWriter.visitAnnotation(descriptor, true);\n+    private void buildClassInfo(ClassBuilder builder) {\n+        builder.withSuperclass(Bytecode.classDesc(Event.class));\n+        builder.withFlags(AccessFlag.FINAL, AccessFlag.PUBLIC, AccessFlag.SUPER);\n+        List<jdk.internal.classfile.Annotation> annotations = new ArrayList<>();\n+        for (jdk.jfr.AnnotationElement a : annotationElements) {\n+            List<jdk.internal.classfile.AnnotationElement> list = new ArrayList<>();\n@@ -118,12 +125,6 @@\n-                Object value = a.getValue(v.getName());\n-                String name = v.getName();\n-                if (v.isArray()) {\n-                    AnnotationVisitor arrayVisitor = av.visitArray(name);\n-                    Object[] array = (Object[]) value;\n-                    for (int i = 0; i < array.length; i++) {\n-                        arrayVisitor.visit(null, array[i]);\n-                    }\n-                    arrayVisitor.visitEnd();\n-                } else {\n-                    av.visit(name, value);\n-                }\n+                \/\/ ValueDescriptor can only hold primitive\n+                \/\/ No need to care about classes\/enums\n+                var value = a.getValue(v.getName());\n+                var av = AnnotationValue.of(value);\n+                var ae = jdk.internal.classfile.AnnotationElement.of(v.getName(), av);\n+                list.add(ae);\n@@ -131,1 +132,2 @@\n-            av.visitEnd();\n+            ClassDesc cd = ClassDesc.of(a.getTypeName());\n+            annotations.add(jdk.internal.classfile.Annotation.of(cd, list));\n@@ -133,0 +135,1 @@\n+        builder.with(RuntimeVisibleAnnotationsAttribute.of(annotations));\n@@ -135,1 +138,1 @@\n-    private void buildFields() {\n+    private void buildFields(ClassBuilder builder) {\n@@ -137,2 +140,1 @@\n-            String internal = ASMToolkit.getDescriptor(v.getTypeName());\n-            classWriter.visitField(Opcodes.ACC_PRIVATE, v.getName(), internal, null, null);\n+            builder.withField(v.getName(), Bytecode.classDesc(v), Classfile.ACC_PRIVATE);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventClassBuilder.java","additions":78,"deletions":76,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -33,0 +35,1 @@\n+import java.util.LinkedHashMap;\n@@ -34,0 +37,1 @@\n+import java.util.Map;\n@@ -37,11 +41,17 @@\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.Label;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n-import jdk.internal.org.objectweb.asm.commons.Method;\n-import jdk.internal.org.objectweb.asm.tree.AnnotationNode;\n-import jdk.internal.org.objectweb.asm.tree.ClassNode;\n-import jdk.internal.org.objectweb.asm.tree.FieldNode;\n-import jdk.internal.org.objectweb.asm.tree.MethodNode;\n+import jdk.internal.classfile.Annotation;\n+import jdk.internal.classfile.AnnotationElement;\n+import jdk.internal.classfile.AnnotationValue;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.CodeBuilder.BlockCodeBuilder;\n+import jdk.internal.classfile.FieldModel;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.MethodElement;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import jdk.jfr.internal.event.EventConfiguration;\n+import jdk.jfr.internal.event.EventWriter;\n@@ -49,1 +59,0 @@\n-import jdk.jfr.Event;\n@@ -54,2 +63,0 @@\n-import jdk.jfr.internal.event.EventConfiguration;\n-import jdk.jfr.internal.event.EventWriter;\n@@ -57,0 +64,8 @@\n+import jdk.jfr.internal.util.Bytecode;\n+import jdk.jfr.internal.util.Bytecode.FieldDesc;\n+import jdk.jfr.internal.util.Bytecode.MethodDesc;\n+import static jdk.jfr.internal.util.Bytecode.invokevirtual;\n+import static jdk.jfr.internal.util.Bytecode.invokestatic;\n+import static jdk.jfr.internal.util.Bytecode.getfield;\n+import static jdk.jfr.internal.util.Bytecode.putfield;\n+import static jdk.jfr.internal.util.Bytecode.classDesc;\n@@ -62,42 +77,33 @@\n-public final class EventInstrumentation {\n-\n-    record SettingInfo(Type paramType, String methodName) {\n-    }\n-\n-    record FieldInfo(String name, String descriptor) {\n-    }\n-\n-    public static final String FIELD_EVENT_THREAD = \"eventThread\";\n-    public static final String FIELD_STACK_TRACE = \"stackTrace\";\n-    public static final String FIELD_DURATION = \"duration\";\n-\n-    static final String FIELD_EVENT_CONFIGURATION = \"eventConfiguration\";\n-    static final String FIELD_START_TIME = \"startTime\";\n-\n-    private static final String ANNOTATION_NAME_DESCRIPTOR = Type.getDescriptor(Name.class);\n-    private static final String ANNOTATION_REGISTERED_DESCRIPTOR = Type.getDescriptor(Registered.class);\n-    private static final String ANNOTATION_ENABLED_DESCRIPTOR = Type.getDescriptor(Enabled.class);\n-    private static final Type TYPE_EVENT_CONFIGURATION = Type.getType(EventConfiguration.class);\n-    private static final Type TYPE_EVENT_WRITER = Type.getType(EventWriter.class);\n-    private static final Type TYPE_EVENT_WRITER_FACTORY = Type.getType(\"Ljdk\/jfr\/internal\/event\/EventWriterFactory;\");\n-    private static final Type TYPE_SETTING_CONTROL = Type.getType(SettingControl.class);\n-    private static final String TYPE_OBJECT_DESCRIPTOR = Type.getDescriptor(Object.class);\n-    private static final String TYPE_EVENT_CONFIGURATION_DESCRIPTOR = TYPE_EVENT_CONFIGURATION.getDescriptor();\n-    private static final String TYPE_SETTING_DEFINITION_DESCRIPTOR = Type.getDescriptor(SettingDefinition.class);\n-    private static final Method METHOD_COMMIT = new Method(\"commit\", Type.VOID_TYPE, new Type[0]);\n-    private static final Method METHOD_BEGIN = new Method(\"begin\", Type.VOID_TYPE, new Type[0]);\n-    private static final Method METHOD_END = new Method(\"end\", Type.VOID_TYPE, new Type[0]);\n-    private static final Method METHOD_IS_ENABLED = new Method(\"isEnabled\", Type.BOOLEAN_TYPE, new Type[0]);\n-    private static final Method METHOD_TIME_STAMP = new Method(\"timestamp\", Type.LONG_TYPE, new Type[0]);\n-    private static final Method METHOD_GET_EVENT_WRITER_KEY = new Method(\"getEventWriter\", TYPE_EVENT_WRITER, new Type[] { Type.LONG_TYPE });\n-    private static final Method METHOD_EVENT_SHOULD_COMMIT = new Method(\"shouldCommit\", Type.BOOLEAN_TYPE, new Type[0]);\n-    private static final Method METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT = new Method(\"shouldCommit\", Type.BOOLEAN_TYPE, new Type[] { Type.LONG_TYPE });\n-    private static final Method METHOD_EVENT_CONFIGURATION_GET_SETTING = new Method(\"getSetting\", TYPE_SETTING_CONTROL, new Type[] { Type.INT_TYPE });\n-    private static final Method METHOD_DURATION = new Method(\"duration\", Type.LONG_TYPE, new Type[] { Type.LONG_TYPE });\n-    private static final Method METHOD_RESET = new Method(\"reset\", \"()V\");\n-    private static final Method METHOD_ENABLED = new Method(\"enabled\", Type.BOOLEAN_TYPE, new Type[0]);\n-    private static final Method METHOD_SHOULD_COMMIT_LONG = new Method(\"shouldCommit\", Type.BOOLEAN_TYPE, new Type[] { Type.LONG_TYPE });\n-\n-    private final ClassNode classNode;\n-    private final List<SettingInfo> settingInfos;\n-    private final List<FieldInfo> fieldInfos;;\n+final class EventInstrumentation {\n+\n+    private record SettingDesc(ClassDesc paramType, String methodName) {\n+    }\n+\n+    private static final FieldDesc FIELD_DURATION = FieldDesc.of(Utils.FIELD_DURATION, long.class);\n+    private static final FieldDesc FIELD_EVENT_CONFIGURATION = FieldDesc.of(\"eventConfiguration\", Object.class);;\n+    private static final FieldDesc FIELD_START_TIME = FieldDesc.of(Utils.FIELD_START_TIME, long.class);\n+    private static final ClassDesc ANNOTATION_ENABLED = classDesc(Enabled.class);\n+    private static final ClassDesc ANNOTATION_NAME = classDesc(Name.class);\n+    private static final ClassDesc ANNOTATION_REGISTERED = classDesc(Registered.class);\n+    private static final ClassDesc TYPE_EVENT_CONFIGURATION = classDesc(EventConfiguration.class);\n+    private static final ClassDesc TYPE_EVENT_WRITER = classDesc(EventWriter.class);\n+    private static final ClassDesc TYPE_EVENT_WRITER_FACTORY = ClassDesc.of(\"jdk.jfr.internal.event.EventWriterFactory\");\n+    private static final ClassDesc TYPE_OBJECT = Bytecode.classDesc(Object.class);\n+    private static final ClassDesc TYPE_SETTING_DEFINITION = Bytecode.classDesc(SettingDefinition.class);\n+    private static final MethodDesc METHOD_BEGIN = MethodDesc.of(\"begin\", \"()V\");\n+    private static final MethodDesc METHOD_COMMIT = MethodDesc.of(\"commit\", \"()V\");\n+    private static final MethodDesc METHOD_DURATION = MethodDesc.of(\"duration\", \"(J)J\");\n+    private static final MethodDesc METHOD_ENABLED = MethodDesc.of(\"enabled\", \"()Z\");\n+    private static final MethodDesc METHOD_END = MethodDesc.of(\"end\", \"()V\");\n+    private static final MethodDesc METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT = MethodDesc.of(\"shouldCommit\", \"(J)Z\");\n+    private static final MethodDesc METHOD_EVENT_CONFIGURATION_GET_SETTING = MethodDesc.of(\"getSetting\", SettingControl.class, int.class);\n+    private static final MethodDesc METHOD_EVENT_SHOULD_COMMIT = MethodDesc.of(\"shouldCommit\", \"()Z\");\n+    private static final MethodDesc METHOD_GET_EVENT_WRITER_KEY = MethodDesc.of(\"getEventWriter\", \"(J)\" + TYPE_EVENT_WRITER.descriptorString());\n+    private static final MethodDesc METHOD_IS_ENABLED = MethodDesc.of(\"isEnabled\", \"()Z\");\n+    private static final MethodDesc METHOD_RESET = MethodDesc.of(\"reset\", \"()V\");\n+    private static final MethodDesc METHOD_SHOULD_COMMIT_LONG = MethodDesc.of(\"shouldCommit\", \"(J)Z\");\n+    private static final MethodDesc METHOD_TIME_STAMP = MethodDesc.of(\"timestamp\", \"()J\");\n+\n+    private final ClassModel classModel;\n+    private final List<SettingDesc> settingDescs;\n+    private final List<FieldDesc> fieldDescs;;\n@@ -107,1 +113,1 @@\n-    private final Method staticCommitMethod;\n+    private final MethodDesc staticCommitMethod;\n@@ -111,0 +117,1 @@\n+    private final Map<MethodDesc, Consumer<CodeBuilder>> methodUpdates = new LinkedHashMap<>();\n@@ -115,6 +122,6 @@\n-        this.classNode = createClassNode(bytes);\n-        this.settingInfos = buildSettingInfos(superClass, classNode);\n-        this.fieldInfos = buildFieldInfos(superClass, classNode);\n-        String n = annotationValue(classNode, ANNOTATION_NAME_DESCRIPTOR, String.class);\n-        this.eventName = n == null ? classNode.name.replace(\"\/\", \".\") : n;\n-        this.staticCommitMethod = isJDK ? findStaticCommitMethod(classNode, fieldInfos) : null;\n+        this.classModel = createClassModel(bytes);\n+        this.settingDescs = buildSettingDescs(superClass, classModel);\n+        this.fieldDescs = buildFieldDescs(superClass, classModel);\n+        String n = annotationValue(classModel, ANNOTATION_NAME, String.class);\n+        this.eventName = n == null ? classModel.thisClass().asInternalName().replace(\"\/\", \".\") : n;\n+        this.staticCommitMethod = isJDK ? findStaticCommitMethod(classModel, fieldDescs) : null;\n@@ -122,2 +129,4 @@\n-        \/\/ Corner case when we are forced to generate bytecode (bytesForEagerInstrumentation)\n-        \/\/ We can't reference EventConfiguration::isEnabled() before event class has been registered,\n+        \/\/ Corner case when we are forced to generate bytecode\n+        \/\/ (bytesForEagerInstrumentation)\n+        \/\/ We can't reference EventConfiguration::isEnabled() before event class has\n+        \/\/ been registered,\n@@ -129,1 +138,1 @@\n-    public static Method findStaticCommitMethod(ClassNode classNode, List<FieldInfo> fields) {\n+    static MethodDesc findStaticCommitMethod(ClassModel classModel, List<FieldDesc> fields) {\n@@ -132,2 +141,2 @@\n-        for (FieldInfo field : fields) {\n-            sb.append(field.descriptor);\n+        for (FieldDesc field : fields) {\n+            sb.append(field.type().descriptorString());\n@@ -136,3 +145,4 @@\n-        Method m = new Method(\"commit\", sb.toString());\n-        for (MethodNode method : classNode.methods) {\n-            if (\"commit\".equals(method.name) && m.getDescriptor().equals(method.desc)) {\n+        MethodDesc m = MethodDesc.of(\"commit\", sb.toString());\n+        for (MethodModel method : classModel.methods()) {\n+            String d = method.methodTypeSymbol().descriptorString();\n+            if (method.methodName().equalsString(\"commit\") && m.descriptor().descriptorString().equals(d)) {\n@@ -146,3 +156,3 @@\n-        for (FieldNode field : classNode.fields) {\n-            if (FIELD_EVENT_CONFIGURATION.equals(field.name)) {\n-                return field.desc.equals(TYPE_OBJECT_DESCRIPTOR);\n+        for (FieldModel f : classModel.fields()) {\n+            if (f.fieldName().equalsString(FIELD_EVENT_CONFIGURATION.name())) {\n+                return f.fieldType().equalsString(TYPE_OBJECT.descriptorString());\n@@ -155,1 +165,1 @@\n-        return classNode.name.replace(\"\/\", \".\");\n+        return classModel.thisClass().asInternalName().replace(\"\/\", \".\");\n@@ -158,5 +168,2 @@\n-    private ClassNode createClassNode(byte[] bytes) {\n-        ClassNode classNode = new ClassNode();\n-        ClassReader classReader = new ClassReader(bytes);\n-        classReader.accept(classNode, 0);\n-        return classNode;\n+    private ClassModel createClassModel(byte[] bytes) {\n+        return Classfile.of().parse(bytes);\n@@ -166,1 +173,1 @@\n-        Boolean result = annotationValue(classNode, ANNOTATION_REGISTERED_DESCRIPTOR, Boolean.class);\n+        Boolean result = annotationValue(classModel, ANNOTATION_REGISTERED, Boolean.class);\n@@ -180,1 +187,1 @@\n-        Boolean result = annotationValue(classNode, ANNOTATION_ENABLED_DESCRIPTOR, Boolean.class);\n+        Boolean result = annotationValue(classModel, ANNOTATION_ENABLED, Boolean.class);\n@@ -194,12 +201,11 @@\n-    private static <T> T annotationValue(ClassNode classNode, String typeDescriptor, Class<?> type) {\n-        if (classNode.visibleAnnotations != null) {\n-            for (AnnotationNode a : classNode.visibleAnnotations) {\n-                if (typeDescriptor.equals(a.desc)) {\n-                    List<Object> values = a.values;\n-                    if (values != null && values.size() == 2) {\n-                        Object key = values.get(0);\n-                        Object value = values.get(1);\n-                        if (key instanceof String keyName && value != null) {\n-                            if (type == value.getClass()) {\n-                                if (\"value\".equals(keyName)) {\n-                                    return (T) value;\n+    private static <T> T annotationValue(ClassModel classModel, ClassDesc classDesc, Class<?> type) {\n+        String typeDescriptor = classDesc.descriptorString();\n+        for (ClassElement ce : classModel.elements()) {\n+            if (ce instanceof RuntimeVisibleAnnotationsAttribute rvaa) {\n+                for (Annotation a : rvaa.annotations()) {\n+                    if (a.className().equalsString(typeDescriptor)) {\n+                        if (a.elements().size() == 1) {\n+                            AnnotationElement ae = a.elements().getFirst();\n+                            if (ae.name().equalsString(\"value\")) {\n+                                if (ae.value() instanceof AnnotationValue.OfString s) {\n+                                    return (T) s.stringValue();\n@@ -216,1 +222,1 @@\n-    private static List<SettingInfo> buildSettingInfos(Class<?> superClass, ClassNode classNode) {\n+    private static List<SettingDesc> buildSettingDescs(Class<?> superClass, ClassModel classModel) {\n@@ -218,14 +224,21 @@\n-        List<SettingInfo> settingInfos = new ArrayList<>();\n-        for (MethodNode m : classNode.methods) {\n-            if (m.visibleAnnotations != null) {\n-                for (AnnotationNode an : m.visibleAnnotations) {\n-                    \/\/ We can't really validate the method at this\n-                    \/\/ stage. We would need to check that the parameter\n-                    \/\/ is an instance of SettingControl.\n-                    if (TYPE_SETTING_DEFINITION_DESCRIPTOR.equals(an.desc)) {\n-                        String name = m.name;\n-                        for (AnnotationNode nameCandidate : m.visibleAnnotations) {\n-                            if (ANNOTATION_NAME_DESCRIPTOR.equals(nameCandidate.desc)) {\n-                                List<Object> values = nameCandidate.values;\n-                                if (values.size() == 1 && values.getFirst() instanceof String s) {\n-                                    name = Utils.validJavaIdentifier(s, name);\n+        List<SettingDesc> settingDescs = new ArrayList<>();\n+        for (MethodModel m : classModel.methods()) {\n+            for (MethodElement me : m.elements()) {\n+                if (me instanceof RuntimeVisibleAnnotationsAttribute rvaa) {\n+                    for (Annotation a : rvaa.annotations()) {\n+                        \/\/ We can't really validate the method at this\n+                        \/\/ stage. We would need to check that the parameter\n+                        \/\/ is an instance of SettingControl.\n+                        if (a.className().equalsString(TYPE_SETTING_DEFINITION.descriptorString())) {\n+                            String name = m.methodName().stringValue();\n+                            \/\/ Use @Name if it exists\n+                            for (Annotation nameCandidate : rvaa.annotations()) {\n+                                if (nameCandidate.className().equalsString(ANNOTATION_NAME.descriptorString())) {\n+                                    if (nameCandidate.elements().size() == 1) {\n+                                        AnnotationElement ae = nameCandidate.elements().getFirst();\n+                                        if (ae.name().equalsString(\"value\")) {\n+                                            if (ae.value() instanceof AnnotationValue.OfString s) {\n+                                                name = Utils.validJavaIdentifier(s.stringValue(), name);\n+                                            }\n+                                        }\n+                                    }\n@@ -234,8 +247,11 @@\n-                        }\n-                        Type returnType = Type.getReturnType(m.desc);\n-                        if (returnType.equals(Type.getType(Boolean.TYPE))) {\n-                            Type[] args = Type.getArgumentTypes(m.desc);\n-                            if (args.length == 1) {\n-                                Type paramType = args[0];\n-                                methodSet.add(m.name);\n-                                settingInfos.add(new SettingInfo(paramType, m.name));\n+                            \/\/ Add setting if method returns boolean and has one parameter\n+                            MethodTypeDesc mtd = m.methodTypeSymbol();\n+                            if (\"Z\".equals(mtd.returnType().descriptorString())) {\n+                                if (mtd.parameterList().size() == 1) {\n+                                    ClassDesc paramType = mtd.parameterList().getFirst();\n+                                    if (!paramType.isPrimitive()) {\n+                                        String methodName = m.methodName().stringValue();\n+                                        methodSet.add(methodName);\n+                                        settingDescs.add(new SettingDesc(paramType, methodName));\n+                                    }\n+                                }\n@@ -248,1 +264,1 @@\n-        for (Class<?> c = superClass; c != jdk.internal.event.Event.class; c = c.getSuperclass()) {\n+        for (Class<?> c = superClass; jdk.internal.event.Event.class != c; c = c.getSuperclass()) {\n@@ -256,3 +272,5 @@\n-                                Type paramType = Type.getType(param.getType());\n-                                methodSet.add(method.getName());\n-                                settingInfos.add(new SettingInfo(paramType, method.getName()));\n+                                if (!param.getType().isPrimitive()) {\n+                                    ClassDesc paramType = Bytecode.classDesc(param.getType());\n+                                    methodSet.add(method.getName());\n+                                    settingDescs.add(new SettingDesc(paramType, method.getName()));\n+                                }\n@@ -265,1 +283,1 @@\n-        return settingInfos;\n+        return settingDescs;\n@@ -268,1 +286,1 @@\n-    private static List<FieldInfo> buildFieldInfos(Class<?> superClass, ClassNode classNode) {\n+    private static List<FieldDesc> buildFieldDescs(Class<?> superClass, ClassModel classModel) {\n@@ -270,1 +288,1 @@\n-        List<FieldInfo> fieldInfos = new ArrayList<>(classNode.fields.size());\n+        List<FieldDesc> fieldDescs = new ArrayList<>(classModel.fields().size());\n@@ -277,7 +295,7 @@\n-        fieldInfos.add(new FieldInfo(\"startTime\", Type.LONG_TYPE.getDescriptor()));\n-        fieldInfos.add(new FieldInfo(\"duration\", Type.LONG_TYPE.getDescriptor()));\n-        for (FieldNode field : classNode.fields) {\n-            if (!fieldSet.contains(field.name) && isValidField(field.access, Type.getType(field.desc).getClassName())) {\n-                FieldInfo fi = new FieldInfo(field.name, field.desc);\n-                fieldInfos.add(fi);\n-                fieldSet.add(field.name);\n+        fieldDescs.add(FIELD_START_TIME);\n+        fieldDescs.add(FIELD_DURATION);\n+        for (FieldModel field : classModel.fields()) {\n+            if (!fieldSet.contains(field.fieldName().stringValue()) && isValidField(field.flags().flagsMask(), field.fieldTypeSymbol())) {\n+                FieldDesc fi = FieldDesc.of(field.fieldTypeSymbol(), field.fieldName().stringValue());\n+                fieldDescs.add(fi);\n+                fieldSet.add(field.fieldName().stringValue());\n@@ -286,1 +304,1 @@\n-        for (Class<?> c = superClass; c != jdk.internal.event.Event.class; c = c.getSuperclass()) {\n+        for (Class<?> c = superClass; jdk.internal.event.Event.class != c; c = c.getSuperclass()) {\n@@ -293,2 +311,1 @@\n-                            Type fieldType = Type.getType(field.getType());\n-                            fieldInfos.add(new FieldInfo(fieldName, fieldType.getDescriptor()));\n+                            fieldDescs.add(FieldDesc.of(fieldName, field.getType()));\n@@ -301,1 +318,10 @@\n-        return fieldInfos;\n+        return fieldDescs;\n+    }\n+\n+    public static boolean isValidField(int access, ClassDesc classDesc) {\n+        String className = classDesc.packageName();\n+        if (!className.isEmpty()) {\n+            className = className + \".\";\n+        }\n+        className += classDesc.displayName();\n+        return isValidField(access, className);\n@@ -308,1 +334,1 @@\n-        return jdk.jfr.internal.Type.isValidJavaFieldType(className);\n+        return Type.isValidJavaFieldType(className);\n@@ -316,5 +342,18 @@\n-    private byte[] toByteArray() {\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);\n-        classNode.accept(cw);\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+    byte[] toByteArray() {\n+        return Classfile.of().build(classModel.thisClass().asSymbol(), classBuilder -> {\n+            for (ClassElement ce : classModel) {\n+                boolean updated = false;\n+                if (ce instanceof MethodModel method) {\n+                    Consumer<CodeBuilder> methodUpdate = findMethodUpdate(method);\n+                    if (methodUpdate != null) {\n+                        classBuilder.withMethod(method.methodName().stringValue(), method.methodTypeSymbol(), method.flags().flagsMask(), methodBuilder -> {\n+                            methodBuilder.withCode(methodUpdate);\n+                        });\n+                        updated = true;\n+                    }\n+                }\n+                if (!updated) {\n+                    classBuilder.with(ce);\n+                }\n+            }\n+        });\n@@ -333,5 +372,5 @@\n-        updateMethod(METHOD_BEGIN, methodVisitor -> {\n-            methodVisitor.visitIntInsn(Opcodes.ALOAD, 0);\n-            invokeStatic(methodVisitor, TYPE_EVENT_CONFIGURATION.getInternalName(), METHOD_TIME_STAMP);\n-            methodVisitor.visitFieldInsn(Opcodes.PUTFIELD, getInternalClassName(), FIELD_START_TIME, \"J\");\n-            methodVisitor.visitInsn(Opcodes.RETURN);\n+        updateMethod(METHOD_BEGIN, codeBuilder -> {\n+            codeBuilder.aload(0);\n+            invokestatic(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_TIME_STAMP);\n+            putfield(codeBuilder, getEventClassDesc(), FIELD_START_TIME);\n+            codeBuilder.return_();\n@@ -341,8 +380,7 @@\n-        updateMethod(METHOD_END, methodVisitor -> {\n-            methodVisitor.visitIntInsn(Opcodes.ALOAD, 0);\n-            methodVisitor.visitIntInsn(Opcodes.ALOAD, 0);\n-            methodVisitor.visitFieldInsn(Opcodes.GETFIELD, getInternalClassName(), FIELD_START_TIME, \"J\");\n-            invokeStatic(methodVisitor, TYPE_EVENT_CONFIGURATION.getInternalName(), METHOD_DURATION);\n-            methodVisitor.visitFieldInsn(Opcodes.PUTFIELD, getInternalClassName(), FIELD_DURATION, \"J\");\n-            methodVisitor.visitInsn(Opcodes.RETURN);\n-            methodVisitor.visitMaxs(0, 0);\n+        updateMethod(METHOD_END, codeBuilder -> {\n+            codeBuilder.aload(0);\n+            codeBuilder.aload(0);\n+            getfield(codeBuilder, getEventClassDesc(), FIELD_START_TIME);\n+            invokestatic(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_DURATION);\n+            putfield(codeBuilder, getEventClassDesc(), FIELD_DURATION);\n+            codeBuilder.return_();\n@@ -352,218 +390,9 @@\n-        if (staticCommitMethod != null) {\n-            updateExistingWithEmptyVoidMethod(METHOD_COMMIT);\n-            updateMethod(staticCommitMethod, mv -> {\n-                \/\/ indexes the argument type array, the argument type array does not include\n-                \/\/ 'this'\n-                int argIndex = 0;\n-                \/\/ indexes the proper slot in the local variable table, takes type size into\n-                \/\/ account, therefore sometimes argIndex != slotIndex\n-                int slotIndex = 0;\n-                int fieldIndex = 0;\n-                Type[] argumentTypes = Type.getArgumentTypes(staticCommitMethod.getDescriptor());\n-                mv.visitCode();\n-                Label start = new Label();\n-                Label endTryBlock = new Label();\n-                Label exceptionHandler = new Label();\n-                mv.visitTryCatchBlock(start, endTryBlock, exceptionHandler, \"java\/lang\/Throwable\");\n-                mv.visitLabel(start);\n-                getEventWriter(mv);\n-                \/\/ stack: [EW]\n-                mv.visitInsn(Opcodes.DUP);\n-                \/\/ stack: [EW], [EW]\n-                \/\/ write begin event\n-                getEventConfiguration(mv);\n-                \/\/ stack: [EW], [EW], [EventConfiguration]\n-                mv.visitLdcInsn(eventTypeId);\n-                \/\/ stack: [EW], [EW], [EventConfiguration] [long]\n-                visitMethod(mv, Opcodes.INVOKEVIRTUAL, TYPE_EVENT_WRITER, EventWriterMethod.BEGIN_EVENT.asASM());\n-                \/\/ stack: [EW], [integer]\n-                Label excluded = new Label();\n-                mv.visitJumpInsn(Opcodes.IFEQ, excluded);\n-                \/\/ stack: [EW]\n-                \/\/ write startTime\n-                mv.visitInsn(Opcodes.DUP);\n-                \/\/ stack: [EW], [EW]\n-                mv.visitVarInsn(argumentTypes[argIndex].getOpcode(Opcodes.ILOAD), slotIndex);\n-                \/\/ stack: [EW], [EW], [long]\n-                slotIndex += argumentTypes[argIndex++].getSize();\n-                visitMethod(mv, Opcodes.INVOKEVIRTUAL, TYPE_EVENT_WRITER, EventWriterMethod.PUT_LONG.asASM());\n-                \/\/ stack: [EW]\n-                fieldIndex++;\n-                \/\/ write duration\n-                mv.visitInsn(Opcodes.DUP);\n-                \/\/ stack: [EW], [EW]\n-                mv.visitVarInsn(argumentTypes[argIndex].getOpcode(Opcodes.ILOAD), slotIndex);\n-                \/\/ stack: [EW], [EW], [long]\n-                slotIndex += argumentTypes[argIndex++].getSize();\n-                visitMethod(mv, Opcodes.INVOKEVIRTUAL, TYPE_EVENT_WRITER, EventWriterMethod.PUT_LONG.asASM());\n-                \/\/ stack: [EW]\n-                fieldIndex++;\n-                \/\/ write eventThread\n-                mv.visitInsn(Opcodes.DUP);\n-                \/\/ stack: [EW], [EW]\n-                visitMethod(mv, Opcodes.INVOKEVIRTUAL, TYPE_EVENT_WRITER, EventWriterMethod.PUT_EVENT_THREAD.asASM());\n-                \/\/ stack: [EW]\n-                \/\/ write stackTrace\n-                mv.visitInsn(Opcodes.DUP);\n-                \/\/ stack: [EW], [EW]\n-                visitMethod(mv, Opcodes.INVOKEVIRTUAL, TYPE_EVENT_WRITER, EventWriterMethod.PUT_STACK_TRACE.asASM());\n-                \/\/ stack: [EW]\n-                \/\/ write custom fields\n-                while (fieldIndex < fieldInfos.size()) {\n-                    mv.visitInsn(Opcodes.DUP);\n-                    \/\/ stack: [EW], [EW]\n-                    mv.visitVarInsn(argumentTypes[argIndex].getOpcode(Opcodes.ILOAD), slotIndex);\n-                    \/\/ stack:[EW], [EW], [field]\n-                    slotIndex += argumentTypes[argIndex++].getSize();\n-                    FieldInfo field = fieldInfos.get(fieldIndex);\n-                    EventWriterMethod eventMethod = EventWriterMethod.lookupMethod(field);\n-                    visitMethod(mv, Opcodes.INVOKEVIRTUAL, TYPE_EVENT_WRITER, eventMethod.asASM());\n-                    \/\/ stack: [EW]\n-                    fieldIndex++;\n-                }\n-                \/\/ stack: [EW]\n-                \/\/ write end event (writer already on stack)\n-                visitMethod(mv, Opcodes.INVOKEVIRTUAL, TYPE_EVENT_WRITER, EventWriterMethod.END_EVENT.asASM());\n-                \/\/ stack [integer]\n-                \/\/ notified -> restart event write attempt\n-                mv.visitJumpInsn(Opcodes.IFEQ, start);\n-                \/\/ stack:\n-                mv.visitLabel(endTryBlock);\n-                Label end = new Label();\n-                mv.visitJumpInsn(Opcodes.GOTO, end);\n-                mv.visitLabel(exceptionHandler);\n-                \/\/ stack: [ex]\n-                mv.visitFrame(Opcodes.F_SAME1, 0, null, 1, new Object[] { \"java\/lang\/Throwable\" });\n-                getEventWriter(mv);\n-                \/\/ stack: [ex] [EW]\n-                mv.visitInsn(Opcodes.DUP);\n-                \/\/ stack: [ex] [EW] [EW]\n-                Label rethrow = new Label();\n-                mv.visitJumpInsn(Opcodes.IFNULL, rethrow);\n-                \/\/ stack: [ex] [EW]\n-                mv.visitInsn(Opcodes.DUP);\n-                \/\/ stack: [ex] [EW] [EW]\n-                visitMethod(mv, Opcodes.INVOKEVIRTUAL, TYPE_EVENT_WRITER, METHOD_RESET);\n-                mv.visitLabel(rethrow);\n-                \/\/ stack:[ex] [EW]\n-                mv.visitFrame(Opcodes.F_SAME, 0, null, 2, new Object[] { \"java\/lang\/Throwable\", TYPE_EVENT_WRITER.getInternalName() });\n-                mv.visitInsn(Opcodes.POP);\n-                \/\/ stack:[ex]\n-                mv.visitInsn(Opcodes.ATHROW);\n-                mv.visitLabel(excluded);\n-                \/\/ stack: [EW]\n-                mv.visitFrame(Opcodes.F_SAME, 0, null, 1, new Object[] { TYPE_EVENT_WRITER.getInternalName() });\n-                mv.visitInsn(Opcodes.POP);\n-                mv.visitLabel(end);\n-                \/\/ stack:\n-                mv.visitFrame(Opcodes.F_SAME, 0, null, 0, null);\n-                mv.visitInsn(Opcodes.RETURN);\n-                mv.visitMaxs(0, 0);\n-                mv.visitEnd();\n-            });\n-        } else {\n-            updateMethod(METHOD_COMMIT, methodVisitor -> {\n-                \/\/ if (!isEnable()) {\n-                \/\/ return;\n-                \/\/ }\n-                methodVisitor.visitCode();\n-                Label start = new Label();\n-                Label endTryBlock = new Label();\n-                Label exceptionHandler = new Label();\n-                methodVisitor.visitTryCatchBlock(start, endTryBlock, exceptionHandler, \"java\/lang\/Throwable\");\n-                methodVisitor.visitLabel(start);\n-                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n-                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, getInternalClassName(), METHOD_IS_ENABLED.getName(), METHOD_IS_ENABLED.getDescriptor(), false);\n-                Label l0 = new Label();\n-                methodVisitor.visitJumpInsn(Opcodes.IFNE, l0);\n-                methodVisitor.visitInsn(Opcodes.RETURN);\n-                methodVisitor.visitLabel(l0);\n-                methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 0, null);\n-                \/\/ long startTime = this.startTime\n-                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n-                methodVisitor.visitFieldInsn(Opcodes.GETFIELD, getInternalClassName(), FIELD_START_TIME, \"J\");\n-                methodVisitor.visitVarInsn(Opcodes.LSTORE, 1);\n-                \/\/ if (startTime == 0) {\n-                \/\/ startTime = EventWriter.timestamp();\n-                \/\/ } else {\n-                methodVisitor.visitVarInsn(Opcodes.LLOAD, 1);\n-                methodVisitor.visitInsn(Opcodes.LCONST_0);\n-                methodVisitor.visitInsn(Opcodes.LCMP);\n-                Label durationalEvent = new Label();\n-                methodVisitor.visitJumpInsn(Opcodes.IFNE, durationalEvent);\n-                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, TYPE_EVENT_CONFIGURATION.getInternalName(), METHOD_TIME_STAMP.getName(), METHOD_TIME_STAMP.getDescriptor(), false);\n-                methodVisitor.visitVarInsn(Opcodes.LSTORE, 1);\n-                Label commit = new Label();\n-                methodVisitor.visitJumpInsn(Opcodes.GOTO, commit);\n-                \/\/ if (duration == 0) {\n-                \/\/ duration = EventWriter.timestamp() - startTime;\n-                \/\/ }\n-                \/\/ }\n-                methodVisitor.visitLabel(durationalEvent);\n-                methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 0, null);\n-                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n-                methodVisitor.visitFieldInsn(Opcodes.GETFIELD, getInternalClassName(), FIELD_DURATION, \"J\");\n-                methodVisitor.visitInsn(Opcodes.LCONST_0);\n-                methodVisitor.visitInsn(Opcodes.LCMP);\n-                methodVisitor.visitJumpInsn(Opcodes.IFNE, commit);\n-                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n-                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, TYPE_EVENT_CONFIGURATION.getInternalName(), METHOD_TIME_STAMP.getName(), METHOD_TIME_STAMP.getDescriptor(), false);\n-                methodVisitor.visitVarInsn(Opcodes.LLOAD, 1);\n-                methodVisitor.visitInsn(Opcodes.LSUB);\n-                methodVisitor.visitFieldInsn(Opcodes.PUTFIELD, getInternalClassName(), FIELD_DURATION, \"J\");\n-                methodVisitor.visitLabel(commit);\n-                \/\/ if (shouldCommit()) {\n-                methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 0, null);\n-                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n-                invokeVirtual(methodVisitor, getInternalClassName(), METHOD_EVENT_SHOULD_COMMIT);\n-                Label end = new Label();\n-                methodVisitor.visitJumpInsn(Opcodes.IFEQ, end);\n-                getEventWriter(methodVisitor);\n-                \/\/ stack: [EW]\n-                methodVisitor.visitInsn(Opcodes.DUP);\n-                \/\/ stack: [EW] [EW]\n-                getEventConfiguration(methodVisitor);\n-                \/\/ stack: [EW] [EW] [EC]\n-                methodVisitor.visitLdcInsn(eventTypeId);\n-                invokeVirtual(methodVisitor, TYPE_EVENT_WRITER, EventWriterMethod.BEGIN_EVENT.asmMethod);\n-                Label excluded = new Label();\n-                \/\/ stack: [EW] [int]\n-                methodVisitor.visitJumpInsn(Opcodes.IFEQ, excluded);\n-                \/\/ stack: [EW]\n-                int fieldIndex = 0;\n-                methodVisitor.visitInsn(Opcodes.DUP);\n-                \/\/ stack: [EW] [EW]\n-                methodVisitor.visitVarInsn(Opcodes.LLOAD, 1);\n-                \/\/ stack: [EW] [EW] [long]\n-                invokeVirtual(methodVisitor, TYPE_EVENT_WRITER, EventWriterMethod.PUT_LONG.asmMethod);\n-                \/\/ stack: [EW]\n-                fieldIndex++;\n-                methodVisitor.visitInsn(Opcodes.DUP);\n-                \/\/ stack: [EW] [EW]\n-                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n-                \/\/ stack: [EW] [EW] [this]\n-                methodVisitor.visitFieldInsn(Opcodes.GETFIELD, getInternalClassName(), FIELD_DURATION, \"J\");\n-                \/\/ stack: [EW] [EW] [long]\n-                invokeVirtual(methodVisitor, TYPE_EVENT_WRITER, EventWriterMethod.PUT_LONG.asmMethod);\n-                \/\/ stack: [EW]\n-                fieldIndex++;\n-                methodVisitor.visitInsn(Opcodes.DUP);\n-                \/\/ stack: [EW] [EW]\n-                invokeVirtual(methodVisitor, TYPE_EVENT_WRITER, EventWriterMethod.PUT_EVENT_THREAD.asASM());\n-                \/\/ stack: [EW]\n-                methodVisitor.visitInsn(Opcodes.DUP);\n-                \/\/ stack: [EW] [EW]\n-                invokeVirtual(methodVisitor, TYPE_EVENT_WRITER, EventWriterMethod.PUT_STACK_TRACE.asASM());\n-                \/\/ stack: [EW]\n-                while (fieldIndex < fieldInfos.size()) {\n-                    FieldInfo field = fieldInfos.get(fieldIndex);\n-                    methodVisitor.visitInsn(Opcodes.DUP);\n-                    \/\/ stack: [EW] [EW]\n-                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n-                    \/\/ stack: [EW] [EW] [this]\n-                    methodVisitor.visitFieldInsn(Opcodes.GETFIELD, getInternalClassName(), field.name, field.descriptor);\n-                    \/\/ stack: [EW] [EW] <T>\n-                    EventWriterMethod eventMethod = EventWriterMethod.lookupMethod(field);\n-                    invokeVirtual(methodVisitor, TYPE_EVENT_WRITER, eventMethod.asmMethod);\n-                    \/\/ stack: [EW]\n-                    fieldIndex++;\n+        MethodDesc m = staticCommitMethod == null ? METHOD_COMMIT : staticCommitMethod;\n+        updateMethod(m, codeBuilder -> {\n+            Label excluded = codeBuilder.newLabel();\n+            Label end = codeBuilder.newLabel();\n+            codeBuilder.trying(blockCodeBuilder -> {\n+                if (staticCommitMethod != null) {\n+                    updateStaticCommit(blockCodeBuilder, excluded);\n+                } else {\n+                    updateInstanceCommit(blockCodeBuilder, end, excluded);\n@@ -571,3 +400,1 @@\n-                \/\/ stack:[EW]\n-                invokeVirtual(methodVisitor, TYPE_EVENT_WRITER, EventWriterMethod.END_EVENT.asASM());\n-                \/\/ stack [int]\n+                \/\/ stack: [integer]\n@@ -575,32 +402,21 @@\n-                methodVisitor.visitJumpInsn(Opcodes.IFEQ, start);\n-                methodVisitor.visitLabel(endTryBlock);\n-                methodVisitor.visitJumpInsn(Opcodes.GOTO, end);\n-                methodVisitor.visitLabel(exceptionHandler);\n-                \/\/ stack: [ex]\n-                methodVisitor.visitFrame(Opcodes.F_SAME1, 0, null, 1, new Object[] { \"java\/lang\/Throwable\" });\n-                getEventWriter(methodVisitor);\n-                \/\/ stack: [ex] [EW]\n-                methodVisitor.visitInsn(Opcodes.DUP);\n-                \/\/ stack: [ex] [EW] [EW]\n-                Label rethrow = new Label();\n-                methodVisitor.visitJumpInsn(Opcodes.IFNULL, rethrow);\n-                \/\/ stack: [ex] [EW]\n-                methodVisitor.visitInsn(Opcodes.DUP);\n-                \/\/ stack: [ex] [EW] [EW]\n-                visitMethod(methodVisitor, Opcodes.INVOKEVIRTUAL, TYPE_EVENT_WRITER, METHOD_RESET);\n-                methodVisitor.visitLabel(rethrow);\n-                \/\/ stack:[ex] [EW]\n-                methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 2, new Object[] { \"java\/lang\/Throwable\", TYPE_EVENT_WRITER.getInternalName() });\n-                methodVisitor.visitInsn(Opcodes.POP);\n-                \/\/ stack:[ex]\n-                methodVisitor.visitInsn(Opcodes.ATHROW);\n-                methodVisitor.visitLabel(excluded);\n-                \/\/ stack: [EW]\n-                methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 1, new Object[] { TYPE_EVENT_WRITER.getInternalName() });\n-                methodVisitor.visitInsn(Opcodes.POP);\n-                methodVisitor.visitLabel(end);\n-                \/\/ stack:\n-                methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 0, null);\n-                methodVisitor.visitInsn(Opcodes.RETURN);\n-                methodVisitor.visitMaxs(0, 0);\n-                methodVisitor.visitEnd();\n+                blockCodeBuilder.ifeq(blockCodeBuilder.startLabel());\n+                \/\/ stack: []\n+                blockCodeBuilder.goto_(end);\n+            }, catchBuilder -> {\n+                catchBuilder.catchingAll(catchAllHandler -> {\n+                    getEventWriter(catchAllHandler);\n+                    \/\/ stack: [ex] [EW]\n+                    catchAllHandler.dup();\n+                    \/\/ stack: [ex] [EW] [EW]\n+                    Label rethrow = catchAllHandler.newLabel();\n+                    catchAllHandler.if_null(rethrow);\n+                    \/\/ stack: [ex] [EW]\n+                    catchAllHandler.dup();\n+                    \/\/ stack: [ex] [EW] [EW]\n+                    invokevirtual(catchAllHandler, TYPE_EVENT_WRITER, METHOD_RESET);\n+                    catchAllHandler.labelBinding(rethrow);\n+                    \/\/ stack:[ex] [EW]\n+                    catchAllHandler.pop();\n+                    \/\/ stack:[ex]\n+                    catchAllHandler.throwInstruction();\n+                });\n@@ -608,1 +424,7 @@\n-        }\n+            codeBuilder.labelBinding(excluded);\n+            \/\/ stack: [EW]\n+            codeBuilder.pop();\n+            codeBuilder.labelBinding(end);\n+            \/\/ stack: []\n+            codeBuilder.return_();\n+        });\n@@ -611,2 +433,2 @@\n-        updateMethod(METHOD_EVENT_SHOULD_COMMIT, methodVisitor -> {\n-            Label fail = new Label();\n+        updateMethod(METHOD_EVENT_SHOULD_COMMIT, codeBuilder -> {\n+            Label fail = codeBuilder.newLabel();\n@@ -614,2 +436,2 @@\n-                getEventConfiguration(methodVisitor);\n-                methodVisitor.visitJumpInsn(Opcodes.IFNULL, fail);\n+                getEventConfiguration(codeBuilder);\n+                codeBuilder.if_null(fail);\n@@ -618,7 +440,7 @@\n-            getEventConfiguration(methodVisitor);\n-            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n-            methodVisitor.visitFieldInsn(Opcodes.GETFIELD, getInternalClassName(), FIELD_DURATION, \"J\");\n-            invokeVirtual(methodVisitor, TYPE_EVENT_CONFIGURATION, METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT);\n-            methodVisitor.visitJumpInsn(Opcodes.IFEQ, fail);\n-            for (int index = 0; index < settingInfos.size(); index++) {\n-                SettingInfo si = settingInfos.get(index);\n+            getEventConfiguration(codeBuilder);\n+            codeBuilder.aload(0);\n+            getfield(codeBuilder, getEventClassDesc(), FIELD_DURATION);\n+            invokevirtual(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT);\n+            codeBuilder.ifeq(fail);\n+            for (int index = 0; index < settingDescs.size(); index++) {\n+                SettingDesc sd = settingDescs.get(index);\n@@ -626,12 +448,9 @@\n-                methodVisitor.visitIntInsn(Opcodes.ALOAD, 0);\n-                if (untypedEventConfiguration) {\n-                    methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, getInternalClassName(), FIELD_EVENT_CONFIGURATION, TYPE_OBJECT_DESCRIPTOR);\n-                } else {\n-                    methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, getInternalClassName(), FIELD_EVENT_CONFIGURATION, TYPE_EVENT_CONFIGURATION_DESCRIPTOR);\n-                }\n-                methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, TYPE_EVENT_CONFIGURATION.getInternalName());\n-                methodVisitor.visitLdcInsn(index);\n-                invokeVirtual(methodVisitor, TYPE_EVENT_CONFIGURATION, METHOD_EVENT_CONFIGURATION_GET_SETTING);\n-                methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, si.paramType().getInternalName());\n-                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, getInternalClassName(), si.methodName, \"(\" + si.paramType().getDescriptor() + \")Z\", false);\n-                methodVisitor.visitJumpInsn(Opcodes.IFEQ, fail);\n+                codeBuilder.aload(0);\n+                getEventConfiguration(codeBuilder);\n+                codeBuilder.checkcast(TYPE_EVENT_CONFIGURATION);\n+                codeBuilder.ldc(index);\n+                invokevirtual(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_EVENT_CONFIGURATION_GET_SETTING);\n+                MethodTypeDesc mdesc = MethodTypeDesc.ofDescriptor(\"(\" + sd.paramType().descriptorString() + \")Z\");\n+                codeBuilder.checkcast(sd.paramType());\n+                codeBuilder.invokevirtual(getEventClassDesc(), sd.methodName(), mdesc);\n+                codeBuilder.ifeq(fail);\n@@ -640,2 +459,2 @@\n-            methodVisitor.visitInsn(Opcodes.ICONST_1);\n-            methodVisitor.visitInsn(Opcodes.IRETURN);\n+            codeBuilder.iconst_1();\n+            codeBuilder.ireturn();\n@@ -643,3 +462,3 @@\n-            methodVisitor.visitLabel(fail);\n-            methodVisitor.visitInsn(Opcodes.ICONST_0);\n-            methodVisitor.visitInsn(Opcodes.IRETURN);\n+            codeBuilder.labelBinding(fail);\n+            codeBuilder.iconst_0();\n+            codeBuilder.ireturn();\n@@ -651,3 +470,4 @@\n-            };\n-            updateIfStaticMethodExists(METHOD_SHOULD_COMMIT_LONG, methodVisitor -> {\n-                Label fail = new Label();\n+            }\n+\n+            updateIfStaticMethodExists(METHOD_SHOULD_COMMIT_LONG, codeBuilder -> {\n+                Label fail = codeBuilder.newLabel();\n@@ -656,2 +476,2 @@\n-                    getEventConfiguration(methodVisitor);\n-                    methodVisitor.visitJumpInsn(Opcodes.IFNULL, fail);\n+                    getEventConfiguration(codeBuilder);\n+                    codeBuilder.if_null(fail);\n@@ -660,4 +480,4 @@\n-                getEventConfiguration(methodVisitor);\n-                methodVisitor.visitVarInsn(Opcodes.LLOAD, 0);\n-                invokeVirtual(methodVisitor, TYPE_EVENT_CONFIGURATION, METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT);\n-                methodVisitor.visitInsn(Opcodes.IRETURN);\n+                getEventConfiguration(codeBuilder);\n+                codeBuilder.lload(0);\n+                codeBuilder.invokevirtual(TYPE_EVENT_CONFIGURATION, METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT.name(), METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT.descriptor());\n+                codeBuilder.ireturn();\n@@ -665,1 +485,1 @@\n-                methodVisitor.visitLabel(fail);\n+                codeBuilder.labelBinding(fail);\n@@ -667,4 +487,2 @@\n-                methodVisitor.visitInsn(Opcodes.ICONST_0);\n-                methodVisitor.visitInsn(Opcodes.IRETURN);\n-                methodVisitor.visitMaxs(0, 0);\n-                methodVisitor.visitEnd();\n+                codeBuilder.iconst_0();\n+                codeBuilder.ireturn();\n@@ -672,5 +490,3 @@\n-            updateIfStaticMethodExists(METHOD_TIME_STAMP, methodVisitor -> {\n-                invokeStatic(methodVisitor, TYPE_EVENT_CONFIGURATION.getInternalName(), METHOD_TIME_STAMP);\n-                methodVisitor.visitInsn(Opcodes.LRETURN);\n-                methodVisitor.visitMaxs(0, 0);\n-                methodVisitor.visitEnd();\n+            updateIfStaticMethodExists(METHOD_TIME_STAMP, codeBuilder -> {\n+                invokestatic(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_TIME_STAMP);\n+                codeBuilder.lreturn();\n@@ -681,3 +497,176 @@\n-    private void updateEnabledMethod(Method method) {\n-        updateMethod(method, methodVisitor -> {\n-            Label nullLabel = new Label();\n+    void updateStaticCommit(BlockCodeBuilder blockCodeBuilder, Label excluded) {\n+        \/\/ indexes the argument type array, the argument type array does not include\n+        \/\/ 'this'\n+        int argIndex = 0;\n+        \/\/ indexes the proper slot in the local variable table, takes type size into\n+        \/\/ account, therefore sometimes argIndex != slotIndex\n+        int slotIndex = 0;\n+        int fieldIndex = 0;\n+        ClassDesc[] argumentTypes = staticCommitMethod.descriptor().parameterArray();\n+        TypeKind tk = null;\n+        getEventWriter(blockCodeBuilder);\n+        \/\/ stack: [EW],\n+        blockCodeBuilder.dup();\n+        \/\/ stack: [EW], [EW]\n+        \/\/ write begin event\n+        getEventConfiguration(blockCodeBuilder);\n+        \/\/ stack: [EW], [EW], [EventConfiguration]\n+        blockCodeBuilder.constantInstruction(Opcode.LDC2_W, eventTypeId);\n+        \/\/ stack: [EW], [EW], [EventConfiguration] [long]\n+        invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.BEGIN_EVENT.method());\n+        \/\/ stack: [EW], [integer]\n+        blockCodeBuilder.ifeq(excluded);\n+        \/\/ stack: [EW]\n+        \/\/ write startTime\n+        blockCodeBuilder.dup();\n+        \/\/ stack: [EW], [EW]\n+        tk = TypeKind.from(argumentTypes[argIndex++]);\n+        blockCodeBuilder.loadInstruction(tk, slotIndex);\n+        \/\/ stack: [EW], [EW], [long]\n+        slotIndex += tk.slotSize();\n+        invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.PUT_LONG.method());\n+        \/\/ stack: [EW]\n+        fieldIndex++;\n+        \/\/ write duration\n+        blockCodeBuilder.dup();\n+        \/\/ stack: [EW], [EW]\n+        tk = TypeKind.from(argumentTypes[argIndex++]);\n+        blockCodeBuilder.loadInstruction(tk, slotIndex);\n+        \/\/ stack: [EW], [EW], [long]\n+        slotIndex += tk.slotSize();\n+        invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.PUT_LONG.method());\n+        \/\/ stack: [EW]\n+        fieldIndex++;\n+        \/\/ write eventThread\n+        blockCodeBuilder.dup();\n+        \/\/ stack: [EW], [EW]\n+        invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.PUT_EVENT_THREAD.method());\n+        \/\/ stack: [EW]\n+        \/\/ write stackTrace\n+        blockCodeBuilder.dup();\n+        \/\/ stack: [EW], [EW]\n+        invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.PUT_STACK_TRACE.method());\n+        \/\/ stack: [EW]\n+        \/\/ write custom fields\n+        while (fieldIndex < fieldDescs.size()) {\n+            blockCodeBuilder.dup();\n+            \/\/ stack: [EW], [EW]\n+            tk = TypeKind.from(argumentTypes[argIndex++]);\n+            blockCodeBuilder.loadInstruction(tk, slotIndex);\n+            \/\/ stack:[EW], [EW], [field]\n+            slotIndex += tk.slotSize();\n+            FieldDesc field = fieldDescs.get(fieldIndex);\n+            EventWriterMethod eventMethod = EventWriterMethod.lookupMethod(field);\n+            invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, eventMethod.method());\n+            \/\/ stack: [EW]\n+            fieldIndex++;\n+        }\n+        \/\/ stack: [EW]\n+        \/\/ write end event (writer already on stack)\n+        invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.END_EVENT.method());\n+        \/\/ stack: [int]\n+    }\n+\n+    void updateInstanceCommit(BlockCodeBuilder blockCodeBuilder, Label end, Label excluded) {\n+        \/\/ if (!isEnable()) {\n+        \/\/ return;\n+        \/\/ }\n+        blockCodeBuilder.aload(0);\n+        invokevirtual(blockCodeBuilder, getEventClassDesc(), METHOD_IS_ENABLED);\n+        Label l0 = blockCodeBuilder.newLabel();\n+        blockCodeBuilder.ifne(l0);\n+        blockCodeBuilder.return_();\n+        blockCodeBuilder.labelBinding(l0);\n+        \/\/ long startTime = this.startTime\n+        blockCodeBuilder.aload(0);\n+        getfield(blockCodeBuilder, getEventClassDesc(), FIELD_START_TIME);\n+        blockCodeBuilder.lstore(1);\n+        \/\/ if (startTime == 0) {\n+        \/\/   startTime = EventWriter.timestamp();\n+        \/\/ } else {\n+        blockCodeBuilder.lload(1);\n+        blockCodeBuilder.lconst_0();\n+        blockCodeBuilder.lcmp();\n+        Label durationEvent = blockCodeBuilder.newLabel();\n+        blockCodeBuilder.ifne(durationEvent);\n+        invokestatic(blockCodeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_TIME_STAMP);\n+        blockCodeBuilder.lstore(1);\n+        Label commit = blockCodeBuilder.newLabel();\n+        blockCodeBuilder.goto_(commit);\n+        \/\/   if (duration == 0) {\n+        \/\/     duration = EventWriter.timestamp() - startTime;\n+        \/\/   }\n+        \/\/ }\n+        blockCodeBuilder.labelBinding(durationEvent);\n+        blockCodeBuilder.aload(0);\n+        getfield(blockCodeBuilder, getEventClassDesc(), FIELD_DURATION);\n+        blockCodeBuilder.lconst_0();\n+        blockCodeBuilder.lcmp();\n+        blockCodeBuilder.ifne(commit);\n+        blockCodeBuilder.aload(0);\n+        invokestatic(blockCodeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_TIME_STAMP);\n+        blockCodeBuilder.lload(1);\n+        blockCodeBuilder.lsub();\n+        putfield(blockCodeBuilder, getEventClassDesc(), FIELD_DURATION);\n+        blockCodeBuilder.labelBinding(commit);\n+        \/\/ if (shouldCommit()) {\n+        blockCodeBuilder.aload(0);\n+        invokevirtual(blockCodeBuilder, getEventClassDesc(), METHOD_EVENT_SHOULD_COMMIT);\n+        blockCodeBuilder.ifeq(end);\n+        getEventWriter(blockCodeBuilder);\n+        \/\/ stack: [EW]\n+        blockCodeBuilder.dup();\n+        \/\/ stack: [EW] [EW]\n+        getEventConfiguration(blockCodeBuilder);\n+        \/\/ stack: [EW] [EW] [EC]\n+        blockCodeBuilder.constantInstruction(Opcode.LDC2_W, eventTypeId);\n+        invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.BEGIN_EVENT.method());\n+        \/\/ stack: [EW] [int]\n+        blockCodeBuilder.ifeq(excluded);\n+        \/\/ stack: [EW]\n+        int fieldIndex = 0;\n+        blockCodeBuilder.dup();\n+        \/\/ stack: [EW] [EW]\n+        blockCodeBuilder.lload(1);\n+        \/\/ stack: [EW] [EW] [long]\n+        invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.PUT_LONG.method());\n+        \/\/ stack: [EW]\n+        fieldIndex++;\n+        blockCodeBuilder.dup();\n+        \/\/ stack: [EW] [EW]\n+        blockCodeBuilder.aload(0);\n+        \/\/ stack: [EW] [EW] [this]\n+        getfield(blockCodeBuilder, getEventClassDesc(), FIELD_DURATION);\n+        \/\/ stack: [EW] [EW] [long]\n+        invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.PUT_LONG.method());\n+        \/\/ stack: [EW]\n+        fieldIndex++;\n+        blockCodeBuilder.dup();\n+        \/\/ stack: [EW] [EW]\n+        invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.PUT_EVENT_THREAD.method());\n+        \/\/ stack: [EW]\n+        blockCodeBuilder.dup();\n+        \/\/ stack: [EW] [EW]\n+        invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.PUT_STACK_TRACE.method());\n+        \/\/ stack: [EW]\n+        while (fieldIndex < fieldDescs.size()) {\n+            FieldDesc field = fieldDescs.get(fieldIndex);\n+            blockCodeBuilder.dup();\n+            \/\/ stack: [EW] [EW]\n+            blockCodeBuilder.aload(0);\n+            \/\/ stack: [EW] [EW] [this]\n+            getfield(blockCodeBuilder, getEventClassDesc(), field);\n+            \/\/ stack: [EW] [EW] <T>\n+            EventWriterMethod eventMethod = EventWriterMethod.lookupMethod(field);\n+            invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, eventMethod.method());\n+            \/\/ stack: [EW]\n+            fieldIndex++;\n+        }\n+        \/\/ stack:[EW]\n+        invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.END_EVENT.method());\n+        \/\/ stack:[int]\n+    }\n+\n+    private void updateEnabledMethod(MethodDesc method) {\n+        updateMethod(method, codeBuilder -> {\n+            Label nullLabel = codeBuilder.newLabel();\n@@ -685,2 +674,2 @@\n-                getEventConfiguration(methodVisitor);\n-                methodVisitor.visitJumpInsn(Opcodes.IFNULL, nullLabel);\n+                getEventConfiguration(codeBuilder);\n+                codeBuilder.branchInstruction(Opcode.IFNULL, nullLabel);\n@@ -688,3 +677,3 @@\n-            getEventConfiguration(methodVisitor);\n-            invokeVirtual(methodVisitor, TYPE_EVENT_CONFIGURATION, METHOD_IS_ENABLED);\n-            methodVisitor.visitInsn(Opcodes.IRETURN);\n+            getEventConfiguration(codeBuilder);\n+            invokevirtual(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_IS_ENABLED);\n+            codeBuilder.ireturn();\n@@ -692,4 +681,3 @@\n-                methodVisitor.visitLabel(nullLabel);\n-                methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 0, null);\n-                methodVisitor.visitInsn(Opcodes.ICONST_0);\n-                methodVisitor.visitInsn(Opcodes.IRETURN);\n+                codeBuilder.labelBinding(nullLabel);\n+                codeBuilder.iconst_0();\n+                codeBuilder.ireturn();\n@@ -697,2 +685,0 @@\n-            methodVisitor.visitMaxs(0, 0);\n-            methodVisitor.visitEnd();\n@@ -702,1 +688,1 @@\n-    private void updateIfStaticMethodExists(Method method, Consumer<MethodVisitor> code) {\n+    private void updateIfStaticMethodExists(MethodDesc method, Consumer<CodeBuilder> code) {\n@@ -708,4 +694,4 @@\n-    private boolean hasStaticMethod(Method method) {\n-        for (MethodNode m : classNode.methods) {\n-            if (m.name.equals(method.getName()) && m.desc.equals(method.getDescriptor())) {\n-                return Modifier.isStatic(m.access);\n+    private boolean hasStaticMethod(MethodDesc method) {\n+        for (MethodModel m : classModel.methods()) {\n+            if (m.methodName().equalsString(method.name()) && m.methodTypeSymbol().equals(method.descriptor())) {\n+                return Modifier.isStatic(m.flags().flagsMask());\n@@ -717,3 +703,3 @@\n-    private void getEventWriter(MethodVisitor mv) {\n-        mv.visitLdcInsn(EventWriterKey.getKey());\n-        visitMethod(mv, Opcodes.INVOKESTATIC, TYPE_EVENT_WRITER_FACTORY, METHOD_GET_EVENT_WRITER_KEY);\n+    private void getEventWriter(CodeBuilder codeBuilder) {\n+        codeBuilder.ldc(EventWriterKey.getKey());\n+        invokestatic(codeBuilder, TYPE_EVENT_WRITER_FACTORY, METHOD_GET_EVENT_WRITER_KEY);\n@@ -722,17 +708,1 @@\n-    private void visitMethod(final MethodVisitor mv, final int opcode, final Type type, final Method method) {\n-        mv.visitMethodInsn(opcode, type.getInternalName(), method.getName(), method.getDescriptor(), false);\n-    }\n-\n-    private static void invokeStatic(MethodVisitor methodVisitor, String className, Method m) {\n-        methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, className, m.getName(), m.getDescriptor(), false);\n-    }\n-\n-    private static void invokeVirtual(MethodVisitor methodVisitor, String className, Method m) {\n-        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, className, m.getName(), m.getDescriptor(), false);\n-    }\n-\n-    private void invokeVirtual(MethodVisitor methodVisitor, Type type, Method method) {\n-        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, type.getInternalName(), method.getName(), method.getDescriptor(), false);\n-    }\n-\n-    private void getEventConfiguration(MethodVisitor methodVisitor) {\n+    private void getEventConfiguration(CodeBuilder codeBuilder) {\n@@ -740,1 +710,1 @@\n-            methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, getInternalClassName(), FIELD_EVENT_CONFIGURATION, TYPE_OBJECT_DESCRIPTOR);\n+            codeBuilder.getstatic(getEventClassDesc(), FIELD_EVENT_CONFIGURATION.name(), TYPE_OBJECT);\n@@ -742,1 +712,1 @@\n-            methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, getInternalClassName(), FIELD_EVENT_CONFIGURATION, TYPE_EVENT_CONFIGURATION_DESCRIPTOR);\n+            codeBuilder.getstatic(getEventClassDesc(), FIELD_EVENT_CONFIGURATION.name(), TYPE_EVENT_CONFIGURATION);\n@@ -757,3 +727,3 @@\n-    private final void updateExistingWithEmptyVoidMethod(Method voidMethod) {\n-        updateMethod(voidMethod, methodVisitor -> {\n-            methodVisitor.visitInsn(Opcodes.RETURN);\n+    private final void updateExistingWithEmptyVoidMethod(MethodDesc voidMethod) {\n+        updateMethod(voidMethod, codeBuilder -> {\n+            codeBuilder.return_();\n@@ -763,4 +733,4 @@\n-    private final void updateExistingWithReturnFalse(Method voidMethod) {\n-        updateMethod(voidMethod, methodVisitor -> {\n-            methodVisitor.visitInsn(Opcodes.ICONST_0);\n-            methodVisitor.visitInsn(Opcodes.IRETURN);\n+    private final void updateExistingWithReturnFalse(MethodDesc voidMethod) {\n+        updateMethod(voidMethod, codeBuilder -> {\n+            codeBuilder.iconst_0();\n+            codeBuilder.ireturn();\n@@ -770,7 +740,3 @@\n-    private MethodNode getMethodNode(Method method) {\n-        for (MethodNode m : classNode.methods) {\n-            if (m.name.equals(method.getName()) && m.desc.equals(method.getDescriptor())) {\n-                return m;\n-            }\n-        }\n-        return null;\n+    private Consumer<CodeBuilder> findMethodUpdate(MethodModel mm) {\n+        MethodDesc m = MethodDesc.of(mm.methodName().stringValue(), mm.methodType().stringValue());\n+        return methodUpdates.get(m);\n@@ -779,11 +745,2 @@\n-    private final void updateMethod(Method method, Consumer<MethodVisitor> code) {\n-        MethodNode old = getMethodNode(method);\n-        int index = classNode.methods.indexOf(old);\n-        classNode.methods.remove(old);\n-        MethodVisitor mv = classNode.visitMethod(old.access, old.name, old.desc, null, null);\n-        mv.visitCode();\n-        code.accept(mv);\n-        mv.visitMaxs(0, 0);\n-        MethodNode newMethod = getMethodNode(method);\n-        classNode.methods.remove(newMethod);\n-        classNode.methods.add(index, newMethod);\n+    private void updateMethod(MethodDesc method, Consumer<CodeBuilder> codeBuilder) {\n+        methodUpdates.put(method, codeBuilder);\n@@ -792,2 +749,2 @@\n-    private String getInternalClassName() {\n-        return classNode.name;\n+    private ClassDesc getEventClassDesc() {\n+        return classModel.thisClass().asSymbol();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventInstrumentation.java","additions":480,"deletions":523,"binary":false,"changes":1003,"status":"modified"},{"patch":"@@ -28,3 +28,3 @@\n-import jdk.internal.org.objectweb.asm.commons.Method;\n-import jdk.jfr.internal.EventInstrumentation.FieldInfo;\n-import jdk.jfr.internal.event.EventConfiguration;\n+import jdk.jfr.internal.util.Bytecode.FieldDesc;\n+import jdk.jfr.internal.util.Bytecode.MethodDesc;\n+import jdk.jfr.internal.util.Utils;\n@@ -34,15 +34,15 @@\n-    BEGIN_EVENT(\"(\" + jdk.internal.org.objectweb.asm.Type.getType(EventConfiguration.class).getDescriptor() + \"J)Z\", \"???\", \"beginEvent\"),\n-    END_EVENT(\"()Z\", \"???\", \"endEvent\"),\n-    PUT_BYTE(\"(B)V\", \"byte\", \"putByte\"),\n-    PUT_SHORT(\"(S)V\", \"short\", \"putShort\"),\n-    PUT_INT(\"(I)V\", \"int\", \"putInt\"),\n-    PUT_LONG(\"(J)V\", \"long\", \"putLong\"),\n-    PUT_FLOAT(\"(F)V\", \"float\", \"putFloat\"),\n-    PUT_DOUBLE(\"(D)V\", \"double\", \"putDouble\"),\n-    PUT_CHAR(\"(C)V\", \"char\", \"putChar\"),\n-    PUT_BOOLEAN(\"(Z)V\", \"boolean\", \"putBoolean\"),\n-    PUT_THREAD(\"(Ljava\/lang\/Thread;)V\", Type.THREAD.getName(), \"putThread\"),\n-    PUT_CLASS(\"(Ljava\/lang\/Class;)V\", Type.CLASS.getName(), \"putClass\"),\n-    PUT_STRING(\"(Ljava\/lang\/String;)V\", Type.STRING.getName(), \"putString\"),\n-    PUT_EVENT_THREAD(\"()V\", Type.THREAD.getName(), \"putEventThread\"),\n-    PUT_STACK_TRACE(\"()V\", Type.TYPES_PREFIX + \"StackTrace\", \"putStackTrace\");\n+     BEGIN_EVENT(\"beginEvent\", \"(Ljdk\/jfr\/internal\/event\/EventConfiguration;J)Z\", \"???\"),\n+     END_EVENT(\"endEvent\", \"()Z\", \"???\"),\n+     PUT_BYTE(\"putByte\", \"(B)V\", \"B\"),\n+     PUT_SHORT(\"putShort\", \"(S)V\", \"S\"),\n+     PUT_INT(\"putInt\", \"(I)V\", \"I\"),\n+     PUT_LONG(\"putLong\", \"(J)V\", \"J\"),\n+     PUT_FLOAT(\"putFloat\", \"(F)V\", \"F\"),\n+     PUT_DOUBLE(\"putDouble\", \"(D)V\", \"D\"),\n+     PUT_CHAR(\"putChar\", \"(C)V\", \"C\"),\n+     PUT_BOOLEAN(\"putBoolean\", \"(Z)V\", \"Z\"),\n+     PUT_THREAD(\"putThread\", \"(Ljava\/lang\/Thread;)V\", \"Ljava\/lang\/Thread;\"),\n+     PUT_CLASS(\"putClass\", \"(Ljava\/lang\/Class;)V\", \"Ljava\/lang\/Class;\"),\n+     PUT_STRING(\"putString\", \"(Ljava\/lang\/String;)V\", \"Ljava\/lang\/String;\"),\n+     PUT_EVENT_THREAD(\"putEventThread\", \"()V\", \"???\"),\n+     PUT_STACK_TRACE(\"putStackTrace\", \"()V\", \"???\");\n@@ -50,2 +50,2 @@\n-    final Method asmMethod;\n-    final String typeDescriptor;\n+    final MethodDesc method;\n+    final String fieldType;\n@@ -53,3 +53,3 @@\n-    EventWriterMethod(String paramSignature, String typeName, String methodName) {\n-        this.typeDescriptor = ASMToolkit.getDescriptor(typeName);\n-        this.asmMethod = new Method(methodName, paramSignature);\n+    EventWriterMethod(String methodName, String paramType, String fieldType) {\n+        this.fieldType = fieldType;\n+        this.method = MethodDesc.of(methodName, paramType);\n@@ -58,2 +58,2 @@\n-    public Method asASM() {\n-        return asmMethod;\n+    public MethodDesc method() {\n+        return method;\n@@ -70,1 +70,1 @@\n-    public static EventWriterMethod lookupMethod(FieldInfo field) {\n+    public static EventWriterMethod lookupMethod(FieldDesc field) {\n@@ -72,1 +72,1 @@\n-        if (field.name().equals(EventInstrumentation.FIELD_EVENT_THREAD)) {\n+        if (field.name().equals(Utils.FIELD_EVENT_THREAD)) {\n@@ -76,1 +76,1 @@\n-            if (field.descriptor().equals(m.typeDescriptor)) {\n+            if (field.type().descriptorString().equals(m.fieldType)) {\n@@ -80,1 +80,1 @@\n-        throw new Error(\"Unknown type \" + field.descriptor());\n+        throw new Error(\"Unknown field type \" + field.type());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventWriterMethod.java","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import jdk.jfr.internal.util.Utils;\n+import jdk.jfr.internal.util.Bytecode;\n@@ -78,1 +78,1 @@\n-                ASMToolkit.logASM(clazz.getName(), bytes);\n+                Bytecode.log(clazz.getName(), bytes);\n@@ -129,1 +129,1 @@\n-            ASMToolkit.logASM(ei.getClassName() + \"(\" + traceId + \")\", bytes);\n+            Bytecode.log(ei.getClassName() + \"(\" + traceId + \")\", bytes);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVMUpcalls.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -79,2 +79,2 @@\n-        return PrivateAccess.getInstance().newValueDescriptor(EventInstrumentation.FIELD_START_TIME, Type.LONG, annos, 0, false,\n-                EventInstrumentation.FIELD_START_TIME);\n+        return PrivateAccess.getInstance().newValueDescriptor(Utils.FIELD_START_TIME, Type.LONG, annos, 0, false,\n+                Utils.FIELD_START_TIME);\n@@ -85,2 +85,2 @@\n-        return PrivateAccess.getInstance().newValueDescriptor(EventInstrumentation.FIELD_STACK_TRACE, Type.STACK_TRACE, annos, 0, true,\n-                EventInstrumentation.FIELD_STACK_TRACE);\n+        return PrivateAccess.getInstance().newValueDescriptor(Utils.FIELD_STACK_TRACE, Type.STACK_TRACE, annos, 0, true,\n+                Utils.FIELD_STACK_TRACE);\n@@ -91,2 +91,2 @@\n-        return PrivateAccess.getInstance().newValueDescriptor(EventInstrumentation.FIELD_EVENT_THREAD, Type.THREAD, annos, 0, true,\n-                EventInstrumentation.FIELD_EVENT_THREAD);\n+        return PrivateAccess.getInstance().newValueDescriptor(Utils.FIELD_EVENT_THREAD, Type.THREAD, annos, 0, true,\n+                Utils.FIELD_EVENT_THREAD);\n@@ -98,1 +98,1 @@\n-        return PrivateAccess.getInstance().newValueDescriptor(EventInstrumentation.FIELD_DURATION, Type.LONG, annos, 0, false, EventInstrumentation.FIELD_DURATION);\n+        return PrivateAccess.getInstance().newValueDescriptor(Utils.FIELD_DURATION, Type.LONG, annos, 0, false, Utils.FIELD_DURATION);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/TypeLibrary.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import static jdk.jfr.internal.EventInstrumentation.FIELD_DURATION;\n+import static jdk.jfr.internal.util.Utils.FIELD_DURATION;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventParser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.util;\n+\n+import jdk.jfr.ValueDescriptor;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.Objects;\n+import jdk.jfr.internal.Logger;\n+import jdk.jfr.internal.LogLevel;\n+import jdk.jfr.internal.LogTag;\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.components.ClassPrinter;\n+\n+\/**\n+ * Helper class when working with bytecode.\n+ *\/\n+public final class Bytecode {\n+\n+    private final static ClassDesc CD_Thread = classDesc(Thread.class);\n+\n+    public record ClassMethodDesc(ClassDesc type, MethodDesc method) {\n+        public static ClassMethodDesc of(Class<?> clazz, String method, String desrciptor) {\n+            return new ClassMethodDesc(classDesc(clazz), MethodDesc.of(method, desrciptor));\n+        }\n+    }\n+\n+    public record FieldDesc(ClassDesc type, String name) {\n+        public static FieldDesc of(ClassDesc type, String name) {\n+            return new FieldDesc(type, name);\n+        }\n+\n+        public static FieldDesc of(String name, Class<?> type) {\n+            return of(classDesc(type), name);\n+        }\n+    }\n+\n+    public record MethodDesc(String name, MethodTypeDesc descriptor) {\n+        public static MethodDesc of(String methodName, String descriptor) {\n+            return new MethodDesc(methodName, MethodTypeDesc.ofDescriptor(descriptor));\n+        }\n+\n+        public static MethodDesc of(String methodName, Class<?> returnType, Class<?>... parameters) {\n+            ClassDesc[] parameterDesc = new ClassDesc[parameters.length];\n+            for (int i = 0; i < parameterDesc.length; i++) {\n+                parameterDesc[i] = classDesc(parameters[i]);\n+            }\n+            ClassDesc returnDesc = classDesc(returnType);\n+            MethodTypeDesc mtd = MethodTypeDesc.of(returnDesc, parameterDesc);\n+            return new MethodDesc(methodName, mtd);\n+        }\n+    }\n+\n+    public static ClassDesc classDesc(ValueDescriptor v) {\n+        String typeName = v.getTypeName();\n+        return switch (typeName) {\n+            case \"boolean\" -> ConstantDescs.CD_boolean;\n+            case \"byte\" -> ConstantDescs.CD_byte;\n+            case \"short\" -> ConstantDescs.CD_short;\n+            case \"char\" -> ConstantDescs.CD_char;\n+            case \"int\" -> ConstantDescs.CD_int;\n+            case \"long\" -> ConstantDescs.CD_long;\n+            case \"double\" -> ConstantDescs.CD_double;\n+            case \"float\" -> ConstantDescs.CD_float;\n+            case \"java.lang.String\" -> ConstantDescs.CD_String;\n+            case \"java.lang.Class\" -> ConstantDescs.CD_Class;\n+            case \"java.lang.Thread\" -> CD_Thread;\n+            default -> throw new InternalError(\"Unsupported JFR type \" + v.getTypeName());\n+        };\n+    }\n+\n+    public static ClassDesc classDesc(Class<?> clazz) {\n+        return ClassDesc.ofDescriptor(clazz.descriptorString());\n+    }\n+\n+    public static void getfield(CodeBuilder codeBuilder, ClassDesc owner, FieldDesc field) {\n+        codeBuilder.getfield(owner, field.name(), field.type());\n+    }\n+\n+    public static void putfield(CodeBuilder codeBuilder, ClassDesc owner, FieldDesc field) {\n+        codeBuilder.putfield(owner, field.name(), field.type());\n+    }\n+\n+    public static void invokestatic(CodeBuilder codeBuilder, ClassDesc owner, MethodDesc method) {\n+        codeBuilder.invokestatic(owner, method.name(), method.descriptor());\n+    }\n+\n+    public static void invokespecial(CodeBuilder codeBuilder, ClassDesc owner, MethodDesc method) {\n+        codeBuilder.invokespecial(owner, method.name(), method.descriptor());\n+    }\n+\n+    public static void invokevirtual(CodeBuilder codeBuilder, ClassDesc owner, MethodDesc method) {\n+        codeBuilder.invokevirtual(owner, method.name(), method.descriptor());\n+    }\n+\n+    public static void invokevirtual(CodeBuilder codeBuilder, ClassMethodDesc cmd) {\n+        invokevirtual(codeBuilder, cmd.type(), cmd.method());\n+    }\n+\n+    public static void unbox(CodeBuilder codeBuilder, ClassDesc type) {\n+        if (!type.isPrimitive()) {\n+            codeBuilder.checkcast(type);\n+            return;\n+        }\n+        ClassMethodDesc unboxer = switch (type.descriptorString()) {\n+            case \"B\" -> ClassMethodDesc.of(Byte.class, \"byteValue\", \"()B\");\n+            case \"S\" -> ClassMethodDesc.of(Short.class, \"shortValue\", \"()S\");\n+            case \"C\" -> ClassMethodDesc.of(Character.class, \"charValue\", \"()C\");\n+            case \"I\" -> ClassMethodDesc.of(Integer.class, \"intValue\", \"()I\");\n+            case \"J\" -> ClassMethodDesc.of(Long.class, \"longValue\", \"()J\");\n+            case \"F\" -> ClassMethodDesc.of(Float.class, \"floatValue\", \"()F\");\n+            case \"D\" -> ClassMethodDesc.of(Double.class, \"doubleValue\", \"()D\");\n+            case \"Z\" -> ClassMethodDesc.of(Boolean.class, \"booleanValue\", \"()Z\");\n+            default -> throw new InternalError(\"Unsupported JFR type \" + type.descriptorString());\n+        };\n+        codeBuilder.checkcast(unboxer.type());\n+        invokevirtual(codeBuilder, unboxer);\n+    }\n+\n+    public static void throwException(CodeBuilder cb, ClassDesc type, String message) {\n+        Objects.requireNonNull(message);\n+        cb.new_(type);\n+        cb.dup();\n+        cb.ldc(message);\n+        MethodDesc md = MethodDesc.of(\"<init>\", void.class, String.class);\n+        invokespecial(cb, type, md);\n+        cb.athrow();\n+    }\n+\n+    public static void log(String className, byte[] bytes) {\n+        Logger.log(LogTag.JFR_SYSTEM_BYTECODE, LogLevel.INFO, \"Generated bytecode for class \" + className);\n+        if (Logger.shouldLog(LogTag.JFR_SYSTEM_BYTECODE, LogLevel.TRACE)) {\n+            StringBuilder out = new StringBuilder();\n+            out.append(\"Bytecode:\");\n+            out.append(System.lineSeparator());\n+            ClassModel classModel = Classfile.of().parse(bytes);\n+            ClassPrinter.toYaml(classModel, ClassPrinter.Verbosity.TRACE_ALL, out::append);\n+            Logger.log(LogTag.JFR_SYSTEM_BYTECODE, LogLevel.TRACE, out.toString());\n+        }\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/Bytecode.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -59,0 +59,5 @@\n+    public static final String FIELD_DURATION = \"duration\";\n+    public static final String FIELD_STACK_TRACE = \"stackTrace\";\n+    public static final String FIELD_START_TIME = \"startTime\";\n+    public static final String FIELD_EVENT_THREAD = \"eventThread\";\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/Utils.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-        output.shouldContain(\"extends jdk\/jfr\/events\/AbstractJDKEvent\");\n+        output.shouldContain(\"superclass: jdk\/jfr\/events\/AbstractJDKEvent\");\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestEventWriterLog.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}