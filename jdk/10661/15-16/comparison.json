{"files":[{"patch":"@@ -999,1 +999,1 @@\n-  if (result  != nullptr && StubRoutines::FTZ_mode_enabled()) {\n+  if (result  != nullptr && ! IEEE_subnormal_handling_OK()) {\n@@ -1004,1 +1004,1 @@\n-    assert(! StubRoutines::FTZ_mode_enabled(), \"fsetenv didn't work\");\n+    assert(IEEE_subnormal_handling_OK(), \"fsetenv didn't work\");\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1859,1 +1859,1 @@\n-    if (StubRoutines::FTZ_mode_enabled()) {\n+    if (! IEEE_subnormal_handling_OK()) {\n@@ -1864,1 +1864,1 @@\n-      assert(! StubRoutines::FTZ_mode_enabled(), \"fsetenv didn't work\");\n+      assert(IEEE_subnormal_handling_OK(), \"fsetenv didn't work\");\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -186,5 +186,0 @@\n-const double StubRoutines::_large_subnormal\n-    = jdouble_cast(0x0030000000000000); \/\/ 0x1.0p-1020;\n-const volatile double StubRoutines::_small_subnormal\n-    = jdouble_cast(0x0000000000000003); \/\/ 0x0.0000000000003p-1022;\n-\n@@ -320,23 +315,0 @@\n-\/\/ Check for Flush-To-Zero mode\n-\n-\/\/ On some processors faster execution can be achieved by returning\n-\/\/ zero for extremely small results, rather than an IEEE-754 subnormal\n-\/\/ number. This mode is not compatible with the Java Language\n-\/\/ Standard.\n-bool StubRoutines::FTZ_mode_enabled() {\n-  \/\/ Quickly test to make sure subnormals are correctly handled.\n-\n-  \/\/ _small_subnormal is the smallest subnormal number that has two\n-  \/\/ bits set. _large_subnormal is a number such that, when\n-  \/\/ _small_subnormal is added to it, must be rounded according to the\n-  \/\/ mode. These two tests detect the rounding mode in use. If\n-  \/\/ subnormals are turned off (i.e. subnormals-are-zero) FTZ mode is\n-  \/\/ in use.\n-\n-  \/\/ We need the addition of _large_subnormal and _small_subnormal to\n-  \/\/ be performed at runtime. Making _small_subnormal volatile ensures\n-  \/\/ that the following expression isn't evaluated at compile time:\n-  return (_large_subnormal + _small_subnormal == _large_subnormal\n-      || -_large_subnormal - _small_subnormal == -_large_subnormal);\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":0,"deletions":28,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -497,2 +497,0 @@\n-\n-  static bool FTZ_mode_enabled();\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -412,0 +412,29 @@\n+\n+\/\/ Check for Flush-To-Zero mode\n+\n+\/\/ On some processors faster execution can be achieved by setting a\n+\/\/ mode to return zero for extremely small results, rather than an\n+\/\/ IEEE-754 subnormal number. This mode is not compatible with the\n+\/\/ Java Language Standard.\n+\n+\/\/ We need the addition of _large_subnormal and _small_subnormal to be\n+\/\/ performed at runtime. _small_subnormal is volatile so that\n+\/\/ expressions involving it cannot be evaluated at compile time.\n+static const double large_subnormal_double\n+  = jdouble_cast(0x0030000000000000); \/\/ 0x1.0p-1020;\n+static const volatile double small_subnormal_double\n+  = jdouble_cast(0x0000000000000003); \/\/ 0x0.0000000000003p-1022;\n+\n+\/\/ Quickly test to make sure IEEE-754 subnormal numbers are correctly\n+\/\/ handled.\n+bool IEEE_subnormal_handling_OK() {\n+  \/\/ _small_subnormal is the smallest subnormal number that has two\n+  \/\/ bits set. _large_subnormal is a number such that, when\n+  \/\/ _small_subnormal is added to it, must be rounded according to the\n+  \/\/ mode. These two tests detect the rounding mode in use. If\n+  \/\/ subnormals are turned off (i.e. subnormals-are-zero) flush-to-\n+  \/\/ zero mode is in use.\n+\n+  return (large_subnormal_double + small_subnormal_double > large_subnormal_double\n+          && -large_subnormal_double - small_subnormal_double < -large_subnormal_double);\n+}\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1338,0 +1338,4 @@\n+\/\/ Quickly test to make sure IEEE-754 subnormal numbers are correctly\n+\/\/ handled.\n+bool IEEE_subnormal_handling_OK();\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}