{"files":[{"patch":"@@ -5170,2 +5170,2 @@\n-      movsd(xmm9, ExternalAddress(StubRoutines::x86::addr_unity()), rsi);\n-      movsd(xmm8, ExternalAddress(StubRoutines::x86::addr_thresh()), rsi);\n+      movsd(xmm9, ExternalAddress(StubRoutines::large_denormal_addr()), rsi);\n+      movsd(xmm8, ExternalAddress(StubRoutines::small_denormal_addr()), rsi);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3902,4 +3902,0 @@\n-  StubRoutines::x86::_unity\n-    = jdouble_cast(0x0030000000000000); \/\/ 0x1.0p-1020;\n-  StubRoutines::x86::_thresh\n-    = jdouble_cast(0x0000000000000003); \/\/ 0x0.0000000000003p-1022;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -131,2 +131,0 @@\n-  static double  _unity;\n-  static double  _thresh;\n@@ -217,2 +215,0 @@\n-  static address addr_unity()            { return (address)&_unity; }\n-  static address addr_thresh()           { return (address)&_thresh; }\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-double  StubRoutines::x86::_unity;\n-double  StubRoutines::x86::_thresh;\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86_64.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -977,1 +977,1 @@\n-#if defined(__GNUC__)\n+#ifndef IA32\n@@ -987,0 +987,4 @@\n+  \/\/ This workaround is ineffective on IA32 systems because the MXCSR\n+  \/\/ register (which controls flush-to-zero mode) is not stored in the\n+  \/\/ legacy fenv.\n+\n@@ -990,1 +994,1 @@\n-#endif \/\/ defined(__GNUC__)\n+#endif \/\/ IA32\n@@ -994,15 +998,7 @@\n-#if defined(__GNUC__)\n-  if (result  != nullptr) {\n-    \/\/ Quickly test to make sure denormals are correctly handled.\n-    static const double unity\n-      = jdouble_cast(0x0030000000000000); \/\/ 0x1.0p-1020;\n-    static const volatile double thresh\n-      = jdouble_cast(0x0000000000000003); \/\/ 0x0.0000000000003p-1022;\n-    if (unity + thresh == unity || -unity - thresh == -unity) {\n-      \/\/ We just dlopen()ed a library that mangled the floating-point\n-      \/\/ flags. Silently fix things now.\n-      int rtn = fesetenv(&default_fenv);\n-      assert(rtn == 0, \"fesetenv must succeed\");\n-      assert(unity + thresh != unity && -unity - thresh != -unity,\n-             \"fsetenv didn't work\");\n-    }\n+#ifndef IA32\n+  if (result  != nullptr && StubRoutines::FTZ_mode_enabled()) {\n+    \/\/ We just dlopen()ed a library that mangled the floating-point\n+    \/\/ flags. Silently fix things now.\n+    int rtn = fesetenv(&default_fenv);\n+    assert(rtn == 0, \"fesetenv must succeed\");\n+    assert(! StubRoutines::FTZ_mode_enabled, \"fsetenv didn't work\");\n@@ -1010,1 +1006,1 @@\n-#endif \/\/ defined(__GNUC__)\n+#endif \/\/ IA32\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":14,"deletions":18,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1801,0 +1801,1 @@\n+#ifndef IA32\n@@ -1809,0 +1810,5 @@\n+\n+  \/\/ This workaround is ineffective on IA32 systems because the MXCSR\n+  \/\/ register (which controls flush-to-zero mode) is not stored in the\n+  \/\/ legacy fenv.\n+\n@@ -1812,0 +1818,1 @@\n+#endif \/\/ IA32\n@@ -1844,0 +1851,2 @@\n+\n+#ifndef IA32\n@@ -1845,5 +1854,1 @@\n-    static const double unity\n-      = jdouble_cast(0x0030000000000000); \/\/ 0x1.0p-1020;\n-    static const volatile double thresh\n-      = jdouble_cast(0x0000000000000003); \/\/ 0x0.0000000000003p-1022;\n-    if (unity + thresh == unity || -unity - thresh == -unity) {\n+    if (StubRoutines::FTZ_mode_enabled()) {\n@@ -1854,2 +1859,1 @@\n-      assert(unity + thresh != unity && -unity - thresh != -unity,\n-             \"fsetenv didn't work\");\n+      assert(! StubRoutines::FTZ_mode_enabled(), \"fsetenv didn't work\");\n@@ -1857,0 +1861,2 @@\n+#endif \/\/ IA32\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -183,0 +183,5 @@\n+const double StubRoutines::_large_denormal\n+    = jdouble_cast(0x0030000000000000); \/\/ 0x1.0p-1020;\n+const volatile double StubRoutines::_small_denormal\n+    = jdouble_cast(0x0000000000000003); \/\/ 0x0.0000000000003p-1022;\n+\n@@ -310,0 +315,22 @@\n+\/\/ Check for Flush-To-Zero mode\n+\n+\/\/ On some processors faster execution can be achieved by returning\n+\/\/ zero for extremely small results, rather than an IEEE-754 denormal\n+\/\/ number. This mode is not compatible with the Java Language\n+\/\/ Standard.\n+bool StubRoutines::FTZ_mode_enabled() {\n+  \/\/ Quickly test to make sure denormals are correctly handled.\n+\n+  \/\/ We need the addition of _large_denormal and _small_denormal to be\n+  \/\/ performed at runtime. Making _small_denormal volatile ensures\n+  \/\/ that the following expression isn't evaluated at compile time:\n+\n+  \/\/ _small_denormal is the smallest denormal number that has two bits\n+  \/\/ set. _large_denormal is a number such that, when _small_denormal\n+  \/\/ is added it it, must be rounded according to the mode. These two\n+  \/\/ tests detect the rounding mode in use. If denormals are turned\n+  \/\/ off (i.e. denormals-are-zero) FTZ mode is in use.\n+  return (_large_denormal + _small_denormal == _large_denormal\n+      || -_large_denormal - _small_denormal == -_large_denormal);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -261,0 +261,3 @@\n+  static const double _large_denormal;\n+  static const volatile double _small_denormal;\n+\n@@ -483,0 +486,8 @@\n+\n+  static address small_denormal_addr() {\n+    return (address)&_small_denormal;\n+  }\n+  static address large_denormal_addr() {\n+    return (address)&_large_denormal;\n+  }\n+  static bool FTZ_mode_enabled();\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/floatingpoint\/TestDenormalDouble.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/floatingpoint\/TestDenormalFloat.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n@@ -24,2 +24,0 @@\n-#include <assert.h>\n-#include <fenv.h>\n@@ -37,0 +35,3 @@\n+\n+\/\/ On systems on which GCC bug 55522 has been fixed, this constructor\n+\/\/ serves to reproduce that bug for the purposes of testing HotSpot.\n@@ -39,1 +40,2 @@\n-#if defined(__x86_64__) && defined(SSE)\n+#if defined(__x86_64__)\n+\n@@ -47,0 +49,1 @@\n+\n@@ -49,1 +52,2 @@\n-  {  __asm__ __volatile__ (\"msr fpcr, %0\" : : \"r\" (fpcr)); }\n+  __asm__ __volatile__ (\"msr fpcr, %0\" : : \"r\" (fpcr));\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/floatingpoint\/libfast-math.c","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"}]}