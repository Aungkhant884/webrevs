{"files":[{"patch":"@@ -1656,0 +1656,32 @@\n+\/\/ According to Java SE specification, for floating-point signum operations, if\n+\/\/ on input we have NaN or +\/-0.0 value we should return it,\n+\/\/ otherwise return +\/- 1.0 using sign of input.\n+\/\/ one - gives us a floating-point 1.0 (got from matching rule)\n+\/\/ bool is_double - specifies single or double precision operations will be used.\n+void C2_MacroAssembler::signum_fp(FloatRegister dst, FloatRegister src, FloatRegister one, bool is_double) {\n+  Register tmp1 = t0;\n+\n+  Label done;\n+\n+  is_double ? fclass_d(tmp1, src)\n+            : fclass_s(tmp1, src);\n+\n+  is_double ? fmv_d(dst, src)\n+            : fmv_s(dst, src);\n+\n+  \/\/bitmask 0b1100011000 specifies this bits:\n+  \/\/ 3 - src is -0\n+  \/\/ 4 - src is +0\n+  \/\/ 8 - src is signaling NaN\n+  \/\/ 9 - src is a quiet NaN\n+  andi(tmp1, tmp1, 0b1100011000);\n+\n+  bnez(tmp1, done);\n+\n+  \/\/ use floating-point 1.0 with a sign of input\n+  is_double ? fsgnj_d(dst, one, src)\n+            : fsgnj_s(dst, one, src);\n+\n+  bind(done);\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -160,0 +160,3 @@\n+  void signum_fp(FloatRegister dst, FloatRegister src, FloatRegister one,\n+                 bool is_double);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -7509,0 +7509,46 @@\n+\/\/ Copysign and signum intrinsics\n+\n+instruct copySignD_reg(fRegD dst, fRegD src1, fRegD src2, immD zero) %{\n+  match(Set dst (CopySignD src1 (Binary src2 zero)));\n+  format %{ \"CopySignD  $dst $src1 $src2\" %}\n+  ins_encode %{\n+    FloatRegister dst = as_FloatRegister($dst$$reg),\n+                  src1 = as_FloatRegister($src1$$reg),\n+                  src2 = as_FloatRegister($src2$$reg);\n+    __ fsgnj_d(dst, src1, src2);\n+  %}\n+  ins_pipe(fp_dop_reg_reg_d);\n+%}\n+\n+instruct copySignF_reg(fRegF dst, fRegF src1, fRegF src2) %{\n+  match(Set dst (CopySignF src1 src2));\n+  format %{ \"CopySignF  $dst $src1 $src2\" %}\n+  ins_encode %{\n+    FloatRegister dst = as_FloatRegister($dst$$reg),\n+                  src1 = as_FloatRegister($src1$$reg),\n+                  src2 = as_FloatRegister($src2$$reg);\n+    __ fsgnj_s(dst, src1, src2);\n+  %}\n+  ins_pipe(fp_dop_reg_reg_s);\n+%}\n+\n+instruct signumD_reg(fRegD dst, fRegD src, immD zero, fRegD one) %{\n+  match(Set dst (SignumD src (Binary zero one)));\n+  format %{ \"signumD  $dst, $src\" %}\n+  ins_encode %{\n+    __ signum_fp(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+                 as_FloatRegister($one$$reg), true \/* is_double *\/);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct signumF_reg(fRegF dst, fRegF src, immF zero, fRegF one) %{\n+  match(Set dst (SignumF src (Binary zero one)));\n+  format %{ \"signumF  $dst, $src\" %}\n+  ins_encode %{\n+    __ signum_fp(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+                 as_FloatRegister($one$$reg), false \/* is_double *\/);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -194,0 +194,8 @@\n+  if (FLAG_IS_DEFAULT(UseCopySignIntrinsic)) {\n+      FLAG_SET_DEFAULT(UseCopySignIntrinsic, true);\n+  }\n+\n+  if (FLAG_IS_DEFAULT(UseSignumIntrinsic)) {\n+      FLAG_SET_DEFAULT(UseSignumIntrinsic, true);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -474,1 +474,1 @@\n-    public double  sigNumDouble() {\n+    public double  signumDouble() {\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/MathBench.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}