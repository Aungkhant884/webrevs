{"files":[{"patch":"@@ -4028,3 +4028,4 @@\n-\/\/ The \"Branchless code for lookup table\" algorithm uses the \"Single pshufb\n-\/\/ method\" described in the paper.\n-\/\/\n+\/\/ For the lookup part of the algorithm, different logic is used than\n+\/\/ described in the paper because of the availability of vperm, which can\n+\/\/ do a 64-byte table lookup in four instructions, while preserving the\n+\/\/ branchless nature.\n@@ -4115,51 +4116,25 @@\n-\/\/ This is the goal:\n-\/\/ +=============+=======+=======================+=======================+\n-\/\/ | 6-bit value | index |  offset (isURL == 0)  |  offset (isURL == 1)  |\n-\/\/ +=============+=======+=======================+=======================+\n-\/\/ |    0..25    |  13   | ord('A') + value - 0  |         same          |\n-\/\/ +-------------+-------+-----------------------+-----------------------+\n-\/\/ |   26..51    |   0   | ord('a') + value - 26 |         same          |\n-\/\/ +-------------+-------+-----------------------+-----------------------+\n-\/\/ |   52..61    | 1..10 | ord('0') + value - 52 |         same          |\n-\/\/ +-------------+-------+-----------------------+-----------------------+\n-\/\/ |     62      |  11   | ord('+') + value - 62 | ord('-') + value - 62 |\n-\/\/ +-------------+-------+-----------------------+-----------------------+\n-\/\/ |     63      |  12   | ord('\/') + value - 63 | ord('_') + value - 63 |\n-\/\/ +=============+=======+=======================+=======================+\n-\/\/\n-\/\/ Do a saturated subtract of 51's from expanded to produce an\n-\/\/ index into the offset table.  Any value less than 52 gets an\n-\/\/ index of zero for now.\n-\/\/ __ vsububs(indexes, expanded, vec_51s);\n-\/\/\n-\/\/ Distinguish between A-Z and a-z\n-\/\/ For those values that are between 0 and 25, set their index to 13\n-\/\/ __ vcmpgtub(is_A_to_Z, vec_26s, expanded);\n-\/\/\n-\/\/ All bytes in input that are between 0 and 25 have their\n-\/\/ corresponding byte in is_A_to_Z set to 0xff, while others are\n-\/\/ set to zero.  AND'ing with 0x13's sets all 0xff bytes to 0x13,\n-\/\/ and leaves the zeroed bytes alone.\n-\/\/ __ vand(is_A_to_Z, is_A_to_Z, vec_13s);\n-\/\/ __ vor(indexes, indexes, is_A_to_Z);\n-\/\/\n-\/\/ indexes is now fully initialized.  Use it to select the offsets.\n-\/\/ __ xxperm(offsets->to_vsr(), offsetLUT->to_vsr(), indexes->to_vsr());\n-\/\/\n-\/\/ Now simply add the offsets to expanded\n-\/\/ __ vaddubm(expanded, expanded, offsets);\n-\n-#define ENCODE_CORE                                                       \\\n-    __ xxperm(input->to_vsr(), input->to_vsr(), expand_permute);          \\\n-    __ vsrb(rshift, input, expand_rshift);                                \\\n-    __ vand(rshift, rshift, expand_rshift_mask);                          \\\n-    __ vslo(lshift, input, vec_8s);                                       \\\n-    __ vslb(lshift, lshift, expand_lshift);                               \\\n-    __ vand(lshift, lshift, expand_lshift_mask);                          \\\n-    __ vor(expanded, rshift, lshift);                                     \\\n-    __ vsububs(indexes, expanded, vec_51s);                               \\\n-    __ vcmpgtub(is_A_to_Z, vec_26s, expanded);                            \\\n-    __ vand(is_A_to_Z, is_A_to_Z, vec_13s);                               \\\n-    __ vor(indexes, indexes, is_A_to_Z);                                  \\\n-    __ xxperm(offsets->to_vsr(), offsetLUT->to_vsr(), indexes->to_vsr()); \\\n-    __ vaddubm(expanded, expanded, offsets);\n+\/\/ At this point, expanded is a vector containing a 6-bit value in each\n+\/\/ byte.  These values are used as indexes into a 64-byte lookup table that\n+\/\/ is contained in four vector registers.  The lookup operation is done\n+\/\/ using vperm instructions with the same indexes for the lower 32 and\n+\/\/ upper 32 bytes.  To figure out which of the two looked-up bytes to use\n+\/\/ at each location, all values in expanded are compared to 31.  Using\n+\/\/ vsel, values higher than 31 use the results from the upper 32 bytes of\n+\/\/ the lookup operation, while values less than or equal to 31 use the\n+\/\/ lower 32 bytes of the lookup operation.  Power10 and beyond can save the\n+\/\/ compare instruction, because the comparison is done within xxpermx\n+\/\/ itself. TODO: use xxpermx,xxpermx,vor on P10 when instruction prefixes are\n+\/\/ available in assembler_ppc.*\n+\n+#define ENCODE_CORE                                                        \\\n+    __ xxperm(input->to_vsr(), input->to_vsr(), expand_permute);           \\\n+    __ vsrb(rshift, input, expand_rshift);                                 \\\n+    __ vand(rshift, rshift, expand_rshift_mask);                           \\\n+    __ vslo(lshift, input, vec_8s);                                        \\\n+    __ vslb(lshift, lshift, expand_lshift);                                \\\n+    __ vand(lshift, lshift, expand_lshift_mask);                           \\\n+    __ vor(expanded, rshift, lshift);                                      \\\n+    __ vperm(encoded_00_31, vec_base64_00_15, vec_base64_16_31, expanded); \\\n+    __ vperm(encoded_32_63, vec_base64_32_47, vec_base64_48_63, expanded); \\\n+    __ vcmpgtub(gt_31, expanded, vec_31s);                                 \\\n+    __ vsel(expanded, encoded_00_31, encoded_32_63, gt_31);\n@@ -4210,1 +4185,1 @@\n-    static const __vector unsigned char offsetLUT_val = {\n+    static const __vector unsigned char base64_00_15 = {\n@@ -4212,23 +4187,2 @@\n-      \/\/ 0\n-      (unsigned char)('a' - 26),\n-      \/\/ 1 .. 10\n-      (unsigned char)('0' - 52),\n-      (unsigned char)('0' - 52),\n-      (unsigned char)('0' - 52),\n-      (unsigned char)('0' - 52),\n-      (unsigned char)('0' - 52),\n-      (unsigned char)('0' - 52),\n-      (unsigned char)('0' - 52),\n-      (unsigned char)('0' - 52),\n-      (unsigned char)('0' - 52),\n-      (unsigned char)('0' - 52),\n-      \/\/ 11\n-      (unsigned char)('+' - 62),\n-      \/\/ 12\n-      (unsigned char)('\/' - 63),\n-      \/\/ 13\n-      (unsigned char)('A' - 0),\n-      \/\/ 14 .. 15 (unused)\n-      0, 0 ) };\n-\n-    static const __vector unsigned char offsetLUT_URL_val = {\n+      'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P' ) };\n+    static const __vector unsigned char base64_16_31 = {\n@@ -4236,21 +4190,10 @@\n-      \/\/ 0\n-      (unsigned char)('a' - 26),\n-      \/\/ 1 .. 10\n-      (unsigned char)('0' - 52),\n-      (unsigned char)('0' - 52),\n-      (unsigned char)('0' - 52),\n-      (unsigned char)('0' - 52),\n-      (unsigned char)('0' - 52),\n-      (unsigned char)('0' - 52),\n-      (unsigned char)('0' - 52),\n-      (unsigned char)('0' - 52),\n-      (unsigned char)('0' - 52),\n-      (unsigned char)('0' - 52),\n-      \/\/ 11\n-      (unsigned char)('-' - 62),\n-      \/\/ 12\n-      (unsigned char)('_' - 63),\n-      \/\/ 13\n-      (unsigned char)('A' - 0),\n-      \/\/ 14 .. 15 (unused)\n-      0, 0 ) };\n+      'Q','R','S','T','U','V','W','X','Y','Z','a','b','c','d','e','f' ) };\n+    static const __vector unsigned char base64_32_47 = {\n+      ARRAY_TO_LXV_ORDER(\n+      'g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v' ) };\n+    static const __vector unsigned char base64_48_63 = {\n+      ARRAY_TO_LXV_ORDER(\n+      'w','x','y','z','0','1','2','3','4','5','6','7','8','9','+','\/' ) };\n+    static const __vector unsigned char base64_48_63_URL = {\n+      ARRAY_TO_LXV_ORDER(\n+      'w','x','y','z','0','1','2','3','4','5','6','7','8','9','-','_' ) };\n@@ -4290,8 +4233,9 @@\n-    VectorRegister  vec_13s            = VR1;\n-    VectorRegister  vec_26s            = VR2;\n-    VectorRegister  vec_51s            = VR3;\n-    VectorRegister  expand_rshift      = VR4;\n-    VectorRegister  expand_rshift_mask = VR5;\n-    VectorRegister  expand_lshift      = VR6;\n-    VectorRegister  expand_lshift_mask = VR7;\n-    VectorRegister  offsetLUT          = VR8;\n+    VectorRegister  vec_31s            = VR1;\n+    VectorRegister  vec_base64_00_15   = VR2;\n+    VectorRegister  vec_base64_16_31   = VR3;\n+    VectorRegister  vec_base64_32_47   = VR4;\n+    VectorRegister  vec_base64_48_63   = VR5;\n+    VectorRegister  expand_rshift      = VR6;\n+    VectorRegister  expand_rshift_mask = VR7;\n+    VectorRegister  expand_lshift      = VR8;\n+    VectorRegister  expand_lshift_mask = VR9;\n@@ -4300,4 +4244,4 @@\n-    VectorRegister  input              = VR9;\n-    VectorRegister  rshift             = VR10;\n-    VectorRegister  lshift             = VR11;\n-    VectorRegister  expanded           = VR12;\n+    VectorRegister  input              = VR10;\n+    VectorRegister  rshift             = VR11;\n+    VectorRegister  lshift             = VR12;\n+    VectorRegister  expanded           = VR13;\n@@ -4306,3 +4250,3 @@\n-    VectorRegister  indexes            = VR10; \/\/ reuse rshift's register\n-    VectorRegister  is_A_to_Z          = VR11; \/\/ reuse lshift's register\n-    VectorRegister  offsets            = VR13; \/\/ reuse lshift's register\n+    VectorRegister  encoded_00_31      = VR10; \/\/ (reuse input)\n+    VectorRegister  encoded_32_63      = VR11; \/\/ (reuse rshift)\n+    VectorRegister  gt_31              = VR12; \/\/ (reuse lshift)\n@@ -4334,0 +4278,8 @@\n+    __ load_const_optimized(const_ptr, (address)&base64_00_15, tmp_reg);\n+    __ lxv(vec_base64_00_15->to_vsr(), 0, const_ptr);\n+    __ load_const_optimized(const_ptr, (address)&base64_16_31, tmp_reg);\n+    __ lxv(vec_base64_16_31->to_vsr(), 0, const_ptr);\n+    __ load_const_optimized(const_ptr, (address)&base64_32_47, tmp_reg);\n+    __ lxv(vec_base64_32_47->to_vsr(), 0, const_ptr);\n+    __ load_const_optimized(const_ptr, (address)&base64_48_63, tmp_reg);\n+    __ lxv(vec_base64_48_63->to_vsr(), 0, const_ptr);\n@@ -4337,3 +4289,1 @@\n-    __ xxspltib(vec_13s->to_vsr(), 13);\n-    __ xxspltib(vec_26s->to_vsr(), 26);\n-    __ xxspltib(vec_51s->to_vsr(), 51);\n+    __ xxspltib(vec_31s->to_vsr(), 31);\n@@ -4341,1 +4291,2 @@\n-    \/\/ Use a different offset lookup table depending on the\n+\n+    \/\/ Use a different translation lookup table depending on the\n@@ -4345,2 +4296,2 @@\n-    __ load_const_optimized(const_ptr, (address)&offsetLUT_URL_val, tmp_reg);\n-    __ lxv(offsetLUT->to_vsr(), 0, const_ptr);\n+    __ load_const_optimized(const_ptr, (address)&base64_48_63_URL, tmp_reg);\n+    __ lxv(vec_base64_48_63->to_vsr(), 0, const_ptr);\n@@ -4350,2 +4301,2 @@\n-    __ load_const_optimized(const_ptr, (address)&offsetLUT_val, tmp_reg);\n-    __ lxv(offsetLUT->to_vsr(), 0, const_ptr);\n+    __ load_const_optimized(const_ptr, (address)&base64_48_63, tmp_reg);\n+    __ lxv(vec_base64_48_63->to_vsr(), 0, const_ptr);\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":73,"deletions":122,"binary":false,"changes":195,"status":"modified"}]}