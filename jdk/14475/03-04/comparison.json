{"files":[{"patch":"@@ -383,1 +383,1 @@\n-     * The accessed address must be <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a> according to the {@linkplain\n+     * The base address must be <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a> according to the {@linkplain\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -207,1 +207,5 @@\n-        if (enclosing != null) {\n+\n+        \/\/ we only have to check the alignment of the root layout for the first dereference we do,\n+        \/\/ as each dereference checks the alignment of the target address when constructing its segment\n+        \/\/ (see Utils::longToAddress)\n+        if (derefAdapters.length == 0 && enclosing != null) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -146,0 +146,12 @@\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    void badDerefMisAligned() {\n+        MemoryLayout struct = MemoryLayout.structLayout(\n+            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT).withName(\"x\"));\n+\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(struct.byteSize() + 1).asSlice(1);\n+            VarHandle vhX = struct.varHandle(PathElement.groupElement(\"x\"), PathElement.dereferenceElement());\n+            vhX.set(segment, 42); \/\/ should throw\n+        }\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestDereferencePath.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"}]}