{"files":[{"patch":"@@ -383,0 +383,4 @@\n+     * The accessed address must be <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a> according to the {@linkplain\n+     * #byteAlignment() alignment constraint} of the root layout (this layout). Note that this can be more strict\n+     * (but not less) than the alignment constraint of the selected value layout.\n+     * <p>\n@@ -439,0 +443,4 @@\n+     * <p>\n+     * The segment to be sliced must be <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a> according to the\n+     * {@linkplain #byteAlignment() alignment constraint} of the root layout (this layout). Note that this can be more\n+     * strict (but not less) than the alignment constraint of the selected value layout.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+    private static final MethodHandle MH_CHECK_ALIGN;\n@@ -69,1 +70,3 @@\n-                    MethodType.methodType(MemorySegment.class, long.class, long.class));\n+                    MethodType.methodType(MemorySegment.class, long.class, MemoryLayout.class));\n+            MH_CHECK_ALIGN = lookup.findStatic(LayoutPath.class, \"checkAlign\",\n+                    MethodType.methodType(MemorySegment.class, MemorySegment.class, MemoryLayout.class));\n@@ -197,7 +200,4 @@\n-        for (int i = strides.length - 1; i >= 0; i--) {\n-            MethodHandle collector = MethodHandles.insertArguments(MH_ADD_SCALED_OFFSET, 2,\n-                    strides[i],\n-                    bounds[i]);\n-            \/\/ (J, ...) -> J to (J, J, ...) -> J\n-            \/\/ i.e. new coord is prefixed. Last coord will correspond to innermost layout\n-            handle = MethodHandles.collectCoordinates(handle, 1, collector);\n+        handle = MethodHandles.collectCoordinates(handle, 1, offsetHandle());\n+        if (enclosing != null) {\n+            MethodHandle checkHandle = MethodHandles.insertArguments(MH_CHECK_ALIGN, 1, rootLayout());\n+            handle = MethodHandles.filterCoordinates(handle, 0, checkHandle);\n@@ -205,2 +205,0 @@\n-        handle = MethodHandles.insertCoordinates(handle, 1,\n-                offset);\n@@ -234,0 +232,4 @@\n+    private MemoryLayout rootLayout() {\n+        return enclosing != null ? enclosing.rootLayout() : this.layout;\n+    }\n+\n@@ -235,1 +237,3 @@\n-        MethodHandle offsetHandle = offsetHandle(); \/\/ byte offset\n+        MethodHandle sliceHandle = MH_SLICE; \/\/ (MS, long, MemoryLayout) -> MS\n+        sliceHandle = MethodHandles.insertArguments(sliceHandle, 2, layout); \/\/ (MS, long) -> MS\n+        sliceHandle = MethodHandles.collectArguments(sliceHandle, 1, offsetHandle()); \/\/ (MS, ...) -> MS\n@@ -237,3 +241,4 @@\n-        MethodHandle sliceHandle = MH_SLICE; \/\/ (MS, long, long) -> MS\n-        sliceHandle = MethodHandles.insertArguments(sliceHandle, 2, layout.byteSize()); \/\/ (MS, long) -> MS\n-        sliceHandle = MethodHandles.collectArguments(sliceHandle, 1, offsetHandle); \/\/ (MS, ...) -> MS\n+        if (enclosing != null) {\n+            MethodHandle checkHandle = MethodHandles.insertArguments(MH_CHECK_ALIGN, 1, rootLayout());\n+            sliceHandle = MethodHandles.filterArguments(sliceHandle, 0, checkHandle);\n+        }\n@@ -244,0 +249,7 @@\n+    private static MemorySegment checkAlign(MemorySegment segment, MemoryLayout constraint) {\n+        if (!((AbstractMemorySegmentImpl) segment).isAlignedForElement(0, constraint)) {\n+            throw new IllegalArgumentException(\"Target offset incompatible with alignment constraints: \" + constraint.byteAlignment());\n+        }\n+        return segment;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":26,"deletions":14,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import org.testng.SkipException;\n@@ -38,0 +37,1 @@\n+import java.lang.invoke.VarHandle;\n@@ -45,0 +45,1 @@\n+import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n@@ -137,0 +138,32 @@\n+    @Test\n+    public void testBadAlignmentOfRoot() throws Throwable {\n+        MemoryLayout struct = MemoryLayout.structLayout(\n+            JAVA_INT,\n+            JAVA_SHORT.withName(\"x\"));\n+        assertEquals(struct.byteAlignment(), 4);\n+\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment seg = arena.allocate(struct.byteSize() + 2, struct.byteAlignment()).asSlice(2);\n+            assertEquals(seg.address() % JAVA_SHORT.byteAlignment(), 0); \/\/ should be aligned\n+            assertNotEquals(seg.address() % struct.byteAlignment(), 0); \/\/ should not be aligned\n+\n+            String expectedMessage = \"Target offset incompatible with alignment constraints: \" + struct.byteAlignment();\n+\n+            try {\n+                VarHandle vhX = struct.varHandle(groupElement(\"x\"));\n+                vhX.set(seg, (short) 42); \/\/ should throw\n+                fail(\"var handle didn't throw\");\n+            } catch (IllegalArgumentException e) {\n+                assertEquals(e.getMessage(), expectedMessage);\n+            }\n+\n+            try {\n+                MethodHandle sliceX = struct.sliceHandle(groupElement(\"x\"));\n+                MemorySegment slice = (MemorySegment) sliceX.invokeExact(seg); \/\/ should throw\n+                fail(\"slice handle didn't throw\");\n+            } catch (IllegalArgumentException e) {\n+                assertEquals(e.getMessage(), expectedMessage);\n+            }\n+        }\n+    }\n+\n@@ -341,1 +374,0 @@\n-\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":34,"deletions":2,"binary":false,"changes":36,"status":"modified"}]}