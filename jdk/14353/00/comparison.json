{"files":[{"patch":"@@ -2274,0 +2274,13 @@\n+jlong LoopLimitNode::calculate_final_con(const Type* init_t,\n+                                         const Type* limit_t,\n+                                         const Type* stride_t) const {\n+  \/\/ Use jlongs to avoid integer overflow.\n+  jlong init_con   = init_t->is_int()->get_con();\n+  jlong limit_con  = limit_t->is_int()->get_con();\n+  int   stride_con = stride_t->is_int()->get_con();\n+  int   stride_m   = stride_con - (stride_con > 0 ? 1 : -1);\n+  jlong trip_count = (limit_con - init_con + stride_m) \/ stride_con;\n+  jlong final_con  = init_con + stride_con * trip_count;\n+  return final_con;\n+}\n+\n@@ -2291,5 +2304,1 @@\n-    jlong init_con   =  init_t->is_int()->get_con();\n-    jlong limit_con  = limit_t->is_int()->get_con();\n-    int  stride_m   = stride_con - (stride_con > 0 ? 1 : -1);\n-    jlong trip_count = (limit_con - init_con + stride_m)\/stride_con;\n-    jlong final_con  = init_con + stride_con*trip_count;\n+    jlong final_con  = calculate_final_con(init_t, limit_t, stride_t);\n@@ -2297,4 +2306,12 @@\n-    \/\/ The final value should be in integer range since the loop\n-    \/\/ is counted and the limit was checked for overflow.\n-    assert(final_con == (jlong)final_int, \"final value should be integer\");\n-    return TypeInt::make(final_int);\n+    \/\/ During CCP, some control paths may not be found yet.\n+    \/\/ So there may be \"fake\" `final_con`, that overflows.\n+    \/\/ In this case, we conservatively return bottom_type().\n+    \/\/\n+    \/\/ At the end of CCP, the final value should be in integer\n+    \/\/ range since the loop is counted and the limit was\n+    \/\/ checked for overflow. We check this in check_final_value().\n+    if (final_con != (jlong) final_int) {\n+      return bottom_type();\n+    } else {\n+      return TypeInt::make(final_int);\n+    }\n@@ -2306,0 +2323,16 @@\n+#ifdef ASSERT\n+\/\/ At the end of CCP, final value should be in integer range\n+void LoopLimitNode::check_final_value(PhaseGVN* phase) const {\n+  const Type* init_t   = phase->type(in(Init));\n+  const Type* limit_t  = phase->type(in(Limit));\n+  const Type* stride_t = phase->type(in(Stride));\n+  assert(init_t->is_int()->is_con()\n+         && limit_t->is_int()->is_con()\n+         && stride_t->is_int()->is_con(),\n+         \"Expect constant values\");\n+  jlong final_con = calculate_final_con(init_t, limit_t, stride_t);\n+  int final_int = (int) final_con;\n+  assert(final_con == (jlong) final_int, \"final value should be integer\");\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":42,"deletions":9,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -543,0 +543,6 @@\n+#ifdef ASSERT\n+  void check_final_value(PhaseGVN* phase) const;\n+#endif\n+\n+ private:\n+  jlong calculate_final_con(const Type* init_t, const Type* limit_t, const Type* stride_t) const;\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -101,0 +101,1 @@\n+class LoopLimitNode;\n@@ -781,0 +782,1 @@\n+    DEFINE_CLASS_ID(LoopLimit, Node, 19)\n@@ -912,0 +914,1 @@\n+  DEFINE_CLASS_QUERY(LoopLimit)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1094,0 +1094,7 @@\n+\n+  if (n->is_LoopLimit()\n+      && type(n)->isa_int() != nullptr\n+      && type(n)->isa_int()->is_con()) {\n+    n->as_LoopLimit()->check_final_value(this);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8309266\n+ * @summary Test that a counted loop generating an exact final value that may sometimes\n+ *          overflow will not crash\n+ *\n+ * @run main\/othervm -Xbatch -XX:CompileOnly=compiler.loopopts.TestCountedLoopFinalValueMayOverflow::test\n+ *                   compiler.loopopts.TestCountedLoopFinalValueMayOverflow\n+ *\/\n+\n+package compiler.loopopts;\n+\n+public class TestCountedLoopFinalValueMayOverflow {\n+\n+    static boolean flag;\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 10000; i++) {\n+            flag = !flag;\n+            test();\n+        }\n+    }\n+\n+    public static void test() {\n+        int limit = flag ? Integer.MAX_VALUE : 1000;\n+        int i = 0;\n+        while (i < limit) {\n+            i += 3;\n+            if (flag) {\n+                return;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestCountedLoopFinalValueMayOverflow.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"}]}