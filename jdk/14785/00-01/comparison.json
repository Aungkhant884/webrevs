{"files":[{"patch":"@@ -1669,0 +1669,1 @@\n+  int invar_factor = mem_ref_p.invar_factor();\n@@ -1688,0 +1689,2 @@\n+    tty->print_cr(\"  invar_factor = %d\", invar_factor);\n+\n@@ -1703,11 +1706,0 @@\n-  \/\/ Out of simplicity: variable init values not supported.\n-  if (!init_node->is_ConI()) {\n-    return AlignmentSolution(\"variable init values not supported\");\n-  }\n-  jint init        = init_node->as_ConI()->get_int();\n-\n-  \/\/ Out of simplicity: mem_ref with invariant not supported.\n-  if (invar != nullptr) {\n-    return AlignmentSolution(\"mem_ref with invariant not supported\");\n-  }\n-\n@@ -1731,3 +1723,4 @@\n-  \/\/       = base + offset + invar + scale * init\n-  \/\/                               + scale * pre_iter * pre_stride\n-  \/\/                               + scale * j * main_stride\n+  \/\/       = base + offset + invar_factor * invar_var\n+  \/\/                       + scale * init\n+  \/\/                       + scale * pre_iter * pre_stride\n+  \/\/                       + scale * j * main_stride\n@@ -1736,8 +1729,22 @@\n-  \/\/         + invar                             (=0, invar not allowed)\n-  \/\/         + C1                                (const)\n-  \/\/         + C2 * pre_iter                     (adjustable term)\n-  \/\/         + C3 * j                            (for any j >= 0)\n-  \/\/\n-  \/\/ With the following constants:\n-  \/\/\n-  int C1 = offset + scale * init;\n+  \/\/         + C0                                (const)\n+  \/\/         + C1_init  * var1                   (term from init, for any var1)\n+  \/\/         + C1_invar * var2                   (term from invar, for any var2)\n+  \/\/         + C2       * pre_iter               (adjustable term)\n+  \/\/         + C3       * j                      (for any j >= 0)\n+\n+  \/\/ Trivial constants\n+  int C0_init  = 0;\n+  int C1_init  = 0;\n+  int C1_invar = 0;\n+\n+  if (init_node->is_ConI()) {\n+    C0_init = init_node->as_ConI()->get_int();\n+  } else {\n+    C1_init = scale;\n+  }\n+\n+  if (invar != nullptr) {\n+    C1_invar = abs(invar_factor);\n+  }\n+\n+  int C0 = offset + C0_init * scale;\n@@ -1750,3 +1757,20 @@\n-    tty->print_cr(\"C1(%d) + C2(%d) * pre_iter + C3(%d) * j\", C1, C2, C3);\n-    tty->print_cr(\"  C1 = offset(%d) + scale(%d) * init(%d) = %d\",\n-                  offset, scale, init, C1);\n+    tty->print_cr(\"C0(%d) + C1_init(%d) * var1 + C1_invar(%d) * var2 + C2(%d) * pre_iter + C3(%d) * j\",\n+                  C0, C1_init, C1_invar, C2, C3);\n+    if (init_node->is_ConI()) {\n+      tty->print_cr(\"  init is constant:\");\n+      tty->print_cr(\"    C0_init = %d\", C0_init);\n+      tty->print_cr(\"    C1_init = %d\", C1_init);\n+    } else {\n+      tty->print_cr(\"  init is variable:\");\n+      tty->print_cr(\"    C0_init = %d\", C0_init);\n+      tty->print_cr(\"    C1_init = abs(scale)= %d\", C1_init);\n+    }\n+    if (invar != nullptr) {\n+      tty->print_cr(\"  invariant present:\");\n+      tty->print_cr(\"    C1_invar = abs(invar_factor) = %d\", C1_invar);\n+    } else {\n+      tty->print_cr(\"  no invariant:\");\n+      tty->print_cr(\"    C1_invar = %d\", C1_invar);\n+    }\n+    tty->print_cr(\"  C0 = offset(%d) + scale(%d) * C0_init(%d) = %d\",\n+                  offset, scale, C0_init, C0);\n@@ -1763,1 +1787,1 @@\n-  \/\/   C1 + C2 * pre_iter + C3 * j = 0 (modulo aw)        (1)\n+  \/\/   C0 + C1_init * var1 + C1_invar * var2 + C2 * pre_iter + C3 * j = 0 (modulo aw)        (1)\n@@ -1765,1 +1789,1 @@\n-  \/\/ Since this holds for any j >= 0, we require:\n+  \/\/ Alignment must be maintained over all main-loop iterations, i.e for any j >= 0, we require:\n@@ -1767,2 +1791,1 @@\n-  \/\/   C3 % aw = 0                                        (2*)\n-  \/\/   C1 + C2 * pre_iter = 0 (modulo aw)                 (3)\n+  \/\/   C3 % aw = 0                                                                           (2*)\n@@ -1774,4 +1797,8 @@\n-    tty->print_cr(\"  EQ(1 ): C1(%d) + C2(%d) * pre_iter + C3(%d) * j = 0 (mod aw(%d))\",\n-                  C1, C2, C3, aw);\n-    tty->print_cr(\"  EQ(2*): C3(%d) %% aw(%d) = scale(%d) * main_stride(%d) %% aw(%d) = %d = 0\",\n-                  C3, aw, scale, main_stride, aw, C3_mod_aw);\n+    tty->print(\"  EQ(1  ): C0(%d) + C1_init(%d) * var1 + C1_invar(%d) * var2\",\n+                  C0, C1_init, C1_invar);\n+    tty->print(\" + C2(%d) * pre_iter + C3(%d) * j = 0 (mod aw(%d))\",\n+                  C2, C3, aw);\n+    tty->print_cr(\" (given base aligned -> align rest)\");\n+    tty->print(\"  EQ(2* ): C3(%d) %% aw(%d) = scale(%d) * main_stride(%d) %% aw(%d) = %d = 0\",\n+               C3, aw, scale, main_stride, aw, C3_mod_aw);\n+    tty->print_cr(\" (alignment across iterations)\");\n@@ -1785,0 +1812,29 @@\n+  \/\/ In what follows, me must ensure that the C2 term can align the C0, C1_init and C1_invar terms,\n+  \/\/ by adjusting the pre-loop limit (pre_iter). We must check\n+  \/\/\n+  \/\/   C1_init  % abs(C2) = 0                                          (3a*)\n+  \/\/   C1_invar % abs(C2) = 0                                          (3b*)\n+  \/\/\n+  \/\/ to ensure that the variable term for init and invar can be aligned with the C2 term.\n+  \/\/\n+  int C1_init_mod_abs_C2  = AlignmentSolution::mod(C1_init,  abs(C2));\n+  int C1_invar_mod_abs_C2 = AlignmentSolution::mod(C1_invar, abs(C2));\n+\n+#ifndef PRODUCT\n+  if (is_trace_align_vector()) {\n+    tty->print_cr(\"  EQ(3a*): C1_init(%d) %% abs(C2(%d)) = %d = 0   (if false: cannot align init)\",\n+                  C1_init, C2, C1_init_mod_abs_C2);\n+    tty->print_cr(\"  EQ(3b*): C1_invar(%d) %% abs(C2(%d)) = %d = 0  (if false: cannot align invar)\",\n+                  C1_invar, C2, C1_invar_mod_abs_C2);\n+  }\n+#endif\n+\n+  if (C1_init_mod_abs_C2 != 0) {\n+    return AlignmentSolution(\"EQ(3a*) not satisfied (cannot align init)\");\n+  }\n+  if (C1_invar_mod_abs_C2 != 0) {\n+    return AlignmentSolution(\"EQ(3b*) not satisfied (cannot align invar)\");\n+  }\n+\n+  \/\/ We must now show that the C0 term can be aligned.\n+  \/\/\n@@ -1789,1 +1845,1 @@\n-  \/\/   C1 % aw = 0                                        (4*)\n+  \/\/   C0 % aw = 0                                           (4*)\n@@ -1804,1 +1860,1 @@\n-    int C1_mod_aw = AlignmentSolution::mod(C1, aw);\n+    int C0_mod_aw = AlignmentSolution::mod(C0, aw);\n@@ -1808,2 +1864,2 @@\n-      tty->print_cr(\"  EQ(4*): C1(%d) %% aw(%d) = %d = 0\",\n-                    C1, aw, C1_mod_aw);\n+      tty->print_cr(\"  EQ(4* ): C0(%d) %% aw(%d) = %d = 0\",\n+                    C0, aw, C0_mod_aw);\n@@ -1813,2 +1869,6 @@\n-    if (C1_mod_aw != 0) {\n-      return AlignmentSolution(\"EQ(4*) not satisfied (offset and init not aligned)\");\n+    \/\/ The C1 terms are trivially aligned.\n+    assert(AlignmentSolution::mod(C1_init,  aw) == 0,  \"implied by abs(C2) >= aw and (3a*)\");\n+    assert(AlignmentSolution::mod(C1_invar, aw) == 0,  \"implied by abs(C2) >= aw and (3b*)\");\n+\n+    if (C0_mod_aw != 0) {\n+      return AlignmentSolution(\"EQ(4*) not satisfied: C0 not aligned\");\n@@ -1816,1 +1876,2 @@\n-      return AlignmentSolution::make_trivial(); \/\/ any pre_iter >= 0\n+      \/\/ Solution is trivial, holds for any pre-loop limit.\n+      return AlignmentSolution();\n@@ -1820,2 +1881,13 @@\n-  \/\/ Otherwise, if abs(C2) < aw, we can find all solutions of pre_iter by\n-  \/\/ defined in terms of the smallest possible pre_q >= 0 and 0 <= pre_r < pre_q:\n+  \/\/ Otherwise, if abs(C2) < aw, we need to produce a solution that aligns\n+  \/\/ the C0, C1_init and C1_invar terms at the same time.\n+  \/\/\n+  \/\/   C0 + C1_init * var1 + C1_invar * var2 + C2 * pre_iter = 0 (modulo aw)        (5)\n+  \/\/\n+  \/\/ In general, this is not an easy task at compile time. We add two\n+  \/\/ simplifying restrictions:\n+  \/\/\n+  \/\/ 1. If a variable init is present (i.e. C1_init = scale), then we\n+  \/\/    make the solution dependent on scale and C2. Only solutions\n+  \/\/    with the same dependencies are compatible. This ensures that\n+  \/\/    all solutions require the same number of pre-loop iterations\n+  \/\/    to align the C1_init term.\n@@ -1823,2 +1895,17 @@\n-  \/\/   pre_iter = pre_r + pre_q * m  (for any m >= 0)     (5)\n-  \/\/   C1 + C2 * pre_r + C2 * pre_q * m = 0 (modulo aw)   (6)\n+  \/\/ 2. If a invariant is present, then we make the solution dependent\n+  \/\/    on C2 and invar. Only solutions with tthe same dependenceis are\n+  \/\/    compatible. This ensures that all solutions require the same\n+  \/\/    number of pre-loop iterations to align the C1_invar term.\n+  \/\/\n+  \/\/ With these assumptions, we can find a solution:\n+  \/\/\n+  \/\/   pre_iter = pre_iter_C0 + pre_iter_C1_init + pre_iter_C1_invar\n+  \/\/\n+  \/\/ From (3b*) and the two simplifying assumptions, we know that\n+  \/\/ pre_iter_C1_init and pre_iter_C1_invar exist and are the same\n+  \/\/ for all compatible solutions.\n+  \/\/ We now have to show that thereis a pre_iter_C0, terms of the\n+  \/\/ smallest possible pre_q >= 0 and 0 <= pre_r < pre_q:\n+  \/\/\n+  \/\/   pre_iter_C0 = pre_r + pre_q * m  (for any m >= 0)                            (6)\n+  \/\/   C0 + C2 * pre_r + C2 * pre_q * m = 0 (modulo aw)                             (7)\n@@ -1828,2 +1915,2 @@\n-  \/\/   C2 * pre_q = 0 (modulo aw)                         (7)\n-  \/\/   C1 + C2 * pre_r = 0 (modulo aw)                    (8*)\n+  \/\/   C2 * pre_q = 0 (modulo aw)                                                   (8)\n+  \/\/   C0 + C2 * pre_r = 0 (modulo aw)                                              (9*)\n@@ -1833,1 +1920,1 @@\n-  int  pre_q = aw \/ abs(C2); \/\/                           (9*)\n+  int  pre_q = aw \/ abs(C2);\n@@ -1836,1 +1923,1 @@\n-  \/\/ all values 0..pre_q-1 and checking EQ(8*).\n+  \/\/ all values 0..pre_q-1 and checking EQ(9*).\n@@ -1842,1 +1929,1 @@\n-    tty->print_cr(\"  EQ(8*): brute force pre_r = 0..%d\", pre_q - 1);\n+    tty->print_cr(\"  EQ(9*): brute force pre_r = 0..%d\", pre_q - 1);\n@@ -1847,1 +1934,1 @@\n-    int EQ8_val = AlignmentSolution::mod(C1 + C2 * pre_r, aw);\n+    int EQ9_val = AlignmentSolution::mod(C0 + C2 * pre_r, aw);\n@@ -1851,2 +1938,2 @@\n-      tty->print_cr(\"   try pre_r = %d: (C1(%d) + C2(%d) * pre_r(%d)) %% aw(%d) = %d = 0\",\n-                    pre_r, C1, C2, pre_r, aw, EQ8_val);\n+      tty->print_cr(\"   try pre_r = %d: (C0(%d) + C2(%d) * pre_r(%d)) %% aw(%d) = %d = 0\",\n+                    pre_r, C0, C2, pre_r, aw, EQ9_val);\n@@ -1856,2 +1943,10 @@\n-    if (EQ8_val == 0) {\n-      return AlignmentSolution(pre_r, pre_q, mem_ref, aw);\n+    if (EQ9_val == 0) {\n+      assert((C1_init == 0) == init_node->is_ConI(), \"init consistent\");\n+      assert((C1_invar == 0) == (invar == nullptr), \"invar consistent\");\n+\n+      \/\/ Dependencies given by the two simplifying assumptions.\n+      \/\/ Note: if scale is the same, then C2 is the same.\n+      Node* invar_dependency = invar;\n+      int scale_dependency  = (invar != nullptr || !init_node->is_ConI()) ? scale : 0;\n+      return AlignmentSolution(pre_r, pre_q, mem_ref, aw,\n+                               invar_dependency, scale_dependency);\n@@ -1860,1 +1955,1 @@\n-  return AlignmentSolution(\"EQ(8*) has no solution for pre_r\");\n+  return AlignmentSolution(\"EQ(9*) has no solution for pre_r\");\n@@ -1911,1 +2006,1 @@\n-  AlignmentSolution current = AlignmentSolution::make_trivial();\n+  AlignmentSolution current; \/\/ trivial\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":151,"deletions":56,"binary":false,"changes":207,"status":"modified"},{"patch":"@@ -239,1 +239,11 @@\n-\/\/ There is either a valid solution (r, q, mem_ref, aw) or otherwise a failure reason.\n+\/\/ Two simplifying restrictions:\n+\/\/   1. In the presence of variable init, all solutions must have the same scale.\n+\/\/   2. In the presence of an invariant, all solutions must have the same invariant\n+\/\/      and the same scale.\n+\/\/\n+\/\/ A solution can be:\n+\/\/   1. Invalid with a failure reason.\n+\/\/   2. Trivial (any pre-loop limit guarantees alignment).\n+\/\/   3. Constrained (r, q, mem_ref, aw, scale, invar)\n+\/\/        Where scale is 0 if no scale dependency,\n+\/\/        and invar is nullptr if no invar dependency.\n@@ -244,0 +254,1 @@\n+  bool _trivial = true;\n@@ -248,0 +259,2 @@\n+  Node* _invar_dependency = nullptr;\n+  int _scale_dependency = 0;\n@@ -249,4 +262,43 @@\n-  AlignmentSolution(const int r, const int q, MemNode* mem_ref, int aw) :\n-                    _valid(true), _reason(nullptr),\n-                    _r(r), _q(q), _mem_ref(mem_ref), _aw(aw) {\n-    assert(q > 0 && is_power_of_2(q), \"q must be power of 2\");\n+  \/\/ Invalid solution.\n+  AlignmentSolution(const char* reason) :\n+      _valid(false),\n+      _reason(reason),\n+      _trivial(false),\n+      _r(0),\n+      _q(1),\n+      _mem_ref(nullptr),\n+      _aw(1),\n+      _invar_dependency(nullptr),\n+      _scale_dependency(0) {\n+    assert(!is_trivial() && !is_valid(), \"must be invalid\");\n+  }\n+  \/\/ Trivial Solution.\n+  AlignmentSolution() :\n+      _valid(true),\n+      _reason(nullptr),\n+      _trivial(true),\n+      _r(0),\n+      _q(1),\n+      _mem_ref(nullptr),\n+      _aw(1),\n+      _invar_dependency(nullptr),\n+      _scale_dependency(0) {\n+    assert(is_trivial() && is_valid(), \"must be trivial\");\n+  }\n+  \/\/ Constrained solution.\n+  AlignmentSolution(const int r,\n+                    const int q,\n+                    MemNode* mem_ref,\n+                    int aw,\n+                    Node* invar_dependency,\n+                    int scale_dependency) :\n+      _valid(true),\n+      _reason(nullptr),\n+      _trivial(false),\n+      _r(r),\n+      _q(q),\n+      _mem_ref(mem_ref),\n+      _aw(aw),\n+      _invar_dependency(invar_dependency),\n+      _scale_dependency(scale_dependency) {\n+    assert(q > 1 && is_power_of_2(q), \"q must be power of 2\");\n@@ -254,2 +306,3 @@\n-    assert(is_trivial() || (_mem_ref != nullptr && _mem_ref->memory_size() <= _aw),\n-           \"trivial solution or must have mem_ref and aw\");\n+    assert(!is_trivial() && is_valid(), \"must be constrained\");\n+    assert(_mem_ref != nullptr && _mem_ref->memory_size() <= _aw,\n+           \"must have mem_ref and aw\");\n@@ -258,4 +311,0 @@\n-  AlignmentSolution(const char* reason) : _valid(false), _reason(reason), _r(0), _q(1) {}\n-  static AlignmentSolution make_trivial() {\n-    return AlignmentSolution(0, 1, nullptr, 1);\n-  }\n@@ -268,1 +317,3 @@\n-  bool is_trivial() const { return r() == 0 && q() == 1; }\n+  bool is_trivial() const { return _trivial; }\n+  Node* invar_dependency() const { return _invar_dependency; }\n+  int scale_dependency() const { return _scale_dependency; }\n@@ -270,0 +321,1 @@\n+    \/\/ Solution invalid if either is invalid.\n@@ -275,0 +327,13 @@\n+\n+    \/\/ If one is trivial, return the other.\n+    if (s1.is_trivial()) { return s2; }\n+    if (s2.is_trivial()) { return s1; }\n+\n+    \/\/ Combine two constrained solutions.\n+    if (s1.invar_dependency() != s2.invar_dependency()) {\n+      return AlignmentSolution(\"invar not identical\");\n+    }\n+    if (s1.scale_dependency() != s2.scale_dependency()) {\n+      return AlignmentSolution(\"different scale dependency (init \/ invar)\");\n+    }\n+    \/\/ Make s2 the bigger modulo space\n@@ -279,4 +344,2 @@\n-    if (mod(s2.r(), s1.q()) == s1.r()) {\n-      \/\/ \"s1 = r1 + m1 * q1\" is a superset of \"s2 = r2 + m2 * q2\"\n-      return s2; \/\/ return the subset\n-    } else {\n+    \/\/ Subset check:\n+    if (mod(s2.r(), s1.q()) != s1.r()) {\n@@ -284,1 +347,1 @@\n-      return AlignmentSolution(\"input solutions have empty intersection\");\n+      return AlignmentSolution(\"empty intersection (r and q)\");\n@@ -286,0 +349,2 @@\n+    \/\/ Now we know: \"s1 = r1 + m1 * q1\" is a superset of \"s2 = r2 + m2 * q2\"\n+    return s2; \/\/ return the subset\n@@ -292,1 +357,1 @@\n-        tty->print_cr(\"pre_iter = pre_r(%d) + m * pre_q(%d) (for any m >= 0) -> mem_ref[%d] %% aw(%d)\",\n+        tty->print(\"pre_r(%d) + m * pre_q(%d), mem_ref[%d] %% aw(%d),\",\n@@ -294,0 +359,6 @@\n+        tty->print(\" scale = %d, \", scale_dependency());\n+        if (invar_dependency() == nullptr) {\n+          tty->print_cr(\"no invar\");\n+\t} else {\n+          tty->print_cr(\"invar[%d]\", invar_dependency()->_idx);\n+\t}\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":89,"deletions":18,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -122,0 +122,16 @@\n+\/\/ Biggest detectable factor of the invariant.\n+int VPointer::invar_factor() {\n+  Node* n = invar();\n+  if (n == nullptr) {\n+    return 0;\n+  }\n+  int opc = n->Opcode();\n+  if (opc == Op_LShiftI && n->in(2)->is_Con()) {\n+    return 1 << n->in(2)->get_int();\n+  } else if (opc == Op_LShiftL && n->in(2)->is_Con()) {\n+    return 1 << n->in(2)->get_int();\n+  }\n+  \/\/ All our best-effort has failed.\n+  return 1;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -101,0 +101,3 @@\n+  \/\/ Biggest detectable factor of the invariant.\n+  int   invar_factor();\n+\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n- * @requires vm.bits == 64\n@@ -54,1 +53,0 @@\n- * @requires vm.bits == 64\n@@ -65,1 +63,0 @@\n- * @requires vm.bits == 64\n@@ -390,0 +387,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -406,0 +404,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -427,0 +426,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -432,0 +432,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -449,0 +450,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -454,0 +456,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -477,0 +480,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -484,0 +488,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -510,0 +515,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -515,0 +521,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -534,0 +541,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -539,0 +547,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -558,0 +567,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -563,0 +573,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -582,0 +593,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -587,0 +599,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -606,0 +619,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -625,0 +639,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -630,0 +645,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -647,0 +663,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -652,0 +669,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -670,0 +688,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -675,0 +694,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -693,0 +713,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -709,0 +730,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -722,0 +744,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -735,0 +758,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -748,0 +772,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -761,0 +786,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -774,0 +800,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -787,0 +814,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -800,0 +828,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -814,0 +843,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -819,0 +849,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -833,0 +864,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -838,0 +870,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -852,0 +885,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -857,0 +891,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -870,0 +905,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -883,7 +919,2 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n-        applyIf = {\"AlignVector\", \"false\"})\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n-                  IRNode.AND_VB, \"= 0\",\n-                  IRNode.STORE_VECTOR, \"= 0\"},\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n-        applyIf = {\"AlignVector\", \"true\"})\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n@@ -892,1 +923,0 @@\n-            \/\/ Not alignable with AlignVector because of invariant\n@@ -902,7 +932,2 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n-        applyIf = {\"AlignVector\", \"false\"})\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"= 0\",\n-                  IRNode.AND_VS, \"= 0\",\n-                  IRNode.STORE_VECTOR, \"= 0\"},\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n-        applyIf = {\"AlignVector\", \"true\"})\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n@@ -911,1 +936,0 @@\n-            \/\/ Not alignable with AlignVector because of invariant\n@@ -921,7 +945,2 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n-        applyIf = {\"AlignVector\", \"false\"})\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n-                  IRNode.AND_VI, \"= 0\",\n-                  IRNode.STORE_VECTOR, \"= 0\"},\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n-        applyIf = {\"AlignVector\", \"true\"})\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n@@ -930,1 +949,0 @@\n-            \/\/ Not alignable with AlignVector because of invariant\n@@ -940,7 +958,2 @@\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n-        applyIf = {\"AlignVector\", \"false\"})\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"= 0\",\n-                  IRNode.AND_VL, \"= 0\",\n-                  IRNode.STORE_VECTOR, \"= 0\"},\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n-        applyIf = {\"AlignVector\", \"true\"})\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n@@ -949,1 +962,0 @@\n-            \/\/ Not alignable with AlignVector because of invariant\n@@ -959,0 +971,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -977,0 +990,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -993,0 +1007,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -1008,0 +1023,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -1027,0 +1043,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -1044,0 +1061,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -1060,0 +1078,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -1075,0 +1094,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -1094,0 +1114,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -1110,0 +1131,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -1115,0 +1137,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -1144,0 +1167,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -1149,0 +1173,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -1178,0 +1203,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -1183,0 +1209,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -1337,0 +1364,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -1365,0 +1393,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -1383,0 +1412,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -1389,0 +1419,1 @@\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAlignVector.java","additions":66,"deletions":35,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -109,4 +109,3 @@\n-        counts = {IRNode.STORE_VECTOR, \">0\",\n-                  IRNode.MUL_VI, \">0\"},\n-        applyIf = {\"AlignVector\", \"false\"})\n-    \/\/ AlignVector does not allow invariants\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse4.1\", \"true\"},\n+        counts = {IRNode.MUL_VI, \">0\"})\n@@ -124,4 +123,3 @@\n-        counts = {IRNode.STORE_VECTOR, \">0\",\n-                  IRNode.MUL_VI, \">0\"},\n-        applyIf = {\"AlignVector\", \"false\"})\n-    \/\/ AlignVector does not allow invariants\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx2\", \"true\"},\n+        counts = {IRNode.MUL_VI, \">0\"})\n@@ -139,4 +137,3 @@\n-        counts = {IRNode.STORE_VECTOR, \">0\",\n-                  IRNode.MUL_VI, \">0\"},\n-        applyIf = {\"AlignVector\", \"false\"})\n-    \/\/ AlignVector does not allow invariants\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse4.1\", \"true\"},\n+        counts = {IRNode.MUL_VI, \">0\"})\n@@ -154,4 +151,3 @@\n-        counts = {IRNode.STORE_VECTOR, \">0\",\n-                  IRNode.SUB_VI, \">0\"},\n-        applyIf = {\"AlignVector\", \"false\"})\n-    \/\/ AlignVector does not allow invariants\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.SUB_VI, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopArrayIndexComputeTest.java","additions":12,"deletions":16,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -72,3 +72,1 @@\n-        counts = {IRNode.STORE_VECTOR, \">0\"},\n-        applyIf = {\"AlignVector\", \"false\"})\n-    \/\/ AlignVector does not allow variable init (start)\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -86,3 +84,1 @@\n-        counts = {IRNode.STORE_VECTOR, \">0\"},\n-        applyIf = {\"AlignVector\", \"false\"})\n-    \/\/ AlignVector does not allow variable init (start)\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -100,3 +96,1 @@\n-        counts = {IRNode.STORE_VECTOR, \">0\"},\n-        applyIf = {\"AlignVector\", \"false\"})\n-    \/\/ AlignVector does not allow variable init (start)\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -114,3 +108,1 @@\n-        counts = {IRNode.STORE_VECTOR, \">0\"},\n-        applyIf = {\"AlignVector\", \"false\"})\n-    \/\/ AlignVector does not allow variable init (start)\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -128,3 +120,1 @@\n-        counts = {IRNode.STORE_VECTOR, \">0\"},\n-        applyIf = {\"AlignVector\", \"false\"})\n-    \/\/ AlignVector does not allow variable init (start)\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopLiveOutNodesTest.java","additions":5,"deletions":15,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -83,3 +83,1 @@\n-        counts = {IRNode.STORE_VECTOR, \">0\"},\n-        applyIf = {\"AlignVector\", \"false\"})\n-    \/\/ AlignVector does not allow variable init (start)\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -107,3 +105,1 @@\n-        counts = {IRNode.STORE_VECTOR, \">0\"},\n-        applyIf = {\"AlignVector\", \"false\"})\n-    \/\/ AlignVector does not allow variable init (start)\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -131,3 +127,1 @@\n-        counts = {IRNode.STORE_VECTOR, \">0\"},\n-        applyIf = {\"AlignVector\", \"false\"})\n-    \/\/ AlignVector does not allow variable init (start)\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -146,3 +140,1 @@\n-        counts = {IRNode.STORE_VECTOR, \">0\"},\n-        applyIf = {\"AlignVector\", \"false\"})\n-    \/\/ AlignVector does not allow variable init (start)\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopRangeStrideTest.java","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -118,3 +118,1 @@\n-        counts = {IRNode.STORE_VECTOR, \">0\"},\n-        applyIf = {\"AlignVector\", \"false\"})\n-    \/\/ AlignVector does not allow invariant (i is invariant in innermost loop)\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/MultipleLoopsTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}