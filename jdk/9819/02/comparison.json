{"files":[{"patch":"@@ -499,1 +499,0 @@\n-jdk\/internal\/misc\/TerminatingThreadLocal\/TestTerminatingThreadLocal.java 8292051 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n@@ -29,1 +31,3 @@\n-import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n@@ -31,0 +35,6 @@\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n@@ -36,1 +46,1 @@\n- * @modules java.base\/jdk.internal.misc\n+ * @modules java.base\/java.lang:+open java.base\/jdk.internal.misc\n@@ -39,1 +49,1 @@\n- * @run main\/othervm -Djdk.virtualThreadScheduler.parallelism=1 -Djdk.virtualThreadScheduler.maxPoolSize=2 TestTerminatingThreadLocal\n+ * @run testng\/othervm TestTerminatingThreadLocal\n@@ -43,6 +53,5 @@\n-    public static void main(String[] args) {\n-        ttlTestSet(42, 112);\n-        ttlTestSet(null, 112);\n-        ttlTestSet(42, null);\n-\n-        ttlTestVirtual(666, ThreadLocal::get, 666);\n+    @SafeVarargs\n+    static <T> Object[] testCase(T initialValue,\n+                                 Consumer<? super TerminatingThreadLocal<T>> ttlOps,\n+                                 T... expectedTerminatedValues) {\n+        return new Object[] {initialValue, ttlOps, Arrays.asList(expectedTerminatedValues)};\n@@ -51,9 +60,11 @@\n-    static <T> void ttlTestSet(T v0, T v1) {\n-        ttlTestPlatform(v0, ttl -> {                                         }    );\n-        ttlTestPlatform(v0, ttl -> { ttl.get();                              }, v0);\n-        ttlTestPlatform(v0, ttl -> { ttl.get();   ttl.remove();              }    );\n-        ttlTestPlatform(v0, ttl -> { ttl.get();   ttl.set(v1);               }, v1);\n-        ttlTestPlatform(v0, ttl -> { ttl.set(v1);                            }, v1);\n-        ttlTestPlatform(v0, ttl -> { ttl.set(v1); ttl.remove();              }    );\n-        ttlTestPlatform(v0, ttl -> { ttl.set(v1); ttl.remove(); ttl.get();   }, v0);\n-        ttlTestPlatform(v0, ttl -> { ttl.get();   ttl.remove(); ttl.set(v1); }, v1);\n+    static <T> Stream<Object[]> testCases(T v0, T v1) {\n+        return Stream.of(\n+            testCase(v0, ttl -> {                                         }    ),\n+            testCase(v0, ttl -> { ttl.get();                              }, v0),\n+            testCase(v0, ttl -> { ttl.get();   ttl.remove();              }    ),\n+            testCase(v0, ttl -> { ttl.get();   ttl.set(v1);               }, v1),\n+            testCase(v0, ttl -> { ttl.set(v1);                            }, v1),\n+            testCase(v0, ttl -> { ttl.set(v1); ttl.remove();              }    ),\n+            testCase(v0, ttl -> { ttl.set(v1); ttl.remove(); ttl.get();   }, v0),\n+            testCase(v0, ttl -> { ttl.get();   ttl.remove(); ttl.set(v1); }, v1)\n+        );\n@@ -62,0 +73,8 @@\n+    @DataProvider\n+    public Object[][] testCases() {\n+        return Stream.of(\n+            testCases(42, 112),\n+            testCases(null, new Object()),\n+            testCases(\"abc\", null)\n+        ).flatMap(Function.identity()).toArray(Object[][]::new);\n+    }\n@@ -63,2 +82,5 @@\n-    @SafeVarargs\n-    static <T> void ttlTestPlatform(T initialValue,\n+    \/**\n+     * Test TerminatingThreadLocal with a platform thread.\n+     *\/\n+    @Test(dataProvider = \"testCases\")\n+    public <T> void ttlTestPlatform(T initialValue,\n@@ -66,1 +88,1 @@\n-                                    T... expectedTerminatedValues) {\n+                                    List<T> expectedTerminatedValues) throws Exception {\n@@ -83,5 +105,1 @@\n-        try {\n-            thread.join();\n-        } catch (InterruptedException e) {\n-            throw new RuntimeException(e);\n-        }\n+        thread.join();\n@@ -89,5 +107,1 @@\n-        if (!terminatedValues.equals(Arrays.asList(expectedTerminatedValues))) {\n-            throw new AssertionError(\"Expected terminated values: \" +\n-                                     Arrays.toString(expectedTerminatedValues) +\n-                                     \" but got: \" + terminatedValues);\n-        }\n+        assertEquals(terminatedValues, expectedTerminatedValues);\n@@ -96,2 +110,7 @@\n-    @SafeVarargs\n-    static <T> void ttlTestVirtual(T initialValue,\n+    \/**\n+     * Test TerminatingThreadLocal with a virtual thread. The thread local should be\n+     * carrier thread local but accessible to the virtual thread. The threadTerminated\n+     * method should be invoked when the carrier thread terminates.\n+     *\/\n+    @Test(dataProvider = \"testCases\")\n+    public <T> void ttlTestVirtual(T initialValue,\n@@ -99,1 +118,1 @@\n-                                   T... expectedTerminatedValues) {\n+                                   List<T> expectedTerminatedValues) throws Exception {\n@@ -114,33 +133,1 @@\n-        var lock = new Lock();\n-\n-        var blockerThread = Thread.startVirtualThread(() -> {\n-            \/\/ force compensation in carrier thread pool which will spin another\n-            \/\/ carrier thread so that we can later observe it being terminated...\n-            synchronized (lock) {\n-                while (!lock.unblock) {\n-                    try {\n-                        lock.wait();\n-                    } catch (InterruptedException e) {\n-                        throw new RuntimeException(e);\n-                    }\n-                }\n-            }\n-            \/\/ keep thread running in a non-blocking-fashion which keeps\n-            \/\/ it bound to carrier thread\n-            while (!lock.unspin) {\n-                Thread.onSpinWait();\n-            }\n-        });\n-\n-        Thread thread = Thread\n-            .ofVirtual()\n-            .allowSetThreadLocals(false)\n-            .inheritInheritableThreadLocals(false)\n-            .name(\"ttl-test-virtual\")\n-            .unstarted(() -> ttlOps.accept(ttl));\n-        thread.start();\n-        try {\n-            thread.join();\n-        } catch (InterruptedException e) {\n-            throw new RuntimeException(e);\n-        }\n+        Thread carrier;\n@@ -148,4 +135,2 @@\n-        if (!terminatedValues.isEmpty()) {\n-            throw new AssertionError(\"Unexpected terminated values after virtual thread.join(): \" +\n-                                     terminatedValues);\n-        }\n+        \/\/ use a single worker thread pool for the cheduler\n+        try (var pool = Executors.newSingleThreadExecutor()) {\n@@ -153,5 +138,2 @@\n-        \/\/ we now unblock the blocker thread but keep it running\n-        synchronized (lock) {\n-            lock.unblock = true;\n-            lock.notify();\n-        }\n+            \/\/ capture carrier Thread\n+            carrier = pool.submit(Thread::currentThread).get();\n@@ -159,8 +141,7 @@\n-        \/\/ carrier thread pool has a 30 second keep-alive time to terminate excessive carrier\n-        \/\/ threads. Since blockerThread is still pinning one of them we hope for the other\n-        \/\/ thread to be terminated...\n-        try {\n-            TimeUnit.SECONDS.sleep(31);\n-        } catch (InterruptedException e) {\n-            throw new RuntimeException(e);\n-        }\n+            ThreadFactory factory = virtualThreadBuilder(pool)\n+                    .name(\"ttl-test-virtual-\", 0)\n+                    .allowSetThreadLocals(false)\n+                    .factory();\n+            try (var executor = Executors.newThreadPerTaskExecutor(factory)) {\n+                executor.submit(() -> ttlOps.accept(ttl)).get();\n+            }\n@@ -168,4 +149,2 @@\n-        if (!terminatedValues.equals(Arrays.asList(expectedTerminatedValues))) {\n-            throw new AssertionError(\"Expected terminated values: \" +\n-                                     Arrays.toString(expectedTerminatedValues) +\n-                                     \" but got: \" + terminatedValues);\n+            assertTrue(terminatedValues.isEmpty(),\n+                       \"Unexpected terminated values after virtual thread terminated\");\n@@ -174,2 +153,10 @@\n-        \/\/ we now terminate the blocker thread\n-        lock.unspin = true;\n+        \/\/ wait for carrier to terminate\n+        carrier.join();\n+\n+        assertEquals(terminatedValues, expectedTerminatedValues);\n+    }\n+\n+    \/**\n+     * Returns a builder to create virtual threads that use the given scheduler.\n+     *\/\n+    static Thread.Builder.OfVirtual virtualThreadBuilder(Executor scheduler) {\n@@ -177,2 +164,11 @@\n-            blockerThread.join();\n-        } catch (InterruptedException e) {\n+            Class<?> clazz = Class.forName(\"java.lang.ThreadBuilders$VirtualThreadBuilder\");\n+            Constructor<?> ctor = clazz.getDeclaredConstructor(Executor.class);\n+            ctor.setAccessible(true);\n+            return (Thread.Builder.OfVirtual) ctor.newInstance(scheduler);\n+        } catch (InvocationTargetException e) {\n+            Throwable cause = e.getCause();\n+            if (cause instanceof RuntimeException re) {\n+                throw re;\n+            }\n+            throw new RuntimeException(e);\n+        } catch (Exception e) {\n@@ -182,5 +178,0 @@\n-\n-    static class Lock {\n-        boolean unblock;\n-        volatile boolean unspin;\n-    }\n","filename":"test\/jdk\/jdk\/internal\/misc\/TerminatingThreadLocal\/TestTerminatingThreadLocal.java","additions":88,"deletions":97,"binary":false,"changes":185,"status":"modified"}]}