{"files":[{"patch":"@@ -499,1 +499,0 @@\n-jdk\/internal\/misc\/TerminatingThreadLocal\/TestTerminatingThreadLocal.java 8292051 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n@@ -29,1 +31,4 @@\n-import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -32,0 +37,4 @@\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n@@ -36,1 +45,1 @@\n- * @modules java.base\/jdk.internal.misc\n+ * @modules java.base\/java.lang:+open java.base\/jdk.internal.misc\n@@ -39,1 +48,1 @@\n- * @run main\/othervm -Djdk.virtualThreadScheduler.parallelism=1 -Djdk.virtualThreadScheduler.maxPoolSize=2 TestTerminatingThreadLocal\n+ * @run testng\/othervm TestTerminatingThreadLocal\n@@ -43,6 +52,3 @@\n-    public static void main(String[] args) {\n-        ttlTestSet(42, 112);\n-        ttlTestSet(null, 112);\n-        ttlTestSet(42, null);\n-\n-        ttlTestVirtual(666, ThreadLocal::get, 666);\n+    @SuppressWarnings(\"unchecked\")\n+    static <T> Object[] testCase(T v0, Consumer<? super TerminatingThreadLocal<T>> action, T... v1) {\n+        return new Object[] { v0, action, v1 };\n@@ -51,9 +57,28 @@\n-    static <T> void ttlTestSet(T v0, T v1) {\n-        ttlTestPlatform(v0, ttl -> {                                         }    );\n-        ttlTestPlatform(v0, ttl -> { ttl.get();                              }, v0);\n-        ttlTestPlatform(v0, ttl -> { ttl.get();   ttl.remove();              }    );\n-        ttlTestPlatform(v0, ttl -> { ttl.get();   ttl.set(v1);               }, v1);\n-        ttlTestPlatform(v0, ttl -> { ttl.set(v1);                            }, v1);\n-        ttlTestPlatform(v0, ttl -> { ttl.set(v1); ttl.remove();              }    );\n-        ttlTestPlatform(v0, ttl -> { ttl.set(v1); ttl.remove(); ttl.get();   }, v0);\n-        ttlTestPlatform(v0, ttl -> { ttl.get();   ttl.remove(); ttl.set(v1); }, v1);\n+    @DataProvider\n+    public Object[][] testCases() {\n+        Integer NULL = null;\n+        return new Object[][] {\n+            testCase(42, ttl -> {                                             }     ),\n+            testCase(42, ttl -> { ttl.get();                                  }, 42 ),\n+            testCase(42, ttl -> { ttl.get();    ttl.remove();                 }     ),\n+            testCase(42, ttl -> { ttl.get();    ttl.set(112);                 }, 112),\n+            testCase(42, ttl -> { ttl.set(112);                               }, 112),\n+            testCase(42, ttl -> { ttl.set(112); ttl.remove();                 }     ),\n+            testCase(42, ttl -> { ttl.set(112); ttl.remove(); ttl.get();      }, 42 ),\n+            testCase(42, ttl -> { ttl.get();    ttl.remove(); ttl.set(112);   }, 112),\n+\n+            testCase(NULL, ttl -> {                                           }      ),\n+            testCase(NULL, ttl -> { ttl.get();                                }, NULL),\n+            testCase(NULL, ttl -> { ttl.get();    ttl.remove();               }      ),\n+            testCase(NULL, ttl -> { ttl.get();    ttl.set(112);               }, 112 ),\n+            testCase(NULL, ttl -> { ttl.set(112);                             }, 112 ),\n+            testCase(NULL, ttl -> { ttl.set(112); ttl.remove();               }      ),\n+            testCase(NULL, ttl -> { ttl.set(112); ttl.remove(); ttl.get();    }, NULL),\n+            testCase(NULL, ttl -> { ttl.get();    ttl.remove(); ttl.set(112); }, 112 ),\n+\n+            testCase(42, ttl -> { ttl.get();     ttl.set(NULL);               }, NULL),\n+            testCase(42, ttl -> { ttl.set(NULL);                              }, NULL),\n+            testCase(42, ttl -> { ttl.set(NULL); ttl.remove();                }      ),\n+            testCase(42, ttl -> { ttl.set(NULL); ttl.remove(); ttl.get();     }, 42  ),\n+            testCase(42, ttl -> { ttl.get();     ttl.remove(); ttl.set(NULL); }, NULL),\n+        };\n@@ -62,3 +87,5 @@\n-\n-    @SafeVarargs\n-    static <T> void ttlTestPlatform(T initialValue,\n+    \/**\n+     * Test TerminatingThreadLocal with a platform thread.\n+     *\/\n+    @Test(dataProvider = \"testCases\")\n+    public <T> void ttlTestPlatform(T initialValue,\n@@ -66,1 +93,1 @@\n-                                    T... expectedTerminatedValues) {\n+                                    T[] expectedTerminatedValues) throws Exception {\n@@ -83,5 +110,1 @@\n-        try {\n-            thread.join();\n-        } catch (InterruptedException e) {\n-            throw new RuntimeException(e);\n-        }\n+        thread.join();\n@@ -89,5 +112,1 @@\n-        if (!terminatedValues.equals(Arrays.asList(expectedTerminatedValues))) {\n-            throw new AssertionError(\"Expected terminated values: \" +\n-                                     Arrays.toString(expectedTerminatedValues) +\n-                                     \" but got: \" + terminatedValues);\n-        }\n+        assertEquals(terminatedValues, Arrays.asList(expectedTerminatedValues));\n@@ -96,2 +115,7 @@\n-    @SafeVarargs\n-    static <T> void ttlTestVirtual(T initialValue,\n+    \/**\n+     * Test TerminatingThreadLocal with a virtual thread. The thread local should be\n+     * carrier thread local but accessible to the virtual thread. The threadTerminated\n+     * method should be invoked when the carrier thread terminates.\n+     *\/\n+    @Test(dataProvider = \"testCases\")\n+    public <T> void ttlTestVirtual(T initialValue,\n@@ -99,1 +123,1 @@\n-                                   T... expectedTerminatedValues) {\n+                                   T[] expectedTerminatedValues) throws Exception {\n@@ -114,33 +138,1 @@\n-        var lock = new Lock();\n-\n-        var blockerThread = Thread.startVirtualThread(() -> {\n-            \/\/ force compensation in carrier thread pool which will spin another\n-            \/\/ carrier thread so that we can later observe it being terminated...\n-            synchronized (lock) {\n-                while (!lock.unblock) {\n-                    try {\n-                        lock.wait();\n-                    } catch (InterruptedException e) {\n-                        throw new RuntimeException(e);\n-                    }\n-                }\n-            }\n-            \/\/ keep thread running in a non-blocking-fashion which keeps\n-            \/\/ it bound to carrier thread\n-            while (!lock.unspin) {\n-                Thread.onSpinWait();\n-            }\n-        });\n-\n-        Thread thread = Thread\n-            .ofVirtual()\n-            .allowSetThreadLocals(false)\n-            .inheritInheritableThreadLocals(false)\n-            .name(\"ttl-test-virtual\")\n-            .unstarted(() -> ttlOps.accept(ttl));\n-        thread.start();\n-        try {\n-            thread.join();\n-        } catch (InterruptedException e) {\n-            throw new RuntimeException(e);\n-        }\n+        var carrierRef = new AtomicReference<Thread>();\n@@ -148,4 +140,2 @@\n-        if (!terminatedValues.isEmpty()) {\n-            throw new AssertionError(\"Unexpected terminated values after virtual thread.join(): \" +\n-                                     terminatedValues);\n-        }\n+        \/\/ use a single worker thread pool for the cheduler\n+        try (var pool = Executors.newSingleThreadExecutor()) {\n@@ -153,5 +143,2 @@\n-        \/\/ we now unblock the blocker thread but keep it running\n-        synchronized (lock) {\n-            lock.unblock = true;\n-            lock.notify();\n-        }\n+            \/\/ capture carrier Thread\n+            pool.submit(() -> carrierRef.set(Thread.currentThread()));\n@@ -159,8 +146,7 @@\n-        \/\/ carrier thread pool has a 30 second keep-alive time to terminate excessive carrier\n-        \/\/ threads. Since blockerThread is still pinning one of them we hope for the other\n-        \/\/ thread to be terminated...\n-        try {\n-            TimeUnit.SECONDS.sleep(31);\n-        } catch (InterruptedException e) {\n-            throw new RuntimeException(e);\n-        }\n+            ThreadFactory factory = virtualThreadBuilder(pool)\n+                    .name(\"ttl-test-virtual-\", 0)\n+                    .allowSetThreadLocals(false)\n+                    .factory();\n+            try (var executor = Executors.newThreadPerTaskExecutor(factory)) {\n+                executor.submit(() -> ttlOps.accept(ttl)).get();\n+            }\n@@ -168,4 +154,2 @@\n-        if (!terminatedValues.equals(Arrays.asList(expectedTerminatedValues))) {\n-            throw new AssertionError(\"Expected terminated values: \" +\n-                                     Arrays.toString(expectedTerminatedValues) +\n-                                     \" but got: \" + terminatedValues);\n+            assertTrue(terminatedValues.isEmpty(),\n+                       \"Unexpected terminated values after virtual thread terminated\");\n@@ -174,2 +158,12 @@\n-        \/\/ we now terminate the blocker thread\n-        lock.unspin = true;\n+        \/\/ wait for carrier to terminate\n+        Thread carrier = carrierRef.get();\n+        carrier.join();\n+\n+        assertEquals(terminatedValues, Arrays.asList(expectedTerminatedValues));\n+    }\n+\n+    \/**\n+     * Returns a builder to create virtual threads that use the given scheduler.\n+     *\/\n+    static Thread.Builder.OfVirtual virtualThreadBuilder(Executor scheduler) {\n+        Thread.Builder.OfVirtual builder = Thread.ofVirtual();\n@@ -177,2 +171,11 @@\n-            blockerThread.join();\n-        } catch (InterruptedException e) {\n+            Class<?> clazz = Class.forName(\"java.lang.ThreadBuilders$VirtualThreadBuilder\");\n+            Constructor<?> ctor = clazz.getDeclaredConstructor(Executor.class);\n+            ctor.setAccessible(true);\n+            return (Thread.Builder.OfVirtual) ctor.newInstance(scheduler);\n+        } catch (InvocationTargetException e) {\n+            Throwable cause = e.getCause();\n+            if (cause instanceof RuntimeException re) {\n+                throw re;\n+            }\n+            throw new RuntimeException(e);\n+        } catch (Exception e) {\n@@ -182,5 +185,0 @@\n-\n-    static class Lock {\n-        boolean unblock;\n-        volatile boolean unspin;\n-    }\n","filename":"test\/jdk\/jdk\/internal\/misc\/TerminatingThreadLocal\/TestTerminatingThreadLocal.java","additions":96,"deletions":98,"binary":false,"changes":194,"status":"modified"}]}