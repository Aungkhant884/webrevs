{"files":[{"patch":"@@ -26,1 +26,2 @@\n-#include \"runtime\/semaphore.hpp\"\n+#include \"runtime\/mutex.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -30,1 +31,1 @@\n-SemaphoreLock* GCLogPrecious::_lock = NULL;\n+Mutex* GCLogPrecious::_lock = NULL;\n@@ -35,1 +36,4 @@\n-  _lock = new SemaphoreLock();\n+  _lock = new Mutex(Mutex::event, \/* The lowest lock rank I could find *\/\n+                    \"GCLogPrecious Lock\",\n+                    true,\n+                    Mutex::_safepoint_check_never);\n@@ -53,1 +57,1 @@\n-  SemaphoreLocker sl(_lock);\n+  MutexLocker locker(_lock, Mutex::_no_safepoint_check_flag);\n@@ -65,1 +69,1 @@\n-    SemaphoreLocker sl(_lock);\n+    MutexLocker locker(_lock, Mutex::_no_safepoint_check_flag);\n@@ -83,1 +87,1 @@\n-  if (!_lock->trylock()) {\n+  if (!_lock->try_lock_without_rank_check()) {\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLogPrecious.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-class SemaphoreLock;\n+class Mutex;\n@@ -60,3 +60,2 @@\n-  \/\/ Protects the buffers - Uses a SemaphoreLock instead of a Mutex because\n-  \/\/ it doesn't require a lock order (precious logging is a leaf operation)\n-  static SemaphoreLock* _lock;\n+  \/\/ Protects the buffers\n+  static Mutex* _lock;\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLogPrecious.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -62,31 +62,0 @@\n-\/\/ Small wrapper to provide semaphore version of a lock.\n-\/\/ Useful for low-level leaf locks.\n-class SemaphoreLock : public CHeapObj<mtSynchronizer> {\n-  Semaphore _semaphore;\n-\n-public:\n-  SemaphoreLock() : _semaphore(1) {}\n-\n-  void lock()     { _semaphore.wait(); }\n-  void unlock()   { _semaphore.signal(); }\n-  bool try_lock() { return _semaphore.trywait(); }\n-};\n-\n-\/\/ Convenience RAII class to lock a SemaphoreLock.\n-class SemaphoreLocker : public StackObj {\n-  SemaphoreLock* const _lock;\n-\n-public:\n-  SemaphoreLocker(SemaphoreLock* lock) : _lock(lock) {\n-    if (_lock != NULL) {\n-      _lock->lock();\n-    }\n-  }\n-\n-  ~SemaphoreLocker() {\n-    if (_lock != NULL) {\n-      _lock->unlock();\n-    }\n-  }\n-};\n-\n","filename":"src\/hotspot\/share\/runtime\/semaphore.hpp","additions":0,"deletions":31,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -106,28 +106,0 @@\n-\n-TEST(SemaphoreLock, lock_unlock) {\n-  SemaphoreLock lock;\n-  lock.lock();\n-  lock.unlock();\n-}\n-\n-TEST(SemaphoreLock, try_lock) {\n-  SemaphoreLock lock;\n-  lock.lock();\n-  ASSERT_EQ(lock.try_lock(), false);\n-  lock.unlock();\n-\n-  ASSERT_EQ(lock.try_lock(), true);\n-  lock.unlock();\n-}\n-\n-TEST(SemaphoreLocker, sanity) {\n-  SemaphoreLock lock;\n-\n-  {\n-    SemaphoreLocker sl(&lock);\n-    ASSERT_EQ(lock.try_lock(), false);\n-  }\n-\n-  ASSERT_EQ(lock.try_lock(), true);\n-  lock.unlock();\n-}\n","filename":"test\/hotspot\/gtest\/runtime\/test_semaphore.cpp","additions":0,"deletions":28,"binary":false,"changes":28,"status":"modified"}]}