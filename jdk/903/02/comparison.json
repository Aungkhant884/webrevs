{"files":[{"patch":"@@ -26,2 +26,1 @@\n-#include \"runtime\/mutex.hpp\"\n-#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/semaphore.hpp\"\n@@ -31,1 +30,1 @@\n-Mutex* GCLogPrecious::_lock = NULL;\n+SemaphoreLock* GCLogPrecious::_lock = NULL;\n@@ -36,4 +35,1 @@\n-  _lock = new Mutex(Mutex::tty,\n-                    \"GCLogPrecious Lock\",\n-                    true,\n-                    Mutex::_safepoint_check_never);\n+  _lock = new SemaphoreLock();\n@@ -57,1 +53,1 @@\n-  MutexLocker locker(_lock, Mutex::_no_safepoint_check_flag);\n+  SemaphoreLocker sl(_lock);\n@@ -69,1 +65,1 @@\n-    MutexLocker locker(_lock, Mutex::_no_safepoint_check_flag);\n+    SemaphoreLocker sl(_lock);\n@@ -80,6 +76,10 @@\n-  if (_lines != NULL) {\n-    MutexLocker locker(_lock, Mutex::_no_safepoint_check_flag);\n-    if (_lines->size() > 0) {\n-      st->print_cr(\"GC Precious Log:\");\n-      st->print_cr(\"%s\", _lines->base());\n-    }\n+  st->print_cr(\"GC Precious Log:\");\n+\n+  if (_lines == NULL) {\n+    st->print_cr(\"<Not initialized>\\n\");\n+    return;\n+  }\n+\n+  if (!_lock->trylock()) {\n+    st->print_cr(\"<Skipped>\\n\");\n+    return;\n@@ -87,0 +87,8 @@\n+\n+  if (_lines->size() == 0) {\n+    st->print_cr(\"<Empty>\\n\");\n+  } else {\n+    st->print_cr(\"%s\", _lines->base());\n+  }\n+\n+  _lock->unlock();\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLogPrecious.cpp","additions":23,"deletions":15,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-class Mutex;\n+class SemaphoreLock;\n@@ -60,2 +60,3 @@\n-  \/\/ Protects the buffers\n-  static Mutex* _lock;\n+  \/\/ Protects the buffers - Uses a SemaphoreLock instead of a Mutex because\n+  \/\/ it doesn't require a lock order (precious logging is a leaf operation)\n+  static SemaphoreLock* _lock;\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLogPrecious.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -62,0 +62,31 @@\n+\/\/ Small wrapper to provide semaphore version of a lock.\n+\/\/ Useful for low-level leaf locks.\n+class SemaphoreLock : public CHeapObj<mtSynchronizer> {\n+  Semaphore _semaphore;\n+\n+public:\n+  SemaphoreLock() : _semaphore(1) {}\n+\n+  void lock()     { _semaphore.wait(); }\n+  void unlock()   { _semaphore.signal(); }\n+  bool try_lock() { return _semaphore.trywait(); }\n+};\n+\n+\/\/ Convenience RAII class to lock a SemaphoreLock.\n+class SemaphoreLocker : public StackObj {\n+  SemaphoreLock* const _lock;\n+\n+public:\n+  SemaphoreLocker(SemaphoreLock* lock) : _lock(lock) {\n+    if (_lock != NULL) {\n+      _lock->lock();\n+    }\n+  }\n+\n+  ~SemaphoreLocker() {\n+    if (_lock != NULL) {\n+      _lock->unlock();\n+    }\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/semaphore.hpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -106,0 +106,28 @@\n+\n+TEST(SemaphoreLock, lock_unlock) {\n+  SemaphoreLock lock;\n+  lock.lock();\n+  lock.unlock();\n+}\n+\n+TEST(SemaphoreLock, try_lock) {\n+  SemaphoreLock lock;\n+  lock.lock();\n+  ASSERT_EQ(lock.try_lock(), false);\n+  lock.unlock();\n+\n+  ASSERT_EQ(lock.try_lock(), true);\n+  lock.unlock();\n+}\n+\n+TEST(SemaphoreLocker, sanity) {\n+  SemaphoreLock lock;\n+\n+  {\n+    SemaphoreLocker sl(&lock);\n+    ASSERT_EQ(lock.try_lock(), false);\n+  }\n+\n+  ASSERT_EQ(lock.try_lock(), true);\n+  lock.unlock();\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_semaphore.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"}]}