{"files":[{"patch":"@@ -30,1 +30,1 @@\n-Semaphore* GCLogPrecious::_lock = NULL;\n+SemaphoreLock* GCLogPrecious::_lock = NULL;\n@@ -35,1 +35,1 @@\n-  _lock = new Semaphore(1);\n+  _lock = new SemaphoreLock();\n@@ -53,1 +53,1 @@\n-  _lock->wait();\n+  SemaphoreLocker sl(_lock);\n@@ -55,1 +55,0 @@\n-  _lock->signal();\n@@ -66,1 +65,1 @@\n-    _lock->wait();\n+    SemaphoreLocker sl(_lock);\n@@ -69,1 +68,0 @@\n-   _lock->signal();\n@@ -78,0 +76,2 @@\n+  st->print_cr(\"GC Precious Log:\");\n+\n@@ -79,0 +79,1 @@\n+    st->print_cr(\"<Not initialized>\\n\");\n@@ -82,4 +83,3 @@\n-  if (!_lock->trywait()) {\n-      st->print_cr(\"GC Precious Log:\");\n-      st->print_cr(\" ... skipping ...\");\n-      return;\n+  if (!_lock->trylock()) {\n+    st->print_cr(\"<Skipped>\\n\");\n+    return;\n@@ -88,2 +88,3 @@\n-  if (_lines->size() > 0) {\n-    st->print_cr(\"GC Precious Log:\");\n+  if (_lines->size() == 0) {\n+    st->print_cr(\"<Empty>\\n\");\n+  } else {\n@@ -93,1 +94,1 @@\n-  _lock->signal();\n+  _lock->unlock();\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLogPrecious.cpp","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-class Semaphore;\n+class SemaphoreLock;\n@@ -61,1 +61,4 @@\n-  static Semaphore* _lock;\n+  \/\/ Note: Uses a SemaphoreLock instead of a Mutex because it:\n+  \/\/ 1) provides trylock()\n+  \/\/ 2) doesn't require a lock order (precious logging is a leaf operation)\n+  static SemaphoreLock* _lock;\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLogPrecious.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -62,0 +62,31 @@\n+\/\/ Small wrapper to provide semaphore version of a lock.\n+\/\/ Useful for low-level leaf locks.\n+class SemaphoreLock : public CHeapObj<mtSynchronizer> {\n+  Semaphore _semaphore;\n+\n+public:\n+  SemaphoreLock() : _semaphore(1) {}\n+\n+  void lock()    { _semaphore.wait(); }\n+  void unlock()  { _semaphore.signal(); }\n+  bool trylock() { return _semaphore.trywait(); }\n+};\n+\n+\/\/ Convenience RAII class to lock a SemaphoreLock.\n+class SemaphoreLocker : public StackObj {\n+  SemaphoreLock* const _lock;\n+\n+public:\n+  SemaphoreLocker(SemaphoreLock* lock) : _lock(lock) {\n+    if (_lock != NULL) {\n+      _lock->lock();\n+    }\n+  }\n+\n+  ~SemaphoreLocker() {\n+    if (_lock != NULL) {\n+      _lock->unlock();\n+    }\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/semaphore.hpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -106,0 +106,28 @@\n+\n+TEST(SemaphoreLock, lock_unlock) {\n+  SemaphoreLock lock;\n+  lock.lock();\n+  lock.unlock();\n+}\n+\n+TEST(SemaphoreLock, trylock) {\n+  SemaphoreLock lock;\n+  lock.lock();\n+  ASSERT_EQ(lock.trylock(), false);\n+  lock.unlock();\n+\n+  ASSERT_EQ(lock.trylock(), true);\n+  lock.unlock();\n+}\n+\n+TEST(SemaphoreLocker, sanity) {\n+  SemaphoreLock lock;\n+\n+  {\n+    SemaphoreLocker sl(&lock);\n+    ASSERT_EQ(lock.trylock(), false);\n+  }\n+\n+  ASSERT_EQ(lock.trylock(), true);\n+  lock.unlock();\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_semaphore.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"}]}