{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import java.nio.ByteBuffer;\n@@ -32,0 +33,1 @@\n+import sun.nio.ch.DirectBuffer;\n@@ -33,0 +35,1 @@\n+import sun.nio.ch.Util;\n@@ -247,1 +250,1 @@\n-     * @param     b the data to be written\n+     * @param     b the data to be read\n@@ -249,1 +252,3 @@\n-     * @param     len the number of bytes that are written\n+     * @param     len the number of bytes to be read\n+     * @param     address the address of the temporary direct buffer's array\n+     * @param     size the size of the temporary direct buffer's array\n@@ -252,1 +257,2 @@\n-    private native int readBytes(byte[] b, int off, int len) throws IOException;\n+    private native int readBytes0(byte[] b, int off, int len, long address,\n+                                  int size) throws IOException;\n@@ -267,1 +273,2 @@\n-        long comp = Blocker.begin();\n+        int size = RandomAccessFile.bufferSize(b.length);\n+        ByteBuffer buf = Util.getTemporaryDirectBuffer(size);\n@@ -269,1 +276,7 @@\n-            return readBytes(b, 0, b.length);\n+            long comp = Blocker.begin();\n+            try {\n+                long address = ((DirectBuffer)buf).address();\n+                return readBytes0(b, 0, b.length, address, size);\n+            } finally {\n+                Blocker.end(comp);\n+            }\n@@ -271,1 +284,1 @@\n-            Blocker.end(comp);\n+            Util.releaseTemporaryDirectBuffer(buf);\n@@ -291,1 +304,2 @@\n-        long comp = Blocker.begin();\n+        int size = RandomAccessFile.bufferSize(len);\n+        ByteBuffer buf = Util.getTemporaryDirectBuffer(size);\n@@ -293,1 +307,7 @@\n-            return readBytes(b, off, len);\n+            long comp = Blocker.begin();\n+            try {\n+                long address = ((DirectBuffer)buf).address();\n+                return readBytes0(b, off, len, address, size);\n+            } finally {\n+                Blocker.end(comp);\n+            }\n@@ -295,1 +315,1 @@\n-            Blocker.end(comp);\n+            Util.releaseTemporaryDirectBuffer(buf);\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileInputStream.java","additions":29,"deletions":9,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.nio.ByteBuffer;\n@@ -32,0 +33,1 @@\n+import sun.nio.ch.DirectBuffer;\n@@ -33,1 +35,1 @@\n-\n+import sun.nio.ch.Util;\n@@ -329,6 +331,6 @@\n-     * Writes a sub array as a sequence of bytes.\n-     * @param b the data to be written\n-     * @param off the start offset in the data\n-     * @param len the number of bytes that are written\n-     * @param append {@code true} to first advance the position to the\n-     *     end of file\n+     * Writes a subarray as a sequence of bytes.\n+     * @param     b the data to be written\n+     * @param     off the start offset in the data\n+     * @param     len the number of bytes to be written\n+     * @param     address the address of the temporary direct buffer's array\n+     * @param     size the size of the temporary direct buffer's array\n@@ -337,1 +339,2 @@\n-    private native void writeBytes(byte[] b, int off, int len, boolean append)\n+    private native void writeBytes0(byte[] b, int off, int len, boolean append,\n+                                    long address, int capacity)\n@@ -350,1 +353,2 @@\n-        long comp = Blocker.begin();\n+        int size = RandomAccessFile.bufferSize(b.length);\n+        ByteBuffer buf = Util.getTemporaryDirectBuffer(size);\n@@ -352,1 +356,7 @@\n-            writeBytes(b, 0, b.length, append);\n+            long comp = Blocker.begin();\n+            try {\n+                long address = ((DirectBuffer)buf).address();\n+                writeBytes0(b, 0, b.length, append, address, size);\n+            } finally {\n+                Blocker.end(comp);\n+            }\n@@ -354,1 +364,1 @@\n-            Blocker.end(comp);\n+            Util.releaseTemporaryDirectBuffer(buf);\n@@ -370,1 +380,2 @@\n-        long comp = Blocker.begin();\n+        int size = RandomAccessFile.bufferSize(len);\n+        ByteBuffer buf = Util.getTemporaryDirectBuffer(size);\n@@ -372,1 +383,7 @@\n-            writeBytes(b, off, len, append);\n+            long comp = Blocker.begin();\n+            try {\n+                long address = ((DirectBuffer)buf).address();\n+                writeBytes0(b, off, len, append, address, size);\n+            } finally {\n+                Blocker.end(comp);\n+            }\n@@ -374,1 +391,1 @@\n-            Blocker.end(comp);\n+            Util.releaseTemporaryDirectBuffer(buf);\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileOutputStream.java","additions":31,"deletions":14,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.nio.ByteBuffer;\n@@ -33,0 +34,1 @@\n+import sun.nio.ch.DirectBuffer;\n@@ -34,1 +36,1 @@\n-\n+import sun.nio.ch.Util;\n@@ -64,1 +66,7 @@\n-    private FileDescriptor fd;\n+    \/\/ minimum capacity of temporary direct buffers\n+    private static final int MIN_BUFFER_SIZE = 8192;\n+\n+    \/\/ maximim capacity of temporary direct buffers\n+    private static final int MAX_BUFFER_SIZE = 65536;\n+\n+    private final FileDescriptor fd;\n@@ -84,0 +92,24 @@\n+    \/**\n+     * Calculate the size of a temporary direct buffer.\n+     *\n+     * @param the number of bytes in question\n+     * @return the size of buffer to use\n+     *\/\n+    \/\/ package scope\n+    static final int bufferSize(int len) {\n+        if (len <= 0) {\n+            return 0;\n+        }\n+\n+        if (len >= MAX_BUFFER_SIZE) {\n+            return MAX_BUFFER_SIZE;\n+        }\n+\n+        if (len % MIN_BUFFER_SIZE == 0) {\n+            return len;\n+        }\n+\n+        int multiple = (len + MIN_BUFFER_SIZE - 1)\/MIN_BUFFER_SIZE;\n+        return multiple*MIN_BUFFER_SIZE;\n+    }\n+\n@@ -388,1 +420,2 @@\n-        long comp = Blocker.begin();\n+        int size = bufferSize(len);\n+        ByteBuffer buf = Util.getTemporaryDirectBuffer(size);\n@@ -390,1 +423,7 @@\n-            return readBytes0(b, off, len);\n+            long comp = Blocker.begin();\n+            try {\n+                long address = ((DirectBuffer)buf).address();\n+                return readBytes0(b, off, len, address, size);\n+            } finally {\n+                Blocker.end(comp);\n+            }\n@@ -392,1 +431,1 @@\n-            Blocker.end(comp);\n+            Util.releaseTemporaryDirectBuffer(buf);\n@@ -396,1 +435,11 @@\n-    private native int readBytes0(byte[] b, int off, int len) throws IOException;\n+    \/**\n+     * Reads a subarray as a sequence of bytes.\n+     * @param     b the data to be read\n+     * @param     off the start offset in the data\n+     * @param     len the number of bytes to be read\n+     * @param     address the address of the temporary direct buffer's array\n+     * @param     size the size of the temporary direct buffer's array\n+     * @throws    IOException If an I\/O error has occurred.\n+     *\/\n+    private native int readBytes0(byte[] b, int off, int len, long address,\n+                                  int size) throws IOException;\n@@ -560,1 +609,2 @@\n-        long comp = Blocker.begin();\n+        int size = bufferSize(len);\n+        ByteBuffer buf = Util.getTemporaryDirectBuffer(size);\n@@ -562,1 +612,7 @@\n-            writeBytes0(b, off, len);\n+            long comp = Blocker.begin();\n+            try {\n+                long address = ((DirectBuffer)buf).address();\n+                writeBytes0(b, off, len, address, size);\n+            } finally {\n+                Blocker.end(comp);\n+            }\n@@ -564,1 +620,1 @@\n-            Blocker.end(comp);\n+            Util.releaseTemporaryDirectBuffer(buf);\n@@ -568,1 +624,11 @@\n-    private native void writeBytes0(byte[] b, int off, int len) throws IOException;\n+    \/**\n+     * Writes a subarray as a sequence of bytes.\n+     * @param     b the data to be written\n+     * @param     off the start offset in the data\n+     * @param     len the number of bytes to be written\n+     * @param     address the address of the temporary direct buffer's array\n+     * @param     size the size of the temporary direct buffer's array\n+     * @throws    IOException If an I\/O error has occurred.\n+     *\/\n+    private native void writeBytes0(byte[] b, int off, int len, long address,\n+                                    int size) throws IOException;\n","filename":"src\/java.base\/share\/classes\/java\/io\/RandomAccessFile.java","additions":76,"deletions":10,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,3 +70,3 @@\n-Java_java_io_FileInputStream_readBytes(JNIEnv *env, jobject this,\n-        jbyteArray bytes, jint off, jint len) {\n-    return readBytes(env, this, bytes, off, len, fis_fd);\n+Java_java_io_FileInputStream_readBytes0(JNIEnv *env, jobject this,\n+        jbyteArray bytes, jint off, jint len, jlong address, jint size) {\n+    return readBytes(env, this, bytes, off, len, fis_fd, address, size);\n","filename":"src\/java.base\/share\/native\/libjava\/FileInputStream.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,3 +68,4 @@\n-Java_java_io_FileOutputStream_writeBytes(JNIEnv *env,\n-    jobject this, jbyteArray bytes, jint off, jint len, jboolean append) {\n-    writeBytes(env, this, bytes, off, len, append, fos_fd);\n+Java_java_io_FileOutputStream_writeBytes0(JNIEnv *env,\n+    jobject this, jbyteArray bytes, jint off, jint len, jboolean append,\n+    jlong addr, jint size) {\n+    writeBytes(env, this, bytes, off, len, append, fos_fd, addr, size);\n","filename":"src\/java.base\/share\/native\/libjava\/FileOutputStream.c","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -77,2 +77,2 @@\n-    jobject this, jbyteArray bytes, jint off, jint len) {\n-    return readBytes(env, this, bytes, off, len, raf_fd);\n+    jobject this, jbyteArray bytes, jint off, jint len, jlong addr, jint size) {\n+    return readBytes(env, this, bytes, off, len, raf_fd, addr, size);\n@@ -88,2 +88,2 @@\n-    jobject this, jbyteArray bytes, jint off, jint len) {\n-    writeBytes(env, this, bytes, off, len, JNI_FALSE, raf_fd);\n+    jobject this, jbyteArray bytes, jint off, jint len, jlong addr, jint size) {\n+    writeBytes(env, this, bytes, off, len, JNI_FALSE, raf_fd, addr, size);\n","filename":"src\/java.base\/share\/native\/libjava\/RandomAccessFile.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-    if (nread == 0) { \/* EOF *\/\n+    if (nread == 0) { \/\/ EOF\n@@ -50,1 +50,1 @@\n-    } else if (nread == -1) { \/* error *\/\n+    } else if (nread == -1) { \/\/ error\n@@ -56,3 +56,5 @@\n-\/* The maximum size of a stack-allocated buffer.\n- *\/\n-#define BUF_SIZE 8192\n+\/\/ The size of a stack-allocated buffer.\n+#define STACK_BUF_SIZE 8192\n+\n+\/\/ The maximum size of a dynamically allocated buffer.\n+#define MAX_MALLOC_SIZE 65536\n@@ -75,1 +77,1 @@\n-          jint off, jint len, jfieldID fid)\n+          jint off, jint len, jfieldID fid, jlong address, jint size)\n@@ -77,3 +79,4 @@\n-    jint nread;\n-    char stackBuf[BUF_SIZE];\n-    char *buf = NULL;\n+    char *buf = (char*)jlong_to_ptr(address);\n+    const jint buf_size = size;\n+    jint read_size;\n+    jint n, nread;\n@@ -94,8 +97,0 @@\n-    } else if (len > BUF_SIZE) {\n-        buf = malloc(len);\n-        if (buf == NULL) {\n-            JNU_ThrowOutOfMemoryError(env, NULL);\n-            return 0;\n-        }\n-    } else {\n-        buf = stackBuf;\n@@ -104,11 +99,8 @@\n-    fd = getFD(env, this, fid);\n-    if (fd == -1) {\n-        JNU_ThrowIOException(env, \"Stream Closed\");\n-        nread = -1;\n-    } else {\n-        nread = IO_Read(fd, buf, len);\n-        if (nread > 0) {\n-            (*env)->SetByteArrayRegion(env, bytes, off, nread, (jbyte *)buf);\n-        } else if (nread == -1) {\n-            JNU_ThrowIOExceptionWithLastError(env, \"Read error\");\n-        } else { \/* EOF *\/\n+    nread = 0;\n+    while (nread < len) {\n+        read_size = len - nread;\n+        if (read_size > buf_size)\n+            read_size = buf_size;\n+        fd = getFD(env, this, fid);\n+        if (fd == -1) {\n+            JNU_ThrowIOException(env, \"Stream Closed\");\n@@ -116,0 +108,17 @@\n+            break;\n+        }\n+        n = IO_Read(fd, buf, read_size);\n+        if (n > 0) {\n+            (*env)->SetByteArrayRegion(env, bytes, off, n, (jbyte*)buf);\n+            nread += n;\n+            \/\/ Exit loop on short read\n+            if (n < read_size)\n+                break;\n+            off += n;\n+        } else if (n == -1) {\n+            JNU_ThrowIOExceptionWithLastError(env, \"Read error\");\n+            break;\n+        } else { \/\/ EOF\n+            if (nread == 0)\n+                nread = -1;\n+            break;\n@@ -119,3 +128,0 @@\n-    if (buf != stackBuf) {\n-        free(buf);\n-    }\n@@ -147,1 +153,2 @@\n-           jint off, jint len, jboolean append, jfieldID fid)\n+           jint off, jint len, jboolean append, jfieldID fid,\n+           jlong address, jint size)\n@@ -149,0 +156,3 @@\n+    char *buf = (char*)jlong_to_ptr(address);\n+    const jint buf_size = size;\n+    jint write_size;\n@@ -150,2 +160,0 @@\n-    char stackBuf[BUF_SIZE];\n-    char *buf = NULL;\n@@ -166,8 +174,0 @@\n-    } else if (len > BUF_SIZE) {\n-        buf = malloc(len);\n-        if (buf == NULL) {\n-            JNU_ThrowOutOfMemoryError(env, NULL);\n-            return;\n-        }\n-    } else {\n-        buf = stackBuf;\n@@ -176,5 +176,4 @@\n-    (*env)->GetByteArrayRegion(env, bytes, off, len, (jbyte *)buf);\n-\n-    if (!(*env)->ExceptionOccurred(env)) {\n-        off = 0;\n-        while (len > 0) {\n+    while (len > 0) {\n+        write_size = len < buf_size ? len : buf_size;\n+        (*env)->GetByteArrayRegion(env, bytes, off, write_size, (jbyte*)buf);\n+        if (!(*env)->ExceptionOccurred(env)) {\n@@ -187,1 +186,1 @@\n-                n = IO_Append(fd, buf+off, len);\n+                n = IO_Append(fd, buf, write_size);\n@@ -189,1 +188,1 @@\n-                n = IO_Write(fd, buf+off, len);\n+                n = IO_Write(fd, buf, write_size);\n@@ -197,0 +196,3 @@\n+        } else { \/\/ ArrayIndexOutOfBoundsException\n+            (*env)->ExceptionClear(env);\n+            break;\n@@ -199,3 +201,0 @@\n-    if (buf != stackBuf) {\n-        free(buf);\n-    }\n","filename":"src\/java.base\/share\/native\/libjava\/io_util.c","additions":52,"deletions":53,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-               jint len, jfieldID fid);\n+               jint len, jfieldID fid, jlong address, jint size);\n@@ -55,1 +55,1 @@\n-                jint len, jboolean append, jfieldID fid);\n+                jint len, jboolean append, jfieldID fid, jlong address, jint size);\n","filename":"src\/java.base\/share\/native\/libjava\/io_util.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * @bug 8264777\n- * @summary Test read{All,N}Bytes overrides (use -Dseed=X to set PRNG seed)\n+ * @bug 6478546 8264777\n+ * @summary Test read(byte[],int,int) and read{All,N}Bytes overrides (use -Dseed=X to set PRNG seed)\n@@ -36,0 +36,1 @@\n+import java.io.FileOutputStream;\n@@ -37,1 +38,0 @@\n-import java.io.RandomAccessFile;\n@@ -44,1 +44,2 @@\n-    private static final int MAX_FILE_SIZE = 1_000_000;\n+    private static final int MAX_EXTRA_FILE_SIZE = 1_000_000;\n+    private static final int MIN_LARGE_FILE_SIZE = 2_500_000;\n@@ -76,1 +77,2 @@\n-            int size = 1 + RND.nextInt(MAX_FILE_SIZE);\n+            int baseSize = i % 2 == 0 ? 1 : MIN_LARGE_FILE_SIZE;\n+            int size = baseSize + RND.nextInt(MAX_EXTRA_FILE_SIZE);\n@@ -78,1 +80,2 @@\n-            byte[] bytes = new byte[size];\n+            int offset = RND.nextInt(size\/4);\n+            byte[] bytes = new byte[offset + size];\n@@ -80,2 +83,18 @@\n-            try (RandomAccessFile raf = new RandomAccessFile(file, \"rw\")) {\n-                raf.write(bytes);\n+            try (FileOutputStream fos = new FileOutputStream(file)) {\n+                fos.write(bytes, offset, size);\n+            }\n+\n+            try (FileInputStream fis = new FileInputStream(file)) {\n+                int pos = RND.nextInt(size);\n+                int len = RND.nextInt(size - pos);\n+                fis.getChannel().position(pos);\n+                byte[] nbytes = new byte[size];\n+                int n = fis.read(nbytes, 0, 0);\n+                if (n != 0)\n+                    throw new RuntimeException(\"read() zero length\");\n+                n = fis.read(nbytes, pos, len);\n+                if (n != len)\n+                    throw new RuntimeException(\"read() length\");\n+                if (!Arrays.equals(nbytes, pos, pos + len,\n+                                   bytes, offset + pos, offset + pos + len))\n+                    throw new RuntimeException(\"read() content\");\n@@ -94,1 +113,2 @@\n-                if (!Arrays.equals(nbytes, 0, len, bytes, pos, pos + len))\n+                if (!Arrays.equals(nbytes, 0, len,\n+                                   bytes, pos + offset, offset + pos + len))\n@@ -105,1 +125,1 @@\n-                                   bytes, pos, pos + allbytes.length))\n+                                   bytes, offset + pos, offset + pos + allbytes.length))\n","filename":"test\/jdk\/java\/io\/FileInputStream\/ReadXBytes.java","additions":31,"deletions":11,"binary":false,"changes":42,"status":"modified"}]}