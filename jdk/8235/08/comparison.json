{"files":[{"patch":"@@ -30,0 +30,1 @@\n+import java.util.Objects;\n@@ -246,4 +247,4 @@\n-     * Reads a subarray as a sequence of bytes.\n-     * @param     b the data to be written\n-     * @param     off the start offset in the data\n-     * @param     len the number of bytes that are written\n+     * Reads a sub-array as a sequence of bytes.\n+     * @param     b the buffer into which the data is read.\n+     * @param     off the start offset of the data.\n+     * @param     len the number of bytes to read.\n@@ -252,1 +253,13 @@\n-    private native int readBytes(byte[] b, int off, int len) throws IOException;\n+    private int readBytes(byte[] b, int off, int len) throws IOException {\n+        Objects.checkFromIndexSize(off, len, b.length);\n+        if (len == 0)\n+            return 0;\n+        long comp = Blocker.begin();\n+        try {\n+            return readBytes0(b, off, len);\n+        } finally {\n+            Blocker.end(comp);\n+        }\n+    }\n+\n+    private native int readBytes0(byte[] b, int off, int len) throws IOException;\n@@ -267,6 +280,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return readBytes(b, 0, b.length);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return readBytes(b, 0, b.length);\n@@ -291,6 +299,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            return readBytes(b, off, len);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        return readBytes(b, off, len);\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileInputStream.java","additions":20,"deletions":17,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.Objects;\n@@ -308,1 +309,1 @@\n-    private native void write(int b, boolean append) throws IOException;\n+    private native void write0(int b, boolean append) throws IOException;\n@@ -322,1 +323,1 @@\n-            write(b, append);\n+            write0(b, append);\n@@ -329,6 +330,7 @@\n-     * Writes a sub array as a sequence of bytes.\n-     * @param b the data to be written\n-     * @param off the start offset in the data\n-     * @param len the number of bytes that are written\n-     * @param append {@code true} to first advance the position to the\n-     *     end of file\n+     * Writes a sub-array as a sequence of bytes.\n+     *\n+     * @param     b the data to be written\n+     * @param     off the start offset in the data\n+     * @param     len the number of bytes that are written\n+     * @param     append {@code true} to first advance the position to the\n+     *            end of file\n@@ -337,1 +339,14 @@\n-    private native void writeBytes(byte[] b, int off, int len, boolean append)\n+    private void writeBytes(byte[] b, int off, int len, boolean append)\n+        throws IOException {\n+        Objects.checkFromIndexSize(off, len, b.length);\n+        if (len == 0)\n+            return;\n+        long comp = Blocker.begin();\n+        try {\n+            writeBytes0(b, off, len, append);\n+        } finally {\n+            Blocker.end(comp);\n+        }\n+    }\n+\n+    private native void writeBytes0(byte[] b, int off, int len, boolean append)\n@@ -350,6 +365,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            writeBytes(b, 0, b.length, append);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        writeBytes(b, 0, b.length, append);\n@@ -370,6 +380,1 @@\n-        long comp = Blocker.begin();\n-        try {\n-            writeBytes(b, off, len, append);\n-        } finally {\n-            Blocker.end(comp);\n-        }\n+        writeBytes(b, off, len, append);\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileOutputStream.java","additions":26,"deletions":21,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.Objects;\n@@ -381,1 +382,1 @@\n-     * Reads a sub array as a sequence of bytes.\n+     * Reads a sub-array as a sequence of bytes.\n@@ -388,0 +389,3 @@\n+        Objects.checkFromIndexSize(off, len, b.length);\n+        if (len == 0)\n+            return 0;\n@@ -552,1 +556,1 @@\n-     * Writes a sub array as a sequence of bytes.\n+     * Writes a sub-array as a sequence of bytes.\n@@ -560,0 +564,3 @@\n+        Objects.checkFromIndexSize(off, len, b.length);\n+        if (len == 0)\n+            return;\n","filename":"src\/java.base\/share\/classes\/java\/io\/RandomAccessFile.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-Java_java_io_FileInputStream_readBytes(JNIEnv *env, jobject this,\n+Java_java_io_FileInputStream_readBytes0(JNIEnv *env, jobject this,\n","filename":"src\/java.base\/share\/native\/libjava\/FileInputStream.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-Java_java_io_FileOutputStream_write(JNIEnv *env, jobject this, jint byte, jboolean append) {\n+Java_java_io_FileOutputStream_write0(JNIEnv *env, jobject this, jint byte, jboolean append) {\n@@ -68,1 +68,1 @@\n-Java_java_io_FileOutputStream_writeBytes(JNIEnv *env,\n+Java_java_io_FileOutputStream_writeBytes0(JNIEnv *env,\n","filename":"src\/java.base\/share\/native\/libjava\/FileOutputStream.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-    if (nread == 0) { \/* EOF *\/\n+    if (nread == 0) { \/\/ EOF\n@@ -50,1 +50,1 @@\n-    } else if (nread == -1) { \/* error *\/\n+    } else if (nread == -1) { \/\/ error\n@@ -56,3 +56,2 @@\n-\/* The maximum size of a stack-allocated buffer.\n- *\/\n-#define BUF_SIZE 8192\n+\/\/ The size of a stack-allocated buffer.\n+#define STACK_BUF_SIZE 8192\n@@ -60,12 +59,2 @@\n-\/*\n- * Returns true if the array slice defined by the given offset and length\n- * is out of bounds.\n- *\/\n-static int\n-outOfBounds(JNIEnv *env, jint off, jint len, jbyteArray array) {\n-    return ((off < 0) ||\n-            (len < 0) ||\n-            \/\/ We are very careful to avoid signed integer overflow,\n-            \/\/ the result of which is undefined in C.\n-            ((*env)->GetArrayLength(env, array) - off < len));\n-}\n+\/\/ The maximum size of a dynamically allocated buffer.\n+#define MAX_MALLOC_SIZE 65536\n@@ -73,0 +62,4 @@\n+\/\/\n+\/\/ The caller should ensure that bytes != NULL, len > 0, and off and len\n+\/\/ specify a valid sub-range of bytes\n+\/\/\n@@ -77,2 +70,1 @@\n-    jint nread;\n-    char stackBuf[BUF_SIZE];\n+    char stackBuf[STACK_BUF_SIZE];\n@@ -80,0 +72,2 @@\n+    jint buf_size, read_size;\n+    jint n, nread;\n@@ -82,14 +76,3 @@\n-    if (IS_NULL(bytes)) {\n-        JNU_ThrowNullPointerException(env, NULL);\n-        return -1;\n-    }\n-\n-    if (outOfBounds(env, off, len, bytes)) {\n-        JNU_ThrowByName(env, \"java\/lang\/IndexOutOfBoundsException\", NULL);\n-        return -1;\n-    }\n-\n-    if (len == 0) {\n-        return 0;\n-    } else if (len > BUF_SIZE) {\n-        buf = malloc(len);\n+    if (len > STACK_BUF_SIZE) {\n+        buf_size = len < MAX_MALLOC_SIZE ? len : MAX_MALLOC_SIZE;\n+        buf = malloc(buf_size);\n@@ -102,0 +85,1 @@\n+        buf_size = STACK_BUF_SIZE;\n@@ -104,11 +88,8 @@\n-    fd = getFD(env, this, fid);\n-    if (fd == -1) {\n-        JNU_ThrowIOException(env, \"Stream Closed\");\n-        nread = -1;\n-    } else {\n-        nread = IO_Read(fd, buf, len);\n-        if (nread > 0) {\n-            (*env)->SetByteArrayRegion(env, bytes, off, nread, (jbyte *)buf);\n-        } else if (nread == -1) {\n-            JNU_ThrowIOExceptionWithLastError(env, \"Read error\");\n-        } else { \/* EOF *\/\n+    nread = 0;\n+    while (nread < len) {\n+        read_size = len - nread;\n+        if (read_size > buf_size)\n+            read_size = buf_size;\n+        fd = getFD(env, this, fid);\n+        if (fd == -1) {\n+            JNU_ThrowIOException(env, \"Stream Closed\");\n@@ -116,0 +97,17 @@\n+            break;\n+        }\n+        n = IO_Read(fd, buf, read_size);\n+        if (n > 0) {\n+            (*env)->SetByteArrayRegion(env, bytes, off, n, (jbyte*)buf);\n+            nread += n;\n+            \/\/ Exit loop on short read\n+            if (n < read_size)\n+                break;\n+            off += n;\n+        } else if (n == -1) {\n+            JNU_ThrowIOExceptionWithLastError(env, \"Read error\");\n+            break;\n+        } else { \/\/ EOF\n+            if (nread == 0)\n+                nread = -1;\n+            break;\n@@ -145,0 +143,4 @@\n+\/\/\n+\/\/ The caller should ensure that bytes != NULL, len > 0, and off and len\n+\/\/ specify a valid sub-range of bytes\n+\/\/\n@@ -149,2 +151,1 @@\n-    jint n;\n-    char stackBuf[BUF_SIZE];\n+    char stackBuf[STACK_BUF_SIZE];\n@@ -152,0 +153,2 @@\n+    jint buf_size, write_size;\n+    jint n;\n@@ -154,14 +157,3 @@\n-    if (IS_NULL(bytes)) {\n-        JNU_ThrowNullPointerException(env, NULL);\n-        return;\n-    }\n-\n-    if (outOfBounds(env, off, len, bytes)) {\n-        JNU_ThrowByName(env, \"java\/lang\/IndexOutOfBoundsException\", NULL);\n-        return;\n-    }\n-\n-    if (len == 0) {\n-        return;\n-    } else if (len > BUF_SIZE) {\n-        buf = malloc(len);\n+    if (len > STACK_BUF_SIZE) {\n+        buf_size = len < MAX_MALLOC_SIZE ? len : MAX_MALLOC_SIZE;\n+        buf = malloc(buf_size);\n@@ -174,0 +166,1 @@\n+        buf_size = STACK_BUF_SIZE;\n@@ -176,5 +169,4 @@\n-    (*env)->GetByteArrayRegion(env, bytes, off, len, (jbyte *)buf);\n-\n-    if (!(*env)->ExceptionOccurred(env)) {\n-        off = 0;\n-        while (len > 0) {\n+    while (len > 0) {\n+        write_size = len < buf_size ? len : buf_size;\n+        (*env)->GetByteArrayRegion(env, bytes, off, write_size, (jbyte*)buf);\n+        if (!(*env)->ExceptionOccurred(env)) {\n@@ -187,1 +179,1 @@\n-                n = IO_Append(fd, buf+off, len);\n+                n = IO_Append(fd, buf, write_size);\n@@ -189,1 +181,1 @@\n-                n = IO_Write(fd, buf+off, len);\n+                n = IO_Write(fd, buf, write_size);\n@@ -197,0 +189,3 @@\n+        } else { \/\/ ArrayIndexOutOfBoundsException\n+            (*env)->ExceptionClear(env);\n+            break;\n@@ -199,0 +194,1 @@\n+\n","filename":"src\/java.base\/share\/native\/libjava\/io_util.c","additions":64,"deletions":68,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * @bug 8264777\n- * @summary Test read{All,N}Bytes overrides (use -Dseed=X to set PRNG seed)\n+ * @bug 6478546 8264777\n+ * @summary Test read(byte[],int,int) and read{All,N}Bytes overrides (use -Dseed=X to set PRNG seed)\n@@ -36,0 +36,1 @@\n+import java.io.FileOutputStream;\n@@ -37,1 +38,0 @@\n-import java.io.RandomAccessFile;\n@@ -44,1 +44,2 @@\n-    private static final int MAX_FILE_SIZE = 1_000_000;\n+    private static final int MAX_EXTRA_FILE_SIZE = 1_000_000;\n+    private static final int MIN_LARGE_FILE_SIZE = 2_500_000;\n@@ -76,1 +77,2 @@\n-            int size = 1 + RND.nextInt(MAX_FILE_SIZE);\n+            int baseSize = i % 2 == 0 ? 1 : MIN_LARGE_FILE_SIZE;\n+            int size = baseSize + RND.nextInt(MAX_EXTRA_FILE_SIZE);\n@@ -78,1 +80,2 @@\n-            byte[] bytes = new byte[size];\n+            int offset = RND.nextInt(size\/4);\n+            byte[] bytes = new byte[offset + size];\n@@ -80,2 +83,18 @@\n-            try (RandomAccessFile raf = new RandomAccessFile(file, \"rw\")) {\n-                raf.write(bytes);\n+            try (FileOutputStream fos = new FileOutputStream(file)) {\n+                fos.write(bytes, offset, size);\n+            }\n+\n+            try (FileInputStream fis = new FileInputStream(file)) {\n+                int pos = RND.nextInt(size);\n+                int len = RND.nextInt(size - pos);\n+                fis.getChannel().position(pos);\n+                byte[] nbytes = new byte[size];\n+                int n = fis.read(nbytes, 0, 0);\n+                if (n != 0)\n+                    throw new RuntimeException(\"read() zero length\");\n+                n = fis.read(nbytes, pos, len);\n+                if (n != len)\n+                    throw new RuntimeException(\"read() length\");\n+                if (!Arrays.equals(nbytes, pos, pos + len,\n+                                   bytes, offset + pos, offset + pos + len))\n+                    throw new RuntimeException(\"read() content\");\n@@ -94,1 +113,2 @@\n-                if (!Arrays.equals(nbytes, 0, len, bytes, pos, pos + len))\n+                if (!Arrays.equals(nbytes, 0, len,\n+                                   bytes, pos + offset, offset + pos + len))\n@@ -105,1 +125,1 @@\n-                                   bytes, pos, pos + allbytes.length))\n+                                   bytes, offset + pos, offset + pos + allbytes.length))\n","filename":"test\/jdk\/java\/io\/FileInputStream\/ReadXBytes.java","additions":31,"deletions":11,"binary":false,"changes":42,"status":"modified"}]}