{"files":[{"patch":"@@ -28,1 +28,0 @@\n-import java.nio.ByteBuffer;\n@@ -31,0 +30,1 @@\n+import java.util.Objects;\n@@ -33,1 +33,0 @@\n-import sun.nio.ch.DirectBuffer;\n@@ -35,1 +34,0 @@\n-import sun.nio.ch.Util;\n@@ -249,11 +247,4 @@\n-     * Reads a subarray as a sequence of bytes via a temporary direct\n-     * buffer.\n-     *\n-     * @param     b the data to be read\n-     * @param     off the start offset in the data\n-     * @param     len the number of bytes to be read\n-     * @param     bufAddr the address of the temporary direct buffer's array\n-     * @param     bufSize the size of the temporary direct buffer's array\n-     * @return    the total number of bytes read into the buffer, or -1\n-     *            if there is no more data because the end of the stream\n-     *            has been reached.\n+     * Reads a sub-array as a sequence of bytes.\n+     * @param     b the buffer into which the data is read.\n+     * @param     off the start offset of the data.\n+     * @param     len the number of bytes to read.\n@@ -262,2 +253,13 @@\n-    private native int readBytes0(byte[] b, int off, int len, long bufAddr,\n-                                  int bufSize) throws IOException;\n+    private int readBytes(byte[] b, int off, int len) throws IOException {\n+        Objects.checkFromIndexSize(off, len, b.length);\n+        if (len == 0)\n+            return 0;\n+        long comp = Blocker.begin();\n+        try {\n+            return readBytes0(b, off, len);\n+        } finally {\n+            Blocker.end(comp);\n+        }\n+    }\n+\n+    private native int readBytes0(byte[] b, int off, int len) throws IOException;\n@@ -278,13 +280,1 @@\n-        int bufSize = RandomAccessFile.bufferSize(b.length);\n-        ByteBuffer buf = Util.getTemporaryDirectBuffer(bufSize);\n-        try {\n-            long comp = Blocker.begin();\n-            try {\n-                long bufAddr = ((DirectBuffer)buf).address();\n-                return readBytes0(b, 0, b.length, bufAddr, bufSize);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n-        } finally {\n-            Util.releaseTemporaryDirectBuffer(buf);\n-        }\n+        return readBytes(b, 0, b.length);\n@@ -309,13 +299,1 @@\n-        int size = RandomAccessFile.bufferSize(len);\n-        ByteBuffer buf = Util.getTemporaryDirectBuffer(size);\n-        try {\n-            long comp = Blocker.begin();\n-            try {\n-                long address = ((DirectBuffer)buf).address();\n-                return readBytes0(b, off, len, address, size);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n-        } finally {\n-            Util.releaseTemporaryDirectBuffer(buf);\n-        }\n+        return readBytes(b, off, len);\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileInputStream.java","additions":20,"deletions":42,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.nio.ByteBuffer;\n@@ -30,0 +29,1 @@\n+import java.util.Objects;\n@@ -33,1 +33,0 @@\n-import sun.nio.ch.DirectBuffer;\n@@ -35,1 +34,1 @@\n-import sun.nio.ch.Util;\n+\n@@ -310,1 +309,1 @@\n-    private native void write(int b, boolean append) throws IOException;\n+    private native void write0(int b, boolean append) throws IOException;\n@@ -324,1 +323,1 @@\n-            write(b, append);\n+            write0(b, append);\n@@ -331,1 +330,1 @@\n-     * Writes a subarray as a sequence of bytes via a temporary direct buffer.\n+     * Writes a sub-array as a sequence of bytes.\n@@ -335,3 +334,3 @@\n-     * @param     len the number of bytes to be written\n-     * @param     bufAddr the address of the temporary direct buffer's array\n-     * @param     bufSize the size of the temporary direct buffer's array\n+     * @param     len the number of bytes that are written\n+     * @param     append {@code true} to first advance the position to the\n+     *            end of file\n@@ -340,2 +339,14 @@\n-    private native void writeBytes0(byte[] b, int off, int len, boolean append,\n-                                    long bufAddr, int bufSize)\n+    private void writeBytes(byte[] b, int off, int len, boolean append)\n+        throws IOException {\n+        Objects.checkFromIndexSize(off, len, b.length);\n+        if (len == 0)\n+            return;\n+        long comp = Blocker.begin();\n+        try {\n+            writeBytes0(b, off, len, append);\n+        } finally {\n+            Blocker.end(comp);\n+        }\n+    }\n+\n+    private native void writeBytes0(byte[] b, int off, int len, boolean append)\n@@ -354,13 +365,1 @@\n-        int bufSize = RandomAccessFile.bufferSize(b.length);\n-        ByteBuffer buf = Util.getTemporaryDirectBuffer(bufSize);\n-        try {\n-            long comp = Blocker.begin();\n-            try {\n-                long bufAddr = ((DirectBuffer)buf).address();\n-                writeBytes0(b, 0, b.length, append, bufAddr, bufSize);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n-        } finally {\n-            Util.releaseTemporaryDirectBuffer(buf);\n-        }\n+        writeBytes(b, 0, b.length, append);\n@@ -381,13 +380,1 @@\n-        int size = RandomAccessFile.bufferSize(len);\n-        ByteBuffer buf = Util.getTemporaryDirectBuffer(size);\n-        try {\n-            long comp = Blocker.begin();\n-            try {\n-                long address = ((DirectBuffer)buf).address();\n-                writeBytes0(b, off, len, append, address, size);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n-        } finally {\n-            Util.releaseTemporaryDirectBuffer(buf);\n-        }\n+        writeBytes(b, off, len, append);\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileOutputStream.java","additions":24,"deletions":37,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.nio.ByteBuffer;\n@@ -30,0 +29,1 @@\n+import java.util.Objects;\n@@ -34,1 +34,0 @@\n-import sun.nio.ch.DirectBuffer;\n@@ -36,1 +35,1 @@\n-import sun.nio.ch.Util;\n+\n@@ -66,7 +65,1 @@\n-    \/\/ minimum capacity of temporary direct buffers\n-    private static final int MIN_BUFFER_SIZE = 8192;\n-\n-    \/\/ maximim capacity of temporary direct buffers\n-    private static final int MAX_BUFFER_SIZE = 65536;\n-\n-    private final FileDescriptor fd;\n+    private FileDescriptor fd;\n@@ -92,25 +85,0 @@\n-    \/**\n-     * Calculate the size of a temporary direct buffer.\n-     *\n-     * @param the number of bytes in question\n-     * @return the size of buffer to use\n-     *\/\n-    \/\/ package scope\n-    static final int bufferSize(int len) {\n-        if (len <= 0) {\n-            return 0;\n-        }\n-\n-        if (len >= MAX_BUFFER_SIZE) {\n-            return MAX_BUFFER_SIZE;\n-        }\n-\n-        if (len % MIN_BUFFER_SIZE == 0) {\n-            return len;\n-        }\n-\n-        \/\/ len is positive and not a multiple of MIN_BUFFER_SIZE; return\n-        \/\/ the smallest multiple of MIN_BUFFER_SIZE greater than len.\n-        return (1 + len\/MIN_BUFFER_SIZE)*MIN_BUFFER_SIZE;\n-    }\n-\n@@ -414,1 +382,1 @@\n-     * Reads a sub array as a sequence of bytes.\n+     * Reads a sub-array as a sequence of bytes.\n@@ -421,2 +389,4 @@\n-        int bufSize = bufferSize(len);\n-        ByteBuffer buf = Util.getTemporaryDirectBuffer(bufSize);\n+        Objects.checkFromIndexSize(off, len, b.length);\n+        if (len == 0)\n+            return 0;\n+        long comp = Blocker.begin();\n@@ -424,7 +394,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                long bufAddr = ((DirectBuffer)buf).address();\n-                return readBytes0(b, off, len, bufAddr, bufSize);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            return readBytes0(b, off, len);\n@@ -432,1 +396,1 @@\n-            Util.releaseTemporaryDirectBuffer(buf);\n+            Blocker.end(comp);\n@@ -436,16 +400,1 @@\n-    \/**\n-     * Reads a subarray as a sequence of bytes via a temporary direct\n-     * buffer.\n-     *\n-     * @param     b the data to be read\n-     * @param     off the start offset in the data\n-     * @param     len the number of bytes to be read\n-     * @param     bufAddr the address of the temporary direct buffer's array\n-     * @param     bufSize the size of the temporary direct buffer's array\n-     * @return    the total number of bytes read into the buffer, or -1\n-     *            if there is no more data because the end of the stream\n-     *            has been reached.\n-     * @throws    IOException If an I\/O error has occurred.\n-     *\/\n-    private native int readBytes0(byte[] b, int off, int len, long bufAddr,\n-                                  int bufSize) throws IOException;\n+    private native int readBytes0(byte[] b, int off, int len) throws IOException;\n@@ -607,1 +556,1 @@\n-     * Writes a sub array as a sequence of bytes.\n+     * Writes a sub-array as a sequence of bytes.\n@@ -615,2 +564,4 @@\n-        int bufSize = bufferSize(len);\n-        ByteBuffer buf = Util.getTemporaryDirectBuffer(bufSize);\n+        Objects.checkFromIndexSize(off, len, b.length);\n+        if (len == 0)\n+            return;\n+        long comp = Blocker.begin();\n@@ -618,7 +569,1 @@\n-            long comp = Blocker.begin();\n-            try {\n-                long bufAddr = ((DirectBuffer)buf).address();\n-                writeBytes0(b, off, len, bufAddr, bufSize);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n+            writeBytes0(b, off, len);\n@@ -626,1 +571,1 @@\n-            Util.releaseTemporaryDirectBuffer(buf);\n+            Blocker.end(comp);\n@@ -630,13 +575,1 @@\n-    \/**\n-     * Writes a subarray as a sequence of bytes via a temporary direct buffer.\n-     *\n-     * @param     b the data to be written\n-     * @param     off the start offset in the data\n-     * @param     len the number of bytes to be written\n-     * @param     bufAddr the address of the temporary direct buffer's array\n-     * @param     bufSize the size of the temporary direct buffer's array\n-     * @throws    IOException If an I\/O error has occurred.\n-     *\/\n-    private native void writeBytes0(byte[] b, int off, int len,\n-                                    long bufAddr, int bufSize)\n-        throws IOException;\n+    private native void writeBytes0(byte[] b, int off, int len) throws IOException;\n","filename":"src\/java.base\/share\/classes\/java\/io\/RandomAccessFile.java","additions":19,"deletions":86,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,2 +71,2 @@\n-        jbyteArray bytes, jint off, jint len, jlong bufAddr, jint bufSize) {\n-    return readBytes(env, this, bytes, off, len, bufAddr, bufSize, fis_fd);\n+        jbyteArray bytes, jint off, jint len) {\n+    return readBytes(env, this, bytes, off, len, fis_fd);\n","filename":"src\/java.base\/share\/native\/libjava\/FileInputStream.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n-Java_java_io_FileOutputStream_write(JNIEnv *env, jobject this, jint byte, jboolean append) {\n+Java_java_io_FileOutputStream_write0(JNIEnv *env, jobject this, jint byte, jboolean append) {\n@@ -69,3 +69,2 @@\n-    jobject this, jbyteArray bytes, jint off, jint len, jboolean append,\n-    jlong bufAddr, jint bufSize) {\n-    writeBytes(env, this, bytes, off, len, append, bufAddr, bufSize, fos_fd);\n+    jobject this, jbyteArray bytes, jint off, jint len, jboolean append) {\n+    writeBytes(env, this, bytes, off, len, append, fos_fd);\n","filename":"src\/java.base\/share\/native\/libjava\/FileOutputStream.c","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -77,3 +77,2 @@\n-    jobject this, jbyteArray bytes, jint off, jint len,\n-    jlong bufAddr, jint bufSize) {\n-    return readBytes(env, this, bytes, off, len, bufAddr, bufSize, raf_fd);\n+    jobject this, jbyteArray bytes, jint off, jint len) {\n+    return readBytes(env, this, bytes, off, len, raf_fd);\n@@ -89,3 +88,2 @@\n-    jobject this, jbyteArray bytes, jint off, jint len,\n-    jlong bufAddr, jint bufSize) {\n-    writeBytes(env, this, bytes, off, len, JNI_FALSE, bufAddr, bufSize, raf_fd);\n+    jobject this, jbyteArray bytes, jint off, jint len) {\n+    writeBytes(env, this, bytes, off, len, JNI_FALSE, raf_fd);\n","filename":"src\/java.base\/share\/native\/libjava\/RandomAccessFile.c","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -56,12 +56,2 @@\n-\/*\n- * Returns true if the array slice defined by the given offset and length\n- * is out of bounds.\n- *\/\n-static int\n-outOfBounds(JNIEnv *env, jint off, jint len, jbyteArray array) {\n-    return ((off < 0) ||\n-            (len < 0) ||\n-            \/\/ We are very careful to avoid signed integer overflow,\n-            \/\/ the result of which is undefined in C.\n-            ((*env)->GetArrayLength(env, array) - off < len));\n-}\n+\/\/ The size of a stack-allocated buffer.\n+#define STACK_BUF_SIZE 8192\n@@ -69,0 +59,7 @@\n+\/\/ The maximum size of a dynamically allocated buffer.\n+#define MAX_MALLOC_SIZE 65536\n+\n+\/\/\n+\/\/ The caller should ensure that bytes != NULL, len > 0, and off and len\n+\/\/ specify a valid sub-range of bytes\n+\/\/\n@@ -71,1 +68,1 @@\n-          jint off, jint len, jlong bufAddr, jint bufSize, jfieldID fid)\n+          jint off, jint len, jfieldID fid)\n@@ -73,4 +70,4 @@\n-    jint remaining;\n-    void* buf = (void*)jlong_to_ptr(bufAddr);\n-    jint readSize;\n-    jint n;\n+    char stackBuf[STACK_BUF_SIZE];\n+    char *buf = NULL;\n+    jint buf_size, read_size;\n+    jint n, nread;\n@@ -79,24 +76,24 @@\n-    if (IS_NULL(bytes)) {\n-        JNU_ThrowNullPointerException(env, NULL);\n-        return -1;\n-    }\n-\n-    if (outOfBounds(env, off, len, bytes)) {\n-        JNU_ThrowByName(env, \"java\/lang\/IndexOutOfBoundsException\", NULL);\n-        return -1;\n-    }\n-\n-    if (len == 0) {\n-        return 0;\n-    }\n-\n-    fd = getFD(env, this, fid);\n-    if (fd == -1) {\n-        JNU_ThrowIOException(env, \"Stream Closed\");\n-        return -1;\n-    }\n-\n-    remaining = len;\n-    while (remaining > 0) {\n-        readSize = remaining < bufSize ? remaining : bufSize;\n-        n = IO_Read(fd, buf, readSize);\n+    if (len > STACK_BUF_SIZE) {\n+        buf_size = len < MAX_MALLOC_SIZE ? len : MAX_MALLOC_SIZE;\n+        buf = malloc(buf_size);\n+        if (buf == NULL) {\n+            JNU_ThrowOutOfMemoryError(env, NULL);\n+            return 0;\n+        }\n+    } else {\n+        buf = stackBuf;\n+        buf_size = STACK_BUF_SIZE;\n+    }\n+\n+    nread = 0;\n+    while (nread < len) {\n+        read_size = len - nread;\n+        if (read_size > buf_size)\n+            read_size = buf_size;\n+        fd = getFD(env, this, fid);\n+        if (fd == -1) {\n+            JNU_ThrowIOException(env, \"Stream Closed\");\n+            nread = -1;\n+            break;\n+        }\n+        n = IO_Read(fd, buf, read_size);\n@@ -105,1 +102,1 @@\n-            remaining -= n;\n+            nread += n;\n@@ -107,1 +104,1 @@\n-            if (n < readSize)\n+            if (n < read_size)\n@@ -110,4 +107,1 @@\n-        } else if (n == 0) { \/\/ EOF\n-            if (remaining == len)\n-                return -1;\n-        } else {\n+        } else if (n == -1) {\n@@ -115,1 +109,5 @@\n-            return -1;\n+            break;\n+        } else { \/\/ EOF\n+            if (nread == 0)\n+                nread = -1;\n+            break;\n@@ -119,1 +117,4 @@\n-    return len - remaining;\n+    if (buf != stackBuf) {\n+        free(buf);\n+    }\n+    return nread;\n@@ -142,0 +143,4 @@\n+\/\/\n+\/\/ The caller should ensure that bytes != NULL, len > 0, and off and len\n+\/\/ specify a valid sub-range of bytes\n+\/\/\n@@ -144,2 +149,1 @@\n-           jint off, jint len, jboolean append,\n-           jlong bufAddr, jint bufSize, jfieldID fid)\n+           jint off, jint len, jboolean append, jfieldID fid)\n@@ -147,3 +151,3 @@\n-    jint remaining;\n-    void* buf = (void*)jlong_to_ptr(bufAddr);\n-    jint writeSize;\n+    char stackBuf[STACK_BUF_SIZE];\n+    char *buf = NULL;\n+    jint buf_size, write_size;\n@@ -153,18 +157,10 @@\n-    if (IS_NULL(bytes)) {\n-        JNU_ThrowNullPointerException(env, NULL);\n-        return;\n-    }\n-\n-    if (outOfBounds(env, off, len, bytes)) {\n-        JNU_ThrowByName(env, \"java\/lang\/IndexOutOfBoundsException\", NULL);\n-        return;\n-    }\n-\n-    if (len == 0) {\n-        return;\n-    }\n-\n-    fd = getFD(env, this, fid);\n-    if (fd == -1) {\n-        JNU_ThrowIOException(env, \"Stream Closed\");\n-        return;\n+    if (len > STACK_BUF_SIZE) {\n+        buf_size = len < MAX_MALLOC_SIZE ? len : MAX_MALLOC_SIZE;\n+        buf = malloc(buf_size);\n+        if (buf == NULL) {\n+            JNU_ThrowOutOfMemoryError(env, NULL);\n+            return;\n+        }\n+    } else {\n+        buf = stackBuf;\n+        buf_size = STACK_BUF_SIZE;\n@@ -173,4 +169,3 @@\n-    remaining = len;\n-    while (remaining > 0) {\n-        writeSize = remaining < bufSize ? remaining : bufSize;\n-        (*env)->GetByteArrayRegion(env, bytes, off, writeSize, (jbyte*)buf);\n+    while (len > 0) {\n+        write_size = len < buf_size ? len : buf_size;\n+        (*env)->GetByteArrayRegion(env, bytes, off, write_size, (jbyte*)buf);\n@@ -178,0 +173,5 @@\n+            fd = getFD(env, this, fid);\n+            if (fd == -1) {\n+                JNU_ThrowIOException(env, \"Stream Closed\");\n+                break;\n+            }\n@@ -179,1 +179,1 @@\n-                n = IO_Append(fd, buf, writeSize);\n+                n = IO_Append(fd, buf, write_size);\n@@ -181,1 +181,1 @@\n-                n = IO_Write(fd, buf, writeSize);\n+                n = IO_Write(fd, buf, write_size);\n@@ -188,1 +188,1 @@\n-            remaining -= n;\n+            len -= n;\n@@ -194,0 +194,4 @@\n+\n+    if (buf != stackBuf) {\n+        free(buf);\n+    }\n","filename":"src\/java.base\/share\/native\/libjava\/io_util.c","additions":83,"deletions":79,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-               jint len, jlong bufAddr, jint bufSize, jfieldID fid);\n+               jint len, jfieldID fid);\n@@ -55,1 +55,1 @@\n-                jint len, jboolean append, jlong bufAddr, jint bufSize, jfieldID fid);\n+                jint len, jboolean append, jfieldID fid);\n","filename":"src\/java.base\/share\/native\/libjava\/io_util.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}