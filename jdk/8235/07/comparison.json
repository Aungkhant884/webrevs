{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import java.nio.ByteBuffer;\n@@ -32,0 +33,1 @@\n+import sun.nio.ch.DirectBuffer;\n@@ -33,0 +35,1 @@\n+import sun.nio.ch.Util;\n@@ -246,2 +249,4 @@\n-     * Reads a subarray as a sequence of bytes.\n-     * @param     b the data to be written\n+     * Reads a subarray as a sequence of bytes via a temporary direct\n+     * buffer.\n+     *\n+     * @param     b the data to be read\n@@ -249,1 +254,6 @@\n-     * @param     len the number of bytes that are written\n+     * @param     len the number of bytes to be read\n+     * @param     bufAddr the address of the temporary direct buffer's array\n+     * @param     bufSize the size of the temporary direct buffer's array\n+     * @return    the total number of bytes read into the buffer, or -1\n+     *            if there is no more data because the end of the stream\n+     *            has been reached.\n@@ -252,1 +262,2 @@\n-    private native int readBytes(byte[] b, int off, int len) throws IOException;\n+    private native int readBytes0(byte[] b, int off, int len, long bufAddr,\n+                                  int bufSize) throws IOException;\n@@ -267,1 +278,2 @@\n-        long comp = Blocker.begin();\n+        int bufSize = RandomAccessFile.bufferSize(b.length);\n+        ByteBuffer buf = Util.getTemporaryDirectBuffer(bufSize);\n@@ -269,1 +281,7 @@\n-            return readBytes(b, 0, b.length);\n+            long comp = Blocker.begin();\n+            try {\n+                long bufAddr = ((DirectBuffer)buf).address();\n+                return readBytes0(b, 0, b.length, bufAddr, bufSize);\n+            } finally {\n+                Blocker.end(comp);\n+            }\n@@ -271,1 +289,1 @@\n-            Blocker.end(comp);\n+            Util.releaseTemporaryDirectBuffer(buf);\n@@ -291,1 +309,2 @@\n-        long comp = Blocker.begin();\n+        int size = RandomAccessFile.bufferSize(len);\n+        ByteBuffer buf = Util.getTemporaryDirectBuffer(size);\n@@ -293,1 +312,7 @@\n-            return readBytes(b, off, len);\n+            long comp = Blocker.begin();\n+            try {\n+                long address = ((DirectBuffer)buf).address();\n+                return readBytes0(b, off, len, address, size);\n+            } finally {\n+                Blocker.end(comp);\n+            }\n@@ -295,1 +320,1 @@\n-            Blocker.end(comp);\n+            Util.releaseTemporaryDirectBuffer(buf);\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileInputStream.java","additions":35,"deletions":10,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.nio.ByteBuffer;\n@@ -32,0 +33,1 @@\n+import sun.nio.ch.DirectBuffer;\n@@ -33,1 +35,1 @@\n-\n+import sun.nio.ch.Util;\n@@ -329,6 +331,7 @@\n-     * Writes a sub array as a sequence of bytes.\n-     * @param b the data to be written\n-     * @param off the start offset in the data\n-     * @param len the number of bytes that are written\n-     * @param append {@code true} to first advance the position to the\n-     *     end of file\n+     * Writes a subarray as a sequence of bytes via a temporary direct buffer.\n+     *\n+     * @param     b the data to be written\n+     * @param     off the start offset in the data\n+     * @param     len the number of bytes to be written\n+     * @param     bufAddr the address of the temporary direct buffer's array\n+     * @param     bufSize the size of the temporary direct buffer's array\n@@ -337,1 +340,2 @@\n-    private native void writeBytes(byte[] b, int off, int len, boolean append)\n+    private native void writeBytes0(byte[] b, int off, int len, boolean append,\n+                                    long bufAddr, int bufSize)\n@@ -350,1 +354,2 @@\n-        long comp = Blocker.begin();\n+        int bufSize = RandomAccessFile.bufferSize(b.length);\n+        ByteBuffer buf = Util.getTemporaryDirectBuffer(bufSize);\n@@ -352,1 +357,7 @@\n-            writeBytes(b, 0, b.length, append);\n+            long comp = Blocker.begin();\n+            try {\n+                long bufAddr = ((DirectBuffer)buf).address();\n+                writeBytes0(b, 0, b.length, append, bufAddr, bufSize);\n+            } finally {\n+                Blocker.end(comp);\n+            }\n@@ -354,1 +365,1 @@\n-            Blocker.end(comp);\n+            Util.releaseTemporaryDirectBuffer(buf);\n@@ -370,1 +381,2 @@\n-        long comp = Blocker.begin();\n+        int size = RandomAccessFile.bufferSize(len);\n+        ByteBuffer buf = Util.getTemporaryDirectBuffer(size);\n@@ -372,1 +384,7 @@\n-            writeBytes(b, off, len, append);\n+            long comp = Blocker.begin();\n+            try {\n+                long address = ((DirectBuffer)buf).address();\n+                writeBytes0(b, off, len, append, address, size);\n+            } finally {\n+                Blocker.end(comp);\n+            }\n@@ -374,1 +392,1 @@\n-            Blocker.end(comp);\n+            Util.releaseTemporaryDirectBuffer(buf);\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileOutputStream.java","additions":32,"deletions":14,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.nio.ByteBuffer;\n@@ -33,0 +34,1 @@\n+import sun.nio.ch.DirectBuffer;\n@@ -34,1 +36,1 @@\n-\n+import sun.nio.ch.Util;\n@@ -64,1 +66,7 @@\n-    private FileDescriptor fd;\n+    \/\/ minimum capacity of temporary direct buffers\n+    private static final int MIN_BUFFER_SIZE = 8192;\n+\n+    \/\/ maximim capacity of temporary direct buffers\n+    private static final int MAX_BUFFER_SIZE = 65536;\n+\n+    private final FileDescriptor fd;\n@@ -84,0 +92,25 @@\n+    \/**\n+     * Calculate the size of a temporary direct buffer.\n+     *\n+     * @param the number of bytes in question\n+     * @return the size of buffer to use\n+     *\/\n+    \/\/ package scope\n+    static final int bufferSize(int len) {\n+        if (len <= 0) {\n+            return 0;\n+        }\n+\n+        if (len >= MAX_BUFFER_SIZE) {\n+            return MAX_BUFFER_SIZE;\n+        }\n+\n+        if (len % MIN_BUFFER_SIZE == 0) {\n+            return len;\n+        }\n+\n+        \/\/ len is positive and not a multiple of MIN_BUFFER_SIZE; return\n+        \/\/ the smallest multiple of MIN_BUFFER_SIZE greater than len.\n+        return (1 + len\/MIN_BUFFER_SIZE)*MIN_BUFFER_SIZE;\n+    }\n+\n@@ -388,1 +421,2 @@\n-        long comp = Blocker.begin();\n+        int bufSize = bufferSize(len);\n+        ByteBuffer buf = Util.getTemporaryDirectBuffer(bufSize);\n@@ -390,1 +424,7 @@\n-            return readBytes0(b, off, len);\n+            long comp = Blocker.begin();\n+            try {\n+                long bufAddr = ((DirectBuffer)buf).address();\n+                return readBytes0(b, off, len, bufAddr, bufSize);\n+            } finally {\n+                Blocker.end(comp);\n+            }\n@@ -392,1 +432,1 @@\n-            Blocker.end(comp);\n+            Util.releaseTemporaryDirectBuffer(buf);\n@@ -396,1 +436,16 @@\n-    private native int readBytes0(byte[] b, int off, int len) throws IOException;\n+    \/**\n+     * Reads a subarray as a sequence of bytes via a temporary direct\n+     * buffer.\n+     *\n+     * @param     b the data to be read\n+     * @param     off the start offset in the data\n+     * @param     len the number of bytes to be read\n+     * @param     bufAddr the address of the temporary direct buffer's array\n+     * @param     bufSize the size of the temporary direct buffer's array\n+     * @return    the total number of bytes read into the buffer, or -1\n+     *            if there is no more data because the end of the stream\n+     *            has been reached.\n+     * @throws    IOException If an I\/O error has occurred.\n+     *\/\n+    private native int readBytes0(byte[] b, int off, int len, long bufAddr,\n+                                  int bufSize) throws IOException;\n@@ -560,1 +615,2 @@\n-        long comp = Blocker.begin();\n+        int bufSize = bufferSize(len);\n+        ByteBuffer buf = Util.getTemporaryDirectBuffer(bufSize);\n@@ -562,1 +618,7 @@\n-            writeBytes0(b, off, len);\n+            long comp = Blocker.begin();\n+            try {\n+                long bufAddr = ((DirectBuffer)buf).address();\n+                writeBytes0(b, off, len, bufAddr, bufSize);\n+            } finally {\n+                Blocker.end(comp);\n+            }\n@@ -564,1 +626,1 @@\n-            Blocker.end(comp);\n+            Util.releaseTemporaryDirectBuffer(buf);\n@@ -568,1 +630,13 @@\n-    private native void writeBytes0(byte[] b, int off, int len) throws IOException;\n+    \/**\n+     * Writes a subarray as a sequence of bytes via a temporary direct buffer.\n+     *\n+     * @param     b the data to be written\n+     * @param     off the start offset in the data\n+     * @param     len the number of bytes to be written\n+     * @param     bufAddr the address of the temporary direct buffer's array\n+     * @param     bufSize the size of the temporary direct buffer's array\n+     * @throws    IOException If an I\/O error has occurred.\n+     *\/\n+    private native void writeBytes0(byte[] b, int off, int len,\n+                                    long bufAddr, int bufSize)\n+        throws IOException;\n","filename":"src\/java.base\/share\/classes\/java\/io\/RandomAccessFile.java","additions":84,"deletions":10,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,3 +70,3 @@\n-Java_java_io_FileInputStream_readBytes(JNIEnv *env, jobject this,\n-        jbyteArray bytes, jint off, jint len) {\n-    return readBytes(env, this, bytes, off, len, fis_fd);\n+Java_java_io_FileInputStream_readBytes0(JNIEnv *env, jobject this,\n+        jbyteArray bytes, jint off, jint len, jlong bufAddr, jint bufSize) {\n+    return readBytes(env, this, bytes, off, len, bufAddr, bufSize, fis_fd);\n","filename":"src\/java.base\/share\/native\/libjava\/FileInputStream.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,3 +68,4 @@\n-Java_java_io_FileOutputStream_writeBytes(JNIEnv *env,\n-    jobject this, jbyteArray bytes, jint off, jint len, jboolean append) {\n-    writeBytes(env, this, bytes, off, len, append, fos_fd);\n+Java_java_io_FileOutputStream_writeBytes0(JNIEnv *env,\n+    jobject this, jbyteArray bytes, jint off, jint len, jboolean append,\n+    jlong bufAddr, jint bufSize) {\n+    writeBytes(env, this, bytes, off, len, append, bufAddr, bufSize, fos_fd);\n","filename":"src\/java.base\/share\/native\/libjava\/FileOutputStream.c","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -77,2 +77,3 @@\n-    jobject this, jbyteArray bytes, jint off, jint len) {\n-    return readBytes(env, this, bytes, off, len, raf_fd);\n+    jobject this, jbyteArray bytes, jint off, jint len,\n+    jlong bufAddr, jint bufSize) {\n+    return readBytes(env, this, bytes, off, len, bufAddr, bufSize, raf_fd);\n@@ -88,2 +89,3 @@\n-    jobject this, jbyteArray bytes, jint off, jint len) {\n-    writeBytes(env, this, bytes, off, len, JNI_FALSE, raf_fd);\n+    jobject this, jbyteArray bytes, jint off, jint len,\n+    jlong bufAddr, jint bufSize) {\n+    writeBytes(env, this, bytes, off, len, JNI_FALSE, bufAddr, bufSize, raf_fd);\n","filename":"src\/java.base\/share\/native\/libjava\/RandomAccessFile.c","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-    if (nread == 0) { \/* EOF *\/\n+    if (nread == 0) { \/\/ EOF\n@@ -50,1 +50,1 @@\n-    } else if (nread == -1) { \/* error *\/\n+    } else if (nread == -1) { \/\/ error\n@@ -56,4 +56,0 @@\n-\/* The maximum size of a stack-allocated buffer.\n- *\/\n-#define BUF_SIZE 8192\n-\n@@ -75,1 +71,1 @@\n-          jint off, jint len, jfieldID fid)\n+          jint off, jint len, jlong bufAddr, jint bufSize, jfieldID fid)\n@@ -77,3 +73,4 @@\n-    jint nread;\n-    char stackBuf[BUF_SIZE];\n-    char *buf = NULL;\n+    jint remaining;\n+    void* buf = (void*)jlong_to_ptr(bufAddr);\n+    jint readSize;\n+    jint n;\n@@ -94,8 +91,0 @@\n-    } else if (len > BUF_SIZE) {\n-        buf = malloc(len);\n-        if (buf == NULL) {\n-            JNU_ThrowOutOfMemoryError(env, NULL);\n-            return 0;\n-        }\n-    } else {\n-        buf = stackBuf;\n@@ -107,6 +96,18 @@\n-        nread = -1;\n-    } else {\n-        nread = IO_Read(fd, buf, len);\n-        if (nread > 0) {\n-            (*env)->SetByteArrayRegion(env, bytes, off, nread, (jbyte *)buf);\n-        } else if (nread == -1) {\n+        return -1;\n+    }\n+\n+    remaining = len;\n+    while (remaining > 0) {\n+        readSize = remaining < bufSize ? remaining : bufSize;\n+        n = IO_Read(fd, buf, readSize);\n+        if (n > 0) {\n+            (*env)->SetByteArrayRegion(env, bytes, off, n, (jbyte*)buf);\n+            remaining -= n;\n+            \/\/ Exit loop on short read\n+            if (n < readSize)\n+                break;\n+            off += n;\n+        } else if (n == 0) { \/\/ EOF\n+            if (remaining == len)\n+                return -1;\n+        } else {\n@@ -114,2 +115,1 @@\n-        } else { \/* EOF *\/\n-            nread = -1;\n+            return -1;\n@@ -119,4 +119,1 @@\n-    if (buf != stackBuf) {\n-        free(buf);\n-    }\n-    return nread;\n+    return len - remaining;\n@@ -147,1 +144,2 @@\n-           jint off, jint len, jboolean append, jfieldID fid)\n+           jint off, jint len, jboolean append,\n+           jlong bufAddr, jint bufSize, jfieldID fid)\n@@ -149,0 +147,3 @@\n+    jint remaining;\n+    void* buf = (void*)jlong_to_ptr(bufAddr);\n+    jint writeSize;\n@@ -150,2 +151,0 @@\n-    char stackBuf[BUF_SIZE];\n-    char *buf = NULL;\n@@ -166,8 +165,0 @@\n-    } else if (len > BUF_SIZE) {\n-        buf = malloc(len);\n-        if (buf == NULL) {\n-            JNU_ThrowOutOfMemoryError(env, NULL);\n-            return;\n-        }\n-    } else {\n-        buf = stackBuf;\n@@ -176,1 +167,5 @@\n-    (*env)->GetByteArrayRegion(env, bytes, off, len, (jbyte *)buf);\n+    fd = getFD(env, this, fid);\n+    if (fd == -1) {\n+        JNU_ThrowIOException(env, \"Stream Closed\");\n+        return;\n+    }\n@@ -178,8 +173,5 @@\n-    if (!(*env)->ExceptionOccurred(env)) {\n-        off = 0;\n-        while (len > 0) {\n-            fd = getFD(env, this, fid);\n-            if (fd == -1) {\n-                JNU_ThrowIOException(env, \"Stream Closed\");\n-                break;\n-            }\n+    remaining = len;\n+    while (remaining > 0) {\n+        writeSize = remaining < bufSize ? remaining : bufSize;\n+        (*env)->GetByteArrayRegion(env, bytes, off, writeSize, (jbyte*)buf);\n+        if (!(*env)->ExceptionOccurred(env)) {\n@@ -187,1 +179,1 @@\n-                n = IO_Append(fd, buf+off, len);\n+                n = IO_Append(fd, buf, writeSize);\n@@ -189,1 +181,1 @@\n-                n = IO_Write(fd, buf+off, len);\n+                n = IO_Write(fd, buf, writeSize);\n@@ -196,1 +188,4 @@\n-            len -= n;\n+            remaining -= n;\n+        } else { \/\/ ArrayIndexOutOfBoundsException\n+            (*env)->ExceptionClear(env);\n+            break;\n@@ -199,3 +194,0 @@\n-    if (buf != stackBuf) {\n-        free(buf);\n-    }\n","filename":"src\/java.base\/share\/native\/libjava\/io_util.c","additions":49,"deletions":57,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-               jint len, jfieldID fid);\n+               jint len, jlong bufAddr, jint bufSize, jfieldID fid);\n@@ -55,1 +55,1 @@\n-                jint len, jboolean append, jfieldID fid);\n+                jint len, jboolean append, jlong bufAddr, jint bufSize, jfieldID fid);\n","filename":"src\/java.base\/share\/native\/libjava\/io_util.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * @bug 8264777\n- * @summary Test read{All,N}Bytes overrides (use -Dseed=X to set PRNG seed)\n+ * @bug 6478546 8264777\n+ * @summary Test read(byte[],int,int) and read{All,N}Bytes overrides (use -Dseed=X to set PRNG seed)\n@@ -36,0 +36,1 @@\n+import java.io.FileOutputStream;\n@@ -37,1 +38,0 @@\n-import java.io.RandomAccessFile;\n@@ -44,1 +44,2 @@\n-    private static final int MAX_FILE_SIZE = 1_000_000;\n+    private static final int MAX_EXTRA_FILE_SIZE = 1_000_000;\n+    private static final int MIN_LARGE_FILE_SIZE = 2_500_000;\n@@ -76,1 +77,2 @@\n-            int size = 1 + RND.nextInt(MAX_FILE_SIZE);\n+            int baseSize = i % 2 == 0 ? 1 : MIN_LARGE_FILE_SIZE;\n+            int size = baseSize + RND.nextInt(MAX_EXTRA_FILE_SIZE);\n@@ -78,1 +80,2 @@\n-            byte[] bytes = new byte[size];\n+            int offset = RND.nextInt(size\/4);\n+            byte[] bytes = new byte[offset + size];\n@@ -80,2 +83,18 @@\n-            try (RandomAccessFile raf = new RandomAccessFile(file, \"rw\")) {\n-                raf.write(bytes);\n+            try (FileOutputStream fos = new FileOutputStream(file)) {\n+                fos.write(bytes, offset, size);\n+            }\n+\n+            try (FileInputStream fis = new FileInputStream(file)) {\n+                int pos = RND.nextInt(size);\n+                int len = RND.nextInt(size - pos);\n+                fis.getChannel().position(pos);\n+                byte[] nbytes = new byte[size];\n+                int n = fis.read(nbytes, 0, 0);\n+                if (n != 0)\n+                    throw new RuntimeException(\"read() zero length\");\n+                n = fis.read(nbytes, pos, len);\n+                if (n != len)\n+                    throw new RuntimeException(\"read() length\");\n+                if (!Arrays.equals(nbytes, pos, pos + len,\n+                                   bytes, offset + pos, offset + pos + len))\n+                    throw new RuntimeException(\"read() content\");\n@@ -94,1 +113,2 @@\n-                if (!Arrays.equals(nbytes, 0, len, bytes, pos, pos + len))\n+                if (!Arrays.equals(nbytes, 0, len,\n+                                   bytes, pos + offset, offset + pos + len))\n@@ -105,1 +125,1 @@\n-                                   bytes, pos, pos + allbytes.length))\n+                                   bytes, offset + pos, offset + pos + allbytes.length))\n","filename":"test\/jdk\/java\/io\/FileInputStream\/ReadXBytes.java","additions":31,"deletions":11,"binary":false,"changes":42,"status":"modified"}]}