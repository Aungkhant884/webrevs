{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import java.nio.ByteBuffer;\n@@ -32,0 +33,1 @@\n+import sun.nio.ch.DirectBuffer;\n@@ -33,0 +35,1 @@\n+import sun.nio.ch.Util;\n@@ -247,1 +250,1 @@\n-     * @param     b the data to be written\n+     * @param     b the data to be read\n@@ -249,1 +252,3 @@\n-     * @param     len the number of bytes that are written\n+     * @param     len the number of bytes to be read\n+     * @param     address the address of the temporary direct buffer's array\n+     * @param     size the size of the temporary direct buffer's array\n@@ -252,1 +257,2 @@\n-    private native int readBytes(byte[] b, int off, int len) throws IOException;\n+    private native int readBytes0(byte[] b, int off, int len, long address,\n+                                  int size) throws IOException;\n@@ -267,1 +273,2 @@\n-        long comp = Blocker.begin();\n+        int size = RandomAccessFile.bufferSize(b.length);\n+        ByteBuffer buf = Util.getTemporaryDirectBuffer(size);\n@@ -269,1 +276,7 @@\n-            return readBytes(b, 0, b.length);\n+            long comp = Blocker.begin();\n+            try {\n+                long address = ((DirectBuffer)buf).address();\n+                return readBytes0(b, 0, b.length, address, size);\n+            } finally {\n+                Blocker.end(comp);\n+            }\n@@ -271,1 +284,1 @@\n-            Blocker.end(comp);\n+            Util.releaseTemporaryDirectBuffer(buf);\n@@ -291,1 +304,2 @@\n-        long comp = Blocker.begin();\n+        int size = RandomAccessFile.bufferSize(len);\n+        ByteBuffer buf = Util.getTemporaryDirectBuffer(size);\n@@ -293,1 +307,7 @@\n-            return readBytes(b, off, len);\n+            long comp = Blocker.begin();\n+            try {\n+                long address = ((DirectBuffer)buf).address();\n+                return readBytes0(b, off, len, address, size);\n+            } finally {\n+                Blocker.end(comp);\n+            }\n@@ -295,1 +315,1 @@\n-            Blocker.end(comp);\n+            Util.releaseTemporaryDirectBuffer(buf);\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileInputStream.java","additions":29,"deletions":9,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.nio.ByteBuffer;\n@@ -32,0 +33,1 @@\n+import sun.nio.ch.DirectBuffer;\n@@ -33,1 +35,1 @@\n-\n+import sun.nio.ch.Util;\n@@ -329,6 +331,6 @@\n-     * Writes a sub array as a sequence of bytes.\n-     * @param b the data to be written\n-     * @param off the start offset in the data\n-     * @param len the number of bytes that are written\n-     * @param append {@code true} to first advance the position to the\n-     *     end of file\n+     * Writes a subarray as a sequence of bytes.\n+     * @param     b the data to be written\n+     * @param     off the start offset in the data\n+     * @param     len the number of bytes to be written\n+     * @param     address the address of the temporary direct buffer's array\n+     * @param     size the size of the temporary direct buffer's array\n@@ -337,1 +339,2 @@\n-    private native void writeBytes(byte[] b, int off, int len, boolean append)\n+    private native void writeBytes0(byte[] b, int off, int len, boolean append,\n+                                    long address, int capacity)\n@@ -350,1 +353,2 @@\n-        long comp = Blocker.begin();\n+        int size = RandomAccessFile.bufferSize(b.length);\n+        ByteBuffer buf = Util.getTemporaryDirectBuffer(size);\n@@ -352,1 +356,7 @@\n-            writeBytes(b, 0, b.length, append);\n+            long comp = Blocker.begin();\n+            try {\n+                long address = ((DirectBuffer)buf).address();\n+                writeBytes0(b, 0, b.length, append, address, size);\n+            } finally {\n+                Blocker.end(comp);\n+            }\n@@ -354,1 +364,1 @@\n-            Blocker.end(comp);\n+            Util.releaseTemporaryDirectBuffer(buf);\n@@ -370,1 +380,2 @@\n-        long comp = Blocker.begin();\n+        int size = RandomAccessFile.bufferSize(len);\n+        ByteBuffer buf = Util.getTemporaryDirectBuffer(size);\n@@ -372,1 +383,7 @@\n-            writeBytes(b, off, len, append);\n+            long comp = Blocker.begin();\n+            try {\n+                long address = ((DirectBuffer)buf).address();\n+                writeBytes0(b, off, len, append, address, size);\n+            } finally {\n+                Blocker.end(comp);\n+            }\n@@ -374,1 +391,1 @@\n-            Blocker.end(comp);\n+            Util.releaseTemporaryDirectBuffer(buf);\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileOutputStream.java","additions":31,"deletions":14,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.nio.ByteBuffer;\n@@ -33,0 +34,1 @@\n+import sun.nio.ch.DirectBuffer;\n@@ -34,1 +36,1 @@\n-\n+import sun.nio.ch.Util;\n@@ -64,1 +66,7 @@\n-    private FileDescriptor fd;\n+    \/\/ minimum capacity of temporary direct buffers\n+    private static final int MIN_BUFFER_SIZE = 8192;\n+\n+    \/\/ maximim capacity of temporary direct buffers\n+    private static final int MAX_BUFFER_SIZE = 65536;\n+\n+    private final FileDescriptor fd;\n@@ -84,0 +92,24 @@\n+    \/**\n+     * Calculate the size of a temporary direct buffer.\n+     *\n+     * @param the number of bytes in question\n+     * @return the size of buffer to use\n+     *\/\n+    \/\/ package scope\n+    static final int bufferSize(int len) {\n+        if (len <= 0) {\n+            return 0;\n+        }\n+\n+        if (len >= MAX_BUFFER_SIZE) {\n+            return MAX_BUFFER_SIZE;\n+        }\n+\n+        if (len % MIN_BUFFER_SIZE == 0) {\n+            return len;\n+        }\n+\n+        int multiple = (len + MIN_BUFFER_SIZE - 1)\/MIN_BUFFER_SIZE;\n+        return multiple*MIN_BUFFER_SIZE;\n+    }\n+\n@@ -388,1 +420,2 @@\n-        long comp = Blocker.begin();\n+        int size = bufferSize(len);\n+        ByteBuffer buf = Util.getTemporaryDirectBuffer(size);\n@@ -390,1 +423,7 @@\n-            return readBytes0(b, off, len);\n+            long comp = Blocker.begin();\n+            try {\n+                long address = ((DirectBuffer)buf).address();\n+                return readBytes0(b, off, len, address, size);\n+            } finally {\n+                Blocker.end(comp);\n+            }\n@@ -392,1 +431,1 @@\n-            Blocker.end(comp);\n+            Util.releaseTemporaryDirectBuffer(buf);\n@@ -396,1 +435,11 @@\n-    private native int readBytes0(byte[] b, int off, int len) throws IOException;\n+    \/**\n+     * Reads a subarray as a sequence of bytes.\n+     * @param     b the data to be read\n+     * @param     off the start offset in the data\n+     * @param     len the number of bytes to be read\n+     * @param     address the address of the temporary direct buffer's array\n+     * @param     size the size of the temporary direct buffer's array\n+     * @throws    IOException If an I\/O error has occurred.\n+     *\/\n+    private native int readBytes0(byte[] b, int off, int len, long address,\n+                                  int size) throws IOException;\n@@ -560,1 +609,2 @@\n-        long comp = Blocker.begin();\n+        int size = bufferSize(len);\n+        ByteBuffer buf = Util.getTemporaryDirectBuffer(size);\n@@ -562,1 +612,7 @@\n-            writeBytes0(b, off, len);\n+            long comp = Blocker.begin();\n+            try {\n+                long address = ((DirectBuffer)buf).address();\n+                writeBytes0(b, off, len, address, size);\n+            } finally {\n+                Blocker.end(comp);\n+            }\n@@ -564,1 +620,1 @@\n-            Blocker.end(comp);\n+            Util.releaseTemporaryDirectBuffer(buf);\n@@ -568,1 +624,11 @@\n-    private native void writeBytes0(byte[] b, int off, int len) throws IOException;\n+    \/**\n+     * Writes a subarray as a sequence of bytes.\n+     * @param     b the data to be written\n+     * @param     off the start offset in the data\n+     * @param     len the number of bytes to be written\n+     * @param     address the address of the temporary direct buffer's array\n+     * @param     size the size of the temporary direct buffer's array\n+     * @throws    IOException If an I\/O error has occurred.\n+     *\/\n+    private native void writeBytes0(byte[] b, int off, int len, long address,\n+                                    int size) throws IOException;\n","filename":"src\/java.base\/share\/classes\/java\/io\/RandomAccessFile.java","additions":76,"deletions":10,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,3 +70,3 @@\n-Java_java_io_FileInputStream_readBytes(JNIEnv *env, jobject this,\n-        jbyteArray bytes, jint off, jint len) {\n-    return readBytes(env, this, bytes, off, len, fis_fd);\n+Java_java_io_FileInputStream_readBytes0(JNIEnv *env, jobject this,\n+        jbyteArray bytes, jint off, jint len, jlong address, jint size) {\n+    return readBytes(env, this, bytes, off, len, fis_fd, address, size);\n","filename":"src\/java.base\/share\/native\/libjava\/FileInputStream.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,3 +68,4 @@\n-Java_java_io_FileOutputStream_writeBytes(JNIEnv *env,\n-    jobject this, jbyteArray bytes, jint off, jint len, jboolean append) {\n-    writeBytes(env, this, bytes, off, len, append, fos_fd);\n+Java_java_io_FileOutputStream_writeBytes0(JNIEnv *env,\n+    jobject this, jbyteArray bytes, jint off, jint len, jboolean append,\n+    jlong addr, jint size) {\n+    writeBytes(env, this, bytes, off, len, append, fos_fd, addr, size);\n","filename":"src\/java.base\/share\/native\/libjava\/FileOutputStream.c","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -77,2 +77,2 @@\n-    jobject this, jbyteArray bytes, jint off, jint len) {\n-    return readBytes(env, this, bytes, off, len, raf_fd);\n+    jobject this, jbyteArray bytes, jint off, jint len, jlong addr, jint size) {\n+    return readBytes(env, this, bytes, off, len, raf_fd, addr, size);\n@@ -88,2 +88,2 @@\n-    jobject this, jbyteArray bytes, jint off, jint len) {\n-    writeBytes(env, this, bytes, off, len, JNI_FALSE, raf_fd);\n+    jobject this, jbyteArray bytes, jint off, jint len, jlong addr, jint size) {\n+    writeBytes(env, this, bytes, off, len, JNI_FALSE, raf_fd, addr, size);\n","filename":"src\/java.base\/share\/native\/libjava\/RandomAccessFile.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-          jint off, jint len, jfieldID fid)\n+          jint off, jint len, jfieldID fid, jlong address, jint size)\n@@ -79,3 +79,3 @@\n-    char stackBuf[STACK_BUF_SIZE];\n-    char *buf = NULL;\n-    jint buf_size, read_size;\n+    char *buf = (char*)jlong_to_ptr(address);\n+    const jint buf_size = size;\n+    jint read_size;\n@@ -97,10 +97,0 @@\n-    } else if (len > STACK_BUF_SIZE) {\n-        buf_size = len < MAX_MALLOC_SIZE ? len : MAX_MALLOC_SIZE;\n-        buf = malloc(buf_size);\n-        if (buf == NULL) {\n-            JNU_ThrowOutOfMemoryError(env, NULL);\n-            return 0;\n-        }\n-    } else {\n-        buf = stackBuf;\n-        buf_size = STACK_BUF_SIZE;\n@@ -138,3 +128,0 @@\n-    if (buf != stackBuf) {\n-        free(buf);\n-    }\n@@ -166,1 +153,2 @@\n-           jint off, jint len, jboolean append, jfieldID fid)\n+           jint off, jint len, jboolean append, jfieldID fid,\n+           jlong address, jint size)\n@@ -168,3 +156,3 @@\n-    char stackBuf[STACK_BUF_SIZE];\n-    char *buf = NULL;\n-    jint buf_size, write_size;\n+    char *buf = (char*)jlong_to_ptr(address);\n+    const jint buf_size = size;\n+    jint write_size;\n@@ -186,10 +174,0 @@\n-    } else if (len > STACK_BUF_SIZE) {\n-        buf_size = len < MAX_MALLOC_SIZE ? len : MAX_MALLOC_SIZE;\n-        buf = malloc(buf_size);\n-        if (buf == NULL) {\n-            JNU_ThrowOutOfMemoryError(env, NULL);\n-            return;\n-        }\n-    } else {\n-        buf = stackBuf;\n-        buf_size = STACK_BUF_SIZE;\n@@ -223,4 +201,0 @@\n-\n-    if (buf != stackBuf) {\n-        free(buf);\n-    }\n","filename":"src\/java.base\/share\/native\/libjava\/io_util.c","additions":9,"deletions":35,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-               jint len, jfieldID fid);\n+               jint len, jfieldID fid, jlong address, jint size);\n@@ -55,1 +55,1 @@\n-                jint len, jboolean append, jfieldID fid);\n+                jint len, jboolean append, jfieldID fid, jlong address, jint size);\n","filename":"src\/java.base\/share\/native\/libjava\/io_util.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}