{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+ * <pre>\n@@ -48,0 +49,1 @@\n+ * <\/pre>\n@@ -50,1 +52,0 @@\n- *\n@@ -94,20 +95,16 @@\n-    protected void engineInit(byte[] encoded)\n-        throws IOException {\n-        DerInputStream der = new DerInputStream(encoded);\n-        mdName = \"SHA-1\";\n-        mgfSpec = MGF1ParameterSpec.SHA1;\n-        p = new byte[0];\n-        DerValue[] datum = der.getSequence(3);\n-        for (int i=0; i<datum.length; i++) {\n-            DerValue data = datum[i];\n-            if (data.isContextSpecific((byte) 0x00)) {\n-                \/\/ hash algid\n-                mdName = AlgorithmId.parse\n-                    (data.data.getDerValue()).getName();\n-            } else if (data.isContextSpecific((byte) 0x01)) {\n-                \/\/ mgf algid\n-                AlgorithmId val = AlgorithmId.parse(data.data.getDerValue());\n-                if (!val.getOID().equals(OID_MGF1)) {\n-                    throw new IOException(\"Only MGF1 mgf is supported\");\n-                }\n-                AlgorithmId params = AlgorithmId.parse(\n+    protected void engineInit(byte[] encoded) throws IOException {\n+\n+        DerInputStream der = DerValue.wrap(encoded).data();\n+        var sub = der.getOptionalExplicitContextSpecific(0);\n+        if (sub.isPresent()) {\n+            mdName = AlgorithmId.parse(sub.get()).getName();\n+        } else {\n+            mdName = \"SHA-1\";\n+        }\n+        sub = der.getOptionalExplicitContextSpecific(1);\n+        if (sub.isPresent()) {\n+            AlgorithmId val = AlgorithmId.parse(sub.get());\n+            if (!val.getOID().equals(OID_MGF1)) {\n+                throw new IOException(\"Only MGF1 mgf is supported\");\n+            }\n+            AlgorithmId params = AlgorithmId.parse(\n@@ -115,17 +112,9 @@\n-                String mgfDigestName = params.getName();\n-                if (mgfDigestName.equals(\"SHA-1\")) {\n-                    mgfSpec = MGF1ParameterSpec.SHA1;\n-                } else if (mgfDigestName.equals(\"SHA-224\")) {\n-                    mgfSpec = MGF1ParameterSpec.SHA224;\n-                } else if (mgfDigestName.equals(\"SHA-256\")) {\n-                    mgfSpec = MGF1ParameterSpec.SHA256;\n-                } else if (mgfDigestName.equals(\"SHA-384\")) {\n-                    mgfSpec = MGF1ParameterSpec.SHA384;\n-                } else if (mgfDigestName.equals(\"SHA-512\")) {\n-                    mgfSpec = MGF1ParameterSpec.SHA512;\n-                } else if (mgfDigestName.equals(\"SHA-512\/224\")) {\n-                    mgfSpec = MGF1ParameterSpec.SHA512_224;\n-                } else if (mgfDigestName.equals(\"SHA-512\/256\")) {\n-                    mgfSpec = MGF1ParameterSpec.SHA512_256;\n-                } else {\n-                    throw new IOException(\n+            mgfSpec = switch (params.getName()) {\n+                case \"SHA-1\" -> MGF1ParameterSpec.SHA1;\n+                case \"SHA-224\" -> MGF1ParameterSpec.SHA224;\n+                case \"SHA-256\" -> MGF1ParameterSpec.SHA256;\n+                case \"SHA-384\" -> MGF1ParameterSpec.SHA384;\n+                case \"SHA-512\" -> MGF1ParameterSpec.SHA512;\n+                case \"SHA-512\/224\" -> MGF1ParameterSpec.SHA512_224;\n+                case \"SHA-512\/256\" -> MGF1ParameterSpec.SHA512_256;\n+                default -> throw new IOException(\n@@ -133,14 +122,9 @@\n-                }\n-            } else if (data.isContextSpecific((byte) 0x02)) {\n-                \/\/ pSource algid\n-                AlgorithmId val = AlgorithmId.parse(data.data.getDerValue());\n-                if (!val.getOID().equals(OID_PSpecified)) {\n-                    throw new IOException(\"Wrong OID for pSpecified\");\n-                }\n-                DerInputStream dis = new DerInputStream(val.getEncodedParams());\n-                p = dis.getOctetString();\n-                if (dis.available() != 0) {\n-                    throw new IOException(\"Extra data for pSpecified\");\n-                }\n-            } else {\n-                throw new IOException(\"Invalid encoded OAEPParameters\");\n+            };\n+        } else {\n+            mgfSpec = MGF1ParameterSpec.SHA1;\n+        }\n+        sub = der.getOptionalExplicitContextSpecific(2);\n+        if (sub.isPresent()) {\n+            AlgorithmId val = AlgorithmId.parse(sub.get());\n+            if (!val.getOID().equals(OID_PSpecified)) {\n+                throw new IOException(\"Wrong OID for pSpecified\");\n@@ -148,0 +132,3 @@\n+            p = DerValue.wrap(val.getEncodedParams()).getOctetString();\n+        } else {\n+            p = new byte[0];\n@@ -149,0 +136,1 @@\n+        der.atEnd();\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/OAEPParameters.java","additions":41,"deletions":53,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import java.util.Optional;\n+import java.util.function.Predicate;\n@@ -56,1 +58,0 @@\n-\n@@ -308,0 +309,86 @@\n+\n+    \/**\n+     * Ensures there is no more data. This can be called when the last\n+     * expected field is parsed, and we need to make sure no unread is left.\n+     *\n+     * @throws IOException if the end is NOT reached yet\n+     *\/\n+    public void atEnd() throws IOException {\n+        if (available() != 0) {\n+            throw new IOException(\"Extra unused bytes\");\n+        }\n+    }\n+\n+    \/**\n+     * Checks if the tag of the next DerValue matches the rule.\n+     *\n+     * @param rule the rule to check for the tag.\n+     * @return true if matches, false if not or stream is at end.\n+     * @throws IOException if an I\/O error happens while peeking the byte\n+     *\/\n+    public boolean checkNextTag(Predicate<Byte> rule) throws IOException {\n+        return available() > 0 && rule.test(data[pos]);\n+    }\n+\n+    \/**\n+     * Detect if the tag of the next DerValue is the specified one.\n+     *\n+     * @param tag the expected tag\n+     * @return true if matches, false if not or stream is at end.\n+     * @throws IOException if an I\/O error happens while peeking the byte\n+     *\/\n+    public boolean checkNextTag(byte tag) throws IOException {\n+        return checkNextTag(t -> t == tag);\n+    }\n+\n+    \/**\n+     * Detect if the next DerValue is a context-specific value\n+     * tagged by {@code n}.\n+     *\n+     * @param n the expected tag\n+     * @return true if matches, false if not or stream is at end.\n+     * @throws IOException if an I\/O error happens while peeking the byte\n+     *\/\n+    public boolean seeOptionalContextSpecific(int n) throws IOException {\n+        return checkNextTag(t -> (t & 0x0c0) == 0x080 && (t & 0x01f) == n);\n+    }\n+\n+    \/**\n+     * Returns the inner DerValue if the next DerValue is\n+     * an EXPLICIT context-specific value tagged by {@code n}.\n+     *\n+     * @param n the expected tag\n+     * @return the inner DerValue, or empty if not found or stream at end\n+     * @throws IOException if an I\/O error happens\n+     *\/\n+    public Optional<DerValue> getOptionalExplicitContextSpecific(int n)\n+            throws IOException {\n+        if (seeOptionalContextSpecific(n)) {\n+            DerInputStream sub = getDerValue().data(); \/\/ stream inside [n]\n+            DerValue inner = sub.getDerValue(); \/\/ inside [n]\n+            sub.atEnd(); \/\/ make sure there is only one inner value\n+            return Optional.of(inner);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    \/**\n+     * Returns the restored DerValue if the next DerValue is\n+     * an IMPLICIT context-specific value tagged by {@code n}.\n+     *\n+     * @param n the expected tag\n+     * @param tag the real tag for the IMPLICIT type\n+     * @return the restored DerValue, or empty if not found or stream at end\n+     * @throws IOException if an I\/O error happens\n+     *\/\n+    public Optional<DerValue> getOptionalImplicitContextSpecific(int n, byte tag)\n+            throws IOException {\n+        if (seeOptionalContextSpecific(n)) {\n+            DerValue v = getDerValue(); \/\/ [n]\n+            \/\/ restore tag because IMPLICIT has overwritten it\n+            return Optional.of(v.withTag(tag));\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DerInputStream.java","additions":89,"deletions":2,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -290,1 +290,1 @@\n-     * Wraps an DerOutputStream. All bytes currently written\n+     * Wraps a DerOutputStream. All bytes currently written\n@@ -305,0 +305,28 @@\n+    \/**\n+     * Wraps a byte array at a single DerValue.\n+     *\n+     * Attention: no cloning is made.\n+     *\n+     * @param buf the byte array containing the DER-encoded datum\n+     * @returns a new DerValue\n+     *\/\n+    public static DerValue wrap(byte[] buf)\n+            throws IOException {\n+        return wrap(buf, 0, buf.length);\n+    }\n+\n+    \/**\n+     * Wraps a byte array at a single DerValue.\n+     *\n+     * Attention: no cloning is made.\n+     *\n+     * @param buf the byte array containing the DER-encoded datum\n+     * @param offset where the encoded datum starts inside {@code buf}\n+     * @param len length of bytes to parse inside {@code buf}\n+     * @returns a new DerValue\n+     *\/\n+    public static DerValue wrap(byte[] buf, int offset, int len)\n+            throws IOException {\n+        return new DerValue(buf, offset, len, true, false);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DerValue.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.crypto.spec.OAEPParameterSpec;\n+import javax.crypto.spec.PSource;\n+import java.io.IOException;\n+import java.security.AlgorithmParameters;\n+import java.security.spec.MGF1ParameterSpec;\n+import java.util.Arrays;\n+\n+\/**\n+ * @test\n+ * @bug 8246797\n+ * @summary Ensures OAEPParameters read correct encoding\n+ *\/\n+\n+public class OAEPOrder {\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Do not use default fields\n+        OAEPParameterSpec spec = new OAEPParameterSpec(\n+                \"SHA-1\", \"MGF1\", MGF1ParameterSpec.SHA1,\n+                new PSource.PSpecified(new byte[10]));\n+        AlgorithmParameters alg = AlgorithmParameters.getInstance(\"OAEP\");\n+        alg.init(spec);\n+        byte[] encoded = alg.getEncoded();\n+\n+        \/\/ Extract the fields inside encoding\n+        \/\/ [0] HashAlgorithm\n+        byte[] a0 = Arrays.copyOfRange(encoded, 2, encoded[3] + 4);\n+        \/\/ [1] MaskGenAlgorithm + [2] PSourceAlgorithm\n+        byte[] a12 = Arrays.copyOfRange(encoded, 2 + a0.length, encoded.length);\n+\n+        \/\/ and rearrange [1] and [2] before [0]\n+        System.arraycopy(a12, 0, encoded, 2, a12.length);\n+        System.arraycopy(a0, 0, encoded, 2 + a12.length, a0.length);\n+\n+        AlgorithmParameters alg2 = AlgorithmParameters.getInstance(\"OAEP\");\n+        try {\n+            alg2.init(encoded);\n+            throw new RuntimeException(\"Should fail\");\n+        } catch (IOException ioe) {\n+            \/\/ expected\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/AlgorithmParameters\/OAEPOrder.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"}]}