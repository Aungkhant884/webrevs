{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+ * <pre>\n@@ -48,0 +49,1 @@\n+ * <\/pre>\n@@ -50,1 +52,0 @@\n- *\n@@ -94,20 +95,16 @@\n-    protected void engineInit(byte[] encoded)\n-        throws IOException {\n-        DerInputStream der = new DerInputStream(encoded);\n-        mdName = \"SHA-1\";\n-        mgfSpec = MGF1ParameterSpec.SHA1;\n-        p = new byte[0];\n-        DerValue[] datum = der.getSequence(3);\n-        for (int i=0; i<datum.length; i++) {\n-            DerValue data = datum[i];\n-            if (data.isContextSpecific((byte) 0x00)) {\n-                \/\/ hash algid\n-                mdName = AlgorithmId.parse\n-                    (data.data.getDerValue()).getName();\n-            } else if (data.isContextSpecific((byte) 0x01)) {\n-                \/\/ mgf algid\n-                AlgorithmId val = AlgorithmId.parse(data.data.getDerValue());\n-                if (!val.getOID().equals(OID_MGF1)) {\n-                    throw new IOException(\"Only MGF1 mgf is supported\");\n-                }\n-                AlgorithmId params = AlgorithmId.parse(\n+    protected void engineInit(byte[] encoded) throws IOException {\n+\n+        DerInputStream der = DerValue.wrap(encoded).data();\n+        var sub = der.getOptionalExplicitContextSpecific(0);\n+        if (sub.isPresent()) {\n+            mdName = AlgorithmId.parse(sub.get()).getName();\n+        } else {\n+            mdName = \"SHA-1\";\n+        }\n+        sub = der.getOptionalExplicitContextSpecific(1);\n+        if (sub.isPresent()) {\n+            AlgorithmId val = AlgorithmId.parse(sub.get());\n+            if (!val.getOID().equals(OID_MGF1)) {\n+                throw new IOException(\"Only MGF1 mgf is supported\");\n+            }\n+            AlgorithmId params = AlgorithmId.parse(\n@@ -115,17 +112,9 @@\n-                String mgfDigestName = params.getName();\n-                if (mgfDigestName.equals(\"SHA-1\")) {\n-                    mgfSpec = MGF1ParameterSpec.SHA1;\n-                } else if (mgfDigestName.equals(\"SHA-224\")) {\n-                    mgfSpec = MGF1ParameterSpec.SHA224;\n-                } else if (mgfDigestName.equals(\"SHA-256\")) {\n-                    mgfSpec = MGF1ParameterSpec.SHA256;\n-                } else if (mgfDigestName.equals(\"SHA-384\")) {\n-                    mgfSpec = MGF1ParameterSpec.SHA384;\n-                } else if (mgfDigestName.equals(\"SHA-512\")) {\n-                    mgfSpec = MGF1ParameterSpec.SHA512;\n-                } else if (mgfDigestName.equals(\"SHA-512\/224\")) {\n-                    mgfSpec = MGF1ParameterSpec.SHA512_224;\n-                } else if (mgfDigestName.equals(\"SHA-512\/256\")) {\n-                    mgfSpec = MGF1ParameterSpec.SHA512_256;\n-                } else {\n-                    throw new IOException(\n+            mgfSpec = switch (params.getName()) {\n+                case \"SHA-1\" -> MGF1ParameterSpec.SHA1;\n+                case \"SHA-224\" -> MGF1ParameterSpec.SHA224;\n+                case \"SHA-256\" -> MGF1ParameterSpec.SHA256;\n+                case \"SHA-384\" -> MGF1ParameterSpec.SHA384;\n+                case \"SHA-512\" -> MGF1ParameterSpec.SHA512;\n+                case \"SHA-512\/224\" -> MGF1ParameterSpec.SHA512_224;\n+                case \"SHA-512\/256\" -> MGF1ParameterSpec.SHA512_256;\n+                default -> throw new IOException(\n@@ -133,14 +122,9 @@\n-                }\n-            } else if (data.isContextSpecific((byte) 0x02)) {\n-                \/\/ pSource algid\n-                AlgorithmId val = AlgorithmId.parse(data.data.getDerValue());\n-                if (!val.getOID().equals(OID_PSpecified)) {\n-                    throw new IOException(\"Wrong OID for pSpecified\");\n-                }\n-                DerInputStream dis = new DerInputStream(val.getEncodedParams());\n-                p = dis.getOctetString();\n-                if (dis.available() != 0) {\n-                    throw new IOException(\"Extra data for pSpecified\");\n-                }\n-            } else {\n-                throw new IOException(\"Invalid encoded OAEPParameters\");\n+            };\n+        } else {\n+            mgfSpec = MGF1ParameterSpec.SHA1;\n+        }\n+        sub = der.getOptionalExplicitContextSpecific(2);\n+        if (sub.isPresent()) {\n+            AlgorithmId val = AlgorithmId.parse(sub.get());\n+            if (!val.getOID().equals(OID_PSpecified)) {\n+                throw new IOException(\"Wrong OID for pSpecified\");\n@@ -148,0 +132,3 @@\n+            p = DerValue.wrap(val.getEncodedParams()).getOctetString();\n+        } else {\n+            p = new byte[0];\n@@ -149,0 +136,1 @@\n+        der.atEnd();\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/OAEPParameters.java","additions":41,"deletions":53,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -271,1 +271,0 @@\n-        DerValue prf = null;\n@@ -273,8 +272,3 @@\n-        if (pBKDF2_params.data.available() > 0) {\n-            DerValue keyLength = pBKDF2_params.data.getDerValue();\n-            if (keyLength.tag == DerValue.tag_Integer) {\n-                keysize = keyLength.getInteger() * 8; \/\/ keysize (in bits)\n-            } else {\n-                \/\/ Should be the prf\n-                prf = keyLength;\n-            }\n+        var ksDer = pBKDF2_params.data.getOptional(DerValue.tag_Integer);\n+        if (ksDer.isPresent()) {\n+            keysize = ksDer.get().getInteger() * 8; \/\/ keysize (in bits)\n@@ -282,0 +276,1 @@\n+\n@@ -283,7 +278,4 @@\n-        String kdfAlgo = \"HmacSHA1\";\n-        if (prf == null) {\n-            if (pBKDF2_params.data.available() > 0) {\n-                prf = pBKDF2_params.data.getDerValue();\n-            }\n-        }\n-        if (prf != null) {\n+        String kdfAlgo;\n+        var prfDer = pBKDF2_params.data.getOptional(DerValue.tag_Sequence);\n+        if (prfDer.isPresent()) {\n+            DerValue prf = prfDer.get();\n@@ -293,4 +285,4 @@\n-                !o.stdName().equals(\"HmacSHA224\") &&\n-                !o.stdName().equals(\"HmacSHA256\") &&\n-                !o.stdName().equals(\"HmacSHA384\") &&\n-                !o.stdName().equals(\"HmacSHA512\"))) {\n+                    !o.stdName().equals(\"HmacSHA224\") &&\n+                    !o.stdName().equals(\"HmacSHA256\") &&\n+                    !o.stdName().equals(\"HmacSHA384\") &&\n+                    !o.stdName().equals(\"HmacSHA512\"))) {\n@@ -302,9 +294,4 @@\n-\n-            if (prf.data.available() != 0) {\n-                \/\/ parameter is 'NULL' for all HmacSHA KDFs\n-                DerValue parameter = prf.data.getDerValue();\n-                if (parameter.tag != DerValue.tag_Null) {\n-                    throw new IOException(\"PBE parameter parsing error: \"\n-                            + \"not an ASN.1 NULL tag\");\n-                }\n-            }\n+            prf.data.getOptional(DerValue.tag_Null);\n+            prf.data.atEnd();\n+        } else {\n+            kdfAlgo = \"HmacSHA1\";\n@@ -312,1 +299,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBES2Parameters.java","additions":16,"deletions":30,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -258,0 +258,10 @@\n+    \/\/    SignedData ::= SEQUENCE {\n+    \/\/     version Version,\n+    \/\/     digestAlgorithms DigestAlgorithmIdentifiers,\n+    \/\/     contentInfo ContentInfo,\n+    \/\/     certificates\n+    \/\/        [0] IMPLICIT ExtendedCertificatesAndCertificates\n+    \/\/          OPTIONAL,\n+    \/\/     crls\n+    \/\/       [1] IMPLICIT CertificateRevocationLists OPTIONAL,\n+    \/\/     signerInfos SignerInfos }\n@@ -297,3 +307,3 @@\n-        if ((byte)(dis.peekByte()) == (byte)0xA0) {\n-            DerValue[] certVals = dis.getSet(2, true);\n-\n+        var certDer = dis.getOptionalImplicitContextSpecific(0, DerValue.tag_SetOf);\n+        if (certDer.isPresent()) {\n+            DerValue[] certVals = certDer.get().subs(DerValue.tag_SetOf, 2);\n@@ -342,3 +352,3 @@\n-        if ((byte)(dis.peekByte()) == (byte)0xA1) {\n-            DerValue[] crlVals = dis.getSet(1, true);\n-\n+        var crlsDer = dis.getOptionalImplicitContextSpecific(1, DerValue.tag_SetOf);\n+        if (crlsDer.isPresent()) {\n+            DerValue[] crlVals = crlsDer.get().subs(DerValue.tag_SetOf, 1);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/PKCS7.java","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import java.util.Optional;\n+import java.util.function.Predicate;\n@@ -56,1 +58,0 @@\n-\n@@ -308,0 +309,101 @@\n+\n+    \/**\n+     * Ensures there is no more data. This can be called when the last\n+     * expected field is parsed, and we need to make sure no unread is left.\n+     *\n+     * @throws IOException if the end is NOT reached yet\n+     *\/\n+    public void atEnd() throws IOException {\n+        if (available() != 0) {\n+            throw new IOException(\"Extra unused bytes\");\n+        }\n+    }\n+\n+    \/**\n+     * Checks if the tag of the next DerValue matches the rule.\n+     *\n+     * @param rule the rule to check for the tag.\n+     * @return true if matches, false if not or stream is at end.\n+     * @throws IOException if an I\/O error happens while peeking the byte\n+     *\/\n+    private boolean checkNextTag(Predicate<Byte> rule) {\n+        return available() > 0 && rule.test(data[pos]);\n+    }\n+\n+    \/**\n+     * Detect if the tag of the next DerValue is the specified one.\n+     *\n+     * @param tag the expected tag\n+     * @return true if matches, false if not or stream is at end.\n+     * @throws IOException if an I\/O error happens while peeking the byte\n+     *\/\n+    private boolean checkNextTag(byte tag) {\n+        return checkNextTag(t -> t == tag);\n+    }\n+\n+    \/**\n+     * Returns the next DerValue if its tag is the given one.\n+     *\n+     * @param tag the expected tag\n+     * @return the next DerValue, or empty if not found or stream at end\n+     * @throws IOException if an I\/O error happens\n+     *\/\n+    public Optional<DerValue> getOptional(byte tag) throws IOException {\n+        if (checkNextTag(tag)) {\n+            return Optional.of(getDerValue());\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    \/**\n+     * Detect if the next DerValue is a context-specific value\n+     * tagged by {@code n}.\n+     *\n+     * @param n the expected tag\n+     * @return true if matches, false if not or stream is at end.\n+     * @throws IOException if an I\/O error happens while peeking the byte\n+     *\/\n+    public boolean seeOptionalContextSpecific(int n) throws IOException {\n+        return checkNextTag(t -> (t & 0x0c0) == 0x080 && (t & 0x01f) == n);\n+    }\n+\n+    \/**\n+     * Returns the inner DerValue if the next DerValue is\n+     * an EXPLICIT context-specific value tagged by {@code n}.\n+     *\n+     * @param n the expected tag\n+     * @return the inner DerValue, or empty if not found or stream at end\n+     * @throws IOException if an I\/O error happens\n+     *\/\n+    public Optional<DerValue> getOptionalExplicitContextSpecific(int n)\n+            throws IOException {\n+        if (seeOptionalContextSpecific(n)) {\n+            DerInputStream sub = getDerValue().data(); \/\/ stream inside [n]\n+            DerValue inner = sub.getDerValue(); \/\/ inside [n]\n+            sub.atEnd(); \/\/ make sure there is only one inner value\n+            return Optional.of(inner);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    \/**\n+     * Returns the restored DerValue if the next DerValue is\n+     * an IMPLICIT context-specific value tagged by {@code n}.\n+     *\n+     * @param n the expected tag\n+     * @param tag the real tag for the IMPLICIT type\n+     * @return the restored DerValue, or empty if not found or stream at end\n+     * @throws IOException if an I\/O error happens\n+     *\/\n+    public Optional<DerValue> getOptionalImplicitContextSpecific(int n, byte tag)\n+            throws IOException {\n+        if (seeOptionalContextSpecific(n)) {\n+            DerValue v = getDerValue(); \/\/ [n]\n+            \/\/ restore tag because IMPLICIT has overwritten it\n+            return Optional.of(v.withTag(tag));\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DerInputStream.java","additions":104,"deletions":2,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -290,1 +290,1 @@\n-     * Wraps an DerOutputStream. All bytes currently written\n+     * Wraps a DerOutputStream. All bytes currently written\n@@ -305,0 +305,28 @@\n+    \/**\n+     * Wraps a byte array as a single DerValue.\n+     *\n+     * Attention: no cloning is made.\n+     *\n+     * @param buf the byte array containing the DER-encoded datum\n+     * @returns a new DerValue\n+     *\/\n+    public static DerValue wrap(byte[] buf)\n+            throws IOException {\n+        return wrap(buf, 0, buf.length);\n+    }\n+\n+    \/**\n+     * Wraps a byte array as a single DerValue.\n+     *\n+     * Attention: no cloning is made.\n+     *\n+     * @param buf the byte array containing the DER-encoded datum\n+     * @param offset where the encoded datum starts inside {@code buf}\n+     * @param len length of bytes to parse inside {@code buf}\n+     * @returns a new DerValue\n+     *\/\n+    public static DerValue wrap(byte[] buf, int offset, int len)\n+            throws IOException {\n+        return new DerValue(buf, offset, len, true, false);\n+    }\n+\n@@ -1229,1 +1257,1 @@\n-    DerValue[] subs(byte expectedTag, int startLen) throws IOException {\n+    public DerValue[] subs(byte expectedTag, int startLen) throws IOException {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DerValue.java","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.crypto.spec.OAEPParameterSpec;\n+import javax.crypto.spec.PSource;\n+import java.io.IOException;\n+import java.security.AlgorithmParameters;\n+import java.security.spec.MGF1ParameterSpec;\n+import java.util.Arrays;\n+\n+\/**\n+ * @test\n+ * @bug 8246797\n+ * @summary Ensures OAEPParameters read correct encoding and\n+ * reject encoding with invalid ordering\n+ *\/\n+\n+public class OAEPOrder {\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Do not use default fields\n+        OAEPParameterSpec spec = new OAEPParameterSpec(\n+                \"SHA-384\", \"MGF1\", MGF1ParameterSpec.SHA384,\n+                new PSource.PSpecified(new byte[10]));\n+        AlgorithmParameters alg = AlgorithmParameters.getInstance(\"OAEP\");\n+        alg.init(spec);\n+        byte[] encoded = alg.getEncoded();\n+\n+        \/\/ Extract the fields inside encoding\n+        \/\/ [0] HashAlgorithm\n+        byte[] a0 = Arrays.copyOfRange(encoded, 2, encoded[3] + 4);\n+        \/\/ [1] MaskGenAlgorithm + [2] PSourceAlgorithm\n+        byte[] a12 = Arrays.copyOfRange(encoded, 2 + a0.length, encoded.length);\n+\n+        \/\/ and rearrange [1] and [2] before [0]\n+        System.arraycopy(a12, 0, encoded, 2, a12.length);\n+        System.arraycopy(a0, 0, encoded, 2 + a12.length, a0.length);\n+\n+        AlgorithmParameters alg2 = AlgorithmParameters.getInstance(\"OAEP\");\n+        try {\n+            alg2.init(encoded);\n+            throw new RuntimeException(\"Should fail\");\n+        } catch (IOException ioe) {\n+            \/\/ expected\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/AlgorithmParameters\/OAEPOrder.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"}]}