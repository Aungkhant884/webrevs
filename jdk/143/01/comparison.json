{"files":[{"patch":"@@ -30,0 +30,1 @@\n+#include <type_traits>\n@@ -49,1 +50,1 @@\n-  friend class PrimitiveConversions;\n+  friend struct PrimitiveConversions::Translate<ZForwardingEntry>;\n@@ -82,1 +83,1 @@\n-struct PrimitiveConversions::Translate<ZForwardingEntry> : public TrueType {\n+struct PrimitiveConversions::Translate<ZForwardingEntry> : public std::true_type {\n","filename":"src\/hotspot\/share\/gc\/z\/zForwardingEntry.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"memory\/allocation.hpp\"\n+#include \"memory\/allStatic.hpp\"\n@@ -30,4 +30,1 @@\n-#include \"metaprogramming\/integralConstant.hpp\"\n-#include \"metaprogramming\/isFloatingPoint.hpp\"\n-#include \"metaprogramming\/isIntegral.hpp\"\n-#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -37,0 +34,8 @@\n+\n+  \/\/ True if types are the same size and either is integral.\n+  template<typename To, typename From>\n+  static constexpr bool check_cast() {\n+    return (sizeof(To) == sizeof(From)) &&\n+           (std::is_integral<To>::value || std::is_integral<From>::value);\n+  }\n+\n@@ -38,1 +43,3 @@\n-  \/\/ Return a value of type T with the same representation as x.\n+  \/\/ template<typename To, typename From> To cast(From x)\n+  \/\/\n+  \/\/ Return a value of type To with the same value representation as x.\n@@ -40,1 +47,1 @@\n-  \/\/ T and U must be of the same size.\n+  \/\/ To and From must be of the same size.\n@@ -42,3 +49,58 @@\n-  \/\/ At least one of T or U must be an integral type.  The other must\n-  \/\/ be an integral, floating point, or pointer type.\n-  template<typename T, typename U> static T cast(U x);\n+  \/\/ At least one of To or From must be an integral type.  The other must\n+  \/\/ be an integral, enum, floating point, or pointer type.\n+\n+  \/\/ integer -> integer\n+  \/\/ Use static_cast for conversion.  See C++14 4.7 Integral\n+  \/\/ conversions. If To is signed and From unsigned, the result is\n+  \/\/ implementation-defined.  All supported platforms provide two's\n+  \/\/ complement behavior, and that behavior is required by C++20.\n+  \/\/ Using an lvalue to reference cast (see C++03 3.10\/15) involves a\n+  \/\/ reinterpret_cast, which prevents constexpr support.\n+  template<typename To, typename From,\n+           ENABLE_IF(sizeof(To) == sizeof(From)),\n+           ENABLE_IF(std::is_integral<To>::value),\n+           ENABLE_IF(std::is_integral<From>::value)>\n+  static constexpr To cast(From x) {\n+    return static_cast<To>(x);\n+  }\n+\n+  \/\/ integer -> enum, enum -> integer\n+  \/\/ Use the enum's underlying type for integer -> integer cast.\n+  template<typename To, typename From,\n+           ENABLE_IF(check_cast<To, From>()),\n+           ENABLE_IF(std::is_enum<To>::value)>\n+  static constexpr To cast(From x) {\n+    return static_cast<To>(cast<std::underlying_type_t<To>>(x));\n+  }\n+\n+  template<typename To, typename From,\n+           ENABLE_IF(check_cast<To, From>()),\n+           ENABLE_IF(std::is_enum<From>::value)>\n+  static constexpr To cast(From x) {\n+    return cast<To>(static_cast<std::underlying_type_t<From>>(x));\n+  }\n+\n+  \/\/ integer -> pointer, pointer -> integer\n+  \/\/ Use reinterpret_cast, so no constexpr support.\n+  template<typename To, typename From,\n+           ENABLE_IF(check_cast<To, From>()),\n+           ENABLE_IF(std::is_pointer<To>::value || std::is_pointer<From>::value)>\n+  static To cast(From x) {\n+    return reinterpret_cast<To>(x);\n+  }\n+\n+  \/\/ integer -> floating point, floating point -> integer\n+  \/\/ Use the union trick.  The union trick is technically UB, but is\n+  \/\/ widely and well supported, producing good code.  In some cases,\n+  \/\/ such as gcc, that support is explicitly documented.  Using memcpy\n+  \/\/ is the correct method, but some compilers produce wretched code\n+  \/\/ for that method, even at maximal optimization levels.  Neither\n+  \/\/ the union trick nor memcpy provides constexpr support.\n+  template<typename To, typename From,\n+           ENABLE_IF(check_cast<To, From>()),\n+           ENABLE_IF(std::is_floating_point<To>::value ||\n+                     std::is_floating_point<From>::value)>\n+  static To cast(From x) {\n+    union { From from; To to; } converter = { x };\n+    return converter.to;\n+  }\n@@ -47,1 +109,1 @@\n-  \/\/ If derived from TrueType, provides representational conversion\n+  \/\/ If derived from std::true_type, provides representational conversion\n@@ -52,1 +114,1 @@\n-  \/\/   the same representation as x.\n+  \/\/   the same value representation as x.\n@@ -54,64 +116,2 @@\n-  \/\/   same representation as x.\n-  template<typename T> struct Translate : public FalseType {};\n-\n-private:\n-\n-  template<typename T,\n-           typename U,\n-           bool same_size = sizeof(T) == sizeof(U),\n-           typename Enable = void>\n-  struct Cast;\n-\n-  template<typename T, typename U> static T cast_using_union(U x);\n-};\n-\n-\/\/ Return an object of type T with the same value representation as x.\n-\/\/\n-\/\/ T and U must be of the same size.  It is expected that one of T and\n-\/\/ U is an integral type, and the other is an integral type, an enum type,\n-\/\/ or a floating point type.\n-\/\/\n-\/\/ This implementation uses the \"union trick\", which seems to be the\n-\/\/ best of a bad set of options.  Though technically undefined\n-\/\/ behavior, it is widely and well supported, producing good code.  In\n-\/\/ some cases, such as gcc, that support is explicitly documented.\n-\/\/\n-\/\/ Using memcpy is the correct method, but some compilers produce\n-\/\/ wretched code for that method, even at maximal optimization levels.\n-\/\/\n-\/\/ Using static_cast is only possible for integral and enum types, not\n-\/\/ for floating point types.  And for integral and enum conversions,\n-\/\/ static_cast has unspecified or implementation-defined behavior for\n-\/\/ some cases.  C++11 <type_traits> can be used to avoid most or all\n-\/\/ of those unspecified or implementation-defined issues, though that\n-\/\/ may require multi-step conversions.\n-\/\/\n-\/\/ Using reinterpret_cast of references has undefined behavior for\n-\/\/ many cases, and there is much less empirical basis for its use, as\n-\/\/ compared to the union trick.\n-template<typename T, typename U>\n-inline T PrimitiveConversions::cast_using_union(U x) {\n-  STATIC_ASSERT(sizeof(T) == sizeof(U));\n-  union { T t; U u; };\n-  u = x;\n-  return t;\n-}\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ cast<T>(x)\n-\/\/\n-\/\/ Cast<T, U, same_size, Enable>\n-\n-\/\/ Give an informative error if the sizes differ.\n-template<typename T, typename U>\n-struct PrimitiveConversions::Cast<T, U, false> {\n-  STATIC_ASSERT(sizeof(T) == sizeof(U));\n-};\n-\n-\/\/ Conversion between integral types.\n-template<typename T, typename U>\n-struct PrimitiveConversions::Cast<\n-  T, U, true,\n-  typename EnableIf<IsIntegral<T>::value && IsIntegral<U>::value>::type>\n-{\n-  T operator()(U x) const { return cast_using_union<T>(x); }\n+  \/\/   same value representation as x.\n+  template<typename T> struct Translate : public std::false_type {};\n@@ -120,45 +120,0 @@\n-\/\/ Convert an enum or floating point value to an integer value.\n-template<typename T, typename U>\n-struct PrimitiveConversions::Cast<\n-  T, U, true,\n-  typename EnableIf<IsIntegral<T>::value &&\n-                    (std::is_enum<U>::value ||\n-                     IsFloatingPoint<U>::value)>::type>\n-{\n-  T operator()(U x) const { return cast_using_union<T>(x); }\n-};\n-\n-\/\/ Convert an integer to an enum or floating point value.\n-template<typename T, typename U>\n-struct PrimitiveConversions::Cast<\n-  T, U, true,\n-  typename EnableIf<IsIntegral<U>::value &&\n-                    (std::is_enum<T>::value ||\n-                     IsFloatingPoint<T>::value)>::type>\n-{\n-  T operator()(U x) const { return cast_using_union<T>(x); }\n-};\n-\n-\/\/ Convert a pointer to an integral value.\n-template<typename T, typename U>\n-struct PrimitiveConversions::Cast<\n-  T, U*, true,\n-  typename EnableIf<IsIntegral<T>::value>::type>\n-{\n-  T operator()(U* x) const { return reinterpret_cast<T>(x); }\n-};\n-\n-\/\/ Convert an integral value to a pointer.\n-template<typename T, typename U>\n-struct PrimitiveConversions::Cast<\n-  T*, U, true,\n-  typename EnableIf<IsIntegral<U>::value>::type>\n-{\n-  T* operator()(U x) const { return reinterpret_cast<T*>(x); }\n-};\n-\n-template<typename T, typename U>\n-inline T PrimitiveConversions::cast(U x) {\n-  return Cast<T, U>()(x);\n-}\n-\n@@ -168,1 +123,1 @@\n-struct PrimitiveConversions::Translate<jdouble> : public TrueType {\n+struct PrimitiveConversions::Translate<jdouble> : public std::true_type {\n@@ -177,1 +132,1 @@\n-struct PrimitiveConversions::Translate<jfloat> : public TrueType {\n+struct PrimitiveConversions::Translate<jfloat> : public std::true_type {\n","filename":"src\/hotspot\/share\/metaprogramming\/primitiveConversions.hpp","additions":79,"deletions":124,"binary":false,"changes":203,"status":"modified"},{"patch":"@@ -98,0 +98,45 @@\n+TEST(PrimitiveConversionsTest, round_trip_int_constexpr) {\n+  constexpr int  sfive = 5;\n+  constexpr int  mfive = -5;\n+  constexpr uint ufive = 5u;\n+\n+  typedef PrimitiveConversionsTestSupport::Signed<int>::type SI;\n+  typedef PrimitiveConversionsTestSupport::Unsigned<int>::type UI;\n+\n+  {\n+    constexpr SI i = PrimitiveConversions::cast<SI>(sfive);\n+    constexpr int r = PrimitiveConversions::cast<int>(i);\n+    EXPECT_EQ(sfive, r);\n+  }\n+\n+  {\n+    constexpr UI i = PrimitiveConversions::cast<UI>(sfive);\n+    constexpr int r = PrimitiveConversions::cast<int>(i);\n+    EXPECT_EQ(sfive, r);\n+  }\n+\n+  {\n+    constexpr SI i = PrimitiveConversions::cast<SI>(mfive);\n+    constexpr int r = PrimitiveConversions::cast<int>(i);\n+    EXPECT_EQ(mfive, r);\n+  }\n+\n+  {\n+    constexpr UI i = PrimitiveConversions::cast<UI>(mfive);\n+    constexpr int r = PrimitiveConversions::cast<int>(i);\n+    EXPECT_EQ(mfive, r);\n+  }\n+\n+  {\n+    constexpr SI i = PrimitiveConversions::cast<SI>(ufive);\n+    constexpr uint r = PrimitiveConversions::cast<uint>(i);\n+    EXPECT_EQ(ufive, r);\n+  }\n+\n+  {\n+    constexpr UI i = PrimitiveConversions::cast<UI>(ufive);\n+    constexpr uint r = PrimitiveConversions::cast<uint>(i);\n+    EXPECT_EQ(ufive, r);\n+  }\n+}\n+\n","filename":"test\/hotspot\/gtest\/metaprogramming\/test_primitiveConversions.cpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"}]}