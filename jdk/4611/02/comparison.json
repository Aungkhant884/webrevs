{"files":[{"patch":"@@ -28,0 +28,1 @@\n+ * @library \/test\/lib \/\n@@ -44,0 +45,1 @@\n+ * @library \/test\/lib \/\n@@ -55,0 +57,1 @@\n+ * @library \/test\/lib \/\n@@ -66,0 +69,1 @@\n+ * @library \/test\/lib \/\n@@ -77,0 +81,1 @@\n+ * @library \/test\/lib \/\n@@ -88,0 +93,1 @@\n+ * @library \/test\/lib \/\n@@ -107,0 +113,2 @@\n+import jdk.test.lib.Utils;\n+\n@@ -124,0 +132,2 @@\n+        final long startTime = System.currentTimeMillis();\n+\n@@ -162,9 +172,0 @@\n-        \/\/ Wait until notifications start arriving, and then wait some more\n-        \/\/ to catch the ones arriving late.\n-        while (churnBytes.get() == 0) {\n-            Thread.sleep(1000);\n-        }\n-        Thread.sleep(5000);\n-\n-        long actual = churnBytes.get();\n-\n@@ -173,0 +174,18 @@\n+        long actual = 0;\n+\n+        \/\/ Look at test timeout to figure out how long we can wait without breaking into timeout.\n+        long spentTime = System.currentTimeMillis() - startTime;\n+        long maxTries = (Utils.adjustTimeout(Utils.DEFAULT_TEST_TIMEOUT) - spentTime) \/ 1000 \/ 2;\n+\n+        \/\/ Wait until enough notifications are accrued to match minimum boundary.\n+        long tries = 0;\n+        while (tries++ < maxTries) {\n+            actual = churnBytes.get();\n+            if (minExpected <= actual) {\n+                \/\/ Wait some more to test if we are breaking the maximum boundary.\n+                Thread.sleep(5000);\n+                actual = churnBytes.get();\n+                break;\n+            }\n+            Thread.sleep(1000);\n+        }\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/mxbeans\/TestChurnNotifications.java","additions":28,"deletions":9,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @library \/test\/lib \/\n@@ -44,0 +45,1 @@\n+ * @library \/test\/lib \/\n@@ -54,0 +56,1 @@\n+ * @library \/test\/lib \/\n@@ -64,0 +67,1 @@\n+ * @library \/test\/lib \/\n@@ -74,0 +78,1 @@\n+ * @library \/test\/lib \/\n@@ -84,0 +89,1 @@\n+ * @library \/test\/lib \/\n@@ -101,0 +107,2 @@\n+import jdk.test.lib.Utils;\n+\n@@ -111,0 +119,2 @@\n+        final long startTime = System.currentTimeMillis();\n+\n@@ -120,3 +130,1 @@\n-                    System.out.println(info.getGcInfo().toString());\n-                    System.out.println(info.getGcName());\n-                    System.out.println();\n+                    System.out.println(\"Received: \" + info.getGcName());\n@@ -151,6 +159,3 @@\n-        \/\/ Wait until notifications start arriving, and then wait some more\n-        \/\/ to catch the ones arriving late.\n-        while (pausesDuration.get() == 0) {\n-            Thread.sleep(1000);\n-        }\n-        Thread.sleep(5000);\n+        \/\/ Look at test timeout to figure out how long we can wait without breaking into timeout.\n+        long spentTime = System.currentTimeMillis() - startTime;\n+        long maxTries = (Utils.adjustTimeout(Utils.DEFAULT_TEST_TIMEOUT) - spentTime) \/ 1000 \/ 2;\n@@ -158,2 +163,2 @@\n-        long pausesActual = pausesDuration.get();\n-        long cyclesActual = cyclesDuration.get();\n+        long actualPauses = 0;\n+        long actualCycles = 0;\n@@ -161,0 +166,1 @@\n+        \/\/ Wait until enough notifications are accrued to match minimum boundary.\n@@ -162,10 +168,0 @@\n-        long maxExpected = Long.MAX_VALUE;\n-\n-        {\n-            String msg = \"Pauses expected = [\" + minExpected + \"; \" + maxExpected + \"], actual = \" + pausesActual;\n-            if (minExpected <= pausesActual && pausesActual <= maxExpected) {\n-                System.out.println(msg);\n-            } else {\n-                throw new IllegalStateException(msg);\n-            }\n-        }\n@@ -173,6 +169,10 @@\n-        {\n-            String msg = \"Cycles expected = [\" + minExpected + \"; \" + maxExpected + \"], actual = \" + cyclesActual;\n-            if (minExpected <= cyclesActual && cyclesActual <= maxExpected) {\n-                System.out.println(msg);\n-            } else {\n-                throw new IllegalStateException(msg);\n+        long tries = 0;\n+        while (tries++ < maxTries) {\n+            actualPauses = pausesDuration.get();\n+            actualCycles = cyclesDuration.get();\n+            if (minExpected <= actualPauses && minExpected <= actualCycles) {\n+                \/\/ Wait a little bit to catch the lingering notifications.\n+                Thread.sleep(5000);\n+                actualPauses = pausesDuration.get();\n+                actualCycles = cyclesDuration.get();\n+                break;\n@@ -180,0 +180,1 @@\n+            Thread.sleep(1000);\n@@ -182,7 +183,8 @@\n-        {\n-            String msg = \"Cycle duration (\" + cyclesActual + \"), pause duration (\" + pausesActual + \")\";\n-            if (pausesActual <= cyclesActual) {\n-                System.out.println(msg);\n-            } else {\n-                throw new IllegalStateException(msg);\n-            }\n+        String msg = \"Pauses expected = [\" + minExpected + \"; +inf], actual = \" + actualPauses + \"\\n\" +\n+                     \"Cycles expected = [\" + minExpected + \"; +inf], actual = \" + actualCycles + \"\\n\" +\n+                     \"Pauses duration (\" + actualPauses + \") is expected to be smaller than cycles duration (\" + actualCycles + \")\";\n+\n+        if (minExpected <= actualPauses && minExpected <= actualCycles && actualPauses <= actualCycles) {\n+            System.out.println(msg);\n+        } else {\n+            throw new IllegalStateException(msg);\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/mxbeans\/TestPauseNotifications.java","additions":36,"deletions":34,"binary":false,"changes":70,"status":"modified"}]}