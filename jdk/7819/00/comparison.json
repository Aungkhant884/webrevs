{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8167108 8266130\n+ * @bug 8167108 8266130 8282704\n@@ -28,0 +28,1 @@\n+ * @modules java.base\/java.lang:open\n@@ -31,0 +32,1 @@\n+import java.lang.reflect.Method;\n@@ -41,0 +43,4 @@\n+    public StopAtExit(ThreadGroup group, Runnable target) {\n+        super(group, target);\n+    }\n+\n@@ -75,0 +81,2 @@\n+        long manualDestroyCnt = 0;\n+        long manualTerminateCnt = 0;\n@@ -79,1 +87,6 @@\n-            StopAtExit thread = new StopAtExit();\n+            \/\/ Use my own ThreadGroup so the thread count is known and make\n+            \/\/ it a daemon ThreadGroup so it is automatically destroyed when\n+            \/\/ the thread is terminated.\n+            ThreadGroup myTG = new ThreadGroup(\"myTG-\" + count);\n+            myTG.setDaemon(true);\n+            StopAtExit thread = new StopAtExit(myTG, null);\n@@ -110,0 +123,2 @@\n+            \/\/ This stop() call happens after the join() so it should do\n+            \/\/ nothing, but let's make sure.\n@@ -111,0 +126,33 @@\n+\n+            if (myTG.activeCount() != 0) {\n+                \/\/ If the ThreadGroup still has a count, then the thread\n+                \/\/ received the async exception while in exit() so we need\n+                \/\/ to do a manual terminate.\n+                manualTerminateCnt++;\n+                try {\n+                    threadTerminated(myTG, thread);\n+                } catch (Exception e) {\n+                    throw new Error(\"threadTerminated() threw unexpected: \" + e);\n+                }\n+                int activeCount = myTG.activeCount();\n+                if (activeCount != 0) {\n+                    throw new Error(\"threadTerminated() did not clean up \" +\n+                                    \"worker thread: count=\" + activeCount);\n+                }\n+                if (!myTG.isDestroyed()) {\n+                    throw new Error(\"threadTerminated() did not destroy \" +\n+                                    myTG.getName());\n+                }\n+            } else if (!myTG.isDestroyed()) {\n+                \/\/ If the ThreadGroup does not have a count, but is not\n+                \/\/ yet destroyed, then the thread received the async\n+                \/\/ exception while the thread was in the later stages of\n+                \/\/ its threadTerminated() call so we need to do a manual\n+                \/\/ destroy.\n+                manualDestroyCnt++;\n+                try {\n+                    myTG.destroy();\n+                } catch (Exception e) {\n+                    throw new Error(\"myTG.destroy() threw unexpected: \" + e);\n+                }\n+            }\n@@ -113,0 +161,8 @@\n+        if (manualDestroyCnt != 0) {\n+            System.out.println(\"Manually destroyed ThreadGroup \" +\n+                               manualDestroyCnt + \" times.\");\n+        }\n+        if (manualTerminateCnt != 0) {\n+            System.out.println(\"Manually terminated Thread \" +\n+                               manualTerminateCnt + \" times.\");\n+        }\n@@ -123,0 +179,7 @@\n+    static void threadTerminated(ThreadGroup group, Thread thread) throws Exception {\n+        \/\/ ThreadGroup.threadTerminated() is package private:\n+        Method method = ThreadGroup.class.getDeclaredMethod(\"threadTerminated\", Thread.class);\n+        method.setAccessible(true);\n+        method.invoke(group, thread);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/StopAtExit.java","additions":66,"deletions":3,"binary":false,"changes":69,"status":"modified"}]}