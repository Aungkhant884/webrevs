{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,0 @@\n-import java.util.Arrays;\n-import java.util.Comparator;\n@@ -53,5 +51,0 @@\n-    private static final int DEFAULT_REFRESH_TIME = 240;  \/\/ 4 minutes\n-    private static final int MINIMUM_REFRESH_TIME = 120;  \/\/ 2 minutes\n-    private static final boolean pollServices;\n-    private static final int refreshTime;\n-\n@@ -59,19 +52,0 @@\n-        \/* The system property \"sun.java2d.print.polling\"\n-         * can be used to force the printing code to poll or not poll\n-         * for PrintServices.\n-         *\/\n-        String pollStr = java.security.AccessController.doPrivileged(\n-            new sun.security.action.GetPropertyAction(\"sun.java2d.print.polling\"));\n-        pollServices = !(\"false\".equalsIgnoreCase(pollStr));\n-\n-        \/* The system property \"sun.java2d.print.minRefreshTime\"\n-         * can be used to specify minimum refresh time (in seconds)\n-         * for polling PrintServices.  The default is 240.\n-         *\/\n-        String refreshTimeStr = java.security.AccessController.doPrivileged(\n-            new sun.security.action.GetPropertyAction(\n-                \"sun.java2d.print.minRefreshTime\"));\n-        refreshTime = (refreshTimeStr != null)\n-                      ? getRefreshTime(refreshTimeStr)\n-                      : DEFAULT_REFRESH_TIME;\n-\n@@ -87,11 +61,0 @@\n-    private static int getRefreshTime(final String refreshTimeStr) {\n-        try {\n-            int minRefreshTime = Integer.parseInt(refreshTimeStr);\n-            return (minRefreshTime < MINIMUM_REFRESH_TIME)\n-                   ? MINIMUM_REFRESH_TIME\n-                   : minRefreshTime;\n-        } catch (NumberFormatException e) {\n-            return DEFAULT_REFRESH_TIME;\n-        }\n-    }\n-\n@@ -129,7 +92,5 @@\n-            if (pollServices) {\n-                \/\/ start the remote printer listener thread\n-                Thread remThr = new Thread(null, new RemotePrinterChangeListener(),\n-                                           \"RemotePrinterListener\", 0, false);\n-                remThr.setDaemon(true);\n-                remThr.start();\n-            }\n+            \/\/ start the remote printer listener thread\n+            Thread remThr = new Thread(null, new RemotePrinterChangeListener(),\n+                                       \"RemotePrinterListener\", 0, false);\n+            remThr.setDaemon(true);\n+            remThr.start();\n@@ -359,30 +320,1 @@\n-    \/* Windows provides *PrinterChangeNotification* functions that provides\n-       information about printer status changes of the local printers but not\n-       network printers.\n-       Alternatively, Windows provides a way through which one can get the\n-       network printer status changes by using WMI, RegistryKeyChange combination,\n-       which is a slightly complex mechanism.\n-       The Windows WMI offers an async and sync method to read through registry\n-       via the WQL query. The async method is considered dangerous as it leaves\n-       open a channel until we close it. But the async method has the advantage of\n-       being notified of a change in registry by calling callback without polling for it.\n-       The sync method uses the polling mechanism to notify.\n-       RegistryValueChange cannot be used in combination with WMI to get registry\n-       value change notification because of an error that may be generated because the\n-       scope of the query would be too big to handle(at times).\n-       Hence an alternative mechanism is chosen via the EnumPrinters by polling for the\n-       count of printer status changes(add\\remove) and based on it update the printers\n-       list.\n-    *\/\n-    class RemotePrinterChangeListener implements Comparator<String>, Runnable {\n-\n-        RemotePrinterChangeListener() {\n-        }\n-\n-        @Override\n-        public int compare(String o1, String o2) {\n-            return ((o1 == null)\n-                    ? ((o2 == null) ? 0 : 1)\n-                    : ((o2 == null) ? -1 : o1.compareTo(o2)));\n-        }\n-\n+    private final class RemotePrinterChangeListener implements Runnable {\n@@ -391,27 +323,1 @@\n-            \/\/ Init the list of remote printers\n-            String[] prevRemotePrinters = getRemotePrintersNames();\n-            if (prevRemotePrinters != null) {\n-                Arrays.sort(prevRemotePrinters, this);\n-            }\n-\n-            while (true) {\n-                try {\n-                    Thread.sleep(refreshTime * 1000);\n-                } catch (InterruptedException e) {\n-                    break;\n-                }\n-\n-                String[] currentRemotePrinters = getRemotePrintersNames();\n-                if (currentRemotePrinters != null) {\n-                    Arrays.sort(currentRemotePrinters, this);\n-                }\n-                if (!Arrays.equals(prevRemotePrinters, currentRemotePrinters)) {\n-                    \/\/ The list of remote printers got updated,\n-                    \/\/ so update the cached list printers which\n-                    \/\/ includes both local and network printers\n-                    refreshServices();\n-\n-                    \/\/ store the current data for next comparison\n-                    prevRemotePrinters = currentRemotePrinters;\n-                }\n-            }\n+            notifyRemotePrinterChange(); \/\/ busy loop in the native code\n@@ -424,1 +330,1 @@\n-    private native String[] getRemotePrintersNames();\n+    private native void notifyRemotePrinterChange();\n","filename":"src\/java.desktop\/windows\/classes\/sun\/print\/PrintServiceLookupProvider.java","additions":9,"deletions":103,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -194,6 +194,0 @@\n-JNIEXPORT jobjectArray JNICALL\n-Java_sun_print_PrintServiceLookupProvider_getRemotePrintersNames(JNIEnv *env,\n-                                                                 jobject peer)\n-{\n-    return getPrinterNames(env, PRINTER_ENUM_CONNECTIONS);\n-}\n@@ -242,0 +236,31 @@\n+JNIEXPORT void JNICALL\n+Java_sun_print_PrintServiceLookupProvider_notifyRemotePrinterChange(JNIEnv *env,\n+                                                                    jobject peer)\n+{\n+    jclass cls = env->GetObjectClass(peer);\n+    CHECK_NULL(cls);\n+    jmethodID refresh = env->GetMethodID(cls, \"refreshServices\", \"()V\");\n+    CHECK_NULL(refresh);\n+\n+    HKEY hKey;\n+    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_CURRENT_USER,\n+                                      _T(\"Printers\\\\Connections\"),\n+                                      0, KEY_NOTIFY, &hKey)) {\n+        return;\n+    }\n+\n+    BOOL keepMonitoring;\n+    do {\n+        keepMonitoring =\n+                ERROR_SUCCESS == RegNotifyChangeKeyValue(hKey, TRUE,\n+                                                         REG_NOTIFY_CHANGE_NAME,\n+                                                         NULL,\n+                                                         FALSE);\n+        if (keepMonitoring) {\n+            env->CallVoidMethod(peer, refresh);\n+        }\n+    } while (keepMonitoring && !env->ExceptionCheck());\n+\n+    RegCloseKey(hKey);\n+}\n+\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/WPrinterJob.cpp","additions":31,"deletions":6,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8153732 8212202 8221263 8221412 8222108\n+ * @bug 8153732 8212202 8221263 8221412 8222108 8263311\n@@ -29,1 +29,1 @@\n- * @run main\/manual\/othervm -Dsun.java2d.print.minRefreshTime=120 RemotePrinterStatusRefresh\n+ * @run main\/manual RemotePrinterStatusRefresh\n@@ -66,6 +66,1 @@\n-    private static final long DEFAULT_REFRESH_TIME = 240L;\n-    private static final long MINIMAL_REFRESH_TIME = 120L;\n-\n-    private static final long refreshTime = getRefreshTime();\n-\n-    private static final long TIMEOUT = refreshTime * 4 + 60;\n+    private static final long TIMEOUT = 15L * 60;\n@@ -89,1 +84,0 @@\n-    private JTextField nextRefresh;\n@@ -187,4 +181,1 @@\n-                    + \"Step 2: Wait for 2\\u20134 minutes after adding or removing.\\n\"\n-                    + \"             \\\"Next printer refresh in\\\" gives you a \"\n-                    +          \"rough estimation on when update will happen.\\n\"\n-                    + \"Step 3: Click Refresh.\"\n+                    + \"Step 2: Click Refresh.\"\n@@ -193,1 +184,1 @@\n-                    + \"Step 4: Compare the list of printers in \\\"Before\\\" and \"\n+                    + \"Step 3: Compare the list of printers in \\\"Before\\\" and \"\n@@ -198,1 +189,1 @@\n-                    + \"Step 5: Click Pass if the list of printers is correctly \"\n+                    + \"Step 4: Click Pass if the list of printers is correctly \"\n@@ -200,3 +191,2 @@\n-                    + \"Step 6: If the list is not updated, wait for another \"\n-                    +          \"2\\u20134 minutes, and then click Refresh again.\\n\"\n-                    + \"Step 7: If the list does not update, click Fail.\\n\"\n+                    + \"Step 5: If the list is not updated, click Refresh again.\\n\"\n+                    + \"Step 6: If the list does not update, click Fail.\\n\"\n@@ -219,12 +209,0 @@\n-    private static long getRefreshTime() {\n-        String refreshTime =\n-                System.getProperty(\"sun.java2d.print.minRefreshTime\",\n-                                   Long.toString(DEFAULT_REFRESH_TIME));\n-        try {\n-            long value = Long.parseLong(refreshTime);\n-            return value < MINIMAL_REFRESH_TIME ? MINIMAL_REFRESH_TIME : value;\n-        } catch (NumberFormatException e) {\n-            return DEFAULT_REFRESH_TIME;\n-        }\n-    }\n-\n@@ -281,25 +259,0 @@\n-        JLabel refreshTimeLabel = new JLabel(\"Refresh interval:\");\n-        long minutes = refreshTime \/ 60;\n-        long seconds = refreshTime % 60;\n-        String interval = String.format(\"%1$d seconds%2$s\",\n-                refreshTime,\n-                minutes > 0\n-                    ? String.format(\" (%1$d %2$s%3$s)\",\n-                        minutes,\n-                        minutes > 1 ? \"minutes\" : \"minute\",\n-                        seconds > 0\n-                            ? String.format(\" %1$d %2$s\",\n-                                seconds,\n-                                seconds > 1 ? \"seconds\" : \"second\")\n-                            : \"\")\n-                    : \"\"\n-        );\n-        JTextField refreshInterval = new JTextField(interval);\n-        refreshInterval.setEditable(false);\n-        refreshTimeLabel.setLabelFor(refreshInterval);\n-\n-        JLabel nextRefreshLabel = new JLabel(\"Next printer refresh in:\");\n-        nextRefresh = new JTextField();\n-        nextRefresh.setEditable(false);\n-        nextRefreshLabel.setLabelFor(nextRefresh);\n-\n@@ -320,2 +273,0 @@\n-                    .addComponent(refreshTimeLabel)\n-                    .addComponent(nextRefreshLabel)\n@@ -326,2 +277,0 @@\n-                    .addComponent(refreshInterval)\n-                    .addComponent(nextRefresh)\n@@ -337,6 +286,0 @@\n-                .addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE)\n-                    .addComponent(refreshTimeLabel)\n-                    .addComponent(refreshInterval))\n-                .addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE)\n-                    .addComponent(nextRefreshLabel)\n-                    .addComponent(nextRefresh))\n@@ -496,1 +439,0 @@\n-        nextRefresh.setText(formatTime(refreshTime - (elapsed % refreshTime)));\n","filename":"test\/jdk\/java\/awt\/print\/RemotePrinterStatusRefresh\/RemotePrinterStatusRefresh.java","additions":9,"deletions":67,"binary":false,"changes":76,"status":"modified"}]}