{"files":[{"patch":"@@ -375,1 +375,0 @@\n-     * @param lenByte the length of the length field to remember\n@@ -381,1 +380,1 @@\n-    public static byte[] convertStream(InputStream in, byte lenByte, byte tag)\n+    public static byte[] convertStream(InputStream in, byte tag)\n@@ -387,1 +386,1 @@\n-        indefData[1] = lenByte;\n+        indefData[1] = (byte)0x80;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DerIndefLenConverter.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -61,2 +61,2 @@\n-    final int start;\n-    final int end;\n+    final int start;    \/\/ inclusive\n+    final int end;      \/\/ exclusive\n@@ -69,0 +69,6 @@\n+    \/**\n+     * Constructs a DerInputStream by assigning all its fields.\n+     *\n+     * No checking on arguments since all callers are internal.\n+     * {@code data} should never be null even if length is 0.\n+     *\/\n@@ -78,4 +84,0 @@\n-    public DerInputStream(DerValue v) {\n-        this(v.buffer, v.start, v.end - v.start, v.allowBER);\n-    }\n-\n@@ -90,0 +92,3 @@\n+    \/**\n+     * Returns the remaining unread bytes, or, all bytes if none read yet.\n+     *\/\n@@ -95,2 +100,3 @@\n-     * Reads a DerValue from this stream. After the call, the data pointer is right after\n-     * this DerValue so that the next call will read the next DerValue.\n+     * Reads a DerValue from this stream. After the call, the data pointer\n+     * is right after this DerValue so that the next call will read the\n+     * next DerValue.\n@@ -99,2 +105,2 @@\n-     * @throws IOException if a DerValue cannot be constructed starting from this position\n-     *                     because of byte shortage or encoding error.\n+     * @throws IOException if a DerValue cannot be constructed starting from\n+     *      this position because of byte shortage or encoding error.\n@@ -105,1 +111,9 @@\n-        this.pos = result.end;\n+        if (result.buffer != this.data) {\n+            \/\/ Indefinite length observed. Unused bytes in data are appended\n+            \/\/ to the end of return value by DerIndefLenConverter::convertBytes\n+            \/\/ and stay inside result.buffer.\n+            int unused = result.buffer.length - result.end;\n+            this.pos = this.data.length - unused;\n+        } else {\n+            this.pos = result.end;\n+        }\n@@ -207,4 +221,0 @@\n-    static int getLength(InputStream in) throws IOException {\n-        return getLength(in.read(), in);\n-    }\n-\n@@ -215,2 +225,0 @@\n-     * @param lenByte\n-     *\n@@ -220,2 +228,2 @@\n-    static int getLength(int lenByte, InputStream in) throws IOException {\n-        int value, tmp;\n+    static int getLength(InputStream in) throws IOException {\n+        int lenByte = in.read();\n@@ -225,0 +233,3 @@\n+        if (lenByte == 0x80) {\n+            return -1;\n+        }\n@@ -226,0 +237,1 @@\n+        int value, tmp;\n@@ -233,7 +245,2 @@\n-            \/*\n-             * NOTE:  tmp == 0 indicates indefinite length encoded data.\n-             * tmp > 4 indicates more than 4Gb of data.\n-             *\/\n-            if (tmp == 0)\n-                return -1;\n-            if (tmp < 0 || tmp > 4)\n+            \/\/ tmp > 4 indicates more than 4Gb of data.\n+            if (tmp < 0 || tmp > 4) {\n@@ -241,1 +248,2 @@\n-                    + ((tmp < 0) ? \"incorrect DER encoding.\" : \"too big.\"));\n+                        + ((tmp < 0) ? \"incorrect DER encoding.\" : \"too big.\"));\n+            }\n@@ -279,0 +287,2 @@\n+     * The {@code readAheadLimit} is useless here because\n+     * all data is available and we can go to anywhere at will.\n@@ -280,1 +290,1 @@\n-    public void mark(int value) { mark = pos; }\n+    public void mark(int readAheadLimit) { mark = pos; }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DerInputStream.java","additions":38,"deletions":28,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-\/**\n+\/*\n@@ -155,1 +155,1 @@\n-    \/\/ This class is 99% immutable except that:\n+    \/\/ This class is mostly immutable except that:\n@@ -158,1 +158,4 @@\n-    \/\/ 2. reading from the data field advances the internal position\n+    \/\/ 2. the data field is mutable\n+    \/\/\n+    \/\/ For compatibility, data, getData() and resetTag() are preserved.\n+    \/\/ A modern caller should call withTag() or data() instead.\n@@ -160,2 +163,2 @@\n-    \/\/ For compatibility, data and resetTag() are preserved. A modern caller\n-    \/\/ should call withTag() or data() instead (do not use the data field).\n+    \/\/ Also, some constructors have not cloned buffer, so the data could\n+    \/\/ be modified externally.\n@@ -165,1 +168,1 @@\n-    final int start;\n+    private final int start;\n@@ -167,1 +170,1 @@\n-    final boolean allowBER;\n+    private final boolean allowBER;\n@@ -226,1 +229,1 @@\n-        this.data = new DerInputStream(this);\n+        this.data = data();\n@@ -294,1 +297,1 @@\n-     * Parse an ASN.1\/BER encoded datum from a byte array.\n+     * Parse an ASN.1 encoded datum from a byte array.\n@@ -301,1 +304,1 @@\n-     *                  If true, {@code len} can be bigger than the length og\n+     *                  If true, {@code len} can be bigger than the length of\n@@ -305,1 +308,1 @@\n-     *                     after the encoded datum but {@code allowMore} is false.\n+     *                     after the encoded datum and {@code allowMore} is false.\n@@ -318,32 +321,1 @@\n-        if (lenByte == (byte)0x80) {\n-            length = -1;\n-        } else if ((lenByte & 0x080) == 0x00) { \/\/ short form, 1 byte datum\n-            length = lenByte;\n-        } else {                     \/\/ long form or indefinite\n-            lenByte &= 0x07f;\n-            if (lenByte == 0) {\n-                length = -1;\n-            } else if (lenByte < 0 || lenByte > 4) {\n-                throw new IOException(\"Invalid lenByte\");\n-            } else {\n-                if (len < 2 + lenByte) {\n-                    throw new IOException(\"Not enough length bytes\");\n-                }\n-                length = 0x0ff & buf[pos++];\n-                lenByte--;\n-                if (length == 0 && !allowBER) {\n-                    \/\/ DER requires length value be encoded in minimum number of bytes\n-                    throw new IOException(\"Redundant length bytes found\");\n-                }\n-                while (lenByte-- > 0) {\n-                    length <<= 8;\n-                    length += 0x0ff & buf[pos++];\n-                }\n-                if (length < 0) {\n-                    throw new IOException(\"Invalid length bytes\");\n-                } else if (length <= 127 && !allowBER) {\n-                    throw new IOException(\"Should use short form for length\");\n-                }\n-            }\n-        }\n-        if (length == -1) { \/\/ indefinite length encoding found\n+        if (lenByte == (byte) 0x80) { \/\/ indefinite length\n@@ -358,7 +330,10 @@\n-            InputStream in = new ByteArrayInputStream(\n-                    DerIndefLenConverter.convertStream(\n-                            new ByteArrayInputStream(buf, pos, len - (pos - offset)),\n-                            (byte)lenByte, tag));\n-            if (tag != in.read()) {\n-                throw new IOException\n-                        (\"Indefinite length encoding not supported\");\n+\n+            \/\/ Reconstruct data source\n+            buf = DerIndefLenConverter.convertStream(\n+                    new ByteArrayInputStream(buf, pos, len - (pos - offset)), tag);\n+            offset = 0;\n+            len = buf.length;\n+            pos = 2;\n+\n+            if (tag != buf[0]) {\n+                throw new IOException(\"Indefinite length encoding not supported\");\n@@ -366,7 +341,12 @@\n-            length = DerInputStream.getDefiniteLength(in);\n-            this.buffer = IOUtils.readExactlyNBytes(in, length);\n-            this.start = 0;\n-            this.end = length;\n-        } else {\n-            if (len - length < pos - offset) {\n-                throw new EOFException(\"Too little\");\n+            lenByte = buf[1];\n+            if (lenByte == (byte) 0x80) {\n+                throw new IOException(\"Indefinite len conversion failed\");\n+            }\n+        }\n+\n+        if ((lenByte & 0x080) == 0x00) { \/\/ short form, 1 byte datum\n+            length = lenByte;\n+        } else {                     \/\/ long form\n+            lenByte &= 0x07f;\n+            if (lenByte < 0 || lenByte > 4) {\n+                throw new IOException(\"Invalid lenByte\");\n@@ -374,2 +354,2 @@\n-            if (len - length > pos - offset && !allowMore) {\n-                throw new IOException(\"Too much\");\n+            if (len < 2 + lenByte) {\n+                throw new IOException(\"Not enough length bytes\");\n@@ -377,3 +357,22 @@\n-            this.buffer = buf;\n-            this.start = pos;\n-            this.end = pos + length;\n+            length = 0x0ff & buf[pos++];\n+            lenByte--;\n+            if (length == 0 && !allowBER) {\n+                \/\/ DER requires length value be encoded in minimum number of bytes\n+                throw new IOException(\"Redundant length bytes found\");\n+            }\n+            while (lenByte-- > 0) {\n+                length <<= 8;\n+                length += 0x0ff & buf[pos++];\n+            }\n+            if (length < 0) {\n+                throw new IOException(\"Invalid length bytes\");\n+            } else if (length <= 127 && !allowBER) {\n+                throw new IOException(\"Should use short form for length\");\n+            }\n+        }\n+        \/\/ pos is now at the beginning of the content\n+        if (len - length < pos - offset) {\n+            throw new EOFException(\"not enough content\");\n+        }\n+        if (len - length > pos - offset && !allowMore) {\n+            throw new IOException(\"extra data at the end\");\n@@ -381,0 +380,3 @@\n+        this.buffer = buf;\n+        this.start = pos;\n+        this.end = pos + length;\n@@ -382,1 +384,1 @@\n-        this.data = new DerInputStream(this);\n+        this.data = data();\n@@ -389,2 +391,1 @@\n-        byte lenByte = (byte)in.read();\n-        int length = DerInputStream.getLength(lenByte, in);\n+        int length = DerInputStream.getLength(in);\n@@ -400,3 +401,3 @@\n-            in = new ByteArrayInputStream(\n-                    DerIndefLenConverter.convertStream(in, lenByte, tag));\n-            if (tag != in.read())\n+            this.buffer = DerIndefLenConverter.convertStream(in, tag);\n+            ByteArrayInputStream bin = new ByteArrayInputStream(this.buffer);\n+            if (tag != bin.read()) {\n@@ -405,1 +406,12 @@\n-            length = DerInputStream.getDefiniteLength(in);\n+            }\n+            length = DerInputStream.getDefiniteLength(bin);\n+            this.start = this.buffer.length - bin.available();\n+            this.end = this.start + length;\n+            \/\/ position of in is undetermined. Precisely, it might be n-bytes\n+            \/\/ after DerValue, and these n bytes are at the end of this.buffer\n+            \/\/ after this.end.\n+        } else {\n+            this.buffer = IOUtils.readExactlyNBytes(in, length);\n+            this.start = 0;\n+            this.end = length;\n+            \/\/ position of in is right after the DerValue\n@@ -407,3 +419,0 @@\n-        this.buffer = IOUtils.readExactlyNBytes(in, length);\n-        this.start = 0;\n-        this.end = length;\n@@ -411,1 +420,1 @@\n-        this.data = new DerInputStream(this);\n+        this.data = data();\n@@ -418,1 +427,2 @@\n-     * must hold only one datum.\n+     * must hold only one datum, i.e. all bytes in the stream might\n+     * be consumed. Otherwise, only one DerValue will be consumed.\n@@ -438,1 +448,2 @@\n-     * Returns a new DerInputStream pointing at the start of buffer.\n+     * Returns a new DerInputStream pointing at the start of this\n+     * DerValue's content.\n@@ -443,1 +454,1 @@\n-        return new DerInputStream(this);\n+        return new DerInputStream(buffer, start, end - start, allowBER);\n@@ -446,0 +457,10 @@\n+    \/**\n+     * Returns the data field inside this class. This method should be\n+     * avoided because the data field is mutable but every call always\n+     * return the same object. The caller had better directly use the\n+     * data field. A better way is to call data() that will always return\n+     * a new DerInputStream that points to the beginning of the content.\n+     *\n+     * Both this method and the {@link #data} field should be avoided.\n+     * Consider using {@link #data()} instead.\n+     *\/\n@@ -506,1 +527,1 @@\n-            DerInputStream dis = new DerInputStream(this);\n+            DerInputStream dis = data();\n@@ -520,1 +541,5 @@\n-        BigInteger result = getBigInteger();\n+        return getIntegerInternal(tag_Integer);\n+    }\n+\n+    private int getIntegerInternal(byte expectedTag) throws IOException {\n+        BigInteger result = getBigIntegerInternal(expectedTag, false);\n@@ -536,1 +561,1 @@\n-        return getBigIntegerInternal(false);\n+        return getBigIntegerInternal(tag_Integer, false);\n@@ -547,1 +572,1 @@\n-        return getBigIntegerInternal(true);\n+        return getBigIntegerInternal(tag_Integer, true);\n@@ -557,3 +582,3 @@\n-    private BigInteger getBigIntegerInternal(boolean makePositive) throws IOException {\n-        if (tag != tag_Integer) {\n-            throw new IOException(\"DerValue.getBigInteger, not an int \" + tag);\n+    private BigInteger getBigIntegerInternal(byte expectedTag, boolean makePositive) throws IOException {\n+        if (tag != expectedTag) {\n+            throw new IOException(\"DerValue.getBigIntegerInternal, not expected \" + tag);\n@@ -579,6 +604,1 @@\n-        if (tag != tag_Enumerated) {\n-            throw new IOException(\"DerValue.getEnumerated, incorrect tag: \"\n-                                  + tag);\n-        }\n-        \/\/ TODO\n-        return new BigInteger(1, buffer, start, end - start).intValue();\n+        return getIntegerInternal(tag_Enumerated);\n@@ -638,1 +658,1 @@\n-            throw new IOException(\"No padding\");\n+            throw new IOException(\"Invalid encoding: zero length bit string\");\n@@ -670,1 +690,1 @@\n-            throw new IOException(\"No padding\");\n+            throw new IOException(\"Invalid encoding: zero length bit string\");\n@@ -673,0 +693,4 @@\n+        int numOfPadBits = buffer[start];\n+        if ((numOfPadBits < 0) || (numOfPadBits > 7)) {\n+            throw new IOException(\"Invalid number of padding bits\");\n+        }\n@@ -676,5 +700,1 @@\n-            int numOfPadBits = buffer[start];\n-            if ((numOfPadBits < 0) || (numOfPadBits > 7)) {\n-                throw new IOException(\"Invalid number of padding bits\");\n-            }\n-            return new BitArray((end - start - 1) * 8 - numOfPadBits,\n+            return new BitArray(((end - start - 1) << 3) - numOfPadBits,\n@@ -764,2 +784,1 @@\n-     * this value or an empty string if UTF_32BE is not a supported character\n-     * set.\n+     * this value\n@@ -771,0 +790,12 @@\n+    \/**\n+     * Reads the ASN.1 NULL value\n+     *\/\n+    public void getNull() throws IOException {\n+        if (tag != tag_Null) {\n+            throw new IOException(\"DerValue.getNull, not NULL: \" + tag);\n+        }\n+        if (end != start) {\n+            throw new IOException(\"NULL should contain no data\");\n+        }\n+    }\n+\n@@ -773,1 +804,0 @@\n-     * @param len the number of bytes to use\n@@ -777,1 +807,1 @@\n-    private Date getTime(int len, boolean generalized) throws IOException {\n+    private Date getTimeInternal(boolean generalized) throws IOException {\n@@ -800,0 +830,1 @@\n+        int len = end - start;\n@@ -969,9 +1000,0 @@\n-    public void getNull() throws IOException {\n-        if (tag != tag_Null) {\n-            throw new IOException(\"DerValue.getUTCTime, not a UtcTime: \" + tag);\n-        }\n-        if (end != start) {\n-            throw new IOException(\"DER UTC Time length error\");\n-        }\n-    }\n-\n@@ -991,1 +1013,1 @@\n-        return getTime(end - start, false);\n+        return getTimeInternal(false);\n@@ -1008,1 +1030,1 @@\n-        return getTime(end - start, true);\n+        return getTimeInternal(true);\n@@ -1043,1 +1065,1 @@\n-        return String.format(\"DerValue(%02x, %s, %d, 5d)\",\n+        return String.format(\"DerValue(%02x, %s, %d, %d)\",\n@@ -1142,0 +1164,2 @@\n+     * This method should be avoided, consider using withTag() instead.\n+     *\n@@ -1149,1 +1173,3 @@\n-     * Returns a new DerValuw with a different tag.\n+     * Returns a new DerValue with a different tag. This method is used\n+     * to convert a DerValue decoded from an IMPLICIT encoding to its real\n+     * tag. The content is not checked against the tag in this method.\n@@ -1172,0 +1198,8 @@\n+    \/**\n+     * Reads the sub-values in a constructed DerValue.\n+     *\n+     * @param expectedTag the expected tag, or zero if we don't check.\n+     *                    This is useful when this DerValue is IMPLICIT.\n+     * @param startLen estimated number of sub-values\n+     * @return the sub-values in an array\n+     *\/\n@@ -1177,1 +1211,1 @@\n-        DerInputStream dis = new DerInputStream(this);\n+        DerInputStream dis = data();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DerValue.java","additions":148,"deletions":114,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @library \/test\/lib\n@@ -32,0 +33,1 @@\n+import java.lang.reflect.Field;\n@@ -34,0 +36,3 @@\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.hexdump.HexPrinter;\n@@ -39,8 +44,55 @@\n-        byte[] input = {\n-            \/\/ An OCTET-STRING in 2 parts\n-            0x24, (byte)0x80, 4, 2, 'a', 'b', 4, 2, 'c', 'd', 0, 0,\n-            \/\/ Garbage follows, may be falsely recognized as EOC\n-            0, 0, 0, 0\n-        };\n-        DerValue v = new DerValue(new ByteArrayInputStream(input));\n-        System.out.println(Arrays.toString(v.getOctetString()));\n+\n+        \/\/ Indefinite length with trailing bytes\n+        test(true, new byte[] {\n+                \/\/ An OCTET-STRING in 2 parts\n+                0x24, (byte) 0x80, 4, 2, 'a', 'b', 4, 2, 'c', 'd', 0, 0,\n+                \/\/ Garbage follows, may be falsely recognized as EOC\n+                0, 0, 0, 0,\n+                \/\/ and more\n+                7, 8, 9, 10});\n+\n+        \/\/ Definite length with trailing bytes\n+        test(false, new byte[] {\n+                4, 4, 'a', 'b', 'c', 'd',\n+                0, 0, 0, 0, 7, 8, 9, 10 });\n+    }\n+\n+    static void test(boolean indefinite, byte[] input) throws Exception {\n+\n+        \/\/ 1. parse stream\n+        InputStream ins = new ByteArrayInputStream(input);\n+        DerValue v = new DerValue(ins);\n+        Asserts.assertEQ(new String(v.getOctetString()), \"abcd\");\n+\n+        if (indefinite) {\n+            \/\/ Trailing bytes might be consumed by the conversion but can\n+            \/\/ be found in DerValue \"after end\".\n+            Field buffer = DerValue.class.getDeclaredField(\"buffer\");\n+            Field end = DerValue.class.getDeclaredField(\"end\");\n+            buffer.setAccessible(true);\n+            end.setAccessible(true);\n+            int bufferLen = ((byte[])buffer.get(v)).length;\n+            int endPos = end.getInt(v);\n+            \/\/ Data \"after end\": bufferLen - endPos\n+            \/\/ Data remained in stream: ins.available()x`\n+            Asserts.assertEQ(bufferLen - endPos + ins.available(), 8);\n+        } else {\n+            \/\/ Trailing bytes remain in the stream for definite length\n+            Asserts.assertEQ(ins.available(), 8);\n+        }\n+\n+        \/\/ 2. parse DerInputStream\n+        DerInputStream ds = new DerInputStream(input);\n+        Asserts.assertEQ(new String(ds.getDerValue().getOctetString()), \"abcd\");\n+        Asserts.assertEQ(ds.available(), 8);\n+        Asserts.assertTrue(Arrays.equals(ds.toByteArray(),\n+                new byte[]{0,0,0,0,7,8,9,10}));\n+\n+        \/\/ 3. Parse full byte array\n+        Utils.runAndCheckException(() -> new DerValue(input),\n+                e -> Asserts.assertTrue(e instanceof IOException\n+                        && e.getMessage().equals(\"extra data at the end\")));\n+\n+        \/\/ 4. Parse exact byte array\n+        Asserts.assertEQ(new String(new DerValue(Arrays.copyOf(input, input.length - 8))\n+                .getOctetString()), \"abcd\");\n","filename":"test\/jdk\/sun\/security\/util\/DerValue\/Indefinite.java","additions":60,"deletions":8,"binary":false,"changes":68,"status":"modified"}]}