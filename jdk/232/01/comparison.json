{"files":[{"patch":"@@ -1,475 +0,0 @@\n-\/*\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.security.util;\n-\n-import java.io.ByteArrayInputStream;\n-import java.io.IOException;\n-import java.math.BigInteger;\n-import java.util.Date;\n-import sun.util.calendar.CalendarDate;\n-import sun.util.calendar.CalendarSystem;\n-\n-\/**\n- * DER input buffer ... this is the main abstraction in the DER library\n- * which actively works with the \"untyped byte stream\" abstraction.  It\n- * does so with impunity, since it's not intended to be exposed to\n- * anyone who could violate the \"typed value stream\" DER model and hence\n- * corrupt the input stream of DER values.\n- *\n- * @author David Brownell\n- *\/\n-class DerInputBuffer extends ByteArrayInputStream implements Cloneable {\n-\n-    boolean allowBER = true;\n-\n-    \/\/ used by sun\/security\/util\/DerInputBuffer\/DerInputBufferEqualsHashCode.java\n-    DerInputBuffer(byte[] buf) {\n-        this(buf, true);\n-    }\n-\n-    DerInputBuffer(byte[] buf, boolean allowBER) {\n-        super(buf);\n-        this.allowBER = allowBER;\n-    }\n-\n-    DerInputBuffer(byte[] buf, int offset, int len, boolean allowBER) {\n-        super(buf, offset, len);\n-        this.allowBER = allowBER;\n-    }\n-\n-    DerInputBuffer dup() {\n-        try {\n-            DerInputBuffer retval = (DerInputBuffer)clone();\n-            retval.mark(Integer.MAX_VALUE);\n-            return retval;\n-        } catch (CloneNotSupportedException e) {\n-            throw new IllegalArgumentException(e.toString());\n-        }\n-    }\n-\n-    byte[] toByteArray() {\n-        int     len = available();\n-        if (len <= 0)\n-            return null;\n-        byte[]  retval = new byte[len];\n-\n-        System.arraycopy(buf, pos, retval, 0, len);\n-        return retval;\n-    }\n-\n-    int peek() throws IOException {\n-        if (pos >= count)\n-            throw new IOException(\"out of data\");\n-        else\n-            return buf[pos];\n-    }\n-\n-    \/**\n-     * Compares this DerInputBuffer for equality with the specified\n-     * object.\n-     *\/\n-    public boolean equals(Object other) {\n-        if (other instanceof DerInputBuffer)\n-            return equals((DerInputBuffer)other);\n-        else\n-            return false;\n-    }\n-\n-    boolean equals(DerInputBuffer other) {\n-        if (this == other)\n-            return true;\n-\n-        int max = this.available();\n-        if (other.available() != max)\n-            return false;\n-        for (int i = 0; i < max; i++) {\n-            if (this.buf[this.pos + i] != other.buf[other.pos + i]) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    \/**\n-     * Returns a hashcode for this DerInputBuffer.\n-     *\n-     * @return a hashcode for this DerInputBuffer.\n-     *\/\n-    public int hashCode() {\n-        int retval = 0;\n-\n-        int len = available();\n-        int p = pos;\n-\n-        for (int i = 0; i < len; i++)\n-            retval += buf[p + i] * i;\n-        return retval;\n-    }\n-\n-    void truncate(int len) throws IOException {\n-        if (len > available())\n-            throw new IOException(\"insufficient data\");\n-        count = pos + len;\n-    }\n-\n-    \/**\n-     * Returns the integer which takes up the specified number\n-     * of bytes in this buffer as a BigInteger.\n-     * @param len the number of bytes to use.\n-     * @param makePositive whether to always return a positive value,\n-     *   irrespective of actual encoding\n-     * @return the integer as a BigInteger.\n-     *\/\n-    BigInteger getBigInteger(int len, boolean makePositive) throws IOException {\n-        if (len > available())\n-            throw new IOException(\"short read of integer\");\n-\n-        if (len == 0) {\n-            throw new IOException(\"Invalid encoding: zero length Int value\");\n-        }\n-\n-        byte[] bytes = new byte[len];\n-\n-        System.arraycopy(buf, pos, bytes, 0, len);\n-        skip(len);\n-\n-        \/\/ BER allows leading 0s but DER does not\n-        if (!allowBER && (len >= 2 && (bytes[0] == 0) && (bytes[1] >= 0))) {\n-            throw new IOException(\"Invalid encoding: redundant leading 0s\");\n-        }\n-\n-        if (makePositive) {\n-            return new BigInteger(1, bytes);\n-        } else {\n-            return new BigInteger(bytes);\n-        }\n-    }\n-\n-    \/**\n-     * Returns the integer which takes up the specified number\n-     * of bytes in this buffer.\n-     * @throws IOException if the result is not within the valid\n-     * range for integer, i.e. between Integer.MIN_VALUE and\n-     * Integer.MAX_VALUE.\n-     * @param len the number of bytes to use.\n-     * @return the integer.\n-     *\/\n-    public int getInteger(int len) throws IOException {\n-\n-        BigInteger result = getBigInteger(len, false);\n-        if (result.compareTo(BigInteger.valueOf(Integer.MIN_VALUE)) < 0) {\n-            throw new IOException(\"Integer below minimum valid value\");\n-        }\n-        if (result.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) > 0) {\n-            throw new IOException(\"Integer exceeds maximum valid value\");\n-        }\n-        return result.intValue();\n-    }\n-\n-    \/**\n-     * Returns the bit string which takes up the specified\n-     * number of bytes in this buffer.\n-     *\/\n-    public byte[] getBitString(int len) throws IOException {\n-        if (len > available())\n-            throw new IOException(\"short read of bit string\");\n-\n-        if (len == 0) {\n-            throw new IOException(\"Invalid encoding: zero length bit string\");\n-        }\n-\n-        int numOfPadBits = buf[pos];\n-        if ((numOfPadBits < 0) || (numOfPadBits > 7)) {\n-            throw new IOException(\"Invalid number of padding bits\");\n-        }\n-        \/\/ minus the first byte which indicates the number of padding bits\n-        byte[] retval = new byte[len - 1];\n-        System.arraycopy(buf, pos + 1, retval, 0, len - 1);\n-        if (numOfPadBits != 0) {\n-            \/\/ get rid of the padding bits\n-            retval[len - 2] &= (0xff << numOfPadBits);\n-        }\n-        skip(len);\n-        return retval;\n-    }\n-\n-    \/**\n-     * Returns the bit string which takes up the rest of this buffer.\n-     *\/\n-    byte[] getBitString() throws IOException {\n-        return getBitString(available());\n-    }\n-\n-    \/**\n-     * Returns the bit string which takes up the rest of this buffer.\n-     * The bit string need not be byte-aligned.\n-     *\/\n-    BitArray getUnalignedBitString() throws IOException {\n-        if (pos >= count)\n-            return null;\n-        \/*\n-         * Just copy the data into an aligned, padded octet buffer,\n-         * and consume the rest of the buffer.\n-         *\/\n-        int len = available();\n-        int unusedBits = buf[pos] & 0xff;\n-        if (unusedBits > 7 ) {\n-            throw new IOException(\"Invalid value for unused bits: \" + unusedBits);\n-        }\n-        byte[] bits = new byte[len - 1];\n-        \/\/ number of valid bits\n-        int length = (bits.length == 0) ? 0 : bits.length * 8 - unusedBits;\n-\n-        System.arraycopy(buf, pos + 1, bits, 0, len - 1);\n-\n-        BitArray bitArray = new BitArray(length, bits);\n-        pos = count;\n-        return bitArray;\n-    }\n-\n-    \/**\n-     * Returns the UTC Time value that takes up the specified number\n-     * of bytes in this buffer.\n-     * @param len the number of bytes to use\n-     *\/\n-    public Date getUTCTime(int len) throws IOException {\n-        if (len > available())\n-            throw new IOException(\"short read of DER UTC Time\");\n-\n-        if (len < 11 || len > 17)\n-            throw new IOException(\"DER UTC Time length error\");\n-\n-        return getTime(len, false);\n-    }\n-\n-    \/**\n-     * Returns the Generalized Time value that takes up the specified\n-     * number of bytes in this buffer.\n-     * @param len the number of bytes to use\n-     *\/\n-    public Date getGeneralizedTime(int len) throws IOException {\n-        if (len > available())\n-            throw new IOException(\"short read of DER Generalized Time\");\n-\n-        if (len < 13)\n-            throw new IOException(\"DER Generalized Time length error\");\n-\n-        return getTime(len, true);\n-\n-    }\n-\n-    \/**\n-     * Private helper routine to extract time from the der value.\n-     * @param len the number of bytes to use\n-     * @param generalized true if Generalized Time is to be read, false\n-     * if UTC Time is to be read.\n-     *\/\n-    private Date getTime(int len, boolean generalized) throws IOException {\n-\n-        \/*\n-         * UTC time encoded as ASCII chars:\n-         *       YYMMDDhhmmZ\n-         *       YYMMDDhhmmssZ\n-         *       YYMMDDhhmm+hhmm\n-         *       YYMMDDhhmm-hhmm\n-         *       YYMMDDhhmmss+hhmm\n-         *       YYMMDDhhmmss-hhmm\n-         * UTC Time is broken in storing only two digits of year.\n-         * If YY < 50, we assume 20YY;\n-         * if YY >= 50, we assume 19YY, as per RFC 5280.\n-         *\n-         * Generalized time has a four-digit year and allows any\n-         * precision specified in ISO 8601. However, for our purposes,\n-         * we will only allow the same format as UTC time, except that\n-         * fractional seconds (millisecond precision) are supported.\n-         *\/\n-\n-        int year, month, day, hour, minute, second, millis;\n-        String type = null;\n-\n-        if (generalized) {\n-            type = \"Generalized\";\n-            year = 1000 * toDigit(buf[pos++], type);\n-            year += 100 * toDigit(buf[pos++], type);\n-            year += 10 * toDigit(buf[pos++], type);\n-            year += toDigit(buf[pos++], type);\n-            len -= 2; \/\/ For the two extra YY\n-        } else {\n-            type = \"UTC\";\n-            year = 10 * toDigit(buf[pos++], type);\n-            year += toDigit(buf[pos++], type);\n-\n-            if (year < 50)              \/\/ origin 2000\n-                year += 2000;\n-            else\n-                year += 1900;   \/\/ origin 1900\n-        }\n-\n-        month = 10 * toDigit(buf[pos++], type);\n-        month += toDigit(buf[pos++], type);\n-\n-        day = 10 * toDigit(buf[pos++], type);\n-        day += toDigit(buf[pos++], type);\n-\n-        hour = 10 * toDigit(buf[pos++], type);\n-        hour += toDigit(buf[pos++], type);\n-\n-        minute = 10 * toDigit(buf[pos++], type);\n-        minute += toDigit(buf[pos++], type);\n-\n-        len -= 10; \/\/ YYMMDDhhmm\n-\n-        \/*\n-         * We allow for non-encoded seconds, even though the\n-         * IETF-PKIX specification says that the seconds should\n-         * always be encoded even if it is zero.\n-         *\/\n-\n-        millis = 0;\n-        if (len > 2) {\n-            second = 10 * toDigit(buf[pos++], type);\n-            second += toDigit(buf[pos++], type);\n-            len -= 2;\n-            \/\/ handle fractional seconds (if present)\n-            if (generalized && (buf[pos] == '.' || buf[pos] == ',')) {\n-                len --;\n-                if (len == 0) {\n-                    throw new IOException(\"Parse \" + type +\n-                            \" time, empty fractional part\");\n-                }\n-                pos++;\n-                int precision = 0;\n-                while (buf[pos] != 'Z' &&\n-                       buf[pos] != '+' &&\n-                       buf[pos] != '-') {\n-                    \/\/ Validate all digits in the fractional part but\n-                    \/\/ store millisecond precision only\n-                    int thisDigit = toDigit(buf[pos], type);\n-                    precision++;\n-                    len--;\n-                    if (len == 0) {\n-                        throw new IOException(\"Parse \" + type +\n-                                \" time, invalid fractional part\");\n-                    }\n-                    pos++;\n-                    switch (precision) {\n-                        case 1:\n-                            millis += 100 * thisDigit;\n-                            break;\n-                        case 2:\n-                            millis += 10 * thisDigit;\n-                            break;\n-                        case 3:\n-                            millis += thisDigit;\n-                            break;\n-                    }\n-                }\n-                if (precision == 0) {\n-                    throw new IOException(\"Parse \" + type +\n-                            \" time, empty fractional part\");\n-                }\n-            }\n-        } else\n-            second = 0;\n-\n-        if (month == 0 || day == 0\n-            || month > 12 || day > 31\n-            || hour >= 24 || minute >= 60 || second >= 60)\n-            throw new IOException(\"Parse \" + type + \" time, invalid format\");\n-\n-        \/*\n-         * Generalized time can theoretically allow any precision,\n-         * but we're not supporting that.\n-         *\/\n-        CalendarSystem gcal = CalendarSystem.getGregorianCalendar();\n-        CalendarDate date = gcal.newCalendarDate(null); \/\/ no time zone\n-        date.setDate(year, month, day);\n-        date.setTimeOfDay(hour, minute, second, millis);\n-        long time = gcal.getTime(date);\n-\n-        \/*\n-         * Finally, \"Z\" or \"+hhmm\" or \"-hhmm\" ... offsets change hhmm\n-         *\/\n-        if (! (len == 1 || len == 5))\n-            throw new IOException(\"Parse \" + type + \" time, invalid offset\");\n-\n-        int hr, min;\n-\n-        switch (buf[pos++]) {\n-        case '+':\n-            if (len != 5) {\n-                throw new IOException(\"Parse \" + type + \" time, invalid offset\");\n-            }\n-            hr = 10 * toDigit(buf[pos++], type);\n-            hr += toDigit(buf[pos++], type);\n-            min = 10 * toDigit(buf[pos++], type);\n-            min += toDigit(buf[pos++], type);\n-\n-            if (hr >= 24 || min >= 60)\n-                throw new IOException(\"Parse \" + type + \" time, +hhmm\");\n-\n-            time -= ((hr * 60) + min) * 60 * 1000;\n-            break;\n-\n-        case '-':\n-            if (len != 5) {\n-                throw new IOException(\"Parse \" + type + \" time, invalid offset\");\n-            }\n-            hr = 10 * toDigit(buf[pos++], type);\n-            hr += toDigit(buf[pos++], type);\n-            min = 10 * toDigit(buf[pos++], type);\n-            min += toDigit(buf[pos++], type);\n-\n-            if (hr >= 24 || min >= 60)\n-                throw new IOException(\"Parse \" + type + \" time, -hhmm\");\n-\n-            time += ((hr * 60) + min) * 60 * 1000;\n-            break;\n-\n-        case 'Z':\n-            if (len != 1) {\n-                throw new IOException(\"Parse \" + type + \" time, invalid format\");\n-            }\n-            break;\n-\n-        default:\n-            throw new IOException(\"Parse \" + type + \" time, garbage offset\");\n-        }\n-        return new Date(time);\n-    }\n-\n-    \/**\n-     * Converts byte (represented as a char) to int.\n-     * @throws IOException if integer is not a valid digit in the specified\n-     *    radix (10)\n-     *\/\n-    private static int toDigit(byte b, String type) throws IOException {\n-        if (b < '0' || b > '9') {\n-            throw new IOException(\"Parse \" + type + \" time, invalid format\");\n-        }\n-        return b - '0';\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DerInputBuffer.java","additions":0,"deletions":475,"binary":false,"changes":475,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-import java.nio.charset.Charset;\n+import java.util.Arrays;\n@@ -33,3 +33,0 @@\n-import java.util.Vector;\n-\n-import static java.nio.charset.StandardCharsets.*;\n@@ -62,7 +59,5 @@\n-    \/*\n-     * This version only supports fully buffered DER.  This is easy to\n-     * work with, though if large objects are manipulated DER becomes\n-     * awkward to deal with.  That's where BER is useful, since BER\n-     * handles streaming data relatively well.\n-     *\/\n-    DerInputBuffer      buffer;\n+    \/\/ The static part\n+    final byte[] data;\n+    final int start;\n+    final int end;\n+    final boolean allowBER;\n@@ -70,2 +65,3 @@\n-    \/** The DER tag of the value; one of the tag_ constants. *\/\n-    public byte         tag;\n+    \/\/ The moving part\n+    int pos;\n+    int mark;\n@@ -73,9 +69,7 @@\n-    \/**\n-     * Create a DER input stream from a data buffer.  The buffer is not\n-     * copied, it is shared.  Accordingly, the buffer should be treated\n-     * as read-only.\n-     *\n-     * @param data the buffer from which to create the string (CONSUMED)\n-     *\/\n-    public DerInputStream(byte[] data) throws IOException {\n-        init(data, 0, data.length, true);\n+    public DerInputStream(byte[] data, int start, int length, boolean allowBER) {\n+        this.data = data;\n+        this.start = start;\n+        this.end = start + length;\n+        this.allowBER = allowBER;\n+        this.pos = start;\n+        this.mark = start;\n@@ -84,17 +78,2 @@\n-    \/**\n-     * Create a DER input stream from part of a data buffer with\n-     * additional arg to control whether DER checks are enforced.\n-     * The buffer is not copied, it is shared.  Accordingly, the\n-     * buffer should be treated as read-only.\n-     *\n-     * @param data the buffer from which to create the string (CONSUMED)\n-     * @param offset the first index of <em>data<\/em> which will\n-     *          be read as DER input in the new stream\n-     * @param len how long a chunk of the buffer to use,\n-     *          starting at \"offset\"\n-     * @param allowBER whether to allow constructed indefinite-length\n-     *          encoding as well as tolerate leading 0s\n-     *\/\n-    public DerInputStream(byte[] data, int offset, int len,\n-        boolean allowBER) throws IOException {\n-        init(data, offset, len, allowBER);\n+    public DerInputStream(DerValue v) {\n+        this(v.buffer, v.start, v.end - v.start, v.allowBER);\n@@ -103,13 +82,2 @@\n-    \/**\n-     * Create a DER input stream from part of a data buffer.\n-     * The buffer is not copied, it is shared.  Accordingly, the\n-     * buffer should be treated as read-only.\n-     *\n-     * @param data the buffer from which to create the string (CONSUMED)\n-     * @param offset the first index of <em>data<\/em> which will\n-     *          be read as DER input in the new stream\n-     * @param len how long a chunk of the buffer to use,\n-     *          starting at \"offset\"\n-     *\/\n-    public DerInputStream(byte[] data, int offset, int len) throws IOException {\n-        init(data, offset, len, true);\n+    public DerInputStream(byte[] data) throws IOException {\n+        this(data, 0, data.length, true);\n@@ -118,27 +86,2 @@\n-    \/*\n-     * private helper routine\n-     *\/\n-    private void init(byte[] data, int offset, int len, boolean allowBER) throws IOException {\n-        if ((offset+2 > data.length) || (offset+len > data.length)) {\n-            throw new IOException(\"Encoding bytes too short\");\n-        }\n-        \/\/ check for indefinite length encoding\n-        if (DerIndefLenConverter.isIndefinite(data[offset+1])) {\n-            if (!allowBER) {\n-                throw new IOException(\"Indefinite length BER encoding found\");\n-            } else {\n-                byte[] inData = new byte[len];\n-                System.arraycopy(data, offset, inData, 0, len);\n-\n-                DerIndefLenConverter derIn = new DerIndefLenConverter();\n-                byte[] result = derIn.convertBytes(inData);\n-                if (result == null) {\n-                    throw new IOException(\"not all indef len BER resolved\");\n-                } else {\n-                    buffer = new DerInputBuffer(result, allowBER);\n-                }\n-            }\n-        } else {\n-            buffer = new DerInputBuffer(data, offset, len, allowBER);\n-        }\n-        buffer.mark(Integer.MAX_VALUE);\n+    public DerInputStream(byte[] data, int offset, int len) throws IOException {\n+        this(data, offset, len, true);\n@@ -147,3 +90,2 @@\n-    DerInputStream(DerInputBuffer buf) {\n-        buffer = buf;\n-        buffer.mark(Integer.MAX_VALUE);\n+    public byte[] toByteArray() {\n+        return Arrays.copyOfRange(data, pos, end);\n@@ -153,1 +95,2 @@\n-     * Creates a new DER input stream from part of this input stream.\n+     * Reads a DerValue from this stream. After the call, the data pointer is right after\n+     * this DerValue so that the next call will read the next DerValue.\n@@ -155,21 +98,3 @@\n-     * @param len how long a chunk of the current input stream to use,\n-     *          starting at the current position.\n-     * @param do_skip true if the existing data in the input stream should\n-     *          be skipped.  If this value is false, the next data read\n-     *          on this stream and the newly created stream will be the\n-     *          same.\n-     *\/\n-    public DerInputStream subStream(int len, boolean do_skip)\n-    throws IOException {\n-        DerInputBuffer newbuf = buffer.dup();\n-\n-        newbuf.truncate(len);\n-        if (do_skip) {\n-            buffer.skip(len);\n-        }\n-        return new DerInputStream(newbuf);\n-    }\n-\n-    \/**\n-     * Return what has been written to this DerInputStream\n-     * as a byte array. Useful for debugging.\n+     * @return the read DerValue.\n+     * @throws IOException if a DerValue cannot be constructed starting from this position\n+     *                     because of byte shortage or encoding error.\n@@ -177,2 +102,5 @@\n-    public byte[] toByteArray() {\n-        return buffer.toByteArray();\n+    public DerValue getDerValue() throws IOException {\n+        DerValue result = new DerValue(\n+                this.data, this.pos, this.end - this.pos, this.allowBER, true);\n+        this.pos = result.end;\n+        return result;\n@@ -181,9 +109,1 @@\n-    \/*\n-     * PRIMITIVES -- these are \"universal\" ASN.1 simple types.\n-     *\n-     *  INTEGER, ENUMERATED, BIT STRING, OCTET STRING, NULL\n-     *  OBJECT IDENTIFIER, SEQUENCE (OF), SET (OF)\n-     *  UTF8String, PrintableString, T61String, IA5String, UTCTime,\n-     *  GeneralizedTime, BMPString.\n-     * Note: UniversalString not supported till encoder is available.\n-     *\/\n+    \/\/ The following getXyz methods are mostly shorthands for getDerValue().getXyz().\n@@ -191,5 +111,0 @@\n-    \/**\n-     * Get an integer from the input stream as an integer.\n-     *\n-     * @return the integer held in this DER input stream.\n-     *\/\n@@ -197,4 +112,1 @@\n-        if (buffer.read() != DerValue.tag_Integer) {\n-            throw new IOException(\"DER input, Integer tag error\");\n-        }\n-        return buffer.getInteger(getDefiniteLength(buffer));\n+        return getDerValue().getInteger();\n@@ -203,5 +115,0 @@\n-    \/**\n-     * Get a integer from the input stream as a BigInteger object.\n-     *\n-     * @return the integer held in this DER input stream.\n-     *\/\n@@ -209,4 +116,1 @@\n-        if (buffer.read() != DerValue.tag_Integer) {\n-            throw new IOException(\"DER input, Integer tag error\");\n-        }\n-        return buffer.getBigInteger(getDefiniteLength(buffer), false);\n+        return getDerValue().getBigInteger();\n@@ -215,7 +119,0 @@\n-    \/**\n-     * Returns an ASN.1 INTEGER value as a positive BigInteger.\n-     * This is just to deal with implementations that incorrectly encode\n-     * some values as negative.\n-     *\n-     * @return the integer held in this DER value as a BigInteger.\n-     *\/\n@@ -223,4 +120,1 @@\n-        if (buffer.read() != DerValue.tag_Integer) {\n-            throw new IOException(\"DER input, Integer tag error\");\n-        }\n-        return buffer.getBigInteger(getDefiniteLength(buffer), true);\n+        return getDerValue().getPositiveBigInteger();\n@@ -229,5 +123,0 @@\n-    \/**\n-     * Get an enumerated from the input stream.\n-     *\n-     * @return the integer held in this DER input stream.\n-     *\/\n@@ -235,4 +124,1 @@\n-        if (buffer.read() != DerValue.tag_Enumerated) {\n-            throw new IOException(\"DER input, Enumerated tag error\");\n-        }\n-        return buffer.getInteger(getDefiniteLength(buffer));\n+        return getDerValue().getEnumerated();\n@@ -241,4 +127,0 @@\n-    \/**\n-     * Get a bit string from the input stream. Padded bits (if any)\n-     * will be stripped off before the bit string is returned.\n-     *\/\n@@ -246,4 +128,1 @@\n-        if (buffer.read() != DerValue.tag_BitString)\n-            throw new IOException(\"DER input not an bit string\");\n-\n-        return buffer.getBitString(getDefiniteLength(buffer));\n+        return getDerValue().getBitString();\n@@ -252,4 +131,0 @@\n-    \/**\n-     * Get a bit string from the input stream.  The bit string need\n-     * not be byte-aligned.\n-     *\/\n@@ -257,31 +132,1 @@\n-        if (buffer.read() != DerValue.tag_BitString) {\n-            throw new IOException(\"DER input not a bit string\");\n-        }\n-\n-        int length = getDefiniteLength(buffer);\n-\n-        if (length == 0) {\n-            return new BitArray(0);\n-        }\n-\n-        \/*\n-         * First byte = number of excess bits in the last octet of the\n-         * representation.\n-         *\/\n-        length--;\n-        int excessBits = buffer.read();\n-        if (excessBits < 0) {\n-            throw new IOException(\"Unused bits of bit string invalid\");\n-        }\n-        int validBits = length*8 - excessBits;\n-        if (validBits < 0) {\n-            throw new IOException(\"Valid bits of bit string invalid\");\n-        }\n-\n-        byte[] repn = new byte[length];\n-\n-        if ((length != 0) && (buffer.read(repn) != length)) {\n-            throw new IOException(\"Short read of DER bit string\");\n-        }\n-\n-        return new BitArray(validBits, repn);\n+        return getDerValue().getUnalignedBitString();\n@@ -290,3 +135,0 @@\n-    \/**\n-     * Returns an ASN.1 OCTET STRING from the input stream.\n-     *\/\n@@ -294,1 +136,4 @@\n-        if (buffer.read() != DerValue.tag_OctetString)\n+        \/\/ Not identical to DerValue::getOctetString. This method\n+        \/\/ does not accept constructed OCTET STRING.\n+        DerValue v = getDerValue();\n+        if (v.tag != DerValue.tag_OctetString) {\n@@ -296,15 +141,0 @@\n-\n-        int length = getDefiniteLength(buffer);\n-        byte[] retval = new byte[length];\n-        if ((length != 0) && (buffer.read(retval) != length))\n-            throw new IOException(\"Short read of DER octet string\");\n-\n-        return retval;\n-    }\n-\n-    \/**\n-     * Returns the asked number of bytes from the input stream.\n-     *\/\n-    public void getBytes(byte[] val) throws IOException {\n-        if ((val.length != 0) && (buffer.read(val) != val.length)) {\n-            throw new IOException(\"Short read of DER octet string\");\n@@ -312,0 +142,1 @@\n+        return v.getOctetString();\n@@ -314,3 +145,0 @@\n-    \/**\n-     * Reads an encoded null value from the input stream.\n-     *\/\n@@ -318,2 +146,1 @@\n-        if (buffer.read() != DerValue.tag_Null || buffer.read() != 0)\n-            throw new IOException(\"getNull, bad data\");\n+        getDerValue().getNull();\n@@ -322,3 +149,0 @@\n-    \/**\n-     * Reads an X.200 style Object Identifier from the stream.\n-     *\/\n@@ -326,131 +150,1 @@\n-        return new ObjectIdentifier(this);\n-    }\n-\n-    \/**\n-     * Return a sequence of encoded entities.  ASN.1 sequences are\n-     * ordered, and they are often used, like a \"struct\" in C or C++,\n-     * to group data values.  They may have optional or context\n-     * specific values.\n-     *\n-     * @param startLen guess about how long the sequence will be\n-     *          (used to initialize an auto-growing data structure)\n-     * @return array of the values in the sequence\n-     *\/\n-    public DerValue[] getSequence(int startLen) throws IOException {\n-        tag = (byte)buffer.read();\n-        if (tag != DerValue.tag_Sequence)\n-            throw new IOException(\"Sequence tag error\");\n-        return readVector(startLen);\n-    }\n-\n-    \/**\n-     * Return a set of encoded entities.  ASN.1 sets are unordered,\n-     * though DER may specify an order for some kinds of sets (such\n-     * as the attributes in an X.500 relative distinguished name)\n-     * to facilitate binary comparisons of encoded values.\n-     *\n-     * @param startLen guess about how large the set will be\n-     *          (used to initialize an auto-growing data structure)\n-     * @return array of the values in the sequence\n-     *\/\n-    public DerValue[] getSet(int startLen) throws IOException {\n-        tag = (byte)buffer.read();\n-        if (tag != DerValue.tag_Set)\n-            throw new IOException(\"Set tag error\");\n-        return readVector(startLen);\n-    }\n-\n-    \/**\n-     * Return a set of encoded entities.  ASN.1 sets are unordered,\n-     * though DER may specify an order for some kinds of sets (such\n-     * as the attributes in an X.500 relative distinguished name)\n-     * to facilitate binary comparisons of encoded values.\n-     *\n-     * @param startLen guess about how large the set will be\n-     *          (used to initialize an auto-growing data structure)\n-     * @param implicit if true tag is assumed implicit.\n-     * @return array of the values in the sequence\n-     *\/\n-    public DerValue[] getSet(int startLen, boolean implicit)\n-        throws IOException {\n-        tag = (byte)buffer.read();\n-        if (!implicit) {\n-            if (tag != DerValue.tag_Set) {\n-                throw new IOException(\"Set tag error\");\n-            }\n-        }\n-        return (readVector(startLen));\n-    }\n-\n-    \/*\n-     * Read a \"vector\" of values ... set or sequence have the\n-     * same encoding, except for the initial tag, so both use\n-     * this same helper routine.\n-     *\/\n-    protected DerValue[] readVector(int startLen) throws IOException {\n-        DerInputStream  newstr;\n-\n-        byte lenByte = (byte)buffer.read();\n-        int len = getLength(lenByte, buffer);\n-\n-        if (len == -1) {\n-           \/\/ indefinite length encoding found\n-           buffer = new DerInputBuffer(\n-                   DerIndefLenConverter.convertStream(buffer, lenByte, tag),\n-                   buffer.allowBER);\n-\n-           if (tag != buffer.read())\n-                throw new IOException(\"Indefinite length encoding\" +\n-                        \" not supported\");\n-           len = DerInputStream.getDefiniteLength(buffer);\n-        }\n-\n-        if (len == 0)\n-            \/\/ return empty array instead of null, which should be\n-            \/\/ used only for missing optionals\n-            return new DerValue[0];\n-\n-        \/*\n-         * Create a temporary stream from which to read the data,\n-         * unless it's not really needed.\n-         *\/\n-        if (buffer.available() == len)\n-            newstr = this;\n-        else\n-            newstr = subStream(len, true);\n-\n-        \/*\n-         * Pull values out of the stream.\n-         *\/\n-        Vector<DerValue> vec = new Vector<>(startLen);\n-        DerValue value;\n-\n-        do {\n-            value = new DerValue(newstr.buffer, buffer.allowBER);\n-            vec.addElement(value);\n-        } while (newstr.available() > 0);\n-\n-        if (newstr.available() != 0)\n-            throw new IOException(\"Extra data at end of vector\");\n-\n-        \/*\n-         * Now stick them into the array we're returning.\n-         *\/\n-        int             i, max = vec.size();\n-        DerValue[]      retval = new DerValue[max];\n-\n-        for (i = 0; i < max; i++)\n-            retval[i] = vec.elementAt(i);\n-\n-        return retval;\n-    }\n-\n-    \/**\n-     * Get a single DER-encoded value from the input stream.\n-     * It can often be useful to pull a value from the stream\n-     * and defer parsing it.  For example, you can pull a nested\n-     * sequence out with one call, and only examine its elements\n-     * later when you really need to.\n-     *\/\n-    public DerValue getDerValue() throws IOException {\n-        return new DerValue(buffer);\n+        return getDerValue().getOID();\n@@ -459,3 +153,0 @@\n-    \/**\n-     * Read a string that was encoded as a UTF8String DER value.\n-     *\/\n@@ -463,1 +154,1 @@\n-        return readString(DerValue.tag_UTF8String, \"UTF-8\", UTF_8);\n+        return getDerValue().getUTF8String();\n@@ -466,3 +157,0 @@\n-    \/**\n-     * Read a string that was encoded as a PrintableString DER value.\n-     *\/\n@@ -470,2 +158,1 @@\n-        return readString(DerValue.tag_PrintableString, \"Printable\",\n-                          US_ASCII);\n+        return getDerValue().getPrintableString();\n@@ -474,3 +161,0 @@\n-    \/**\n-     * Read a string that was encoded as a T61String DER value.\n-     *\/\n@@ -478,11 +162,1 @@\n-        \/*\n-         * Works for common characters between T61 and ASCII.\n-         *\/\n-        return readString(DerValue.tag_T61String, \"T61\", ISO_8859_1);\n-    }\n-\n-    \/**\n-     * Read a string that was encoded as a IA5String DER value.\n-     *\/\n-    public String getIA5String() throws IOException {\n-        return readString(DerValue.tag_IA5String, \"IA5\", US_ASCII);\n+        return getDerValue().getT61String();\n@@ -491,3 +165,0 @@\n-    \/**\n-     * Read a string that was encoded as a BMPString DER value.\n-     *\/\n@@ -495,1 +166,1 @@\n-        return readString(DerValue.tag_BMPString, \"BMP\", UTF_16BE);\n+        return getDerValue().getBMPString();\n@@ -498,6 +169,2 @@\n-    \/**\n-     * Read a string that was encoded as a GeneralString DER value.\n-     *\/\n-    public String getGeneralString() throws IOException {\n-        return readString(DerValue.tag_GeneralString, \"General\",\n-                          US_ASCII);\n+    public String getIA5String() throws IOException {\n+        return getDerValue().getIA5String();\n@@ -506,22 +173,2 @@\n-    \/**\n-     * Private helper routine to read an encoded string from the input\n-     * stream.\n-     * @param stringTag the tag for the type of string to read\n-     * @param stringName a name to display in error messages\n-     * @param enc the encoder to use to interpret the data. Should\n-     * correspond to the stringTag above.\n-     *\/\n-    private String readString(byte stringTag, String stringName,\n-                              Charset charset) throws IOException {\n-\n-        if (buffer.read() != stringTag)\n-            throw new IOException(\"DER input not a \" +\n-                                  stringName + \" string\");\n-\n-        int length = getDefiniteLength(buffer);\n-        byte[] retval = new byte[length];\n-        if ((length != 0) && (buffer.read(retval) != length))\n-            throw new IOException(\"Short read of DER \" +\n-                                  stringName + \" string\");\n-\n-        return new String(retval, charset);\n+    public String getGeneralString() throws IOException {\n+        return getDerValue().getGeneralString();\n@@ -530,3 +177,0 @@\n-    \/**\n-     * Get a UTC encoded time value from the input stream.\n-     *\/\n@@ -534,3 +178,1 @@\n-        if (buffer.read() != DerValue.tag_UtcTime)\n-            throw new IOException(\"DER input, UTCtime tag invalid \");\n-        return buffer.getUTCTime(getDefiniteLength(buffer));\n+        return getDerValue().getUTCTime();\n@@ -539,3 +181,0 @@\n-    \/**\n-     * Get a Generalized encoded time value from the input stream.\n-     *\/\n@@ -543,3 +182,1 @@\n-        if (buffer.read() != DerValue.tag_GeneralizedTime)\n-            throw new IOException(\"DER input, GeneralizedTime tag invalid \");\n-        return buffer.getGeneralizedTime(getDefiniteLength(buffer));\n+        return getDerValue().getGeneralizedTime();\n@@ -548,6 +185,5 @@\n-    \/*\n-     * Get a byte from the input stream.\n-     *\/\n-    \/\/ package private\n-    int getByte() throws IOException {\n-        return (0x00ff & buffer.read());\n+    \/\/ Read a series of DerValue objects which is the sub-elements\n+    \/\/ of a SEQUENCE and SET.\n+\n+    public DerValue[] getSequence(int startLen) throws IOException {\n+        return getDerValue().subs(DerValue.tag_Sequence, startLen);\n@@ -556,2 +192,2 @@\n-    public int peekByte() throws IOException {\n-        return buffer.peek();\n+    public DerValue[] getSet(int startLen) throws IOException {\n+        return getDerValue().subs(DerValue.tag_Set, startLen);\n@@ -560,3 +196,9 @@\n-    \/\/ package private\n-    int getLength() throws IOException {\n-        return getLength(buffer);\n+    public DerValue[] getSet(int startLen, boolean implicit) throws IOException {\n+        return getDerValue().subs((byte)0, startLen);\n+    }\n+\n+    public int peekByte() throws IOException {\n+        if (pos == end) {\n+            throw new IOException(\"At end\");\n+        }\n+        return data[pos];\n@@ -565,7 +207,0 @@\n-    \/*\n-     * Get a length from the input stream, allowing for at most 32 bits of\n-     * encoding to be used.  (Not the same as getting a tagged integer!)\n-     *\n-     * @return the length or -1 if indefinite length found.\n-     * @exception IOException on parsing error or unsupported lengths.\n-     *\/\n@@ -576,1 +211,1 @@\n-    \/*\n+    \/**\n@@ -580,0 +215,2 @@\n+     * @param lenByte\n+     *\n@@ -625,4 +262,0 @@\n-    int getDefiniteLength() throws IOException {\n-        return getDefiniteLength(buffer);\n-    }\n-\n@@ -630,1 +263,1 @@\n-     * Get a length from the input stream.\n+     * Get a definite length from the input stream.\n@@ -647,2 +280,1 @@\n-    public void mark(int value) { buffer.mark(value); }\n-\n+    public void mark(int value) { mark = pos; }\n@@ -655,2 +287,1 @@\n-    public void reset() { buffer.reset(); }\n-\n+    public void reset() { pos = mark; }\n@@ -663,1 +294,1 @@\n-    public int available() { return buffer.available(); }\n+    public int available() { return end - pos; }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DerInputStream.java","additions":82,"deletions":451,"binary":false,"changes":533,"status":"modified"},{"patch":"@@ -28,0 +28,4 @@\n+import sun.nio.cs.UTF_32BE;\n+import sun.util.calendar.CalendarDate;\n+import sun.util.calendar.CalendarSystem;\n+\n@@ -31,3 +35,1 @@\n-import java.nio.charset.IllegalCharsetNameException;\n-import java.nio.charset.UnsupportedCharsetException;\n-import java.util.Date;\n+import java.util.*;\n@@ -61,0 +63,1 @@\n+\n@@ -67,12 +70,0 @@\n-    \/** The DER tag of the value; one of the tag_ constants. *\/\n-    public byte                 tag;\n-\n-    protected DerInputBuffer    buffer;\n-\n-    \/**\n-     * The DER-encoded data of the value, never null\n-     *\/\n-    public final DerInputStream data;\n-\n-    private int                 length;\n-\n@@ -164,0 +155,17 @@\n+    \/\/ This class is 99% immutable except that:\n+    \/\/\n+    \/\/ 1. resetTag() modifies the tag\n+    \/\/ 2. reading from the data field advances the internal position\n+    \/\/\n+    \/\/ For compatibility, data and resetTag() are preserved. A modern caller\n+    \/\/ should call withTag() or data() instead (do not use the data field).\n+\n+    public \/*final*\/ byte tag;\n+    final byte[] buffer;\n+    final int start;\n+    final int end;\n+    final boolean allowBER;\n+\n+    \/\/ Unsafe. Legacy. Never null.\n+    final public DerInputStream data;\n+\n@@ -210,1 +218,13 @@\n-     * Creates a PrintableString or UTF8string DER value from a string\n+     * Creates a new DerValue by specifying all its fields.\n+     *\/\n+    DerValue(byte tag, byte[] buffer, int start, int end, boolean allowBER) {\n+        this.tag = tag;\n+        this.buffer = buffer;\n+        this.start = start;\n+        this.end = end;\n+        this.allowBER = allowBER;\n+        this.data = new DerInputStream(this);\n+    }\n+\n+    \/**\n+     * Creates a PrintableString or UTF8string DER value from a string.\n@@ -213,1 +233,5 @@\n-        boolean isPrintableString = true;\n+        this(isPrintableString(value) ? tag_PrintableString : tag_UTF8String,\n+                value);\n+    }\n+\n+    private static boolean isPrintableString(String value) {\n@@ -216,2 +240,1 @@\n-                isPrintableString = false;\n-                break;\n+                return false;\n@@ -220,2 +243,1 @@\n-\n-        data = init(isPrintableString ? tag_PrintableString : tag_UTF8String, value);\n+        return true;\n@@ -230,1 +252,1 @@\n-        data = init(stringTag, value);\n+        this(stringTag, string2bytes(stringTag, value), false);\n@@ -233,8 +255,14 @@\n-    \/\/ Creates a DerValue from a tag and some DER-encoded data w\/ additional\n-    \/\/ arg to control whether DER checks are enforced.\n-    DerValue(byte tag, byte[] data, boolean allowBER) {\n-        this.tag = tag;\n-        buffer = new DerInputBuffer(data.clone(), allowBER);\n-        length = data.length;\n-        this.data = new DerInputStream(buffer);\n-        this.data.mark(Integer.MAX_VALUE);\n+    private static byte[] string2bytes(byte stringTag, String value) {\n+        Charset charset = switch (stringTag) {\n+            case tag_PrintableString, tag_IA5String, tag_GeneralString -> US_ASCII;\n+            case tag_T61String -> ISO_8859_1;\n+            case tag_BMPString -> UTF_16BE;\n+            case tag_UTF8String -> UTF_8;\n+            case tag_UniversalString -> Charset.forName(\"UTF_32BE\");\n+            default -> throw new IllegalArgumentException(\"Unsupported DER string type\");\n+        };\n+        return value.getBytes(charset);\n+    }\n+\n+    DerValue(byte tag, byte[] buffer, boolean allowBER) {\n+        this(tag, buffer, 0, buffer.length, allowBER);\n@@ -246,0 +274,2 @@\n+     * This is a public constructor.\n+     *\n@@ -247,1 +277,1 @@\n-     * @param data the DER-encoded data\n+     * @param buffer the DER-encoded data\n@@ -249,44 +279,2 @@\n-    public DerValue(byte tag, byte[] data) {\n-        this(tag, data, true);\n-    }\n-\n-    \/*\n-     * package private\n-     *\/\n-    DerValue(DerInputBuffer in) throws IOException {\n-\n-        \/\/ XXX must also parse BER-encoded constructed\n-        \/\/ values such as sequences, sets...\n-        tag = (byte)in.read();\n-        byte lenByte = (byte)in.read();\n-        length = DerInputStream.getLength(lenByte, in);\n-        if (length == -1) {  \/\/ indefinite length encoding found\n-            DerInputBuffer inbuf = in.dup();\n-            inbuf = new DerInputBuffer(\n-                    DerIndefLenConverter.convertStream(inbuf, lenByte, tag),\n-                    in.allowBER);\n-            if (tag != inbuf.read())\n-                throw new IOException\n-                        (\"Indefinite length encoding not supported\");\n-            length = DerInputStream.getDefiniteLength(inbuf);\n-            buffer = inbuf.dup();\n-            buffer.truncate(length);\n-            data = new DerInputStream(buffer);\n-            \/\/ indefinite form is encoded by sending a length field with a\n-            \/\/ length of 0. - i.e. [1000|0000].\n-            \/\/ the object is ended by sending two zero bytes.\n-            in.skip(length + 2);\n-        } else {\n-\n-            buffer = in.dup();\n-            buffer.truncate(length);\n-            data = new DerInputStream(buffer);\n-\n-            in.skip(length);\n-        }\n-    }\n-\n-    \/\/ Get an ASN.1\/DER encoded datum from a buffer w\/ additional\n-    \/\/ arg to control whether DER checks are enforced.\n-    DerValue(byte[] buf, boolean allowBER) throws IOException {\n-        data = init(true, new ByteArrayInputStream(buf), allowBER);\n+    public DerValue(byte tag, byte[] buffer) {\n+        this(tag, buffer.clone(), true);\n@@ -296,3 +284,2 @@\n-     * Get an ASN.1\/DER encoded datum from a buffer.  The\n-     * entire buffer must hold exactly one datum, including\n-     * its tag and length.\n+     * Parse an ASN.1\/BER encoded datum. The entire encoding must hold exactly\n+     * one datum, including its tag and length.\n@@ -300,1 +287,1 @@\n-     * @param buf buffer holding a single DER-encoded datum.\n+     * This is a public constructor.\n@@ -302,9 +289,2 @@\n-    public DerValue(byte[] buf) throws IOException {\n-        this(buf, true);\n-    }\n-\n-    \/\/ Get an ASN.1\/DER encoded datum from part of a buffer w\/ additional\n-    \/\/ arg to control whether DER checks are enforced.\n-    DerValue(byte[] buf, int offset, int len, boolean allowBER)\n-        throws IOException {\n-        data = init(true, new ByteArrayInputStream(buf, offset, len), allowBER);\n+    public DerValue(byte[] encoding) throws IOException {\n+        this(encoding.clone(), 0, encoding.length, true, false);\n@@ -314,3 +294,9 @@\n-     * Get an ASN.1\/DER encoded datum from part of a buffer.\n-     * That part of the buffer must hold exactly one datum, including\n-     * its tag and length.\n+     * Parse an ASN.1\/BER encoded datum from a byte array.\n+     *\n+     * @param buf the byte array containing the DER-encoded datum\n+     * @param offset where the encoded datum starts inside {@code buf}\n+     * @param len length of bytes to parse inside {@code buf}\n+     * @param allowBER whether BER is allowed\n+     * @param allowMore whether extra bytes are allowed after the encoded datum.\n+     *                  If true, {@code len} can be bigger than the length og\n+     *                  the encoded datum.\n@@ -318,3 +304,2 @@\n-     * @param buf the buffer\n-     * @param offset start point of the single DER-encoded dataum\n-     * @param len how many bytes are in the encoded datum\n+     * @throws IOException if it's an invalid encoding or there are extra bytes\n+     *                     after the encoded datum but {@code allowMore} is false.\n@@ -322,2 +307,76 @@\n-    public DerValue(byte[] buf, int offset, int len) throws IOException {\n-        this(buf, offset, len, true);\n+    DerValue(byte[] buf, int offset, int len, boolean allowBER, boolean allowMore)\n+            throws IOException {\n+\n+        if (len < 2) {\n+            throw new IOException(\"Too short\");\n+        }\n+        int pos = offset;\n+        tag = buf[pos++];\n+        int lenByte = buf[pos++];\n+\n+        int length;\n+        if (lenByte == (byte)0x80) {\n+            length = -1;\n+        } else if ((lenByte & 0x080) == 0x00) { \/\/ short form, 1 byte datum\n+            length = lenByte;\n+        } else {                     \/\/ long form or indefinite\n+            lenByte &= 0x07f;\n+            if (lenByte == 0) {\n+                length = -1;\n+            } else if (lenByte < 0 || lenByte > 4) {\n+                throw new IOException(\"Invalid lenByte\");\n+            } else {\n+                if (len < 2 + lenByte) {\n+                    throw new IOException(\"Not enough length bytes\");\n+                }\n+                length = 0x0ff & buf[pos++];\n+                lenByte--;\n+                if (length == 0 && !allowBER) {\n+                    \/\/ DER requires length value be encoded in minimum number of bytes\n+                    throw new IOException(\"Redundant length bytes found\");\n+                }\n+                while (lenByte-- > 0) {\n+                    length <<= 8;\n+                    length += 0x0ff & buf[pos++];\n+                }\n+                if (length < 0) {\n+                    throw new IOException(\"Invalid length bytes\");\n+                } else if (length <= 127 && !allowBER) {\n+                    throw new IOException(\"Should use short form for length\");\n+                }\n+            }\n+        }\n+        if (length == -1) { \/\/ indefinite length encoding found\n+            if (!allowBER) {\n+                throw new IOException(\"Indefinite length encoding \" +\n+                        \"not supported with DER\");\n+            }\n+            if (!isConstructed()) {\n+                throw new IOException(\"Indefinite length encoding \" +\n+                        \"not supported with non-constructed data\");\n+            }\n+            InputStream in = new ByteArrayInputStream(\n+                    DerIndefLenConverter.convertStream(\n+                            new ByteArrayInputStream(buf, pos, len - (pos - offset)),\n+                            (byte)lenByte, tag));\n+            if (tag != in.read()) {\n+                throw new IOException\n+                        (\"Indefinite length encoding not supported\");\n+            }\n+            length = DerInputStream.getDefiniteLength(in);\n+            this.buffer = IOUtils.readExactlyNBytes(in, length);\n+            this.start = 0;\n+            this.end = length;\n+        } else {\n+            if (len - length < pos - offset) {\n+                throw new EOFException(\"Too little\");\n+            }\n+            if (len - length > pos - offset && !allowMore) {\n+                throw new IOException(\"Too much\");\n+            }\n+            this.buffer = buf;\n+            this.start = pos;\n+            this.end = pos + length;\n+        }\n+        this.allowBER = allowBER;\n+        this.data = new DerInputStream(this);\n@@ -329,1 +388,24 @@\n-        data = init(false, in, allowBER);\n+        this.tag = (byte)in.read();\n+        byte lenByte = (byte)in.read();\n+        int length = DerInputStream.getLength(lenByte, in);\n+        if (length == -1) { \/\/ indefinite length encoding found\n+            if (!allowBER) {\n+                throw new IOException(\"Indefinite length encoding \" +\n+                        \"not supported with DER\");\n+            }\n+            if (!isConstructed()) {\n+                throw new IOException(\"Indefinite length encoding \" +\n+                        \"not supported with non-constructed data\");\n+            }\n+            in = new ByteArrayInputStream(\n+                    DerIndefLenConverter.convertStream(in, lenByte, tag));\n+            if (tag != in.read())\n+                throw new IOException\n+                        (\"Indefinite length encoding not supported\");\n+            length = DerInputStream.getDefiniteLength(in);\n+        }\n+        this.buffer = IOUtils.readExactlyNBytes(in, length);\n+        this.start = 0;\n+        this.end = length;\n+        this.allowBER = allowBER;\n+        this.data = new DerInputStream(this);\n@@ -345,37 +427,2 @@\n-    private DerInputStream init(byte stringTag, String value) {\n-        final Charset charset;\n-\n-        tag = stringTag;\n-\n-        switch (stringTag) {\n-        case tag_PrintableString:\n-        case tag_IA5String:\n-        case tag_GeneralString:\n-            charset = US_ASCII;\n-            break;\n-        case tag_T61String:\n-            charset = ISO_8859_1;\n-            break;\n-        case tag_BMPString:\n-            charset = UTF_16BE;\n-            break;\n-        case tag_UTF8String:\n-            charset = UTF_8;\n-            break;\n-        case tag_UniversalString:\n-            charset = Charset.forName(\"UTF_32BE\");\n-            break;\n-        default:\n-            throw new IllegalArgumentException(\"Unsupported DER string type\");\n-        }\n-\n-        byte[] buf = value.getBytes(charset);\n-        length = buf.length;\n-        buffer = new DerInputBuffer(buf, true);\n-        DerInputStream result = new DerInputStream(buffer);\n-        result.mark(Integer.MAX_VALUE);\n-        return result;\n-    }\n-\n-    \/*\n-     * helper routine\n+    \/**\n+     * Encode an ASN1\/DER encoded datum onto a DER output stream.\n@@ -383,22 +430,5 @@\n-    private DerInputStream init(boolean fullyBuffered, InputStream in,\n-        boolean allowBER) throws IOException {\n-\n-        tag = (byte)in.read();\n-        byte lenByte = (byte)in.read();\n-        length = DerInputStream.getLength(lenByte, in);\n-        if (length == -1) { \/\/ indefinite length encoding found\n-            in = new ByteArrayInputStream(\n-                    DerIndefLenConverter.convertStream(in, lenByte, tag));\n-            if (tag != in.read())\n-                throw new IOException\n-                        (\"Indefinite length encoding not supported\");\n-            length = DerInputStream.getDefiniteLength(in);\n-        }\n-\n-        if (fullyBuffered && in.available() != length)\n-            throw new IOException(\"extra data given to DerValue constructor\");\n-\n-        byte[] bytes = IOUtils.readExactlyNBytes(in, length);\n-\n-        buffer = new DerInputBuffer(bytes, allowBER);\n-        return new DerInputStream(buffer);\n+    public void encode(DerOutputStream out) throws IOException {\n+        out.write(tag);\n+        out.putLength(end - start);\n+        out.write(buffer, start, end - start);\n+        data.pos = data.end; \/\/ Compatibility. Reach end.\n@@ -408,1 +438,3 @@\n-     * Encode an ASN1\/DER encoded datum onto a DER output stream.\n+     * Returns a new DerInputStream pointing at the start of buffer.\n+     *\n+     * @return the new DerInputStream value\n@@ -410,16 +442,2 @@\n-    public void encode(DerOutputStream out)\n-    throws IOException {\n-        out.write(tag);\n-        out.putLength(length);\n-        \/\/ XXX yeech, excess copies ... DerInputBuffer.write(OutStream)\n-        if (length > 0) {\n-            byte[] value = new byte[length];\n-            \/\/ always synchronized on data\n-            synchronized (data) {\n-                buffer.reset();\n-                if (buffer.read(value) != length) {\n-                    throw new IOException(\"short DER value read (encode)\");\n-                }\n-                out.write(value);\n-            }\n-        }\n+    public final DerInputStream data() {\n+        return new DerInputStream(this);\n@@ -445,1 +463,1 @@\n-        if (length != 1) {\n+        if (end - start != 1) {\n@@ -447,1 +465,1 @@\n-                                        + length);\n+                                        + (end - start));\n@@ -449,4 +467,2 @@\n-        if (buffer.read() != 0) {\n-            return true;\n-        }\n-        return false;\n+        data.pos = data.end; \/\/ Compatibility. Reach end.\n+        return buffer[start] != 0;\n@@ -461,1 +477,1 @@\n-        if (tag != tag_ObjectId)\n+        if (tag != tag_ObjectId) {\n@@ -463,12 +479,3 @@\n-        return new ObjectIdentifier(buffer);\n-    }\n-\n-    private byte[] append(byte[] a, byte[] b) {\n-        if (a == null)\n-            return b;\n-\n-        byte[] ret = new byte[a.length + b.length];\n-        System.arraycopy(a, 0, ret, 0, a.length);\n-        System.arraycopy(b, 0, ret, a.length, b.length);\n-\n-        return ret;\n+        }\n+        data.pos = data.end; \/\/ Compatibility. Reach end.\n+        return new ObjectIdentifier(Arrays.copyOfRange(buffer, start, end));\n@@ -490,1 +497,1 @@\n-        if (length == 0) {\n+        if (end - start == 0) {\n@@ -494,16 +501,8 @@\n-        \/\/ Only allocate the array if there are enough bytes available.\n-        \/\/ This only works for ByteArrayInputStream.\n-        \/\/ The assignment below ensures that buffer has the required type.\n-        ByteArrayInputStream arrayInput = buffer;\n-        if (arrayInput.available() < length) {\n-            throw new IOException(\"short read on DerValue buffer\");\n-        }\n-        byte[] bytes = new byte[length];\n-        arrayInput.read(bytes);\n-\n-        if (isConstructed()) {\n-            DerInputStream in = new DerInputStream(bytes, 0, bytes.length,\n-                buffer.allowBER);\n-            bytes = null;\n-            while (in.available() != 0) {\n-                bytes = append(bytes, in.getOctetString());\n+        data.pos = data.end; \/\/ Compatibility. Reach end.\n+        if (!isConstructed()) {\n+            return Arrays.copyOfRange(buffer, start, end);\n+        } else {\n+            ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+            DerInputStream dis = new DerInputStream(this);\n+            while (dis.available() > 0) {\n+                bout.write(dis.getDerValue().getOctetString());\n@@ -511,0 +510,1 @@\n+            return bout.toByteArray();\n@@ -512,1 +512,0 @@\n-        return bytes;\n@@ -521,2 +520,6 @@\n-        if (tag != tag_Integer) {\n-            throw new IOException(\"DerValue.getInteger, not an int \" + tag);\n+        BigInteger result = getBigInteger();\n+        if (result.compareTo(BigInteger.valueOf(Integer.MIN_VALUE)) < 0) {\n+            throw new IOException(\"Integer below minimum valid value\");\n+        }\n+        if (result.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) > 0) {\n+            throw new IOException(\"Integer exceeds maximum valid value\");\n@@ -524,1 +527,1 @@\n-        return buffer.getInteger(data.available());\n+        return result.intValue();\n@@ -533,3 +536,1 @@\n-        if (tag != tag_Integer)\n-            throw new IOException(\"DerValue.getBigInteger, not an int \" + tag);\n-        return buffer.getBigInteger(data.available(), false);\n+        return getBigIntegerInternal(false);\n@@ -546,1 +547,12 @@\n-        if (tag != tag_Integer)\n+        return getBigIntegerInternal(true);\n+    }\n+\n+    \/**\n+     * Returns a BigInteger value\n+     *\n+     * @param makePositive whether to always return a positive value,\n+     *   irrespective of actual encoding\n+     * @return the integer as a BigInteger.\n+     *\/\n+    private BigInteger getBigIntegerInternal(boolean makePositive) throws IOException {\n+        if (tag != tag_Integer) {\n@@ -548,1 +560,11 @@\n-        return buffer.getBigInteger(data.available(), true);\n+        }\n+        if (end == start) {\n+            throw new IOException(\"Invalid encoding: zero length Int value\");\n+        }\n+        data.pos = data.end; \/\/ Compatibility. Reach end.\n+        if (!allowBER && (end - start >= 2 && (buffer[start] == 0) && (buffer[start + 1] >= 0))) {\n+            throw new IOException(\"Invalid encoding: redundant leading 0s\");\n+        }\n+        return makePositive\n+                ? new BigInteger(1, buffer, start, end - start)\n+                : new BigInteger(buffer, start, end - start);\n@@ -561,1 +583,2 @@\n-        return buffer.getInteger(data.available());\n+        \/\/ TODO\n+        return new BigInteger(1, buffer, start, end - start).intValue();\n@@ -570,5 +593,1 @@\n-        if (tag != tag_BitString)\n-            throw new IOException(\n-                \"DerValue.getBitString, not a bit string \" + tag);\n-\n-        return buffer.getBitString();\n+        return getBitString(false);\n@@ -583,5 +602,1 @@\n-        if (tag != tag_BitString)\n-            throw new IOException(\n-                \"DerValue.getBitString, not a bit string \" + tag);\n-\n-        return buffer.getUnalignedBitString();\n+        return getUnalignedBitString(false);\n@@ -596,16 +611,10 @@\n-        if (tag == tag_UTF8String)\n-            return getUTF8String();\n-        else if (tag == tag_PrintableString)\n-            return getPrintableString();\n-        else if (tag == tag_T61String)\n-            return getT61String();\n-        else if (tag == tag_IA5String)\n-            return getIA5String();\n-        else if (tag == tag_UniversalString)\n-          return getUniversalString();\n-        else if (tag == tag_BMPString)\n-            return getBMPString();\n-        else if (tag == tag_GeneralString)\n-            return getGeneralString();\n-        else\n-            return null;\n+        return switch (tag) {\n+            case tag_UTF8String -> getUTF8String();\n+            case tag_PrintableString -> getPrintableString();\n+            case tag_T61String -> getT61String();\n+            case tag_IA5String -> getIA5String();\n+            case tag_UniversalString -> getUniversalString();\n+            case tag_BMPString -> getBMPString();\n+            case tag_GeneralString -> getGeneralString();\n+            default -> null;\n+        };\n@@ -623,1 +632,1 @@\n-            if (tag != tag_BitString)\n+            if (tag != tag_BitString) {\n@@ -625,1 +634,1 @@\n-                                       + tag);\n+                        + tag);\n@@ -627,1 +636,16 @@\n-        return buffer.getBitString();\n+        }\n+        if (end == start) {\n+            throw new IOException(\"No padding\");\n+        }\n+        int numOfPadBits = buffer[start];\n+        if ((numOfPadBits < 0) || (numOfPadBits > 7)) {\n+            throw new IOException(\"Invalid number of padding bits\");\n+        }\n+        \/\/ minus the first byte which indicates the number of padding bits\n+        byte[] retval = Arrays.copyOfRange(buffer, start + 1, end);\n+        if (numOfPadBits != 0) {\n+            \/\/ get rid of the padding bits\n+            retval[end - start - 2] &= (0xff << numOfPadBits);\n+        }\n+        data.pos = data.end; \/\/ Compatibility. Reach end.\n+        return retval;\n@@ -638,1 +662,1 @@\n-    throws IOException {\n+            throws IOException {\n@@ -640,1 +664,1 @@\n-            if (tag != tag_BitString)\n+            if (tag != tag_BitString) {\n@@ -642,1 +666,1 @@\n-                                       + tag);\n+                        + tag);\n@@ -644,1 +668,15 @@\n-        return buffer.getUnalignedBitString();\n+        }\n+        if (end == start) {\n+            throw new IOException(\"No padding\");\n+        }\n+        data.pos = data.end; \/\/ Compatibility. Reach end.\n+        if (end == start + 1) {\n+            return new BitArray(0);\n+        } else {\n+            int numOfPadBits = buffer[start];\n+            if ((numOfPadBits < 0) || (numOfPadBits > 7)) {\n+                throw new IOException(\"Invalid number of padding bits\");\n+            }\n+            return new BitArray((end - start - 1) * 8 - numOfPadBits,\n+                    Arrays.copyOfRange(buffer, start + 1, end));\n+        }\n@@ -652,4 +690,7 @@\n-        byte[] retVal = new byte[length];\n-        synchronized (data) {\n-            data.reset();\n-            data.getBytes(retVal);\n+        data.pos = data.end; \/\/ Compatibility. Reach end.\n+        return Arrays.copyOfRange(buffer, start, end);\n+    }\n+\n+    private String readStringInternal(byte expectedTag, Charset cs) throws IOException {\n+        if (tag != expectedTag) {\n+            throw new IOException(\"Incorrect string type \" + tag + \" is not \" + expectedTag);\n@@ -657,1 +698,2 @@\n-        return retVal;\n+        data.pos = data.end; \/\/ Compatibility. Reach end.\n+        return new String(buffer, start, end - start, cs);\n@@ -665,7 +707,2 @@\n-    public String getPrintableString()\n-    throws IOException {\n-        if (tag != tag_PrintableString)\n-            throw new IOException(\n-                \"DerValue.getPrintableString, not a string \" + tag);\n-\n-        return new String(getDataBytes(), US_ASCII);\n+    public String getPrintableString() throws IOException {\n+        return readStringInternal(tag_PrintableString, US_ASCII);\n@@ -680,5 +717,1 @@\n-        if (tag != tag_T61String)\n-            throw new IOException(\n-                \"DerValue.getT61String, not T61 \" + tag);\n-\n-        return new String(getDataBytes(), ISO_8859_1);\n+        return readStringInternal(tag_T61String, ISO_8859_1);\n@@ -693,5 +726,1 @@\n-        if (tag != tag_IA5String)\n-            throw new IOException(\n-                \"DerValue.getIA5String, not IA5 \" + tag);\n-\n-        return new String(getDataBytes(), US_ASCII);\n+        return readStringInternal(tag_IA5String, US_ASCII);\n@@ -707,7 +736,2 @@\n-        if (tag != tag_BMPString)\n-            throw new IOException(\n-                \"DerValue.getBMPString, not BMP \" + tag);\n-\n-        \/\/ BMPString is the same as Unicode in big endian, unmarked\n-        \/\/ format.\n-        return new String(getDataBytes(), UTF_16BE);\n+        \/\/ BMPString is the same as Unicode in big endian, unmarked format.\n+        return readStringInternal(tag_BMPString, UTF_16BE);\n@@ -723,5 +747,1 @@\n-        if (tag != tag_UTF8String)\n-            throw new IOException(\n-                \"DerValue.getUTF8String, not UTF-8 \" + tag);\n-\n-        return new String(getDataBytes(), UTF_8);\n+        return readStringInternal(tag_UTF8String, UTF_8);\n@@ -737,5 +757,1 @@\n-        if (tag != tag_GeneralString)\n-            throw new IOException(\n-                \"DerValue.getGeneralString, not GeneralString \" + tag);\n-\n-        return new String(getDataBytes(), US_ASCII);\n+        return readStringInternal(tag_GeneralString, US_ASCII);\n@@ -752,8 +768,207 @@\n-        if (tag != tag_UniversalString)\n-            throw new IOException(\n-                \"DerValue.getUniversalString, not UniversalString \" + tag);\n-        try {\n-            Charset cset = Charset.forName(\"UTF_32BE\");\n-            return new String(getDataBytes(), cset);\n-        } catch (IllegalCharsetNameException | UnsupportedCharsetException e) {\n-            return \"\";\n+        return readStringInternal(tag_UniversalString, new UTF_32BE());\n+    }\n+\n+    \/**\n+     * Private helper routine to extract time from the der value.\n+     * @param len the number of bytes to use\n+     * @param generalized true if Generalized Time is to be read, false\n+     * if UTC Time is to be read.\n+     *\/\n+    private Date getTime(int len, boolean generalized) throws IOException {\n+\n+        \/*\n+         * UTC time encoded as ASCII chars:\n+         *       YYMMDDhhmmZ\n+         *       YYMMDDhhmmssZ\n+         *       YYMMDDhhmm+hhmm\n+         *       YYMMDDhhmm-hhmm\n+         *       YYMMDDhhmmss+hhmm\n+         *       YYMMDDhhmmss-hhmm\n+         * UTC Time is broken in storing only two digits of year.\n+         * If YY < 50, we assume 20YY;\n+         * if YY >= 50, we assume 19YY, as per RFC 5280.\n+         *\n+         * Generalized time has a four-digit year and allows any\n+         * precision specified in ISO 8601. However, for our purposes,\n+         * we will only allow the same format as UTC time, except that\n+         * fractional seconds (millisecond precision) are supported.\n+         *\/\n+\n+        int year, month, day, hour, minute, second, millis;\n+        String type = null;\n+        int pos = start;\n+\n+        if (generalized) {\n+            type = \"Generalized\";\n+            year = 1000 * toDigit(buffer[pos++], type);\n+            year += 100 * toDigit(buffer[pos++], type);\n+            year += 10 * toDigit(buffer[pos++], type);\n+            year += toDigit(buffer[pos++], type);\n+            len -= 2; \/\/ For the two extra YY\n+        } else {\n+            type = \"UTC\";\n+            year = 10 * toDigit(buffer[pos++], type);\n+            year += toDigit(buffer[pos++], type);\n+\n+            if (year < 50) {             \/\/ origin 2000\n+                year += 2000;\n+            } else {\n+                year += 1900;   \/\/ origin 1900\n+            }\n+        }\n+\n+        month = 10 * toDigit(buffer[pos++], type);\n+        month += toDigit(buffer[pos++], type);\n+\n+        day = 10 * toDigit(buffer[pos++], type);\n+        day += toDigit(buffer[pos++], type);\n+\n+        hour = 10 * toDigit(buffer[pos++], type);\n+        hour += toDigit(buffer[pos++], type);\n+\n+        minute = 10 * toDigit(buffer[pos++], type);\n+        minute += toDigit(buffer[pos++], type);\n+\n+        len -= 10; \/\/ YYMMDDhhmm\n+\n+        \/*\n+         * We allow for non-encoded seconds, even though the\n+         * IETF-PKIX specification says that the seconds should\n+         * always be encoded even if it is zero.\n+         *\/\n+\n+        millis = 0;\n+        if (len > 2) {\n+            second = 10 * toDigit(buffer[pos++], type);\n+            second += toDigit(buffer[pos++], type);\n+            len -= 2;\n+            \/\/ handle fractional seconds (if present)\n+            if (generalized && (buffer[pos] == '.' || buffer[pos] == ',')) {\n+                len --;\n+                if (len == 0) {\n+                    throw new IOException(\"Parse \" + type +\n+                            \" time, empty fractional part\");\n+                }\n+                pos++;\n+                int precision = 0;\n+                while (buffer[pos] != 'Z' &&\n+                        buffer[pos] != '+' &&\n+                        buffer[pos] != '-') {\n+                    \/\/ Validate all digits in the fractional part but\n+                    \/\/ store millisecond precision only\n+                    int thisDigit = toDigit(buffer[pos], type);\n+                    precision++;\n+                    len--;\n+                    if (len == 0) {\n+                        throw new IOException(\"Parse \" + type +\n+                                \" time, invalid fractional part\");\n+                    }\n+                    pos++;\n+                    switch (precision) {\n+                        case 1:\n+                            millis += 100 * thisDigit;\n+                            break;\n+                        case 2:\n+                            millis += 10 * thisDigit;\n+                            break;\n+                        case 3:\n+                            millis += thisDigit;\n+                            break;\n+                    }\n+                }\n+                if (precision == 0) {\n+                    throw new IOException(\"Parse \" + type +\n+                            \" time, empty fractional part\");\n+                }\n+            }\n+        } else\n+            second = 0;\n+\n+        if (month == 0 || day == 0\n+                || month > 12 || day > 31\n+                || hour >= 24 || minute >= 60 || second >= 60) {\n+            throw new IOException(\"Parse \" + type + \" time, invalid format\");\n+        }\n+\n+        \/*\n+         * Generalized time can theoretically allow any precision,\n+         * but we're not supporting that.\n+         *\/\n+        CalendarSystem gcal = CalendarSystem.getGregorianCalendar();\n+        CalendarDate date = gcal.newCalendarDate(null); \/\/ no time zone\n+        date.setDate(year, month, day);\n+        date.setTimeOfDay(hour, minute, second, millis);\n+        long time = gcal.getTime(date);\n+\n+        \/*\n+         * Finally, \"Z\" or \"+hhmm\" or \"-hhmm\" ... offsets change hhmm\n+         *\/\n+        if (! (len == 1 || len == 5)) {\n+            throw new IOException(\"Parse \" + type + \" time, invalid offset\");\n+        }\n+\n+        int hr, min;\n+\n+        switch (buffer[pos++]) {\n+            case '+':\n+                if (len != 5) {\n+                    throw new IOException(\"Parse \" + type + \" time, invalid offset\");\n+                }\n+                hr = 10 * toDigit(buffer[pos++], type);\n+                hr += toDigit(buffer[pos++], type);\n+                min = 10 * toDigit(buffer[pos++], type);\n+                min += toDigit(buffer[pos++], type);\n+\n+                if (hr >= 24 || min >= 60) {\n+                    throw new IOException(\"Parse \" + type + \" time, +hhmm\");\n+                }\n+\n+                time -= ((hr * 60) + min) * 60 * 1000;\n+                break;\n+\n+            case '-':\n+                if (len != 5) {\n+                    throw new IOException(\"Parse \" + type + \" time, invalid offset\");\n+                }\n+                hr = 10 * toDigit(buffer[pos++], type);\n+                hr += toDigit(buffer[pos++], type);\n+                min = 10 * toDigit(buffer[pos++], type);\n+                min += toDigit(buffer[pos++], type);\n+\n+                if (hr >= 24 || min >= 60) {\n+                    throw new IOException(\"Parse \" + type + \" time, -hhmm\");\n+                }\n+\n+                time += ((hr * 60) + min) * 60 * 1000;\n+                break;\n+\n+            case 'Z':\n+                if (len != 1) {\n+                    throw new IOException(\"Parse \" + type + \" time, invalid format\");\n+                }\n+                break;\n+\n+            default:\n+                throw new IOException(\"Parse \" + type + \" time, garbage offset\");\n+        }\n+        return new Date(time);\n+    }\n+\n+    \/**\n+     * Converts byte (represented as a char) to int.\n+     * @throws IOException if integer is not a valid digit in the specified\n+     *    radix (10)\n+     *\/\n+    private static int toDigit(byte b, String type) throws IOException {\n+        if (b < '0' || b > '9') {\n+            throw new IOException(\"Parse \" + type + \" time, invalid format\");\n+        }\n+        return b - '0';\n+    }\n+\n+    public void getNull() throws IOException {\n+        if (tag != tag_Null) {\n+            throw new IOException(\"DerValue.getUTCTime, not a UtcTime: \" + tag);\n+        }\n+        if (end != start) {\n+            throw new IOException(\"DER UTC Time length error\");\n@@ -772,1 +987,5 @@\n-        return buffer.getUTCTime(data.available());\n+        if (end - start < 11 || end - start > 17)\n+            throw new IOException(\"DER UTC Time length error\");\n+\n+        data.pos = data.end; \/\/ Compatibility. Reach end.\n+        return getTime(end - start, false);\n@@ -785,1 +1004,5 @@\n-        return buffer.getGeneralizedTime(data.available());\n+        if (end - start < 13)\n+            throw new IOException(\"DER Generalized Time length error\");\n+\n+        data.pos = data.end; \/\/ Compatibility. Reach end.\n+        return getTime(end - start, true);\n@@ -807,1 +1030,1 @@\n-        if (data == other.data) {\n+        if (buffer == other.buffer && start == other.start && end == other.end) {\n@@ -810,19 +1033,1 @@\n-\n-        \/\/ make sure the order of lock is always consistent to avoid a deadlock\n-        return (System.identityHashCode(this.data)\n-                > System.identityHashCode(other.data)) ?\n-                doEquals(this, other):\n-                doEquals(other, this);\n-    }\n-\n-    \/**\n-     * Helper for public method equals()\n-     *\/\n-    private static boolean doEquals(DerValue d1, DerValue d2) {\n-        synchronized (d1.data) {\n-            synchronized (d2.data) {\n-                d1.data.reset();\n-                d2.data.reset();\n-                return d1.buffer.equals(d2.buffer);\n-            }\n-        }\n+        return Arrays.equals(buffer, start, end, other.buffer, other.start, other.end);\n@@ -838,17 +1043,2 @@\n-        try {\n-\n-            String str = getAsString();\n-            if (str != null)\n-                return \"\\\"\" + str + \"\\\"\";\n-            if (tag == tag_Null)\n-                return \"[DerValue, null]\";\n-            if (tag == tag_ObjectId)\n-                return \"OID.\" + getOID();\n-\n-            \/\/ integers\n-            else\n-                return \"[DerValue, tag = \" + tag\n-                        + \", length = \" + length + \"]\";\n-        } catch (IOException e) {\n-            throw new IllegalArgumentException(\"misformatted DER value\");\n-        }\n+        return String.format(\"DerValue(%02x, %s, %d, 5d)\",\n+                0xff & tag, buffer, start, end);\n@@ -865,1 +1055,0 @@\n-\n@@ -867,1 +1056,1 @@\n-        data.reset();\n+        data.pos = data.start; \/\/ encode go last, should go back\n@@ -879,1 +1068,1 @@\n-            return new DerInputStream(buffer);\n+            return data;\n@@ -887,1 +1076,1 @@\n-        return length;\n+        return end - start;\n@@ -959,0 +1148,10 @@\n+    \/**\n+     * Returns a new DerValuw with a different tag.\n+     *\n+     * @param newTag the new tag\n+     * @return a new DerValue\n+     *\/\n+    public DerValue withTag(byte newTag) {\n+        return new DerValue(newTag, buffer, start, end, allowBER);\n+    }\n+\n@@ -966,1 +1165,17 @@\n-        return toString().hashCode();\n+        int result = tag;\n+        for (int i = start; i < end; i++) {\n+            result = 31 * result + buffer[i];\n+        }\n+        return result;\n+    }\n+\n+    DerValue[] subs(byte expectedTag, int startLen) throws IOException {\n+        if (expectedTag != 0 && expectedTag != tag) {\n+            throw new IOException(\"Not the correct tag\");\n+        }\n+        List<DerValue> result = new ArrayList<>(startLen);\n+        DerInputStream dis = new DerInputStream(this);\n+        while (dis.available() > 0) {\n+            result.add(dis.getDerValue());\n+        }\n+        return result.toArray(new DerValue[result.size()]);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DerValue.java","additions":558,"deletions":343,"binary":false,"changes":901,"status":"modified"},{"patch":"@@ -141,1 +141,2 @@\n-            \/\/ Check the estimated size before it is too later.\n+            \/\/ Check the estimated size before it is too late. The check\n+            \/\/ will be performed again in init().\n@@ -143,1 +144,0 @@\n-\n@@ -147,0 +147,1 @@\n+            check(encoding);\n@@ -247,42 +248,3 @@\n-    \/**\n-     * Constructor, from an ASN.1 encoded input stream.\n-     * Validity check NOT included.\n-     * The encoding of the ID in the stream uses \"DER\", a BER\/1 subset.\n-     * In this case, that means a triple { typeId, length, data }.\n-     *\n-     * <P><STRONG>NOTE:<\/STRONG>  When an exception is thrown, the\n-     * input stream has not been returned to its \"initial\" state.\n-     *\n-     * @param in DER-encoded data holding an object ID\n-     * @exception IOException indicates a decoding error\n-     *\/\n-    public ObjectIdentifier(DerInputStream in) throws IOException {\n-        byte    type_id;\n-        int     bufferEnd;\n-\n-        \/*\n-         * Object IDs are a \"universal\" type, and their tag needs only\n-         * one byte of encoding.  Verify that the tag of this datum\n-         * is that of an object ID.\n-         *\n-         * Then get and check the length of the ID's encoding.  We set\n-         * up so that we can use in.available() to check for the end of\n-         * this value in the data stream.\n-         *\/\n-        type_id = (byte)in.getByte();\n-        if (type_id != DerValue.tag_ObjectId)\n-            throw new IOException (\n-                \"ObjectIdentifier() -- data isn't an object ID\"\n-                + \" (tag = \" +  type_id + \")\"\n-                );\n-\n-        int len = in.getDefiniteLength();\n-        checkOidSize(len);\n-        if (len > in.available()) {\n-            throw new IOException(\"ObjectIdentifier length exceeds \" +\n-                    \"data available.  Length: \" + len + \", Available: \" +\n-                    in.available());\n-        }\n-\n-        encoding = new byte[len];\n-        in.getBytes(encoding);\n+    \/\/ Called by DerValue::getOID. No need to clone input.\n+    ObjectIdentifier(byte[] encoding) throws IOException {\n+        checkOidSize(encoding.length);\n@@ -290,0 +252,1 @@\n+        this.encoding = encoding;\n@@ -292,4 +255,4 @@\n-    \/*\n-     * Constructor, from the rest of a DER input buffer;\n-     * the tag and length have been removed\/verified\n-     * Validity check NOT included.\n+    \/**\n+     * Reads an ObjectIdentifier from a DerInputStream.\n+     * @param in the input stream\n+     * @throws IOException if there is an encoding error\n@@ -297,8 +260,2 @@\n-    ObjectIdentifier(DerInputBuffer buf) throws IOException {\n-        DerInputStream in = new DerInputStream(buf);\n-        int len = in.available();\n-        checkOidSize(len);\n-\n-        encoding = new byte[len];\n-        in.getBytes(encoding);\n-        check(encoding);\n+    public ObjectIdentifier(DerInputStream in) throws IOException {\n+        encoding = in.getDerValue().getOID().encoding;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/ObjectIdentifier.java","additions":13,"deletions":56,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -1,111 +0,0 @@\n-\/*\n- * Copyright (c) 1999, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @author Gary Ellison\n- * @bug 4170635\n- * @summary Verify equals()\/hashCode() contract honored\n- * @modules java.base\/sun.security.util:+open\n- *          java.base\/sun.security.x509\n- * @run main\/othervm\/policy=Allow.policy DerInputBufferEqualsHashCode\n- *\/\n-\n-import java.io.*;\n-import sun.security.util.*;\n-import sun.security.x509.*;\n-import java.lang.reflect.*;\n-\n-\n-public class DerInputBufferEqualsHashCode {\n-\n-    public static void main(String[] args) throws Exception {\n-\n-        String name1 = \"CN=eve s. dropper\";\n-        DerOutputStream deros;\n-        byte[] ba;\n-        \/\/ encode\n-        X500Name dn1 = new X500Name(name1);\n-\n-        deros = new DerOutputStream();\n-        dn1.encode(deros);\n-        ba = deros.toByteArray();\n-\n-        GetDIBConstructor a = new GetDIBConstructor();\n-        java.security.AccessController.doPrivileged(a);\n-        Constructor c = a.getCons();\n-\n-        Object[] objs = new Object[1];\n-        objs[0] = ba;\n-\n-        Object db1 = null, db2 = null;\n-        try {\n-            db1 = c.newInstance(objs);\n-            db2 = c.newInstance(objs);\n-        } catch (Exception e) {\n-            System.out.println(\"Caught unexpected exception \" + e);\n-            throw e;\n-        }\n-\n-        if ( (db1.equals(db2)) == (db1.hashCode()==db2.hashCode()) )\n-            System.out.println(\"PASSED\");\n-        else\n-            throw new Exception(\"FAILED equals()\/hashCode() contract\");\n-\n-    }\n-}\n-\n-\n-class GetDIBConstructor implements java.security.PrivilegedExceptionAction {\n-\n-    private Class dibClass = null;\n-    private Constructor dibCons = null;\n-\n-    public Object run() throws Exception {\n-        try {\n-            dibClass = Class.forName(\"sun.security.util.DerInputBuffer\");\n-            Constructor[] cons = dibClass.getDeclaredConstructors();\n-\n-            int i;\n-            for (i = 0; i < cons.length; i++) {\n-                Class [] parms = cons[i].getParameterTypes();\n-                if (parms.length == 1) {\n-                    if (parms[0].getName().equalsIgnoreCase(\"[B\")) {\n-                        cons[i].setAccessible(true);\n-                        break;\n-                    }\n-                }\n-            }\n-            dibCons = cons[i];\n-        } catch (Exception e) {\n-            System.out.println(\"Caught unexpected exception \" + e);\n-            throw e;\n-        }\n-        return dibCons;\n-    }\n-\n-    public Constructor getCons(){\n-        return dibCons;\n-    }\n-\n-}\n","filename":"test\/jdk\/sun\/security\/util\/DerInputBuffer\/DerInputBufferEqualsHashCode.java","additions":0,"deletions":111,"binary":false,"changes":111,"status":"deleted"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8249783\n+ * @summary read very deep constructed OCTET STRING\n+ * @modules java.base\/sun.security.util\n+ * @library \/test\/lib\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import sun.security.util.DerInputStream;\n+import sun.security.util.DerValue;\n+\n+import java.io.IOException;\n+\n+public class DeepOctets {\n+\n+    public static void main(String[] args) throws Exception {\n+        byte[] input = {\n+            0x24, 24,\n+                0x24, 8, 4, 2, 'a', 'b', 4, 2, 'c', 'd',\n+                0x24, 8, 4, 2, 'e', 'f', 4, 2, 'g', 'h',\n+                4, 2, 'i', 'j'\n+        };\n+\n+        \/\/ DerValue::getOctetString supports constructed BER\n+        byte[] s = new DerValue(input).getOctetString();\n+        Asserts.assertEQ(new String(s), \"abcdefghij\");\n+\n+        \/\/ DerInputStream::getOctetString does not\n+        Utils.runAndCheckException(\n+                () -> new DerInputStream(input).getOctetString(),\n+                IOException.class);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/util\/DerValue\/DeepOctets.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 6731685\n+ * @bug 6731685 8249783\n@@ -32,0 +32,2 @@\n+import java.util.Arrays;\n+\n@@ -39,1 +41,1 @@\n-            4, (byte)0x80, 4, 2, 'a', 'b', 4, 2, 'c', 'd', 0, 0,\n+            0x24, (byte)0x80, 4, 2, 'a', 'b', 4, 2, 'c', 'd', 0, 0,\n@@ -43,1 +45,2 @@\n-        new DerValue(new ByteArrayInputStream(input));\n+        DerValue v = new DerValue(new ByteArrayInputStream(input));\n+        System.out.println(Arrays.toString(v.getOctetString()));\n","filename":"test\/jdk\/sun\/security\/util\/DerValue\/Indefinite.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"}]}