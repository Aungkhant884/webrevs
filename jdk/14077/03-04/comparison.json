{"files":[{"patch":"@@ -70,5 +70,0 @@\n-#ifdef ASSERT\n-bool G1Allocator::has_mutator_alloc_region(uint node_index) {\n-  return mutator_alloc_region(node_index)->get() != nullptr;\n-}\n-#endif\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -100,5 +100,0 @@\n-#ifdef ASSERT\n-  \/\/ Do we currently have an active mutator region to allocate into?\n-  bool has_mutator_alloc_region(uint node_index);\n-#endif\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -419,2 +419,1 @@\n-    bool succeeded = false;\n-    do_collection_pause(word_size, gc_count_before, &succeeded, gc_cause);\n+    do_collection_pause(word_size, gc_count_before, gc_cause);\n@@ -430,7 +429,1 @@\n-    if (request.state() == StalledAllocReq::AllocationState::Pending) {\n-      \/\/ GC Safepoint did not handle our allocation request. We should retry.\n-      _stalled_allocations.remove(&request);\n-      return false;\n-    } else {\n-      _satisfied_allocations.remove(&request);\n-    }\n+    _stalled_allocations.remove(&request);\n@@ -439,1 +432,4 @@\n-  if (request.state() == StalledAllocReq::AllocationState::Success) {\n+  if (request.pending()) {\n+    \/\/ GC Safepoint did not handle our allocation request. We should retry.\n+    return false;\n+  } else if (request.succeeded()) {\n@@ -442,1 +438,1 @@\n-    assert(request.state() == StalledAllocReq::AllocationState::Failed, \"Sanity check!\");\n+    assert(request.failed(), \"Sanity check!\");\n@@ -722,2 +718,1 @@\n-                                                           uint node_index,\n-                                                           bool expect_null_mutator_alloc_region) {\n+                                                           uint node_index) {\n@@ -725,2 +720,0 @@\n-  assert(!_allocator->has_mutator_alloc_region(node_index) || !expect_null_mutator_alloc_region,\n-         \"the current alloc region was unexpectedly found to be non-null\");\n@@ -926,2 +919,1 @@\n-                                                            uint node_index,\n-                                                            bool expect_null_mutator_alloc_region) {\n+                                                            uint node_index) {\n@@ -931,2 +923,1 @@\n-                                    node_index,\n-                                    expect_null_mutator_alloc_region);\n+                                    node_index);\n@@ -943,2 +934,1 @@\n-                                           node_index,\n-                                           expect_null_mutator_alloc_region);\n+                                           node_index);\n@@ -951,1 +941,1 @@\n-  if (!has_satisfied_allocations()) {\n+  if (!has_stalled_allocations()) {\n@@ -955,3 +945,2 @@\n-  for(StalledAllocReq* alloc_req : _satisfied_allocations) {\n-    if (alloc_req->state() == StalledAllocReq::AllocationState::Success &&\n-        alloc_req->result() == obj) {\n+  for(StalledAllocReq* alloc_req : _stalled_allocations) {\n+    if (alloc_req->succeeded() && alloc_req->result() == obj) {\n@@ -1007,5 +996,4 @@\n-  DoublyLinkedList<StalledAllocReq>::RemoveIterator iter(&_stalled_allocations);\n-\n-  for (StalledAllocReq* alloc_req; iter.next(&alloc_req);) {\n-    alloc_req->set_state(StalledAllocReq::AllocationState::Failed);\n-    _satisfied_allocations.insert_last(alloc_req);\n+  for (StalledAllocReq* alloc_req : _stalled_allocations) {\n+    if (alloc_req->pending()) {\n+      alloc_req->set_state(StalledAllocReq::AllocationState::Failed);\n+    }\n@@ -1022,15 +1010,2 @@\n-  DoublyLinkedList<StalledAllocReq> prev_allocations;\n-\n-  prev_allocations.swap(_satisfied_allocations);\n-\n-  assert(_satisfied_allocations.is_empty(), \"Sanity check!\");\n-\n-  DoublyLinkedList<StalledAllocReq>::RemoveIterator iter(&prev_allocations);\n-\n-  for (StalledAllocReq* alloc_req; iter.next(&alloc_req);) {\n-    if (alloc_req->state() == StalledAllocReq::AllocationState::Failed) {\n-      \/\/ If an allocation request was declared failed, we maintain the failed state.\n-      \/\/ This prevents requests from flip-floping between Pending->Failed->Pending states.\n-      \/\/ Once any allocation attempt declares a request as failed, that request will not be re-attempted.\n-      _satisfied_allocations.insert_first(alloc_req);\n-    } else {\n+  for (StalledAllocReq* alloc_req : _stalled_allocations) {\n+    if (alloc_req->succeeded()) {\n@@ -1038,1 +1013,0 @@\n-      _stalled_allocations.insert_first(alloc_req);\n@@ -1046,12 +1020,7 @@\n-  const uint active_numa_nodes = G1NUMA::numa()->num_active_nodes();\n-  bool *expect_null_alloc_regions = (bool*)alloca(active_numa_nodes * sizeof(bool));\n-  for (uint i = 0; i < active_numa_nodes; i++) {\n-    expect_null_alloc_regions[i] = expect_null_mutator_alloc_region;\n-  }\n-\n-  while (true) {\n-    StalledAllocReq* alloc_req = _stalled_allocations.first();\n-    if (alloc_req == nullptr) {\n-      \/\/ No more pending requests, all allocations succeeded.\n-      return true;\n-    }\n+  for (StalledAllocReq* alloc_req : _stalled_allocations) {\n+    if (alloc_req->failed()) {\n+      \/\/ If an allocation request was declared failed, we maintain the failed state.\n+      \/\/ This prevents requests from flip-floping between Pending->Failed->Pending states.\n+      \/\/ Once any allocation attempt declares a request as failed, that request will not be re-attempted.\n+      continue;\n+     }\n@@ -1061,2 +1030,1 @@\n-                                       alloc_req->node_index(),\n-                                       expect_null_alloc_regions[alloc_req->node_index()]);\n+                                       alloc_req->node_index());\n@@ -1069,2 +1037,0 @@\n-    expect_null_alloc_regions[alloc_req->node_index()] = false;\n-\n@@ -1074,0 +1040,3 @@\n+    \/\/ Initialize memory locations with filler objects such that the heap is passable\n+    \/\/ even when there is a delay between the allocation and object initialization\n+    \/\/ by the requesting mutator thread.\n@@ -1089,1 +1058,0 @@\n-      \/\/ Fill the allocated memory with filler objects.\n@@ -1092,4 +1060,0 @@\n-\n-    \/\/ Move the allocation request from stalled to satisfied list.\n-    _stalled_allocations.remove(alloc_req);\n-    _satisfied_allocations.insert_last(alloc_req);\n@@ -1097,0 +1061,1 @@\n+  return true;\n@@ -1254,1 +1219,0 @@\n-  _satisfied_allocations(),\n@@ -2401,1 +2365,0 @@\n-                                               bool* succeeded,\n@@ -2411,1 +2374,0 @@\n-  *succeeded = ret_succeeded;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":32,"deletions":70,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -212,0 +212,3 @@\n+    bool failed() { return _state == AllocationState::Failed; }\n+    bool succeeded() { return _state == AllocationState::Success; }\n+    bool pending() { return _state == AllocationState::Pending; }\n@@ -224,1 +227,0 @@\n-  DoublyLinkedList<StalledAllocReq> _satisfied_allocations;\n@@ -254,1 +256,1 @@\n-  bool has_satisfied_allocations() { return !_satisfied_allocations.is_empty(); }\n+  bool has_stalled_allocations() { return !_stalled_allocations.is_empty(); }\n@@ -529,2 +531,1 @@\n-  \/\/ to use for allocation. expect_null_mutator_alloc_region specifies\n-  \/\/ whether the mutator alloc region is expected to be null or not.\n+  \/\/ to use for allocation.\n@@ -532,2 +533,1 @@\n-                                            uint node_index,\n-                                            bool expect_null_mutator_alloc_region);\n+                                            uint node_index);\n@@ -584,2 +584,1 @@\n-                                             uint node_index,\n-                                             bool expect_null_mutator_alloc_region);\n+                                             uint node_index);\n@@ -802,6 +801,3 @@\n-  \/\/ satisfy an allocation request of word_size. *succeeded will\n-  \/\/ return whether the VM operation was successful (it did do an\n-  \/\/ evacuation pause) or not (another thread beat us to it or the GC\n-  \/\/ locker was active). Given that we should not be holding the\n-  \/\/ Heap_lock when we enter this method, we will pass the\n-  \/\/ gc_count_before (i.e., total_collections()) as a parameter since\n+  \/\/ satisfy any pending allocation requests. Given that we should\n+  \/\/ not be holding the Heap_lock when we enter this method, we will pass\n+  \/\/ the gc_count_before (i.e., total_collections()) as a parameter since\n@@ -813,1 +809,0 @@\n-                                bool*          succeeded,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":10,"deletions":15,"binary":false,"changes":25,"status":"modified"}]}