{"files":[{"patch":"@@ -906,1 +906,1 @@\n-  \/\/ Reset any allocated but yet claimed allocation requests.\n+  \/\/ Reset any allocated but unclaimed allocation requests.\n@@ -958,0 +958,14 @@\n+bool G1CollectedHeap::is_unclaimed_allocation(HeapWord *obj) {\n+  if (!has_satisfied_allocations()) {\n+    return false;\n+  }\n+\n+  for(StalledAllocReq* alloc_req : _satisfied_allocations) {\n+    if (alloc_req->state() == StalledAllocReq::AllocationState::Success &&\n+        alloc_req->result() == obj) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -961,1 +975,1 @@\n-  bool success = handle_allocation_requests(false \/* expect_null_mutator_alloc_region*\/);\n+  bool alloc_succeeded = handle_allocation_requests(false \/* expect_null_mutator_alloc_region*\/);\n@@ -963,2 +977,2 @@\n-  if (success) {\n-   return success;\n+  if (alloc_succeeded) {\n+    return alloc_succeeded;\n@@ -977,1 +991,1 @@\n-  success = handle_allocation_requests(true \/* expect_null_mutator_alloc_region*\/);\n+  alloc_succeeded = handle_allocation_requests(true \/* expect_null_mutator_alloc_region*\/);\n@@ -979,2 +993,2 @@\n-  if (success) {\n-   return success;\n+  if (alloc_succeeded) {\n+    return alloc_succeeded;\n@@ -985,1 +999,0 @@\n-\n@@ -994,1 +1007,1 @@\n-  success = handle_allocation_requests(true \/* expect_null_mutator_alloc_region*\/);\n+  alloc_succeeded = handle_allocation_requests(true \/* expect_null_mutator_alloc_region*\/);\n@@ -996,2 +1009,2 @@\n-  if (success) {\n-   return success;\n+  if (alloc_succeeded) {\n+    return alloc_succeeded;\n@@ -1005,1 +1018,0 @@\n-    _satisfied_allocations.insert_last(alloc_req);\n@@ -1007,0 +1019,1 @@\n+    _satisfied_allocations.insert_last(alloc_req);\n@@ -1042,1 +1055,1 @@\n-  bool *expect_null_alloc_regions = (bool *)alloca(active_numa_nodes * sizeof(bool));\n+  bool *expect_null_alloc_regions = (bool*)alloca(active_numa_nodes * sizeof(bool));\n@@ -1047,1 +1060,1 @@\n-  while(true) {\n+  while (true) {\n@@ -1057,2 +1070,1 @@\n-                                       expect_null_alloc_regions[alloc_req->node_index()]\n-                                       );\n+                                       expect_null_alloc_regions[alloc_req->node_index()]);\n@@ -1067,1 +1079,1 @@\n-    \/\/ Allocation succeeded, update the state and result of the allocation request\n+    \/\/ Allocation succeeded, update the state and result of the allocation request.\n@@ -1071,1 +1083,1 @@\n-      \/\/ Calculate payload size and initialize the humongous object with a fillerArray\n+      \/\/ Calculate payload size and initialize the humongous object with a fillerArray.\n@@ -1085,1 +1097,1 @@\n-      \/\/ Fill the allocated memory with filler objects\n+      \/\/ Fill the allocated memory with filler objects.\n@@ -1089,1 +1101,1 @@\n-    \/\/ Move the allocation request from stalled to satisfied list\n+    \/\/ Move the allocation request from stalled to satisfied list.\n@@ -1112,4 +1124,0 @@\n-\/\/ Attempting to expand the heap sufficiently\n-\/\/ to support an allocation of the given \"word_size\". If\n-\/\/ successful, perform the allocation and return the address of the\n-\/\/ allocated block, or else null.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":32,"deletions":24,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -172,0 +172,12 @@\n+  \/\/ StalledAllocReq represents a stalled allocation request in a doubly linked list.\n+  \/\/\n+  \/\/ It provides functionality to track and manage an allocation request. The\n+  \/\/ allocation request encapsulates information such as the size of the allocation,\n+  \/\/ the NUMA (Non-Uniform Memory Access) node index, the state of the allocation,\n+  \/\/ and the resulting memory address.\n+  \/\/\n+  \/\/ The state of an allocation request can transition from Pending to Failed or\n+  \/\/ Success. Failed state is a terminating state, indicating that the allocation\n+  \/\/ request has failed. However, the Success state may be reset to Pending if an\n+  \/\/ interfering safepoint observes the successful allocation before the requesting\n+  \/\/ thread.\n@@ -174,0 +186,1 @@\n+\n@@ -179,0 +192,1 @@\n+\n@@ -188,3 +202,1 @@\n-    size_t size() {\n-      return _size;\n-    }\n+    size_t size() { return _size; }\n@@ -192,3 +204,1 @@\n-    uint node_index() const {\n-      return _node_index;\n-    }\n+    uint node_index() const { return _node_index; }\n@@ -201,3 +211,3 @@\n-    AllocationState state() {\n-      return _state;\n-    }\n+    AllocationState state() { return _state; }\n+\n+    HeapWord* result() { return _result; }\n@@ -205,3 +215,0 @@\n-    HeapWord* result() {\n-      return _result;\n-    }\n@@ -216,2 +223,2 @@\n-  DoublyLinkedList<StalledAllocReq>  _stalled_allocations;\n-  DoublyLinkedList<StalledAllocReq>  _satisfied_allocations;\n+  DoublyLinkedList<StalledAllocReq> _stalled_allocations;\n+  DoublyLinkedList<StalledAllocReq> _satisfied_allocations;\n@@ -246,0 +253,4 @@\n+\n+  bool has_satisfied_allocations() { return !_satisfied_allocations.is_empty(); }\n+  bool is_unclaimed_allocation(HeapWord *obj);\n+\n@@ -576,4 +587,3 @@\n-  \/\/ Attempting to expand the heap sufficiently\n-  \/\/ to support an allocation of the given \"word_size\".  If\n-  \/\/ successful, perform the allocation and return the address of the\n-  \/\/ allocated block, or else null.\n+  \/\/ Attempts to expand the heap sufficiently to support an allocation of the\n+  \/\/ given \"word_size\". If successful, perform the allocation and return the address\n+  \/\/ of the allocated block, or else null.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":28,"deletions":18,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -1109,2 +1109,1 @@\n-        oop obj = cast_to_oop(hr->humongous_start_region()->bottom());\n-        if (G1CollectedHeap::is_obj_filler(obj)) { \/\/ Object allocated, but not well-formed\n+        if (_g1h->is_unclaimed_allocation(hr->humongous_start_region()->bottom())) {\n@@ -1162,2 +1161,1 @@\n-          oop obj = cast_to_oop(hr->bottom());\n-          if (G1CollectedHeap::is_obj_filler(obj)) { \/\/ Object allocated, but not well-formed\n+          if (_g1h->is_unclaimed_allocation(hr->humongous_start_region()->bottom())) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -55,0 +55,4 @@\n+  \/\/ Any allocation requests that were handled during a previous GC safepoint but\n+  \/\/ have not been observed by the requesting mutator thread should be reset to\n+  \/\/ pending. This makes it easier for the current GC to treat the unclaimed memory\n+  \/\/ as garbage.\n@@ -56,0 +60,1 @@\n+\n@@ -130,10 +135,4 @@\n-  \/\/ Any allocation requests that were handled during a previous GC safepoint but have not been observed\n-  \/\/ by the requesting mutator thread should be reset to pending. This makes it easier for the current GC to\n-  \/\/ treat the unclaimed memory as garbage.\n-  g1h->reset_allocation_requests();\n-\n-  bool gc_succeeded = false;\n-  bool has_pending_allocations = !g1h->_stalled_allocations.is_empty();\n-\n-  if (has_pending_allocations) {\n-    bool success = g1h->handle_allocation_requests(false \/* expect_null_mutator_alloc_region*\/);\n+  \/\/ If any allocation has been requested, try to do that first.\n+  bool has_allocation_requests = !g1h->_stalled_allocations.is_empty();\n+  if (has_allocation_requests) {\n+    bool alloc_succeeded = g1h->handle_allocation_requests(false \/* expect_null_mutator_alloc_region*\/);\n@@ -141,2 +140,2 @@\n-    if (success) {\n-    return;\n+    if (alloc_succeeded) {\n+      return;\n@@ -144,3 +143,0 @@\n-    \/\/ Could not handle all pending allocations, so we reset those that were handled\n-    \/\/ before attempting the collection.\n-    g1h->reset_allocation_requests();\n@@ -149,0 +145,3 @@\n+  \/\/ Reset any satisfied allocation requests before attempting the collection.\n+  g1h->reset_allocation_requests();\n+\n@@ -150,0 +149,1 @@\n+  bool gc_succeeded = false;\n@@ -157,1 +157,3 @@\n-  if (has_pending_allocations) {\n+  has_allocation_requests = !g1h->_stalled_allocations.is_empty();\n+\n+  if (has_allocation_requests) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.cpp","additions":18,"deletions":16,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-  return align_object_offset(arrayOopDesc::header_size(T_INT)); \/\/ align to Long\n+  return align_object_offset(arrayOopDesc::header_size(T_INT)); \/\/ Align to INT.\n@@ -54,1 +54,1 @@\n-  return align_object_size(filler_array_hdr_size()); \/\/ align to MinObjAlignment\n+  return align_object_size(filler_array_hdr_size()); \/\/ Align to MinObjAlignment.\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/utilities\/doublyLinkedList.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -175,1 +175,2 @@\n- * @run main\/othervm -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g\n+ * @run main\/othervm -Xlog:gc+region=trace -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g\n+ *      -XX:VerifyGCType=full -XX:+VerifyDuringGC -XX:+VerifyAfterGC\n","filename":"test\/hotspot\/jtreg\/gc\/TestAllocHumongousFragment.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}