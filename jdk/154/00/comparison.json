{"files":[{"patch":"@@ -5274,1 +5274,1 @@\n-  if (VM_Version::supports_dcpop()) {\n+  if (VM_Version::features() & VM_Version::CPU_DCPOP) {\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,3 +27,0 @@\n-#include \"asm\/macroAssembler.hpp\"\n-#include \"asm\/macroAssembler.inline.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n@@ -33,1 +30,0 @@\n-#include \"runtime\/stubCodeGenerator.hpp\"\n@@ -40,46 +36,0 @@\n-#include <asm\/hwcap.h>\n-#include <sys\/auxv.h>\n-#include <sys\/prctl.h>\n-\n-#ifndef HWCAP_AES\n-#define HWCAP_AES   (1<<3)\n-#endif\n-\n-#ifndef HWCAP_PMULL\n-#define HWCAP_PMULL (1<<4)\n-#endif\n-\n-#ifndef HWCAP_SHA1\n-#define HWCAP_SHA1  (1<<5)\n-#endif\n-\n-#ifndef HWCAP_SHA2\n-#define HWCAP_SHA2  (1<<6)\n-#endif\n-\n-#ifndef HWCAP_CRC32\n-#define HWCAP_CRC32 (1<<7)\n-#endif\n-\n-#ifndef HWCAP_ATOMICS\n-#define HWCAP_ATOMICS (1<<8)\n-#endif\n-\n-#ifndef HWCAP_SHA512\n-#define HWCAP_SHA512 (1 << 21)\n-#endif\n-\n-#ifndef HWCAP_SVE\n-#define HWCAP_SVE (1 << 22)\n-#endif\n-\n-#ifndef HWCAP2_SVE2\n-#define HWCAP2_SVE2 (1 << 1)\n-#endif\n-\n-#ifndef PR_SVE_GET_VL\n-\/\/ For old toolchains which do not have SVE related macros defined.\n-#define PR_SVE_SET_VL   50\n-#define PR_SVE_GET_VL   51\n-#endif\n-\n@@ -92,15 +42,0 @@\n-bool VM_Version::_dcpop;\n-int VM_Version::_initial_sve_vector_length;\n-VM_Version::PsrInfo VM_Version::_psr_info   = { 0, };\n-\n-static BufferBlob* stub_blob;\n-static const int stub_size = 550;\n-\n-extern \"C\" {\n-  typedef void (*getPsrInfo_stub_t)(void*);\n-}\n-static getPsrInfo_stub_t getPsrInfo_stub = NULL;\n-\n-\n-class VM_Version_StubGenerator: public StubCodeGenerator {\n- public:\n@@ -108,27 +43,4 @@\n-  VM_Version_StubGenerator(CodeBuffer *c) : StubCodeGenerator(c) {}\n-\n-  address generate_getPsrInfo() {\n-    StubCodeMark mark(this, \"VM_Version\", \"getPsrInfo_stub\");\n-#   define __ _masm->\n-    address start = __ pc();\n-\n-    \/\/ void getPsrInfo(VM_Version::PsrInfo* psr_info);\n-\n-    address entry = __ pc();\n-\n-    __ enter();\n-\n-    __ get_dczid_el0(rscratch1);\n-    __ strw(rscratch1, Address(c_rarg0, in_bytes(VM_Version::dczid_el0_offset())));\n-\n-    __ get_ctr_el0(rscratch1);\n-    __ strw(rscratch1, Address(c_rarg0, in_bytes(VM_Version::ctr_el0_offset())));\n-\n-    __ leave();\n-    __ ret(lr);\n-\n-#   undef __\n-\n-    return start;\n-  }\n-};\n+int VM_Version::_zva_length;\n+int VM_Version::_dcache_line_size;\n+int VM_Version::_icache_line_size;\n+int VM_Version::_initial_sve_vector_length;\n@@ -136,1 +48,1 @@\n-void VM_Version::get_processor_features() {\n+void VM_Version::initialize() {\n@@ -143,1 +55,1 @@\n-  getPsrInfo_stub(&_psr_info);\n+  get_os_cpu_info();\n@@ -185,33 +97,0 @@\n-  uint64_t auxv = getauxval(AT_HWCAP);\n-  uint64_t auxv2 = getauxval(AT_HWCAP2);\n-\n-  char buf[512];\n-\n-  _features = auxv;\n-\n-  int cpu_lines = 0;\n-  if (FILE *f = fopen(\"\/proc\/cpuinfo\", \"r\")) {\n-    \/\/ need a large buffer as the flags line may include lots of text\n-    char buf[1024], *p;\n-    while (fgets(buf, sizeof (buf), f) != NULL) {\n-      if ((p = strchr(buf, ':')) != NULL) {\n-        long v = strtol(p+1, NULL, 0);\n-        if (strncmp(buf, \"CPU implementer\", sizeof \"CPU implementer\" - 1) == 0) {\n-          _cpu = v;\n-          cpu_lines++;\n-        } else if (strncmp(buf, \"CPU variant\", sizeof \"CPU variant\" - 1) == 0) {\n-          _variant = v;\n-        } else if (strncmp(buf, \"CPU part\", sizeof \"CPU part\" - 1) == 0) {\n-          if (_model != v)  _model2 = _model;\n-          _model = v;\n-        } else if (strncmp(buf, \"CPU revision\", sizeof \"CPU revision\" - 1) == 0) {\n-          _revision = v;\n-        } else if (strncmp(buf, \"flags\", sizeof(\"flags\") - 1) == 0) {\n-          if (strstr(p+1, \"dcpop\")) {\n-            _dcpop = true;\n-          }\n-        }\n-      }\n-    }\n-    fclose(f);\n-  }\n@@ -223,1 +102,1 @@\n-    if (_dcpop) {\n+    if (_features & CPU_DCPOP) {\n@@ -304,1 +183,1 @@\n-  \/\/ If an olde style \/proc\/cpuinfo (cpu_lines == 1) then if _model is an A57 (0xd07)\n+  \/\/ If an olde style \/proc\/cpuinfo (cores == 1) then if _model is an A57 (0xd07)\n@@ -307,1 +186,1 @@\n-  if (_cpu == CPU_ARM && cpu_lines == 1 && _model == 0xd07) _features |= CPU_A53MAC;\n+  if (_cpu == CPU_ARM && os::processor_count() == 1 && _model == 0xd07) _features |= CPU_A53MAC;\n@@ -309,0 +188,1 @@\n+  char buf[512];\n@@ -311,9 +191,9 @@\n-  if (auxv & HWCAP_ASIMD) strcat(buf, \", simd\");\n-  if (auxv & HWCAP_CRC32) strcat(buf, \", crc\");\n-  if (auxv & HWCAP_AES)   strcat(buf, \", aes\");\n-  if (auxv & HWCAP_SHA1)  strcat(buf, \", sha1\");\n-  if (auxv & HWCAP_SHA2)  strcat(buf, \", sha256\");\n-  if (auxv & HWCAP_SHA512) strcat(buf, \", sha512\");\n-  if (auxv & HWCAP_ATOMICS) strcat(buf, \", lse\");\n-  if (auxv & HWCAP_SVE) strcat(buf, \", sve\");\n-  if (auxv2 & HWCAP2_SVE2) strcat(buf, \", sve2\");\n+  if (_features & CPU_ASIMD) strcat(buf, \", simd\");\n+  if (_features & CPU_CRC32) strcat(buf, \", crc\");\n+  if (_features & CPU_AES)   strcat(buf, \", aes\");\n+  if (_features & CPU_SHA1)  strcat(buf, \", sha1\");\n+  if (_features & CPU_SHA2)  strcat(buf, \", sha256\");\n+  if (_features & CPU_SHA512) strcat(buf, \", sha512\");\n+  if (_features & CPU_LSE) strcat(buf, \", lse\");\n+  if (_features & CPU_SVE) strcat(buf, \", sve\");\n+  if (_features & CPU_SVE2) strcat(buf, \", sve2\");\n@@ -324,1 +204,1 @@\n-    UseCRC32 = (auxv & HWCAP_CRC32) != 0;\n+    UseCRC32 = (_features & CPU_CRC32) != 0;\n@@ -327,1 +207,1 @@\n-  if (UseCRC32 && (auxv & HWCAP_CRC32) == 0) {\n+  if (UseCRC32 && (_features & CPU_CRC32) == 0) {\n@@ -341,1 +221,1 @@\n-  if (auxv & HWCAP_ATOMICS) {\n+  if (_features & CPU_LSE) {\n@@ -351,1 +231,1 @@\n-  if (auxv & HWCAP_AES) {\n+  if (_features & CPU_AES) {\n@@ -379,1 +259,1 @@\n-  if (auxv & HWCAP_CRC32) {\n+  if (_features & CPU_CRC32) {\n@@ -397,1 +277,1 @@\n-  if (auxv & (HWCAP_SHA1 | HWCAP_SHA2)) {\n+  if (_features & (CPU_SHA1 | CPU_SHA2)) {\n@@ -406,1 +286,1 @@\n-  if (UseSHA && (auxv & HWCAP_SHA1)) {\n+  if (UseSHA && (_features & CPU_SHA1)) {\n@@ -415,1 +295,1 @@\n-  if (UseSHA && (auxv & HWCAP_SHA2)) {\n+  if (UseSHA && (_features & CPU_SHA2)) {\n@@ -424,1 +304,1 @@\n-  if (UseSHA && (auxv & HWCAP_SHA512)) {\n+  if (UseSHA && (_features & CPU_SHA512)) {\n@@ -438,1 +318,1 @@\n-  if (auxv & HWCAP_PMULL) {\n+  if (_features & CPU_PMULL) {\n@@ -459,1 +339,1 @@\n-  if (auxv & HWCAP_SVE) {\n+  if (_features & CPU_SVE) {\n@@ -461,1 +341,1 @@\n-      FLAG_SET_DEFAULT(UseSVE, (auxv2 & HWCAP2_SVE2) ? 2 : 1);\n+      FLAG_SET_DEFAULT(UseSVE, (_features & CPU_SVE2) ? 2 : 1);\n@@ -464,1 +344,1 @@\n-      _initial_sve_vector_length = prctl(PR_SVE_GET_VL);\n+      _initial_sve_vector_length = get_current_sve_vector_length();\n@@ -512,1 +392,1 @@\n-      int new_vl = prctl(PR_SVE_SET_VL, MaxVectorSize);\n+      int new_vl = set_and_get_current_sve_vector_lenght(MaxVectorSize);\n@@ -514,3 +394,1 @@\n-      \/\/ If MaxVectorSize is larger than system largest supported SVE vector length, above prctl()\n-      \/\/ call will set task vector length to the system largest supported value. So, we also update\n-      \/\/ MaxVectorSize to that largest supported value.\n+      \/\/ Update MaxVectorSize to the largest supported value.\n@@ -557,16 +435,0 @@\n-}\n-\n-void VM_Version::initialize() {\n-  ResourceMark rm;\n-\n-  stub_blob = BufferBlob::create(\"getPsrInfo_stub\", stub_size);\n-  if (stub_blob == NULL) {\n-    vm_exit_during_initialization(\"Unable to allocate getPsrInfo_stub\");\n-  }\n-\n-  CodeBuffer c(stub_blob);\n-  VM_Version_StubGenerator g(&c);\n-  getPsrInfo_stub = CAST_TO_FN_PTR(getPsrInfo_stub_t,\n-                                   g.generate_getPsrInfo());\n-\n-  get_processor_features();\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":34,"deletions":172,"binary":false,"changes":206,"status":"modified"},{"patch":"@@ -43,1 +43,4 @@\n-  static bool _dcpop;\n+\n+  static int _zva_length;\n+  static int _dcache_line_size;\n+  static int _icache_line_size;\n@@ -46,6 +49,8 @@\n-  struct PsrInfo {\n-    uint32_t dczid_el0;\n-    uint32_t ctr_el0;\n-  };\n-  static PsrInfo _psr_info;\n-  static void get_processor_features();\n+  \/\/ Read additional info using OS-specific interfaces\n+  static void get_os_cpu_info();\n+\n+  \/\/ Sets the SVE length and returns a new actual value or negative on error.\n+  \/\/ If the len is larger than the system largest supported SVE vector length,\n+  \/\/ the function sets the largest supported value.\n+  static int set_and_get_current_sve_vector_lenght(int len);\n+  static int get_current_sve_vector_length();\n@@ -101,2 +106,7 @@\n-    CPU_STXR_PREFETCH= (1 << 29),\n-    CPU_A53MAC       = (1 << 30),\n+    CPU_DCPOP        = (1<<16),\n+    CPU_SHA512       = (1<<21),\n+    CPU_SVE          = (1<<22),\n+    \/\/ flags above must follow Linux HWCAP\n+    CPU_SVE2         = (1<<28),\n+    CPU_STXR_PREFETCH= (1<<29),\n+    CPU_A53MAC       = (1<<30),\n@@ -110,10 +120,2 @@\n-  static bool supports_dcpop()                { return _dcpop; }\n-  static int get_initial_sve_vector_length()  { return _initial_sve_vector_length; };\n-  static ByteSize dczid_el0_offset() { return byte_offset_of(PsrInfo, dczid_el0); }\n-  static ByteSize ctr_el0_offset()   { return byte_offset_of(PsrInfo, ctr_el0); }\n-  static bool is_zva_enabled() {\n-    \/\/ Check the DZP bit (bit 4) of dczid_el0 is zero\n-    \/\/ and block size (bit 0~3) is not zero.\n-    return ((_psr_info.dczid_el0 & 0x10) == 0 &&\n-            (_psr_info.dczid_el0 & 0xf) != 0);\n-  }\n+\n+  static bool is_zva_enabled() { return 0 <= _zva_length; }\n@@ -122,7 +124,1 @@\n-    return 4 << (_psr_info.dczid_el0 & 0xf);\n-  }\n-  static int icache_line_size() {\n-    return (1 << (_psr_info.ctr_el0 & 0x0f)) * 4;\n-  }\n-  static int dcache_line_size() {\n-    return (1 << ((_psr_info.ctr_el0 >> 16) & 0x0f)) * 4;\n+    return _zva_length;\n@@ -130,0 +126,5 @@\n+\n+  static int icache_line_size() { return _icache_line_size; }\n+  static int dcache_line_size() { return _dcache_line_size; }\n+  static int get_initial_sve_vector_length()  { return _initial_sve_vector_length; };\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":27,"deletions":26,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -30,0 +30,137 @@\n+#include <asm\/hwcap.h>\n+#include <sys\/auxv.h>\n+#include <sys\/prctl.h>\n+\n+#ifndef HWCAP_AES\n+#define HWCAP_AES   (1<<3)\n+#endif\n+\n+#ifndef HWCAP_PMULL\n+#define HWCAP_PMULL (1<<4)\n+#endif\n+\n+#ifndef HWCAP_SHA1\n+#define HWCAP_SHA1  (1<<5)\n+#endif\n+\n+#ifndef HWCAP_SHA2\n+#define HWCAP_SHA2  (1<<6)\n+#endif\n+\n+#ifndef HWCAP_CRC32\n+#define HWCAP_CRC32 (1<<7)\n+#endif\n+\n+#ifndef HWCAP_ATOMICS\n+#define HWCAP_ATOMICS (1<<8)\n+#endif\n+\n+#ifndef HWCAP_DCPOP\n+#define HWCAP_DCPOP (1<<16)\n+#endif\n+\n+#ifndef HWCAP_SHA512\n+#define HWCAP_SHA512 (1 << 21)\n+#endif\n+\n+#ifndef HWCAP_SVE\n+#define HWCAP_SVE (1 << 22)\n+#endif\n+\n+#ifndef HWCAP2_SVE2\n+#define HWCAP2_SVE2 (1 << 1)\n+#endif\n+\n+#ifndef PR_SVE_GET_VL\n+\/\/ For old toolchains which do not have SVE related macros defined.\n+#define PR_SVE_SET_VL   50\n+#define PR_SVE_GET_VL   51\n+#endif\n+\n+int VM_Version::get_current_sve_vector_length() {\n+  assert(_features & CPU_SVE, \"should not call this\");\n+  return prctl(PR_SVE_GET_VL);\n+}\n+\n+int VM_Version::set_and_get_current_sve_vector_lenght(int length) {\n+  assert(_features & CPU_SVE, \"should not call this\");\n+  int new_length = prctl(PR_SVE_SET_VL, length);\n+  return new_length;\n+}\n+\n+void VM_Version::get_os_cpu_info() {\n+\n+  uint64_t auxv = getauxval(AT_HWCAP);\n+  uint64_t auxv2 = getauxval(AT_HWCAP2);\n+\n+  static_assert(CPU_FP      == HWCAP_FP);\n+  static_assert(CPU_ASIMD   == HWCAP_ASIMD);\n+  static_assert(CPU_EVTSTRM == HWCAP_EVTSTRM);\n+  static_assert(CPU_AES     == HWCAP_AES);\n+  static_assert(CPU_PMULL   == HWCAP_PMULL);\n+  static_assert(CPU_SHA1    == HWCAP_SHA1);\n+  static_assert(CPU_SHA2    == HWCAP_SHA2);\n+  static_assert(CPU_CRC32   == HWCAP_CRC32);\n+  static_assert(CPU_LSE     == HWCAP_ATOMICS);\n+  static_assert(CPU_DCPOP   == HWCAP_DCPOP);\n+  static_assert(CPU_SHA512  == HWCAP_SHA512);\n+  static_assert(CPU_SVE     == HWCAP_SVE);\n+  _features = auxv & (\n+      HWCAP_FP      |\n+      HWCAP_ASIMD   |\n+      HWCAP_EVTSTRM |\n+      HWCAP_AES     |\n+      HWCAP_PMULL   |\n+      HWCAP_SHA1    |\n+      HWCAP_SHA2    |\n+      HWCAP_CRC32   |\n+      HWCAP_ATOMICS |\n+      HWCAP_DCPOP   |\n+      HWCAP_SHA512  |\n+      HWCAP_SVE);\n+\n+  if (auxv2 & HWCAP2_SVE2) _features |= CPU_SVE2;\n+\n+  uint64_t ctr_el0;\n+  uint64_t dczid_el0;\n+  __asm__ (\n+    \"mrs %0, CTR_EL0\\n\"\n+    \"mrs %1, DCZID_EL0\\n\"\n+    : \"=r\"(ctr_el0), \"=r\"(dczid_el0)\n+  );\n+\n+  _icache_line_size = (1 << (ctr_el0 & 0x0f)) * 4;\n+  _dcache_line_size = (1 << ((ctr_el0 >> 16) & 0x0f)) * 4;\n+\n+  if (!(dczid_el0 & 0x10)) {\n+    _zva_length = 4 << (dczid_el0 & 0xf);\n+  }\n+\n+  int cpu_lines = 0;\n+  if (FILE *f = fopen(\"\/proc\/cpuinfo\", \"r\")) {\n+    \/\/ need a large buffer as the flags line may include lots of text\n+    char buf[1024], *p;\n+    while (fgets(buf, sizeof (buf), f) != NULL) {\n+      if ((p = strchr(buf, ':')) != NULL) {\n+        long v = strtol(p+1, NULL, 0);\n+        if (strncmp(buf, \"CPU implementer\", sizeof \"CPU implementer\" - 1) == 0) {\n+          _cpu = v;\n+          cpu_lines++;\n+        } else if (strncmp(buf, \"CPU variant\", sizeof \"CPU variant\" - 1) == 0) {\n+          _variant = v;\n+        } else if (strncmp(buf, \"CPU part\", sizeof \"CPU part\" - 1) == 0) {\n+          if (_model != v)  _model2 = _model;\n+          _model = v;\n+        } else if (strncmp(buf, \"CPU revision\", sizeof \"CPU revision\" - 1) == 0) {\n+          _revision = v;\n+        } else if (strncmp(buf, \"flags\", sizeof(\"flags\") - 1) == 0) {\n+          if (strstr(p+1, \"dcpop\")) {\n+            guarantee(_features & CPU_DCPOP, \"dcpop availability should be consistent\");\n+          }\n+        }\n+      }\n+    }\n+    fclose(f);\n+  }\n+  guarantee(cpu_lines == os::processor_count(), \"core count should be consistent\");\n+}\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/vm_version_linux_aarch64.cpp","additions":137,"deletions":0,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -726,1 +726,1 @@\n-  static_field(VM_Version, _psr_info.dczid_el0, uint32_t)               \\\n+  static_field(VM_Version, _zva_length, int)                            \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -554,8 +554,16 @@\n-        int dczidValue = config.psrInfoDczidValue;\n-        EnumSet<AArch64.Flag> flags = ((AArch64) target().arch).getFlags();\n-\n-        \/\/ ARMv8-A architecture reference manual D12.2.35 Data Cache Zero ID register says:\n-        \/\/ * BS, bits [3:0] indicate log2 of the DC ZVA block size in (4-byte) words.\n-        \/\/ * DZP, bit [4] of indicates whether use of DC ZVA instruction is prohibited.\n-        int zvaLength = 4 << (dczidValue & 0xF);\n-        boolean isDcZvaProhibited = ((dczidValue & 0x10) != 0);\n+        final EnumSet<AArch64.Flag> flags = ((AArch64) target().arch).getFlags();\n+\n+        boolean isDcZvaProhibited = true;\n+        int zvaLength = 0;\n+        if (GraalHotSpotVMConfig.JDK >= 16) {\n+            zvaLength = config.zvaLength;\n+            isDcZvaProhibited = 0 == config.zvaLength;\n+        } else {\n+            int dczidValue = config.psrInfoDczidValue;\n+\n+            \/\/ ARMv8-A architecture reference manual D12.2.35 Data Cache Zero ID register says:\n+            \/\/ * BS, bits [3:0] indicate log2 of the DC ZVA block size in (4-byte) words.\n+            \/\/ * DZP, bit [4] of indicates whether use of DC ZVA instruction is prohibited.\n+            zvaLength = 4 << (dczidValue & 0xF);\n+            isDcZvaProhibited = ((dczidValue & 0x10) != 0);\n+        }\n","filename":"src\/jdk.internal.vm.compiler\/share\/classes\/org.graalvm.compiler.hotspot.aarch64\/src\/org\/graalvm\/compiler\/hotspot\/aarch64\/AArch64HotSpotLIRGenerator.java","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -722,1 +722,3 @@\n-    public final int psrInfoDczidValue = getFieldValue(\"VM_Version::_psr_info.dczid_el0\", Integer.class, \"uint32_t\", 0x10, (JVMCI ? jvmciGE(JVMCI_19_3_b04) : JDK >= 14) && osArch.equals(\"aarch64\"));\n+    public final int psrInfoDczidValue = getFieldValue(\"VM_Version::_psr_info.dczid_el0\", Integer.class, \"uint32_t\", 0x10, (JVMCI ? jvmciGE(JVMCI_19_3_b04) : (JDK == 14 || JDK == 15)) && osArch.equals(\"aarch64\"));\n+\n+    public final int zvaLength = getFieldValue(\"VM_Version::_zva_length\", Integer.class, \"int\", 0, JDK >= 16 && osArch.equals(\"aarch64\"));\n","filename":"src\/jdk.internal.vm.compiler\/share\/classes\/org.graalvm.compiler.hotspot\/src\/org\/graalvm\/compiler\/hotspot\/GraalHotSpotVMConfig.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}