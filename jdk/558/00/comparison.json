{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -314,0 +314,11 @@\n+    \/** Prints the key-value pairs represented by this\n+        header. Also prints the RFC required blank line\n+        at the end. Omits pairs with a null key. Omits\n+        colon if key-value pair is the requestline. *\/\n+    public void print(PrintStream p) {\n+        \/\/ no synchronization: use cloned arrays instead.\n+        String[] k; String[] v; int n;\n+        synchronized (this) { n = nkeys; k = keys.clone(); v = values.clone(); }\n+        print(n, k, v, p);\n+    }\n+\n@@ -319,1 +330,1 @@\n-    public synchronized void print(PrintStream p) {\n+    private  void print(int nkeys, String[] keys, String[] values, PrintStream p) {\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/MessageHeader.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import java.net.URL;\n-import java.util.*;\n@@ -31,0 +29,1 @@\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -47,0 +46,1 @@\n+    private final ReentrantLock readLock = new ReentrantLock();\n@@ -60,1 +60,3 @@\n-    private final void justRead(long n) throws IOException   {\n+    private final void justRead(long n) throws IOException {\n+        assert isLockHeldByCurrentThread();\n+\n@@ -102,0 +104,1 @@\n+        assert isLockHeldByCurrentThread();\n@@ -116,9 +119,14 @@\n-    public synchronized int read() throws java.io.IOException {\n-        if (closed) {\n-            return -1;\n-        }\n-        int c = in.read();\n-        if (c != -1) {\n-            justRead(1);\n-        } else {\n-            justRead(c);\n+    public int read() throws java.io.IOException {\n+        if (closed) return -1;\n+        lock();\n+        try {\n+            if (closed) return -1;\n+            int c = in.read();\n+            if (c != -1) {\n+                justRead(1);\n+            } else {\n+                justRead(c);\n+            }\n+            return c;\n+        } finally {\n+            unlock();\n@@ -126,1 +134,0 @@\n-        return c;\n@@ -129,1 +136,1 @@\n-    public synchronized int read(byte b[], int off, int len)\n+    public int read(byte b[], int off, int len)\n@@ -131,2 +138,10 @@\n-        if (closed) {\n-            return -1;\n+        if (closed) return -1;\n+        lock();\n+        try {\n+            if (closed) return -1;\n+\n+            int n = in.read(b, off, len);\n+            justRead(n);\n+            return n;\n+        } finally {\n+            unlock();\n@@ -134,3 +149,0 @@\n-        int n = in.read(b, off, len);\n-        justRead(n);\n-        return n;\n@@ -139,1 +151,1 @@\n-    public synchronized long skip(long n) throws IOException {\n+    public long skip(long n) throws IOException {\n@@ -141,12 +153,17 @@\n-        \/\/ REMIND: what does skip do on EOF????\n-        if (closed) {\n-            return 0;\n-        }\n-\n-        if (in instanceof ChunkedInputStream) {\n-            n = in.skip(n);\n-        }\n-        else {\n-            \/\/ just skip min(n, num_bytes_left)\n-            long min = (n > expected - count) ? expected - count: n;\n-            n = in.skip(min);\n+        if (closed) return 0;\n+        lock();\n+        try {\n+            \/\/ REMIND: what does skip do on EOF????\n+            if (closed) return 0;\n+\n+            if (in instanceof ChunkedInputStream) {\n+                n = in.skip(n);\n+            } else {\n+                \/\/ just skip min(n, num_bytes_left)\n+                long min = (n > expected - count) ? expected - count : n;\n+                n = in.skip(min);\n+            }\n+            justRead(n);\n+            return n;\n+        } finally {\n+            unlock();\n@@ -154,2 +171,0 @@\n-        justRead(n);\n-        return n;\n@@ -159,5 +174,6 @@\n-        if (closed) {\n-            return;\n-        }\n-        if (pi != null)\n-            pi.finishTracking();\n+        if (closed) return;\n+        lock();\n+        try {\n+            if (closed) return;\n+            if (pi != null)\n+                pi.finishTracking();\n@@ -165,2 +181,5 @@\n-        closed = true;\n-        in.close();\n+            closed = true;\n+            in.close();\n+        } finally {\n+            unlock();\n+        }\n@@ -169,2 +188,8 @@\n-    public synchronized int available() throws IOException {\n-        return closed ? 0: in.available();\n+    public int available() throws IOException {\n+        if (closed) return 0;\n+        lock();\n+        try {\n+            return closed ? 0 : in.available();\n+        } finally {\n+            unlock();\n+        }\n@@ -173,5 +198,6 @@\n-    public synchronized void mark(int readLimit) {\n-        if (closed) {\n-            return;\n-        }\n-        super.mark(readLimit);\n+    public void mark(int readLimit) {\n+        if (closed) return;\n+        lock();\n+        try {\n+            if (closed) return;\n+            super.mark(readLimit);\n@@ -179,5 +205,8 @@\n-        \/*\n-         * mark the count to restore upon reset\n-         *\/\n-        markedCount = count;\n-        markLimit = readLimit;\n+            \/*\n+             * mark the count to restore upon reset\n+             *\/\n+            markedCount = count;\n+            markLimit = readLimit;\n+        } finally {\n+            unlock();\n+        }\n@@ -186,4 +215,2 @@\n-    public synchronized void reset() throws IOException {\n-        if (closed) {\n-            return;\n-        }\n+    public void reset() throws IOException {\n+        if (closed) return;\n@@ -191,3 +218,6 @@\n-        if (!isMarked()) {\n-            throw new IOException (\"Resetting to an invalid mark\");\n-        }\n+        lock();\n+        try {\n+            if (closed) return;\n+            if (!isMarked()) {\n+                throw new IOException(\"Resetting to an invalid mark\");\n+            }\n@@ -195,2 +225,5 @@\n-        count = markedCount;\n-        super.reset();\n+            count = markedCount;\n+            super.reset();\n+        } finally {\n+            unlock();\n+        }\n@@ -200,2 +233,7 @@\n-        if (closed) {\n-            return false;\n+        if (closed) return false;\n+        lock();\n+        try {\n+            if (closed) return false;\n+            return super.markSupported();\n+        } finally {\n+            unlock();\n@@ -203,1 +241,12 @@\n-        return super.markSupported();\n+    }\n+\n+    public final void lock() {\n+        readLock.lock();\n+    }\n+\n+    public final void unlock() {\n+        readLock.unlock();\n+    }\n+\n+    public final boolean isLockHeldByCurrentThread() {\n+        return readLock.isHeldByCurrentThread();\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/MeteredStream.java","additions":115,"deletions":66,"binary":false,"changes":181,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,1 @@\n-import java.util.*;\n-\n-import sun.net.*;\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -44,2 +42,1 @@\n-public\n-class ChunkedInputStream extends InputStream implements Hurryable {\n+public class ChunkedInputStream extends InputStream implements Hurryable {\n@@ -129,0 +126,2 @@\n+    private final ReentrantLock readLock = new ReentrantLock();\n+\n@@ -651,5 +650,8 @@\n-    public synchronized int read() throws IOException {\n-        ensureOpen();\n-        if (chunkPos >= chunkCount) {\n-            if (readAhead(true) <= 0) {\n-                return -1;\n+    public int read() throws IOException {\n+        readLock.lock();\n+        try {\n+            ensureOpen();\n+            if (chunkPos >= chunkCount) {\n+                if (readAhead(true) <= 0) {\n+                    return -1;\n+                }\n@@ -657,0 +659,3 @@\n+            return chunkData[chunkPos++] & 0xff;\n+        } finally {\n+            readLock.unlock();\n@@ -658,1 +663,0 @@\n-        return chunkData[chunkPos++] & 0xff;\n@@ -673,1 +677,1 @@\n-    public synchronized int read(byte b[], int off, int len)\n+    public int read(byte b[], int off, int len)\n@@ -676,17 +680,8 @@\n-        ensureOpen();\n-        if ((off < 0) || (off > b.length) || (len < 0) ||\n-            ((off + len) > b.length) || ((off + len) < 0)) {\n-            throw new IndexOutOfBoundsException();\n-        } else if (len == 0) {\n-            return 0;\n-        }\n-\n-        int avail = chunkCount - chunkPos;\n-        if (avail <= 0) {\n-            \/*\n-             * Optimization: if we're in the middle of the chunk read\n-             * directly from the underlying stream into the caller's\n-             * buffer\n-             *\/\n-            if (state == STATE_READING_CHUNK) {\n-                return fastRead( b, off, len );\n+        readLock.lock();\n+        try {\n+            ensureOpen();\n+            if ((off < 0) || (off > b.length) || (len < 0) ||\n+                    ((off + len) > b.length) || ((off + len) < 0)) {\n+                throw new IndexOutOfBoundsException();\n+            } else if (len == 0) {\n+                return 0;\n@@ -695,7 +690,19 @@\n-            \/*\n-             * We're not in the middle of a chunk so we must read ahead\n-             * until there is some chunk data available.\n-             *\/\n-            avail = readAhead(true);\n-            if (avail < 0) {\n-                return -1;      \/* EOF *\/\n+            int avail = chunkCount - chunkPos;\n+            if (avail <= 0) {\n+                \/*\n+                 * Optimization: if we're in the middle of the chunk read\n+                 * directly from the underlying stream into the caller's\n+                 * buffer\n+                 *\/\n+                if (state == STATE_READING_CHUNK) {\n+                    return fastRead(b, off, len);\n+                }\n+\n+                \/*\n+                 * We're not in the middle of a chunk so we must read ahead\n+                 * until there is some chunk data available.\n+                 *\/\n+                avail = readAhead(true);\n+                if (avail < 0) {\n+                    return -1;      \/* EOF *\/\n+                }\n@@ -703,4 +710,3 @@\n-        }\n-        int cnt = (avail < len) ? avail : len;\n-        System.arraycopy(chunkData, chunkPos, b, off, cnt);\n-        chunkPos += cnt;\n+            int cnt = (avail < len) ? avail : len;\n+            System.arraycopy(chunkData, chunkPos, b, off, cnt);\n+            chunkPos += cnt;\n@@ -708,1 +714,4 @@\n-        return cnt;\n+            return cnt;\n+        } finally {\n+            readLock.unlock();\n+        }\n@@ -720,2 +729,4 @@\n-    public synchronized int available() throws IOException {\n-        ensureOpen();\n+    public int available() throws IOException {\n+        readLock.lock();\n+        try {\n+            ensureOpen();\n@@ -723,4 +734,4 @@\n-        int avail = chunkCount - chunkPos;\n-        if(avail > 0) {\n-            return avail;\n-        }\n+            int avail = chunkCount - chunkPos;\n+            if (avail > 0) {\n+                return avail;\n+            }\n@@ -728,1 +739,1 @@\n-        avail = readAhead(false);\n+            avail = readAhead(false);\n@@ -730,4 +741,7 @@\n-        if (avail < 0) {\n-            return 0;\n-        } else  {\n-            return avail;\n+            if (avail < 0) {\n+                return 0;\n+            } else {\n+                return avail;\n+            }\n+        } finally {\n+            readLock.unlock();\n@@ -748,3 +762,11 @@\n-    public synchronized void close() throws IOException {\n-        if (closed) {\n-            return;\n+    public void close() throws IOException {\n+        if (closed) return;\n+        readLock.lock();\n+        try {\n+            if (closed) {\n+                return;\n+            }\n+            closeUnderlying();\n+            closed = true;\n+        } finally {\n+            readLock.unlock();\n@@ -752,2 +774,0 @@\n-        closeUnderlying();\n-        closed = true;\n@@ -765,5 +785,2 @@\n-    public synchronized boolean hurry() {\n-        if (in == null || error) {\n-            return false;\n-        }\n-\n+    public boolean hurry() {\n+        readLock.lock();\n@@ -771,4 +788,3 @@\n-            readAhead(false);\n-        } catch (Exception e) {\n-            return false;\n-        }\n+            if (in == null || error) {\n+                return false;\n+            }\n@@ -776,3 +792,5 @@\n-        if (error) {\n-            return false;\n-        }\n+            try {\n+                readAhead(false);\n+            } catch (Exception e) {\n+                return false;\n+            }\n@@ -780,1 +798,8 @@\n-        return (state == STATE_DONE);\n+            if (error) {\n+                return false;\n+            }\n+\n+            return (state == STATE_DONE);\n+        } finally {\n+            readLock.unlock();\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/http\/ChunkedInputStream.java","additions":96,"deletions":71,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -35,1 +37,1 @@\n-public class ChunkedOutputStream extends PrintStream {\n+public class ChunkedOutputStream extends OutputStream {\n@@ -66,0 +68,2 @@\n+    private final Lock writeLock = new ReentrantLock();\n+\n@@ -88,1 +92,0 @@\n-        super(o);\n@@ -147,1 +150,1 @@\n-            if (size > 0){\n+            if (size > 0) {\n@@ -171,1 +174,1 @@\n-         }\n+        }\n@@ -174,1 +177,0 @@\n-    @Override\n@@ -176,1 +178,2 @@\n-        return out.checkError();\n+        var out = this.out;\n+        return out == null || out.checkError();\n@@ -180,1 +183,1 @@\n-    private void ensureOpen() {\n+    private void ensureOpen() throws IOException {\n@@ -182,1 +185,1 @@\n-            setError();\n+            throw new IOException(\"closed\");\n@@ -197,36 +200,10 @@\n-    public synchronized void write(byte b[], int off, int len) {\n-        ensureOpen();\n-        if ((off < 0) || (off > b.length) || (len < 0) ||\n-            ((off + len) > b.length) || ((off + len) < 0)) {\n-            throw new IndexOutOfBoundsException();\n-        } else if (len == 0) {\n-            return;\n-        }\n-\n-        \/* if b[] contains enough data then one loop cycle creates one complete\n-         * data chunk with a header, body and a footer, and then flushes the\n-         * chunk to the underlying stream. Otherwise, the last loop cycle\n-         * creates incomplete data chunk with empty header and with no footer\n-         * and stores this incomplete chunk in an internal buffer buf[]\n-         *\/\n-        int bytesToWrite = len;\n-        int inputIndex = off;  \/* the index of the byte[] currently being written *\/\n-\n-        do {\n-            \/* enough data to complete a chunk *\/\n-            if (bytesToWrite >= spaceInCurrentChunk) {\n-\n-                \/* header *\/\n-                for (int i=0; i<completeHeader.length; i++)\n-                    buf[i] = completeHeader[i];\n-\n-                \/* data *\/\n-                System.arraycopy(b, inputIndex, buf, count, spaceInCurrentChunk);\n-                inputIndex += spaceInCurrentChunk;\n-                bytesToWrite -= spaceInCurrentChunk;\n-                count += spaceInCurrentChunk;\n-\n-                \/* footer *\/\n-                buf[count++] = FOOTER[0];\n-                buf[count++] = FOOTER[1];\n-                spaceInCurrentChunk = 0; \/\/chunk is complete\n+    public void write(byte b[], int off, int len) throws IOException {\n+        writeLock.lock();\n+        try {\n+            ensureOpen();\n+            if ((off < 0) || (off > b.length) || (len < 0) ||\n+                    ((off + len) > b.length) || ((off + len) < 0)) {\n+                throw new IndexOutOfBoundsException();\n+            } else if (len == 0) {\n+                return;\n+            }\n@@ -234,3 +211,32 @@\n-                flush(false);\n-                if (checkError()){\n-                    break;\n+            \/* if b[] contains enough data then one loop cycle creates one complete\n+             * data chunk with a header, body and a footer, and then flushes the\n+             * chunk to the underlying stream. Otherwise, the last loop cycle\n+             * creates incomplete data chunk with empty header and with no footer\n+             * and stores this incomplete chunk in an internal buffer buf[]\n+             *\/\n+            int bytesToWrite = len;\n+            int inputIndex = off;  \/* the index of the byte[] currently being written *\/\n+\n+            do {\n+                \/* enough data to complete a chunk *\/\n+                if (bytesToWrite >= spaceInCurrentChunk) {\n+\n+                    \/* header *\/\n+                    for (int i = 0; i < completeHeader.length; i++)\n+                        buf[i] = completeHeader[i];\n+\n+                    \/* data *\/\n+                    System.arraycopy(b, inputIndex, buf, count, spaceInCurrentChunk);\n+                    inputIndex += spaceInCurrentChunk;\n+                    bytesToWrite -= spaceInCurrentChunk;\n+                    count += spaceInCurrentChunk;\n+\n+                    \/* footer *\/\n+                    buf[count++] = FOOTER[0];\n+                    buf[count++] = FOOTER[1];\n+                    spaceInCurrentChunk = 0; \/\/chunk is complete\n+\n+                    flush(false);\n+                    if (checkError()) {\n+                        break;\n+                    }\n@@ -238,1 +244,0 @@\n-            }\n@@ -240,4 +245,4 @@\n-            \/* not enough data to build a chunk *\/\n-            else {\n-                \/* header *\/\n-                \/* do not write header if not enough bytes to build a chunk yet *\/\n+                \/* not enough data to build a chunk *\/\n+                else {\n+                    \/* header *\/\n+                    \/* do not write header if not enough bytes to build a chunk yet *\/\n@@ -245,6 +250,6 @@\n-                \/* data *\/\n-                System.arraycopy(b, inputIndex, buf, count, bytesToWrite);\n-                count += bytesToWrite;\n-                size += bytesToWrite;\n-                spaceInCurrentChunk -= bytesToWrite;\n-                bytesToWrite = 0;\n+                    \/* data *\/\n+                    System.arraycopy(b, inputIndex, buf, count, bytesToWrite);\n+                    count += bytesToWrite;\n+                    size += bytesToWrite;\n+                    spaceInCurrentChunk -= bytesToWrite;\n+                    bytesToWrite = 0;\n@@ -252,4 +257,7 @@\n-                \/* footer *\/\n-                \/* do not write header if not enough bytes to build a chunk yet *\/\n-            }\n-        } while (bytesToWrite > 0);\n+                    \/* footer *\/\n+                    \/* do not write header if not enough bytes to build a chunk yet *\/\n+                }\n+            } while (bytesToWrite > 0);\n+        } finally {\n+            writeLock.unlock();\n+        }\n@@ -259,3 +267,8 @@\n-    public synchronized void write(int _b) {\n-        byte b[] = {(byte)_b};\n-        write(b, 0, 1);\n+    public void write(int _b) throws IOException {\n+        writeLock.lock();\n+        try {\n+            byte b[] = {(byte) _b};\n+            write(b, 0, 1);\n+        } finally {\n+            writeLock.unlock();\n+        }\n@@ -264,4 +277,9 @@\n-    public synchronized void reset() {\n-        count = preferedHeaderSize;\n-        size = 0;\n-        spaceInCurrentChunk = preferredChunkDataSize;\n+    public void reset() {\n+        writeLock.lock();\n+        try {\n+            count = preferedHeaderSize;\n+            size = 0;\n+            spaceInCurrentChunk = preferredChunkDataSize;\n+        } finally {\n+            writeLock.unlock();\n+        }\n@@ -275,2 +293,9 @@\n-    public synchronized void close() {\n-        ensureOpen();\n+    public void close() {\n+        writeLock.lock();\n+        try {\n+           if (out == null) return;\n+\n+            \/* if we have buffer a chunked send it *\/\n+            if (size > 0) {\n+                flush(true);\n+            }\n@@ -278,2 +303,1 @@\n-        \/* if we have buffer a chunked send it *\/\n-        if (size > 0) {\n+            \/* send a zero length chunk *\/\n@@ -281,4 +305,0 @@\n-        }\n-\n-        \/* send a zero length chunk *\/\n-        flush(true);\n@@ -286,2 +306,5 @@\n-        \/* don't close the underlying stream *\/\n-        out = null;\n+            \/* don't close the underlying stream *\/\n+            out = null;\n+        } finally {\n+            writeLock.unlock();\n+        }\n@@ -291,4 +314,9 @@\n-    public synchronized void flush() {\n-        ensureOpen();\n-        if (size > 0) {\n-            flush(true);\n+    public void flush() throws IOException {\n+        writeLock.lock();\n+        try {\n+            ensureOpen();\n+            if (size > 0) {\n+                flush(true);\n+            }\n+        } finally {\n+            writeLock.unlock();\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/http\/ChunkedOutputStream.java","additions":112,"deletions":84,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+\/\/ Using synchronized should be safe here.\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/http\/HttpCapture.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import java.util.concurrent.locks.ReentrantLock;\n+\n@@ -50,0 +52,2 @@\n+    private final ReentrantLock clientLock = new ReentrantLock();\n+\n@@ -319,1 +323,2 @@\n-                    synchronized (ret) {\n+                    ret.lock();\n+                    try {\n@@ -326,0 +331,2 @@\n+                    } finally {\n+                        ret.unlock();\n@@ -332,1 +339,2 @@\n-                    synchronized(ret) {\n+                    ret.lock();\n+                    try  {\n@@ -335,0 +343,2 @@\n+                    } finally {\n+                        ret.unlock();\n@@ -412,1 +422,1 @@\n-    protected synchronized boolean available() {\n+    protected boolean available() {\n@@ -416,0 +426,1 @@\n+        lock();\n@@ -439,0 +450,2 @@\n+        } finally {\n+            unlock();\n@@ -443,4 +456,11 @@\n-    protected synchronized void putInKeepAliveCache() {\n-        if (inCache) {\n-            assert false : \"Duplicate put to keep alive cache\";\n-            return;\n+    protected void putInKeepAliveCache() {\n+        lock();\n+        try {\n+            if (inCache) {\n+                assert false : \"Duplicate put to keep alive cache\";\n+                return;\n+            }\n+            inCache = true;\n+            kac.put(url, null, this);\n+        } finally {\n+            unlock();\n@@ -448,2 +468,0 @@\n-        inCache = true;\n-        kac.put(url, null, this);\n@@ -452,2 +470,7 @@\n-    protected synchronized boolean isInKeepAliveCache() {\n-        return inCache;\n+    protected boolean isInKeepAliveCache() {\n+        lock();\n+        try {\n+            return inCache;\n+        } finally {\n+            unlock();\n+        }\n@@ -500,2 +523,7 @@\n-    public synchronized boolean isCachedConnection() {\n-        return cachedHttpClient;\n+    public boolean isCachedConnection() {\n+        lock();\n+        try {\n+            return cachedHttpClient;\n+        } finally {\n+            unlock();\n+        }\n@@ -519,1 +547,1 @@\n-    private synchronized void privilegedOpenServer(final InetSocketAddress server)\n+    private void privilegedOpenServer(final InetSocketAddress server)\n@@ -522,0 +550,1 @@\n+        assert clientLock.isHeldByCurrentThread();\n@@ -547,1 +576,1 @@\n-    protected synchronized void openServer() throws IOException {\n+    protected void openServer() throws IOException {\n@@ -551,10 +580,5 @@\n-        if (security != null) {\n-            security.checkConnect(host, port);\n-        }\n-\n-        if (keepingAlive) { \/\/ already opened\n-            return;\n-        }\n-\n-        if (url.getProtocol().equals(\"http\") ||\n-            url.getProtocol().equals(\"https\") ) {\n+        lock();\n+        try {\n+            if (security != null) {\n+                security.checkConnect(host, port);\n+            }\n@@ -562,9 +586,1 @@\n-            if ((proxy != null) && (proxy.type() == Proxy.Type.HTTP)) {\n-                sun.net.www.URLConnection.setProxiedHost(host);\n-                privilegedOpenServer((InetSocketAddress) proxy.address());\n-                usingProxy = true;\n-                return;\n-            } else {\n-                \/\/ make direct connection\n-                openServer(host, port);\n-                usingProxy = false;\n+            if (keepingAlive) { \/\/ already opened\n@@ -574,9 +590,15 @@\n-        } else {\n-            \/* we're opening some other kind of url, most likely an\n-             * ftp url.\n-             *\/\n-            if ((proxy != null) && (proxy.type() == Proxy.Type.HTTP)) {\n-                sun.net.www.URLConnection.setProxiedHost(host);\n-                privilegedOpenServer((InetSocketAddress) proxy.address());\n-                usingProxy = true;\n-                return;\n+            if (url.getProtocol().equals(\"http\") ||\n+                    url.getProtocol().equals(\"https\")) {\n+\n+                if ((proxy != null) && (proxy.type() == Proxy.Type.HTTP)) {\n+                    sun.net.www.URLConnection.setProxiedHost(host);\n+                    privilegedOpenServer((InetSocketAddress) proxy.address());\n+                    usingProxy = true;\n+                    return;\n+                } else {\n+                    \/\/ make direct connection\n+                    openServer(host, port);\n+                    usingProxy = false;\n+                    return;\n+                }\n+\n@@ -584,4 +606,14 @@\n-                \/\/ make direct connection\n-                super.openServer(host, port);\n-                usingProxy = false;\n-                return;\n+                \/* we're opening some other kind of url, most likely an\n+                 * ftp url.\n+                 *\/\n+                if ((proxy != null) && (proxy.type() == Proxy.Type.HTTP)) {\n+                    sun.net.www.URLConnection.setProxiedHost(host);\n+                    privilegedOpenServer((InetSocketAddress) proxy.address());\n+                    usingProxy = true;\n+                    return;\n+                } else {\n+                    \/\/ make direct connection\n+                    super.openServer(host, port);\n+                    usingProxy = false;\n+                    return;\n+                }\n@@ -589,0 +621,2 @@\n+        } finally {\n+            unlock();\n@@ -1013,2 +1047,7 @@\n-    public synchronized InputStream getInputStream() {\n-        return serverInput;\n+    public InputStream getInputStream() {\n+        lock();\n+        try {\n+            return serverInput;\n+        } finally {\n+            unlock();\n+        }\n@@ -1087,0 +1126,8 @@\n+\n+    public final void lock() {\n+        clientLock.lock();\n+    }\n+\n+    public final void unlock() {\n+        clientLock.unlock();\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/http\/HttpClient.java","additions":97,"deletions":50,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,2 @@\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -77,0 +79,2 @@\n+    \/\/ This class is never serialized (see writeObject\/readObject).\n+    private final ReentrantLock cacheLock = new ReentrantLock();\n@@ -89,23 +93,7 @@\n-    public synchronized void put(final URL url, Object obj, HttpClient http) {\n-        boolean startThread = (keepAliveTimer == null);\n-        if (!startThread) {\n-            if (!keepAliveTimer.isAlive()) {\n-                startThread = true;\n-            }\n-        }\n-        if (startThread) {\n-            clear();\n-            \/* Unfortunately, we can't always believe the keep-alive timeout we got\n-             * back from the server.  If I'm connected through a Netscape proxy\n-             * to a server that sent me a keep-alive\n-             * time of 15 sec, the proxy unilaterally terminates my connection\n-             * The robustness to get around this is in HttpClient.parseHTTP()\n-             *\/\n-            final KeepAliveCache cache = this;\n-            AccessController.doPrivileged(new PrivilegedAction<>() {\n-                public Void run() {\n-                    keepAliveTimer = InnocuousThread.newSystemThread(\"Keep-Alive-Timer\", cache);\n-                    keepAliveTimer.setDaemon(true);\n-                    keepAliveTimer.setPriority(Thread.MAX_PRIORITY - 2);\n-                    keepAliveTimer.start();\n-                    return null;\n+    public void put(final URL url, Object obj, HttpClient http) {\n+        cacheLock.lock();\n+        try {\n+            boolean startThread = (keepAliveTimer == null);\n+            if (!startThread) {\n+                if (!keepAliveTimer.isAlive()) {\n+                    startThread = true;\n@@ -113,2 +101,23 @@\n-            });\n-        }\n+            }\n+            if (startThread) {\n+                clear();\n+                \/* Unfortunately, we can't always believe the keep-alive timeout we got\n+                 * back from the server.  If I'm connected through a Netscape proxy\n+                 * to a server that sent me a keep-alive\n+                 * time of 15 sec, the proxy unilaterally terminates my connection\n+                 * The robustness to get around this is in HttpClient.parseHTTP()\n+                 *\/\n+                final KeepAliveCache cache = this;\n+                AccessController.doPrivileged(new PrivilegedAction<>() {\n+                    public Void run() {\n+                        keepAliveTimer = InnocuousThread.newSystemThread(\"Keep-Alive-Timer\", cache);\n+                        keepAliveTimer.setDaemon(true);\n+                        keepAliveTimer.setPriority(Thread.MAX_PRIORITY - 2);\n+                        keepAliveTimer.start();\n+                        return null;\n+                    }\n+                });\n+            }\n+\n+            KeepAliveKey key = new KeepAliveKey(url, obj);\n+            ClientVector v = super.get(key);\n@@ -116,11 +125,11 @@\n-        KeepAliveKey key = new KeepAliveKey(url, obj);\n-        ClientVector v = super.get(key);\n-\n-        if (v == null) {\n-            int keepAliveTimeout = http.getKeepAliveTimeout();\n-            v = new ClientVector(keepAliveTimeout > 0 ?\n-                                 keepAliveTimeout * 1000 : LIFETIME);\n-            v.put(http);\n-            super.put(key, v);\n-        } else {\n-            v.put(http);\n+            if (v == null) {\n+                int keepAliveTimeout = http.getKeepAliveTimeout();\n+                v = new ClientVector(keepAliveTimeout > 0 ?\n+                        keepAliveTimeout * 1000 : LIFETIME);\n+                v.put(http);\n+                super.put(key, v);\n+            } else {\n+                v.put(http);\n+            }\n+        } finally {\n+            cacheLock.unlock();\n@@ -131,7 +140,10 @@\n-    public synchronized void remove(HttpClient h, Object obj) {\n-        KeepAliveKey key = new KeepAliveKey(h.url, obj);\n-        ClientVector v = super.get(key);\n-        if (v != null) {\n-            v.remove(h);\n-            if (v.isEmpty()) {\n-                removeVector(key);\n+    public void remove(HttpClient h, Object obj) {\n+        cacheLock.lock();\n+        try {\n+            KeepAliveKey key = new KeepAliveKey(h.url, obj);\n+            ClientVector v = super.get(key);\n+            if (v != null) {\n+                v.remove(h);\n+                if (v.isEmpty()) {\n+                    removeVector(key);\n+                }\n@@ -139,0 +151,2 @@\n+        } finally {\n+            cacheLock.unlock();\n@@ -145,1 +159,2 @@\n-    synchronized void removeVector(KeepAliveKey k) {\n+    private void removeVector(KeepAliveKey k) {\n+        assert cacheLock.isHeldByCurrentThread();\n@@ -152,5 +167,11 @@\n-    public synchronized HttpClient get(URL url, Object obj) {\n-        KeepAliveKey key = new KeepAliveKey(url, obj);\n-        ClientVector v = super.get(key);\n-        if (v == null) { \/\/ nothing in cache yet\n-            return null;\n+    public HttpClient get(URL url, Object obj) {\n+        cacheLock.lock();\n+        try {\n+            KeepAliveKey key = new KeepAliveKey(url, obj);\n+            ClientVector v = super.get(key);\n+            if (v == null) { \/\/ nothing in cache yet\n+                return null;\n+            }\n+            return v.get();\n+        } finally {\n+            cacheLock.unlock();\n@@ -158,1 +179,0 @@\n-        return v.get();\n@@ -173,1 +193,2 @@\n-            synchronized (this) {\n+            cacheLock.lock();\n+            try {\n@@ -179,1 +200,2 @@\n-                    synchronized (v) {\n+                    v.lock();\n+                    try {\n@@ -194,0 +216,2 @@\n+                    } finally {\n+                        v.unlock();\n@@ -200,0 +224,2 @@\n+            } finally {\n+                cacheLock.unlock();\n@@ -226,0 +252,1 @@\n+    private final ReentrantLock lock = new ReentrantLock();\n@@ -234,14 +261,5 @@\n-    synchronized HttpClient get() {\n-        if (isEmpty()) {\n-            return null;\n-        }\n-\n-        \/\/ Loop until we find a connection that has not timed out\n-        HttpClient hc = null;\n-        long currentTime = System.currentTimeMillis();\n-        do {\n-            KeepAliveEntry e = pop();\n-            if ((currentTime - e.idleStartTime) > nap) {\n-                e.hc.closeServer();\n-            } else {\n-                hc = e.hc;\n+    HttpClient get() {\n+        lock();\n+        try {\n+            if (isEmpty()) {\n+                return null;\n@@ -249,2 +267,16 @@\n-        } while ((hc == null) && (!isEmpty()));\n-        return hc;\n+\n+            \/\/ Loop until we find a connection that has not timed out\n+            HttpClient hc = null;\n+            long currentTime = System.currentTimeMillis();\n+            do {\n+                KeepAliveEntry e = pop();\n+                if ((currentTime - e.idleStartTime) > nap) {\n+                    e.hc.closeServer();\n+                } else {\n+                    hc = e.hc;\n+                }\n+            } while ((hc == null) && (!isEmpty()));\n+            return hc;\n+        } finally {\n+            unlock();\n+        }\n@@ -254,5 +286,10 @@\n-    synchronized void put(HttpClient h) {\n-        if (size() >= KeepAliveCache.getMaxConnections()) {\n-            h.closeServer(); \/\/ otherwise the connection remains in limbo\n-        } else {\n-            push(new KeepAliveEntry(h, System.currentTimeMillis()));\n+    void put(HttpClient h) {\n+        lock();\n+        try {\n+            if (size() >= KeepAliveCache.getMaxConnections()) {\n+                h.closeServer(); \/\/ otherwise the connection remains in limbo\n+            } else {\n+                push(new KeepAliveEntry(h, System.currentTimeMillis()));\n+            }\n+        } finally {\n+            unlock();\n@@ -263,4 +300,7 @@\n-    synchronized boolean remove(HttpClient h) {\n-        for (KeepAliveEntry curr : this) {\n-            if (curr.hc == h) {\n-                return super.remove(curr);\n+    boolean remove(HttpClient h) {\n+        lock();\n+        try {\n+            for (KeepAliveEntry curr : this) {\n+                if (curr.hc == h) {\n+                    return super.remove(curr);\n+                }\n@@ -268,0 +308,3 @@\n+            return false;\n+        } finally {\n+            unlock();\n@@ -269,1 +312,8 @@\n-        return false;\n+    }\n+\n+    final void lock() {\n+        lock.lock();\n+    }\n+\n+    final void unlock() {\n+        lock.unlock();\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/http\/KeepAliveCache.java","additions":129,"deletions":79,"binary":false,"changes":208,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,2 @@\n-    protected boolean queuedForCleanup = false;\n+    \/\/ This flag is read from within KeepAliveCleanerEntry outside of any lock.\n+    protected volatile boolean queuedForCleanup = false;\n@@ -67,9 +68,3 @@\n-        \/\/ If the inputstream is closed already, just return.\n-        if (closed) {\n-            return;\n-        }\n-\n-        \/\/ If this stream has already been queued for cleanup.\n-        if (queuedForCleanup) {\n-            return;\n-        }\n+        \/\/ If the inputstream is closed already, or if this stream\n+        \/\/ has already been queued for cleanup.just return.\n+        if (closed || queuedForCleanup) return;\n@@ -84,0 +79,3 @@\n+        \/\/ For consistency, access to `expected` and `count` should be\n+        \/\/ protected by readLock\n+        lock();\n@@ -85,11 +83,29 @@\n-            if (expected > count) {\n-                long nskip = expected - count;\n-                if (nskip <= available()) {\n-                    do {} while ((nskip = (expected - count)) > 0L\n-                                 && skip(Math.min(nskip, available())) > 0L);\n-                } else if (expected <= KeepAliveStreamCleaner.MAX_DATA_REMAINING && !hurried) {\n-                    \/\/put this KeepAliveStream on the queue so that the data remaining\n-                    \/\/on the socket can be cleanup asyncronously.\n-                    queueForCleanup(new KeepAliveCleanerEntry(this, hc));\n-                } else {\n-                    hc.closeServer();\n+            if (closed || queuedForCleanup) return;\n+            try {\n+                if (expected > count) {\n+                    long nskip = expected - count;\n+                    if (nskip <= available()) {\n+                        do {\n+                        } while ((nskip = (expected - count)) > 0L\n+                                && skip(Math.min(nskip, available())) > 0L);\n+                    } else if (expected <= KeepAliveStreamCleaner.MAX_DATA_REMAINING && !hurried) {\n+                        \/\/put this KeepAliveStream on the queue so that the data remaining\n+                        \/\/on the socket can be cleanup asyncronously.\n+                        queueForCleanup(new KeepAliveCleanerEntry(this, hc));\n+                    } else {\n+                        hc.closeServer();\n+                    }\n+                }\n+                if (!closed && !hurried && !queuedForCleanup) {\n+                    hc.finished();\n+                }\n+            } finally {\n+                if (pi != null)\n+                    pi.finishTracking();\n+\n+                if (!queuedForCleanup) {\n+                    \/\/ nulling out the underlying inputstream as well as\n+                    \/\/ httpClient to let gc collect the memories faster\n+                    in = null;\n+                    hc = null;\n+                    closed = true;\n@@ -97,3 +113,0 @@\n-            }\n-            if (!closed && !hurried && !queuedForCleanup) {\n-                hc.finished();\n@@ -102,10 +115,1 @@\n-            if (pi != null)\n-                pi.finishTracking();\n-\n-            if (!queuedForCleanup) {\n-                \/\/ nulling out the underlying inputstream as well as\n-                \/\/ httpClient to let gc collect the memories faster\n-                in = null;\n-                hc = null;\n-                closed = true;\n-            }\n+            unlock();\n@@ -127,1 +131,2 @@\n-    public synchronized boolean hurry() {\n+    public boolean hurry() {\n+        lock();\n@@ -150,0 +155,2 @@\n+        } finally {\n+            unlock();\n@@ -154,1 +161,2 @@\n-        synchronized(queue) {\n+        queue.lock();\n+        try {\n@@ -162,1 +170,1 @@\n-                queue.notifyAll();\n+                queue.signalAll();\n@@ -184,1 +192,3 @@\n-        } \/\/ queue\n+        } finally {\n+            queue.unlock();\n+        }\n@@ -187,0 +197,1 @@\n+    \/\/ Only called from KeepAliveStreamCleaner\n@@ -188,0 +199,1 @@\n+        assert isLockHeldByCurrentThread();\n@@ -191,0 +203,1 @@\n+    \/\/ Only called from KeepAliveStreamCleaner\n@@ -192,0 +205,1 @@\n+        assert isLockHeldByCurrentThread();\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/http\/KeepAliveStream.java","additions":53,"deletions":39,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import java.util.concurrent.locks.Condition;\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -81,0 +83,14 @@\n+    private final ReentrantLock queueLock = new ReentrantLock();\n+    private final Condition waiter = queueLock.newCondition();\n+\n+    final void signalAll() {\n+        waiter.signalAll();\n+    }\n+\n+    final void lock() {\n+        queueLock.lock();\n+    }\n+\n+    final void unlock() {\n+        queueLock.unlock();\n+    }\n@@ -97,1 +113,2 @@\n-                synchronized(this) {\n+                lock();\n+                try {\n@@ -101,1 +118,1 @@\n-                        this.wait(timeout);\n+                        waiter.wait(timeout);\n@@ -113,0 +130,2 @@\n+                } finally {\n+                    unlock();\n@@ -121,1 +140,2 @@\n-                    synchronized(kas) {\n+                    kas.lock();\n+                    try {\n@@ -150,0 +170,2 @@\n+                    } finally {\n+                        kas.unlock();\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/http\/KeepAliveStreamCleaner.java","additions":26,"deletions":4,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-\n+\/\/ Using synchronized in this class should be safe\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/AuthCacheImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+import java.util.concurrent.locks.Condition;\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -128,2 +130,3 @@\n-    private static HashMap<String,Thread> requests = new HashMap<>();\n-\n+    private static final HashMap<String,Thread> requests = new HashMap<>();\n+    private static final ReentrantLock requestLock = new ReentrantLock();\n+    private static final Condition requestFinished = requestLock.newCondition();\n@@ -145,2 +148,3 @@\n-        synchronized (requests) {\n-            \/\/ check again after synchronizing, and if available\n+        requestLock.lock();\n+        try {\n+            \/\/ check again after locking, and if available\n@@ -167,3 +171,1 @@\n-                try {\n-                    requests.wait ();\n-                } catch (InterruptedException e) {}\n+                requestFinished.awaitUninterruptibly();\n@@ -171,0 +173,2 @@\n+        } finally {\n+            requestLock.unlock();\n@@ -180,1 +184,2 @@\n-        synchronized (requests) {\n+        requestLock.lock();\n+        try {\n@@ -186,1 +191,3 @@\n-            requests.notifyAll();\n+            requestFinished.signalAll();\n+        } finally {\n+            requestLock.unlock();\n@@ -417,3 +424,1 @@\n-        synchronized (requests) {\n-            requestCompleted(key);\n-        }\n+        requestCompleted(key);\n@@ -503,0 +508,1 @@\n+    \/\/ should be safe to keep synchronized here\n@@ -515,0 +521,1 @@\n+    \/\/ should be safe to keep synchronized here\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/AuthenticationInfo.java","additions":20,"deletions":13,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+        assert conn.isLockHeldByCurrentThread();\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/BasicAuthentication.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+    \/\/ synchronized should be safe here\n@@ -301,0 +302,2 @@\n+        assert conn.isLockHeldByCurrentThread();\n+\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/DigestAuthentication.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -84,0 +84,2 @@\n+import java.util.concurrent.locks.ReentrantLock;\n+\n@@ -100,1 +102,1 @@\n-    static String HTTP_CONNECT = \"CONNECT\";\n+    static final String HTTP_CONNECT = \"CONNECT\";\n@@ -356,1 +358,1 @@\n-     * Access synchronized on this.\n+     * Access is protected by connectionLock.\n@@ -435,0 +437,16 @@\n+    \/* Lock *\/\n+    private final ReentrantLock connectionLock = new ReentrantLock();\n+\n+    private final void lock() {\n+        connectionLock.lock();\n+    }\n+\n+    private final void unlock() {\n+        connectionLock.unlock();\n+    }\n+\n+    public final boolean isLockHeldByCurrentThread() {\n+        return connectionLock.isHeldByCurrentThread();\n+    }\n+\n+\n@@ -517,4 +535,11 @@\n-    public synchronized void setAuthenticator(Authenticator auth) {\n-        if (connecting || connected) {\n-            throw new IllegalStateException(\n-                  \"Authenticator must be set before connecting\");\n+    public void setAuthenticator(Authenticator auth) {\n+        lock();\n+        try {\n+            if (connecting || connected) {\n+                throw new IllegalStateException(\n+                        \"Authenticator must be set before connecting\");\n+            }\n+            authenticator = Objects.requireNonNull(auth);\n+            authenticatorKey = AuthenticatorKeys.getKey(authenticator);\n+        } finally {\n+            unlock();\n@@ -522,2 +547,0 @@\n-        authenticator = Objects.requireNonNull(auth);\n-        authenticatorKey = AuthenticatorKeys.getKey(authenticator);\n@@ -566,1 +589,1 @@\n-    public synchronized void setRequestMethod(String method)\n+    public void setRequestMethod(String method)\n@@ -568,2 +591,8 @@\n-        if (connecting) {\n-            throw new IllegalStateException(\"connect in progress\");\n+        lock();\n+        try {\n+            if (connecting) {\n+                throw new IllegalStateException(\"connect in progress\");\n+            }\n+            super.setRequestMethod(method);\n+        } finally {\n+            unlock();\n@@ -571,1 +600,0 @@\n-        super.setRequestMethod(method);\n@@ -578,0 +606,2 @@\n+        assert isLockHeldByCurrentThread();\n+\n@@ -686,0 +716,2 @@\n+                \/\/ safe to synchronize on poster: this is\n+                \/\/ a simple subclass of ByteArrayOutputStream\n@@ -1013,1 +1045,2 @@\n-        synchronized (this) {\n+        lock();\n+        try {\n@@ -1015,0 +1048,2 @@\n+        } finally {\n+            unlock();\n@@ -1060,2 +1095,3 @@\n-    protected void plainConnect()  throws IOException {\n-        synchronized (this) {\n+    protected void plainConnect() throws IOException {\n+        lock();\n+        try {\n@@ -1065,0 +1101,2 @@\n+        } finally {\n+            unlock();\n@@ -1333,3 +1371,5 @@\n-    public synchronized OutputStream getOutputStream() throws IOException {\n-        connecting = true;\n-        SocketPermission p = URLtoSocketPermission(this.url);\n+    public OutputStream getOutputStream() throws IOException {\n+        lock();\n+        try {\n+            connecting = true;\n+            SocketPermission p = URLtoSocketPermission(this.url);\n@@ -1337,11 +1377,14 @@\n-        if (p != null) {\n-            try {\n-                return AccessController.doPrivilegedWithCombiner(\n-                    new PrivilegedExceptionAction<>() {\n-                        public OutputStream run() throws IOException {\n-                            return getOutputStream0();\n-                        }\n-                    }, null, p\n-                );\n-            } catch (PrivilegedActionException e) {\n-                throw (IOException) e.getException();\n+            if (p != null) {\n+                try {\n+                    return AccessController.doPrivilegedWithCombiner(\n+                            new PrivilegedExceptionAction<>() {\n+                                public OutputStream run() throws IOException {\n+                                    return getOutputStream0();\n+                                }\n+                            }, null, p\n+                    );\n+                } catch (PrivilegedActionException e) {\n+                    throw (IOException) e.getException();\n+                }\n+            } else {\n+                return getOutputStream0();\n@@ -1349,2 +1392,2 @@\n-        } else {\n-            return getOutputStream0();\n+        } finally {\n+            unlock();\n@@ -1354,1 +1397,2 @@\n-    private synchronized OutputStream getOutputStream0() throws IOException {\n+    private OutputStream getOutputStream0() throws IOException {\n+        assert isLockHeldByCurrentThread();\n@@ -1444,10 +1488,13 @@\n-            synchronized (this) {\n-                if (setUserCookies) {\n-                    int k = requests.getKey(\"Cookie\");\n-                    if (k != -1)\n-                        userCookies = requests.getValue(k);\n-                    k = requests.getKey(\"Cookie2\");\n-                    if (k != -1)\n-                        userCookies2 = requests.getValue(k);\n-                    setUserCookies = false;\n-                }\n+\n+            \/\/ we should only reach here when called from\n+            \/\/ writeRequest, which in turn is only called by\n+            \/\/ getInputStream0\n+            assert isLockHeldByCurrentThread();\n+            if (setUserCookies) {\n+                int k = requests.getKey(\"Cookie\");\n+                if (k != -1)\n+                    userCookies = requests.getValue(k);\n+                k = requests.getKey(\"Cookie2\");\n+                if (k != -1)\n+                    userCookies2 = requests.getValue(k);\n+                setUserCookies = false;\n@@ -1511,3 +1558,5 @@\n-    public synchronized InputStream getInputStream() throws IOException {\n-        connecting = true;\n-        SocketPermission p = URLtoSocketPermission(this.url);\n+    public InputStream getInputStream() throws IOException {\n+        lock();\n+        try {\n+            connecting = true;\n+            SocketPermission p = URLtoSocketPermission(this.url);\n@@ -1515,11 +1564,14 @@\n-        if (p != null) {\n-            try {\n-                return AccessController.doPrivilegedWithCombiner(\n-                    new PrivilegedExceptionAction<>() {\n-                        public InputStream run() throws IOException {\n-                            return getInputStream0();\n-                        }\n-                    }, null, p\n-                );\n-            } catch (PrivilegedActionException e) {\n-                throw (IOException) e.getException();\n+            if (p != null) {\n+                try {\n+                    return AccessController.doPrivilegedWithCombiner(\n+                            new PrivilegedExceptionAction<>() {\n+                                public InputStream run() throws IOException {\n+                                    return getInputStream0();\n+                                }\n+                            }, null, p\n+                    );\n+                } catch (PrivilegedActionException e) {\n+                    throw (IOException) e.getException();\n+                }\n+            } else {\n+                return getInputStream0();\n@@ -1527,2 +1579,2 @@\n-        } else {\n-            return getInputStream0();\n+        } finally {\n+            unlock();\n@@ -1533,1 +1585,1 @@\n-    private synchronized InputStream getInputStream0() throws IOException {\n+    private InputStream getInputStream0() throws IOException {\n@@ -1535,0 +1587,1 @@\n+        assert isLockHeldByCurrentThread();\n@@ -2013,0 +2066,4 @@\n+\n+        \/\/ Only called from getInputStream0 and doTunneling0\n+        assert isLockHeldByCurrentThread();\n+\n@@ -2063,1 +2120,10 @@\n-    public synchronized void doTunneling() throws IOException {\n+    public void doTunneling() throws IOException {\n+        lock();\n+        try {\n+            doTunneling0();\n+        } finally{\n+            unlock();\n+        }\n+    }\n+\n+    private void doTunneling0() throws IOException {\n@@ -2071,0 +2137,2 @@\n+        assert isLockHeldByCurrentThread();\n+\n@@ -2276,1 +2344,4 @@\n-    private AuthenticationInfo getHttpProxyAuthentication (AuthenticationHeader authhdr) {\n+    private AuthenticationInfo getHttpProxyAuthentication(AuthenticationHeader authhdr) {\n+\n+        assert isLockHeldByCurrentThread();\n+\n@@ -2437,1 +2508,1 @@\n-     * @param authHdr the AuthenticationHeader which tells what auth scheme is\n+     * @param authhdr the AuthenticationHeader which tells what auth scheme is\n@@ -2441,1 +2512,5 @@\n-    private AuthenticationInfo getServerAuthentication (AuthenticationHeader authhdr) {\n+    private AuthenticationInfo getServerAuthentication(AuthenticationHeader authhdr) {\n+\n+        \/\/ Only called from getInputStream0\n+        assert isLockHeldByCurrentThread();\n+\n@@ -2719,0 +2794,2 @@\n+        assert isLockHeldByCurrentThread();\n+\n@@ -3198,5 +3275,7 @@\n-    public synchronized void setRequestProperty(String key, String value) {\n-        if (connected || connecting)\n-            throw new IllegalStateException(\"Already connected\");\n-        if (key == null)\n-            throw new NullPointerException (\"key is null\");\n+    public void setRequestProperty(String key, String value) {\n+        lock();\n+        try {\n+            if (connected || connecting)\n+                throw new IllegalStateException(\"Already connected\");\n+            if (key == null)\n+                throw new NullPointerException(\"key is null\");\n@@ -3204,4 +3283,5 @@\n-        if (isExternalMessageHeaderAllowed(key, value)) {\n-            requests.set(key, value);\n-            if (!key.equalsIgnoreCase(\"Content-Type\")) {\n-                userHeaders.set(key, value);\n+            if (isExternalMessageHeaderAllowed(key, value)) {\n+                requests.set(key, value);\n+                if (!key.equalsIgnoreCase(\"Content-Type\")) {\n+                    userHeaders.set(key, value);\n+                }\n@@ -3209,0 +3289,2 @@\n+        } finally {\n+            unlock();\n@@ -3224,1 +3306,1 @@\n-     * @see #getRequestProperties(java.lang.String)\n+     * @see #getRequestProperty(java.lang.String)\n@@ -3228,9 +3310,11 @@\n-    public synchronized void addRequestProperty(String key, String value) {\n-        if (connected || connecting)\n-            throw new IllegalStateException(\"Already connected\");\n-        if (key == null)\n-            throw new NullPointerException (\"key is null\");\n-\n-        if (isExternalMessageHeaderAllowed(key, value)) {\n-            requests.add(key, value);\n-            if (!key.equalsIgnoreCase(\"Content-Type\")) {\n+    public void addRequestProperty(String key, String value) {\n+        lock();\n+        try {\n+            if (connected || connecting)\n+                throw new IllegalStateException(\"Already connected\");\n+            if (key == null)\n+                throw new NullPointerException(\"key is null\");\n+\n+            if (isExternalMessageHeaderAllowed(key, value)) {\n+                requests.add(key, value);\n+                if (!key.equalsIgnoreCase(\"Content-Type\")) {\n@@ -3238,0 +3322,1 @@\n+                }\n@@ -3239,0 +3324,2 @@\n+        } finally {\n+            unlock();\n@@ -3247,0 +3334,5 @@\n+        \/\/ Only called by the implementation of AuthenticationInfo::setHeaders(...)\n+        \/\/ in AuthenticationInfo subclasses, which is only called from\n+        \/\/ methods from HttpURLConnection protected by the connectionLock.\n+        assert isLockHeldByCurrentThread();\n+\n@@ -3252,8 +3344,4 @@\n-    public synchronized String getRequestProperty (String key) {\n-        if (key == null) {\n-            return null;\n-        }\n-\n-        \/\/ don't return headers containing security sensitive information\n-        for (int i=0; i < EXCLUDE_HEADERS.length; i++) {\n-            if (key.equalsIgnoreCase(EXCLUDE_HEADERS[i])) {\n+    public String getRequestProperty (String key) {\n+        lock();\n+        try {\n+            if (key == null) {\n@@ -3262,4 +3350,6 @@\n-        }\n-        if (!setUserCookies) {\n-            if (key.equalsIgnoreCase(\"Cookie\")) {\n-                return userCookies;\n+\n+            \/\/ don't return headers containing security sensitive information\n+            for (int i = 0; i < EXCLUDE_HEADERS.length; i++) {\n+                if (key.equalsIgnoreCase(EXCLUDE_HEADERS[i])) {\n+                    return null;\n+                }\n@@ -3267,2 +3357,7 @@\n-            if (key.equalsIgnoreCase(\"Cookie2\")) {\n-                return userCookies2;\n+            if (!setUserCookies) {\n+                if (key.equalsIgnoreCase(\"Cookie\")) {\n+                    return userCookies;\n+                }\n+                if (key.equalsIgnoreCase(\"Cookie2\")) {\n+                    return userCookies2;\n+                }\n@@ -3270,0 +3365,3 @@\n+            return requests.findValue(key);\n+        } finally {\n+            unlock();\n@@ -3271,1 +3369,0 @@\n-        return requests.findValue(key);\n@@ -3287,3 +3384,5 @@\n-    public synchronized Map<String, List<String>> getRequestProperties() {\n-        if (connected)\n-            throw new IllegalStateException(\"Already connected\");\n+    public Map<String, List<String>> getRequestProperties() {\n+        lock();\n+        try {\n+            if (connected)\n+                throw new IllegalStateException(\"Already connected\");\n@@ -3291,13 +3390,3 @@\n-        \/\/ exclude headers containing security-sensitive info\n-        if (setUserCookies) {\n-            return requests.getHeaders(EXCLUDE_HEADERS);\n-        }\n-        \/*\n-         * The cookies in the requests message headers may have\n-         * been modified. Use the saved user cookies instead.\n-         *\/\n-        Map<String, List<String>> userCookiesMap = null;\n-        if (userCookies != null || userCookies2 != null) {\n-            userCookiesMap = new HashMap<>();\n-            if (userCookies != null) {\n-                userCookiesMap.put(\"Cookie\", Arrays.asList(userCookies));\n+            \/\/ exclude headers containing security-sensitive info\n+            if (setUserCookies) {\n+                return requests.getHeaders(EXCLUDE_HEADERS);\n@@ -3305,2 +3394,13 @@\n-            if (userCookies2 != null) {\n-                userCookiesMap.put(\"Cookie2\", Arrays.asList(userCookies2));\n+            \/*\n+             * The cookies in the requests message headers may have\n+             * been modified. Use the saved user cookies instead.\n+             *\/\n+            Map<String, List<String>> userCookiesMap = null;\n+            if (userCookies != null || userCookies2 != null) {\n+                userCookiesMap = new HashMap<>();\n+                if (userCookies != null) {\n+                    userCookiesMap.put(\"Cookie\", Arrays.asList(userCookies));\n+                }\n+                if (userCookies2 != null) {\n+                    userCookiesMap.put(\"Cookie2\", Arrays.asList(userCookies2));\n+                }\n@@ -3308,0 +3408,3 @@\n+            return requests.filterAndAddHeaders(EXCLUDE_HEADERS2, userCookiesMap);\n+        } finally {\n+            unlock();\n@@ -3309,1 +3412,0 @@\n-        return requests.filterAndAddHeaders(EXCLUDE_HEADERS2, userCookiesMap);\n@@ -3353,1 +3455,1 @@\n-     * @see java.net.URLConnectiongetReadTimeout()\n+     * @see java.net.URLConnection#getReadTimeout()\n@@ -3472,0 +3574,3 @@\n+        \/\/ safe to use synchronized here: super method is synchronized too\n+        \/\/ and involves no blocking operation; only mark & reset are\n+        \/\/ synchronized in the super class hierarchy.\n@@ -3502,0 +3607,3 @@\n+        \/\/ safe to use synchronized here: super method is synchronized too\n+        \/\/ and involves no blocking operation; only mark & reset are\n+        \/\/ synchronized in the super class hierarchy.\n@@ -3682,2 +3790,8 @@\n-            if (((PrintStream)out).checkError()) {\n-                throw new IOException(\"Error writing request body to server\");\n+            if (out instanceof PrintStream) {\n+                if (((PrintStream) out).checkError()) {\n+                    throw new IOException(\"Error writing request body to server\");\n+                }\n+            } else if (out instanceof ChunkedOutputStream) {\n+                if (((ChunkedOutputStream) out).checkError()) {\n+                    throw new IOException(\"Error writing request body to server\");\n+                }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/HttpURLConnection.java","additions":233,"deletions":119,"binary":false,"changes":352,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import java.util.concurrent.locks.ReentrantLock;\n+\n@@ -60,0 +62,2 @@\n+    private static final ReentrantLock negotiateLock = new ReentrantLock();\n+\n@@ -104,9 +108,11 @@\n-    synchronized public static boolean isSupported(HttpCallerInfo hci) {\n-        if (supported == null) {\n-            supported = new HashMap<>();\n-        }\n-        String hostname = hci.host;\n-        hostname = hostname.toLowerCase();\n-        if (supported.containsKey(hostname)) {\n-            return supported.get(hostname);\n-        }\n+    public static boolean isSupported(HttpCallerInfo hci) {\n+        negotiateLock.lock();\n+        try {\n+            if (supported == null) {\n+                supported = new HashMap<>();\n+            }\n+            String hostname = hci.host;\n+            hostname = hostname.toLowerCase();\n+            if (supported.containsKey(hostname)) {\n+                return supported.get(hostname);\n+            }\n@@ -114,12 +120,18 @@\n-        Negotiator neg = Negotiator.getNegotiator(hci);\n-        if (neg != null) {\n-            supported.put(hostname, true);\n-            \/\/ the only place cache.put is called. here we can make sure\n-            \/\/ the object is valid and the oneToken inside is not null\n-            if (cache == null) {\n-                cache = new ThreadLocal<>() {\n-                    @Override\n-                    protected HashMap<String, Negotiator> initialValue() {\n-                        return new HashMap<>();\n-                    }\n-                };\n+            Negotiator neg = Negotiator.getNegotiator(hci);\n+            if (neg != null) {\n+                supported.put(hostname, true);\n+                \/\/ the only place cache.put is called. here we can make sure\n+                \/\/ the object is valid and the oneToken inside is not null\n+                if (cache == null) {\n+                    cache = new ThreadLocal<>() {\n+                        @Override\n+                        protected HashMap<String, Negotiator> initialValue() {\n+                            return new HashMap<>();\n+                        }\n+                    };\n+                }\n+                cache.get().put(hostname, neg);\n+                return true;\n+            } else {\n+                supported.put(hostname, false);\n+                return false;\n@@ -127,5 +139,2 @@\n-            cache.get().put(hostname, neg);\n-            return true;\n-        } else {\n-            supported.put(hostname, false);\n-            return false;\n+        } finally {\n+            negotiateLock.unlock();\n@@ -135,3 +144,8 @@\n-    private static synchronized HashMap<String, Negotiator> getCache() {\n-        if (cache == null) return null;\n-        return cache.get();\n+    private static HashMap<String, Negotiator> getCache() {\n+        negotiateLock.lock();\n+        try {\n+            if (cache == null) return null;\n+            return cache.get();\n+        } finally {\n+            negotiateLock.unlock();\n+        }\n@@ -175,1 +189,3 @@\n-    public synchronized boolean setHeaders(HttpURLConnection conn, HeaderParser p, String raw) {\n+    public boolean setHeaders(HttpURLConnection conn, HeaderParser p, String raw) {\n+\n+        assert conn.isLockHeldByCurrentThread();\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/NegotiateAuthentication.java","additions":47,"deletions":31,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -344,0 +344,1 @@\n+\n@@ -345,1 +346,2 @@\n-                    synchronized (ret) {\n+                    ret.lock();\n+                    try {\n@@ -354,0 +356,2 @@\n+                    } finally {\n+                        ret.unlock();\n@@ -360,1 +364,2 @@\n-                    synchronized(ret) {\n+                    ret.lock();\n+                    try {\n@@ -366,0 +371,2 @@\n+                    } finally {\n+                        ret.unlock();\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/https\/HttpsClient.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -228,1 +228,4 @@\n-    public synchronized boolean setHeaders(HttpURLConnection conn, HeaderParser p, String raw) {\n+    public boolean setHeaders(HttpURLConnection conn, HeaderParser p, String raw) {\n+        \/\/ no need to synchronize here:\n+        \/\/   already locked by s.n.w.p.h.HttpURLConnection\n+        assert conn.isLockHeldByCurrentThread();\n","filename":"src\/java.base\/unix\/classes\/sun\/net\/www\/protocol\/http\/ntlm\/NTLMAuthentication.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -247,1 +247,5 @@\n-    public synchronized boolean setHeaders(HttpURLConnection conn, HeaderParser p, String raw) {\n+    public boolean setHeaders(HttpURLConnection conn, HeaderParser p, String raw) {\n+\n+        \/\/ no need to synchronize here:\n+        \/\/   already locked by s.n.w.p.h.HttpURLConnection\n+        assert conn.isLockHeldByCurrentThread();\n","filename":"src\/java.base\/windows\/classes\/sun\/net\/www\/protocol\/http\/ntlm\/NTLMAuthentication.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"}]}