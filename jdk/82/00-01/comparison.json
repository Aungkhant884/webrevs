{"files":[{"patch":"@@ -3900,0 +3900,1 @@\n+  JVMFlag::check_all_flag_declarations();\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -189,4 +189,0 @@\n-bool JVMFlag::is_read_write() const {\n-  return (_flags & KIND_READ_WRITE) != 0;\n-}\n-\n@@ -270,1 +266,1 @@\n-  return is_manageable() || (is_product() && is_read_write());\n+  return is_manageable() || is_product();\n@@ -519,1 +515,0 @@\n-    { KIND_READ_WRITE, \"rw\" },\n@@ -660,1 +655,1 @@\n-static constexpr inline int flag_group(int flag_enum) {\n+static constexpr int flag_group(int flag_enum) {\n@@ -1226,0 +1221,4 @@\n+#endif \/\/ PRODUCT\n+\n+#ifdef ASSERT\n+\n@@ -1230,1 +1229,20 @@\n-#endif \/\/ PRODUCT\n+void JVMFlag::check_all_flag_declarations() {\n+  for (JVMFlag* current = &flagTable[0]; current->_name != NULL; current++) {\n+    int flags = static_cast<int>(current->_flags);\n+    \/\/ Backwards compatibility. This will be relaxed\/removed in JDK-7123237.\n+    int mask = JVMFlag::KIND_DIAGNOSTIC | JVMFlag::KIND_MANAGEABLE | JVMFlag::KIND_EXPERIMENTAL;\n+    if ((flags & mask) != 0) {\n+      assert((flags & mask) == JVMFlag::KIND_DIAGNOSTIC ||\n+             (flags & mask) == JVMFlag::KIND_MANAGEABLE ||\n+             (flags & mask) == JVMFlag::KIND_EXPERIMENTAL,\n+             \"%s can be declared with at most one of \"\n+             \"DIAGNOSTIC, MANAGEABLE or EXPERIMENTAL\", current->_name);\n+      assert((flags & KIND_NOT_PRODUCT) == 0 &&\n+             (flags & KIND_DEVELOP) == 0,\n+             \"%s has an optional DIAGNOSTIC, MANAGEABLE or EXPERIMENTAL \"\n+             \"attribute; it must be declared as a product flag\", current->_name);\n+    }\n+  }\n+}\n+\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlag.cpp","additions":26,"deletions":8,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-    KIND_READ_WRITE         = 1 << 16,\n@@ -127,2 +126,2 @@\n-  constexpr inline JVMFlag(int flag_enum, const char* type, const char* name,\n-                           void* addr, int flags, int extra_flags, const char* doc);\n+  constexpr JVMFlag(int flag_enum, const char* type, const char* name,\n+                    void* addr, int flags, int extra_flags, const char* doc);\n@@ -130,2 +129,2 @@\n-  constexpr inline JVMFlag(int flag_enum,  const char* type, const char* name,\n-                           void* addr, int flags, const char* doc);\n+  constexpr JVMFlag(int flag_enum,  const char* type, const char* name,\n+                    void* addr, int flags, const char* doc);\n@@ -153,1 +152,2 @@\n-  static void assert_valid_flag_enum(int i) PRODUCT_RETURN;\n+  static void assert_valid_flag_enum(int i) NOT_DEBUG_RETURN;\n+  static void check_all_flag_declarations() NOT_DEBUG_RETURN;\n@@ -161,0 +161,5 @@\n+  static JVMFlag* flag_from_enum(int flag_enum) {\n+    assert_valid_flag_enum(flag_enum);\n+    return &JVMFlag::flags[flag_enum];\n+  }\n+\n@@ -213,1 +218,0 @@\n-  bool is_read_write() const;\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlag.hpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -220,1 +220,1 @@\n-  for (int i=0; i<NUM_JVMFlagsEnum; i++) {\n+  for (int i = 0; i < NUM_JVMFlagsEnum; i++) {\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintList.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-  assert(0 <= i && i <NUM_JVMFlagConstraintsEnum, \"sanity\");\n+  assert(0 <= i && i < NUM_JVMFlagConstraintsEnum, \"sanity\");\n@@ -91,1 +91,1 @@\n-  static constexpr const JVMFlagLimit* get_limit(const JVMTypedFlagLimit<T>*p, int dummy, T min, T max) {\n+  static constexpr const JVMFlagLimit* get_limit(const JVMTypedFlagLimit<T>* p, int dummy, T min, T max) {\n@@ -94,1 +94,1 @@\n-  static constexpr const JVMFlagLimit* get_limit(const JVMTypedFlagLimit<T>*p, int dummy, ConstraintMarker dummy2, short func, int phase) {\n+  static constexpr const JVMFlagLimit* get_limit(const JVMTypedFlagLimit<T>* p, int dummy, ConstraintMarker dummy2, short func, int phase) {\n@@ -97,1 +97,1 @@\n-  static constexpr const JVMFlagLimit* get_limit(const JVMTypedFlagLimit<T>*p, int dummy, T min, T max, ConstraintMarker dummy2, short func, int phase) {\n+  static constexpr const JVMFlagLimit* get_limit(const JVMTypedFlagLimit<T>* p, int dummy, T min, T max, ConstraintMarker dummy2, short func, int phase) {\n@@ -100,1 +100,1 @@\n-  static constexpr const JVMFlagLimit* get_limit(const JVMTypedFlagLimit<T>*p, int dummy, ConstraintMarker dummy2, short func, int phase, T min, T max) {\n+  static constexpr const JVMFlagLimit* get_limit(const JVMTypedFlagLimit<T>* p, int dummy, ConstraintMarker dummy2, short func, int phase, T min, T max) {\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagLimit.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -44,0 +44,14 @@\n+\n+\/\/ A JVMFlagLimit is created for each JVMFlag that has a range() and\/or constraint() in its declaration in\n+\/\/ the globals_xxx.hpp file.\n+\/\/\n+\/\/ To query the range information of a JVMFlag:\n+\/\/     JVMFlagLimit::get_range(JVMFlag*)\n+\/\/     JVMFlagLimit::get_range_at(int flag_enum)\n+\/\/ If the given flag doesn't have a range, NULL is returned.\n+\/\/\n+\/\/ To query the constraint information of a JVMFlag:\n+\/\/     JVMFlagLimit::get_constraint(JVMFlag*)\n+\/\/     JVMFlagLimit::get_constraint_at(int flag_enum)\n+\/\/ If the given flag doesn't have a constraint, NULL is returned.\n+\n@@ -49,1 +63,1 @@\n- static const JVMFlagLimit* const* flagLimits;\n+  static const JVMFlagLimit* const* flagLimits;\n@@ -53,1 +67,1 @@\n-  enum {\n+  enum Kind {\n@@ -58,0 +72,16 @@\n+private:\n+  static const JVMFlagLimit* get_kind_at(int flag_enum, Kind kind) {\n+    const JVMFlagLimit* limit = at(flag_enum);\n+    if (limit != NULL && (limit->_kind & int(kind)) != 0) {\n+      _last_checked = flag_enum;\n+      return limit;\n+    } else {\n+      return NULL;\n+    }\n+  }\n+\n+  static const JVMFlagLimit* at(int flag_enum) {\n+    JVMFlag::assert_valid_flag_enum(flag_enum);\n+    return flagLimits[flag_enum];\n+  }\n+\n@@ -69,7 +99,1 @@\n-    const JVMFlagLimit* limit = flagLimits[flag_enum];\n-    if (limit != NULL && (limit->_kind & HAS_RANGE) != 0) {\n-      _last_checked = flag_enum;\n-      return limit;\n-    } else {\n-      return NULL;\n-    }\n+    return get_kind_at(flag_enum, HAS_RANGE);\n@@ -82,7 +106,1 @@\n-    const JVMFlagLimit* limit = flagLimits[flag_enum];\n-    if (limit != NULL && (limit->_kind & HAS_CONSTRAINT) != 0) {\n-      _last_checked = flag_enum;\n-      return limit;\n-    } else {\n-      return NULL;\n-    }\n+    return get_kind_at(flag_enum, HAS_CONSTRAINT);\n@@ -90,0 +108,1 @@\n+\n@@ -92,1 +111,1 @@\n-      return &JVMFlag::flags[_last_checked];\n+      return JVMFlag::flag_from_enum(_last_checked);\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagLimit.hpp","additions":36,"deletions":17,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -245,5 +245,5 @@\n-#define DEFINE_RANGE_CHECK(T)                                                           \\\n-JVMFlag::Error JVMFlagRangeChecker::check_ ## T(T value, bool verbose) const {          \\\n-  assert(exists(), \"must be\");                                                          \\\n-  JVMFlagRange_ ## T range(_flag, _limit->as_##T()->min(), _limit->as_ ## T()->max());  \\\n-  return range.check_ ## T(value, verbose);                                             \\\n+#define DEFINE_RANGE_CHECK(T)                                                            \\\n+JVMFlag::Error JVMFlagRangeChecker::check_ ## T(T value, bool verbose) const {           \\\n+  assert(exists(), \"must be\");                                                           \\\n+  JVMFlagRange_ ## T range(_flag, _limit->as_ ## T()->min(), _limit->as_ ## T()->max()); \\\n+  return range.check_ ## T(value, verbose);                                              \\\n@@ -256,4 +256,4 @@\n-#define CHECK_RANGE(T)                                                                    \\\n-  if (_flag->is_ ## T()) {                                                                \\\n-    JVMFlagRange_ ## T range(_flag, _limit->as_##T()->min(), _limit->as_ ## T()->max());  \\\n-    return range.check(verbose);                                                          \\\n+#define CHECK_RANGE(T)                                                                     \\\n+  if (_flag->is_ ## T()) {                                                                 \\\n+    JVMFlagRange_ ## T range(_flag, _limit->as_ ## T()->min(), _limit->as_ ## T()->max()); \\\n+    return range.check(verbose);                                                           \\\n@@ -269,5 +269,5 @@\n-#define PRINT_RANGE(T)                                                                    \\\n-  if (_flag->is_ ## T()) {                                                                \\\n-    JVMFlagRange_ ## T range(_flag, _limit->as_##T()->min(), _limit->as_ ## T()->max());  \\\n-    range.print(out);                                                                     \\\n-    return;                                                                               \\\n+#define PRINT_RANGE(T)                                                                     \\\n+  if (_flag->is_ ## T()) {                                                                 \\\n+    JVMFlagRange_ ## T range(_flag, _limit->as_ ## T()->min(), _limit->as_ ## T()->max()); \\\n+    range.print(out);                                                                      \\\n+    return;                                                                                \\\n@@ -290,2 +290,2 @@\n-      \/\/ Two special cases who's range lower limit is an os:: function call and cannot\n-      \/\/ be initialized at compile time with constexpr.\n+      \/\/ Two special cases where the lower limit of the range is defined by an os:: function call\n+      \/\/ and cannot be initialized at compile time with constexpr.\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagRangeList.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -41,0 +41,10 @@\n+\/\/ develop_pd\/product_pd flags are the same as develop\/product, except that their default values\n+\/\/ are specified in platform-dependent header files.\n+\n+\/\/ Flags must be declared with the following number of parameters:\n+\/\/ non-pd flags:\n+\/\/    (type, name, default_value, doc), or\n+\/\/    (type, name, default_value, extra_attrs, doc)\n+\/\/ pd flags:\n+\/\/    (type, name, doc), or\n+\/\/    (type, name, extra_attrs, doc)\n@@ -47,9 +57,13 @@\n-\/\/ Note: Diagnostic options not meant for VM tuning or for product modes.\n-\/\/ They are to be used for VM quality assurance or field diagnosis\n-\/\/ of VM bugs.  They are hidden so that users will not be encouraged to\n-\/\/ try them as if they were VM ordinary execution options.  However, they\n-\/\/ are available in the product version of the VM.  Under instruction\n-\/\/ from support engineers, VM customers can turn them on to collect\n-\/\/ diagnostic information about VM problems.  To use a VM diagnostic\n-\/\/ option, you must first specify +UnlockDiagnosticVMOptions.\n-\/\/ (This master switch also affects the behavior of -Xprintflags.)\n+\/\/ The optional extra_attrs parameter may have one of the following values:\n+\/\/ DIAGNOSTIC, EXPERIMENTAL, or MANAGEABLE. Currently extra_attrs can be used\n+\/\/ only with product\/product_pd flags.\n+\/\/\n+\/\/ DIAGNOSTIC options are not meant for VM tuning or for product modes.\n+\/\/    They are to be used for VM quality assurance or field diagnosis\n+\/\/    of VM bugs.  They are hidden so that users will not be encouraged to\n+\/\/    try them as if they were VM ordinary execution options.  However, they\n+\/\/    are available in the product version of the VM.  Under instruction\n+\/\/    from support engineers, VM customers can turn them on to collect\n+\/\/    diagnostic information about VM problems.  To use a VM diagnostic\n+\/\/    option, you must first specify +UnlockDiagnosticVMOptions.\n+\/\/    (This master switch also affects the behavior of -Xprintflags.)\n@@ -57,1 +71,1 @@\n-\/\/ experimental flags are in support of features that are not\n+\/\/ EXPERIMENTAL flags are in support of features that are not\n@@ -73,1 +87,1 @@\n-\/\/ manageable flags are writeable external product flags.\n+\/\/ MANAGEABLE flags are writeable external product flags.\n@@ -87,14 +101,1 @@\n-\/\/ product_rw flags are writeable internal product flags.\n-\/\/    They are like \"manageable\" flags but for internal\/private use.\n-\/\/    The list of product_rw flags are internal\/private flags which\n-\/\/    may be changed\/removed in a future release.  It can be set\n-\/\/    through the management interface to get\/set value\n-\/\/    when the name of flag is supplied.\n-\/\/\n-\/\/    A flag can be made as \"product_rw\" only if\n-\/\/    - the VM implementation supports dynamic setting of the flag.\n-\/\/      This implies that the VM must *always* query the flag variable\n-\/\/      and not reuse state related to the flag state at any given time.\n-\/\/\n-\/\/ Note that when there is a need to support develop flags to be writeable,\n-\/\/ it can be done in the same way as product_rw.\n+\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":26,"deletions":25,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -975,6 +975,6 @@\n-template<class T> inline constexpr T MAX2(T a, T b)           { return (a > b) ? a : b; }\n-template<class T> inline constexpr T MIN2(T a, T b)           { return (a < b) ? a : b; }\n-template<class T> inline constexpr T MAX3(T a, T b, T c)      { return MAX2(MAX2(a, b), c); }\n-template<class T> inline constexpr T MIN3(T a, T b, T c)      { return MIN2(MIN2(a, b), c); }\n-template<class T> inline constexpr T MAX4(T a, T b, T c, T d) { return MAX2(MAX3(a, b, c), d); }\n-template<class T> inline constexpr T MIN4(T a, T b, T c, T d) { return MIN2(MIN3(a, b, c), d); }\n+template<class T> constexpr T MAX2(T a, T b)           { return (a > b) ? a : b; }\n+template<class T> constexpr T MIN2(T a, T b)           { return (a < b) ? a : b; }\n+template<class T> constexpr T MAX3(T a, T b, T c)      { return MAX2(MAX2(a, b), c); }\n+template<class T> constexpr T MIN3(T a, T b, T c)      { return MIN2(MIN2(a, b), c); }\n+template<class T> constexpr T MAX4(T a, T b, T c, T d) { return MAX2(MAX3(a, b, c), d); }\n+template<class T> constexpr T MIN4(T a, T b, T c, T d) { return MIN2(MIN3(a, b, c), d); }\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"}]}