{"files":[{"patch":"@@ -78,7 +78,5 @@\n-#define ARCH_FLAGS(develop, \\\n-                   product, \\\n-                   diagnostic, \\\n-                   experimental, \\\n-                   notproduct, \\\n-                   range, \\\n-                   constraint) \\\n+#define ARCH_FLAGS(develop,                                             \\\n+                   product,                                             \\\n+                   notproduct,                                          \\\n+                   range,                                               \\\n+                   constraint)                                          \\\n@@ -116,0 +114,2 @@\n+\/\/ end of ARCH_FLAGS\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -73,6 +73,4 @@\n-#define ARCH_FLAGS(develop, \\\n-                   product, \\\n-                   diagnostic, \\\n-                   experimental, \\\n-                   notproduct, \\\n-                   range, \\\n+#define ARCH_FLAGS(develop,     \\\n+                   product,     \\\n+                   notproduct,  \\\n+                   range,       \\\n@@ -80,0 +78,3 @@\n+\n+\/\/ end of ARCH_FLAGS\n+\n","filename":"src\/hotspot\/cpu\/arm\/globals_arm.hpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -78,7 +78,5 @@\n-#define ARCH_FLAGS(develop,      \\\n-                   product,      \\\n-                   diagnostic,   \\\n-                   experimental, \\\n-                   notproduct,   \\\n-                   range,        \\\n-                   constraint)   \\\n+#define ARCH_FLAGS(develop,                                                 \\\n+                   product,                                                 \\\n+                   notproduct,                                              \\\n+                   range,                                                   \\\n+                   constraint)                                              \\\n@@ -164,1 +162,1 @@\n-  experimental(bool, UseRTMForStackLocks, false,                            \\\n+  product(bool, UseRTMForStackLocks, false, EXPERIMENTAL,                   \\\n@@ -174,1 +172,1 @@\n-  experimental(int, RTMSpinLoopCount, 100,                                  \\\n+  product(int, RTMSpinLoopCount, 100, EXPERIMENTAL,                         \\\n@@ -178,1 +176,1 @@\n-  experimental(int, RTMAbortThreshold, 1000,                                \\\n+  product(int, RTMAbortThreshold, 1000, EXPERIMENTAL,                       \\\n@@ -182,1 +180,1 @@\n-  experimental(int, RTMLockingThreshold, 10000,                             \\\n+  product(int, RTMLockingThreshold, 10000, EXPERIMENTAL,                    \\\n@@ -187,1 +185,1 @@\n-  experimental(int, RTMAbortRatio, 50,                                      \\\n+  product(int, RTMAbortRatio, 50, EXPERIMENTAL,                             \\\n@@ -191,1 +189,1 @@\n-  experimental(int, RTMTotalCountIncrRate, 64,                              \\\n+  product(int, RTMTotalCountIncrRate, 64, EXPERIMENTAL,                     \\\n@@ -196,1 +194,1 @@\n-  experimental(intx, RTMLockingCalculationDelay, 0,                         \\\n+  product(intx, RTMLockingCalculationDelay, 0, EXPERIMENTAL,                \\\n@@ -200,2 +198,4 @@\n-  experimental(bool, UseRTMXendForLockBusy, true,                           \\\n-          \"Use RTM Xend instead of Xabort when lock busy\")                  \\\n+  product(bool, UseRTMXendForLockBusy, true, EXPERIMENTAL,                  \\\n+          \"Use RTM Xend instead of Xabort when lock busy\")\n+\n+\/\/ end of ARCH_FLAGS\n","filename":"src\/hotspot\/cpu\/ppc\/globals_ppc.hpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -78,7 +78,5 @@\n-#define ARCH_FLAGS(develop,      \\\n-                   product,      \\\n-                   diagnostic,   \\\n-                   experimental, \\\n-                   notproduct,   \\\n-                   range,        \\\n-                   constraint)   \\\n+#define ARCH_FLAGS(develop,                                                   \\\n+                   product,                                                   \\\n+                   notproduct,                                                \\\n+                   range,                                                     \\\n+                   constraint)                                                \\\n@@ -120,0 +118,2 @@\n+\/\/ end of ARCH_FLAGS\n+\n","filename":"src\/hotspot\/cpu\/s390\/globals_s390.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -92,7 +92,5 @@\n-#define ARCH_FLAGS(develop, \\\n-                   product, \\\n-                   diagnostic, \\\n-                   experimental, \\\n-                   notproduct, \\\n-                   range, \\\n-                   constraint) \\\n+#define ARCH_FLAGS(develop,                                                 \\\n+                   product,                                                 \\\n+                   notproduct,                                              \\\n+                   range,                                                   \\\n+                   constraint)                                              \\\n@@ -117,1 +115,1 @@\n-  diagnostic(bool, UseIncDec, true,                                         \\\n+  product(bool, UseIncDec, true, DIAGNOSTIC,                                \\\n@@ -151,1 +149,1 @@\n-  experimental(bool, UseRTMForStackLocks, false,                            \\\n+  product(bool, UseRTMForStackLocks, false, EXPERIMENTAL,                   \\\n@@ -161,1 +159,1 @@\n-  experimental(int, RTMSpinLoopCount, 100,                                  \\\n+  product(int, RTMSpinLoopCount, 100, EXPERIMENTAL,                         \\\n@@ -165,1 +163,1 @@\n-  experimental(int, RTMAbortThreshold, 1000,                                \\\n+  product(int, RTMAbortThreshold, 1000, EXPERIMENTAL,                       \\\n@@ -169,1 +167,1 @@\n-  experimental(int, RTMLockingThreshold, 10000,                             \\\n+  product(int, RTMLockingThreshold, 10000, EXPERIMENTAL,                    \\\n@@ -174,1 +172,1 @@\n-  experimental(int, RTMAbortRatio, 50,                                      \\\n+  product(int, RTMAbortRatio, 50, EXPERIMENTAL,                             \\\n@@ -178,1 +176,1 @@\n-  experimental(int, RTMTotalCountIncrRate, 64,                              \\\n+  product(int, RTMTotalCountIncrRate, 64, EXPERIMENTAL,                     \\\n@@ -183,1 +181,1 @@\n-  experimental(intx, RTMLockingCalculationDelay, 0,                         \\\n+  product(intx, RTMLockingCalculationDelay, 0, EXPERIMENTAL,                \\\n@@ -187,1 +185,1 @@\n-  experimental(bool, UseRTMXendForLockBusy, true,                           \\\n+  product(bool, UseRTMXendForLockBusy, true, EXPERIMENTAL,                  \\\n@@ -206,1 +204,1 @@\n-  diagnostic(bool, UseLibmIntrinsic, true,                                  \\\n+  product(bool, UseLibmIntrinsic, true, DIAGNOSTIC,                         \\\n@@ -213,1 +211,1 @@\n-  diagnostic(int, AVX3Threshold, 4096,                                      \\\n+  product(int, AVX3Threshold, 4096, DIAGNOSTIC,                             \\\n@@ -219,1 +217,1 @@\n-  diagnostic(bool, IntelJccErratumMitigation, true,                         \\\n+  product(bool, IntelJccErratumMitigation, true, DIAGNOSTIC,                \\\n@@ -223,0 +221,2 @@\n+\/\/ end of ARCH_FLAGS\n+\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -76,7 +76,5 @@\n-#define ARCH_FLAGS(develop, \\\n-                   product, \\\n-                   diagnostic, \\\n-                   experimental, \\\n-                   notproduct, \\\n-                   range, \\\n-                   constraint)  \\\n+#define ARCH_FLAGS(develop,                                                 \\\n+                   product,                                                 \\\n+                   notproduct,                                              \\\n+                   range,                                                   \\\n+                   constraint)                                              \\\n@@ -88,2 +86,3 @@\n-          \"Use fast method entry code for accessor methods\")                \\\n-                                                                            \\\n+          \"Use fast method entry code for accessor methods\")\n+\n+\/\/ end of ARCH_FLAGS\n","filename":"src\/hotspot\/cpu\/zero\/globals_zero.hpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-\/\/ Defines Aix specific flags. They are not available on other platforms.\n+\/\/ Declare Aix specific flags. They are not available on other platforms.\n@@ -33,9 +33,7 @@\n-#define RUNTIME_OS_FLAGS(develop, \\\n-                         develop_pd, \\\n-                         product, \\\n-                         product_pd, \\\n-                         diagnostic, \\\n-                         diagnostic_pd, \\\n-                         notproduct, \\\n-                         range, \\\n-                         constraint) \\\n+#define RUNTIME_OS_FLAGS(develop,                                                   \\\n+                         develop_pd,                                                \\\n+                         product,                                                   \\\n+                         product_pd,                                                \\\n+                         notproduct,                                                \\\n+                         range,                                                     \\\n+                         constraint)                                                \\\n@@ -80,2 +78,1 @@\n-          \"Explicit commit for virtual memory.\")                                    \\\n-                                                                                    \\\n+          \"Explicit commit for virtual memory.\")\n@@ -83,0 +80,1 @@\n+\/\/ end of RUNTIME_OS_FLAGS\n","filename":"src\/hotspot\/os\/aix\/globals_aix.hpp","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-\/\/ Defines Bsd specific flags. They are not available on other platforms.\n+\/\/ Declare Bsd specific flags. They are not available on other platforms.\n@@ -31,8 +31,6 @@\n-#define RUNTIME_OS_FLAGS(develop, \\\n-                         develop_pd, \\\n-                         product, \\\n-                         product_pd, \\\n-                         diagnostic, \\\n-                         diagnostic_pd, \\\n-                         notproduct, \\\n-                         range, \\\n+#define RUNTIME_OS_FLAGS(develop,     \\\n+                         develop_pd,  \\\n+                         product,     \\\n+                         product_pd,  \\\n+                         notproduct,  \\\n+                         range,       \\\n@@ -41,0 +39,2 @@\n+\/\/ end of RUNTIME_OS_FLAGS\n+\n","filename":"src\/hotspot\/os\/bsd\/globals_bsd.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-\/\/ Defines Linux specific flags. They are not available on other platforms.\n+\/\/ Declare Linux specific flags. They are not available on other platforms.\n@@ -31,9 +31,7 @@\n-#define RUNTIME_OS_FLAGS(develop, \\\n-                         develop_pd, \\\n-                         product, \\\n-                         product_pd, \\\n-                         diagnostic, \\\n-                         diagnostic_pd, \\\n-                         notproduct, \\\n-                         range, \\\n-                         constraint) \\\n+#define RUNTIME_OS_FLAGS(develop,                                       \\\n+                         develop_pd,                                    \\\n+                         product,                                       \\\n+                         product_pd,                                    \\\n+                         notproduct,                                    \\\n+                         range,                                         \\\n+                         constraint)                                    \\\n@@ -73,1 +71,1 @@\n-  diagnostic(bool, DumpPrivateMappingsInCore, true,                     \\\n+  product(bool, DumpPrivateMappingsInCore, true, DIAGNOSTIC,            \\\n@@ -78,1 +76,1 @@\n-  diagnostic(bool, DumpSharedMappingsInCore, true,                      \\\n+  product(bool, DumpSharedMappingsInCore, true, DIAGNOSTIC,             \\\n@@ -83,1 +81,1 @@\n-  diagnostic(bool, UseCpuAllocPath, false,                              \\\n+  product(bool, UseCpuAllocPath, false, DIAGNOSTIC,                     \\\n@@ -86,0 +84,2 @@\n+\/\/ end of RUNTIME_OS_FLAGS\n+\n","filename":"src\/hotspot\/os\/linux\/globals_linux.hpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-\/\/ Defines Windows specific flags. They are not available on other platforms.\n+\/\/ Declare Windows specific flags. They are not available on other platforms.\n@@ -31,8 +31,6 @@\n-#define RUNTIME_OS_FLAGS(develop, \\\n-                         develop_pd, \\\n-                         product, \\\n-                         product_pd, \\\n-                         diagnostic, \\\n-                         diagnostic_pd, \\\n-                         notproduct, \\\n-                         range, \\\n+#define RUNTIME_OS_FLAGS(develop,     \\\n+                         develop_pd,  \\\n+                         product,     \\\n+                         product_pd,  \\\n+                         notproduct,  \\\n+                         range,       \\\n@@ -41,0 +39,2 @@\n+\/\/ end of RUNTIME_OS_FLAGS\n+\n","filename":"src\/hotspot\/os\/windows\/globals_windows.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-\/\/ Defines all global flags used by the client compiler.\n+\/\/ Declare all global flags used by the client compiler.\n@@ -37,9 +37,7 @@\n-#define C1_FLAGS(develop, \\\n-                 develop_pd, \\\n-                 product, \\\n-                 product_pd, \\\n-                 diagnostic, \\\n-                 diagnostic_pd, \\\n-                 notproduct, \\\n-                 range, \\\n-                 constraint) \\\n+#define C1_FLAGS(develop,                                                   \\\n+                 develop_pd,                                                \\\n+                 product,                                                   \\\n+                 product_pd,                                                \\\n+                 notproduct,                                                \\\n+                 range,                                                     \\\n+                 constraint)                                                \\\n@@ -161,1 +159,1 @@\n-  diagnostic(bool, InlineNIOCheckIndex, true,                               \\\n+  product(bool, InlineNIOCheckIndex, true, DIAGNOSTIC,                      \\\n@@ -340,2 +338,3 @@\n-          \"print control flow graph to a separate file during compilation\") \\\n-                                                                            \\\n+          \"print control flow graph to a separate file during compilation\")\n+\n+\/\/ end of C1_FLAGS\n","filename":"src\/hotspot\/share\/c1\/c1_globals.hpp","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -36,12 +36,6 @@\n-                    develop_pd,                                             \\\n-                    product,                                                \\\n-                    product_pd,                                             \\\n-                    diagnostic,                                             \\\n-                    diagnostic_pd,                                          \\\n-                    experimental,                                           \\\n-                    notproduct,                                             \\\n-                    manageable,                                             \\\n-                    product_rw,                                             \\\n-                    lp64_product,                                           \\\n-                    range,                                                  \\\n-                    constraint)                                             \\\n+                         develop_pd,                                        \\\n+                         product,                                           \\\n+                         product_pd,                                        \\\n+                         notproduct,                                        \\\n+                         range,                                             \\\n+                         constraint)                                        \\\n@@ -49,1 +43,1 @@\n-  experimental(size_t, EpsilonPrintHeapSteps, 20,                           \\\n+  product(size_t, EpsilonPrintHeapSteps, 20, EXPERIMENTAL,                  \\\n@@ -54,1 +48,1 @@\n-  experimental(size_t, EpsilonUpdateCountersStep, 1 * M,                    \\\n+  product(size_t, EpsilonUpdateCountersStep, 1 * M, EXPERIMENTAL,           \\\n@@ -60,1 +54,1 @@\n-  experimental(size_t, EpsilonMaxTLABSize, 4 * M,                           \\\n+  product(size_t, EpsilonMaxTLABSize, 4 * M, EXPERIMENTAL,                  \\\n@@ -66,1 +60,1 @@\n-  experimental(bool, EpsilonElasticTLAB, true,                              \\\n+  product(bool, EpsilonElasticTLAB, true, EXPERIMENTAL,                     \\\n@@ -72,1 +66,1 @@\n-  experimental(bool, EpsilonElasticTLABDecay, true,                         \\\n+  product(bool, EpsilonElasticTLABDecay, true, EXPERIMENTAL,                \\\n@@ -78,1 +72,1 @@\n-  experimental(double, EpsilonTLABElasticity, 1.1,                          \\\n+  product(double, EpsilonTLABElasticity, 1.1, EXPERIMENTAL,                 \\\n@@ -85,1 +79,1 @@\n-  experimental(size_t, EpsilonTLABDecayTime, 1000,                          \\\n+  product(size_t, EpsilonTLABDecayTime, 1000, EXPERIMENTAL,                 \\\n@@ -92,1 +86,1 @@\n-  experimental(size_t, EpsilonMinHeapExpand, 128 * M,                       \\\n+  product(size_t, EpsilonMinHeapExpand, 128 * M, EXPERIMENTAL,              \\\n@@ -97,0 +91,2 @@\n+\/\/ end of GC_EPSILON_FLAGS\n+\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilon_globals.hpp","additions":16,"deletions":20,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -38,3 +38,0 @@\n-                    diagnostic,                                             \\\n-                    diagnostic_pd,                                          \\\n-                    experimental,                                           \\\n@@ -42,3 +39,0 @@\n-                    manageable,                                             \\\n-                    product_rw,                                             \\\n-                    lp64_product,                                           \\\n@@ -54,1 +48,1 @@\n-  experimental(size_t, G1AdaptiveIHOPNumInitialSamples, 3,                  \\\n+  product(size_t, G1AdaptiveIHOPNumInitialSamples, 3, EXPERIMENTAL,         \\\n@@ -64,1 +58,1 @@\n-  diagnostic(intx, G1SummarizeRSetStatsPeriod, 0,                           \\\n+  product(intx, G1SummarizeRSetStatsPeriod, 0, DIAGNOSTIC,                  \\\n@@ -82,1 +76,1 @@\n-  experimental(bool, G1UseReferencePrecleaning, true,                       \\\n+  product(bool, G1UseReferencePrecleaning, true, EXPERIMENTAL,              \\\n@@ -86,1 +80,1 @@\n-  experimental(double, G1LastPLABAverageOccupancy, 50.0,                    \\\n+  product(double, G1LastPLABAverageOccupancy, 50.0, EXPERIMENTAL,           \\\n@@ -107,1 +101,1 @@\n-  experimental(intx, G1ExpandByPercentOfAvailable, 20,                      \\\n+  product(intx, G1ExpandByPercentOfAvailable, 20, EXPERIMENTAL,             \\\n@@ -215,1 +209,1 @@\n-  experimental(uintx, G1MaxNewSizePercent, 60,                              \\\n+  product(uintx, G1MaxNewSizePercent, 60, EXPERIMENTAL,                     \\\n@@ -221,1 +215,1 @@\n-  experimental(uintx, G1NewSizePercent, 5,                                  \\\n+  product(uintx, G1NewSizePercent, 5, EXPERIMENTAL,                         \\\n@@ -227,1 +221,1 @@\n-  experimental(uintx, G1MixedGCLiveThresholdPercent, 85,                    \\\n+  product(uintx, G1MixedGCLiveThresholdPercent, 85, EXPERIMENTAL,           \\\n@@ -242,1 +236,1 @@\n-  experimental(bool, G1EagerReclaimHumongousObjects, true,                  \\\n+  product(bool, G1EagerReclaimHumongousObjects, true, EXPERIMENTAL,         \\\n@@ -245,1 +239,1 @@\n-  experimental(bool, G1EagerReclaimHumongousObjectsWithStaleRefs, true,     \\\n+  product(bool, G1EagerReclaimHumongousObjectsWithStaleRefs, true, EXPERIMENTAL, \\\n@@ -249,1 +243,1 @@\n-  experimental(size_t, G1RebuildRemSetChunkSize, 256 * K,                   \\\n+  product(size_t, G1RebuildRemSetChunkSize, 256 * K, EXPERIMENTAL,          \\\n@@ -253,1 +247,1 @@\n-  experimental(uintx, G1OldCSetRegionThresholdPercent, 10,                  \\\n+  product(uintx, G1OldCSetRegionThresholdPercent, 10, EXPERIMENTAL,         \\\n@@ -286,1 +280,1 @@\n-  diagnostic(bool, G1VerifyRSetsDuringFullGC, false,                        \\\n+  product(bool, G1VerifyRSetsDuringFullGC, false, DIAGNOSTIC,               \\\n@@ -290,1 +284,1 @@\n-  diagnostic(bool, G1VerifyHeapRegionCodeRoots, false,                      \\\n+  product(bool, G1VerifyHeapRegionCodeRoots, false, DIAGNOSTIC,             \\\n@@ -296,1 +290,1 @@\n-  manageable(uintx, G1PeriodicGCInterval, 0,                                \\\n+  product(uintx, G1PeriodicGCInterval, 0, MANAGEABLE,                       \\\n@@ -306,1 +300,1 @@\n-  manageable(double, G1PeriodicGCSystemLoadThreshold, 0.0,                  \\\n+  product(double, G1PeriodicGCSystemLoadThreshold, 0.0, MANAGEABLE,         \\\n@@ -313,1 +307,1 @@\n-  experimental(uintx, G1YoungExpansionBufferPercent, 10,                    \\\n+  product(uintx, G1YoungExpansionBufferPercent, 10, EXPERIMENTAL,           \\\n@@ -320,1 +314,1 @@\n-               range(0, 100)                                                \\\n+               range(0, 100)\n@@ -322,0 +316,1 @@\n+\/\/ end of GC_G1_FLAGS\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":19,"deletions":24,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,6 +31,13 @@\n-\/\/ G1 Flag Constraints\n-JVMFlag::Error G1RSetRegionEntriesConstraintFunc(intx value, bool verbose);\n-JVMFlag::Error G1RSetSparseRegionEntriesConstraintFunc(intx value, bool verbose);\n-JVMFlag::Error G1HeapRegionSizeConstraintFunc(size_t value, bool verbose);\n-JVMFlag::Error G1NewSizePercentConstraintFunc(uintx value, bool verbose);\n-JVMFlag::Error G1MaxNewSizePercentConstraintFunc(uintx value, bool verbose);\n+#define G1_GC_CONSTRAINTS(f)                          \\\n+                                                      \\\n+  \/* G1 Flag Constraints *\/                           \\\n+  f(intx,   G1RSetRegionEntriesConstraintFunc)        \\\n+  f(intx,   G1RSetSparseRegionEntriesConstraintFunc)  \\\n+  f(size_t, G1HeapRegionSizeConstraintFunc)           \\\n+  f(uintx,  G1NewSizePercentConstraintFunc)           \\\n+  f(uintx,  G1MaxNewSizePercentConstraintFunc)        \\\n+                                                      \\\n+  \/* G1 Subconstraints *\/                             \\\n+  f(uintx,  MaxGCPauseMillisConstraintFuncG1)         \\\n+  f(uintx,  GCPauseIntervalMillisConstraintFuncG1)    \\\n+  f(size_t, NewSizeConstraintFuncG1)\n@@ -38,5 +45,1 @@\n-\/\/ G1 Subconstraints\n-JVMFlag::Error MaxGCPauseMillisConstraintFuncG1(uintx value, bool verbose);\n-JVMFlag::Error GCPauseIntervalMillisConstraintFuncG1(uintx value, bool verbose);\n-JVMFlag::Error MaxSizeForHeapAlignmentG1(const char* name, size_t value, bool verbose);\n-JVMFlag::Error NewSizeConstraintFuncG1(size_t value, bool verbose);\n+G1_GC_CONSTRAINTS(DECLARE_CONSTRAINT)\n","filename":"src\/hotspot\/share\/gc\/g1\/jvmFlagConstraintsG1.hpp","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,3 +32,6 @@\n-JVMFlag::Error ParallelGCThreadsConstraintFuncParallel(uint value, bool verbose);\n-JVMFlag::Error InitialTenuringThresholdConstraintFuncParallel(uintx value, bool verbose);\n-JVMFlag::Error MaxTenuringThresholdConstraintFuncParallel(uintx value, bool verbose);\n+#define PARALLEL_GC_CONSTRAINTS(f)                          \\\n+  f(uint, ParallelGCThreadsConstraintFuncParallel)          \\\n+  f(uintx, InitialTenuringThresholdConstraintFuncParallel)  \\\n+  f(uintx, MaxTenuringThresholdConstraintFuncParallel)\n+\n+PARALLEL_GC_CONSTRAINTS(DECLARE_CONSTRAINT)\n","filename":"src\/hotspot\/share\/gc\/parallel\/jvmFlagConstraintsParallel.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -32,3 +32,0 @@\n-                          diagnostic,                                       \\\n-                          diagnostic_pd,                                    \\\n-                          experimental,                                     \\\n@@ -36,3 +33,0 @@\n-                          manageable,                                       \\\n-                          product_rw,                                       \\\n-                          lp64_product,                                     \\\n@@ -70,0 +64,2 @@\n+\/\/ end of GC_PARALLEL_FLAGS\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallel_globals.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,12 +28,6 @@\n-#define GC_SERIAL_FLAGS(develop,                                            \\\n-                        develop_pd,                                         \\\n-                        product,                                            \\\n-                        product_pd,                                         \\\n-                        diagnostic,                                         \\\n-                        diagnostic_pd,                                      \\\n-                        experimental,                                       \\\n-                        notproduct,                                         \\\n-                        manageable,                                         \\\n-                        product_rw,                                         \\\n-                        lp64_product,                                       \\\n-                        range,                                              \\\n+#define GC_SERIAL_FLAGS(develop,     \\\n+                        develop_pd,  \\\n+                        product,     \\\n+                        product_pd,  \\\n+                        notproduct,  \\\n+                        range,       \\\n@@ -42,0 +36,2 @@\n+\/\/ end of GC_SERIAL_FLAGS\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/serial_globals.hpp","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -53,3 +53,0 @@\n-                 diagnostic,                                                \\\n-                 diagnostic_pd,                                             \\\n-                 experimental,                                              \\\n@@ -57,3 +54,0 @@\n-                 manageable,                                                \\\n-                 product_rw,                                                \\\n-                 lp64_product,                                              \\\n@@ -68,3 +62,0 @@\n-    diagnostic,                                                             \\\n-    diagnostic_pd,                                                          \\\n-    experimental,                                                           \\\n@@ -72,3 +63,0 @@\n-    manageable,                                                             \\\n-    product_rw,                                                             \\\n-    lp64_product,                                                           \\\n@@ -83,3 +71,0 @@\n-    diagnostic,                                                             \\\n-    diagnostic_pd,                                                          \\\n-    experimental,                                                           \\\n@@ -87,3 +72,0 @@\n-    manageable,                                                             \\\n-    product_rw,                                                             \\\n-    lp64_product,                                                           \\\n@@ -98,3 +80,0 @@\n-    diagnostic,                                                             \\\n-    diagnostic_pd,                                                          \\\n-    experimental,                                                           \\\n@@ -102,3 +81,0 @@\n-    manageable,                                                             \\\n-    product_rw,                                                             \\\n-    lp64_product,                                                           \\\n@@ -113,3 +89,0 @@\n-    diagnostic,                                                             \\\n-    diagnostic_pd,                                                          \\\n-    experimental,                                                           \\\n@@ -117,3 +90,0 @@\n-    manageable,                                                             \\\n-    product_rw,                                                             \\\n-    lp64_product,                                                           \\\n@@ -128,3 +98,0 @@\n-    diagnostic,                                                             \\\n-    diagnostic_pd,                                                          \\\n-    experimental,                                                           \\\n@@ -132,3 +99,0 @@\n-    manageable,                                                             \\\n-    product_rw,                                                             \\\n-    lp64_product,                                                           \\\n@@ -143,3 +107,0 @@\n-    diagnostic,                                                             \\\n-    diagnostic_pd,                                                          \\\n-    experimental,                                                           \\\n@@ -147,3 +108,0 @@\n-    manageable,                                                             \\\n-    product_rw,                                                             \\\n-    lp64_product,                                                           \\\n@@ -164,1 +122,1 @@\n-  experimental(bool, UseEpsilonGC, false,                                   \\\n+  product(bool, UseEpsilonGC, false, EXPERIMENTAL,                          \\\n@@ -182,1 +140,1 @@\n-  diagnostic(bool, InjectGCWorkerCreationFailure, false,                    \\\n+  product(bool, InjectGCWorkerCreationFailure, false, DIAGNOSTIC,           \\\n@@ -189,1 +147,1 @@\n-          range((size_t)os::vm_page_size(), (size_t)max_uintx)              \\\n+          constraint(VMPageSizeConstraintFunc, AtParse)                     \\\n@@ -214,1 +172,1 @@\n-  diagnostic(uintx, GCLockerRetryAllocationCount, 2,                        \\\n+  product(uintx, GCLockerRetryAllocationCount, 2, DIAGNOSTIC,               \\\n@@ -271,1 +229,1 @@\n-  experimental(size_t, ReferencesPerThread, 1000,                           \\\n+  product(size_t, ReferencesPerThread, 1000, EXPERIMENTAL,                  \\\n@@ -311,1 +269,1 @@\n-  experimental(uintx, WorkStealingSleepMillis, 1,                           \\\n+  product(uintx, WorkStealingSleepMillis, 1, EXPERIMENTAL,                  \\\n@@ -314,1 +272,1 @@\n-  experimental(uintx, WorkStealingYieldsBeforeSleep, 5000,                  \\\n+  product(uintx, WorkStealingYieldsBeforeSleep, 5000, EXPERIMENTAL,         \\\n@@ -317,1 +275,1 @@\n-  experimental(uintx, WorkStealingHardSpins, 4096,                          \\\n+  product(uintx, WorkStealingHardSpins, 4096, EXPERIMENTAL,                 \\\n@@ -321,1 +279,1 @@\n-  experimental(uintx, WorkStealingSpinToYieldRatio, 10,                     \\\n+  product(uintx, WorkStealingSpinToYieldRatio, 10, EXPERIMENTAL,            \\\n@@ -566,1 +524,1 @@\n-  diagnostic(bool, VerifyDuringStartup, false,                              \\\n+  product(bool, VerifyDuringStartup, false, DIAGNOSTIC,                     \\\n@@ -570,1 +528,1 @@\n-  diagnostic(bool, VerifyBeforeExit, trueInDebug,                           \\\n+  product(bool, VerifyBeforeExit, trueInDebug, DIAGNOSTIC,                  \\\n@@ -573,1 +531,1 @@\n-  diagnostic(bool, VerifyBeforeGC, false,                                   \\\n+  product(bool, VerifyBeforeGC, false, DIAGNOSTIC,                          \\\n@@ -576,1 +534,1 @@\n-  diagnostic(bool, VerifyAfterGC, false,                                    \\\n+  product(bool, VerifyAfterGC, false, DIAGNOSTIC,                           \\\n@@ -579,1 +537,1 @@\n-  diagnostic(bool, VerifyDuringGC, false,                                   \\\n+  product(bool, VerifyDuringGC, false, DIAGNOSTIC,                          \\\n@@ -582,1 +540,1 @@\n-  diagnostic(ccstrlist, VerifyGCType, \"\",                                   \\\n+  product(ccstrlist, VerifyGCType, \"\", DIAGNOSTIC,                          \\\n@@ -586,1 +544,1 @@\n-  diagnostic(ccstrlist, VerifySubSet, \"\",                                   \\\n+  product(ccstrlist, VerifySubSet, \"\", DIAGNOSTIC,                          \\\n@@ -594,1 +552,1 @@\n-  diagnostic(bool, GCParallelVerificationEnabled, true,                     \\\n+  product(bool, GCParallelVerificationEnabled, true, DIAGNOSTIC,            \\\n@@ -597,1 +555,1 @@\n-  diagnostic(bool, DeferInitialCardMark, false,                             \\\n+  product(bool, DeferInitialCardMark, false, DIAGNOSTIC,                    \\\n@@ -604,1 +562,1 @@\n-  diagnostic(bool, VerifyRememberedSets, false,                             \\\n+  product(bool, VerifyRememberedSets, false, DIAGNOSTIC,                    \\\n@@ -607,1 +565,1 @@\n-  diagnostic(bool, VerifyObjectStartArray, true,                            \\\n+  product(bool, VerifyObjectStartArray, true, DIAGNOSTIC,                   \\\n@@ -652,1 +610,1 @@\n-  manageable(size_t, SoftMaxHeapSize, 0,                                    \\\n+  product(size_t, SoftMaxHeapSize, 0, MANAGEABLE,                           \\\n@@ -733,1 +691,1 @@\n-  diagnostic(uintx, VerifyGCStartAt,   0,                                   \\\n+  product(uintx, VerifyGCStartAt,   0, DIAGNOSTIC,                          \\\n@@ -737,1 +695,1 @@\n-  diagnostic(intx, VerifyGCLevel,     0,                                    \\\n+  product(intx, VerifyGCLevel,     0, DIAGNOSTIC,                           \\\n@@ -778,0 +736,2 @@\n+\/\/ end of GC_FLAGS\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":25,"deletions":65,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,30 @@\n+#define SHARED_GC_CONSTRAINTS(f)                               \\\n+ f(uint,   ParallelGCThreadsConstraintFunc)                    \\\n+ f(uint,   ConcGCThreadsConstraintFunc)                        \\\n+ f(size_t, YoungPLABSizeConstraintFunc)                        \\\n+ f(size_t, OldPLABSizeConstraintFunc)                          \\\n+ f(uintx,  MinHeapFreeRatioConstraintFunc)                     \\\n+ f(uintx,  MaxHeapFreeRatioConstraintFunc)                     \\\n+ f(intx,   SoftRefLRUPolicyMSPerMBConstraintFunc)              \\\n+ f(size_t, MarkStackSizeConstraintFunc)                        \\\n+ f(uintx,  MinMetaspaceFreeRatioConstraintFunc)                \\\n+ f(uintx,  MaxMetaspaceFreeRatioConstraintFunc)                \\\n+ f(uintx,  InitialTenuringThresholdConstraintFunc)             \\\n+ f(uintx,  MaxTenuringThresholdConstraintFunc)                 \\\n+                                                               \\\n+ f(uintx,  MaxGCPauseMillisConstraintFunc)                     \\\n+ f(uintx,  GCPauseIntervalMillisConstraintFunc)                \\\n+ f(size_t, InitialBootClassLoaderMetaspaceSizeConstraintFunc)  \\\n+ f(size_t, MinHeapSizeConstraintFunc)                          \\\n+ f(size_t, InitialHeapSizeConstraintFunc)                      \\\n+ f(size_t, MaxHeapSizeConstraintFunc)                          \\\n+ f(size_t, SoftMaxHeapSizeConstraintFunc)                      \\\n+ f(size_t, HeapBaseMinAddressConstraintFunc)                   \\\n+ f(size_t, NewSizeConstraintFunc)                              \\\n+ f(size_t, MinTLABSizeConstraintFunc)                          \\\n+ f(size_t, TLABSizeConstraintFunc)                             \\\n+ f(uintx,  TLABWasteIncrementConstraintFunc)                   \\\n+ f(uintx,  SurvivorRatioConstraintFunc)                        \\\n+ f(size_t, MetaspaceSizeConstraintFunc)                        \\\n+ f(size_t, MaxMetaspaceSizeConstraintFunc)                     \\\n+ f(intx,   SurvivorAlignmentInBytesConstraintFunc)\n@@ -44,12 +74,1 @@\n-JVMFlag::Error ParallelGCThreadsConstraintFunc(uint value, bool verbose);\n-JVMFlag::Error ConcGCThreadsConstraintFunc(uint value, bool verbose);\n-JVMFlag::Error YoungPLABSizeConstraintFunc(size_t value, bool verbose);\n-JVMFlag::Error OldPLABSizeConstraintFunc(size_t value, bool verbose);\n-JVMFlag::Error MinHeapFreeRatioConstraintFunc(uintx value, bool verbose);\n-JVMFlag::Error MaxHeapFreeRatioConstraintFunc(uintx value, bool verbose);\n-JVMFlag::Error SoftRefLRUPolicyMSPerMBConstraintFunc(intx value, bool verbose);\n-JVMFlag::Error MarkStackSizeConstraintFunc(size_t value, bool verbose);\n-JVMFlag::Error MinMetaspaceFreeRatioConstraintFunc(uintx value, bool verbose);\n-JVMFlag::Error MaxMetaspaceFreeRatioConstraintFunc(uintx value, bool verbose);\n-JVMFlag::Error InitialTenuringThresholdConstraintFunc(uintx value, bool verbose);\n-JVMFlag::Error MaxTenuringThresholdConstraintFunc(uintx value, bool verbose);\n+SHARED_GC_CONSTRAINTS(DECLARE_CONSTRAINT)\n@@ -57,18 +76,0 @@\n-JVMFlag::Error MaxGCPauseMillisConstraintFunc(uintx value, bool verbose);\n-JVMFlag::Error GCPauseIntervalMillisConstraintFunc(uintx value, bool verbose);\n-JVMFlag::Error InitialBootClassLoaderMetaspaceSizeConstraintFunc(size_t value, bool verbose);\n-JVMFlag::Error MinHeapSizeConstraintFunc(size_t value, bool verbose);\n-JVMFlag::Error InitialHeapSizeConstraintFunc(size_t value, bool verbose);\n-JVMFlag::Error MaxHeapSizeConstraintFunc(size_t value, bool verbose);\n-JVMFlag::Error SoftMaxHeapSizeConstraintFunc(size_t value, bool verbose);\n-JVMFlag::Error HeapBaseMinAddressConstraintFunc(size_t value, bool verbose);\n-JVMFlag::Error NewSizeConstraintFunc(size_t value, bool verbose);\n-JVMFlag::Error MinTLABSizeConstraintFunc(size_t value, bool verbose);\n-JVMFlag::Error TLABSizeConstraintFunc(size_t value, bool verbose);\n-JVMFlag::Error TLABWasteIncrementConstraintFunc(uintx value, bool verbose);\n-JVMFlag::Error SurvivorRatioConstraintFunc(uintx value, bool verbose);\n-JVMFlag::Error MetaspaceSizeConstraintFunc(size_t value, bool verbose);\n-JVMFlag::Error MaxMetaspaceSizeConstraintFunc(size_t value, bool verbose);\n-JVMFlag::Error SurvivorAlignmentInBytesConstraintFunc(intx value, bool verbose);\n-\n-\/\/ Internal\n@@ -77,0 +78,5 @@\n+#define GC_CONSTRAINTS(f)                      \\\n+  SHARED_GC_CONSTRAINTS(f)                     \\\n+  G1GC_ONLY(G1_GC_CONSTRAINTS(f))              \\\n+  PARALLELGC_ONLY(PARALLEL_GC_CONSTRAINTS(f))\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.hpp","additions":37,"deletions":31,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -33,3 +33,0 @@\n-                            diagnostic,                                     \\\n-                            diagnostic_pd,                                  \\\n-                            experimental,                                   \\\n@@ -37,3 +34,0 @@\n-                            manageable,                                     \\\n-                            product_rw,                                     \\\n-                            lp64_product,                                   \\\n@@ -43,1 +37,1 @@\n-  experimental(size_t, ShenandoahRegionSize, 0,                             \\\n+  product(size_t, ShenandoahRegionSize, 0, EXPERIMENTAL,                    \\\n@@ -46,1 +40,1 @@\n-  experimental(size_t, ShenandoahTargetNumRegions, 2048,                    \\\n+  product(size_t, ShenandoahTargetNumRegions, 2048, EXPERIMENTAL,           \\\n@@ -51,1 +45,1 @@\n-  experimental(size_t, ShenandoahMinRegionSize, 256 * K,                    \\\n+  product(size_t, ShenandoahMinRegionSize, 256 * K, EXPERIMENTAL,           \\\n@@ -55,1 +49,1 @@\n-  experimental(size_t, ShenandoahMaxRegionSize, 32 * M,                     \\\n+  product(size_t, ShenandoahMaxRegionSize, 32 * M, EXPERIMENTAL,            \\\n@@ -59,1 +53,1 @@\n-  experimental(intx, ShenandoahHumongousThreshold, 100,                     \\\n+  product(intx, ShenandoahHumongousThreshold, 100, EXPERIMENTAL,            \\\n@@ -85,1 +79,1 @@\n-  experimental(uintx, ShenandoahRefProcFrequency, 5,                        \\\n+  product(uintx, ShenandoahRefProcFrequency, 5, EXPERIMENTAL,               \\\n@@ -92,1 +86,1 @@\n-  experimental(uintx, ShenandoahUnloadClassesFrequency, 1,                  \\\n+  product(uintx, ShenandoahUnloadClassesFrequency, 1, EXPERIMENTAL,         \\\n@@ -97,1 +91,1 @@\n-  experimental(uintx, ShenandoahGarbageThreshold, 25,                       \\\n+  product(uintx, ShenandoahGarbageThreshold, 25, EXPERIMENTAL,              \\\n@@ -105,1 +99,1 @@\n-  experimental(uintx, ShenandoahInitFreeThreshold, 70,                      \\\n+  product(uintx, ShenandoahInitFreeThreshold, 70, EXPERIMENTAL,             \\\n@@ -112,1 +106,1 @@\n-  experimental(uintx, ShenandoahMinFreeThreshold, 10,                       \\\n+  product(uintx, ShenandoahMinFreeThreshold, 10, EXPERIMENTAL,              \\\n@@ -118,1 +112,1 @@\n-  experimental(uintx, ShenandoahAllocationThreshold, 0,                     \\\n+  product(uintx, ShenandoahAllocationThreshold, 0, EXPERIMENTAL,            \\\n@@ -124,1 +118,1 @@\n-  experimental(uintx, ShenandoahAllocSpikeFactor, 5,                        \\\n+  product(uintx, ShenandoahAllocSpikeFactor, 5, EXPERIMENTAL,               \\\n@@ -131,1 +125,1 @@\n-  experimental(uintx, ShenandoahLearningSteps, 5,                           \\\n+  product(uintx, ShenandoahLearningSteps, 5, EXPERIMENTAL,                  \\\n@@ -136,1 +130,1 @@\n-  experimental(uintx, ShenandoahImmediateThreshold, 90,                     \\\n+  product(uintx, ShenandoahImmediateThreshold, 90, EXPERIMENTAL,            \\\n@@ -143,1 +137,1 @@\n-  experimental(uintx, ShenandoahGuaranteedGCInterval, 5*60*1000,            \\\n+  product(uintx, ShenandoahGuaranteedGCInterval, 5*60*1000, EXPERIMENTAL,   \\\n@@ -150,1 +144,1 @@\n-  experimental(bool, ShenandoahAlwaysClearSoftRefs, false,                  \\\n+  product(bool, ShenandoahAlwaysClearSoftRefs, false, EXPERIMENTAL,         \\\n@@ -155,1 +149,1 @@\n-  experimental(bool, ShenandoahUncommit, true,                              \\\n+  product(bool, ShenandoahUncommit, true, EXPERIMENTAL,                     \\\n@@ -161,1 +155,1 @@\n-  experimental(uintx, ShenandoahUncommitDelay, 5*60*1000,                   \\\n+  product(uintx, ShenandoahUncommitDelay, 5*60*1000, EXPERIMENTAL,          \\\n@@ -169,1 +163,1 @@\n-  experimental(bool, ShenandoahRegionSampling, false,                       \\\n+  product(bool, ShenandoahRegionSampling, false, EXPERIMENTAL,              \\\n@@ -172,1 +166,1 @@\n-  experimental(int, ShenandoahRegionSamplingRate, 40,                       \\\n+  product(int, ShenandoahRegionSamplingRate, 40, EXPERIMENTAL,              \\\n@@ -177,1 +171,1 @@\n-  experimental(uintx, ShenandoahControlIntervalMin, 1,                      \\\n+  product(uintx, ShenandoahControlIntervalMin, 1, EXPERIMENTAL,             \\\n@@ -183,1 +177,1 @@\n-  experimental(uintx, ShenandoahControlIntervalMax, 10,                     \\\n+  product(uintx, ShenandoahControlIntervalMax, 10, EXPERIMENTAL,            \\\n@@ -189,1 +183,1 @@\n-  experimental(uintx, ShenandoahControlIntervalAdjustPeriod, 1000,          \\\n+  product(uintx, ShenandoahControlIntervalAdjustPeriod, 1000, EXPERIMENTAL, \\\n@@ -194,1 +188,1 @@\n-  diagnostic(bool, ShenandoahVerify, false,                                 \\\n+  product(bool, ShenandoahVerify, false, DIAGNOSTIC,                        \\\n@@ -199,1 +193,1 @@\n-  diagnostic(intx, ShenandoahVerifyLevel, 4,                                \\\n+  product(intx, ShenandoahVerifyLevel, 4, DIAGNOSTIC,                       \\\n@@ -208,1 +202,1 @@\n-  diagnostic(bool, ShenandoahElasticTLAB, true,                             \\\n+  product(bool, ShenandoahElasticTLAB, true, DIAGNOSTIC,                    \\\n@@ -211,1 +205,1 @@\n-  experimental(uintx, ShenandoahEvacReserve, 5,                             \\\n+  product(uintx, ShenandoahEvacReserve, 5, EXPERIMENTAL,                    \\\n@@ -218,1 +212,1 @@\n-  experimental(double, ShenandoahEvacWaste, 1.2,                            \\\n+  product(double, ShenandoahEvacWaste, 1.2, EXPERIMENTAL,                   \\\n@@ -225,1 +219,1 @@\n-  experimental(bool, ShenandoahEvacReserveOverflow, true,                   \\\n+  product(bool, ShenandoahEvacReserveOverflow, true, EXPERIMENTAL,          \\\n@@ -231,1 +225,1 @@\n-  experimental(bool, ShenandoahPacing, true,                                \\\n+  product(bool, ShenandoahPacing, true, EXPERIMENTAL,                       \\\n@@ -235,1 +229,1 @@\n-  experimental(uintx, ShenandoahPacingMaxDelay, 10,                         \\\n+  product(uintx, ShenandoahPacingMaxDelay, 10, EXPERIMENTAL,                \\\n@@ -243,1 +237,1 @@\n-  experimental(uintx, ShenandoahPacingIdleSlack, 2,                         \\\n+  product(uintx, ShenandoahPacingIdleSlack, 2, EXPERIMENTAL,                \\\n@@ -251,1 +245,1 @@\n-  experimental(uintx, ShenandoahPacingCycleSlack, 10,                       \\\n+  product(uintx, ShenandoahPacingCycleSlack, 10, EXPERIMENTAL,              \\\n@@ -258,1 +252,1 @@\n-  experimental(double, ShenandoahPacingSurcharge, 1.1,                      \\\n+  product(double, ShenandoahPacingSurcharge, 1.1, EXPERIMENTAL,             \\\n@@ -265,1 +259,1 @@\n-  experimental(uintx, ShenandoahCriticalFreeThreshold, 1,                   \\\n+  product(uintx, ShenandoahCriticalFreeThreshold, 1, EXPERIMENTAL,          \\\n@@ -272,1 +266,1 @@\n-  diagnostic(bool, ShenandoahDegeneratedGC, true,                           \\\n+  product(bool, ShenandoahDegeneratedGC, true, DIAGNOSTIC,                  \\\n@@ -278,1 +272,1 @@\n-  experimental(uintx, ShenandoahFullGCThreshold, 3,                         \\\n+  product(uintx, ShenandoahFullGCThreshold, 3, EXPERIMENTAL,                \\\n@@ -282,1 +276,1 @@\n-  experimental(bool, ShenandoahImplicitGCInvokesConcurrent, false,          \\\n+  product(bool, ShenandoahImplicitGCInvokesConcurrent, false, EXPERIMENTAL, \\\n@@ -288,1 +282,1 @@\n-  diagnostic(bool, ShenandoahHumongousMoves, true,                          \\\n+  product(bool, ShenandoahHumongousMoves, true, DIAGNOSTIC,                 \\\n@@ -294,1 +288,1 @@\n-  diagnostic(bool, ShenandoahOOMDuringEvacALot, false,                      \\\n+  product(bool, ShenandoahOOMDuringEvacALot, false, DIAGNOSTIC,             \\\n@@ -297,1 +291,1 @@\n-  diagnostic(bool, ShenandoahAllocFailureALot, false,                       \\\n+  product(bool, ShenandoahAllocFailureALot, false, DIAGNOSTIC,              \\\n@@ -300,1 +294,1 @@\n-  experimental(intx, ShenandoahMarkScanPrefetch, 32,                        \\\n+  product(intx, ShenandoahMarkScanPrefetch, 32, EXPERIMENTAL,               \\\n@@ -305,1 +299,1 @@\n-  experimental(uintx, ShenandoahMarkLoopStride, 1000,                       \\\n+  product(uintx, ShenandoahMarkLoopStride, 1000, EXPERIMENTAL,              \\\n@@ -310,1 +304,1 @@\n-  experimental(uintx, ShenandoahParallelRegionStride, 1024,                 \\\n+  product(uintx, ShenandoahParallelRegionStride, 1024, EXPERIMENTAL,        \\\n@@ -314,1 +308,1 @@\n-  experimental(size_t, ShenandoahSATBBufferSize, 1 * K,                     \\\n+  product(size_t, ShenandoahSATBBufferSize, 1 * K, EXPERIMENTAL,            \\\n@@ -318,1 +312,1 @@\n-  experimental(uintx, ShenandoahSATBBufferFlushInterval, 100,               \\\n+  product(uintx, ShenandoahSATBBufferFlushInterval, 100, EXPERIMENTAL,      \\\n@@ -322,1 +316,1 @@\n-  diagnostic(bool, ShenandoahPreclean, true,                                \\\n+  product(bool, ShenandoahPreclean, true, DIAGNOSTIC,                       \\\n@@ -327,1 +321,1 @@\n-  experimental(bool, ShenandoahSuspendibleWorkers, false,                   \\\n+  product(bool, ShenandoahSuspendibleWorkers, false, EXPERIMENTAL,          \\\n@@ -330,1 +324,1 @@\n-  diagnostic(bool, ShenandoahSATBBarrier, true,                             \\\n+  product(bool, ShenandoahSATBBarrier, true, DIAGNOSTIC,                    \\\n@@ -333,1 +327,1 @@\n-  diagnostic(bool, ShenandoahStoreValEnqueueBarrier, false,                 \\\n+  product(bool, ShenandoahStoreValEnqueueBarrier, false, DIAGNOSTIC,        \\\n@@ -336,1 +330,1 @@\n-  diagnostic(bool, ShenandoahCASBarrier, true,                              \\\n+  product(bool, ShenandoahCASBarrier, true, DIAGNOSTIC,                     \\\n@@ -339,1 +333,1 @@\n-  diagnostic(bool, ShenandoahCloneBarrier, true,                            \\\n+  product(bool, ShenandoahCloneBarrier, true, DIAGNOSTIC,                   \\\n@@ -342,1 +336,1 @@\n-  diagnostic(bool, ShenandoahLoadRefBarrier, true,                          \\\n+  product(bool, ShenandoahLoadRefBarrier, true, DIAGNOSTIC,                 \\\n@@ -345,1 +339,1 @@\n-  diagnostic(uintx, ShenandoahCodeRootsStyle, 2,                            \\\n+  product(uintx, ShenandoahCodeRootsStyle, 2, DIAGNOSTIC,                   \\\n@@ -354,1 +348,1 @@\n-  diagnostic(bool, ShenandoahLoopOptsAfterExpansion, true,                  \\\n+  product(bool, ShenandoahLoopOptsAfterExpansion, true, DIAGNOSTIC,         \\\n@@ -357,1 +351,1 @@\n-  diagnostic(bool, ShenandoahSelfFixing, true,                              \\\n+  product(bool, ShenandoahSelfFixing, true, DIAGNOSTIC,                     \\\n@@ -359,1 +353,1 @@\n-          \"might degrade performance.\")                                     \\\n+          \"might degrade performance.\")\n@@ -361,0 +355,1 @@\n+\/\/ end of GC_SHENANDOAH_FLAGS\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":58,"deletions":63,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -31,3 +31,0 @@\n-                   diagnostic,                                              \\\n-                   diagnostic_pd,                                           \\\n-                   experimental,                                            \\\n@@ -35,3 +32,0 @@\n-                   manageable,                                              \\\n-                   product_rw,                                              \\\n-                   lp64_product,                                            \\\n@@ -64,1 +58,1 @@\n-  diagnostic(uint, ZStatisticsInterval, 10,                                 \\\n+  product(uint, ZStatisticsInterval, 10, DIAGNOSTIC,                        \\\n@@ -68,1 +62,1 @@\n-  diagnostic(bool, ZVerifyViews, false,                                     \\\n+  product(bool, ZVerifyViews, false, DIAGNOSTIC,                            \\\n@@ -71,1 +65,1 @@\n-  diagnostic(bool, ZVerifyRoots, trueInDebug,                               \\\n+  product(bool, ZVerifyRoots, trueInDebug, DIAGNOSTIC,                      \\\n@@ -74,1 +68,1 @@\n-  diagnostic(bool, ZVerifyObjects, false,                                   \\\n+  product(bool, ZVerifyObjects, false, DIAGNOSTIC,                          \\\n@@ -77,1 +71,1 @@\n-  diagnostic(bool, ZVerifyMarking, trueInDebug,                             \\\n+  product(bool, ZVerifyMarking, trueInDebug, DIAGNOSTIC,                    \\\n@@ -80,1 +74,1 @@\n-  diagnostic(bool, ZVerifyForwarding, false,                                \\\n+  product(bool, ZVerifyForwarding, false, DIAGNOSTIC,                       \\\n@@ -83,0 +77,2 @@\n+\/\/ end of GC_Z_FLAGS\n+\n","filename":"src\/hotspot\/share\/gc\/z\/z_globals.hpp","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -41,3 +41,3 @@\n-  JVMCI_FLAGS(params4, params3, params4, params3, params4, params3, params4, params4, IGNORE_RANGE, IGNORE_CONSTRAINT)\n-#define JVMCI_DECLARE_CHECK4(type, name, value, doc) bool name##checked = false;\n-#define JVMCI_DECLARE_CHECK3(type, name, doc)        bool name##checked = false;\n+  JVMCI_FLAGS(params4, params3, params4, params3, params4, IGNORE_RANGE, IGNORE_CONSTRAINT)\n+#define JVMCI_DECLARE_CHECK4(type, name, value, ...) bool name##checked = false;\n+#define JVMCI_DECLARE_CHECK3(type, name, ...)        bool name##checked = false;\n@@ -134,2 +134,2 @@\n-#define JVMCI_CHECK4(type, name, value, doc) assert(name##checked, #name \" flag not checked\");\n-#define JVMCI_CHECK3(type, name, doc)        assert(name##checked, #name \" flag not checked\");\n+#define JVMCI_CHECK4(type, name, value, ...) assert(name##checked, #name \" flag not checked\");\n+#define JVMCI_CHECK3(type, name, ...)        assert(name##checked, #name \" flag not checked\");\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/ Defines all global flags used by the JVMCI compiler. Only flags that need\n+\/\/ Declare all global flags used by the JVMCI compiler. Only flags that need\n@@ -36,12 +36,9 @@\n-#define JVMCI_FLAGS(develop, \\\n-                    develop_pd, \\\n-                    product, \\\n-                    product_pd, \\\n-                    diagnostic, \\\n-                    diagnostic_pd, \\\n-                    experimental, \\\n-                    notproduct, \\\n-                    range, \\\n-                    constraint) \\\n-                                                                            \\\n-  experimental(bool, EnableJVMCI, false,                                    \\\n+#define JVMCI_FLAGS(develop,                                                \\\n+                    develop_pd,                                             \\\n+                    product,                                                \\\n+                    product_pd,                                             \\\n+                    notproduct,                                             \\\n+                    range,                                                  \\\n+                    constraint)                                             \\\n+                                                                            \\\n+  product(bool, EnableJVMCI, false, EXPERIMENTAL,                           \\\n@@ -50,1 +47,1 @@\n-  experimental(bool, EnableJVMCIProduct, false,                             \\\n+  product(bool, EnableJVMCIProduct, false, EXPERIMENTAL,                    \\\n@@ -56,1 +53,1 @@\n-  experimental(bool, UseJVMCICompiler, false,                               \\\n+  product(bool, UseJVMCICompiler, false, EXPERIMENTAL,                      \\\n@@ -60,1 +57,1 @@\n-  experimental(bool, JVMCIPrintProperties, false,                           \\\n+  product(bool, JVMCIPrintProperties, false, EXPERIMENTAL,                  \\\n@@ -63,1 +60,1 @@\n-  experimental(bool, BootstrapJVMCI, false,                                 \\\n+  product(bool, BootstrapJVMCI, false, EXPERIMENTAL,                        \\\n@@ -69,1 +66,1 @@\n-  experimental(bool, EagerJVMCI, false,                                     \\\n+  product(bool, EagerJVMCI, false, EXPERIMENTAL,                            \\\n@@ -72,1 +69,1 @@\n-  experimental(bool, PrintBootstrap, true,                                  \\\n+  product(bool, PrintBootstrap, true, EXPERIMENTAL,                         \\\n@@ -75,1 +72,1 @@\n-  experimental(intx, JVMCIThreads, 1,                                       \\\n+  product(intx, JVMCIThreads, 1, EXPERIMENTAL,                              \\\n@@ -80,1 +77,1 @@\n-  experimental(intx, JVMCIHostThreads, 1,                                   \\\n+  product(intx, JVMCIHostThreads, 1, EXPERIMENTAL,                          \\\n@@ -93,1 +90,1 @@\n-  experimental(intx, JVMCIEventLogLevel, 1,                                 \\\n+  product(intx, JVMCIEventLogLevel, 1, EXPERIMENTAL,                        \\\n@@ -97,1 +94,1 @@\n-  experimental(intx, JVMCITraceLevel, 0,                                    \\\n+  product(intx, JVMCITraceLevel, 0, EXPERIMENTAL,                           \\\n@@ -101,1 +98,1 @@\n-  experimental(intx, JVMCICounterSize, 0,                                   \\\n+  product(intx, JVMCICounterSize, 0, EXPERIMENTAL,                          \\\n@@ -105,1 +102,1 @@\n-  experimental(bool, JVMCICountersExcludeCompiler, true,                    \\\n+  product(bool, JVMCICountersExcludeCompiler, true, EXPERIMENTAL,           \\\n@@ -111,1 +108,1 @@\n-  experimental(intx, JVMCINMethodSizeLimit, (80*K)*wordSize,                \\\n+  product(intx, JVMCINMethodSizeLimit, (80*K)*wordSize, EXPERIMENTAL,       \\\n@@ -115,1 +112,1 @@\n-  experimental(ccstr, JVMCILibPath, NULL,                                   \\\n+  product(ccstr, JVMCILibPath, NULL, EXPERIMENTAL,                          \\\n@@ -118,1 +115,1 @@\n-  experimental(ccstr, JVMCILibDumpJNIConfig, NULL,                          \\\n+  product(ccstr, JVMCILibDumpJNIConfig, NULL, EXPERIMENTAL,                 \\\n@@ -122,1 +119,1 @@\n-  experimental(bool, UseJVMCINativeLibrary, false,                          \\\n+  product(bool, UseJVMCINativeLibrary, false, EXPERIMENTAL,                 \\\n@@ -128,1 +125,1 @@\n-  NOT_COMPILER2(diagnostic(bool, UseMultiplyToLenIntrinsic, false,          \\\n+  NOT_COMPILER2(product(bool, UseMultiplyToLenIntrinsic, false, DIAGNOSTIC, \\\n@@ -131,1 +128,1 @@\n-  NOT_COMPILER2(diagnostic(bool, UseSquareToLenIntrinsic, false,            \\\n+  NOT_COMPILER2(product(bool, UseSquareToLenIntrinsic, false, DIAGNOSTIC,   \\\n@@ -134,1 +131,1 @@\n-  NOT_COMPILER2(diagnostic(bool, UseMulAddIntrinsic, false,                 \\\n+  NOT_COMPILER2(product(bool, UseMulAddIntrinsic, false, DIAGNOSTIC,        \\\n@@ -137,1 +134,1 @@\n-  NOT_COMPILER2(diagnostic(bool, UseMontgomeryMultiplyIntrinsic, false,     \\\n+  NOT_COMPILER2(product(bool, UseMontgomeryMultiplyIntrinsic, false, DIAGNOSTIC, \\\n@@ -140,1 +137,1 @@\n-  NOT_COMPILER2(diagnostic(bool, UseMontgomerySquareIntrinsic, false,       \\\n+  NOT_COMPILER2(product(bool, UseMontgomerySquareIntrinsic, false, DIAGNOSTIC, \\\n@@ -143,0 +140,2 @@\n+\/\/ end of JVMCI_FLAGS\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.hpp","additions":33,"deletions":34,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -152,6 +152,0 @@\n-  nonstatic_field(JVMFlag,                     _type,                                         const char*)                           \\\n-  nonstatic_field(JVMFlag,                     _name,                                         const char*)                           \\\n-  unchecked_nonstatic_field(JVMFlag,           _addr,                                         sizeof(void*))                         \\\n-  nonstatic_field(JVMFlag,                     _flags,                                        JVMFlag::Flags)                        \\\n-  static_field(JVMFlag,                        flags,                                         JVMFlag*)                              \\\n-                                                                                                                                     \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,12 +38,9 @@\n-#define C2_FLAGS(develop, \\\n-                 develop_pd, \\\n-                 product, \\\n-                 product_pd, \\\n-                 diagnostic, \\\n-                 diagnostic_pd, \\\n-                 experimental, \\\n-                 notproduct, \\\n-                 range, \\\n-                 constraint) \\\n-                                                                            \\\n-  diagnostic(bool, StressLCM, false,                                        \\\n+#define C2_FLAGS(develop,                                                   \\\n+                 develop_pd,                                                \\\n+                 product,                                                   \\\n+                 product_pd,                                                \\\n+                 notproduct,                                                \\\n+                 range,                                                     \\\n+                 constraint)                                                \\\n+                                                                            \\\n+  product(bool, StressLCM, false, DIAGNOSTIC,                               \\\n@@ -52,1 +49,1 @@\n-  diagnostic(bool, StressGCM, false,                                        \\\n+  product(bool, StressGCM, false, DIAGNOSTIC,                               \\\n@@ -119,1 +116,1 @@\n-  diagnostic_pd(bool, IdealizeClearArrayNode,                               \\\n+  product_pd(bool, IdealizeClearArrayNode, DIAGNOSTIC,                      \\\n@@ -140,1 +137,1 @@\n-  diagnostic(bool, PrintOptoAssembly, false,                                \\\n+  product(bool, PrintOptoAssembly, false, DIAGNOSTIC,                       \\\n@@ -180,1 +177,1 @@\n-  experimental(bool, PostLoopMultiversioning, false,                        \\\n+  product(bool, PostLoopMultiversioning, false, EXPERIMENTAL,               \\\n@@ -186,1 +183,1 @@\n-  diagnostic(bool, UseVectorMacroLogic, true,                               \\\n+  product(bool, UseVectorMacroLogic, true, DIAGNOSTIC,                      \\\n@@ -485,1 +482,1 @@\n-  diagnostic(bool, PrintPreciseBiasedLockingStatistics, false,              \\\n+  product(bool, PrintPreciseBiasedLockingStatistics, false, DIAGNOSTIC,     \\\n@@ -489,1 +486,1 @@\n-  diagnostic(bool, PrintPreciseRTMLockingStatistics, false,                 \\\n+  product(bool, PrintPreciseRTMLockingStatistics, false, DIAGNOSTIC,        \\\n@@ -502,1 +499,1 @@\n-  diagnostic(bool, AggressiveUnboxing, true,                                \\\n+  product(bool, AggressiveUnboxing, true, DIAGNOSTIC,                       \\\n@@ -557,1 +554,1 @@\n-  diagnostic(intx, DominatorSearchLimit, 1000,                              \\\n+  product(intx, DominatorSearchLimit, 1000, DIAGNOSTIC,                     \\\n@@ -572,1 +569,1 @@\n-  diagnostic(bool, InlineReflectionGetCallerClass, true,                    \\\n+  product(bool, InlineReflectionGetCallerClass, true, DIAGNOSTIC,           \\\n@@ -576,1 +573,1 @@\n-  diagnostic(bool, InlineObjectCopy, true,                                  \\\n+  product(bool, InlineObjectCopy, true, DIAGNOSTIC,                         \\\n@@ -579,1 +576,1 @@\n-  diagnostic(bool, SpecialStringCompareTo, true,                            \\\n+  product(bool, SpecialStringCompareTo, true, DIAGNOSTIC,                   \\\n@@ -582,1 +579,1 @@\n-  diagnostic(bool, SpecialStringIndexOf, true,                              \\\n+  product(bool, SpecialStringIndexOf, true, DIAGNOSTIC,                     \\\n@@ -585,1 +582,1 @@\n-  diagnostic(bool, SpecialStringEquals, true,                               \\\n+  product(bool, SpecialStringEquals, true, DIAGNOSTIC,                      \\\n@@ -588,1 +585,1 @@\n-  diagnostic(bool, SpecialArraysEquals, true,                               \\\n+  product(bool, SpecialArraysEquals, true, DIAGNOSTIC,                      \\\n@@ -591,1 +588,1 @@\n-  diagnostic(bool, SpecialEncodeISOArray, true,                             \\\n+  product(bool, SpecialEncodeISOArray, true, DIAGNOSTIC,                    \\\n@@ -613,1 +610,1 @@\n-  diagnostic(bool, TraceSpilling, false,                                    \\\n+  product(bool, TraceSpilling, false, DIAGNOSTIC,                           \\\n@@ -616,1 +613,1 @@\n-  diagnostic(bool, TraceTypeProfile, false,                                 \\\n+  product(bool, TraceTypeProfile, false, DIAGNOSTIC,                        \\\n@@ -632,1 +629,1 @@\n-  diagnostic(bool, PrintIntrinsics, false,                                  \\\n+  product(bool, PrintIntrinsics, false, DIAGNOSTIC,                         \\\n@@ -638,1 +635,1 @@\n-  diagnostic(bool, DebugInlinedCalls, true,                                 \\\n+  product(bool, DebugInlinedCalls, true, DIAGNOSTIC,                        \\\n@@ -644,1 +641,1 @@\n-  diagnostic(bool, ProfileDynamicTypes, true,                               \\\n+  product(bool, ProfileDynamicTypes, true, DIAGNOSTIC,                      \\\n@@ -713,1 +710,1 @@\n-  diagnostic(bool, OptimizeExpensiveOps, true,                              \\\n+  product(bool, OptimizeExpensiveOps, true, DIAGNOSTIC,                     \\\n@@ -716,1 +713,1 @@\n-  diagnostic(bool, UseMathExactIntrinsics, true,                            \\\n+  product(bool, UseMathExactIntrinsics, true, DIAGNOSTIC,                   \\\n@@ -719,1 +716,1 @@\n-  diagnostic(bool, UseCharacterCompareIntrinsics, false,                    \\\n+  product(bool, UseCharacterCompareIntrinsics, false, DIAGNOSTIC,           \\\n@@ -722,1 +719,1 @@\n-  diagnostic(bool, UseMultiplyToLenIntrinsic, false,                        \\\n+  product(bool, UseMultiplyToLenIntrinsic, false, DIAGNOSTIC,               \\\n@@ -725,1 +722,1 @@\n-  diagnostic(bool, UseSquareToLenIntrinsic, false,                          \\\n+  product(bool, UseSquareToLenIntrinsic, false, DIAGNOSTIC,                 \\\n@@ -728,1 +725,1 @@\n-  diagnostic(bool, UseMulAddIntrinsic, false,                               \\\n+  product(bool, UseMulAddIntrinsic, false, DIAGNOSTIC,                      \\\n@@ -731,1 +728,1 @@\n-  diagnostic(bool, UseMontgomeryMultiplyIntrinsic, false,                   \\\n+  product(bool, UseMontgomeryMultiplyIntrinsic, false, DIAGNOSTIC,          \\\n@@ -734,1 +731,1 @@\n-  diagnostic(bool, UseMontgomerySquareIntrinsic, false,                     \\\n+  product(bool, UseMontgomerySquareIntrinsic, false, DIAGNOSTIC,            \\\n@@ -740,1 +737,1 @@\n-  diagnostic(bool, UseInlineDepthForSpeculativeTypes, true,                 \\\n+  product(bool, UseInlineDepthForSpeculativeTypes, true, DIAGNOSTIC,        \\\n@@ -771,2 +768,4 @@\n-  diagnostic(bool, ExpandSubTypeCheckAtParseTime, false,                    \\\n-          \"Do not use subtype check macro node\")                            \\\n+  product(bool, ExpandSubTypeCheckAtParseTime, false, DIAGNOSTIC,           \\\n+          \"Do not use subtype check macro node\")\n+\n+\/\/ end of C2_FLAGS\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":43,"deletions":44,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -3901,4 +3901,1 @@\n-\n-  \/\/ Initialize ranges and constraints\n-  JVMFlagRangeList::init();\n-  JVMFlagConstraintList::init();\n+  JVMFlag::check_all_flag_declarations();\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/flags\/jvmFlagLookup.hpp\"\n@@ -134,1 +135,1 @@\n-JVMFlag::Flags JVMFlag::get_origin() {\n+JVMFlag::Flags JVMFlag::get_origin() const {\n@@ -144,1 +145,1 @@\n-bool JVMFlag::is_default() {\n+bool JVMFlag::is_default() const {\n@@ -148,1 +149,1 @@\n-bool JVMFlag::is_ergonomic() {\n+bool JVMFlag::is_ergonomic() const {\n@@ -152,1 +153,1 @@\n-bool JVMFlag::is_command_line() {\n+bool JVMFlag::is_command_line() const {\n@@ -156,1 +157,1 @@\n-bool JVMFlag::is_jimage_resource() {\n+bool JVMFlag::is_jimage_resource() const {\n@@ -188,4 +189,0 @@\n-bool JVMFlag::is_read_write() const {\n-  return (_flags & KIND_READ_WRITE) != 0;\n-}\n-\n@@ -227,1 +224,1 @@\n- _flags = Flags(_flags & ~KIND_EXPERIMENTAL);\n+  _flags = Flags(_flags & ~KIND_EXPERIMENTAL);\n@@ -233,1 +230,1 @@\n- _flags = Flags(_flags | KIND_PRODUCT);\n+  _flags = Flags(_flags | KIND_PRODUCT);\n@@ -269,1 +266,1 @@\n-  return is_manageable() || (is_product() && is_read_write());\n+  return is_manageable();\n@@ -291,1 +288,1 @@\n-void JVMFlag::print_on(outputStream* st, bool withComments, bool printRanges) {\n+void JVMFlag::print_on(outputStream* st, bool withComments, bool printRanges) const {\n@@ -499,1 +496,1 @@\n-void JVMFlag::print_kind(outputStream* st, unsigned int width) {\n+void JVMFlag::print_kind(outputStream* st, unsigned int width) const {\n@@ -518,1 +515,0 @@\n-    { KIND_READ_WRITE, \"rw\" },\n@@ -552,1 +548,1 @@\n-void JVMFlag::print_origin(outputStream* st, unsigned int width) {\n+void JVMFlag::print_origin(outputStream* st, unsigned int width) const {\n@@ -581,1 +577,1 @@\n-void JVMFlag::print_as_flag(outputStream* st) {\n+void JVMFlag::print_as_flag(outputStream* st) const {\n@@ -636,119 +632,79 @@\n-\/\/ 4991491 do not \"optimize out\" the was_set false values: omitting them\n-\/\/ tickles a Microsoft compiler bug causing flagTable to be malformed\n-\n-#define RUNTIME_PRODUCT_FLAG_STRUCT(     type, name, value, doc) { #type, XSTR(name), &name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_PRODUCT) },\n-#define RUNTIME_PD_PRODUCT_FLAG_STRUCT(  type, name,        doc) { #type, XSTR(name), &name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_PRODUCT | JVMFlag::KIND_PLATFORM_DEPENDENT) },\n-#define RUNTIME_DIAGNOSTIC_FLAG_STRUCT(  type, name, value, doc) { #type, XSTR(name), &name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_DIAGNOSTIC) },\n-#define RUNTIME_PD_DIAGNOSTIC_FLAG_STRUCT(type, name,       doc) { #type, XSTR(name), &name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_DIAGNOSTIC | JVMFlag::KIND_PLATFORM_DEPENDENT) },\n-#define RUNTIME_EXPERIMENTAL_FLAG_STRUCT(type, name, value, doc) { #type, XSTR(name), &name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_EXPERIMENTAL) },\n-#define RUNTIME_MANAGEABLE_FLAG_STRUCT(  type, name, value, doc) { #type, XSTR(name), &name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_MANAGEABLE) },\n-#define RUNTIME_PRODUCT_RW_FLAG_STRUCT(  type, name, value, doc) { #type, XSTR(name), &name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_PRODUCT | JVMFlag::KIND_READ_WRITE) },\n-#define RUNTIME_DEVELOP_FLAG_STRUCT(     type, name, value, doc) { #type, XSTR(name), (void*) &name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_DEVELOP) },\n-#define RUNTIME_PD_DEVELOP_FLAG_STRUCT(  type, name,        doc) { #type, XSTR(name), (void*) &name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_DEVELOP | JVMFlag::KIND_PLATFORM_DEPENDENT) },\n-#define RUNTIME_NOTPRODUCT_FLAG_STRUCT(  type, name, value, doc) { #type, XSTR(name), (void*) &name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_NOT_PRODUCT) },\n-\n-#define JVMCI_PRODUCT_FLAG_STRUCT(       type, name, value, doc) { #type, XSTR(name), &name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_JVMCI | JVMFlag::KIND_PRODUCT) },\n-#define JVMCI_PD_PRODUCT_FLAG_STRUCT(    type, name,        doc) { #type, XSTR(name), &name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_JVMCI | JVMFlag::KIND_PRODUCT | JVMFlag::KIND_PLATFORM_DEPENDENT) },\n-#define JVMCI_DIAGNOSTIC_FLAG_STRUCT(    type, name, value, doc) { #type, XSTR(name), &name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_JVMCI | JVMFlag::KIND_DIAGNOSTIC) },\n-#define JVMCI_PD_DIAGNOSTIC_FLAG_STRUCT( type, name,        doc) { #type, XSTR(name), &name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_JVMCI | JVMFlag::KIND_DIAGNOSTIC | JVMFlag::KIND_PLATFORM_DEPENDENT) },\n-#define JVMCI_EXPERIMENTAL_FLAG_STRUCT(  type, name, value, doc) { #type, XSTR(name), &name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_JVMCI | JVMFlag::KIND_EXPERIMENTAL) },\n-#define JVMCI_DEVELOP_FLAG_STRUCT(       type, name, value, doc) { #type, XSTR(name), (void*) &name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_JVMCI | JVMFlag::KIND_DEVELOP) },\n-#define JVMCI_PD_DEVELOP_FLAG_STRUCT(    type, name,        doc) { #type, XSTR(name), (void*) &name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_JVMCI | JVMFlag::KIND_DEVELOP | JVMFlag::KIND_PLATFORM_DEPENDENT) },\n-#define JVMCI_NOTPRODUCT_FLAG_STRUCT(    type, name, value, doc) { #type, XSTR(name), (void*) &name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_JVMCI | JVMFlag::KIND_NOT_PRODUCT) },\n-\n-#ifdef _LP64\n-#define RUNTIME_LP64_PRODUCT_FLAG_STRUCT(type, name, value, doc) { #type, XSTR(name), &name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_LP64_PRODUCT) },\n-#else\n-#define RUNTIME_LP64_PRODUCT_FLAG_STRUCT(type, name, value, doc) \/* flag is constant *\/\n-#endif \/\/ _LP64\n-\n-#define C1_PRODUCT_FLAG_STRUCT(          type, name, value, doc) { #type, XSTR(name), &name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C1 | JVMFlag::KIND_PRODUCT) },\n-#define C1_PD_PRODUCT_FLAG_STRUCT(       type, name,        doc) { #type, XSTR(name), &name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C1 | JVMFlag::KIND_PRODUCT | JVMFlag::KIND_PLATFORM_DEPENDENT) },\n-#define C1_DIAGNOSTIC_FLAG_STRUCT(       type, name, value, doc) { #type, XSTR(name), &name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C1 | JVMFlag::KIND_DIAGNOSTIC) },\n-#define C1_PD_DIAGNOSTIC_FLAG_STRUCT(    type, name,        doc) { #type, XSTR(name), &name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C1 | JVMFlag::KIND_DIAGNOSTIC | JVMFlag::KIND_PLATFORM_DEPENDENT) },\n-#define C1_DEVELOP_FLAG_STRUCT(          type, name, value, doc) { #type, XSTR(name), (void*) &name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C1 | JVMFlag::KIND_DEVELOP) },\n-#define C1_PD_DEVELOP_FLAG_STRUCT(       type, name,        doc) { #type, XSTR(name), (void*) &name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C1 | JVMFlag::KIND_DEVELOP | JVMFlag::KIND_PLATFORM_DEPENDENT) },\n-#define C1_NOTPRODUCT_FLAG_STRUCT(       type, name, value, doc) { #type, XSTR(name), (void*) &name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C1 | JVMFlag::KIND_NOT_PRODUCT) },\n-\n-#define C2_PRODUCT_FLAG_STRUCT(          type, name, value, doc) { #type, XSTR(name), &name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C2 | JVMFlag::KIND_PRODUCT) },\n-#define C2_PD_PRODUCT_FLAG_STRUCT(       type, name,        doc) { #type, XSTR(name), &name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C2 | JVMFlag::KIND_PRODUCT | JVMFlag::KIND_PLATFORM_DEPENDENT) },\n-#define C2_DIAGNOSTIC_FLAG_STRUCT(       type, name, value, doc) { #type, XSTR(name), &name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C2 | JVMFlag::KIND_DIAGNOSTIC) },\n-#define C2_PD_DIAGNOSTIC_FLAG_STRUCT(    type, name,        doc) { #type, XSTR(name), &name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C2 | JVMFlag::KIND_DIAGNOSTIC | JVMFlag::KIND_PLATFORM_DEPENDENT) },\n-#define C2_EXPERIMENTAL_FLAG_STRUCT(     type, name, value, doc) { #type, XSTR(name), &name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C2 | JVMFlag::KIND_EXPERIMENTAL) },\n-#define C2_DEVELOP_FLAG_STRUCT(          type, name, value, doc) { #type, XSTR(name), (void*) &name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C2 | JVMFlag::KIND_DEVELOP) },\n-#define C2_PD_DEVELOP_FLAG_STRUCT(       type, name,        doc) { #type, XSTR(name), (void*) &name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C2 | JVMFlag::KIND_DEVELOP | JVMFlag::KIND_PLATFORM_DEPENDENT) },\n-#define C2_NOTPRODUCT_FLAG_STRUCT(       type, name, value, doc) { #type, XSTR(name), (void*) &name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C2 | JVMFlag::KIND_NOT_PRODUCT) },\n-\n-#define ARCH_PRODUCT_FLAG_STRUCT(        type, name, value, doc) { #type, XSTR(name), &name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_ARCH | JVMFlag::KIND_PRODUCT) },\n-#define ARCH_DIAGNOSTIC_FLAG_STRUCT(     type, name, value, doc) { #type, XSTR(name), &name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_ARCH | JVMFlag::KIND_DIAGNOSTIC) },\n-#define ARCH_EXPERIMENTAL_FLAG_STRUCT(   type, name, value, doc) { #type, XSTR(name), &name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_ARCH | JVMFlag::KIND_EXPERIMENTAL) },\n-#define ARCH_DEVELOP_FLAG_STRUCT(        type, name, value, doc) { #type, XSTR(name), (void*) &name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_ARCH | JVMFlag::KIND_DEVELOP) },\n-#define ARCH_NOTPRODUCT_FLAG_STRUCT(     type, name, value, doc) { #type, XSTR(name), (void*) &name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_ARCH | JVMFlag::KIND_NOT_PRODUCT) },\n-\n-static JVMFlag flagTable[] = {\n-  VM_FLAGS(RUNTIME_DEVELOP_FLAG_STRUCT, \\\n-           RUNTIME_PD_DEVELOP_FLAG_STRUCT, \\\n-           RUNTIME_PRODUCT_FLAG_STRUCT, \\\n-           RUNTIME_PD_PRODUCT_FLAG_STRUCT, \\\n-           RUNTIME_DIAGNOSTIC_FLAG_STRUCT, \\\n-           RUNTIME_PD_DIAGNOSTIC_FLAG_STRUCT, \\\n-           RUNTIME_EXPERIMENTAL_FLAG_STRUCT, \\\n-           RUNTIME_NOTPRODUCT_FLAG_STRUCT, \\\n-           RUNTIME_MANAGEABLE_FLAG_STRUCT, \\\n-           RUNTIME_PRODUCT_RW_FLAG_STRUCT, \\\n-           RUNTIME_LP64_PRODUCT_FLAG_STRUCT, \\\n-           IGNORE_RANGE, \\\n-           IGNORE_CONSTRAINT)\n-\n-  RUNTIME_OS_FLAGS(RUNTIME_DEVELOP_FLAG_STRUCT, \\\n-                   RUNTIME_PD_DEVELOP_FLAG_STRUCT, \\\n-                   RUNTIME_PRODUCT_FLAG_STRUCT, \\\n-                   RUNTIME_PD_PRODUCT_FLAG_STRUCT, \\\n-                   RUNTIME_DIAGNOSTIC_FLAG_STRUCT, \\\n-                   RUNTIME_PD_DIAGNOSTIC_FLAG_STRUCT, \\\n-                   RUNTIME_NOTPRODUCT_FLAG_STRUCT, \\\n-                   IGNORE_RANGE, \\\n-                   IGNORE_CONSTRAINT)\n-#if INCLUDE_JVMCI\n-  JVMCI_FLAGS(JVMCI_DEVELOP_FLAG_STRUCT, \\\n-              JVMCI_PD_DEVELOP_FLAG_STRUCT, \\\n-              JVMCI_PRODUCT_FLAG_STRUCT, \\\n-              JVMCI_PD_PRODUCT_FLAG_STRUCT, \\\n-              JVMCI_DIAGNOSTIC_FLAG_STRUCT, \\\n-              JVMCI_PD_DIAGNOSTIC_FLAG_STRUCT, \\\n-              JVMCI_EXPERIMENTAL_FLAG_STRUCT, \\\n-              JVMCI_NOTPRODUCT_FLAG_STRUCT, \\\n-              IGNORE_RANGE, \\\n-              IGNORE_CONSTRAINT)\n-#endif \/\/ INCLUDE_JVMCI\n-#ifdef COMPILER1\n-  C1_FLAGS(C1_DEVELOP_FLAG_STRUCT, \\\n-           C1_PD_DEVELOP_FLAG_STRUCT, \\\n-           C1_PRODUCT_FLAG_STRUCT, \\\n-           C1_PD_PRODUCT_FLAG_STRUCT, \\\n-           C1_DIAGNOSTIC_FLAG_STRUCT, \\\n-           C1_PD_DIAGNOSTIC_FLAG_STRUCT, \\\n-           C1_NOTPRODUCT_FLAG_STRUCT, \\\n-           IGNORE_RANGE, \\\n-           IGNORE_CONSTRAINT)\n-#endif \/\/ COMPILER1\n-#ifdef COMPILER2\n-  C2_FLAGS(C2_DEVELOP_FLAG_STRUCT, \\\n-           C2_PD_DEVELOP_FLAG_STRUCT, \\\n-           C2_PRODUCT_FLAG_STRUCT, \\\n-           C2_PD_PRODUCT_FLAG_STRUCT, \\\n-           C2_DIAGNOSTIC_FLAG_STRUCT, \\\n-           C2_PD_DIAGNOSTIC_FLAG_STRUCT, \\\n-           C2_EXPERIMENTAL_FLAG_STRUCT, \\\n-           C2_NOTPRODUCT_FLAG_STRUCT, \\\n-           IGNORE_RANGE, \\\n-           IGNORE_CONSTRAINT)\n-#endif \/\/ COMPILER2\n-  ARCH_FLAGS(ARCH_DEVELOP_FLAG_STRUCT, \\\n-             ARCH_PRODUCT_FLAG_STRUCT, \\\n-             ARCH_DIAGNOSTIC_FLAG_STRUCT, \\\n-             ARCH_EXPERIMENTAL_FLAG_STRUCT, \\\n-             ARCH_NOTPRODUCT_FLAG_STRUCT, \\\n-             IGNORE_RANGE, \\\n-             IGNORE_CONSTRAINT)\n-  {0, NULL, NULL}\n+\/\/----------------------------------------------------------------------\n+\/\/ Build flagTable[]\n+\n+\/\/ Find out the number of LP64\/JVMCI\/COMPILER1\/COMPILER1\/ARCH flags,\n+\/\/ for JVMFlag::flag_group()\n+\n+#define ENUM_F(type, name, ...)  enum_##name,\n+#define IGNORE_F(...)\n+\n+\/\/                                                  dev     dev-pd  pro     pro-pd  notpro  range     constraint\n+enum FlagCounter_LP64  { LP64_RUNTIME_FLAGS(        ENUM_F, ENUM_F, ENUM_F, ENUM_F, ENUM_F, IGNORE_F, IGNORE_F)  num_flags_LP64   };\n+enum FlagCounter_JVMCI { JVMCI_ONLY(JVMCI_FLAGS(    ENUM_F, ENUM_F, ENUM_F, ENUM_F, ENUM_F, IGNORE_F, IGNORE_F)) num_flags_JVMCI  };\n+enum FlagCounter_C1    { COMPILER1_PRESENT(C1_FLAGS(ENUM_F, ENUM_F, ENUM_F, ENUM_F, ENUM_F, IGNORE_F, IGNORE_F)) num_flags_C1     };\n+enum FlagCounter_C2    { COMPILER2_PRESENT(C2_FLAGS(ENUM_F, ENUM_F, ENUM_F, ENUM_F, ENUM_F, IGNORE_F, IGNORE_F)) num_flags_C2     };\n+enum FlagCounter_ARCH  { ARCH_FLAGS(                ENUM_F,         ENUM_F,         ENUM_F, IGNORE_F, IGNORE_F)  num_flags_ARCH   };\n+\n+const int first_flag_enum_LP64   = 0;\n+const int first_flag_enum_JVMCI  = first_flag_enum_LP64  + num_flags_LP64;\n+const int first_flag_enum_C1     = first_flag_enum_JVMCI + num_flags_JVMCI;\n+const int first_flag_enum_C2     = first_flag_enum_C1    + num_flags_C1;\n+const int first_flag_enum_ARCH   = first_flag_enum_C2    + num_flags_C2;\n+const int first_flag_enum_other  = first_flag_enum_ARCH  + num_flags_ARCH;\n+\n+static constexpr int flag_group(int flag_enum) {\n+  if (flag_enum < first_flag_enum_JVMCI) return JVMFlag::KIND_LP64_PRODUCT;\n+  if (flag_enum < first_flag_enum_C1)    return JVMFlag::KIND_JVMCI;\n+  if (flag_enum < first_flag_enum_C2)    return JVMFlag::KIND_C1;\n+  if (flag_enum < first_flag_enum_ARCH)  return JVMFlag::KIND_C2;\n+  if (flag_enum < first_flag_enum_other) return JVMFlag::KIND_ARCH;\n+\n+  return 0;\n+}\n+\n+constexpr JVMFlag::JVMFlag(int flag_enum, const char* type, const char* name,\n+                           void* addr, int flags, int extra_flags, const char* doc) :\n+  _type(type), _name(name), _addr(addr), _flags() NOT_PRODUCT(COMMA _doc(doc)) {\n+  flags = flags | extra_flags | JVMFlag::DEFAULT | flag_group(flag_enum);\n+  if ((flags & JVMFlag::KIND_PRODUCT) != 0) {\n+    if (flags & (JVMFlag::KIND_DIAGNOSTIC | JVMFlag::KIND_MANAGEABLE | JVMFlag::KIND_EXPERIMENTAL)) {\n+      \/\/ Backwards compatibility. This will be relaxed in JDK-7123237.\n+      flags &= ~(JVMFlag::KIND_PRODUCT);\n+    }\n+  }\n+  _flags = static_cast<Flags>(flags);\n+}\n+\n+constexpr JVMFlag::JVMFlag(int flag_enum,  const char* type, const char* name,\n+                           void* addr, int flags, const char* doc) :\n+  JVMFlag(flag_enum, type, name, addr, flags, \/*extra_flags*\/0, doc) {}\n+\n+const int PRODUCT_KIND     = JVMFlag::KIND_PRODUCT;\n+const int PRODUCT_KIND_PD  = JVMFlag::KIND_PRODUCT | JVMFlag::KIND_PLATFORM_DEPENDENT;\n+const int DEVELOP_KIND     = JVMFlag::KIND_DEVELOP;\n+const int DEVELOP_KIND_PD  = JVMFlag::KIND_DEVELOP | JVMFlag::KIND_PLATFORM_DEPENDENT;\n+const int NOTPROD_KIND     = JVMFlag::KIND_NOT_PRODUCT;\n+\n+#define DEVELOP_FLAG_INIT(   type, name, value, ...) JVMFlag(FLAG_MEMBER_ENUM(name), #type, XSTR(name), (void*)&name, DEVELOP_KIND,    __VA_ARGS__),\n+#define DEVELOP_FLAG_INIT_PD(type, name,        ...) JVMFlag(FLAG_MEMBER_ENUM(name), #type, XSTR(name), (void*)&name, DEVELOP_KIND_PD, __VA_ARGS__),\n+#define PRODUCT_FLAG_INIT(   type, name, value, ...) JVMFlag(FLAG_MEMBER_ENUM(name), #type, XSTR(name), (void*)&name, PRODUCT_KIND,    __VA_ARGS__),\n+#define PRODUCT_FLAG_INIT_PD(type, name,        ...) JVMFlag(FLAG_MEMBER_ENUM(name), #type, XSTR(name), (void*)&name, PRODUCT_KIND_PD, __VA_ARGS__),\n+#define NOTPROD_FLAG_INIT(   type, name, value, ...) JVMFlag(FLAG_MEMBER_ENUM(name), #type, XSTR(name), (void*)&name, NOTPROD_KIND,    __VA_ARGS__),\n+\n+\/\/ Handy aliases to match the symbols used in the flag specification macros.\n+const int DIAGNOSTIC   = JVMFlag::KIND_DIAGNOSTIC;\n+const int MANAGEABLE   = JVMFlag::KIND_MANAGEABLE;\n+const int EXPERIMENTAL = JVMFlag::KIND_EXPERIMENTAL;\n+\n+#define MATERIALIZE_ALL_FLAGS      \\\n+  ALL_FLAGS(DEVELOP_FLAG_INIT,     \\\n+            DEVELOP_FLAG_INIT_PD,  \\\n+            PRODUCT_FLAG_INIT,     \\\n+            PRODUCT_FLAG_INIT_PD,  \\\n+            NOTPROD_FLAG_INIT,     \\\n+            IGNORE_RANGE,          \\\n+            IGNORE_CONSTRAINT)\n+\n+static JVMFlag flagTable[NUM_JVMFlagsEnum + 1] = {\n+  MATERIALIZE_ALL_FLAGS\n+  JVMFlag() \/\/ The iteration code wants a flag with a NULL name at the end of the table.\n@@ -757,0 +713,12 @@\n+\/\/ We want flagTable[] to be completely initialized at C++ compilation time, which requires\n+\/\/ that all arguments passed to JVMFlag() constructors be constexpr. The following line\n+\/\/ checks for this -- if any non-constexpr arguments are passed, the C++ compiler will\n+\/\/ generate an error.\n+\/\/\n+\/\/ constexpr implies internal linkage. This means the flagTable_verify_constexpr[] variable\n+\/\/ will not be included in jvmFlag.o, so there's no footprint cost for having this variable.\n+\/\/\n+\/\/ Note that we cannot declare flagTable[] as constexpr because JVMFlag::_flags is modified\n+\/\/ at runtime.\n+constexpr JVMFlag flagTable_verify_constexpr[] = { MATERIALIZE_ALL_FLAGS };\n+\n@@ -760,5 +728,0 @@\n-inline bool str_equal(const char* s, size_t s_len, const char* q, size_t q_len) {\n-  if (s_len != q_len) return false;\n-  return memcmp(s, q, q_len) == 0;\n-}\n-\n@@ -767,14 +730,13 @@\n-  for (JVMFlag* current = &flagTable[0]; current->_name != NULL; current++) {\n-    if (str_equal(current->_name, current->get_name_length(), name, length)) {\n-      \/\/ Found a matching entry.\n-      \/\/ Don't report notproduct and develop flags in product builds.\n-      if (current->is_constant_in_binary()) {\n-        return (return_flag ? current : NULL);\n-      }\n-      \/\/ Report locked flags only if allowed.\n-      if (!(current->is_unlocked() || current->is_unlocker())) {\n-        if (!allow_locked) {\n-          \/\/ disable use of locked flags, e.g. diagnostic, experimental,\n-          \/\/ etc. until they are explicitly unlocked\n-          return NULL;\n-        }\n+  JVMFlag* flag = JVMFlagLookup::find(name, length);\n+  if (flag != NULL) {\n+    \/\/ Found a matching entry.\n+    \/\/ Don't report notproduct and develop flags in product builds.\n+    if (flag->is_constant_in_binary()) {\n+      return (return_flag ? flag : NULL);\n+    }\n+    \/\/ Report locked flags only if allowed.\n+    if (!(flag->is_unlocked() || flag->is_unlocker())) {\n+      if (!allow_locked) {\n+        \/\/ disable use of locked flags, e.g. diagnostic, experimental,\n+        \/\/ etc. until they are explicitly unlocked\n+        return NULL;\n@@ -782,1 +744,0 @@\n-      return current;\n@@ -784,0 +745,1 @@\n+    return flag;\n@@ -789,8 +751,0 @@\n-\/\/ Get or compute the flag name length\n-size_t JVMFlag::get_name_length() {\n-  if (_name_len == 0) {\n-    _name_len = strlen(_name);\n-  }\n-  return _name_len;\n-}\n-\n@@ -859,1 +813,1 @@\n-static void trace_flag_changed(const JVMFlag* flag, const T old_value, const T new_value, const JVMFlag::Flags origin) {\n+static void trace_flag_changed(JVMFlag* flag, const T old_value, const T new_value, const JVMFlag::Flags origin) {\n@@ -868,1 +822,1 @@\n-static JVMFlag::Error apply_constraint_and_check_range_bool(const JVMFlag* flag, bool new_value, bool verbose) {\n+static JVMFlag::Error apply_constraint_and_check_range_bool(JVMFlag* flag, bool new_value, bool verbose) {\n@@ -870,3 +824,3 @@\n-  JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);\n-  if (constraint != NULL) {\n-    status = constraint->apply_bool(new_value, verbose);\n+  JVMFlagConstraintChecker constraint = JVMFlagConstraintList::find_if_needs_check(flag);\n+  if (constraint.exists()) {\n+    status = constraint.apply_bool(new_value, verbose);\n@@ -903,1 +857,1 @@\n-static JVMFlag::Error apply_constraint_and_check_range_int(const JVMFlag* flag, int new_value, bool verbose) {\n+static JVMFlag::Error apply_constraint_and_check_range_int(JVMFlag* flag, int new_value, bool verbose) {\n@@ -905,3 +859,3 @@\n-  JVMFlagRange* range = JVMFlagRangeList::find(flag);\n-  if (range != NULL) {\n-    status = range->check_int(new_value, verbose);\n+  JVMFlagRangeChecker range = JVMFlagRangeList::find(flag);\n+  if (range.exists()) {\n+    status = range.check_int(new_value, verbose);\n@@ -910,3 +864,3 @@\n-    JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);\n-    if (constraint != NULL) {\n-      status = constraint->apply_int(new_value, verbose);\n+    JVMFlagConstraintChecker constraint = JVMFlagConstraintList::find_if_needs_check(flag);\n+    if (constraint.exists()) {\n+      status = constraint.apply_int(new_value, verbose);\n@@ -944,1 +898,1 @@\n-static JVMFlag::Error apply_constraint_and_check_range_uint(const JVMFlag* flag, uint new_value, bool verbose) {\n+static JVMFlag::Error apply_constraint_and_check_range_uint(JVMFlag* flag, uint new_value, bool verbose) {\n@@ -946,3 +900,3 @@\n-  JVMFlagRange* range = JVMFlagRangeList::find(flag);\n-  if (range != NULL) {\n-    status = range->check_uint(new_value, verbose);\n+  JVMFlagRangeChecker range = JVMFlagRangeList::find(flag);\n+  if (range.exists()) {\n+    status = range.check_uint(new_value, verbose);\n@@ -951,3 +905,3 @@\n-    JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);\n-    if (constraint != NULL) {\n-      status = constraint->apply_uint(new_value, verbose);\n+    JVMFlagConstraintChecker constraint = JVMFlagConstraintList::find_if_needs_check(flag);\n+    if (constraint.exists()) {\n+      status = constraint.apply_uint(new_value, verbose);\n@@ -992,1 +946,1 @@\n-static JVMFlag::Error apply_constraint_and_check_range_intx(const JVMFlag* flag, intx new_value, bool verbose) {\n+static JVMFlag::Error apply_constraint_and_check_range_intx(JVMFlag* flag, intx new_value, bool verbose) {\n@@ -994,3 +948,3 @@\n-  JVMFlagRange* range = JVMFlagRangeList::find(flag);\n-  if (range != NULL) {\n-    status = range->check_intx(new_value, verbose);\n+  JVMFlagRangeChecker range = JVMFlagRangeList::find(flag);\n+  if (range.exists()) {\n+    status = range.check_intx(new_value, verbose);\n@@ -999,3 +953,3 @@\n-    JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);\n-    if (constraint != NULL) {\n-      status = constraint->apply_intx(new_value, verbose);\n+    JVMFlagConstraintChecker constraint = JVMFlagConstraintList::find_if_needs_check(flag);\n+    if (constraint.exists()) {\n+      status = constraint.apply_intx(new_value, verbose);\n@@ -1033,1 +987,1 @@\n-static JVMFlag::Error apply_constraint_and_check_range_uintx(const JVMFlag* flag, uintx new_value, bool verbose) {\n+static JVMFlag::Error apply_constraint_and_check_range_uintx(JVMFlag* flag, uintx new_value, bool verbose) {\n@@ -1035,3 +989,3 @@\n-  JVMFlagRange* range = JVMFlagRangeList::find(flag);\n-  if (range != NULL) {\n-    status = range->check_uintx(new_value, verbose);\n+  JVMFlagRangeChecker range = JVMFlagRangeList::find(flag);\n+  if (range.exists()) {\n+    status = range.check_uintx(new_value, verbose);\n@@ -1040,3 +994,3 @@\n-    JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);\n-    if (constraint != NULL) {\n-      status = constraint->apply_uintx(new_value, verbose);\n+    JVMFlagConstraintChecker constraint = JVMFlagConstraintList::find_if_needs_check(flag);\n+    if (constraint.exists()) {\n+      status = constraint.apply_uintx(new_value, verbose);\n@@ -1074,1 +1028,1 @@\n-static JVMFlag::Error apply_constraint_and_check_range_uint64_t(const JVMFlag* flag, uint64_t new_value, bool verbose) {\n+static JVMFlag::Error apply_constraint_and_check_range_uint64_t(JVMFlag* flag, uint64_t new_value, bool verbose) {\n@@ -1076,3 +1030,3 @@\n-  JVMFlagRange* range = JVMFlagRangeList::find(flag);\n-  if (range != NULL) {\n-    status = range->check_uint64_t(new_value, verbose);\n+  JVMFlagRangeChecker range = JVMFlagRangeList::find(flag);\n+  if (range.exists()) {\n+    status = range.check_uint64_t(new_value, verbose);\n@@ -1081,3 +1035,3 @@\n-    JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);\n-    if (constraint != NULL) {\n-      status = constraint->apply_uint64_t(new_value, verbose);\n+    JVMFlagConstraintChecker constraint = JVMFlagConstraintList::find_if_needs_check(flag);\n+    if (constraint.exists()) {\n+      status = constraint.apply_uint64_t(new_value, verbose);\n@@ -1115,1 +1069,1 @@\n-static JVMFlag::Error apply_constraint_and_check_range_size_t(const JVMFlag* flag, size_t new_value, bool verbose) {\n+static JVMFlag::Error apply_constraint_and_check_range_size_t(JVMFlag* flag, size_t new_value, bool verbose) {\n@@ -1117,3 +1071,3 @@\n-  JVMFlagRange* range = JVMFlagRangeList::find(flag);\n-  if (range != NULL) {\n-    status = range->check_size_t(new_value, verbose);\n+  JVMFlagRangeChecker range = JVMFlagRangeList::find(flag);\n+  if (range.exists()) {\n+    status = range.check_size_t(new_value, verbose);\n@@ -1122,3 +1076,3 @@\n-    JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);\n-    if (constraint != NULL) {\n-      status = constraint->apply_size_t(new_value, verbose);\n+    JVMFlagConstraintChecker constraint = JVMFlagConstraintList::find_if_needs_check(flag);\n+    if (constraint.exists()) {\n+      status = constraint.apply_size_t(new_value, verbose);\n@@ -1157,1 +1111,1 @@\n-static JVMFlag::Error apply_constraint_and_check_range_double(const JVMFlag* flag, double new_value, bool verbose) {\n+static JVMFlag::Error apply_constraint_and_check_range_double(JVMFlag* flag, double new_value, bool verbose) {\n@@ -1159,3 +1113,3 @@\n-  JVMFlagRange* range = JVMFlagRangeList::find(flag);\n-  if (range != NULL) {\n-    status = range->check_double(new_value, verbose);\n+  JVMFlagRangeChecker range = JVMFlagRangeList::find(flag);\n+  if (range.exists()) {\n+    status = range.check_double(new_value, verbose);\n@@ -1164,3 +1118,3 @@\n-    JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);\n-    if (constraint != NULL) {\n-      status = constraint->apply_double(new_value, verbose);\n+    JVMFlagConstraintChecker constraint = JVMFlagConstraintList::find_if_needs_check(flag);\n+    if (constraint.exists()) {\n+      status = constraint.apply_double(new_value, verbose);\n@@ -1272,0 +1226,27 @@\n+#ifdef ASSERT\n+\n+void JVMFlag::assert_valid_flag_enum(int i) {\n+  assert(0 <= i && i < NUM_JVMFlagsEnum, \"must be\");\n+}\n+\n+void JVMFlag::check_all_flag_declarations() {\n+  for (JVMFlag* current = &flagTable[0]; current->_name != NULL; current++) {\n+    int flags = static_cast<int>(current->_flags);\n+    \/\/ Backwards compatibility. This will be relaxed\/removed in JDK-7123237.\n+    int mask = JVMFlag::KIND_DIAGNOSTIC | JVMFlag::KIND_MANAGEABLE | JVMFlag::KIND_EXPERIMENTAL;\n+    if ((flags & mask) != 0) {\n+      assert((flags & mask) == JVMFlag::KIND_DIAGNOSTIC ||\n+             (flags & mask) == JVMFlag::KIND_MANAGEABLE ||\n+             (flags & mask) == JVMFlag::KIND_EXPERIMENTAL,\n+             \"%s can be declared with at most one of \"\n+             \"DIAGNOSTIC, MANAGEABLE or EXPERIMENTAL\", current->_name);\n+      assert((flags & KIND_NOT_PRODUCT) == 0 &&\n+             (flags & KIND_DEVELOP) == 0,\n+             \"%s has an optional DIAGNOSTIC, MANAGEABLE or EXPERIMENTAL \"\n+             \"attribute; it must be declared as a product flag\", current->_name);\n+    }\n+  }\n+}\n+\n+#endif \/\/ ASSERT\n+\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlag.cpp","additions":199,"deletions":218,"binary":false,"changes":417,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  enum Flags {\n+  enum Flags : int {\n@@ -61,6 +61,5 @@\n-    KIND_READ_WRITE         = 1 << 11,\n-    KIND_C1                 = 1 << 12,\n-    KIND_C2                 = 1 << 13,\n-    KIND_ARCH               = 1 << 14,\n-    KIND_LP64_PRODUCT       = 1 << 15,\n-    KIND_JVMCI              = 1 << 16,\n+    KIND_C1                 = 1 << 11,\n+    KIND_C2                 = 1 << 12,\n+    KIND_ARCH               = 1 << 13,\n+    KIND_LP64_PRODUCT       = 1 << 14,\n+    KIND_JVMCI              = 1 << 15,\n@@ -112,1 +111,0 @@\n-  NOT_PRODUCT(const char* _doc;)\n@@ -114,1 +112,1 @@\n-  size_t _name_len;\n+  NOT_PRODUCT(const char* _doc;)\n@@ -126,0 +124,8 @@\n+  constexpr JVMFlag() : _type(), _name(), _addr(), _flags() NOT_PRODUCT(COMMA _doc()) {}\n+\n+  constexpr JVMFlag(int flag_enum, const char* type, const char* name,\n+                    void* addr, int flags, int extra_flags, const char* doc);\n+\n+  constexpr JVMFlag(int flag_enum,  const char* type, const char* name,\n+                    void* addr, int flags, const char* doc);\n+\n@@ -129,1 +135,1 @@\n-  static const JVMFlag* find_declared_flag(const char* name, size_t length) {\n+  static JVMFlag* find_declared_flag(const char* name, size_t length) {\n@@ -132,1 +138,1 @@\n-  static const JVMFlag* find_declared_flag(const char* name) {\n+  static JVMFlag* find_declared_flag(const char* name) {\n@@ -146,0 +152,14 @@\n+  static void assert_valid_flag_enum(int i) NOT_DEBUG_RETURN;\n+  static void check_all_flag_declarations() NOT_DEBUG_RETURN;\n+\n+  inline int flag_enum() const {\n+    int i = this - JVMFlag::flags;\n+    assert_valid_flag_enum(i);\n+    return i;\n+  }\n+\n+  static JVMFlag* flag_from_enum(int flag_enum) {\n+    assert_valid_flag_enum(flag_enum);\n+    return &JVMFlag::flags[flag_enum];\n+  }\n+\n@@ -148,1 +168,1 @@\n-  void set_bool(bool value)                   { *((bool*) _addr) = value; }\n+  void set_bool(bool value) const             { *((bool*) _addr) = value; }\n@@ -152,1 +172,1 @@\n-  void set_int(int value)                     { *((int*) _addr) = value; }\n+  void set_int(int value) const               { *((int*) _addr) = value; }\n@@ -156,1 +176,1 @@\n-  void set_uint(uint value)                   { *((uint*) _addr) = value; }\n+  void set_uint(uint value) const             { *((uint*) _addr) = value; }\n@@ -160,1 +180,1 @@\n-  void set_intx(intx value)                   { *((intx*) _addr) = value; }\n+  void set_intx(intx value) const             { *((intx*) _addr) = value; }\n@@ -164,1 +184,1 @@\n-  void set_uintx(uintx value)                 { *((uintx*) _addr) = value; }\n+  void set_uintx(uintx value) const           { *((uintx*) _addr) = value; }\n@@ -168,1 +188,1 @@\n-  void set_uint64_t(uint64_t value)           { *((uint64_t*) _addr) = value; }\n+  void set_uint64_t(uint64_t value) const     { *((uint64_t*) _addr) = value; }\n@@ -172,1 +192,1 @@\n-  void set_size_t(size_t value)               { *((size_t*) _addr) = value; }\n+  void set_size_t(size_t value) const         { *((size_t*) _addr) = value; }\n@@ -176,1 +196,1 @@\n-  void set_double(double value)               { *((double*) _addr) = value; }\n+  void set_double(double value) const         { *((double*) _addr) = value; }\n@@ -181,1 +201,1 @@\n-  void set_ccstr(ccstr value)                 { *((ccstr*) _addr) = value; }\n+  void set_ccstr(ccstr value) const           { *((ccstr*) _addr) = value; }\n@@ -183,1 +203,1 @@\n-  Flags get_origin();\n+  Flags get_origin() const;\n@@ -186,6 +206,4 @@\n-  size_t get_name_length();\n-\n-  bool is_default();\n-  bool is_ergonomic();\n-  bool is_jimage_resource();\n-  bool is_command_line();\n+  bool is_default() const;\n+  bool is_ergonomic() const;\n+  bool is_jimage_resource() const;\n+  bool is_command_line() const;\n@@ -200,1 +218,0 @@\n-  bool is_read_write() const;\n@@ -217,4 +234,4 @@\n-  void print_on(outputStream* st, bool withComments = false, bool printRanges = false);\n-  void print_kind(outputStream* st, unsigned int width);\n-  void print_origin(outputStream* st, unsigned int width);\n-  void print_as_flag(outputStream* st);\n+  void print_on(outputStream* st, bool withComments = false, bool printRanges = false) const;\n+  void print_kind(outputStream* st, unsigned int width) const;\n+  void print_origin(outputStream* st, unsigned int width) const;\n+  void print_as_flag(outputStream* st) const;\n@@ -263,0 +280,2 @@\n+#define DECLARE_CONSTRAINT(type, func) JVMFlag::Error func(type value, bool verbose);\n+\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlag.hpp","additions":51,"deletions":32,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -175,39 +175,7 @@\n-\/\/ No constraint emitting\n-void emit_constraint_no(...)                            { \/* NOP *\/ }\n-\n-\/\/ No constraint emitting if function argument is NOT provided\n-void emit_constraint_bool(const JVMFlag* \/*flag*\/)      { \/* NOP *\/ }\n-void emit_constraint_ccstr(const JVMFlag* \/*flag*\/)     { \/* NOP *\/ }\n-void emit_constraint_ccstrlist(const JVMFlag* \/*flag*\/) { \/* NOP *\/ }\n-void emit_constraint_int(const JVMFlag* \/*flag*\/)       { \/* NOP *\/ }\n-void emit_constraint_intx(const JVMFlag* \/*flag*\/)      { \/* NOP *\/ }\n-void emit_constraint_uint(const JVMFlag* \/*flag*\/)      { \/* NOP *\/ }\n-void emit_constraint_uintx(const JVMFlag* \/*flag*\/)     { \/* NOP *\/ }\n-void emit_constraint_uint64_t(const JVMFlag* \/*flag*\/)  { \/* NOP *\/ }\n-void emit_constraint_size_t(const JVMFlag* \/*flag*\/)    { \/* NOP *\/ }\n-void emit_constraint_double(const JVMFlag* \/*flag*\/)    { \/* NOP *\/ }\n-\n-\/\/ JVMFlagConstraint emitting code functions if function argument is provided\n-void emit_constraint_bool(const JVMFlag* flag, JVMFlagConstraintFunc_bool func, JVMFlagConstraint::ConstraintType type) {\n-  JVMFlagConstraintList::add(new JVMFlagConstraint_bool(flag, func, type));\n-}\n-void emit_constraint_int(const JVMFlag* flag, JVMFlagConstraintFunc_int func, JVMFlagConstraint::ConstraintType type) {\n-  JVMFlagConstraintList::add(new JVMFlagConstraint_int(flag, func, type));\n-}\n-void emit_constraint_intx(const JVMFlag* flag, JVMFlagConstraintFunc_intx func, JVMFlagConstraint::ConstraintType type) {\n-  JVMFlagConstraintList::add(new JVMFlagConstraint_intx(flag, func, type));\n-}\n-void emit_constraint_uint(const JVMFlag* flag, JVMFlagConstraintFunc_uint func, JVMFlagConstraint::ConstraintType type) {\n-  JVMFlagConstraintList::add(new JVMFlagConstraint_uint(flag, func, type));\n-}\n-void emit_constraint_uintx(const JVMFlag* flag, JVMFlagConstraintFunc_uintx func, JVMFlagConstraint::ConstraintType type) {\n-  JVMFlagConstraintList::add(new JVMFlagConstraint_uintx(flag, func, type));\n-}\n-void emit_constraint_uint64_t(const JVMFlag* flag, JVMFlagConstraintFunc_uint64_t func, JVMFlagConstraint::ConstraintType type) {\n-  JVMFlagConstraintList::add(new JVMFlagConstraint_uint64_t(flag, func, type));\n-}\n-void emit_constraint_size_t(const JVMFlag* flag, JVMFlagConstraintFunc_size_t func, JVMFlagConstraint::ConstraintType type) {\n-  JVMFlagConstraintList::add(new JVMFlagConstraint_size_t(flag, func, type));\n-}\n-void emit_constraint_double(const JVMFlag* flag, JVMFlagConstraintFunc_double func, JVMFlagConstraint::ConstraintType type) {\n-  JVMFlagConstraintList::add(new JVMFlagConstraint_double(flag, func, type));\n+#define DEFINE_CONSTRAINT_APPLY(T) \\\n+JVMFlag::Error JVMFlagConstraintChecker::apply_ ## T(T value, bool verbose) const {           \\\n+  assert(exists(), \"must be\");                                                                \\\n+  JVMFlagConstraint_ ## T constraint(_flag,                                                   \\\n+                                     (JVMFlagConstraintFunc_ ## T)_limit->constraint_func(),  \\\n+                                     (JVMFlagConstraint::ConstraintType)_limit->phase());     \\\n+  return constraint.apply_ ## T(value, verbose);                                              \\\n@@ -216,34 +184,1 @@\n-\/\/ Generate code to call emit_constraint_xxx function\n-#define EMIT_CONSTRAINT_START       (void)(0\n-#define EMIT_CONSTRAINT(type, name) ); emit_constraint_##type(JVMFlagEx::flag_from_enum(FLAG_MEMBER_ENUM(name))\n-#define EMIT_CONSTRAINT_NO          ); emit_constraint_no(0\n-#define EMIT_CONSTRAINT_PRODUCT_FLAG(type, name, value, doc)      EMIT_CONSTRAINT(type, name)\n-#define EMIT_CONSTRAINT_DIAGNOSTIC_FLAG(type, name, value, doc)   EMIT_CONSTRAINT(type, name)\n-#define EMIT_CONSTRAINT_EXPERIMENTAL_FLAG(type, name, value, doc) EMIT_CONSTRAINT(type, name)\n-#define EMIT_CONSTRAINT_MANAGEABLE_FLAG(type, name, value, doc)   EMIT_CONSTRAINT(type, name)\n-#define EMIT_CONSTRAINT_PRODUCT_RW_FLAG(type, name, value, doc)   EMIT_CONSTRAINT(type, name)\n-#define EMIT_CONSTRAINT_PD_PRODUCT_FLAG(type, name, doc)          EMIT_CONSTRAINT(type, name)\n-#define EMIT_CONSTRAINT_PD_DIAGNOSTIC_FLAG(type, name, doc)       EMIT_CONSTRAINT(type, name)\n-#ifndef PRODUCT\n-#define EMIT_CONSTRAINT_DEVELOPER_FLAG(type, name, value, doc)    EMIT_CONSTRAINT(type, name)\n-#define EMIT_CONSTRAINT_PD_DEVELOPER_FLAG(type, name, doc)        EMIT_CONSTRAINT(type, name)\n-#define EMIT_CONSTRAINT_NOTPRODUCT_FLAG(type, name, value, doc)   EMIT_CONSTRAINT(type, name)\n-#else\n-#define EMIT_CONSTRAINT_DEVELOPER_FLAG(type, name, value, doc)    EMIT_CONSTRAINT_NO\n-#define EMIT_CONSTRAINT_PD_DEVELOPER_FLAG(type, name, doc)        EMIT_CONSTRAINT_NO\n-#define EMIT_CONSTRAINT_NOTPRODUCT_FLAG(type, name, value, doc)   EMIT_CONSTRAINT_NO\n-#endif\n-#ifdef _LP64\n-#define EMIT_CONSTRAINT_LP64_PRODUCT_FLAG(type, name, value, doc) EMIT_CONSTRAINT(type, name)\n-#else\n-#define EMIT_CONSTRAINT_LP64_PRODUCT_FLAG(type, name, value, doc) EMIT_CONSTRAINT_NO\n-#endif\n-#define EMIT_CONSTRAINT_END         );\n-\n-\/\/ Generate func argument to pass into emit_constraint_xxx functions\n-#define EMIT_CONSTRAINT_CHECK(func, type)                         , func, JVMFlagConstraint::type\n-\n-\/\/ the \"name\" argument must be a string literal\n-#define INITIAL_CONSTRAINTS_SIZE 72\n-GrowableArray<JVMFlagConstraint*>* JVMFlagConstraintList::_constraints = NULL;\n-JVMFlagConstraint::ConstraintType JVMFlagConstraintList::_validating_type = JVMFlagConstraint::AtParse;\n+ALL_CONSTRAINT_TYPES(DEFINE_CONSTRAINT_APPLY)\n@@ -251,22 +186,0 @@\n-\/\/ Check the ranges of all flags that have them or print them out and exit if requested\n-void JVMFlagConstraintList::init(void) {\n-  _constraints = new (ResourceObj::C_HEAP, mtArguments) GrowableArray<JVMFlagConstraint*>(INITIAL_CONSTRAINTS_SIZE, mtArguments);\n-\n-  EMIT_CONSTRAINT_START\n-\n-  ALL_FLAGS(EMIT_CONSTRAINT_DEVELOPER_FLAG,\n-            EMIT_CONSTRAINT_PD_DEVELOPER_FLAG,\n-            EMIT_CONSTRAINT_PRODUCT_FLAG,\n-            EMIT_CONSTRAINT_PD_PRODUCT_FLAG,\n-            EMIT_CONSTRAINT_DIAGNOSTIC_FLAG,\n-            EMIT_CONSTRAINT_PD_DIAGNOSTIC_FLAG,\n-            EMIT_CONSTRAINT_EXPERIMENTAL_FLAG,\n-            EMIT_CONSTRAINT_NOTPRODUCT_FLAG,\n-            EMIT_CONSTRAINT_MANAGEABLE_FLAG,\n-            EMIT_CONSTRAINT_PRODUCT_RW_FLAG,\n-            EMIT_CONSTRAINT_LP64_PRODUCT_FLAG,\n-            IGNORE_RANGE,\n-            EMIT_CONSTRAINT_CHECK)\n-\n-  EMIT_CONSTRAINT_END\n-}\n@@ -274,8 +187,7 @@\n-JVMFlagConstraint* JVMFlagConstraintList::find(const JVMFlag* flag) {\n-  JVMFlagConstraint* found = NULL;\n-  for (int i=0; i<length(); i++) {\n-    JVMFlagConstraint* constraint = at(i);\n-    if (constraint->flag() == flag) {\n-      found = constraint;\n-      break;\n-    }\n+JVMFlag::Error JVMFlagConstraintChecker::apply(bool verbose) const {\n+#define APPLY_CONSTRAINT(T)                                                                     \\\n+  if (_flag->is_ ## T()) {                                                                      \\\n+    JVMFlagConstraint_ ## T constraint(_flag,                                                   \\\n+                                       (JVMFlagConstraintFunc_ ## T)_limit->constraint_func(),  \\\n+                                       (JVMFlagConstraint::ConstraintType)_limit->phase());     \\\n+    return constraint.apply(verbose);                                                           \\\n@@ -283,1 +195,5 @@\n-  return found;\n+\n+  ALL_CONSTRAINT_TYPES(APPLY_CONSTRAINT);\n+\n+  ShouldNotReachHere();\n+  return JVMFlag::INVALID_FLAG;\n@@ -286,0 +202,3 @@\n+\n+JVMFlagConstraint::ConstraintType JVMFlagConstraintList::_validating_type = JVMFlagConstraint::AtParse;\n+\n@@ -287,5 +206,4 @@\n-JVMFlagConstraint* JVMFlagConstraintList::find_if_needs_check(const JVMFlag* flag) {\n-  JVMFlagConstraint* found = NULL;\n-  JVMFlagConstraint* constraint = find(flag);\n-  if (constraint != NULL && (constraint->type() <= _validating_type)) {\n-    found = constraint;\n+JVMFlagConstraintChecker JVMFlagConstraintList::find_if_needs_check(const JVMFlag* flag) {\n+  JVMFlagConstraintChecker constraint = JVMFlagConstraintList::find(flag);\n+  if (constraint.exists() && (constraint.type() <= _validating_type)) {\n+    return constraint;\n@@ -293,1 +211,1 @@\n-  return found;\n+  return JVMFlagConstraintChecker(flag, NULL);\n@@ -302,4 +220,5 @@\n-  for (int i=0; i<length(); i++) {\n-    JVMFlagConstraint* constraint = at(i);\n-    if (type != constraint->type()) continue;\n-    if (constraint->apply(true) != JVMFlag::SUCCESS) status = false;\n+  for (int i = 0; i < NUM_JVMFlagsEnum; i++) {\n+    JVMFlagConstraintChecker constraint(&JVMFlag::flags[i], JVMFlagLimit::get_constraint_at(i));\n+    if (!constraint.exists()) continue;\n+    if (type != constraint.type()) continue;\n+    if (constraint.apply(true) != JVMFlag::SUCCESS) status = false;\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintList.cpp","additions":33,"deletions":114,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"utilities\/growableArray.hpp\"\n+#include \"runtime\/flags\/jvmFlagLimit.hpp\"\n@@ -86,0 +86,14 @@\n+class JVMFlagConstraintChecker {\n+  const JVMFlag* _flag;\n+  const JVMFlagLimit* _limit;\n+\n+public:\n+  JVMFlagConstraintChecker(const JVMFlag* flag, const JVMFlagLimit* limit) : _flag(flag), _limit(limit) {}\n+  bool exists() const { return _limit != NULL; }\n+  JVMFlag::Error apply(bool verbose = true) const;\n+\n+  JVMFlagConstraint::ConstraintType type() const { return (JVMFlagConstraint::ConstraintType)_limit->phase(); }\n+#define DECLARE_CONSTRAINT_APPLY(T) JVMFlag::Error apply_ ## T(T new_value, bool verbose = true) const;\n+  ALL_CONSTRAINT_TYPES(DECLARE_CONSTRAINT_APPLY)\n+};\n+\n@@ -88,1 +102,0 @@\n-  static GrowableArray<JVMFlagConstraint*>* _constraints;\n@@ -93,5 +106,2 @@\n-  static int length() { return (_constraints != NULL) ? _constraints->length() : 0; }\n-  static JVMFlagConstraint* at(int i) { return (_constraints != NULL) ? _constraints->at(i) : NULL; }\n-  static JVMFlagConstraint* find(const JVMFlag* flag);\n-  static JVMFlagConstraint* find_if_needs_check(const JVMFlag* flag);\n-  static void add(JVMFlagConstraint* constraint) { _constraints->append(constraint); }\n+  static JVMFlagConstraintChecker find(const JVMFlag* flag) { return JVMFlagConstraintChecker(flag, JVMFlagLimit::get_constraint(flag)); }\n+  static JVMFlagConstraintChecker find_if_needs_check(const JVMFlag* flag);\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintList.hpp","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"utilities\/macros.hpp\"\n@@ -36,41 +37,23 @@\n-JVMFlag::Error AliasLevelConstraintFunc(intx value, bool verbose);\n-\n-JVMFlag::Error CICompilerCountConstraintFunc(intx value, bool verbose);\n-\n-JVMFlag::Error AllocatePrefetchDistanceConstraintFunc(intx value, bool verbose);\n-\n-JVMFlag::Error AllocatePrefetchInstrConstraintFunc(intx value, bool verbose);\n-\n-JVMFlag::Error AllocatePrefetchStepSizeConstraintFunc(intx value, bool verbose);\n-\n-JVMFlag::Error CompileThresholdConstraintFunc(intx value, bool verbose);\n-\n-JVMFlag::Error OnStackReplacePercentageConstraintFunc(intx value, bool verbose);\n-\n-JVMFlag::Error CodeCacheSegmentSizeConstraintFunc(uintx value, bool verbose);\n-\n-JVMFlag::Error CompilerThreadPriorityConstraintFunc(intx value, bool verbose);\n-\n-JVMFlag::Error CodeEntryAlignmentConstraintFunc(intx value, bool verbose);\n-\n-JVMFlag::Error OptoLoopAlignmentConstraintFunc(intx value, bool verbose);\n-\n-JVMFlag::Error ArraycopyDstPrefetchDistanceConstraintFunc(uintx value, bool verbose);\n-\n-JVMFlag::Error ArraycopySrcPrefetchDistanceConstraintFunc(uintx value, bool verbose);\n-\n-JVMFlag::Error TypeProfileLevelConstraintFunc(uintx value, bool verbose);\n-\n-JVMFlag::Error InitArrayShortSizeConstraintFunc(intx value, bool verbose);\n-\n-#ifdef COMPILER2\n-JVMFlag::Error InteriorEntryAlignmentConstraintFunc(intx value, bool verbose);\n-\n-JVMFlag::Error NodeLimitFudgeFactorConstraintFunc(intx value, bool verbose);\n-#endif\n-\n-JVMFlag::Error RTMTotalCountIncrRateConstraintFunc(int value, bool verbose);\n-\n-#ifdef COMPILER2\n-JVMFlag::Error LoopStripMiningIterConstraintFunc(uintx value, bool verbose);\n-#endif\n+#define COMPILER_CONSTRAINTS(f)                         \\\n+  f(intx,  AliasLevelConstraintFunc)                    \\\n+  f(intx,  CICompilerCountConstraintFunc)               \\\n+  f(intx,  AllocatePrefetchDistanceConstraintFunc)      \\\n+  f(intx,  AllocatePrefetchInstrConstraintFunc)         \\\n+  f(intx,  AllocatePrefetchStepSizeConstraintFunc)      \\\n+  f(intx,  CompileThresholdConstraintFunc)              \\\n+  f(intx,  OnStackReplacePercentageConstraintFunc)      \\\n+  f(uintx, CodeCacheSegmentSizeConstraintFunc)          \\\n+  f(intx,  CodeEntryAlignmentConstraintFunc)            \\\n+  f(intx,  OptoLoopAlignmentConstraintFunc)             \\\n+  f(uintx, ArraycopyDstPrefetchDistanceConstraintFunc)  \\\n+  f(uintx, ArraycopySrcPrefetchDistanceConstraintFunc)  \\\n+  f(uintx, TypeProfileLevelConstraintFunc)              \\\n+  f(intx,  InitArrayShortSizeConstraintFunc)            \\\n+  f(int ,  RTMTotalCountIncrRateConstraintFunc)         \\\n+COMPILER2_PRESENT(                                      \\\n+  f(intx,  InteriorEntryAlignmentConstraintFunc)        \\\n+  f(intx,  NodeLimitFudgeFactorConstraintFunc)          \\\n+  f(uintx, LoopStripMiningIterConstraintFunc)           \\\n+)\n+\n+COMPILER_CONSTRAINTS(DECLARE_CONSTRAINT)\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsCompiler.hpp","additions":25,"deletions":42,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"runtime\/flags\/jvmFlagLimit.hpp\"\n@@ -134,0 +135,29 @@\n+\n+JVMFlag::Error VMPageSizeConstraintFunc(uintx value, bool verbose) {\n+  uintx min = (uintx)os::vm_page_size();\n+  if (value < min) {\n+    JVMFlag::printError(verbose,\n+                        \"%s %s=\" UINTX_FORMAT \" is outside the allowed range [ \" UINTX_FORMAT\n+                        \" ... \" UINTX_FORMAT \" ]\\n\",\n+                        JVMFlagLimit::last_checked_flag()->_type,\n+                        JVMFlagLimit::last_checked_flag()->_name,\n+                        value, min, max_uintx);\n+    return JVMFlag::VIOLATES_CONSTRAINT;\n+  }\n+\n+  return JVMFlag::SUCCESS;\n+}\n+\n+JVMFlag::Error NUMAInterleaveGranularityConstraintFunc(size_t value, bool verbose) {\n+  size_t min = os::vm_allocation_granularity();\n+  size_t max = NOT_LP64(2*G) LP64_ONLY(8192*G);\n+\n+  if (value < min || value > max) {\n+    JVMFlag::printError(verbose,\n+                        \"size_t NUMAInterleaveGranularity=\" UINTX_FORMAT \" is outside the allowed range [ \" UINTX_FORMAT\n+                        \" ... \" UINTX_FORMAT \" ]\\n\", value, min, max);\n+    return JVMFlag::VIOLATES_CONSTRAINT;\n+  }\n+\n+  return JVMFlag::SUCCESS;\n+}\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.cpp","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,10 +36,12 @@\n-JVMFlag::Error ObjectAlignmentInBytesConstraintFunc(intx value, bool verbose);\n-\n-JVMFlag::Error ContendedPaddingWidthConstraintFunc(intx value, bool verbose);\n-\n-JVMFlag::Error BiasedLockingBulkRebiasThresholdFunc(intx value, bool verbose);\n-JVMFlag::Error BiasedLockingStartupDelayFunc(intx value, bool verbose);\n-JVMFlag::Error BiasedLockingBulkRevokeThresholdFunc(intx value, bool verbose);\n-JVMFlag::Error BiasedLockingDecayTimeFunc(intx value, bool verbose);\n-\n-JVMFlag::Error PerfDataSamplingIntervalFunc(intx value, bool verbose);\n+#define RUNTIME_CONSTRAINTS(f)                        \\\n+  f(intx,   ObjectAlignmentInBytesConstraintFunc)     \\\n+  f(intx,   ContendedPaddingWidthConstraintFunc)      \\\n+  f(intx,   BiasedLockingBulkRebiasThresholdFunc)     \\\n+  f(intx,   BiasedLockingStartupDelayFunc)            \\\n+  f(intx,   BiasedLockingBulkRevokeThresholdFunc)     \\\n+  f(intx,   BiasedLockingDecayTimeFunc)               \\\n+  f(intx,   PerfDataSamplingIntervalFunc)             \\\n+  f(uintx,  VMPageSizeConstraintFunc)                 \\\n+  f(size_t, NUMAInterleaveGranularityConstraintFunc)\n+\n+RUNTIME_CONSTRAINTS(DECLARE_CONSTRAINT)\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.hpp","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"gc\/shared\/jvmFlagConstraintsGC.hpp\"\n+#include \"runtime\/flags\/jvmFlag.hpp\"\n+#include \"runtime\/flags\/jvmFlagLimit.hpp\"\n+#include \"runtime\/flags\/jvmFlagConstraintList.hpp\"\n+#include \"runtime\/flags\/jvmFlagConstraintsCompiler.hpp\"\n+#include \"runtime\/flags\/jvmFlagConstraintsRuntime.hpp\"\n+#include \"runtime\/flags\/jvmFlagRangeList.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"gc\/shared\/referenceProcessor.hpp\"\n+#include \"oops\/markWord.hpp\"\n+#include \"runtime\/task.hpp\"\n+\n+\/\/----------------------------------------------------------------------\n+\/\/ Build flagLimitTable[]\n+\n+#define CONSTRAINT_ENUM(func)         constraint_enum_ ## func\n+#define CONSTRAINT_ENUM_(type, func)  CONSTRAINT_ENUM(func),\n+#define CONSTRAINT_FUNC(type, func)   (void*)&func,\n+\n+enum JVMFlagConstraintsEnum : int {\n+  ALL_CONSTRAINTS(CONSTRAINT_ENUM_)\n+  NUM_JVMFlagConstraintsEnum\n+};\n+\n+static void* const flagConstraintTable[NUM_JVMFlagConstraintsEnum] = {\n+  ALL_CONSTRAINTS(CONSTRAINT_FUNC)\n+};\n+\n+void* JVMFlagLimit::constraint_func() const {\n+  int i = _constraint_func;\n+  assert(0 <= i && i < NUM_JVMFlagConstraintsEnum, \"sanity\");\n+  return flagConstraintTable[i];\n+}\n+\n+struct DummyLimit {\n+  char dummy;\n+  constexpr DummyLimit(...) : dummy() {}\n+};\n+\n+template <typename T>\n+class LimitGetter {\n+public:\n+  \/\/ These functions return NULL for develop flags in a PRODUCT build\n+  static constexpr const JVMFlagLimit* no_limit(...) {\n+    return NULL;\n+  }\n+\n+  \/\/ This is for flags that have neither range no constraint. We don't need the JVMFlagLimit struct.\n+  static constexpr const JVMFlagLimit* get_limit(const JVMTypedFlagLimit<T>* p, int dummy) {\n+    return NULL;\n+  }\n+\n+  static constexpr const JVMFlagLimit* get_limit(const JVMTypedFlagLimit<T>* p, int dummy, T min, T max) {\n+    return p;\n+  }\n+  static constexpr const JVMFlagLimit* get_limit(const JVMTypedFlagLimit<T>* p, int dummy, ConstraintMarker dummy2, short func, int phase) {\n+    return p;\n+  }\n+  static constexpr const JVMFlagLimit* get_limit(const JVMTypedFlagLimit<T>* p, int dummy, T min, T max, ConstraintMarker dummy2, short func, int phase) {\n+    return p;\n+  }\n+  static constexpr const JVMFlagLimit* get_limit(const JVMTypedFlagLimit<T>* p, int dummy, ConstraintMarker dummy2, short func, int phase, T min, T max) {\n+    return p;\n+  }\n+};\n+\n+\/\/           macro body starts here -------------------+\n+\/\/                                                     |\n+\/\/                                                     v\n+#define FLAG_LIMIT_DEFINE(      type, name, ...)       ); constexpr JVMTypedFlagLimit<type> limit_##name(0\n+#define FLAG_LIMIT_DEFINE_DUMMY(type, name, ...)       ); constexpr DummyLimit nolimit_##name(0\n+#define FLAG_LIMIT_PTR(         type, name, ...)       ), LimitGetter<type>::get_limit(&limit_##name, 0\n+#define FLAG_LIMIT_PTR_NONE(    type, name, ...)       ), LimitGetter<type>::no_limit(0\n+#define APPLY_FLAG_RANGE(...)                          , __VA_ARGS__\n+#define APPLY_FLAG_CONSTRAINT(func, phase)             , next_two_args_are_constraint, (short)CONSTRAINT_ENUM(func), int(JVMFlagConstraint::phase)\n+\n+constexpr JVMTypedFlagLimit<int> limit_dummy\n+(\n+#ifdef PRODUCT\n+ ALL_FLAGS(FLAG_LIMIT_DEFINE_DUMMY,\n+           FLAG_LIMIT_DEFINE_DUMMY,\n+           FLAG_LIMIT_DEFINE,\n+           FLAG_LIMIT_DEFINE,\n+           FLAG_LIMIT_DEFINE_DUMMY,\n+           APPLY_FLAG_RANGE,\n+           APPLY_FLAG_CONSTRAINT)\n+#else\n+ ALL_FLAGS(FLAG_LIMIT_DEFINE,\n+           FLAG_LIMIT_DEFINE,\n+           FLAG_LIMIT_DEFINE,\n+           FLAG_LIMIT_DEFINE,\n+           FLAG_LIMIT_DEFINE,\n+           APPLY_FLAG_RANGE,\n+           APPLY_FLAG_CONSTRAINT)\n+#endif\n+);\n+\n+static constexpr const JVMFlagLimit* const flagLimitTable[1 + NUM_JVMFlagsEnum] = {\n+  \/\/ Because FLAG_LIMIT_PTR must start with an \"),\", we have to place a dummy element here.\n+  LimitGetter<int>::get_limit(NULL, 0\n+\n+#ifdef PRODUCT\n+  ALL_FLAGS(FLAG_LIMIT_PTR_NONE,\n+            FLAG_LIMIT_PTR_NONE,\n+            FLAG_LIMIT_PTR,\n+            FLAG_LIMIT_PTR,\n+            FLAG_LIMIT_PTR_NONE,\n+            APPLY_FLAG_RANGE,\n+            APPLY_FLAG_CONSTRAINT)\n+#else\n+  ALL_FLAGS(FLAG_LIMIT_PTR,\n+            FLAG_LIMIT_PTR,\n+            FLAG_LIMIT_PTR,\n+            FLAG_LIMIT_PTR,\n+            FLAG_LIMIT_PTR,\n+            APPLY_FLAG_RANGE,\n+            APPLY_FLAG_CONSTRAINT)\n+#endif\n+  )\n+};\n+\n+int JVMFlagLimit::_last_checked = -1;\n+\n+const JVMFlagLimit* const* JVMFlagLimit::flagLimits = &flagLimitTable[1]; \/\/ excludes dummy\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagLimit.cpp","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_FLAGS_JVMFLAGLIMIT_HPP\n+#define SHARE_RUNTIME_FLAGS_JVMFLAGLIMIT_HPP\n+\n+#include \"runtime\/flags\/jvmFlag.hpp\"\n+\n+#define ALL_LIMIT_TYPES(f)  \\\n+  f(int)                    \\\n+  f(intx)                   \\\n+  f(uint)                   \\\n+  f(uintx)                  \\\n+  f(uint64_t)               \\\n+  f(size_t)                 \\\n+  f(double)\n+\n+#define ALL_RANGE_TYPES(f) ALL_LIMIT_TYPES(f)\n+#define ALL_CONSTRAINT_TYPES(f) ALL_LIMIT_TYPES(f) f(bool)\n+\n+template <typename T> class JVMTypedFlagLimit;\n+\n+\n+\/\/ A JVMFlagLimit is created for each JVMFlag that has a range() and\/or constraint() in its declaration in\n+\/\/ the globals_xxx.hpp file.\n+\/\/\n+\/\/ To query the range information of a JVMFlag:\n+\/\/     JVMFlagLimit::get_range(JVMFlag*)\n+\/\/     JVMFlagLimit::get_range_at(int flag_enum)\n+\/\/ If the given flag doesn't have a range, NULL is returned.\n+\/\/\n+\/\/ To query the constraint information of a JVMFlag:\n+\/\/     JVMFlagLimit::get_constraint(JVMFlag*)\n+\/\/     JVMFlagLimit::get_constraint_at(int flag_enum)\n+\/\/ If the given flag doesn't have a constraint, NULL is returned.\n+\n+class JVMFlagLimit {\n+  short _constraint_func;\n+  char  _phase;\n+  char  _kind;\n+\n+  static const JVMFlagLimit* const* flagLimits;\n+  static int _last_checked;\n+\n+protected:\n+  static constexpr int HAS_RANGE = 1;\n+  static constexpr int HAS_CONSTRAINT = 2;\n+\n+private:\n+  static const JVMFlagLimit* get_kind_at(int flag_enum, int required_kind) {\n+    const JVMFlagLimit* limit = at(flag_enum);\n+    if (limit != NULL && (limit->_kind & required_kind) != 0) {\n+      _last_checked = flag_enum;\n+      return limit;\n+    } else {\n+      return NULL;\n+    }\n+  }\n+\n+  static const JVMFlagLimit* at(int flag_enum) {\n+    JVMFlag::assert_valid_flag_enum(flag_enum);\n+    return flagLimits[flag_enum];\n+  }\n+\n+public:\n+  void* constraint_func() const;\n+  char phase() const { return _phase; }\n+  char kind()  const { return _kind; }\n+\n+  constexpr JVMFlagLimit(short func, short phase, short kind) : _constraint_func(func), _phase(phase), _kind(kind) {}\n+\n+  static const JVMFlagLimit* get_range(const JVMFlag* flag) {\n+    return get_range_at(flag->flag_enum());\n+  }\n+  static const JVMFlagLimit* get_range_at(int flag_enum) {\n+    return get_kind_at(flag_enum, HAS_RANGE);\n+  }\n+\n+  static const JVMFlagLimit* get_constraint(const JVMFlag* flag) {\n+    return get_constraint_at(flag->flag_enum());\n+  }\n+  static const JVMFlagLimit* get_constraint_at(int flag_enum) {\n+    return get_kind_at(flag_enum, HAS_CONSTRAINT);\n+  }\n+\n+  static const JVMFlag* last_checked_flag() {\n+    if (_last_checked >= 0) {\n+      return JVMFlag::flag_from_enum(_last_checked);\n+    } else {\n+      return NULL;\n+    }\n+  }\n+\n+#define AS_TYPED_LIMIT(type) inline JVMTypedFlagLimit<type>* as_ ## type() const { return (JVMTypedFlagLimit<type>*)this; }\n+  ALL_RANGE_TYPES(AS_TYPED_LIMIT)\n+\n+};\n+\n+enum ConstraintMarker {\n+  next_two_args_are_constraint,\n+};\n+\n+template <typename T>\n+class JVMTypedFlagLimit : public JVMFlagLimit {\n+  const T _min;\n+  const T _max;\n+\n+public:\n+  \/\/ dummy - no range or constraint. This object will not be emitted into the .o file\n+  \/\/ because we declare it as \"const\" but has no reference to it.\n+  constexpr JVMTypedFlagLimit(int dummy) :\n+    JVMFlagLimit(0, 0, 0), _min(0), _max(0) {}\n+\n+  \/\/ range only\n+  constexpr JVMTypedFlagLimit(int dummy, T min, T max) :\n+    JVMFlagLimit(0, 0, HAS_RANGE), _min(min), _max(max) {}\n+\n+  \/\/ constraint only\n+  constexpr JVMTypedFlagLimit(int dummy, ConstraintMarker dummy2, short func, int phase) :\n+    JVMFlagLimit(func, phase, HAS_CONSTRAINT), _min(0), _max(0) {}\n+\n+  \/\/ range and constraint\n+  constexpr JVMTypedFlagLimit(int dummy, T min, T max, ConstraintMarker dummy2, short func, int phase)  :\n+    JVMFlagLimit(func, phase, HAS_RANGE | HAS_CONSTRAINT), _min(min), _max(max) {}\n+\n+  \/\/ constraint and range\n+  constexpr JVMTypedFlagLimit(int dummy, ConstraintMarker dummy2, short func, int phase, T min, T max)  :\n+    JVMFlagLimit(func, phase, HAS_RANGE | HAS_CONSTRAINT), _min(min), _max(max) {}\n+\n+  T min() const { return _min; }\n+  T max() const { return _max; }\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_FLAGS_JVMFLAGLIMIT_HPP\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagLimit.hpp","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/flags\/jvmFlag.hpp\"\n+#include \"runtime\/flags\/jvmFlagLookup.hpp\"\n+#include \"utilities\/defaultStream.hpp\"\n+\n+#define DO_FLAG(type, name,...) DO_HASH(FLAG_MEMBER_ENUM(name), XSTR(name))\n+\n+#define DO_HASH(flag_enum, flag_name) {          \\\n+  unsigned int hash = hash_code(flag_name);      \\\n+  int bucket_index = (int)(hash % NUM_BUCKETS);  \\\n+  _hashes[flag_enum] = (u2)(hash);               \\\n+  _table[flag_enum] = _buckets[bucket_index];    \\\n+  _buckets[bucket_index] = (short)flag_enum;     \\\n+}\n+\n+constexpr JVMFlagLookup::JVMFlagLookup() : _buckets(), _table(), _hashes() {\n+  for (int i = 0; i < NUM_BUCKETS; i++) {\n+    _buckets[i] = -1;\n+  }\n+\n+  ALL_FLAGS(DO_FLAG,\n+            DO_FLAG,\n+            DO_FLAG,\n+            DO_FLAG,\n+            DO_FLAG,\n+            IGNORE_RANGE,\n+            IGNORE_CONSTRAINT)\n+}\n+\n+constexpr JVMFlagLookup _flag_lookup_table;\n+\n+JVMFlag* JVMFlagLookup::find_impl(const char* name, size_t length) const {\n+  unsigned int hash = hash_code(name, length);\n+  int bucket_index = (int)(hash % NUM_BUCKETS);\n+  for (int flag_enum = _buckets[bucket_index]; flag_enum >= 0; ) {\n+    if (_hashes[flag_enum] == (u2)hash) {\n+      JVMFlag* flag = JVMFlag::flags + flag_enum;\n+      if (strncmp(name, flag->_name, length) == 0) {\n+        \/\/ We know flag->_name has at least <length> bytes.\n+        \/\/ Make sure it has exactly <length> bytes\n+        if (flag->_name[length] == 0) {\n+          return flag;\n+        }\n+      }\n+    }\n+    flag_enum = (int)_table[flag_enum];\n+  }\n+\n+  return NULL;\n+}\n+\n+JVMFlag* JVMFlagLookup::find(const char* name, size_t length) {\n+  return _flag_lookup_table.find_impl(name, length);\n+}\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagLookup.cpp","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_FLAGS_JVMFLAGLOOKUP_HPP\n+#define SHARE_RUNTIME_FLAGS_JVMFLAGLOOKUP_HPP\n+\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"runtime\/flags\/jvmFlag.hpp\"\n+\n+\/\/ This is a hashtable that maps from (const char*) to (JVMFlag*) to speed up\n+\/\/ the processing of JVM command-line arguments at runtime.\n+\/\/\n+\/\/ With constexpr, this table is generated at C++ compile time so there's\n+\/\/ no set up cost at runtime.\n+class JVMFlagLookup {\n+  static constexpr int NUM_BUCKETS = 277;\n+  short _buckets[NUM_BUCKETS];\n+  short _table[NUM_JVMFlagsEnum];\n+  u2    _hashes[NUM_JVMFlagsEnum];\n+\n+  \/\/ Cannot use strlen() -- it's not constexpr.\n+  static constexpr size_t string_len(const char* s) {\n+    size_t len = 0;\n+    while (*s != 0) {\n+      len++;\n+      s++;\n+    }\n+    return len;\n+  }\n+\n+  \/\/ This is executed at build-time only, so it doesn't matter if we walk\n+  \/\/ the string twice.\n+  static constexpr unsigned int hash_code(const char* s) {\n+    return hash_code(s, string_len(s));\n+  }\n+\n+  static constexpr unsigned int hash_code(const char* s, size_t len) {\n+    unsigned int h = 0;\n+    while (len -- > 0) {\n+      h = 31*h + (unsigned int) *s;\n+      s++;\n+    }\n+    return h;\n+  }\n+\n+  JVMFlag* find_impl(const char* flag_name, size_t length) const;\n+\n+public:\n+  constexpr JVMFlagLookup();\n+  static JVMFlag* find(const char* flag_name, size_t length);\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_FLAGS_JVMFLAGLOOKUP_HPP\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagLookup.hpp","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/flags\/jvmFlagConstraintsRuntime.hpp\"\n@@ -244,36 +245,5 @@\n-\/\/ No constraint emitting\n-void emit_range_no(...)                         { \/* NOP *\/ }\n-\n-\/\/ No constraint emitting if function argument is NOT provided\n-void emit_range_bool(const JVMFlag* \/*flag*\/)      { \/* NOP *\/ }\n-void emit_range_ccstr(const JVMFlag* \/*flag*\/)     { \/* NOP *\/ }\n-void emit_range_ccstrlist(const JVMFlag* \/*flag*\/) { \/* NOP *\/ }\n-void emit_range_int(const JVMFlag* \/*flag*\/)       { \/* NOP *\/ }\n-void emit_range_intx(const JVMFlag* \/*flag*\/)      { \/* NOP *\/ }\n-void emit_range_uint(const JVMFlag* \/*flag*\/)      { \/* NOP *\/ }\n-void emit_range_uintx(const JVMFlag* \/*flag*\/)     { \/* NOP *\/ }\n-void emit_range_uint64_t(const JVMFlag* \/*flag*\/)  { \/* NOP *\/ }\n-void emit_range_size_t(const JVMFlag* \/*flag*\/)    { \/* NOP *\/ }\n-void emit_range_double(const JVMFlag* \/*flag*\/)    { \/* NOP *\/ }\n-\n-\/\/ JVMFlagRange emitting code functions if range arguments are provided\n-void emit_range_int(const JVMFlag* flag, int min, int max)       {\n-  JVMFlagRangeList::add(new JVMFlagRange_int(flag, min, max));\n-}\n-void emit_range_intx(const JVMFlag* flag, intx min, intx max) {\n-  JVMFlagRangeList::add(new JVMFlagRange_intx(flag, min, max));\n-}\n-void emit_range_uint(const JVMFlag* flag, uint min, uint max) {\n-  JVMFlagRangeList::add(new JVMFlagRange_uint(flag, min, max));\n-}\n-void emit_range_uintx(const JVMFlag* flag, uintx min, uintx max) {\n-  JVMFlagRangeList::add(new JVMFlagRange_uintx(flag, min, max));\n-}\n-void emit_range_uint64_t(const JVMFlag* flag, uint64_t min, uint64_t max) {\n-  JVMFlagRangeList::add(new JVMFlagRange_uint64_t(flag, min, max));\n-}\n-void emit_range_size_t(const JVMFlag* flag, size_t min, size_t max) {\n-  JVMFlagRangeList::add(new JVMFlagRange_size_t(flag, min, max));\n-}\n-void emit_range_double(const JVMFlag* flag, double min, double max) {\n-  JVMFlagRangeList::add(new JVMFlagRange_double(flag, min, max));\n+#define DEFINE_RANGE_CHECK(T)                                                            \\\n+JVMFlag::Error JVMFlagRangeChecker::check_ ## T(T value, bool verbose) const {           \\\n+  assert(exists(), \"must be\");                                                           \\\n+  JVMFlagRange_ ## T range(_flag, _limit->as_ ## T()->min(), _limit->as_ ## T()->max()); \\\n+  return range.check_ ## T(value, verbose);                                              \\\n@@ -282,55 +252,14 @@\n-\/\/ Generate code to call emit_range_xxx function\n-#define EMIT_RANGE_START       (void)(0\n-#define EMIT_RANGE(type, name) ); emit_range_##type(JVMFlagEx::flag_from_enum(FLAG_MEMBER_ENUM(name))\n-#define EMIT_RANGE_NO          ); emit_range_no(0\n-#define EMIT_RANGE_PRODUCT_FLAG(type, name, value, doc)      EMIT_RANGE(type, name)\n-#define EMIT_RANGE_DIAGNOSTIC_FLAG(type, name, value, doc)   EMIT_RANGE(type, name)\n-#define EMIT_RANGE_EXPERIMENTAL_FLAG(type, name, value, doc) EMIT_RANGE(type, name)\n-#define EMIT_RANGE_MANAGEABLE_FLAG(type, name, value, doc)   EMIT_RANGE(type, name)\n-#define EMIT_RANGE_PRODUCT_RW_FLAG(type, name, value, doc)   EMIT_RANGE(type, name)\n-#define EMIT_RANGE_PD_PRODUCT_FLAG(type, name, doc)          EMIT_RANGE(type, name)\n-#define EMIT_RANGE_PD_DIAGNOSTIC_FLAG(type, name, doc)       EMIT_RANGE(type, name)\n-#ifndef PRODUCT\n-#define EMIT_RANGE_DEVELOPER_FLAG(type, name, value, doc)    EMIT_RANGE(type, name)\n-#define EMIT_RANGE_PD_DEVELOPER_FLAG(type, name, doc)        EMIT_RANGE(type, name)\n-#define EMIT_RANGE_NOTPRODUCT_FLAG(type, name, value, doc)   EMIT_RANGE(type, name)\n-#else\n-#define EMIT_RANGE_DEVELOPER_FLAG(type, name, value, doc)    EMIT_RANGE_NO\n-#define EMIT_RANGE_PD_DEVELOPER_FLAG(type, name, doc)        EMIT_RANGE_NO\n-#define EMIT_RANGE_NOTPRODUCT_FLAG(type, name, value, doc)   EMIT_RANGE_NO\n-#endif\n-#ifdef _LP64\n-#define EMIT_RANGE_LP64_PRODUCT_FLAG(type, name, value, doc) EMIT_RANGE(type, name)\n-#else\n-#define EMIT_RANGE_LP64_PRODUCT_FLAG(type, name, value, doc) EMIT_RANGE_NO\n-#endif\n-#define EMIT_RANGE_END         );\n-\n-\/\/ Generate func argument to pass into emit_range_xxx functions\n-#define EMIT_RANGE_CHECK(a, b)                               , a, b\n-\n-#define INITIAL_RANGES_SIZE 379\n-GrowableArray<JVMFlagRange*>* JVMFlagRangeList::_ranges = NULL;\n-\n-\/\/ Check the ranges of all flags that have them\n-void JVMFlagRangeList::init(void) {\n-\n-  _ranges = new (ResourceObj::C_HEAP, mtArguments) GrowableArray<JVMFlagRange*>(INITIAL_RANGES_SIZE, mtArguments);\n-\n-  EMIT_RANGE_START\n-\n-  ALL_FLAGS(EMIT_RANGE_DEVELOPER_FLAG,\n-            EMIT_RANGE_PD_DEVELOPER_FLAG,\n-            EMIT_RANGE_PRODUCT_FLAG,\n-            EMIT_RANGE_PD_PRODUCT_FLAG,\n-            EMIT_RANGE_DIAGNOSTIC_FLAG,\n-            EMIT_RANGE_PD_DIAGNOSTIC_FLAG,\n-            EMIT_RANGE_EXPERIMENTAL_FLAG,\n-            EMIT_RANGE_NOTPRODUCT_FLAG,\n-            EMIT_RANGE_MANAGEABLE_FLAG,\n-            EMIT_RANGE_PRODUCT_RW_FLAG,\n-            EMIT_RANGE_LP64_PRODUCT_FLAG,\n-            EMIT_RANGE_CHECK,\n-            IGNORE_CONSTRAINT)\n-\n-  EMIT_RANGE_END\n+ALL_RANGE_TYPES(DEFINE_RANGE_CHECK)\n+\n+\n+JVMFlag::Error JVMFlagRangeChecker::check(bool verbose) const {\n+#define CHECK_RANGE(T)                                                                     \\\n+  if (_flag->is_ ## T()) {                                                                 \\\n+    JVMFlagRange_ ## T range(_flag, _limit->as_ ## T()->min(), _limit->as_ ## T()->max()); \\\n+    return range.check(verbose);                                                           \\\n+  }\n+\n+  ALL_RANGE_TYPES(CHECK_RANGE);\n+\n+  ShouldNotReachHere();\n+  return JVMFlag::INVALID_FLAG;\n@@ -339,8 +268,6 @@\n-JVMFlagRange* JVMFlagRangeList::find(const JVMFlag* flag) {\n-  JVMFlagRange* found = NULL;\n-  for (int i=0; i<length(); i++) {\n-    JVMFlagRange* range = at(i);\n-    if (range->flag() == flag) {\n-      found = range;\n-      break;\n-    }\n+void JVMFlagRangeChecker::print(outputStream* out) const {\n+#define PRINT_RANGE(T)                                                                     \\\n+  if (_flag->is_ ## T()) {                                                                 \\\n+    JVMFlagRange_ ## T range(_flag, _limit->as_ ## T()->min(), _limit->as_ ## T()->max()); \\\n+    range.print(out);                                                                      \\\n+    return;                                                                                \\\n@@ -348,1 +275,4 @@\n-  return found;\n+\n+  ALL_RANGE_TYPES(PRINT_RANGE);\n+\n+  ShouldNotReachHere();\n@@ -352,3 +282,3 @@\n-  JVMFlagRange* range = JVMFlagRangeList::find(flag);\n-  if (range != NULL) {\n-    range->print(st);\n+  JVMFlagRangeChecker range = JVMFlagRangeList::find(flag);\n+  if (range.exists()) {\n+    range.print(st);\n@@ -356,4 +286,22 @@\n-    JVMFlagConstraint* constraint = JVMFlagConstraintList::find(flag);\n-    if (constraint != NULL) {\n-      assert(default_range_str_func!=NULL, \"default_range_str_func must be provided\");\n-      st->print(\"%s\", default_range_str_func());\n+    const JVMFlagLimit* limit = JVMFlagLimit::get_constraint(flag);\n+    if (limit != NULL) {\n+      void* func = limit->constraint_func();\n+\n+      \/\/ Two special cases where the lower limit of the range is defined by an os:: function call\n+      \/\/ and cannot be initialized at compile time with constexpr.\n+      if (func == (void*)VMPageSizeConstraintFunc) {\n+        uintx min = (uintx)os::vm_page_size();\n+        uintx max = max_uintx;\n+\n+        JVMFlagRange_uintx tmp(flag, min, max);\n+        tmp.print(st);\n+      } else if (func == (void*)NUMAInterleaveGranularityConstraintFunc) {\n+        size_t min = os::vm_allocation_granularity();\n+        size_t max = NOT_LP64(2*G) LP64_ONLY(8192*G);\n+\n+        JVMFlagRange_size_t tmp(flag, min, max);\n+        tmp.print(st);\n+      } else {\n+        assert(default_range_str_func!=NULL, \"default_range_str_func must be provided\");\n+        st->print(\"%s\", default_range_str_func());\n+      }\n@@ -368,3 +316,3 @@\n-  for (int i=0; i<length(); i++) {\n-    JVMFlagRange* range = at(i);\n-    if (range->check(true) != JVMFlag::SUCCESS) status = false;\n+  for (int i = 0; i < NUM_JVMFlagsEnum; i++) {\n+    JVMFlagRangeChecker range(&JVMFlag::flags[i], JVMFlagLimit::get_range_at(i));\n+    if (range.exists() && range.check(true) != JVMFlag::SUCCESS) status = false;\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagRangeList.cpp","additions":58,"deletions":110,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"utilities\/growableArray.hpp\"\n+#include \"runtime\/flags\/jvmFlagLimit.hpp\"\n@@ -61,0 +61,14 @@\n+class JVMFlagRangeChecker {\n+  const JVMFlag* _flag;\n+  const JVMFlagLimit* _limit;\n+\n+public:\n+  JVMFlagRangeChecker(const JVMFlag* flag, const JVMFlagLimit* limit) : _flag(flag), _limit(limit) {}\n+  bool exists() const { return _limit != NULL; }\n+  JVMFlag::Error check(bool verbose = true) const;\n+  void print(outputStream* st) const;\n+\n+#define DECLARE_RANGE_CHECK(T) JVMFlag::Error check_ ## T(T new_value, bool verbose = true) const;\n+  ALL_RANGE_TYPES(DECLARE_RANGE_CHECK)\n+};\n+\n@@ -62,1 +76,0 @@\n-  static GrowableArray<JVMFlagRange*>* _ranges;\n@@ -64,5 +77,1 @@\n-  static void init();\n-  static int length() { return (_ranges != NULL) ? _ranges->length() : 0; }\n-  static JVMFlagRange* at(int i) { return (_ranges != NULL) ? _ranges->at(i) : NULL; }\n-  static JVMFlagRange* find(const JVMFlag* flag);\n-  static void add(JVMFlagRange* range) { _ranges->append(range); }\n+  static JVMFlagRangeChecker find(const JVMFlag* flag) { return JVMFlagRangeChecker(flag, JVMFlagLimit::get_range(flag)); }\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagRangeList.hpp","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -43,7 +43,2 @@\n-#define MATERIALIZE_PRODUCT_FLAG(type, name, value, doc)      type name = value;\n-#define MATERIALIZE_PD_PRODUCT_FLAG(type, name, doc)          type name = pd_##name;\n-#define MATERIALIZE_DIAGNOSTIC_FLAG(type, name, value, doc)   type name = value;\n-#define MATERIALIZE_PD_DIAGNOSTIC_FLAG(type, name, doc)       type name = pd_##name;\n-#define MATERIALIZE_EXPERIMENTAL_FLAG(type, name, value, doc) type name = value;\n-#define MATERIALIZE_MANAGEABLE_FLAG(type, name, value, doc)   type name = value;\n-#define MATERIALIZE_PRODUCT_RW_FLAG(type, name, value, doc)   type name = value;\n+#define MATERIALIZE_PRODUCT_FLAG(type, name, value, ...)      type name = value;\n+#define MATERIALIZE_PD_PRODUCT_FLAG(type, name, ...)          type name = pd_##name;\n@@ -51,3 +46,3 @@\n-#define MATERIALIZE_DEVELOPER_FLAG(type, name, value, doc)\n-#define MATERIALIZE_PD_DEVELOPER_FLAG(type, name, doc)\n-#define MATERIALIZE_NOTPRODUCT_FLAG(type, name, value, doc)\n+#define MATERIALIZE_DEVELOPER_FLAG(type, name, value, ...)\n+#define MATERIALIZE_PD_DEVELOPER_FLAG(type, name, ...)\n+#define MATERIALIZE_NOTPRODUCT_FLAG(type, name, value, ...)\n@@ -55,3 +50,3 @@\n-#define MATERIALIZE_DEVELOPER_FLAG(type, name, value, doc)    type name = value;\n-#define MATERIALIZE_PD_DEVELOPER_FLAG(type, name, doc)        type name = pd_##name;\n-#define MATERIALIZE_NOTPRODUCT_FLAG(type, name, value, doc)   type name = value;\n+#define MATERIALIZE_DEVELOPER_FLAG(type, name, value, ...)    type name = value;\n+#define MATERIALIZE_PD_DEVELOPER_FLAG(type, name, ...)        type name = pd_##name;\n+#define MATERIALIZE_NOTPRODUCT_FLAG(type, name, value, ...)   type name = value;\n@@ -59,6 +54,0 @@\n-#ifdef _LP64\n-#define MATERIALIZE_LP64_PRODUCT_FLAG(type, name, value, doc) type name = value;\n-#else\n-#define MATERIALIZE_LP64_PRODUCT_FLAG(type, name, value, doc) \/* flag is constant *\/\n-#endif \/\/ _LP64\n-\n@@ -66,12 +55,6 @@\n-ALL_FLAGS(MATERIALIZE_DEVELOPER_FLAG,     \\\n-          MATERIALIZE_PD_DEVELOPER_FLAG,  \\\n-          MATERIALIZE_PRODUCT_FLAG,       \\\n-          MATERIALIZE_PD_PRODUCT_FLAG,    \\\n-          MATERIALIZE_DIAGNOSTIC_FLAG,    \\\n-          MATERIALIZE_PD_DIAGNOSTIC_FLAG, \\\n-          MATERIALIZE_EXPERIMENTAL_FLAG,  \\\n-          MATERIALIZE_NOTPRODUCT_FLAG,    \\\n-          MATERIALIZE_MANAGEABLE_FLAG,    \\\n-          MATERIALIZE_PRODUCT_RW_FLAG,    \\\n-          MATERIALIZE_LP64_PRODUCT_FLAG,  \\\n-          IGNORE_RANGE,                   \\\n+ALL_FLAGS(MATERIALIZE_DEVELOPER_FLAG,\n+          MATERIALIZE_PD_DEVELOPER_FLAG,\n+          MATERIALIZE_PRODUCT_FLAG,\n+          MATERIALIZE_PD_PRODUCT_FLAG,\n+          MATERIALIZE_NOTPRODUCT_FLAG,\n+          IGNORE_RANGE,\n","filename":"src\/hotspot\/share\/runtime\/globals.cpp","additions":14,"deletions":31,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -41,0 +41,10 @@\n+\/\/ develop_pd\/product_pd flags are the same as develop\/product, except that their default values\n+\/\/ are specified in platform-dependent header files.\n+\n+\/\/ Flags must be declared with the following number of parameters:\n+\/\/ non-pd flags:\n+\/\/    (type, name, default_value, doc), or\n+\/\/    (type, name, default_value, extra_attrs, doc)\n+\/\/ pd flags:\n+\/\/    (type, name, doc), or\n+\/\/    (type, name, extra_attrs, doc)\n@@ -47,9 +57,13 @@\n-\/\/ Note: Diagnostic options not meant for VM tuning or for product modes.\n-\/\/ They are to be used for VM quality assurance or field diagnosis\n-\/\/ of VM bugs.  They are hidden so that users will not be encouraged to\n-\/\/ try them as if they were VM ordinary execution options.  However, they\n-\/\/ are available in the product version of the VM.  Under instruction\n-\/\/ from support engineers, VM customers can turn them on to collect\n-\/\/ diagnostic information about VM problems.  To use a VM diagnostic\n-\/\/ option, you must first specify +UnlockDiagnosticVMOptions.\n-\/\/ (This master switch also affects the behavior of -Xprintflags.)\n+\/\/ The optional extra_attrs parameter may have one of the following values:\n+\/\/ DIAGNOSTIC, EXPERIMENTAL, or MANAGEABLE. Currently extra_attrs can be used\n+\/\/ only with product\/product_pd flags.\n+\/\/\n+\/\/ DIAGNOSTIC options are not meant for VM tuning or for product modes.\n+\/\/    They are to be used for VM quality assurance or field diagnosis\n+\/\/    of VM bugs.  They are hidden so that users will not be encouraged to\n+\/\/    try them as if they were VM ordinary execution options.  However, they\n+\/\/    are available in the product version of the VM.  Under instruction\n+\/\/    from support engineers, VM customers can turn them on to collect\n+\/\/    diagnostic information about VM problems.  To use a VM diagnostic\n+\/\/    option, you must first specify +UnlockDiagnosticVMOptions.\n+\/\/    (This master switch also affects the behavior of -Xprintflags.)\n@@ -57,1 +71,1 @@\n-\/\/ experimental flags are in support of features that are not\n+\/\/ EXPERIMENTAL flags are in support of features that are not\n@@ -73,1 +87,1 @@\n-\/\/ manageable flags are writeable external product flags.\n+\/\/ MANAGEABLE flags are writeable external product flags.\n@@ -87,14 +101,1 @@\n-\/\/ product_rw flags are writeable internal product flags.\n-\/\/    They are like \"manageable\" flags but for internal\/private use.\n-\/\/    The list of product_rw flags are internal\/private flags which\n-\/\/    may be changed\/removed in a future release.  It can be set\n-\/\/    through the management interface to get\/set value\n-\/\/    when the name of flag is supplied.\n-\/\/\n-\/\/    A flag can be made as \"product_rw\" only if\n-\/\/    - the VM implementation supports dynamic setting of the flag.\n-\/\/      This implies that the VM must *always* query the flag variable\n-\/\/      and not reuse state related to the flag state at any given time.\n-\/\/\n-\/\/ Note that when there is a need to support develop flags to be writeable,\n-\/\/ it can be done in the same way as product_rw.\n+\n@@ -115,15 +116,10 @@\n-#define RUNTIME_FLAGS(develop, \\\n-                      develop_pd, \\\n-                      product, \\\n-                      product_pd, \\\n-                      diagnostic, \\\n-                      diagnostic_pd, \\\n-                      experimental, \\\n-                      notproduct, \\\n-                      manageable, \\\n-                      product_rw, \\\n-                      lp64_product, \\\n-                      range, \\\n-                      constraint) \\\n-                                                                            \\\n-  lp64_product(bool, UseCompressedOops, false,                              \\\n+#ifdef _LP64\n+#define LP64_RUNTIME_FLAGS(develop,                                         \\\n+                           develop_pd,                                      \\\n+                           product,                                         \\\n+                           product_pd,                                      \\\n+                           notproduct,                                      \\\n+                           range,                                           \\\n+                           constraint)                                      \\\n+                                                                            \\\n+  product(bool, UseCompressedOops, false,                                   \\\n@@ -133,1 +129,1 @@\n-  lp64_product(bool, UseCompressedClassPointers, false,                     \\\n+  product(bool, UseCompressedClassPointers, false,                          \\\n@@ -137,0 +133,29 @@\n+  product(intx, ObjectAlignmentInBytes, 8,                                  \\\n+          \"Default object alignment in bytes, 8 is minimum\")                \\\n+          range(8, 256)                                                     \\\n+          constraint(ObjectAlignmentInBytesConstraintFunc, AtParse)\n+\n+#else\n+\/\/ !_LP64\n+\n+#define LP64_RUNTIME_FLAGS(develop,                                         \\\n+                           develop_pd,                                      \\\n+                           product,                                         \\\n+                           product_pd,                                      \\\n+                           notproduct,                                      \\\n+                           range,                                           \\\n+                           constraint)\n+const bool UseCompressedOops = false;\n+const bool UseCompressedClassPointers = false;\n+const intx ObjectAlignmentInBytes = 8;\n+\n+#endif \/\/ _LP64\n+\n+#define RUNTIME_FLAGS(develop,                                              \\\n+                      develop_pd,                                           \\\n+                      product,                                              \\\n+                      product_pd,                                           \\\n+                      notproduct,                                           \\\n+                      range,                                                \\\n+                      constraint)                                           \\\n+                                                                            \\\n@@ -146,5 +171,0 @@\n-  lp64_product(intx, ObjectAlignmentInBytes, 8,                             \\\n-          \"Default object alignment in bytes, 8 is minimum\")                \\\n-          range(8, 256)                                                     \\\n-          constraint(ObjectAlignmentInBytesConstraintFunc,AtParse)          \\\n-                                                                            \\\n@@ -154,1 +174,1 @@\n-  diagnostic(uint, HandshakeTimeout, 0,                                     \\\n+  product(uint, HandshakeTimeout, 0, DIAGNOSTIC,                            \\\n@@ -157,1 +177,1 @@\n-  experimental(bool, AlwaysSafeConstructors, false,                         \\\n+  product(bool, AlwaysSafeConstructors, false, EXPERIMENTAL,                \\\n@@ -160,1 +180,1 @@\n-  diagnostic(bool, UnlockDiagnosticVMOptions, trueInDebug,                  \\\n+  product(bool, UnlockDiagnosticVMOptions, trueInDebug, DIAGNOSTIC,         \\\n@@ -163,1 +183,1 @@\n-  experimental(bool, UnlockExperimentalVMOptions, false,                    \\\n+  product(bool, UnlockExperimentalVMOptions, false, EXPERIMENTAL,           \\\n@@ -192,1 +212,1 @@\n-          range(os::vm_allocation_granularity(), NOT_LP64(2*G) LP64_ONLY(8192*G)) \\\n+          constraint(NUMAInterleaveGranularityConstraintFunc, AtParse)      \\\n@@ -223,1 +243,1 @@\n-  diagnostic(bool, UseGHASHIntrinsics, false,                               \\\n+  product(bool, UseGHASHIntrinsics, false, DIAGNOSTIC,                      \\\n@@ -250,1 +270,1 @@\n-  diagnostic(bool, SafepointALot, false,                                    \\\n+  product(bool, SafepointALot, false, DIAGNOSTIC,                           \\\n@@ -254,1 +274,1 @@\n-  diagnostic(bool, HandshakeALot, false,                                    \\\n+  product(bool, HandshakeALot, false, DIAGNOSTIC,                           \\\n@@ -268,1 +288,1 @@\n-  diagnostic(bool, ForceUnreachable, false,                                 \\\n+  product(bool, ForceUnreachable, false, DIAGNOSTIC,                        \\\n@@ -288,1 +308,1 @@\n-  diagnostic(bool, InlineArrayCopy, true,                                   \\\n+  product(bool, InlineArrayCopy, true, DIAGNOSTIC,                          \\\n@@ -292,1 +312,1 @@\n-  diagnostic(bool, InlineObjectHash, true,                                  \\\n+  product(bool, InlineObjectHash, true, DIAGNOSTIC,                         \\\n@@ -296,1 +316,1 @@\n-  diagnostic(bool, InlineNatives, true,                                     \\\n+  product(bool, InlineNatives, true, DIAGNOSTIC,                            \\\n@@ -299,1 +319,1 @@\n-  diagnostic(bool, InlineMathNatives, true,                                 \\\n+  product(bool, InlineMathNatives, true, DIAGNOSTIC,                        \\\n@@ -302,1 +322,1 @@\n-  diagnostic(bool, InlineClassNatives, true,                                \\\n+  product(bool, InlineClassNatives, true, DIAGNOSTIC,                       \\\n@@ -305,1 +325,1 @@\n-  diagnostic(bool, InlineThreadNatives, true,                               \\\n+  product(bool, InlineThreadNatives, true, DIAGNOSTIC,                      \\\n@@ -308,1 +328,1 @@\n-  diagnostic(bool, InlineUnsafeOps, true,                                   \\\n+  product(bool, InlineUnsafeOps, true, DIAGNOSTIC,                          \\\n@@ -317,1 +337,1 @@\n-  diagnostic(bool, UseAESIntrinsics, false,                                 \\\n+  product(bool, UseAESIntrinsics, false, DIAGNOSTIC,                        \\\n@@ -320,1 +340,1 @@\n-  diagnostic(bool, UseAESCTRIntrinsics, false,                              \\\n+  product(bool, UseAESCTRIntrinsics, false, DIAGNOSTIC,                     \\\n@@ -323,1 +343,1 @@\n-  diagnostic(bool, UseMD5Intrinsics, false,                                 \\\n+  product(bool, UseMD5Intrinsics, false, DIAGNOSTIC,                        \\\n@@ -326,1 +346,1 @@\n-  diagnostic(bool, UseSHA1Intrinsics, false,                                \\\n+  product(bool, UseSHA1Intrinsics, false, DIAGNOSTIC,                       \\\n@@ -330,1 +350,1 @@\n-  diagnostic(bool, UseSHA256Intrinsics, false,                              \\\n+  product(bool, UseSHA256Intrinsics, false, DIAGNOSTIC,                     \\\n@@ -334,1 +354,1 @@\n-  diagnostic(bool, UseSHA512Intrinsics, false,                              \\\n+  product(bool, UseSHA512Intrinsics, false, DIAGNOSTIC,                     \\\n@@ -338,1 +358,1 @@\n-  diagnostic(bool, UseCRC32Intrinsics, false,                               \\\n+  product(bool, UseCRC32Intrinsics, false, DIAGNOSTIC,                      \\\n@@ -341,1 +361,1 @@\n-  diagnostic(bool, UseCRC32CIntrinsics, false,                              \\\n+  product(bool, UseCRC32CIntrinsics, false, DIAGNOSTIC,                     \\\n@@ -344,1 +364,1 @@\n-  diagnostic(bool, UseAdler32Intrinsics, false,                             \\\n+  product(bool, UseAdler32Intrinsics, false, DIAGNOSTIC,                    \\\n@@ -347,1 +367,1 @@\n-  diagnostic(bool, UseVectorizedMismatchIntrinsic, false,                   \\\n+  product(bool, UseVectorizedMismatchIntrinsic, false, DIAGNOSTIC,          \\\n@@ -350,1 +370,1 @@\n-  diagnostic(bool, UseCopySignIntrinsic, false,                             \\\n+  product(bool, UseCopySignIntrinsic, false, DIAGNOSTIC,                    \\\n@@ -353,1 +373,1 @@\n-  diagnostic(bool, UseSignumIntrinsic, false,                               \\\n+  product(bool, UseSignumIntrinsic, false, DIAGNOSTIC,                      \\\n@@ -356,1 +376,1 @@\n-  diagnostic(ccstrlist, DisableIntrinsic, \"\",                               \\\n+  product(ccstrlist, DisableIntrinsic, \"\", DIAGNOSTIC,                      \\\n@@ -359,1 +379,1 @@\n-  diagnostic(ccstrlist, ControlIntrinsic, \"\",                               \\\n+  product(ccstrlist, ControlIntrinsic, \"\", DIAGNOSTIC,                      \\\n@@ -392,1 +412,1 @@\n-  diagnostic(bool, AbortVMOnSafepointTimeout, false,                        \\\n+  product(bool, AbortVMOnSafepointTimeout, false, DIAGNOSTIC,               \\\n@@ -395,1 +415,1 @@\n-  diagnostic(bool, AbortVMOnVMOperationTimeout, false,                      \\\n+  product(bool, AbortVMOnVMOperationTimeout, false, DIAGNOSTIC,             \\\n@@ -398,1 +418,1 @@\n-  diagnostic(intx, AbortVMOnVMOperationTimeoutDelay, 1000,                  \\\n+  product(intx, AbortVMOnVMOperationTimeoutDelay, 1000, DIAGNOSTIC,         \\\n@@ -421,1 +441,1 @@\n-  diagnostic(bool, LogEvents, true,                                         \\\n+  product(bool, LogEvents, true, DIAGNOSTIC,                                \\\n@@ -424,1 +444,1 @@\n-  diagnostic(uintx, LogEventsBufferEntries, 20,                             \\\n+  product(uintx, LogEventsBufferEntries, 20, DIAGNOSTIC,                    \\\n@@ -428,1 +448,1 @@\n-  diagnostic(bool, BytecodeVerificationRemote, true,                        \\\n+  product(bool, BytecodeVerificationRemote, true, DIAGNOSTIC,               \\\n@@ -431,1 +451,1 @@\n-  diagnostic(bool, BytecodeVerificationLocal, false,                        \\\n+  product(bool, BytecodeVerificationLocal, false, DIAGNOSTIC,               \\\n@@ -518,1 +538,1 @@\n-  manageable(bool, HeapDumpBeforeFullGC, false,                             \\\n+  product(bool, HeapDumpBeforeFullGC, false, MANAGEABLE,                    \\\n@@ -521,1 +541,1 @@\n-  manageable(bool, HeapDumpAfterFullGC, false,                              \\\n+  product(bool, HeapDumpAfterFullGC, false, MANAGEABLE,                     \\\n@@ -524,1 +544,1 @@\n-  manageable(bool, HeapDumpOnOutOfMemoryError, false,                       \\\n+  product(bool, HeapDumpOnOutOfMemoryError, false, MANAGEABLE,              \\\n@@ -527,1 +547,1 @@\n-  manageable(ccstr, HeapDumpPath, NULL,                                     \\\n+  product(ccstr, HeapDumpPath, NULL, MANAGEABLE,                            \\\n@@ -538,1 +558,1 @@\n-  diagnostic(bool, PrintNMTStatistics, false,                               \\\n+  product(bool, PrintNMTStatistics, false, DIAGNOSTIC,                      \\\n@@ -541,1 +561,1 @@\n-  diagnostic(bool, LogCompilation, false,                                   \\\n+  product(bool, LogCompilation, false, DIAGNOSTIC,                          \\\n@@ -547,1 +567,1 @@\n-  diagnostic(intx, RepeatCompilation, 0,                                    \\\n+  product(intx, RepeatCompilation, 0, DIAGNOSTIC,                           \\\n@@ -549,1 +569,1 @@\n-          range(0, max_jint)                                                 \\\n+          range(0, max_jint)                                                \\\n@@ -554,1 +574,1 @@\n-  diagnostic(intx, ScavengeRootsInCode, 2,                                  \\\n+  product(intx, ScavengeRootsInCode, 2, DIAGNOSTIC,                         \\\n@@ -563,1 +583,1 @@\n-  diagnostic(bool, PrintCompilation2, false,                                \\\n+  product(bool, PrintCompilation2, false, DIAGNOSTIC,                       \\\n@@ -566,1 +586,1 @@\n-  diagnostic(bool, PrintAdapterHandlers, false,                             \\\n+  product(bool, PrintAdapterHandlers, false, DIAGNOSTIC,                    \\\n@@ -569,1 +589,1 @@\n-  diagnostic(bool, VerifyAdapterCalls, trueInDebug,                         \\\n+  product(bool, VerifyAdapterCalls, trueInDebug, DIAGNOSTIC,                \\\n@@ -575,1 +595,1 @@\n-  diagnostic(bool, PrintAssembly, false,                                    \\\n+  product(bool, PrintAssembly, false, DIAGNOSTIC,                           \\\n@@ -578,1 +598,1 @@\n-  diagnostic(ccstr, PrintAssemblyOptions, NULL,                             \\\n+  product(ccstr, PrintAssemblyOptions, NULL, DIAGNOSTIC,                    \\\n@@ -584,1 +604,1 @@\n-  diagnostic(bool, PrintNMethods, false,                                    \\\n+  product(bool, PrintNMethods, false, DIAGNOSTIC,                           \\\n@@ -587,1 +607,1 @@\n-  diagnostic(bool, PrintNativeNMethods, false,                              \\\n+  product(bool, PrintNativeNMethods, false, DIAGNOSTIC,                     \\\n@@ -619,1 +639,1 @@\n-  diagnostic(bool, PrintCodeHeapAnalytics, false,                           \\\n+  product(bool, PrintCodeHeapAnalytics, false, DIAGNOSTIC,                  \\\n@@ -622,1 +642,1 @@\n-  diagnostic(bool, PrintStubCode, false,                                    \\\n+  product(bool, PrintStubCode, false, DIAGNOSTIC,                           \\\n@@ -631,1 +651,1 @@\n-  manageable(bool, ShowCodeDetailsInExceptionMessages, true,                \\\n+  product(bool, ShowCodeDetailsInExceptionMessages, true, MANAGEABLE,       \\\n@@ -678,1 +698,1 @@\n-  diagnostic(bool, DynamicallyResizeSystemDictionaries, true,               \\\n+  product(bool, DynamicallyResizeSystemDictionaries, true, DIAGNOSTIC,      \\\n@@ -693,1 +713,1 @@\n-  experimental(bool, DisablePrimordialThreadGuardPages, false,              \\\n+  product(bool, DisablePrimordialThreadGuardPages, false, EXPERIMENTAL,     \\\n@@ -699,1 +719,1 @@\n-  diagnostic(intx, AsyncDeflationInterval, 250,                             \\\n+  product(intx, AsyncDeflationInterval, 250, DIAGNOSTIC,                    \\\n@@ -704,1 +724,1 @@\n-  experimental(intx, MonitorUsedDeflationThreshold, 90,                     \\\n+  product(intx, MonitorUsedDeflationThreshold, 90, EXPERIMENTAL,            \\\n@@ -710,1 +730,1 @@\n-  experimental(intx, hashCode, 5,                                           \\\n+  product(intx, hashCode, 5, EXPERIMENTAL,                                  \\\n@@ -795,1 +815,1 @@\n-  diagnostic(bool, PrintBiasedLockingStatistics, false,                     \\\n+  product(bool, PrintBiasedLockingStatistics, false, DIAGNOSTIC,            \\\n@@ -817,1 +837,1 @@\n-  diagnostic(intx, DiagnoseSyncOnPrimitiveWrappers, 0,                      \\\n+  product(intx, DiagnoseSyncOnPrimitiveWrappers, 0, DIAGNOSTIC,             \\\n@@ -921,1 +941,1 @@\n-  manageable(bool, PrintClassHistogram, false,                              \\\n+  product(bool, PrintClassHistogram, false, MANAGEABLE,                     \\\n@@ -924,1 +944,1 @@\n-  experimental(double, ObjectCountCutOffPercent, 0.5,                       \\\n+  product(double, ObjectCountCutOffPercent, 0.5, EXPERIMENTAL,              \\\n@@ -931,1 +951,1 @@\n-  diagnostic(bool, TraceJVMTIObjectTagging, false,                          \\\n+  product(bool, TraceJVMTIObjectTagging, false, DIAGNOSTIC,                 \\\n@@ -934,1 +954,1 @@\n-  diagnostic(bool, VerifyBeforeIteration, false,                            \\\n+  product(bool, VerifyBeforeIteration, false, DIAGNOSTIC,                   \\\n@@ -942,1 +962,1 @@\n-  diagnostic(bool, CIPrintCompileQueue, false,                              \\\n+  product(bool, CIPrintCompileQueue, false, DIAGNOSTIC,                     \\\n@@ -992,1 +1012,1 @@\n-  diagnostic(bool, ReduceNumberOfCompilerThreads, true,                     \\\n+  product(bool, ReduceNumberOfCompilerThreads, true, DIAGNOSTIC,            \\\n@@ -996,1 +1016,1 @@\n-  diagnostic(bool, TraceCompilerThreads, false,                             \\\n+  product(bool, TraceCompilerThreads, false, DIAGNOSTIC,                    \\\n@@ -1015,1 +1035,1 @@\n-  diagnostic_pd(bool, ImplicitNullChecks,                                   \\\n+  product_pd(bool, ImplicitNullChecks, DIAGNOSTIC,                          \\\n@@ -1024,1 +1044,1 @@\n-  diagnostic(bool, EnableThreadSMRExtraValidityChecks, true,                \\\n+  product(bool, EnableThreadSMRExtraValidityChecks, true, DIAGNOSTIC,       \\\n@@ -1027,1 +1047,1 @@\n-  diagnostic(bool, EnableThreadSMRStatistics, trueInDebug,                  \\\n+  product(bool, EnableThreadSMRStatistics, trueInDebug, DIAGNOSTIC,         \\\n@@ -1045,1 +1065,1 @@\n-  diagnostic(bool, PrintInlining, false,                                    \\\n+  product(bool, PrintInlining, false, DIAGNOSTIC,                           \\\n@@ -1054,1 +1074,1 @@\n-  diagnostic(bool, LogTouchedMethods, false,                                \\\n+  product(bool, LogTouchedMethods, false, DIAGNOSTIC,                       \\\n@@ -1057,1 +1077,1 @@\n-  diagnostic(bool, PrintTouchedMethodsAtExit, false,                        \\\n+  product(bool, PrintTouchedMethodsAtExit, false, DIAGNOSTIC,               \\\n@@ -1066,1 +1086,1 @@\n-  diagnostic(bool, PrintMethodFlushingStatistics, false,                    \\\n+  product(bool, PrintMethodFlushingStatistics, false, DIAGNOSTIC,           \\\n@@ -1069,1 +1089,1 @@\n-  diagnostic(intx, HotMethodDetectionLimit, 100000,                         \\\n+  product(intx, HotMethodDetectionLimit, 100000, DIAGNOSTIC,                \\\n@@ -1074,1 +1094,1 @@\n-  diagnostic(intx, MinPassesBeforeFlush, 10,                                \\\n+  product(intx, MinPassesBeforeFlush, 10, DIAGNOSTIC,                       \\\n@@ -1082,1 +1102,1 @@\n-  diagnostic(bool, StressCodeAging, false,                                  \\\n+  product(bool, StressCodeAging, false, DIAGNOSTIC,                         \\\n@@ -1088,1 +1108,1 @@\n-  diagnostic(bool, DebugNonSafepoints, trueInDebug,                         \\\n+  product(bool, DebugNonSafepoints, trueInDebug, DIAGNOSTIC,                \\\n@@ -1114,1 +1134,1 @@\n-  diagnostic(bool, SerializeVMOutput, true,                                 \\\n+  product(bool, SerializeVMOutput, true, DIAGNOSTIC,                        \\\n@@ -1117,1 +1137,1 @@\n-  diagnostic(bool, DisplayVMOutput, true,                                   \\\n+  product(bool, DisplayVMOutput, true, DIAGNOSTIC,                          \\\n@@ -1120,1 +1140,1 @@\n-  diagnostic(bool, LogVMOutput, false,                                      \\\n+  product(bool, LogVMOutput, false, DIAGNOSTIC,                             \\\n@@ -1123,1 +1143,1 @@\n-  diagnostic(ccstr, LogFile, NULL,                                          \\\n+  product(ccstr, LogFile, NULL, DIAGNOSTIC,                                 \\\n@@ -1153,1 +1173,1 @@\n-  diagnostic(bool, VerifyStringTableAtExit, false,                          \\\n+  product(bool, VerifyStringTableAtExit, false, DIAGNOSTIC,                 \\\n@@ -1163,1 +1183,1 @@\n-  diagnostic(ccstr, AbortVMOnException, NULL,                               \\\n+  product(ccstr, AbortVMOnException, NULL, DIAGNOSTIC,                      \\\n@@ -1167,1 +1187,1 @@\n-  diagnostic(ccstr, AbortVMOnExceptionMessage, NULL,                        \\\n+  product(ccstr, AbortVMOnExceptionMessage, NULL, DIAGNOSTIC,               \\\n@@ -1251,1 +1271,1 @@\n-  diagnostic(bool, PrintInterpreter, false,                                 \\\n+  product(bool, PrintInterpreter, false, DIAGNOSTIC,                        \\\n@@ -1283,1 +1303,1 @@\n-  diagnostic(bool, PrintSignatureHandlers, false,                           \\\n+  product(bool, PrintSignatureHandlers, false, DIAGNOSTIC,                  \\\n@@ -1331,1 +1351,1 @@\n-  diagnostic(bool, PrintMethodData, false,                                  \\\n+  product(bool, PrintMethodData, false, DIAGNOSTIC,                         \\\n@@ -1435,1 +1455,1 @@\n-  diagnostic(intx, GuaranteedSafepointInterval, 1000,                       \\\n+  product(intx, GuaranteedSafepointInterval, 1000, DIAGNOSTIC,              \\\n@@ -1442,2 +1462,1 @@\n-  LP64_ONLY(range(0, max_intx\/MICROUNITS))                                  \\\n-  NOT_LP64(range(0, max_intx))                                              \\\n+          range(0, max_intx LP64_ONLY(\/MICROUNITS))                         \\\n@@ -1496,1 +1515,1 @@\n-  diagnostic(uintx, MallocMaxTestWords,     0,                              \\\n+  product(uintx, MallocMaxTestWords,     0, DIAGNOSTIC,                     \\\n@@ -1520,1 +1539,1 @@\n-  experimental(intx, PerMethodSpecTrapLimit,  5000,                         \\\n+  product(intx, PerMethodSpecTrapLimit,  5000, EXPERIMENTAL,                \\\n@@ -1529,1 +1548,1 @@\n-  experimental(intx, SpecTrapLimitExtraEntries,  3,                         \\\n+  product(intx, SpecTrapLimitExtraEntries,  3, EXPERIMENTAL,                \\\n@@ -1536,1 +1555,1 @@\n-  diagnostic_pd(intx, InlineFrequencyCount,                                 \\\n+  product_pd(intx, InlineFrequencyCount, DIAGNOSTIC,                        \\\n@@ -1567,1 +1586,1 @@\n-  manageable(uintx, MinHeapFreeRatio, 40,                                   \\\n+  product(uintx, MinHeapFreeRatio, 40, MANAGEABLE,                          \\\n@@ -1574,1 +1593,1 @@\n-  manageable(uintx, MaxHeapFreeRatio, 70,                                   \\\n+  product(uintx, MaxHeapFreeRatio, 70, MANAGEABLE,                          \\\n@@ -1674,1 +1693,1 @@\n-          range(os::vm_page_size(), max_uintx)                              \\\n+          constraint(VMPageSizeConstraintFunc, AtParse)                     \\\n@@ -1685,1 +1704,1 @@\n-          range(os::vm_page_size(), max_uintx)                              \\\n+          constraint(VMPageSizeConstraintFunc, AtParse)                     \\\n@@ -1697,1 +1716,1 @@\n-          range(os::vm_page_size(), max_uintx)                              \\\n+          constraint(VMPageSizeConstraintFunc, AtParse)                     \\\n@@ -1703,1 +1722,1 @@\n-  diagnostic_pd(uintx, CodeCacheMinBlockLength,                             \\\n+  product_pd(uintx, CodeCacheMinBlockLength, DIAGNOSTIC,                    \\\n@@ -1725,1 +1744,1 @@\n-  experimental(bool, UseAOT, false,                                         \\\n+  product(bool, UseAOT, false, EXPERIMENTAL,                                \\\n@@ -1728,1 +1747,1 @@\n-  experimental(ccstrlist, AOTLibrary, NULL,                                 \\\n+  product(ccstrlist, AOTLibrary, NULL, EXPERIMENTAL,                        \\\n@@ -1731,1 +1750,1 @@\n-  experimental(bool, PrintAOT, false,                                       \\\n+  product(bool, PrintAOT, false, EXPERIMENTAL,                              \\\n@@ -1737,1 +1756,1 @@\n-  diagnostic(bool, UseAOTStrictLoading, false,                              \\\n+  product(bool, UseAOTStrictLoading, false, DIAGNOSTIC,                     \\\n@@ -1781,1 +1800,1 @@\n-  diagnostic(ccstr, CompilerDirectivesFile, NULL,                           \\\n+  product(ccstr, CompilerDirectivesFile, NULL, DIAGNOSTIC,                  \\\n@@ -1822,1 +1841,1 @@\n-  diagnostic(bool, AbortVMOnCompilationFailure, false,                      \\\n+  product(bool, AbortVMOnCompilationFailure, false, DIAGNOSTIC,             \\\n@@ -1903,1 +1922,1 @@\n-  experimental(bool, UseCriticalJavaThreadPriority, false,                  \\\n+  product(bool, UseCriticalJavaThreadPriority, false, EXPERIMENTAL,         \\\n@@ -1906,1 +1925,1 @@\n-  experimental(bool, UseCriticalCompilerThreadPriority, false,              \\\n+  product(bool, UseCriticalCompilerThreadPriority, false, EXPERIMENTAL,     \\\n@@ -2015,1 +2034,1 @@\n-  diagnostic(intx, Tier0AOTInvocationThreshold, 200,                        \\\n+  product(intx, Tier0AOTInvocationThreshold, 200, DIAGNOSTIC,               \\\n@@ -2022,1 +2041,1 @@\n-  diagnostic(intx, Tier0AOTMinInvocationThreshold, 100,                     \\\n+  product(intx, Tier0AOTMinInvocationThreshold, 100, DIAGNOSTIC,            \\\n@@ -2029,1 +2048,1 @@\n-  diagnostic(intx, Tier0AOTCompileThreshold, 2000,                          \\\n+  product(intx, Tier0AOTCompileThreshold, 2000, DIAGNOSTIC,                 \\\n@@ -2037,1 +2056,1 @@\n-  diagnostic(intx, Tier0AOTBackEdgeThreshold,  60000,                       \\\n+  product(intx, Tier0AOTBackEdgeThreshold,  60000, DIAGNOSTIC,              \\\n@@ -2062,1 +2081,1 @@\n-  diagnostic(intx, Tier40InvocationThreshold, 5000,                         \\\n+  product(intx, Tier40InvocationThreshold, 5000, DIAGNOSTIC,                \\\n@@ -2068,1 +2087,1 @@\n-  diagnostic(intx, Tier40MinInvocationThreshold, 600,                       \\\n+  product(intx, Tier40MinInvocationThreshold, 600, DIAGNOSTIC,              \\\n@@ -2074,1 +2093,1 @@\n-  diagnostic(intx, Tier40CompileThreshold, 10000,                           \\\n+  product(intx, Tier40CompileThreshold, 10000, DIAGNOSTIC,                  \\\n@@ -2080,1 +2099,1 @@\n-  diagnostic(intx, Tier40BackEdgeThreshold, 15000,                          \\\n+  product(intx, Tier40BackEdgeThreshold, 15000, DIAGNOSTIC,                 \\\n@@ -2086,1 +2105,1 @@\n-  diagnostic(intx, Tier0Delay, 5,                                           \\\n+  product(intx, Tier0Delay, 5, DIAGNOSTIC,                                  \\\n@@ -2181,1 +2200,1 @@\n-  diagnostic(bool, UseNewCode, false,                                       \\\n+  product(bool, UseNewCode, false, DIAGNOSTIC,                              \\\n@@ -2184,1 +2203,1 @@\n-  diagnostic(bool, UseNewCode2, false,                                      \\\n+  product(bool, UseNewCode2, false, DIAGNOSTIC,                             \\\n@@ -2187,1 +2206,1 @@\n-  diagnostic(bool, UseNewCode3, false,                                      \\\n+  product(bool, UseNewCode3, false, DIAGNOSTIC,                             \\\n@@ -2246,1 +2265,1 @@\n-  manageable(bool, PrintConcurrentLocks, false,                             \\\n+  product(bool, PrintConcurrentLocks, false, MANAGEABLE,                    \\\n@@ -2287,1 +2306,1 @@\n-  diagnostic(bool, AllowArchivingWithJavaAgent, false,                      \\\n+  product(bool, AllowArchivingWithJavaAgent, false, DIAGNOSTIC,             \\\n@@ -2290,1 +2309,1 @@\n-  diagnostic(bool, PrintMethodHandleStubs, false,                           \\\n+  product(bool, PrintMethodHandleStubs, false, DIAGNOSTIC,                  \\\n@@ -2293,1 +2312,1 @@\n-  diagnostic(bool, VerifyMethodHandles, trueInDebug,                        \\\n+  product(bool, VerifyMethodHandles, trueInDebug, DIAGNOSTIC,               \\\n@@ -2296,1 +2315,1 @@\n-  diagnostic(bool, ShowHiddenFrames, false,                                 \\\n+  product(bool, ShowHiddenFrames, false, DIAGNOSTIC,                        \\\n@@ -2299,1 +2318,1 @@\n-  experimental(bool, TrustFinalNonStaticFields, false,                      \\\n+  product(bool, TrustFinalNonStaticFields, false, EXPERIMENTAL,             \\\n@@ -2302,1 +2321,1 @@\n-  diagnostic(bool, FoldStableValues, true,                                  \\\n+  product(bool, FoldStableValues, true, DIAGNOSTIC,                         \\\n@@ -2305,1 +2324,1 @@\n-  diagnostic(int, UseBootstrapCallInfo, 1,                                  \\\n+  product(int, UseBootstrapCallInfo, 1, DIAGNOSTIC,                         \\\n@@ -2313,1 +2332,1 @@\n-  diagnostic(bool, PauseAtStartup,      false,                              \\\n+  product(bool, PauseAtStartup,      false, DIAGNOSTIC,                     \\\n@@ -2317,1 +2336,1 @@\n-  diagnostic(ccstr, PauseAtStartupFile, NULL,                               \\\n+  product(ccstr, PauseAtStartupFile, NULL, DIAGNOSTIC,                      \\\n@@ -2321,1 +2340,1 @@\n-  diagnostic(bool, PauseAtExit, false,                                      \\\n+  product(bool, PauseAtExit, false, DIAGNOSTIC,                             \\\n@@ -2344,1 +2363,1 @@\n-  experimental(uintx, SymbolTableSize, defaultSymbolTableSize,              \\\n+  product(uintx, SymbolTableSize, defaultSymbolTableSize, EXPERIMENTAL,     \\\n@@ -2356,1 +2375,1 @@\n-  diagnostic(bool, StringDeduplicationResizeALot, false,                    \\\n+  product(bool, StringDeduplicationResizeALot, false, DIAGNOSTIC,           \\\n@@ -2359,1 +2378,1 @@\n-  diagnostic(bool, StringDeduplicationRehashALot, false,                    \\\n+  product(bool, StringDeduplicationRehashALot, false, DIAGNOSTIC,           \\\n@@ -2362,1 +2381,1 @@\n-  diagnostic(bool, WhiteBoxAPI, false,                                      \\\n+  product(bool, WhiteBoxAPI, false, DIAGNOSTIC,                             \\\n@@ -2365,1 +2384,1 @@\n-  experimental(intx, SurvivorAlignmentInBytes, 0,                           \\\n+  product(intx, SurvivorAlignmentInBytes, 0, EXPERIMENTAL,                  \\\n@@ -2386,1 +2405,1 @@\n-  diagnostic(intx, ArchiveRelocationMode, 0,                                \\\n+  product(intx, ArchiveRelocationMode, 0, DIAGNOSTIC,                       \\\n@@ -2394,1 +2413,1 @@\n-  experimental(size_t, ArrayAllocatorMallocLimit, (size_t)-1,               \\\n+  product(size_t, ArrayAllocatorMallocLimit, (size_t)-1, EXPERIMENTAL,      \\\n@@ -2398,1 +2417,1 @@\n-  experimental(bool, AlwaysAtomicAccesses, false,                           \\\n+  product(bool, AlwaysAtomicAccesses, false, EXPERIMENTAL,                  \\\n@@ -2401,1 +2420,1 @@\n-  diagnostic(bool, UseUnalignedAccesses, false,                             \\\n+  product(bool, UseUnalignedAccesses, false, DIAGNOSTIC,                    \\\n@@ -2408,1 +2427,1 @@\n-  diagnostic(bool, CheckIntrinsics, true,                                   \\\n+  product(bool, CheckIntrinsics, true, DIAGNOSTIC,                          \\\n@@ -2421,1 +2440,1 @@\n-  diagnostic_pd(intx, InitArrayShortSize,                                   \\\n+  product_pd(intx, InitArrayShortSize, DIAGNOSTIC,                          \\\n@@ -2428,1 +2447,1 @@\n-  diagnostic(bool, CompilerDirectivesIgnoreCompileCommands, false,          \\\n+  product(bool, CompilerDirectivesIgnoreCompileCommands, false, DIAGNOSTIC, \\\n@@ -2431,1 +2450,1 @@\n-  diagnostic(bool, CompilerDirectivesPrint, false,                          \\\n+  product(bool, CompilerDirectivesPrint, false, DIAGNOSTIC,                 \\\n@@ -2433,1 +2452,1 @@\n-  diagnostic(int,  CompilerDirectivesLimit, 50,                             \\\n+  product(int,  CompilerDirectivesLimit, 50, DIAGNOSTIC,                    \\\n@@ -2440,1 +2459,1 @@\n-  experimental(ccstr, AllocateOldGenAt, NULL,                               \\\n+  product(ccstr, AllocateOldGenAt, NULL, EXPERIMENTAL,                      \\\n@@ -2450,1 +2469,1 @@\n-  diagnostic(bool, ShowRegistersOnAssert, true,                             \\\n+  product(bool, ShowRegistersOnAssert, true, DIAGNOSTIC,                    \\\n@@ -2453,1 +2472,1 @@\n-  diagnostic(bool, UseSwitchProfiling, true,                                \\\n+  product(bool, UseSwitchProfiling, true, DIAGNOSTIC,                       \\\n@@ -2468,1 +2487,1 @@\n-  experimental(bool, UseFastUnorderedTimeStamps, false,                     \\\n+  product(bool, UseFastUnorderedTimeStamps, false, EXPERIMENTAL,            \\\n@@ -2474,2 +2493,4 @@\n-  diagnostic(bool, DeoptimizeNMethodBarriersALot, false,                    \\\n-                \"Make nmethod barriers deoptimise a lot.\")                  \\\n+  product(bool, DeoptimizeNMethodBarriersALot, false, DIAGNOSTIC,           \\\n+                \"Make nmethod barriers deoptimise a lot.\")\n+\n+\/\/ end of RUNTIME_FLAGS\n@@ -2478,7 +2499,2 @@\n-#define DECLARE_PRODUCT_FLAG(type, name, value, doc)      extern \"C\" type name;\n-#define DECLARE_PD_PRODUCT_FLAG(type, name, doc)          extern \"C\" type name;\n-#define DECLARE_DIAGNOSTIC_FLAG(type, name, value, doc)   extern \"C\" type name;\n-#define DECLARE_PD_DIAGNOSTIC_FLAG(type, name, doc)       extern \"C\" type name;\n-#define DECLARE_EXPERIMENTAL_FLAG(type, name, value, doc) extern \"C\" type name;\n-#define DECLARE_MANAGEABLE_FLAG(type, name, value, doc)   extern \"C\" type name;\n-#define DECLARE_PRODUCT_RW_FLAG(type, name, value, doc)   extern \"C\" type name;\n+#define DECLARE_PRODUCT_FLAG(type, name, value, ...)      extern \"C\" type name;\n+#define DECLARE_PD_PRODUCT_FLAG(type, name, ...)          extern \"C\" type name;\n@@ -2486,3 +2502,3 @@\n-#define DECLARE_DEVELOPER_FLAG(type, name, value, doc)    const type name = value;\n-#define DECLARE_PD_DEVELOPER_FLAG(type, name, doc)        const type name = pd_##name;\n-#define DECLARE_NOTPRODUCT_FLAG(type, name, value, doc)   const type name = value;\n+#define DECLARE_DEVELOPER_FLAG(type, name, value, ...)    const type name = value;\n+#define DECLARE_PD_DEVELOPER_FLAG(type, name, ...)        const type name = pd_##name;\n+#define DECLARE_NOTPRODUCT_FLAG(type, name, value, ...)   const type name = value;\n@@ -2490,3 +2506,3 @@\n-#define DECLARE_DEVELOPER_FLAG(type, name, value, doc)    extern \"C\" type name;\n-#define DECLARE_PD_DEVELOPER_FLAG(type, name, doc)        extern \"C\" type name;\n-#define DECLARE_NOTPRODUCT_FLAG(type, name, value, doc)   extern \"C\" type name;\n+#define DECLARE_DEVELOPER_FLAG(type, name, value, ...)    extern \"C\" type name;\n+#define DECLARE_PD_DEVELOPER_FLAG(type, name, ...)        extern \"C\" type name;\n+#define DECLARE_NOTPRODUCT_FLAG(type, name, value, ...)   extern \"C\" type name;\n@@ -2494,6 +2510,0 @@\n-\/\/ Special LP64 flags, product only needed for now.\n-#ifdef _LP64\n-#define DECLARE_LP64_PRODUCT_FLAG(type, name, value, doc) extern \"C\" type name;\n-#else\n-#define DECLARE_LP64_PRODUCT_FLAG(type, name, value, doc) const type name = value;\n-#endif \/\/ _LP64\n@@ -2501,12 +2511,6 @@\n-ALL_FLAGS(DECLARE_DEVELOPER_FLAG,     \\\n-          DECLARE_PD_DEVELOPER_FLAG,  \\\n-          DECLARE_PRODUCT_FLAG,       \\\n-          DECLARE_PD_PRODUCT_FLAG,    \\\n-          DECLARE_DIAGNOSTIC_FLAG,    \\\n-          DECLARE_PD_DIAGNOSTIC_FLAG, \\\n-          DECLARE_EXPERIMENTAL_FLAG,  \\\n-          DECLARE_NOTPRODUCT_FLAG,    \\\n-          DECLARE_MANAGEABLE_FLAG,    \\\n-          DECLARE_PRODUCT_RW_FLAG,    \\\n-          DECLARE_LP64_PRODUCT_FLAG,  \\\n-          IGNORE_RANGE,               \\\n+ALL_FLAGS(DECLARE_DEVELOPER_FLAG,\n+          DECLARE_PD_DEVELOPER_FLAG,\n+          DECLARE_PRODUCT_FLAG,\n+          DECLARE_PD_PRODUCT_FLAG,\n+          DECLARE_NOTPRODUCT_FLAG,\n+          IGNORE_RANGE,\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":236,"deletions":232,"binary":false,"changes":468,"status":"modified"},{"patch":"@@ -37,15 +37,5 @@\n-#define FLAG_MEMBER_ENUM_PRODUCT(type, name, value, doc)      FLAG_MEMBER_ENUM_(name)\n-#define FLAG_MEMBER_ENUM_PD_PRODUCT(type, name, doc)          FLAG_MEMBER_ENUM_(name)\n-#define FLAG_MEMBER_ENUM_DIAGNOSTIC(type, name, value, doc)   FLAG_MEMBER_ENUM_(name)\n-#define FLAG_MEMBER_ENUM_PD_DIAGNOSTIC(type, name, doc)       FLAG_MEMBER_ENUM_(name)\n-#define FLAG_MEMBER_ENUM_EXPERIMENTAL(type, name, value, doc) FLAG_MEMBER_ENUM_(name)\n-#define FLAG_MEMBER_ENUM_MANAGEABLE(type, name, value, doc)   FLAG_MEMBER_ENUM_(name)\n-#define FLAG_MEMBER_ENUM_PRODUCT_RW(type, name, value, doc)   FLAG_MEMBER_ENUM_(name)\n-#define FLAG_MEMBER_ENUM_DEVELOP(type, name, value, doc)      FLAG_MEMBER_ENUM_(name)\n-#define FLAG_MEMBER_ENUM_PD_DEVELOP(type, name, doc)          FLAG_MEMBER_ENUM_(name)\n-#define FLAG_MEMBER_ENUM_NOTPRODUCT(type, name, value, doc)   FLAG_MEMBER_ENUM_(name)\n-#ifdef _LP64\n-#define FLAG_MEMBER_ENUM_LP64_PRODUCT(type, name, value, doc) FLAG_MEMBER_ENUM_(name)\n-#else\n-#define FLAG_MEMBER_ENUM_LP64_PRODUCT(type, name, value, doc) \/* flag is constant *\/\n-#endif \/\/ _LP64\n+#define FLAG_MEMBER_ENUM_PRODUCT(type, name, value, ...)      FLAG_MEMBER_ENUM_(name)\n+#define FLAG_MEMBER_ENUM_PD_PRODUCT(type, name, ...)          FLAG_MEMBER_ENUM_(name)\n+#define FLAG_MEMBER_ENUM_DEVELOP(type, name, value, ...)      FLAG_MEMBER_ENUM_(name)\n+#define FLAG_MEMBER_ENUM_PD_DEVELOP(type, name, ...)          FLAG_MEMBER_ENUM_(name)\n+#define FLAG_MEMBER_ENUM_NOTPRODUCT(type, name, value, ...)   FLAG_MEMBER_ENUM_(name)\n@@ -53,1 +43,1 @@\n-typedef enum {\n+typedef enum : int {\n@@ -58,3 +48,0 @@\n-            FLAG_MEMBER_ENUM_DIAGNOSTIC,\n-            FLAG_MEMBER_ENUM_PD_DIAGNOSTIC,\n-            FLAG_MEMBER_ENUM_EXPERIMENTAL,\n@@ -62,3 +49,0 @@\n-            FLAG_MEMBER_ENUM_MANAGEABLE,\n-            FLAG_MEMBER_ENUM_PRODUCT_RW,\n-            FLAG_MEMBER_ENUM_LP64_PRODUCT,\n@@ -103,15 +87,5 @@\n-#define FLAG_MEMBER_SET_PRODUCT(type, name, value, doc)      FLAG_MEMBER_SET_(type, name)\n-#define FLAG_MEMBER_SET_PD_PRODUCT(type, name, doc)          FLAG_MEMBER_SET_(type, name)\n-#define FLAG_MEMBER_SET_DIAGNOSTIC(type, name, value, doc)   FLAG_MEMBER_SET_(type, name)\n-#define FLAG_MEMBER_SET_PD_DIAGNOSTIC(type, name, doc)       FLAG_MEMBER_SET_(type, name)\n-#define FLAG_MEMBER_SET_EXPERIMENTAL(type, name, value, doc) FLAG_MEMBER_SET_(type, name)\n-#define FLAG_MEMBER_SET_MANAGEABLE(type, name, value, doc)   FLAG_MEMBER_SET_(type, name)\n-#define FLAG_MEMBER_SET_PRODUCT_RW(type, name, value, doc)   FLAG_MEMBER_SET_(type, name)\n-#define FLAG_MEMBER_SET_DEVELOP(type, name, value, doc)      FLAG_MEMBER_SET_(type, name)\n-#define FLAG_MEMBER_SET_PD_DEVELOP(type, name, doc)          FLAG_MEMBER_SET_(type, name)\n-#define FLAG_MEMBER_SET_NOTPRODUCT(type, name, value, doc)   FLAG_MEMBER_SET_(type, name)\n-#ifdef _LP64\n-#define FLAG_MEMBER_SET_LP64_PRODUCT(type, name, value, doc) FLAG_MEMBER_SET_(type, name)\n-#else\n-#define FLAG_MEMBER_SET_LP64_PRODUCT(type, name, value, doc) \/* flag is constant *\/\n-#endif \/\/ _LP64\n+#define FLAG_MEMBER_SET_PRODUCT(type, name, value, ...)      FLAG_MEMBER_SET_(type, name)\n+#define FLAG_MEMBER_SET_PD_PRODUCT(type, name, ...)          FLAG_MEMBER_SET_(type, name)\n+#define FLAG_MEMBER_SET_DEVELOP(type, name, value, ...)      FLAG_MEMBER_SET_(type, name)\n+#define FLAG_MEMBER_SET_PD_DEVELOP(type, name, ...)          FLAG_MEMBER_SET_(type, name)\n+#define FLAG_MEMBER_SET_NOTPRODUCT(type, name, value, ...)   FLAG_MEMBER_SET_(type, name)\n@@ -123,3 +97,0 @@\n-          FLAG_MEMBER_SET_DIAGNOSTIC,\n-          FLAG_MEMBER_SET_PD_DIAGNOSTIC,\n-          FLAG_MEMBER_SET_EXPERIMENTAL,\n@@ -127,3 +98,0 @@\n-          FLAG_MEMBER_SET_MANAGEABLE,\n-          FLAG_MEMBER_SET_PRODUCT_RW,\n-          FLAG_MEMBER_SET_LP64_PRODUCT,\n","filename":"src\/hotspot\/share\/runtime\/globals_extension.hpp","additions":11,"deletions":43,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -80,0 +80,2 @@\n+#define IGNORE_FLAG(...)\n+\n@@ -85,3 +87,0 @@\n-    diagnostic,               \\\n-    diagnostic_pd,            \\\n-    experimental,             \\\n@@ -89,3 +88,0 @@\n-    manageable,               \\\n-    product_rw,               \\\n-    lp64_product,             \\\n@@ -100,3 +96,0 @@\n-    diagnostic,               \\\n-    diagnostic_pd,            \\\n-    experimental,             \\\n@@ -104,3 +97,0 @@\n-    manageable,               \\\n-    product_rw,               \\\n-    lp64_product,             \\\n@@ -115,3 +105,0 @@\n-    diagnostic,               \\\n-    diagnostic_pd,            \\\n-    experimental,             \\\n@@ -119,3 +106,0 @@\n-    manageable,               \\\n-    product_rw,               \\\n-    lp64_product,             \\\n@@ -125,0 +109,3 @@\n+\/\/ Put the LP64\/JVMCI\/COMPILER1\/COMPILER1\/ARCH at\n+\/\/ the top, as they are processed by jvmFlags.cpp in that\n+\/\/ order.\n@@ -131,3 +118,0 @@\n-    diagnostic,               \\\n-    diagnostic_pd,            \\\n-    experimental,             \\\n@@ -135,3 +119,0 @@\n-    manageable,               \\\n-    product_rw,               \\\n-    lp64_product,             \\\n@@ -141,1 +122,1 @@\n-  VM_FLAGS(                   \\\n+  LP64_RUNTIME_FLAGS(         \\\n@@ -146,3 +127,0 @@\n-    diagnostic,               \\\n-    diagnostic_pd,            \\\n-    experimental,             \\\n@@ -150,3 +128,0 @@\n-    manageable,               \\\n-    product_rw,               \\\n-    lp64_product,             \\\n@@ -156,1 +131,1 @@\n-  RUNTIME_OS_FLAGS(           \\\n+  JVMCI_ONLY(JVMCI_FLAGS(     \\\n@@ -161,2 +136,0 @@\n-    diagnostic,               \\\n-    diagnostic_pd,            \\\n@@ -165,1 +138,1 @@\n-    constraint)               \\\n+    constraint))              \\\n@@ -167,1 +140,1 @@\n-  JVMCI_ONLY(JVMCI_FLAGS(     \\\n+  COMPILER1_PRESENT(C1_FLAGS( \\\n@@ -172,3 +145,0 @@\n-    diagnostic,               \\\n-    diagnostic_pd,            \\\n-    experimental,             \\\n@@ -179,1 +149,1 @@\n-  COMPILER1_PRESENT(C1_FLAGS( \\\n+  COMPILER2_PRESENT(C2_FLAGS( \\\n@@ -184,2 +154,0 @@\n-    diagnostic,               \\\n-    diagnostic_pd,            \\\n@@ -190,1 +158,8 @@\n-  COMPILER2_PRESENT(C2_FLAGS( \\\n+  ARCH_FLAGS(                 \\\n+    develop,                  \\\n+    product,                  \\\n+    notproduct,               \\\n+    range,                    \\\n+    constraint)               \\\n+                              \\\n+  VM_FLAGS(                   \\\n@@ -195,3 +170,0 @@\n-    diagnostic,               \\\n-    diagnostic_pd,            \\\n-    experimental,             \\\n@@ -200,1 +172,1 @@\n-    constraint))              \\\n+    constraint)               \\\n@@ -202,1 +174,1 @@\n-  ARCH_FLAGS(                 \\\n+  RUNTIME_OS_FLAGS(           \\\n@@ -204,0 +176,1 @@\n+    develop_pd,               \\\n@@ -205,2 +178,1 @@\n-    diagnostic,               \\\n-    experimental,             \\\n+    product_pd,               \\\n@@ -211,0 +183,5 @@\n+#define ALL_CONSTRAINTS(f)    \\\n+  COMPILER_CONSTRAINTS(f)     \\\n+  RUNTIME_CONSTRAINTS(f)      \\\n+  GC_CONSTRAINTS(f)\n+\n","filename":"src\/hotspot\/share\/runtime\/globals_shared.hpp","additions":27,"deletions":50,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,2 +42,2 @@\n-  JVMFlagRange* range = JVMFlagRangeList::find(flag);\n-  if (range != NULL) {\n+  JVMFlagRangeChecker range = JVMFlagRangeList::find(flag);\n+  if (range.exists()) {\n@@ -47,1 +47,1 @@\n-    range->print(&stream);\n+    range.print(&stream);\n","filename":"src\/hotspot\/share\/services\/writeableFlags.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -975,6 +975,6 @@\n-template<class T> inline T MAX2(T a, T b)           { return (a > b) ? a : b; }\n-template<class T> inline T MIN2(T a, T b)           { return (a < b) ? a : b; }\n-template<class T> inline T MAX3(T a, T b, T c)      { return MAX2(MAX2(a, b), c); }\n-template<class T> inline T MIN3(T a, T b, T c)      { return MIN2(MIN2(a, b), c); }\n-template<class T> inline T MAX4(T a, T b, T c, T d) { return MAX2(MAX3(a, b, c), d); }\n-template<class T> inline T MIN4(T a, T b, T c, T d) { return MIN2(MIN3(a, b, c), d); }\n+template<class T> constexpr T MAX2(T a, T b)           { return (a > b) ? a : b; }\n+template<class T> constexpr T MIN2(T a, T b)           { return (a < b) ? a : b; }\n+template<class T> constexpr T MAX3(T a, T b, T c)      { return MAX2(MAX2(a, b), c); }\n+template<class T> constexpr T MIN3(T a, T b, T c)      { return MIN2(MIN2(a, b), c); }\n+template<class T> constexpr T MAX4(T a, T b, T c, T d) { return MAX2(MAX3(a, b, c), d); }\n+template<class T> constexpr T MIN4(T a, T b, T c, T d) { return MIN2(MIN3(a, b, c), d); }\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"}]}