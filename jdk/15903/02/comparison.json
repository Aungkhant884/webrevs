{"files":[{"patch":"@@ -6352,0 +6352,1 @@\n+  ldrw(t1, Address(rthread, JavaThread::lock_stack_top_offset()));\n@@ -6360,1 +6361,0 @@\n-    ldrw(t1, Address(rthread, JavaThread::lock_stack_top_offset()));\n@@ -6366,10 +6366,0 @@\n-  {\n-    \/\/ Check if the top of the lock-stack matches the unlocked object.\n-    Label tos_ok;\n-    subw(t1, t1, oopSize);\n-    ldr(t1, Address(rthread, t1));\n-    cmpoop(t1, obj);\n-    br(Assembler::EQ, tos_ok);\n-    STOP(\"Top of lock-stack does not match the unlocked object\");\n-    bind(tos_ok);\n-  }\n@@ -6386,0 +6376,6 @@\n+  \/\/ Check if the top of the lock-stack matches the unlocked object.\n+  subw(t1, t1, oopSize);\n+  ldr(t2, Address(rthread, t1));\n+  cmpoop(t2, obj);\n+  br(Assembler::NE, slow);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -218,1 +218,1 @@\n-    __ unlock_object(R5, R6, R4, *stub->entry());\n+    __ unlock_object(R5, R6, R4, *stub->entry(), compilation()->is_osr_compile());\n@@ -2682,1 +2682,1 @@\n-      __ unlock_object(hdr, obj, lock, *op->stub()->entry());\n+      __ unlock_object(hdr, obj, lock, *op->stub()->entry(), compilation()->is_osr_compile());\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-void C1_MacroAssembler::unlock_object(Register Rmark, Register Roop, Register Rbox, Label& slow_case) {\n+void C1_MacroAssembler::unlock_object(Register Rmark, Register Roop, Register Rbox, Label& slow_case, bool may_be_unordered) {\n@@ -184,1 +184,1 @@\n-    lightweight_unlock(Roop, Rmark, slow_int);\n+    lightweight_unlock(Roop, Rmark, noreg, slow_int, may_be_unordered);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-  void unlock_object(Register Rmark, Register Roop, Register Rbox,                    Label& slow_case);\n+  void unlock_object(Register Rmark, Register Roop, Register Rbox,                    Label& slow_case, bool may_be_unordered);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1130,5 +1130,0 @@\n-      \/\/ Then check if the top of the lock-stack matches the unlocked object.\n-      addi(tmp, tmp, -oopSize);\n-      ldx(tmp, tmp, R16_thread);\n-      cmpd(CCR0, tmp, object);\n-      bne(CCR0, slow_case);\n@@ -1139,1 +1134,2 @@\n-      lightweight_unlock(object, header, slow_case);\n+\n+      lightweight_unlock(object, header, tmp, slow_case, true);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2296,1 +2296,2 @@\n-                                                 Register temp, Register displaced_header, Register current_header) {\n+                                                 Register temp, Register displaced_header, Register current_header,\n+                                                 bool may_be_unordered) {\n@@ -2337,1 +2338,1 @@\n-    lightweight_unlock(oop, current_header, failure);\n+    lightweight_unlock(oop, current_header, \/* temp *\/ displaced_header, failure, may_be_unordered);\n@@ -4035,1 +4036,1 @@\n-void MacroAssembler::lightweight_unlock(Register obj, Register hdr, Label& slow) {\n+void MacroAssembler::lightweight_unlock(Register obj, Register hdr, Register t1, Label& slow, bool may_be_unordered) {\n@@ -4048,1 +4049,6 @@\n-  Register t1 = hdr; \/\/ Reuse in debug build.\n+#endif\n+\n+  Register temp = (t1 != noreg) ? t1 : hdr; \/\/ Reuse if no temp reg given.\n+  lwz(temp, in_bytes(JavaThread::lock_stack_top_offset()), R16_thread);\n+\n+#ifdef ASSERT\n@@ -4056,2 +4062,1 @@\n-    lwz(t1, in_bytes(JavaThread::lock_stack_top_offset()), R16_thread);\n-    cmplwi(CCR0, t1, LockStack::start_offset());\n+    cmplwi(CCR0, temp, LockStack::start_offset());\n@@ -4062,2 +4067,10 @@\n-  {\n-    \/\/ Check if the top of the lock-stack matches the unlocked object.\n+#endif\n+\n+  \/\/ Check if the top of the lock-stack matches the unlocked object.\n+  addi(temp, temp, -oopSize);\n+  if (may_be_unordered) {\n+    ldx(R0, temp, R16_thread);\n+    cmpd(CCR0, R0, obj);\n+    bne(CCR0, slow);\n+  } else {\n+#ifdef ASSERT\n@@ -4065,3 +4078,2 @@\n-    addi(t1, t1, -oopSize);\n-    ldx(t1, t1, R16_thread);\n-    cmpd(CCR0, t1, obj);\n+    ldx(R0, temp, R16_thread);\n+    cmpd(CCR0, R0, obj);\n@@ -4071,1 +4083,0 @@\n-  }\n@@ -4073,0 +4084,1 @@\n+  }\n@@ -4078,3 +4090,5 @@\n-  Register t2 = hdr;\n-  lwz(t2, in_bytes(JavaThread::lock_stack_top_offset()), R16_thread);\n-  addi(t2, t2, -oopSize);\n+  if (temp == hdr) {\n+    \/\/ Need to reload if we killed it due to lack of registers.\n+    lwz(temp, in_bytes(JavaThread::lock_stack_top_offset()), R16_thread);\n+    addi(temp, temp, -oopSize);\n+  }\n@@ -4083,1 +4097,1 @@\n-  stdx(R0, t2, R16_thread);\n+  stdx(R0, temp, R16_thread);\n@@ -4085,1 +4099,1 @@\n-  stw(t2, in_bytes(JavaThread::lock_stack_top_offset()), R16_thread);\n+  stw(temp, in_bytes(JavaThread::lock_stack_top_offset()), R16_thread);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":31,"deletions":17,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -610,1 +610,1 @@\n-  void lightweight_unlock(Register obj, Register hdr, Label& slow);\n+  void lightweight_unlock(Register obj, Register hdr, Register t1, Label& slow, bool may_be_unordered);\n@@ -629,1 +629,1 @@\n-                                   Register tmp1, Register tmp2, Register tmp3);\n+                                   Register tmp1, Register tmp2, Register tmp3, bool may_be_unoredered);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -12171,1 +12171,1 @@\n-                                   $tmp1$$Register, $tmp2$$Register, $tmp3$$Register);\n+                                   $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, Compile::current()->is_osr_compilation());\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2677,1 +2677,1 @@\n-    __ compiler_fast_unlock_object(CCR0, r_oop, r_box, r_temp_1, r_temp_2, r_temp_3);\n+    __ compiler_fast_unlock_object(CCR0, r_oop, r_box, r_temp_1, r_temp_2, r_temp_3, false);\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -9839,0 +9839,14 @@\n+  \/\/ Check if the top of the lock-stack matches the unlocked object.\n+#ifdef _LP64\n+  const Register thread = r15_thread;\n+#else\n+  const Register thread = rax;\n+  \/\/ TODO: push hdr and use below from stack\n+  \/\/ get_thread(thread);\n+#endif\n+#ifdef _LP64\n+  movl(tmp, Address(thread, JavaThread::lock_stack_top_offset()));\n+  cmpptr(obj, Address(thread, tmp, Address::times_1, -oopSize));\n+  jcc(Assembler::notEqual, slow);\n+#endif\n+\n@@ -9846,4 +9860,1 @@\n-#ifdef _LP64\n-  const Register thread = r15_thread;\n-#else\n-  const Register thread = rax;\n+#ifndef _LP64\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"}]}