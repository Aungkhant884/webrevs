{"files":[{"patch":"@@ -69,1 +69,1 @@\n-    private static final int MAX_DIRECT_TRANSFER_SIZE;\n+    private static final long MAX_DIRECT_TRANSFER_SIZE;\n@@ -492,1 +492,1 @@\n-    private long transferToDirectlyInternal(long position, int icount,\n+    private long transferToDirectlyInternal(long position, long count,\n@@ -508,1 +508,1 @@\n-                n = transferTo0(fd, position, icount, targetFD);\n+                n = transferTo0(fd, position, count, targetFD);\n@@ -529,1 +529,1 @@\n-    private long transferToDirectly(long position, int icount,\n+    private long transferToDirectly(long position, long count,\n@@ -566,1 +566,1 @@\n-                    return transferToDirectlyInternal(position, icount,\n+                    return transferToDirectlyInternal(position, count,\n@@ -573,1 +573,1 @@\n-            return transferToDirectlyInternal(position, icount, target, targetFD);\n+            return transferToDirectlyInternal(position, count, target, targetFD);\n@@ -577,0 +577,4 @@\n+    \/\/ Size threshold above which to use a mapped buffer;\n+    \/\/ transferToArbitraryChannel() is faster for smaller transfers\n+    private static final long TRUSTED_TRANSFER_THRESHOLD = 16L*1024L;\n+\n@@ -584,0 +588,3 @@\n+        if (count < TRUSTED_TRANSFER_THRESHOLD)\n+            return IOStatus.UNSUPPORTED_CASE;\n+\n@@ -693,1 +700,1 @@\n-        int icount = (int)Math.min(count, MAX_DIRECT_TRANSFER_SIZE);\n+        long dcount = Math.min(count, MAX_DIRECT_TRANSFER_SIZE);\n@@ -695,1 +702,1 @@\n-        if ((n = transferToDirectly(position, icount, target)) >= 0)\n+        if ((n = transferToDirectly(position, dcount, target)) >= 0)\n@@ -1375,3 +1382,4 @@\n-    \/\/ Transfers from src to dst, or returns -2 if kernel can't do that\n-    private native long transferTo0(FileDescriptor src, long position,\n-                                    long count, FileDescriptor dst);\n+    \/\/ Transfers from src to dst, or returns IOStatus.UNSUPPORTED (-4)\n+    \/\/ or IOStatus.UNSUPPORTED_CASE (-6) if kernel can't do that\n+    private static native long transferTo0(FileDescriptor src, long position,\n+                                           long count, FileDescriptor dst);\n@@ -1380,1 +1388,1 @@\n-    private static native int maxDirectTransferSize0();\n+    private static native long maxDirectTransferSize0();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+#include <dlfcn.h>\n@@ -50,1 +51,1 @@\n-#include \"java_lang_Integer.h\"\n+#include \"java_lang_Long.h\"\n@@ -53,0 +54,7 @@\n+#if defined(__linux__)\n+typedef ssize_t copy_file_range_func(int fd_in, off64_t *off_in,\n+                                     int fd_out, off64_t *off_out,\n+                                     size_t len, unsigned int flags);\n+static copy_file_range_func* my_copy_file_range_func = NULL;\n+#endif\n+\n@@ -60,0 +68,3 @@\n+#if defined(__linux__)\n+    my_copy_file_range_func = (copy_file_range_func*)dlsym(RTLD_DEFAULT, \"copy_file_range\");\n+#endif\n@@ -172,1 +183,8 @@\n-    jlong n = sendfile64(dstFD, srcFD, &offset, (size_t)count);\n+    jlong n;\n+    if (my_copy_file_range_func != NULL) {\n+        size_t len = (size_t)count;\n+        n = my_copy_file_range_func(srcFD, &offset, dstFD, NULL, len, 0);\n+        if (n >= 0)\n+            return n;\n+    }\n+    n = sendfile64(dstFD, srcFD, &offset, (size_t)count);\n@@ -255,1 +273,1 @@\n-JNIEXPORT jint JNICALL\n+JNIEXPORT jlong JNICALL\n@@ -259,1 +277,3 @@\n-    return 0x7ffff000; \/\/ 2,147,479,552 maximum for sendfile()\n+    return my_copy_file_range_func != NULL ?\n+           java_lang_Long_MAX_VALUE : \/\/ maximum value of type ssize_t\n+           0x7ffff000;                \/\/ 2,147,479,552 maximum for sendfile()\n@@ -261,1 +281,1 @@\n-    return java_lang_Integer_MAX_VALUE;\n+    return java_lang_Long_MAX_VALUE;\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/FileChannelImpl.c","additions":26,"deletions":6,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -196,2 +196,1 @@\n-\n-JNIEXPORT jint JNICALL\n+JNIEXPORT jlong JNICALL\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/FileChannelImpl.c","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 4652496\n+ * @bug 4652496 8274112\n@@ -27,0 +27,2 @@\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n@@ -29,0 +31,1 @@\n+ * @key randomness\n@@ -31,0 +34,7 @@\n+import java.io.BufferedOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n@@ -33,2 +43,2 @@\n-import java.nio.ByteBuffer;\n-import java.io.*;\n+import java.nio.file.Files;\n+import java.util.Arrays;\n@@ -36,0 +46,1 @@\n+import jdk.test.lib.RandomFactory;\n@@ -39,5 +50,15 @@\n-    static File file;\n-    static File outFile;\n-    static FileChannel in;\n-    \/\/ Chunk size should be larger than FileChannelImpl.TRANSFER_SIZE for good test\n-    static int CHUNK_SIZE = 1024 * 9;\n+    private static final Random RAND = RandomFactory.getRandom();\n+\n+    private static final int FILE_SIZE = 1000*1024;\n+\n+    \/\/ Chunk size should be larger than FileChannelImpl.TRANSFER_SIZE (8192)\n+    \/\/ for a good test\n+    private static final int CHUNK_SIZE = 1024 * 9;\n+\n+    \/\/ This should be the same values as FCOPYFILE_THRESHOLD in\n+    \/\/ the Unix version of FileChannelImpl.c.\n+    private static final int MIN_DIRECT_TRANSFER_SIZE = 512000;\n+\n+    private static File file;\n+    private static File outFile;\n+    private static FileChannel in;\n@@ -55,0 +76,1 @@\n+        test3();\n@@ -60,1 +82,1 @@\n-    static void test1() throws Exception {\n+    private static void test1() throws Exception {\n@@ -64,1 +86,1 @@\n-            System.err.println(\"Transferred file...\");\n+            System.err.println(\"Transferred file to user channel...\");\n@@ -68,1 +90,1 @@\n-    static void test2() throws Exception {\n+    private static void test2() throws Exception {\n@@ -72,1 +94,1 @@\n-            System.err.println(\"Transferred file...\");\n+            System.err.println(\"Transferred file to trusted channel...\");\n@@ -76,1 +98,9 @@\n-    static void transferFileToUserChannel() throws Exception {\n+    private static void test3() throws Exception {\n+        for (int i=0; i<10; i++) {\n+            transferFileDirectly();\n+            System.gc();\n+            System.err.println(\"Transferred file directly...\");\n+        }\n+    }\n+\n+    private static void transferFileToUserChannel() throws Exception {\n@@ -80,21 +110,21 @@\n-                Random rand = new Random(0);\n-                public int write(ByteBuffer src) throws IOException {\n-                    int read = src.remaining();\n-                    byte[] incoming = new byte[read];\n-                    src.get(incoming);\n-                    checkData(incoming, read);\n-                    return read == 0 ? -1 : read;\n-                }\n-                public boolean isOpen() {\n-                    return true;\n-                }\n-                public void close() throws IOException {\n-                }\n-                void checkData(byte[] incoming, int size) {\n-                    byte[] expected = new byte[size];\n-                    rand.nextBytes(expected);\n-                    for (int i=0; i<size; i++)\n-                        if (incoming[i] != expected[i])\n-                            throw new RuntimeException(\"Data corrupted\");\n-                }\n-            };\n+            Random rand = new Random(0);\n+            public int write(ByteBuffer src) throws IOException {\n+                int read = src.remaining();\n+                byte[] incoming = new byte[read];\n+                src.get(incoming);\n+                checkData(incoming, read);\n+                return read == 0 ? -1 : read;\n+            }\n+            public boolean isOpen() {\n+                return true;\n+            }\n+            public void close() throws IOException {\n+            }\n+            void checkData(byte[] incoming, int size) {\n+                byte[] expected = new byte[size];\n+                rand.nextBytes(expected);\n+                for (int i=0; i<size; i++)\n+                    if (incoming[i] != expected[i])\n+                        throw new RuntimeException(\"Data corrupted\");\n+            }\n+        };\n@@ -111,1 +141,1 @@\n-    static void transferFileToTrustedChannel() throws Exception {\n+    private static void transferFileToTrustedChannel() throws Exception {\n@@ -127,1 +157,26 @@\n-    static void generateBigFile(File file) throws Exception {\n+    private static void transferFileDirectly() throws Exception {\n+        outFile.delete();\n+        FileOutputStream fos = new FileOutputStream(outFile);\n+        FileChannel out = fos.getChannel();\n+\n+        final long size = in.size();\n+        final long position = RAND.nextInt((int)size - MIN_DIRECT_TRANSFER_SIZE);\n+        assert out.position() == 0;\n+        long pos = position;\n+        while (pos < size) {\n+            long bytesTransferred = in.transferTo(pos, Long.MAX_VALUE, out);\n+            if (bytesTransferred >= 0)\n+                pos += bytesTransferred;\n+            else\n+                throw new Exception(\"transfer failed\");\n+        }\n+        out.close();\n+\n+        byte[] expected = Files.readAllBytes(file.toPath());\n+        byte[] actual = Files.readAllBytes(outFile.toPath());\n+        if (!Arrays.equals(expected, (int)position, (int)size,\n+                           actual, 0, (int)(size - position)))\n+            throw new Exception(\"Actual bytes do not match expected bytes\");\n+    }\n+\n+    private static void generateBigFile(File file) throws Exception {\n@@ -132,1 +187,3 @@\n-        for (int i = 0; i < 1000; i++) {\n+        int numWritten = 0;\n+        while (numWritten < FILE_SIZE) {\n+            int nwrite = Math.min(randomBytes.length, FILE_SIZE - numWritten);\n@@ -134,1 +191,2 @@\n-            out.write(randomBytes);\n+            out.write(randomBytes, 0, nwrite);\n+            numWritten += nwrite;\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/TransferToChannel.java","additions":97,"deletions":39,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -435,4 +435,10 @@\n-        int n = (int)fc.transferTo(off, len, tgt.channel());\n-        if (n != len)\n-            throw new Failure(\"Incorrect transfer length: \" + n\n-                              + \" (expected \" + len + \")\");\n+        long position = off;\n+        long count = len;\n+        while (count > 0) {\n+            long n = (int)fc.transferTo(position, count, tgt.channel());\n+            if (n < 0 || n > count)\n+                throw new Failure(\"Incorrect transfer length n = : \" + n\n+                                  + \" (expected 0 <= n <= \" + len + \")\");\n+            position += n;\n+            count -= n;\n+        }\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/Transfers.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"}]}