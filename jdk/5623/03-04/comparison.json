{"files":[{"patch":"@@ -577,57 +577,3 @@\n-    \/\/ Assume that the underlying kernel supports a fast file copying\n-    \/\/ function such as copy_file_range(2) (Linux) or fcopyfile(3) (macOS);\n-    \/\/ set this to false if we find out later that it doesn't\n-    \/\/\n-    private static volatile boolean transferToFileChannelSupported = true;\n-\n-    private long transferToFileChannelInternal(long position, long count,\n-                                               FileChannelImpl target,\n-                                               FileDescriptor targetFD)\n-        throws IOException\n-    {\n-        assert !nd.transferToFileChannelNeedsPositionLock() ||\n-               Thread.holdsLock(positionLock);\n-\n-        long n = -1;\n-        int ti = -1;\n-        try {\n-            beginBlocking();\n-            ti = threads.add();\n-            if (!isOpen())\n-                return -1;\n-            do {\n-                n = transferToFileChannel0(fd, position, count, targetFD);\n-            } while ((n == IOStatus.INTERRUPTED) && isOpen());\n-            if (n == IOStatus.UNSUPPORTED) {\n-                \/\/ Don't bother trying again\n-                transferToFileChannelSupported = false;\n-            }\n-            return IOStatus.normalize(n);\n-        } finally {\n-            threads.remove(ti);\n-            end (n > -1);\n-        }\n-    }\n-\n-    private long transferToFileChannel(long position, long count,\n-                                       FileChannelImpl target)\n-        throws IOException\n-    {\n-        if (!transferToFileChannelSupported)\n-            return IOStatus.UNSUPPORTED;\n-\n-        if (nd.transferToFileChannelNeedsPositionLock()) {\n-            synchronized (positionLock) {\n-                long pos = position();\n-                try {\n-                    return transferToFileChannelInternal(position, count,\n-                                                         target, target.fd);\n-                } finally {\n-                    position(pos);\n-                }\n-            }\n-        } else {\n-            return transferToFileChannelInternal(position, count,\n-                                                 target, target.fd);\n-        }\n-    }\n+    \/\/ Size threshold above which to use a mapped buffer;\n+    \/\/ transferToArbitraryChannel() is faster for smaller transfers\n+    private static final long TRUSTED_TRANSFER_THRESHOLD = 16L*1024L;\n@@ -642,0 +588,3 @@\n+        if (count < TRUSTED_TRANSFER_THRESHOLD)\n+            return IOStatus.UNSUPPORTED_CASE;\n+\n@@ -756,5 +705,0 @@\n-        \/\/ Attempt a transfer using native functions, if available\n-        if (target instanceof FileChannelImpl targetFCI)\n-            if ((n = transferToFileChannel(position, count, targetFCI)) >= 0)\n-                return n;\n-\n@@ -1446,6 +1390,0 @@\n-    \/\/ Transfers from src to dst, or returns IOStatus.UNSUPPORTED (-4)\n-    \/\/ or IOStatus.UNSUPPORTED_CASE (-6) if kernel can't do that\n-    private static native long transferToFileChannel0(FileDescriptor src,\n-                                                      long position, long count,\n-                                                      FileDescriptor dst);\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":6,"deletions":68,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -70,2 +70,0 @@\n-    abstract boolean transferToFileChannelNeedsPositionLock();\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileDispatcher.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -129,4 +129,0 @@\n-    boolean transferToFileChannelNeedsPositionLock() {\n-        return false;\n-    }\n-\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/FileDispatcherImpl.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+#include <dlfcn.h>\n@@ -50,1 +51,1 @@\n-#include \"java_lang_Integer.h\"\n+#include \"java_lang_Long.h\"\n@@ -53,0 +54,7 @@\n+#if defined(__linux__)\n+typedef ssize_t copy_file_range_func(int fd_in, off64_t *off_in,\n+                                     int fd_out, off64_t *off_out,\n+                                     size_t len, unsigned int flags);\n+static copy_file_range_func* my_copy_file_range_func = NULL;\n+#endif\n+\n@@ -60,0 +68,3 @@\n+#if defined(__linux__)\n+    my_copy_file_range_func = (copy_file_range_func*)dlsym(RTLD_DEFAULT, \"copy_file_range\");\n+#endif\n@@ -172,1 +183,8 @@\n-    jlong n = sendfile64(dstFD, srcFD, &offset, (size_t)count);\n+    jlong n;\n+    if (my_copy_file_range_func != NULL) {\n+        size_t len = (size_t)count;\n+        n = my_copy_file_range_func(srcFD, &offset, dstFD, NULL, len, 0);\n+        if (n >= 0)\n+            return n;\n+    }\n+    n = sendfile64(dstFD, srcFD, &offset, (size_t)count);\n@@ -259,60 +277,3 @@\n-    return 0x7ffff000; \/\/ 2,147,479,552 maximum for sendfile()\n-#else\n-    return java_lang_Integer_MAX_VALUE;\n-#endif\n-}\n-\n-#if defined(__APPLE__)\n-#define RESTARTABLE(_cmd, _result) do { \\\n-  do { \\\n-    _result = _cmd; \\\n-  } while((_result == -1) && (errno == EINTR)); \\\n-} while(0)\n-\n-#define READ_WRITE_TRANSFER_SIZE 32768\n-\n-long transfer_read_write(JNIEnv* env, jint src, jlong position, jlong count,\n-                         jint dst)\n-{\n-    char buf[READ_WRITE_TRANSFER_SIZE];\n-\n-    ssize_t tw = 0;\n-    off_t offset = (off_t)position;\n-    while (tw < count) {\n-        ssize_t remaining = count - tw;\n-        ssize_t nr = remaining < READ_WRITE_TRANSFER_SIZE ?\n-            remaining : READ_WRITE_TRANSFER_SIZE;\n-        RESTARTABLE(pread((int)src, &buf, nr, offset), nr);\n-        if (nr <= 0) {\n-            break;\n-        }\n-        offset += nr;\n-\n-        ssize_t nw;\n-        RESTARTABLE(write((int)dst, &buf, nr), nw);\n-        tw += nw;\n-        if (nw != nr)\n-            return tw;\n-    }\n-\n-    return tw;\n-}\n-#endif\n-\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileChannelImpl_transferToFileChannel0(JNIEnv *env,\n-                                                       jobject this,\n-                                                       jobject srcFDO,\n-                                                       jlong position,\n-                                                       jlong count,\n-                                                       jobject dstFDO)\n-{\n-    jint srcFD = fdval(env, srcFDO);\n-    jint dstFD = fdval(env, dstFDO);\n-\n-#if defined(__linux__)\n-    \/\/ Once the Linux kernel version used for the JDK production build is at\n-    \/\/ least 5.3, copy_file_range(2) could be used here.\n-    return IOS_UNSUPPORTED;\n-#elif defined(__APPLE__)\n-    return transfer_read_write(env, srcFD, position, count, dstFD);\n+    return my_copy_file_range_func != NULL ?\n+           java_lang_Long_MAX_VALUE : \/\/ maximum value of type ssize_t\n+           0x7ffff000;                \/\/ 2,147,479,552 maximum for sendfile()\n@@ -320,1 +281,1 @@\n-    return IOS_UNSUPPORTED;\n+    return java_lang_Long_MAX_VALUE;\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/FileChannelImpl.c","additions":25,"deletions":64,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -128,4 +128,0 @@\n-    boolean transferToFileChannelNeedsPositionLock() {\n-        return true;\n-    }\n-\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/FileDispatcherImpl.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-#include \"java_lang_Long.h\"\n@@ -200,53 +199,1 @@\n-    return java_lang_Long_MAX_VALUE;\n-}\n-\n-#define READ_WRITE_TRANSFER_SIZE  32768\n-#define READ_WRITE_TRANSFER_LIMIT 2097152\n-\n-DWORD transfer_read_write(JNIEnv* env, HANDLE src, DWORD position, DWORD count,\n-                          HANDLE dst)\n-{\n-    LARGE_INTEGER where;\n-    where.QuadPart = (LONGLONG)position;\n-    if (SetFilePointerEx(src, where, &where, FILE_BEGIN) == 0) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"SetFilePointerEx failed\");\n-        return IOS_THROWN;\n-    }\n-\n-    char buf[READ_WRITE_TRANSFER_SIZE];\n-\n-    DWORD tw = 0;\n-    while (tw < count) {\n-        DWORD remaining = count - tw;\n-        DWORD nr = remaining < READ_WRITE_TRANSFER_SIZE ?\n-            remaining : READ_WRITE_TRANSFER_SIZE;\n-        if (ReadFile(src, (LPVOID)&buf, nr, &nr, NULL) == 0 || nr <= 0)\n-            break;\n-\n-        DWORD nw = 0;\n-        if (WriteFile(dst, &buf, nr, &nw, NULL) == 0)\n-            break;\n-        tw += nw;\n-        if (nw != nr)\n-            break;\n-    }\n-\n-    return tw;\n-}\n-\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileChannelImpl_transferToFileChannel0(JNIEnv *env,\n-                                                       jobject this,\n-                                                       jobject srcFDO,\n-                                                       jlong position,\n-                                                       jlong count,\n-                                                       jobject dstFDO)\n-{\n-      HANDLE src = (HANDLE)(handleval(env, srcFDO));\n-      HANDLE dst = (HANDLE)(handleval(env, dstFDO));\n-\n-      if (src != dst && count < READ_WRITE_TRANSFER_LIMIT)\n-          return transfer_read_write(env, src, (DWORD)position, (DWORD)count,\n-                                     dst);\n-\n-      return IOS_UNSUPPORTED_CASE;\n+    return MAX_TRANSMIT_SIZE;\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/FileChannelImpl.c","additions":2,"deletions":55,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/TransferToChannel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -435,4 +435,10 @@\n-        int n = (int)fc.transferTo(off, len, tgt.channel());\n-        if (n != len)\n-            throw new Failure(\"Incorrect transfer length: \" + n\n-                              + \" (expected \" + len + \")\");\n+        long position = off;\n+        long count = len;\n+        while (count > 0) {\n+            long n = (int)fc.transferTo(position, count, tgt.channel());\n+            if (n < 0 || n > count)\n+                throw new Failure(\"Incorrect transfer length n = : \" + n\n+                                  + \" (expected 0 <= n <= \" + len + \")\");\n+            position += n;\n+            count -= n;\n+        }\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/Transfers.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"}]}