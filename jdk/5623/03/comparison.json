{"files":[{"patch":"@@ -69,1 +69,1 @@\n-    private static final int MAX_DIRECT_TRANSFER_SIZE;\n+    private static final long MAX_DIRECT_TRANSFER_SIZE;\n@@ -492,1 +492,1 @@\n-    private long transferToDirectlyInternal(long position, int icount,\n+    private long transferToDirectlyInternal(long position, long count,\n@@ -508,1 +508,1 @@\n-                n = transferTo0(fd, position, icount, targetFD);\n+                n = transferTo0(fd, position, count, targetFD);\n@@ -529,1 +529,1 @@\n-    private long transferToDirectly(long position, int icount,\n+    private long transferToDirectly(long position, long count,\n@@ -566,1 +566,1 @@\n-                    return transferToDirectlyInternal(position, icount,\n+                    return transferToDirectlyInternal(position, count,\n@@ -573,1 +573,59 @@\n-            return transferToDirectlyInternal(position, icount, target, targetFD);\n+            return transferToDirectlyInternal(position, count, target, targetFD);\n+        }\n+    }\n+\n+    \/\/ Assume that the underlying kernel supports a fast file copying\n+    \/\/ function such as copy_file_range(2) (Linux) or fcopyfile(3) (macOS);\n+    \/\/ set this to false if we find out later that it doesn't\n+    \/\/\n+    private static volatile boolean transferToFileChannelSupported = true;\n+\n+    private long transferToFileChannelInternal(long position, long count,\n+                                               FileChannelImpl target,\n+                                               FileDescriptor targetFD)\n+        throws IOException\n+    {\n+        assert !nd.transferToFileChannelNeedsPositionLock() ||\n+               Thread.holdsLock(positionLock);\n+\n+        long n = -1;\n+        int ti = -1;\n+        try {\n+            beginBlocking();\n+            ti = threads.add();\n+            if (!isOpen())\n+                return -1;\n+            do {\n+                n = transferToFileChannel0(fd, position, count, targetFD);\n+            } while ((n == IOStatus.INTERRUPTED) && isOpen());\n+            if (n == IOStatus.UNSUPPORTED) {\n+                \/\/ Don't bother trying again\n+                transferToFileChannelSupported = false;\n+            }\n+            return IOStatus.normalize(n);\n+        } finally {\n+            threads.remove(ti);\n+            end (n > -1);\n+        }\n+    }\n+\n+    private long transferToFileChannel(long position, long count,\n+                                       FileChannelImpl target)\n+        throws IOException\n+    {\n+        if (!transferToFileChannelSupported)\n+            return IOStatus.UNSUPPORTED;\n+\n+        if (nd.transferToFileChannelNeedsPositionLock()) {\n+            synchronized (positionLock) {\n+                long pos = position();\n+                try {\n+                    return transferToFileChannelInternal(position, count,\n+                                                         target, target.fd);\n+                } finally {\n+                    position(pos);\n+                }\n+            }\n+        } else {\n+            return transferToFileChannelInternal(position, count,\n+                                                 target, target.fd);\n@@ -693,1 +751,1 @@\n-        int icount = (int)Math.min(count, MAX_DIRECT_TRANSFER_SIZE);\n+        long dcount = Math.min(count, MAX_DIRECT_TRANSFER_SIZE);\n@@ -695,1 +753,1 @@\n-        if ((n = transferToDirectly(position, icount, target)) >= 0)\n+        if ((n = transferToDirectly(position, dcount, target)) >= 0)\n@@ -698,0 +756,5 @@\n+        \/\/ Attempt a transfer using native functions, if available\n+        if (target instanceof FileChannelImpl targetFCI)\n+            if ((n = transferToFileChannel(position, count, targetFCI)) >= 0)\n+                return n;\n+\n@@ -1371,3 +1434,4 @@\n-    \/\/ Transfers from src to dst, or returns -2 if kernel can't do that\n-    private native long transferTo0(FileDescriptor src, long position,\n-                                    long count, FileDescriptor dst);\n+    \/\/ Transfers from src to dst, or returns IOStatus.UNSUPPORTED (-4)\n+    \/\/ or IOStatus.UNSUPPORTED_CASE (-6) if kernel can't do that\n+    private static native long transferTo0(FileDescriptor src, long position,\n+                                           long count, FileDescriptor dst);\n@@ -1376,1 +1440,7 @@\n-    private static native int maxDirectTransferSize0();\n+    private static native long maxDirectTransferSize0();\n+\n+    \/\/ Transfers from src to dst, or returns IOStatus.UNSUPPORTED (-4)\n+    \/\/ or IOStatus.UNSUPPORTED_CASE (-6) if kernel can't do that\n+    private static native long transferToFileChannel0(FileDescriptor src,\n+                                                      long position, long count,\n+                                                      FileDescriptor dst);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":82,"deletions":12,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -70,0 +70,2 @@\n+    abstract boolean transferToFileChannelNeedsPositionLock();\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileDispatcher.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -129,0 +129,4 @@\n+    boolean transferToFileChannelNeedsPositionLock() {\n+        return false;\n+    }\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/FileDispatcherImpl.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -255,1 +255,1 @@\n-JNIEXPORT jint JNICALL\n+JNIEXPORT jlong JNICALL\n@@ -264,0 +264,59 @@\n+\n+#if defined(__APPLE__)\n+#define RESTARTABLE(_cmd, _result) do { \\\n+  do { \\\n+    _result = _cmd; \\\n+  } while((_result == -1) && (errno == EINTR)); \\\n+} while(0)\n+\n+#define READ_WRITE_TRANSFER_SIZE 32768\n+\n+long transfer_read_write(JNIEnv* env, jint src, jlong position, jlong count,\n+                         jint dst)\n+{\n+    char buf[READ_WRITE_TRANSFER_SIZE];\n+\n+    ssize_t tw = 0;\n+    off_t offset = (off_t)position;\n+    while (tw < count) {\n+        ssize_t remaining = count - tw;\n+        ssize_t nr = remaining < READ_WRITE_TRANSFER_SIZE ?\n+            remaining : READ_WRITE_TRANSFER_SIZE;\n+        RESTARTABLE(pread((int)src, &buf, nr, offset), nr);\n+        if (nr <= 0) {\n+            break;\n+        }\n+        offset += nr;\n+\n+        ssize_t nw;\n+        RESTARTABLE(write((int)dst, &buf, nr), nw);\n+        tw += nw;\n+        if (nw != nr)\n+            return tw;\n+    }\n+\n+    return tw;\n+}\n+#endif\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_FileChannelImpl_transferToFileChannel0(JNIEnv *env,\n+                                                       jobject this,\n+                                                       jobject srcFDO,\n+                                                       jlong position,\n+                                                       jlong count,\n+                                                       jobject dstFDO)\n+{\n+    jint srcFD = fdval(env, srcFDO);\n+    jint dstFD = fdval(env, dstFDO);\n+\n+#if defined(__linux__)\n+    \/\/ Once the Linux kernel version used for the JDK production build is at\n+    \/\/ least 5.3, copy_file_range(2) could be used here.\n+    return IOS_UNSUPPORTED;\n+#elif defined(__APPLE__)\n+    return transfer_read_write(env, srcFD, position, count, dstFD);\n+#else\n+    return IOS_UNSUPPORTED;\n+#endif\n+}\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/FileChannelImpl.c","additions":60,"deletions":1,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -128,0 +128,4 @@\n+    boolean transferToFileChannelNeedsPositionLock() {\n+        return true;\n+    }\n+\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/FileDispatcherImpl.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"java_lang_Long.h\"\n@@ -196,2 +197,1 @@\n-\n-JNIEXPORT jint JNICALL\n+JNIEXPORT jlong JNICALL\n@@ -200,1 +200,53 @@\n-    return MAX_TRANSMIT_SIZE;\n+    return java_lang_Long_MAX_VALUE;\n+}\n+\n+#define READ_WRITE_TRANSFER_SIZE  32768\n+#define READ_WRITE_TRANSFER_LIMIT 2097152\n+\n+DWORD transfer_read_write(JNIEnv* env, HANDLE src, DWORD position, DWORD count,\n+                          HANDLE dst)\n+{\n+    LARGE_INTEGER where;\n+    where.QuadPart = (LONGLONG)position;\n+    if (SetFilePointerEx(src, where, &where, FILE_BEGIN) == 0) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"SetFilePointerEx failed\");\n+        return IOS_THROWN;\n+    }\n+\n+    char buf[READ_WRITE_TRANSFER_SIZE];\n+\n+    DWORD tw = 0;\n+    while (tw < count) {\n+        DWORD remaining = count - tw;\n+        DWORD nr = remaining < READ_WRITE_TRANSFER_SIZE ?\n+            remaining : READ_WRITE_TRANSFER_SIZE;\n+        if (ReadFile(src, (LPVOID)&buf, nr, &nr, NULL) == 0 || nr <= 0)\n+            break;\n+\n+        DWORD nw = 0;\n+        if (WriteFile(dst, &buf, nr, &nw, NULL) == 0)\n+            break;\n+        tw += nw;\n+        if (nw != nr)\n+            break;\n+    }\n+\n+    return tw;\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_FileChannelImpl_transferToFileChannel0(JNIEnv *env,\n+                                                       jobject this,\n+                                                       jobject srcFDO,\n+                                                       jlong position,\n+                                                       jlong count,\n+                                                       jobject dstFDO)\n+{\n+      HANDLE src = (HANDLE)(handleval(env, srcFDO));\n+      HANDLE dst = (HANDLE)(handleval(env, dstFDO));\n+\n+      if (src != dst && count < READ_WRITE_TRANSFER_LIMIT)\n+          return transfer_read_write(env, src, (DWORD)position, (DWORD)count,\n+                                     dst);\n+\n+      return IOS_UNSUPPORTED_CASE;\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/FileChannelImpl.c","additions":55,"deletions":3,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 4652496\n+ * @bug 4652496 8274112\n@@ -27,0 +27,2 @@\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n@@ -29,0 +31,1 @@\n+ * @key randomness\n@@ -31,0 +34,7 @@\n+import java.io.BufferedOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n@@ -33,2 +43,2 @@\n-import java.nio.ByteBuffer;\n-import java.io.*;\n+import java.nio.file.Files;\n+import java.util.Arrays;\n@@ -36,0 +46,1 @@\n+import jdk.test.lib.RandomFactory;\n@@ -39,5 +50,15 @@\n-    static File file;\n-    static File outFile;\n-    static FileChannel in;\n-    \/\/ Chunk size should be larger than FileChannelImpl.TRANSFER_SIZE for good test\n-    static int CHUNK_SIZE = 1024 * 9;\n+    private static final Random RAND = RandomFactory.getRandom();\n+\n+    private static final int FILE_SIZE = 1000*1024;\n+\n+    \/\/ Chunk size should be larger than FileChannelImpl.TRANSFER_SIZE (8192)\n+    \/\/ for a good test\n+    private static final int CHUNK_SIZE = 1024 * 9;\n+\n+    \/\/ This should be the same values as FCOPYFILE_THRESHOLD in\n+    \/\/ the Unix version of FileChannelImpl.c.\n+    private static final int MIN_DIRECT_TRANSFER_SIZE = 512000;\n+\n+    private static File file;\n+    private static File outFile;\n+    private static FileChannel in;\n@@ -55,0 +76,1 @@\n+        test3();\n@@ -60,1 +82,1 @@\n-    static void test1() throws Exception {\n+    private static void test1() throws Exception {\n@@ -64,1 +86,1 @@\n-            System.err.println(\"Transferred file...\");\n+            System.err.println(\"Transferred file to user channel...\");\n@@ -68,1 +90,1 @@\n-    static void test2() throws Exception {\n+    private static void test2() throws Exception {\n@@ -72,1 +94,1 @@\n-            System.err.println(\"Transferred file...\");\n+            System.err.println(\"Transferred file to trusted channel...\");\n@@ -76,1 +98,9 @@\n-    static void transferFileToUserChannel() throws Exception {\n+    private static void test3() throws Exception {\n+        for (int i=0; i<10; i++) {\n+            transferFileDirectly();\n+            System.gc();\n+            System.err.println(\"Transferred file directly...\");\n+        }\n+    }\n+\n+    private static void transferFileToUserChannel() throws Exception {\n@@ -80,21 +110,21 @@\n-                Random rand = new Random(0);\n-                public int write(ByteBuffer src) throws IOException {\n-                    int read = src.remaining();\n-                    byte[] incoming = new byte[read];\n-                    src.get(incoming);\n-                    checkData(incoming, read);\n-                    return read == 0 ? -1 : read;\n-                }\n-                public boolean isOpen() {\n-                    return true;\n-                }\n-                public void close() throws IOException {\n-                }\n-                void checkData(byte[] incoming, int size) {\n-                    byte[] expected = new byte[size];\n-                    rand.nextBytes(expected);\n-                    for (int i=0; i<size; i++)\n-                        if (incoming[i] != expected[i])\n-                            throw new RuntimeException(\"Data corrupted\");\n-                }\n-            };\n+            Random rand = new Random(0);\n+            public int write(ByteBuffer src) throws IOException {\n+                int read = src.remaining();\n+                byte[] incoming = new byte[read];\n+                src.get(incoming);\n+                checkData(incoming, read);\n+                return read == 0 ? -1 : read;\n+            }\n+            public boolean isOpen() {\n+                return true;\n+            }\n+            public void close() throws IOException {\n+            }\n+            void checkData(byte[] incoming, int size) {\n+                byte[] expected = new byte[size];\n+                rand.nextBytes(expected);\n+                for (int i=0; i<size; i++)\n+                    if (incoming[i] != expected[i])\n+                        throw new RuntimeException(\"Data corrupted\");\n+            }\n+        };\n@@ -111,1 +141,1 @@\n-    static void transferFileToTrustedChannel() throws Exception {\n+    private static void transferFileToTrustedChannel() throws Exception {\n@@ -127,1 +157,26 @@\n-    static void generateBigFile(File file) throws Exception {\n+    private static void transferFileDirectly() throws Exception {\n+        outFile.delete();\n+        FileOutputStream fos = new FileOutputStream(outFile);\n+        FileChannel out = fos.getChannel();\n+\n+        final long size = in.size();\n+        final long position = RAND.nextInt((int)size - MIN_DIRECT_TRANSFER_SIZE);\n+        assert out.position() == 0;\n+        long pos = position;\n+        while (pos < size) {\n+            long bytesTransferred = in.transferTo(pos, Long.MAX_VALUE, out);\n+            if (bytesTransferred >= 0)\n+                pos += bytesTransferred;\n+            else\n+                throw new Exception(\"transfer failed\");\n+        }\n+        out.close();\n+\n+        byte[] expected = Files.readAllBytes(file.toPath());\n+        byte[] actual = Files.readAllBytes(outFile.toPath());\n+        if (!Arrays.equals(expected, (int)position, (int)size,\n+                           actual, 0, (int)(size - position)))\n+            throw new Exception(\"Actual bytes do not match expected bytes\");\n+    }\n+\n+    private static void generateBigFile(File file) throws Exception {\n@@ -132,1 +187,3 @@\n-        for (int i = 0; i < 1000; i++) {\n+        int numWritten = 0;\n+        while (numWritten < FILE_SIZE) {\n+            int nwrite = Math.min(randomBytes.length, FILE_SIZE - numWritten);\n@@ -134,1 +191,2 @@\n-            out.write(randomBytes);\n+            out.write(randomBytes, 0, nwrite);\n+            numWritten += nwrite;\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/TransferToChannel.java","additions":97,"deletions":39,"binary":false,"changes":136,"status":"modified"}]}