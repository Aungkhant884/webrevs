{"files":[{"patch":"@@ -61,4 +61,0 @@\n- *\n- * suspendCount is the number of outstanding suspends\n- * from the debugger. suspends from the app itself are\n- * not included in this count.\n@@ -77,1 +73,0 @@\n-    unsigned int handlingAppResume : 1;\n@@ -80,2 +75,1 @@\n-    jint suspendCount;\n-    jint resumeFrameDepth; \/* !=0 => This thread is in a call to Thread.resume() *\/\n+    jint suspendCount;     \/* Number of outstanding suspends from the debugger. *\/\n@@ -115,4 +109,0 @@\n-static jlocation resumeLocation;\n-static HandlerNode *breakpointHandlerNode;\n-static HandlerNode *framePopHandlerNode;\n-static HandlerNode *catchHandlerNode;\n@@ -155,14 +145,0 @@\n-static jint\n-getStackDepth(jthread thread)\n-{\n-    jint count = 0;\n-    jvmtiError error;\n-\n-    error = JVMTI_FUNC_PTR(gdata->jvmti,GetFrameCount)\n-                        (gdata->jvmti, thread, &count);\n-    if (error != JVMTI_ERROR_NONE) {\n-        EXIT_ERROR(error, \"getting frame count\");\n-    }\n-    return count;\n-}\n-\n@@ -674,3 +650,0 @@\n-    jlocation unused;\n-    jvmtiError error;\n-\n@@ -683,200 +656,0 @@\n-    if (gdata->threadClass==NULL) {\n-        EXIT_ERROR(AGENT_ERROR_NULL_POINTER, \"no java.lang.thread class\");\n-    }\n-    if (gdata->threadResume==0) {\n-        EXIT_ERROR(AGENT_ERROR_NULL_POINTER, \"cannot resume thread\");\n-    }\n-    \/* Get the java.lang.Thread.resume() method beginning location *\/\n-    error = methodLocation(gdata->threadResume, &resumeLocation, &unused);\n-    if (error != JVMTI_ERROR_NONE) {\n-        EXIT_ERROR(error, \"getting method location\");\n-    }\n-}\n-\n-static jthread\n-getResumee(jthread resumingThread)\n-{\n-    jthread resumee = NULL;\n-    jvmtiError error;\n-    jobject object;\n-    FrameNumber fnum = 0;\n-\n-    error = JVMTI_FUNC_PTR(gdata->jvmti,GetLocalObject)\n-                    (gdata->jvmti, resumingThread, fnum, 0, &object);\n-    if (error == JVMTI_ERROR_NONE) {\n-        resumee = object;\n-    }\n-    return resumee;\n-}\n-\n-\n-static jboolean\n-pendingAppResume(jboolean includeSuspended)\n-{\n-    ThreadList *list;\n-    ThreadNode *node;\n-\n-    list = &runningThreads;\n-    node = list->first;\n-    while (node != NULL) {\n-        if (node->resumeFrameDepth > 0) {\n-            if (includeSuspended) {\n-                return JNI_TRUE;\n-            } else {\n-                jvmtiError error;\n-                jint       state;\n-\n-                error = threadState(node->thread, &state);\n-                if (error != JVMTI_ERROR_NONE) {\n-                    EXIT_ERROR(error, \"getting thread state\");\n-                }\n-                \/* !node->handlingAppResume && resumeFrameDepth > 0\n-                 * means the thread has entered Thread.resume() *\/\n-                if (!(state & JVMTI_THREAD_STATE_SUSPENDED) &&\n-                    !node->handlingAppResume) {\n-                    return JNI_TRUE;\n-                }\n-            }\n-        }\n-        node = node->next;\n-        if (node == NULL && list == &runningThreads) {\n-            \/\/ We need to look at runningVThreads after we are done with runningThreads.\n-            list = &runningVThreads;\n-            node = list->first;\n-        }\n-    }\n-    return JNI_FALSE;\n-}\n-\n-static void\n-notifyAppResumeComplete(void)\n-{\n-    debugMonitorNotifyAll(threadLock);\n-    if (!pendingAppResume(JNI_TRUE)) {\n-        if (framePopHandlerNode != NULL) {\n-            (void)eventHandler_free(framePopHandlerNode);\n-            framePopHandlerNode = NULL;\n-        }\n-        if (catchHandlerNode != NULL) {\n-            (void)eventHandler_free(catchHandlerNode);\n-            catchHandlerNode = NULL;\n-        }\n-    }\n-}\n-\n-\/*\n- * Event handler for FRAME_POP and EXCEPTION_CATCH when in Thread.resume()\n- * so we can detect its completion.\n- *\/\n-static void\n-handleAppResumeCompletion(JNIEnv *env, EventInfo *evinfo,\n-                          HandlerNode *handlerNode,\n-                          struct bag *eventBag)\n-{\n-    ThreadNode *node;\n-    jthread     thread;\n-\n-    thread = evinfo->thread;\n-\n-    debugMonitorEnter(threadLock);\n-\n-    node = findRunningThread(thread);\n-    if (node != NULL) {\n-        if (node->resumeFrameDepth > 0) {\n-            jint compareDepth = getStackDepth(thread);\n-            if (evinfo->ei == EI_FRAME_POP) {\n-                compareDepth--;\n-            }\n-            if (compareDepth < node->resumeFrameDepth) {\n-                node->resumeFrameDepth = 0;\n-                notifyAppResumeComplete();\n-            }\n-        }\n-    }\n-\n-    debugMonitorExit(threadLock);\n-}\n-\n-static void\n-blockOnDebuggerSuspend(jthread thread)\n-{\n-    ThreadNode *node;\n-\n-    node = findThread(NULL, thread);\n-    if (node != NULL) {\n-        while (node && node->suspendCount > 0) {\n-            debugMonitorWait(threadLock);\n-            node = findThread(NULL, thread);\n-        }\n-    }\n-}\n-\n-\/*\n- * The caller is expected to hold threadLock and handlerLock.\n- * eventHandler_createInternalThreadOnly() can deadlock because of\n- * wrong lock ordering if the caller does not hold handlerLock.\n- *\/\n-static void\n-trackAppResume(jthread thread)\n-{\n-    jvmtiError  error;\n-    FrameNumber fnum;\n-    ThreadNode *node;\n-\n-    fnum = 0;\n-    node = findRunningThread(thread);\n-    if (node != NULL) {\n-        JDI_ASSERT(node->resumeFrameDepth == 0);\n-        error = JVMTI_FUNC_PTR(gdata->jvmti,NotifyFramePop)\n-                        (gdata->jvmti, thread, fnum);\n-        if (error == JVMTI_ERROR_NONE) {\n-            jint frameDepth = getStackDepth(thread);\n-            if ((frameDepth > 0) && (framePopHandlerNode == NULL)) {\n-                framePopHandlerNode = eventHandler_createInternalThreadOnly(\n-                                           EI_FRAME_POP,\n-                                           handleAppResumeCompletion,\n-                                           thread);\n-                catchHandlerNode = eventHandler_createInternalThreadOnly(\n-                                           EI_EXCEPTION_CATCH,\n-                                           handleAppResumeCompletion,\n-                                           thread);\n-                if ((framePopHandlerNode == NULL) ||\n-                    (catchHandlerNode == NULL)) {\n-                    (void)eventHandler_free(framePopHandlerNode);\n-                    framePopHandlerNode = NULL;\n-                    (void)eventHandler_free(catchHandlerNode);\n-                    catchHandlerNode = NULL;\n-                }\n-            }\n-            if ((framePopHandlerNode != NULL) &&\n-                (catchHandlerNode != NULL) &&\n-                (frameDepth > 0)) {\n-                node->resumeFrameDepth = frameDepth;\n-            }\n-        }\n-    }\n-}\n-\n-\/* Global breakpoint handler for Thread.resume() *\/\n-static void\n-handleAppResumeBreakpoint(JNIEnv *env, EventInfo *evinfo,\n-                          HandlerNode *handlerNode,\n-                          struct bag *eventBag)\n-{\n-    jthread resumer = evinfo->thread;\n-\n-    debugMonitorEnter(threadLock);\n-\n-    \/*\n-     * Actual handling has to be deferred. We cannot block right here if the\n-     * target of the resume call is suspended by the debugger since we are\n-     * holding handlerLock which must not be released. See doPendingTasks().\n-     *\/\n-    if (resumer != NULL) {\n-        ThreadNode* node = findThread(&runningThreads, resumer);\n-        if (node != NULL) {\n-            node->handlingAppResume = JNI_TRUE;\n-        }\n-    }\n-\n-    debugMonitorExit(threadLock);\n@@ -888,3 +661,0 @@\n-    breakpointHandlerNode = eventHandler_createInternalBreakpoint(\n-                 handleAppResumeBreakpoint, NULL,\n-                 gdata->threadClass, gdata->threadResume, resumeLocation);\n@@ -896,12 +666,0 @@\n-    if (breakpointHandlerNode != NULL) {\n-        (void)eventHandler_free(breakpointHandlerNode);\n-        breakpointHandlerNode = NULL;\n-    }\n-    if (framePopHandlerNode != NULL) {\n-        (void)eventHandler_free(framePopHandlerNode);\n-        framePopHandlerNode = NULL;\n-    }\n-    if (catchHandlerNode != NULL) {\n-        (void)eventHandler_free(catchHandlerNode);\n-        catchHandlerNode = NULL;\n-    }\n@@ -981,2 +739,2 @@\n-     * If the thread was suspended by another app thread,\n-     * do nothing and report no error (we won't resume it later).\n+     * JVMTI_ERROR_THREAD_SUSPENDED used to be possible when Thread.suspend()\n+     * was still supported, but now we should no longer ever see it.\n@@ -984,3 +742,1 @@\n-     if (error == JVMTI_ERROR_THREAD_SUSPENDED) {\n-        error = JVMTI_ERROR_NONE;\n-     }\n+    JDI_ASSERT(error != JVMTI_ERROR_THREAD_SUSPENDED);\n@@ -988,1 +744,1 @@\n-     return error;\n+    return error;\n@@ -1089,2 +845,3 @@\n-        if ((node->suspendCount == 0) && node->toBeResumed &&\n-            !node->suspendOnStart) {\n+        if ((node->suspendCount == 0) && node->toBeResumed) {\n+            \/\/ We should never see both toBeResumed and suspendOnStart set true.\n+            JDI_ASSERT(!node->suspendOnStart);\n@@ -1130,26 +887,0 @@\n-\n-    \/*\n-     * Delay any suspend while a call to java.lang.Thread.resume is in\n-     * progress (not including those in suspended threads). The wait is\n-     * timed because the threads suspended through\n-     * java.lang.Thread.suspend won't result in a notify even though\n-     * it may change the result of pendingAppResume()\n-     *\/\n-    while (pendingAppResume(JNI_FALSE)) {\n-        \/*\n-         * This is ugly but we need to release the locks from getLocks\n-         * or else the notify will never happen. The locks must be\n-         * released and reacquired in the right order. else deadlocks\n-         * can happen. It is possible that, during this dance, the\n-         * notify will be missed, but since the wait needs to be timed\n-         * anyway, it won't be a disaster. Note that this code will\n-         * execute only on very rare occasions anyway.\n-         *\/\n-        releaseLocks();\n-\n-        debugMonitorEnter(threadLock);\n-        debugMonitorTimedWait(threadLock, 1000);\n-        debugMonitorExit(threadLock);\n-\n-        getLocks();\n-    }\n@@ -1222,9 +953,0 @@\n-     * Another case to be handled here is when the debugger suspends\n-     * the thread while the app has it suspended. In this case,\n-     * the toBeResumed flag has been cleared indicating that\n-     * the thread should not be resumed when the debugger does a resume.\n-     * In this case, we also have to decrement the suspend count.\n-     * If we don't then when the app resumes the thread and our Thread.resume\n-     * bkpt handler is called, blockOnDebuggerSuspend will not resume\n-     * the thread because suspendCount will be 1 meaning that the\n-     * debugger has the thread suspended.  See bug 6224859.\n@@ -1232,1 +954,3 @@\n-    if (node->suspendCount == 1 && (!node->toBeResumed || node->suspendOnStart)) {\n+    if (node->suspendCount == 1 && node->suspendOnStart) {\n+        \/\/ We should never see both toBeResumed and suspendOnStart set true.\n+        JDI_ASSERT(!node->toBeResumed);\n@@ -1245,3 +969,2 @@\n-     * JVM\/DI SuspendThread() or JVM\/DI SuspendThreadList() was called\n-     * on this thread. The check for !suspendOnStart is paranoia that\n-     * we inherited from resumeThreadByNode().\n+     * JVMTI SuspendThread() or JVMTI SuspendThreadList() was called\n+     * on this thread.\n@@ -1249,1 +972,3 @@\n-    if (node->suspendCount == 1 && node->toBeResumed && !node->suspendOnStart) {\n+    if (node->suspendCount == 1 && node->toBeResumed) {\n+        \/\/ We should never see both toBeResumed and suspendOnStart set true.\n+        JDI_ASSERT(!node->suspendOnStart);\n@@ -1251,1 +976,0 @@\n-\n@@ -1269,3 +993,2 @@\n-     * JVM\/DI SuspendThread() or JVM\/DI SuspendThreadList() was called\n-     * on this thread. The check for !suspendOnStart is paranoia that\n-     * we inherited from resumeThreadByNode().\n+     * JVMTI SuspendThread() or JVMTDI SuspendThreadList() was called\n+     * on this thread.\n@@ -1273,1 +996,3 @@\n-    if (node->suspendCount == 1 && node->toBeResumed && !node->suspendOnStart) {\n+    if (node->suspendCount == 1 && node->toBeResumed) {\n+        \/\/ We should never see both toBeResumed and suspendOnStart set true.\n+        JDI_ASSERT(!node->suspendOnStart);\n@@ -1275,1 +1000,0 @@\n-\n@@ -1377,1 +1101,1 @@\n-         * resumeThreadByNode() assumes that JVM\/DI ResumeThread()\n+         * resumeThreadByNode() assumes that JVMTI ResumeThread()\n@@ -2378,53 +2102,0 @@\n-    \/* Deferred breakpoint handling for Thread.resume() *\/\n-    if (node->handlingAppResume) {\n-        jthread resumer = node->thread;\n-        jthread resumee = getResumee(resumer);\n-\n-        if (resumer != NULL) {\n-            \/*\n-             * trackAppResume indirectly acquires handlerLock. For proper lock\n-             * ordering handlerLock has to be acquired before threadLock.\n-             *\/\n-            debugMonitorExit(threadLock);\n-            eventHandler_lock();\n-            debugMonitorEnter(threadLock);\n-\n-            \/*\n-             * Track the resuming thread by marking it as being within\n-             * a resume and by setting up for notification on\n-             * a frame pop or exception. We won't allow the debugger\n-             * to suspend threads while any thread is within a\n-             * call to resume. This (along with the block below)\n-             * ensures that when the debugger\n-             * suspends a thread it will remain suspended.\n-             *\/\n-            trackAppResume(resumer);\n-\n-            \/*\n-             * handlerLock is not needed anymore. We must release it before calling\n-             * blockOnDebuggerSuspend() because it is required for resumes done by\n-             * the debugger. If resumee is currently suspended by the debugger, then\n-             * blockOnDebuggerSuspend() will block until a debugger resume is done.\n-             * If it blocks while holding the handlerLock, then the resume will deadlock.\n-             *\/\n-            eventHandler_unlock();\n-        }\n-\n-        if (resumee != NULL) {\n-            \/*\n-             * Hold up any attempt to resume as long as the debugger\n-             * has suspended the resumee.\n-             *\/\n-            blockOnDebuggerSuspend(resumee);\n-        }\n-\n-        node->handlingAppResume = JNI_FALSE;\n-\n-        \/*\n-         * The blocks exit condition: resumee's suspendCount == 0.\n-         *\n-         * Debugger suspends are blocked if any thread is executing\n-         * Thread.resume(), i.e. !handlingAppResume && frameDepth > 0.\n-         *\/\n-    }\n-\n@@ -2475,1 +2146,0 @@\n-            jboolean inResume = (node->resumeFrameDepth > 0);\n@@ -2478,8 +2148,0 @@\n-\n-            \/*\n-             * Clean up mechanism used to detect end of\n-             * resume.\n-             *\/\n-            if (inResume) {\n-                notifyAppResumeComplete();\n-            }\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/threadControl.c","additions":22,"deletions":360,"binary":false,"changes":382,"status":"modified"},{"patch":"@@ -225,2 +225,0 @@\n-        gdata->threadResume =\n-                getMethod(env, gdata->threadClass, \"resume\", \"()V\");\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.c","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -109,1 +109,0 @@\n-    jmethodID           threadResume;\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.h","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}