{"files":[{"patch":"@@ -1797,3 +1797,0 @@\n-                \/\/ Store product in a double field to cause an\n-                \/\/ overflow even if non-strictfp evaluation is being\n-                \/\/ used.\n@@ -2665,14 +2662,11 @@\n-     * Returns {@code d} &times;\n-     * 2<sup>{@code scaleFactor}<\/sup> rounded as if performed\n-     * by a single correctly rounded floating-point multiply to a\n-     * member of the double value set.  See the Java\n-     * Language Specification for a discussion of floating-point\n-     * value sets.  If the exponent of the result is between {@link\n-     * Double#MIN_EXPONENT} and {@link Double#MAX_EXPONENT}, the\n-     * answer is calculated exactly.  If the exponent of the result\n-     * would be larger than {@code Double.MAX_EXPONENT}, an\n-     * infinity is returned.  Note that if the result is subnormal,\n-     * precision may be lost; that is, when {@code scalb(x, n)}\n-     * is subnormal, {@code scalb(scalb(x, n), -n)} may not equal\n-     * <i>x<\/i>.  When the result is non-NaN, the result has the same\n-     * sign as {@code d}.\n+     * Returns {@code d} &times; 2<sup>{@code scaleFactor}<\/sup>\n+     * rounded as if performed by a single correctly rounded\n+     * floating-point multiply.  If the exponent of the result is\n+     * between {@link Double#MIN_EXPONENT} and {@link\n+     * Double#MAX_EXPONENT}, the answer is calculated exactly.  If the\n+     * exponent of the result would be larger than {@code\n+     * Double.MAX_EXPONENT}, an infinity is returned.  Note that if\n+     * the result is subnormal, precision may be lost; that is, when\n+     * {@code scalb(x, n)} is subnormal, {@code scalb(scalb(x, n),\n+     * -n)} may not equal <i>x<\/i>.  When the result is non-NaN, the\n+     * result has the same sign as {@code d}.\n@@ -2696,3 +2690,1 @@\n-         * This method does not need to be declared strictfp to\n-         * compute the same correct result on all platforms.  When\n-         * scaling up, it does not matter what order the\n+         * When scaling up, it does not matter what order the\n@@ -2712,19 +2704,1 @@\n-         * real rounding error occurs.  If the double value set is\n-         * being used exclusively, the rounding will occur on a\n-         * multiply.  If the double-extended-exponent value set is\n-         * being used, the products will (perhaps) be exact but the\n-         * stores to d are guaranteed to round to the double value\n-         * set.\n-         *\n-         * It is _not_ a valid implementation to first multiply d by\n-         * 2^MIN_EXPONENT and then by 2 ^ (scaleFactor %\n-         * MIN_EXPONENT) since even in a strictfp program double\n-         * rounding on underflow could occur; e.g. if the scaleFactor\n-         * argument was (MIN_EXPONENT - n) and the exponent of d was a\n-         * little less than -(MIN_EXPONENT - n), meaning the final\n-         * result would be subnormal.\n-         *\n-         * Since exact reproducibility of this method can be achieved\n-         * without any undue performance burden, there is no\n-         * compelling reason to allow double rounding on underflow in\n-         * scalb.\n+         * real rounding error occurs.\n@@ -2772,14 +2746,11 @@\n-     * Returns {@code f} &times;\n-     * 2<sup>{@code scaleFactor}<\/sup> rounded as if performed\n-     * by a single correctly rounded floating-point multiply to a\n-     * member of the float value set.  See the Java\n-     * Language Specification for a discussion of floating-point\n-     * value sets.  If the exponent of the result is between {@link\n-     * Float#MIN_EXPONENT} and {@link Float#MAX_EXPONENT}, the\n-     * answer is calculated exactly.  If the exponent of the result\n-     * would be larger than {@code Float.MAX_EXPONENT}, an\n-     * infinity is returned.  Note that if the result is subnormal,\n-     * precision may be lost; that is, when {@code scalb(x, n)}\n-     * is subnormal, {@code scalb(scalb(x, n), -n)} may not equal\n-     * <i>x<\/i>.  When the result is non-NaN, the result has the same\n-     * sign as {@code f}.\n+     * Returns {@code f} &times; 2<sup>{@code scaleFactor}<\/sup>\n+     * rounded as if performed by a single correctly rounded\n+     * floating-point multiply.  If the exponent of the result is\n+     * between {@link Float#MIN_EXPONENT} and {@link\n+     * Float#MAX_EXPONENT}, the answer is calculated exactly.  If the\n+     * exponent of the result would be larger than {@code\n+     * Float.MAX_EXPONENT}, an infinity is returned.  Note that if the\n+     * result is subnormal, precision may be lost; that is, when\n+     * {@code scalb(x, n)} is subnormal, {@code scalb(scalb(x, n),\n+     * -n)} may not equal <i>x<\/i>.  When the result is non-NaN, the\n+     * result has the same sign as {@code f}.\n@@ -2817,3 +2788,1 @@\n-         * float will be the correctly rounded float result.  Since\n-         * all operations other than the final multiply will be exact,\n-         * it is not necessary to declare this method strictfp.\n+         * float will be the correctly rounded float result.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Math.java","additions":25,"deletions":56,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -472,13 +472,0 @@\n-         *\n-         * This method does *not* need to be declared strictfp to get\n-         * fully reproducible results.  Whether or not a method is\n-         * declared strictfp can only make a difference in the\n-         * returned result if some operation would overflow or\n-         * underflow with strictfp semantics.  The operation\n-         * (twoToThe52 + a ) cannot overflow since large values of a\n-         * are screened out; the add cannot underflow since twoToThe52\n-         * is too large.  The subtraction ((twoToThe52 + a ) -\n-         * twoToThe52) will be exact as discussed above and thus\n-         * cannot overflow or meaningfully underflow.  Finally, the\n-         * last multiply in the return statement is by plus or minus\n-         * 1.0, which is exact too.\n@@ -2063,14 +2050,11 @@\n-     * Returns {@code d} &times;\n-     * 2<sup>{@code scaleFactor}<\/sup> rounded as if performed\n-     * by a single correctly rounded floating-point multiply to a\n-     * member of the double value set.  See the Java\n-     * Language Specification for a discussion of floating-point\n-     * value sets.  If the exponent of the result is between {@link\n-     * Double#MIN_EXPONENT} and {@link Double#MAX_EXPONENT}, the\n-     * answer is calculated exactly.  If the exponent of the result\n-     * would be larger than {@code Double.MAX_EXPONENT}, an\n-     * infinity is returned.  Note that if the result is subnormal,\n-     * precision may be lost; that is, when {@code scalb(x, n)}\n-     * is subnormal, {@code scalb(scalb(x, n), -n)} may not equal\n-     * <i>x<\/i>.  When the result is non-NaN, the result has the same\n-     * sign as {@code d}.\n+     * Returns {@code d} &times; 2<sup>{@code scaleFactor}<\/sup>\n+     * rounded as if performed by a single correctly rounded\n+     * floating-point multiply.  If the exponent of the result is\n+     * between {@link Double#MIN_EXPONENT} and {@link\n+     * Double#MAX_EXPONENT}, the answer is calculated exactly.  If the\n+     * exponent of the result would be larger than {@code\n+     * Double.MAX_EXPONENT}, an infinity is returned.  Note that if\n+     * the result is subnormal, precision may be lost; that is, when\n+     * {@code scalb(x, n)} is subnormal, {@code scalb(scalb(x, n),\n+     * -n)} may not equal <i>x<\/i>.  When the result is non-NaN, the\n+     * result has the same sign as {@code d}.\n@@ -2097,14 +2081,11 @@\n-     * Returns {@code f} &times;\n-     * 2<sup>{@code scaleFactor}<\/sup> rounded as if performed\n-     * by a single correctly rounded floating-point multiply to a\n-     * member of the float value set.  See the Java\n-     * Language Specification for a discussion of floating-point\n-     * value sets.  If the exponent of the result is between {@link\n-     * Float#MIN_EXPONENT} and {@link Float#MAX_EXPONENT}, the\n-     * answer is calculated exactly.  If the exponent of the result\n-     * would be larger than {@code Float.MAX_EXPONENT}, an\n-     * infinity is returned.  Note that if the result is subnormal,\n-     * precision may be lost; that is, when {@code scalb(x, n)}\n-     * is subnormal, {@code scalb(scalb(x, n), -n)} may not equal\n-     * <i>x<\/i>.  When the result is non-NaN, the result has the same\n-     * sign as {@code f}.\n+     * Returns {@code f} &times; 2<sup>{@code scaleFactor}<\/sup>\n+     * rounded as if performed by a single correctly rounded\n+     * floating-point multiply.  If the exponent of the result is\n+     * between {@link Float#MIN_EXPONENT} and {@link\n+     * Float#MAX_EXPONENT}, the answer is calculated exactly.  If the\n+     * exponent of the result would be larger than {@code\n+     * Float.MAX_EXPONENT}, an infinity is returned.  Note that if the\n+     * result is subnormal, precision may be lost; that is, when\n+     * {@code scalb(x, n)} is subnormal, {@code scalb(scalb(x, n),\n+     * -n)} may not equal <i>x<\/i>.  When the result is non-NaN, the\n+     * result has the same sign as {@code f}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StrictMath.java","additions":22,"deletions":41,"binary":false,"changes":63,"status":"modified"}]}