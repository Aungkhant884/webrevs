{"files":[{"patch":"@@ -28,0 +28,3 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.util.concurrent.locks.StampedLock;\n@@ -30,0 +33,2 @@\n+import jdk.internal.util.random.RandomSupport;\n+\n@@ -102,0 +107,4 @@\n+     * <p>\n+     * The implementation buffers the reads to avoid bashing SecureRandom with\n+     * small requests. It also maintains a SecureRandom per buffer to alleviate\n+     * scalability bottlenecks when reading from a single (synchronized) SecureRandom.\n@@ -103,2 +112,163 @@\n-    private static class Holder {\n-        static final SecureRandom numberGenerator = new SecureRandom();\n+    private static final class RandomUUID {\n+        static final String PROP_NAME_PRNG_NAME = \"java.util.UUID.prngName\";\n+        static final String PROP_NAME_BUF_COUNT = \"java.util.UUID.buffersCount\";\n+\n+        static final String PRNG_NAME;\n+        static final int BUFS_COUNT;\n+        static final Buffer[] BUFS;\n+\n+        private static final int roundPowerOfTwo(int x) {\n+            int n = -1 >>> Integer.numberOfLeadingZeros(x - 1);\n+            return (n < 0) ? 1 : (n + 1);\n+        }\n+\n+        static {\n+            try {\n+                PRNG_NAME = System.getProperty(PROP_NAME_PRNG_NAME, null);\n+                try {\n+                    newRandom();\n+                } catch (Exception e) {\n+                    throw new IllegalArgumentException(PROP_NAME_PRNG_NAME + \" is incorrect\", e);\n+                }\n+                int bufCount = Integer.getInteger(PROP_NAME_BUF_COUNT, Runtime.getRuntime().availableProcessors());\n+                if (bufCount < 1) {\n+                    throw new IllegalArgumentException(PROP_NAME_BUF_COUNT + \" is out of range\");\n+                }\n+                BUFS_COUNT = roundPowerOfTwo(bufCount);\n+                BUFS = new Buffer[BUFS_COUNT];\n+            } catch (Exception e) {\n+                throw new InternalError(e);\n+            }\n+        }\n+\n+        static SecureRandom newRandom() {\n+            if (PRNG_NAME == null) {\n+                return new SecureRandom();\n+            } else {\n+                try {\n+                    return SecureRandom.getInstance(PRNG_NAME);\n+                } catch (Exception e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        }\n+\n+        public static UUID next() {\n+            \/\/ We want to hit the same buffer from the same thread for several reasons:\n+            \/\/   - in best case, make thread poll from the single random stream;\n+            \/\/   - avoid instantiating too many buffers when only a few calling threads;\n+            \/\/   - make sure the buffers stay hot in the local caches;\n+            \/\/   - minimize coherence traffic for cursor updates\n+            \/\/\n+            \/\/ Without recording the buffer index in the thread itself, the good option is to use\n+            \/\/ the thread ID scrambled with Murmur hash, which results in good bit entropy.\n+\n+            long h = RandomSupport.mixMurmur64(Thread.currentThread().threadId());\n+            int idx = (int)(h & (BUFS_COUNT - 1));\n+            Buffer current = BUFS[idx];\n+            if (current == null) {\n+                \/\/ Create a new buffer and install it.\n+                \/\/ On initial contention, some buffers may be lost, but this is not\n+                \/\/ a problem for correctness, or for steady-state performance.\n+                current = new Buffer(newRandom());\n+                BUFS[idx] = current;\n+            }\n+            return current.next();\n+        }\n+\n+        \/\/ Buffer random reads. This allows batching the SecureRandom provider requests.\n+        \/\/ Current implementation targets the 4K buffer size, which balances the initialization\n+        \/\/ costs, memory footprint and cache pressure.\n+        @jdk.internal.vm.annotation.Contended\n+        static final class Buffer {\n+            static final String PROP_NAME_UUID_COUNT = \"java.util.UUID.uuidsPerBuffer\";\n+\n+            static final int UUID_CHUNK = 16;\n+            static final int UUID_COUNT;\n+            static final int BUF_SIZE;\n+\n+            static final VarHandle VH_POS;\n+            static {\n+                try {\n+                    VH_POS = MethodHandles.lookup().findVarHandle(Buffer.class, \"pos\", int.class);\n+                    UUID_COUNT = Integer.getInteger(PROP_NAME_UUID_COUNT, 256);\n+                    if (UUID_COUNT < 1 || UUID_COUNT > Integer.MAX_VALUE \/ UUID_CHUNK) {\n+                        throw new IllegalArgumentException(PROP_NAME_UUID_COUNT + \" is out of range\");\n+                    }\n+                    BUF_SIZE = UUID_CHUNK * UUID_COUNT;\n+                } catch (Exception e) {\n+                    throw new InternalError(e);\n+                }\n+            }\n+\n+            final SecureRandom random;\n+            final StampedLock lock;\n+            final byte[] buf;\n+            int pos;\n+\n+            public Buffer(SecureRandom random) {\n+                this.random = random;\n+                this.lock = new StampedLock();\n+                this.buf = new byte[BUF_SIZE];\n+                this.pos = BUF_SIZE; \/\/ trigger re-creation on first use\n+            }\n+\n+            public UUID next() {\n+                long stamp = lock.tryOptimisticRead();\n+                try {\n+                    UUID uuid = null;\n+\n+                    \/\/ Optimistic path: optimistic locking succeeded.\n+                    \/\/ Try to pull the UUID from the current buffer at current position.\n+                    if (stamp != 0) {\n+                        int p = (int)VH_POS.getAndAdd(this, UUID_CHUNK);\n+                        if (p < BUF_SIZE) {\n+                            uuid = new UUID(buf, p);\n+                            if (lock.validate(stamp)) {\n+                                \/\/ Success: UUID is valid, and there were no buffer changes.\n+                                return uuid;\n+                            }\n+                        }\n+                    }\n+\n+                    \/\/ Semi-pessimistic path: either the buffer was depleted, or optimistic locking\n+                    \/\/ failed. Either way, we need to take the exclusive lock and try again.\n+                    stamp = lock.tryConvertToWriteLock(stamp);\n+                    if (stamp == 0L) {\n+                        stamp = lock.writeLock();\n+                    }\n+\n+                    \/\/ See if some other thread had already replenished the buffer.\n+                    \/\/ Pull the UUID from there then. We are still holding the write lock, so\n+                    \/\/ buffer is guaranteed to not change under our feet.\n+                    if ((int)VH_POS.get(this) > 0) {\n+                        int p = (int)VH_POS.getAndAdd(this, UUID_CHUNK);\n+                        if (p < BUF_SIZE) {\n+                            return new UUID(buf, p);\n+                        }\n+                    }\n+\n+                    \/\/ Pessimistic path: buffer requires replenishment. Recreate it from the\n+                    \/\/ provided random, and initialize all UUIDs at once to avoid further\n+                    \/\/ initializations, and thus false sharing between reader threads.\n+                    random.nextBytes(buf);\n+                    for (int c = 0; c < BUF_SIZE; c += UUID_CHUNK) {\n+                        buf[c + 6] &= 0x0f;  \/* clear version        *\/\n+                        buf[c + 6] |= 0x40;  \/* set to version 4     *\/\n+                        buf[c + 8] &= 0x3f;  \/* clear variant        *\/\n+                        buf[c + 8] |= (byte) 0x80;  \/* set to IETF variant  *\/\n+                    }\n+\n+                    \/\/ Take the UUID from new buffer. We are still under write lock,\n+                    \/\/ so we know we are the only thread here.\n+                    uuid = new UUID(buf, 0);\n+                    VH_POS.set(this, UUID_CHUNK);\n+\n+                    return uuid;\n+                } finally {\n+                    if (StampedLock.isWriteLockStamp(stamp)) {\n+                        lock.unlockWrite(stamp);\n+                    }\n+                }\n+            }\n+        }\n@@ -112,1 +282,1 @@\n-    private UUID(byte[] data) {\n+    private UUID(byte[] data, int start) {\n@@ -115,2 +285,1 @@\n-        assert data.length == 16 : \"data must be 16 bytes in length\";\n-        for (int i=0; i<8; i++)\n+        for (int i = start; i < start + 8; i++) {\n@@ -118,1 +287,2 @@\n-        for (int i=8; i<16; i++)\n+        }\n+        for (int i = start + 8; i < start + 16; i++) {\n@@ -120,0 +290,1 @@\n+        }\n@@ -150,9 +321,1 @@\n-        SecureRandom ng = Holder.numberGenerator;\n-\n-        byte[] randomBytes = new byte[16];\n-        ng.nextBytes(randomBytes);\n-        randomBytes[6]  &= 0x0f;  \/* clear version        *\/\n-        randomBytes[6]  |= 0x40;  \/* set to version 4     *\/\n-        randomBytes[8]  &= 0x3f;  \/* clear variant        *\/\n-        randomBytes[8]  |= (byte) 0x80;  \/* set to IETF variant  *\/\n-        return new UUID(randomBytes);\n+        return RandomUUID.next();\n@@ -182,1 +345,1 @@\n-        return new UUID(md5Bytes);\n+        return new UUID(md5Bytes, 0);\n","filename":"src\/java.base\/share\/classes\/java\/util\/UUID.java","additions":179,"deletions":16,"binary":false,"changes":195,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util;\n+\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(3)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@BenchmarkMode(Mode.Throughput)\n+public class UUIDRandomBench {\n+\n+    @Benchmark\n+    @Threads(1)\n+    public UUID single() {\n+        return UUID.randomUUID();\n+    }\n+\n+    @Benchmark\n+    @Threads(Threads.MAX)\n+    public UUID max() {\n+        return UUID.randomUUID();\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/UUIDRandomBench.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"}]}