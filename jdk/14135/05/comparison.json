{"files":[{"patch":"@@ -28,0 +28,3 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.util.concurrent.locks.StampedLock;\n@@ -32,0 +35,2 @@\n+import jdk.internal.util.random.RandomSupport;\n+import jdk.internal.util.ByteArray;\n@@ -102,0 +107,4 @@\n+     * <p>\n+     * The implementation buffers the reads to avoid bashing SecureRandom with\n+     * small requests. It also maintains a SecureRandom per buffer to alleviate\n+     * scalability bottlenecks when reading from a single (synchronized) SecureRandom.\n@@ -103,2 +112,130 @@\n-    private static class Holder {\n-        static final SecureRandom numberGenerator = new SecureRandom();\n+    private static final class RandomUUID {\n+        static final int BUFS_COUNT;\n+        static final Buffer[] BUFS;\n+\n+        private static final int roundPowerOfTwo(int x) {\n+            int n = -1 >>> Integer.numberOfLeadingZeros(x - 1);\n+            return (n < 0) ? 1 : (n + 1);\n+        }\n+\n+        static {\n+            BUFS_COUNT = roundPowerOfTwo(Runtime.getRuntime().availableProcessors());\n+            BUFS = new Buffer[BUFS_COUNT];\n+        }\n+\n+        public static UUID next() {\n+            \/\/ We want to hit the same buffer from the same thread for several reasons:\n+            \/\/   - in best case, make thread poll from the single random stream;\n+            \/\/   - avoid instantiating too many buffers when only a few calling threads;\n+            \/\/   - make sure the buffers stay hot in the local caches;\n+            \/\/   - minimize coherence traffic for cursor updates\n+            \/\/\n+            \/\/ Without recording the buffer index in the thread itself, the good option is to use\n+            \/\/ the thread ID scrambled with Murmur hash, which results in good bit entropy.\n+\n+            long h = RandomSupport.mixMurmur64(Thread.currentThread().threadId());\n+            int idx = (int)(h & (BUFS_COUNT - 1));\n+            Buffer current = BUFS[idx];\n+            if (current == null) {\n+                \/\/ Create a new buffer and install it.\n+                \/\/ On initial contention, some buffers may be lost, but this is not\n+                \/\/ a problem for correctness, or for steady-state performance.\n+                current = new Buffer();\n+                BUFS[idx] = current;\n+            }\n+            return current.next();\n+        }\n+\n+        \/\/ Buffer random reads. This allows batching the SecureRandom provider requests.\n+        \/\/ Current implementation targets the 4K buffer size, which balances the initialization\n+        \/\/ costs, memory footprint and cache pressure.\n+        @jdk.internal.vm.annotation.Contended\n+        static final class Buffer {\n+            static final int UUID_CHUNK = 16;\n+            static final int UUID_COUNT = 256;\n+            static final int BUF_SIZE;\n+\n+            static final VarHandle VH_POS;\n+            static {\n+                try {\n+                    VH_POS = MethodHandles.lookup().findVarHandle(Buffer.class, \"pos\", int.class);\n+                    BUF_SIZE = UUID_CHUNK * UUID_COUNT;\n+                } catch (Exception e) {\n+                    throw new InternalError(e);\n+                }\n+            }\n+\n+            final SecureRandom random;\n+            final StampedLock lock;\n+            final byte[] buf;\n+            int pos;\n+\n+            public Buffer() {\n+                this.random = new SecureRandom();\n+                this.lock = new StampedLock();\n+                this.buf = new byte[BUF_SIZE];\n+                this.pos = BUF_SIZE; \/\/ trigger re-creation on first use\n+            }\n+\n+            private static UUID fromRandom(long msb, long lsb) {\n+                \/\/ set version to 3\n+                msb = (msb & (0xFFFF_FFFF_FFFF_0FFFL)) | 0x0000_0000_0000_4000L;\n+                \/\/ set variant to IETF\n+                lsb = (lsb & (0x3FFF_FFFF_FFFF_FFFFL)) | 0x8000_0000_0000_0000L;\n+                return new UUID(msb, lsb);\n+            }\n+\n+            public UUID next() {\n+                long stamp = lock.tryOptimisticRead();\n+                try {\n+                    \/\/ Optimistic path: optimistic locking succeeded.\n+                    \/\/ Try to pull the UUID from the current buffer at current position.\n+                    if (stamp != 0) {\n+                        int p = (int)VH_POS.getAndAdd(this, UUID_CHUNK);\n+                        if (p < BUF_SIZE) {\n+                            long msb = ByteArray.getLong(buf, p);\n+                            long lsb = ByteArray.getLong(buf, p + 8);\n+                            if (lock.validate(stamp)) {\n+                                \/\/ Success: there were no buffer changes. Construct the UUID.\n+                                return fromRandom(msb, lsb);\n+                            }\n+                        }\n+                    }\n+\n+                    \/\/ Semi-pessimistic path: either the buffer was depleted, or optimistic locking\n+                    \/\/ failed. Either way, we need to take the exclusive lock and try again.\n+                    stamp = lock.tryConvertToWriteLock(stamp);\n+                    if (stamp == 0L) {\n+                        stamp = lock.writeLock();\n+                    }\n+\n+                    \/\/ See if some other thread had already replenished the buffer.\n+                    \/\/ Pull the UUID from there then. We are still holding the write lock, so\n+                    \/\/ buffer is guaranteed to not change under our feet.\n+                    if ((int)VH_POS.get(this) > 0) {\n+                        int p = (int)VH_POS.getAndAdd(this, UUID_CHUNK);\n+                        if (p < BUF_SIZE) {\n+                            long msb = ByteArray.getLong(buf, p);\n+                            long lsb = ByteArray.getLong(buf, p + 8);\n+                            return fromRandom(msb, lsb);\n+                        }\n+                    }\n+\n+                    \/\/ Pessimistic path: buffer requires replenishment.\n+                    \/\/ Recreate it from the provided random.\n+                    random.nextBytes(buf);\n+\n+                    \/\/ Take the UUID from new buffer. We are still under write lock,\n+                    \/\/ so we know we are the only thread here.\n+                    VH_POS.set(this, UUID_CHUNK);\n+\n+                    long msb = ByteArray.getLong(buf, 0);\n+                    long lsb = ByteArray.getLong(buf, 8);\n+                    return fromRandom(msb, lsb);\n+                } finally {\n+                    if (StampedLock.isWriteLockStamp(stamp)) {\n+                        lock.unlockWrite(stamp);\n+                    }\n+                }\n+            }\n+        }\n@@ -150,9 +287,1 @@\n-        SecureRandom ng = Holder.numberGenerator;\n-\n-        byte[] randomBytes = new byte[16];\n-        ng.nextBytes(randomBytes);\n-        randomBytes[6]  &= 0x0f;  \/* clear version        *\/\n-        randomBytes[6]  |= 0x40;  \/* set to version 4     *\/\n-        randomBytes[8]  &= 0x3f;  \/* clear variant        *\/\n-        randomBytes[8]  |= (byte) 0x80;  \/* set to IETF variant  *\/\n-        return new UUID(randomBytes);\n+        return RandomUUID.next();\n","filename":"src\/java.base\/share\/classes\/java\/util\/UUID.java","additions":140,"deletions":11,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 4173528 5068772 8148936 8196334\n+ * @bug 4173528 5068772 8148936 8196334 8308803\n@@ -28,2 +28,2 @@\n- * @run main\/othervm -XX:+CompactStrings UUIDTest\n- * @run main\/othervm -XX:-CompactStrings UUIDTest\n+ * @run main\/othervm -Xmx1g -XX:+CompactStrings UUIDTest\n+ * @run main\/othervm -Xmx1g -XX:-CompactStrings UUIDTest\n@@ -33,0 +33,1 @@\n+import java.util.stream.IntStream;\n@@ -36,1 +37,4 @@\n-    static Random generator = new Random();\n+    \/\/ Single UUID instance is ~32 bytes, 1M instances take ~256M in the set\n+    private static final int COUNT = 1_000_000;\n+\n+    static final Random generator = new Random();\n@@ -39,1 +43,1 @@\n-        containsTest();\n+        negativeTest();\n@@ -41,0 +45,1 @@\n+        randomUUIDTest_Multi();\n@@ -52,6 +57,6 @@\n-    \/\/ Verify that list.contains detects UUID collisons\n-    private static void containsTest() throws Exception {\n-        List list = new LinkedList();\n-        list.add(new UUID(4,4));\n-        if (!list.contains(new UUID(4,4)))\n-            throw new Exception(\"contains test did not work as expected\");\n+    private static void negativeTest() throws Exception {\n+        Set<UUID> set = new HashSet<>();\n+        set.add(new UUID(4, 4));\n+        if (set.add(new UUID(4, 4))) {\n+            throw new Exception(\"Contains test does not work as expected\");\n+        }\n@@ -61,5 +66,27 @@\n-        List list = new LinkedList();\n-        for (int i=0; i<100; i++) {\n-            UUID u1 = UUID.randomUUID();\n-            if (4 != u1.version()) {\n-                throw new Exception(\"bad version\");\n+        Set<UUID> set = new HashSet<>();\n+        for (int i = 0; i < COUNT; i++) {\n+            UUID u = UUID.randomUUID();\n+            if (u.version() != 4) {\n+                throw new Exception(\"Bad version: \" + u);\n+            }\n+            if (u.variant() != 2) {\n+                throw new Exception(\"Bad variant: \" + u);\n+            }\n+            if (!set.add(u)) {\n+                throw new Exception(\"UUID collision: \" + u);\n+            }\n+        }\n+    }\n+\n+    private static void randomUUIDTest_Multi() throws Exception {\n+        List<UUID> uuids = IntStream.range(0, COUNT).parallel()\n+                                    .mapToObj(i -> UUID.randomUUID())\n+                                    .toList();\n+\n+        Set<UUID> set = new HashSet<>();\n+        for (UUID u : uuids) {\n+            if (u.version() != 4) {\n+                throw new Exception(\"Bad version: \" + u);\n+            }\n+            if (u.variant() != 2) {\n+                throw new Exception(\"Bad variant: \" + u);\n@@ -67,2 +94,2 @@\n-            if (2 != u1.variant()) {\n-                throw new Exception(\"bad variant\");\n+            if (!set.add(u)) {\n+                throw new Exception(\"UUID collision: \" + u);\n@@ -70,3 +97,0 @@\n-            if (list.contains(u1))\n-                throw new Exception(\"random UUID collision very unlikely\");\n-            list.add(u1);\n@@ -76,0 +100,1 @@\n+\n@@ -77,1 +102,0 @@\n-        Random byteSource = new Random();\n@@ -79,6 +103,6 @@\n-        List list = new LinkedList();\n-        for (int i=0; i<100; i++) {\n-            byteSource.nextBytes(someBytes);\n-            UUID u1 = UUID.nameUUIDFromBytes(someBytes);\n-            if (3 != u1.version()) {\n-                throw new Exception(\"bad version\");\n+        Set<UUID> set = new HashSet<>();\n+        for (int i = 0; i < COUNT; i++) {\n+            generator.nextBytes(someBytes);\n+            UUID u = UUID.nameUUIDFromBytes(someBytes);\n+            if (u.version() != 3) {\n+                throw new Exception(\"Bad version: \" + u);\n@@ -86,2 +110,5 @@\n-            if (2 != u1.variant()) {\n-                throw new Exception(\"bad variant\");\n+            if (u.variant() != 2) {\n+                throw new Exception(\"Bad variant: \" + u);\n+            }\n+            if (!set.add(u)) {\n+                throw new Exception(\"UUID collision: \" + u);\n@@ -89,3 +116,0 @@\n-            if (list.contains(u1))\n-                throw new Exception(\"byte UUID collision very unlikely\");\n-            list.add(u1);\n@@ -96,1 +120,1 @@\n-        for (int i=0; i<100; i++) {\n+        for (int i = 0; i < COUNT; i++) {\n@@ -100,2 +124,3 @@\n-            if (!u1.equals(u2) || !u1.equals(u3))\n-                throw new Exception(\"UUID -> string -> UUID failed\");\n+            if (!u1.equals(u2) || !u1.equals(u3)) {\n+                throw new Exception(\"UUID -> string -> UUID failed: \" + u1 + \" -> \" + u2 + \" -> \" + u3);\n+            }\n@@ -124,3 +149,4 @@\n-        if (test.version() != 4)\n-            throw new Exception(\"randomUUID not type 4\");\n-        Random byteSource = new Random();\n+        if (test.version() != 4) {\n+            throw new Exception(\"randomUUID not type 4: \" + test);\n+        }\n+\n@@ -128,1 +154,1 @@\n-        byteSource.nextBytes(someBytes);\n+        generator.nextBytes(someBytes);\n@@ -130,2 +156,4 @@\n-        if (test.version() != 3)\n-            throw new Exception(\"nameUUIDFromBytes not type 3\");\n+        if (test.version() != 3) {\n+            throw new Exception(\"nameUUIDFromBytes not type 3: \" + test);\n+        }\n+\n@@ -133,1 +161,1 @@\n-        if (test.version() != 1)\n+        if (test.version() != 1) {\n@@ -135,0 +163,2 @@\n+        }\n+\n@@ -136,1 +166,1 @@\n-        if (test.version() != 2)\n+        if (test.version() != 2) {\n@@ -138,0 +168,2 @@\n+        }\n+\n@@ -139,1 +171,1 @@\n-        if (test.version() != 3)\n+        if (test.version() != 3) {\n@@ -141,0 +173,2 @@\n+        }\n+\n@@ -142,1 +176,1 @@\n-        if (test.version() != 4)\n+        if (test.version() != 4) {\n@@ -144,0 +178,2 @@\n+        }\n+\n@@ -145,1 +181,1 @@\n-        if (test.version() != 1)\n+        if (test.version() != 1) {\n@@ -147,0 +183,2 @@\n+        }\n+\n@@ -148,1 +186,1 @@\n-        if (test.version() != 2)\n+        if (test.version() != 2) {\n@@ -150,0 +188,2 @@\n+        }\n+\n@@ -151,1 +191,1 @@\n-        if (test.version() != 3)\n+        if (test.version() != 3) {\n@@ -153,0 +193,2 @@\n+        }\n+\n@@ -154,1 +196,1 @@\n-        if (test.version() != 4)\n+        if (test.version() != 4) {\n@@ -156,0 +198,1 @@\n+        }\n@@ -160,1 +203,1 @@\n-        if (test.variant() != 2)\n+        if (test.variant() != 2) {\n@@ -162,1 +205,2 @@\n-        Random byteSource = new Random();\n+        }\n+\n@@ -164,1 +208,1 @@\n-        byteSource.nextBytes(someBytes);\n+        generator.nextBytes(someBytes);\n@@ -166,1 +210,1 @@\n-        if (test.variant() != 2)\n+        if (test.variant() != 2) {\n@@ -168,0 +212,2 @@\n+        }\n+\n@@ -169,1 +215,1 @@\n-        if (test.variant() != 0)\n+        if (test.variant() != 0) {\n@@ -171,0 +217,2 @@\n+        }\n+\n@@ -172,1 +220,1 @@\n-        if (test.variant() != 2)\n+        if (test.variant() != 2) {\n@@ -174,2 +222,4 @@\n-       test = new UUID(55L, 0xc000000000001000L);\n-        if (test.variant() != 6)\n+        }\n+\n+        test = new UUID(55L, 0xc000000000001000L);\n+        if (test.variant() != 6) {\n@@ -177,2 +227,4 @@\n-       test = new UUID(55L, 0xe000000000001000L);\n-        if (test.variant() != 7)\n+        }\n+\n+        test = new UUID(55L, 0xe000000000001000L);\n+        if (test.variant() != 7) {\n@@ -180,0 +232,1 @@\n+        }\n@@ -190,0 +243,1 @@\n+\n@@ -191,1 +245,1 @@\n-        if (test.timestamp() != 1)\n+        if (test.timestamp() != 1) {\n@@ -193,0 +247,2 @@\n+        }\n+\n@@ -194,1 +250,1 @@\n-        if (test.timestamp() != 1024)\n+        if (test.timestamp() != 1024) {\n@@ -196,0 +252,2 @@\n+        }\n+\n@@ -197,1 +255,1 @@\n-        if (test.timestamp() != Long.MAX_VALUE>>3)\n+        if (test.timestamp() != (Long.MAX_VALUE >> 3)) {\n@@ -199,0 +257,1 @@\n+        }\n@@ -209,0 +268,1 @@\n+\n@@ -210,1 +270,1 @@\n-        if (test.clockSequence() != 1)\n+        if (test.clockSequence() != 1) {\n@@ -212,0 +272,2 @@\n+        }\n+\n@@ -213,1 +275,1 @@\n-        if (test.clockSequence() != 2)\n+        if (test.clockSequence() != 2) {\n@@ -215,0 +277,2 @@\n+        }\n+\n@@ -216,1 +280,1 @@\n-        if (test.clockSequence() != 16)\n+        if (test.clockSequence() != 16) {\n@@ -218,0 +282,2 @@\n+        }\n+\n@@ -219,1 +285,1 @@\n-        if (test.clockSequence() != ((2L<<13)-1)) \/\/ 2^14 - 1\n+        if (test.clockSequence() != ((1L << 14) - 1)) {\n@@ -221,0 +287,1 @@\n+        }\n@@ -231,0 +298,1 @@\n+\n@@ -232,1 +300,1 @@\n-        if (test.node() != 1)\n+        if (test.node() != 1) {\n@@ -234,0 +302,2 @@\n+        }\n+\n@@ -235,1 +305,1 @@\n-        if (test.node() != ((2L<<47)-1)) \/\/ 2^48 - 1\n+        if (test.node() != ((1L << 48) - 1)) {\n@@ -237,0 +307,1 @@\n+        }\n@@ -241,1 +312,1 @@\n-        for (int i=0; i<100; i++) {\n+        for (int i = 0; i < COUNT; i++) {\n@@ -244,2 +315,3 @@\n-            if (u1.hashCode() != u2.hashCode())\n-                throw new Exception(\"Equal UUIDs with different hashcodes\");\n+            if (u1.hashCode() != u2.hashCode()) {\n+                throw new Exception(\"Equal UUIDs with different hash codes: \" + u1 + \" and \" + u2);\n+            }\n@@ -247,0 +319,1 @@\n+\n@@ -248,1 +321,1 @@\n-        for (int i=0; i<1000; i++) {\n+        for (int i = 0; i < COUNT; i++) {\n@@ -255,2 +328,3 @@\n-            if (u1.equals(u2))\n-                throw new Exception(\"UUIDs with different bits equal\");\n+            if (u1.equals(u2)) {\n+                throw new Exception(\"UUIDs with different bits equal: \" + u1 + \" and \" + u2);\n+            }\n@@ -270,1 +344,1 @@\n-            (id4.compareTo(id5) >= 0))\n+            (id4.compareTo(id5) >= 0)) {\n@@ -272,0 +346,1 @@\n+        }\n@@ -276,1 +351,1 @@\n-            (id2.compareTo(id) <= 0))\n+            (id2.compareTo(id) <= 0)) {\n@@ -278,0 +353,1 @@\n+        }\n@@ -279,1 +355,1 @@\n-        if (id.compareTo(id) != 0)\n+        if (id.compareTo(id) != 0) {\n@@ -281,1 +357,1 @@\n-\n+        }\n","filename":"test\/jdk\/java\/util\/UUID\/UUIDTest.java","additions":156,"deletions":80,"binary":false,"changes":236,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util;\n+\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(3)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@BenchmarkMode(Mode.Throughput)\n+public class UUIDRandomBench {\n+\n+    @Benchmark\n+    @Threads(1)\n+    public UUID single() {\n+        return UUID.randomUUID();\n+    }\n+\n+    @Benchmark\n+    @Threads(Threads.MAX)\n+    public UUID max() {\n+        return UUID.randomUUID();\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/UUIDRandomBench.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"}]}