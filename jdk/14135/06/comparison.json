{"files":[{"patch":"@@ -28,0 +28,3 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.util.concurrent.locks.StampedLock;\n@@ -32,0 +35,2 @@\n+import jdk.internal.util.random.RandomSupport;\n+import jdk.internal.util.ByteArray;\n@@ -102,0 +107,4 @@\n+     * <p>\n+     * The implementation buffers the reads to avoid bashing SecureRandom with\n+     * small requests. It also maintains a SecureRandom per buffer to alleviate\n+     * scalability bottlenecks when reading from a single (synchronized) SecureRandom.\n@@ -103,2 +112,130 @@\n-    private static class Holder {\n-        static final SecureRandom numberGenerator = new SecureRandom();\n+    private static final class RandomUUID {\n+        static final int BUFS_COUNT;\n+        static final Buffer[] BUFS;\n+\n+        private static final int roundPowerOfTwo(int x) {\n+            int n = -1 >>> Integer.numberOfLeadingZeros(x - 1);\n+            return (n < 0) ? 1 : (n + 1);\n+        }\n+\n+        static {\n+            BUFS_COUNT = roundPowerOfTwo(Runtime.getRuntime().availableProcessors());\n+            BUFS = new Buffer[BUFS_COUNT];\n+        }\n+\n+        public static UUID next() {\n+            \/\/ We want to hit the same buffer from the same thread for several reasons:\n+            \/\/   - in best case, make thread poll from the single random stream;\n+            \/\/   - avoid instantiating too many buffers when only a few calling threads;\n+            \/\/   - make sure the buffers stay hot in the local caches;\n+            \/\/   - minimize coherence traffic for cursor updates\n+            \/\/\n+            \/\/ Without recording the buffer index in the thread itself, the good option is to use\n+            \/\/ the thread ID scrambled with Murmur hash, which results in good bit entropy.\n+\n+            long h = RandomSupport.mixMurmur64(Thread.currentThread().threadId());\n+            int idx = (int)(h & (BUFS_COUNT - 1));\n+            Buffer current = BUFS[idx];\n+            if (current == null) {\n+                \/\/ Create a new buffer and install it.\n+                \/\/ On initial contention, some buffers may be lost, but this is not\n+                \/\/ a problem for correctness, or for steady-state performance.\n+                current = new Buffer();\n+                BUFS[idx] = current;\n+            }\n+            return current.next();\n+        }\n+\n+        \/\/ Buffer random reads. This allows batching the SecureRandom provider requests.\n+        \/\/ Current implementation targets the 4K buffer size, which balances the initialization\n+        \/\/ costs, memory footprint and cache pressure.\n+        @jdk.internal.vm.annotation.Contended\n+        static final class Buffer {\n+            static final int UUID_CHUNK = 16;\n+            static final int UUID_COUNT = 256;\n+            static final int BUF_SIZE;\n+\n+            static final VarHandle VH_POS;\n+            static {\n+                try {\n+                    VH_POS = MethodHandles.lookup().findVarHandle(Buffer.class, \"pos\", int.class);\n+                    BUF_SIZE = UUID_CHUNK * UUID_COUNT;\n+                } catch (Exception e) {\n+                    throw new InternalError(e);\n+                }\n+            }\n+\n+            final SecureRandom random;\n+            final StampedLock lock;\n+            final byte[] buf;\n+            int pos;\n+\n+            public Buffer() {\n+                this.random = new SecureRandom();\n+                this.lock = new StampedLock();\n+                this.buf = new byte[BUF_SIZE];\n+                this.pos = BUF_SIZE; \/\/ trigger re-creation on first use\n+            }\n+\n+            private static UUID fromRandom(long msb, long lsb) {\n+                \/\/ set version to 3\n+                msb = (msb & (0xFFFF_FFFF_FFFF_0FFFL)) | 0x0000_0000_0000_4000L;\n+                \/\/ set variant to IETF\n+                lsb = (lsb & (0x3FFF_FFFF_FFFF_FFFFL)) | 0x8000_0000_0000_0000L;\n+                return new UUID(msb, lsb);\n+            }\n+\n+            public UUID next() {\n+                long stamp = lock.tryOptimisticRead();\n+                try {\n+                    \/\/ Optimistic path: optimistic locking succeeded.\n+                    \/\/ Try to pull the UUID from the current buffer at current position.\n+                    if (stamp != 0) {\n+                        int p = (int)VH_POS.getAndAdd(this, UUID_CHUNK);\n+                        if (p < BUF_SIZE) {\n+                            long msb = ByteArray.getLong(buf, p);\n+                            long lsb = ByteArray.getLong(buf, p + 8);\n+                            if (lock.validate(stamp)) {\n+                                \/\/ Success: there were no buffer changes. Construct the UUID.\n+                                return fromRandom(msb, lsb);\n+                            }\n+                        }\n+                    }\n+\n+                    \/\/ Semi-pessimistic path: either the buffer was depleted, or optimistic locking\n+                    \/\/ failed. Either way, we need to take the exclusive lock and try again.\n+                    stamp = lock.tryConvertToWriteLock(stamp);\n+                    if (stamp == 0L) {\n+                        stamp = lock.writeLock();\n+                    }\n+\n+                    \/\/ See if some other thread had already replenished the buffer.\n+                    \/\/ Pull the UUID from there then. We are still holding the write lock, so\n+                    \/\/ buffer is guaranteed to not change under our feet.\n+                    if ((int)VH_POS.get(this) > 0) {\n+                        int p = (int)VH_POS.getAndAdd(this, UUID_CHUNK);\n+                        if (p < BUF_SIZE) {\n+                            long msb = ByteArray.getLong(buf, p);\n+                            long lsb = ByteArray.getLong(buf, p + 8);\n+                            return fromRandom(msb, lsb);\n+                        }\n+                    }\n+\n+                    \/\/ Pessimistic path: buffer requires replenishment.\n+                    \/\/ Recreate it from the provided random.\n+                    random.nextBytes(buf);\n+\n+                    \/\/ Take the UUID from new buffer. We are still under write lock,\n+                    \/\/ so we know we are the only thread here.\n+                    VH_POS.set(this, UUID_CHUNK);\n+\n+                    long msb = ByteArray.getLong(buf, 0);\n+                    long lsb = ByteArray.getLong(buf, 8);\n+                    return fromRandom(msb, lsb);\n+                } finally {\n+                    if (StampedLock.isWriteLockStamp(stamp)) {\n+                        lock.unlockWrite(stamp);\n+                    }\n+                }\n+            }\n+        }\n@@ -150,9 +287,1 @@\n-        SecureRandom ng = Holder.numberGenerator;\n-\n-        byte[] randomBytes = new byte[16];\n-        ng.nextBytes(randomBytes);\n-        randomBytes[6]  &= 0x0f;  \/* clear version        *\/\n-        randomBytes[6]  |= 0x40;  \/* set to version 4     *\/\n-        randomBytes[8]  &= 0x3f;  \/* clear variant        *\/\n-        randomBytes[8]  |= (byte) 0x80;  \/* set to IETF variant  *\/\n-        return new UUID(randomBytes);\n+        return RandomUUID.next();\n","filename":"src\/java.base\/share\/classes\/java\/util\/UUID.java","additions":140,"deletions":11,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util;\n+\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(3)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@BenchmarkMode(Mode.Throughput)\n+public class UUIDRandomBench {\n+\n+    @Benchmark\n+    @Threads(1)\n+    public UUID single() {\n+        return UUID.randomUUID();\n+    }\n+\n+    @Benchmark\n+    @Threads(Threads.MAX)\n+    public UUID max() {\n+        return UUID.randomUUID();\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/UUIDRandomBench.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"}]}