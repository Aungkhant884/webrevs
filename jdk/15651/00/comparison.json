{"files":[{"patch":"@@ -2486,0 +2486,20 @@\n+            public int stringSize(int i) {\n+                return Integer.stringSize(i);\n+            }\n+\n+            public int stringSize(long i) {\n+                return Long.stringSize(i);\n+            }\n+\n+            public int getChars(int i, int index, byte[] buf) {\n+                return StringLatin1.getChars(i, index, buf);\n+            }\n+\n+            public int getChars(long i, int index, byte[] buf) {\n+                return StringLatin1.getChars(i, index, buf);\n+            }\n+\n+            public short digitPair(int i) {\n+                return StringLatin1.PACKED_DIGITS[i];\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n-import jdk.internal.vm.annotation.Stable;\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -38,2 +39,1 @@\n-    @Stable\n-    private static final short[] DIGITS;\n+    private static final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n@@ -46,15 +46,0 @@\n-    static {\n-        short[] digits = new short[10 * 10];\n-\n-        for (int i = 0; i < 10; i++) {\n-            short hi = (short) ((i + '0') << 8);\n-\n-            for (int j = 0; j < 10; j++) {\n-                short lo = (short) (j + '0');\n-                digits[i * 10 + j] = (short) (hi | lo);\n-            }\n-        }\n-\n-        DIGITS = digits;\n-    }\n-\n@@ -81,1 +66,1 @@\n-            int digits = DIGITS[r];\n+            int digits = jla.digitPair(r);\n@@ -83,1 +68,0 @@\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n@@ -85,0 +69,1 @@\n+            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n@@ -92,2 +77,1 @@\n-            int digits = DIGITS[r];\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+            int digits = jla.digitPair(r);\n@@ -95,0 +79,1 @@\n+            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n@@ -101,2 +86,2 @@\n-        int digits = DIGITS[ivalue];\n-        putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+        int digits = jla.digitPair(ivalue);\n+        putCharMH.invokeExact(buffer, --index, digits >> 8);\n@@ -105,1 +90,1 @@\n-            putCharMH.invokeExact(buffer, --index, digits >> 8);\n+            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n@@ -117,16 +102,1 @@\n-        boolean negative = value < 0;\n-        int sign = negative ? 1 : 0;\n-\n-        if (!negative) {\n-            value = -value;\n-        }\n-\n-        long precision = -10;\n-        for (int i = 1; i < 19; i++) {\n-            if (value > precision)\n-                return i + sign;\n-\n-            precision = 10 * precision;\n-        }\n-\n-        return 19 + sign;\n+        return jla.stringSize(value);\n","filename":"src\/java.base\/share\/classes\/java\/util\/DecimalDigits.java","additions":11,"deletions":41,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -336,0 +336,50 @@\n+    \/**\n+     * Returns the string representation size for a given int value.\n+     *\n+     * @param x int value\n+     * @return string size\n+     *\/\n+    int stringSize(int x);\n+\n+    \/**\n+     * Returns the string representation size for a given long value.\n+     *\n+     * @param x long value\n+     * @return string size\n+     *\/\n+    int stringSize(long i);\n+\n+    \/**\n+     * For values from 0 to 99 return a short encoding a pair of ASCII-encoded digit characters in little-endian,\n+     * e.g. 0 -> ('0' << 8 | '0'). Used for formatting\n+     *\/\n+    short digitPair(int i);\n+\n+    \/**\n+     * Places characters representing the integer i into the\n+     * character array buf. The characters are placed into\n+     * the buffer backwards starting with the least significant\n+     * digit at the specified index (exclusive), and working\n+     * backwards from there.\n+     *\n+     * @param i     value to convert\n+     * @param index next index, after the least significant digit\n+     * @param buf   target buffer, Latin1-encoded\n+     * @return index of the most significant digit or minus sign, if present\n+     *\/\n+    int getChars(int i, int index, byte[] buf);\n+\n+    \/**\n+     * Places characters representing the long i into the\n+     * character array buf. The characters are placed into\n+     * the buffer backwards starting with the least significant\n+     * digit at the specified index (exclusive), and working\n+     * backwards from there.\n+     *\n+     * @param i     value to convert\n+     * @param index next index, after the least significant digit\n+     * @param buf   target buffer, Latin1-encoded\n+     * @return index of the most significant digit or minus sign, if present\n+     *\/\n+    int getChars(long i, int index, byte[] buf);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"}]}