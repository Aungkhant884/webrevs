{"files":[{"patch":"@@ -1163,1 +1163,1 @@\n-\/\/ Mirror of DecimalDigits.stringSize() method, return the count of digits in integer,\n+\/\/ Mirror of Integer.stringSize() method, return the count of digits in integer,\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -833,1 +833,1 @@\n-        int spaceNeeded = count + DecimalDigits.stringSize(i);\n+        int spaceNeeded = count + Integer.stringSize(i);\n@@ -858,1 +858,1 @@\n-        int spaceNeeded = count + DecimalDigits.stringSize(l);\n+        int spaceNeeded = count + Long.stringSize(l);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/AbstractStringBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -430,1 +430,1 @@\n-        int size = DecimalDigits.stringSize(i);\n+        int size = stringSize(i);\n@@ -460,0 +460,26 @@\n+    \/**\n+     * Returns the string representation size for a given long value.\n+     *\n+     * @param x long value\n+     * @return string size\n+     *\n+     * @implNote There are other ways to compute this: e.g. binary search,\n+     * but values are biased heavily towards zero, and therefore linear search\n+     * wins. The iteration results are also routinely inlined in the generated\n+     * code after loop unrolling.\n+     *\/\n+    static int stringSize(long x) {\n+        int d = 1;\n+        if (x >= 0) {\n+            d = 0;\n+            x = -x;\n+        }\n+        long p = -10;\n+        for (int i = 1; i < 19; i++) {\n+            if (x > p)\n+                return i + d;\n+            p = 10 * p;\n+        }\n+        return 19 + d;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -460,1 +460,1 @@\n-        int size = DecimalDigits.stringSize(i);\n+        int size = stringSize(i);\n@@ -490,0 +490,26 @@\n+    \/**\n+     * Returns the string representation size for a given long value.\n+     *\n+     * @param x long value\n+     * @return string size\n+     *\n+     * @implNote There are other ways to compute this: e.g. binary search,\n+     * but values are biased heavily towards zero, and therefore linear search\n+     * wins. The iteration results are also routinely inlined in the generated\n+     * code after loop unrolling.\n+     *\/\n+    static int stringSize(long x) {\n+        int d = 1;\n+        if (x >= 0) {\n+            d = 0;\n+            x = -x;\n+        }\n+        long p = -10;\n+        for (int i = 1; i < 19; i++) {\n+            if (x > p)\n+                return i + d;\n+            p = 10 * p;\n+        }\n+        return 19 + d;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-        return checkOverflow(lengthCoder + DecimalDigits.stringSize(value));\n+        return checkOverflow(lengthCoder + Integer.stringSize(value));\n@@ -113,1 +113,1 @@\n-        return checkOverflow(lengthCoder + DecimalDigits.stringSize(value));\n+        return checkOverflow(lengthCoder + Long.stringSize(value));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringConcatHelper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -124,2 +124,0 @@\n-import jdk.internal.util.DecimalDigits;\n-\n@@ -3356,0 +3354,11 @@\n+        \/\/ Simplified variant of Integer.stringSize that assumes positive values\n+        private static int stringSize(int x) {\n+            int p = 10;\n+            for (int i = 1; i < 10; i++) {\n+                if (x < p)\n+                    return i;\n+                p = 10 * p;\n+            }\n+            return 10;\n+        }\n+\n@@ -3376,1 +3385,1 @@\n-            int stringSize = DecimalDigits.stringSize(val);\n+            int stringSize = stringSize(val);\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -32,0 +32,35 @@\n+\n+    \/**\n+     * Each element of the array represents the packaging of two ascii characters based on little endian:<p>\n+     * <pre>\n+     *      00 -> '0' | ('0' << 8) -> 0x3030\n+     *      01 -> '1' | ('0' << 8) -> 0x3130\n+     *      02 -> '2' | ('0' << 8) -> 0x3230\n+     *\n+     *     ...\n+     *\n+     *      10 -> '0' | ('1' << 8) -> 0x3031\n+     *      11 -> '1' | ('1' << 8) -> 0x3131\n+     *      12 -> '2' | ('1' << 8) -> 0x3231\n+     *\n+     *     ...\n+     *\n+     *      97 -> '7' | ('9' << 8) -> 0x3739\n+     *      98 -> '8' | ('9' << 8) -> 0x3839\n+     *      99 -> '9' | ('9' << 8) -> 0x3939\n+     * <\/pre>\n+     *\/\n+    @Stable\n+    private static final short[] PACKED_DIGITS = new short[] {\n+            0x3030, 0x3130, 0x3230, 0x3330, 0x3430, 0x3530, 0x3630, 0x3730, 0x3830, 0x3930,\n+            0x3031, 0x3131, 0x3231, 0x3331, 0x3431, 0x3531, 0x3631, 0x3731, 0x3831, 0x3931,\n+            0x3032, 0x3132, 0x3232, 0x3332, 0x3432, 0x3532, 0x3632, 0x3732, 0x3832, 0x3932,\n+            0x3033, 0x3133, 0x3233, 0x3333, 0x3433, 0x3533, 0x3633, 0x3733, 0x3833, 0x3933,\n+            0x3034, 0x3134, 0x3234, 0x3334, 0x3434, 0x3534, 0x3634, 0x3734, 0x3834, 0x3934,\n+            0x3035, 0x3135, 0x3235, 0x3335, 0x3435, 0x3535, 0x3635, 0x3735, 0x3835, 0x3935,\n+            0x3036, 0x3136, 0x3236, 0x3336, 0x3436, 0x3536, 0x3636, 0x3736, 0x3836, 0x3936,\n+            0x3037, 0x3137, 0x3237, 0x3337, 0x3437, 0x3537, 0x3637, 0x3737, 0x3837, 0x3937,\n+            0x3038, 0x3138, 0x3238, 0x3338, 0x3438, 0x3538, 0x3638, 0x3738, 0x3838, 0x3938,\n+            0x3039, 0x3139, 0x3239, 0x3339, 0x3439, 0x3539, 0x3639, 0x3739, 0x3839, 0x3939\n+    };\n+\n@@ -93,2 +128,2 @@\n-        return stringSize(value);\n-    }\n+        boolean negative = value < 0;\n+        int sign = negative ? 1 : 0;\n@@ -96,33 +131,3 @@\n-    \/**\n-     * Each element of the array represents the packaging of two ascii characters based on little endian:<p>\n-     * <pre>\n-     *      00 -> '0' | ('0' << 8) -> 0x3030\n-     *      01 -> '1' | ('0' << 8) -> 0x3130\n-     *      02 -> '2' | ('0' << 8) -> 0x3230\n-     *\n-     *     ...\n-     *\n-     *      10 -> '0' | ('1' << 8) -> 0x3031\n-     *      11 -> '1' | ('1' << 8) -> 0x3131\n-     *      12 -> '2' | ('1' << 8) -> 0x3231\n-     *\n-     *     ...\n-     *\n-     *      97 -> '7' | ('9' << 8) -> 0x3739\n-     *      98 -> '8' | ('9' << 8) -> 0x3839\n-     *      99 -> '9' | ('9' << 8) -> 0x3939\n-     * <\/pre>\n-     *\/\n-    @Stable\n-    private static final short[] PACKED_DIGITS = new short[] {\n-            0x3030, 0x3130, 0x3230, 0x3330, 0x3430, 0x3530, 0x3630, 0x3730, 0x3830, 0x3930,\n-            0x3031, 0x3131, 0x3231, 0x3331, 0x3431, 0x3531, 0x3631, 0x3731, 0x3831, 0x3931,\n-            0x3032, 0x3132, 0x3232, 0x3332, 0x3432, 0x3532, 0x3632, 0x3732, 0x3832, 0x3932,\n-            0x3033, 0x3133, 0x3233, 0x3333, 0x3433, 0x3533, 0x3633, 0x3733, 0x3833, 0x3933,\n-            0x3034, 0x3134, 0x3234, 0x3334, 0x3434, 0x3534, 0x3634, 0x3734, 0x3834, 0x3934,\n-            0x3035, 0x3135, 0x3235, 0x3335, 0x3435, 0x3535, 0x3635, 0x3735, 0x3835, 0x3935,\n-            0x3036, 0x3136, 0x3236, 0x3336, 0x3436, 0x3536, 0x3636, 0x3736, 0x3836, 0x3936,\n-            0x3037, 0x3137, 0x3237, 0x3337, 0x3437, 0x3537, 0x3637, 0x3737, 0x3837, 0x3937,\n-            0x3038, 0x3138, 0x3238, 0x3338, 0x3438, 0x3538, 0x3638, 0x3738, 0x3838, 0x3938,\n-            0x3039, 0x3139, 0x3239, 0x3339, 0x3439, 0x3539, 0x3639, 0x3739, 0x3839, 0x3939\n-    };\n+        if (!negative) {\n+            value = -value;\n+        }\n@@ -130,3 +135,4 @@\n-    public static short digitPair(int i) {\n-        return PACKED_DIGITS[i];\n-    }\n+        long precision = -10;\n+        for (int i = 1; i < 19; i++) {\n+            if (value > precision)\n+                return i + sign;\n@@ -134,16 +140,1 @@\n-    \/**\n-     * Returns the string representation size for a given int value.\n-     *\n-     * @param x int value\n-     * @return string size\n-     *\n-     * @implNote There are other ways to compute this: e.g. binary search,\n-     * but values are biased heavily towards zero, and therefore linear search\n-     * wins. The iteration results are also routinely inlined in the generated\n-     * code after loop unrolling.\n-     *\/\n-    public static int stringSize(int x) {\n-        int d = 1;\n-        if (x >= 0) {\n-            d = 0;\n-            x = -x;\n+            precision = 10 * precision;\n@@ -151,7 +142,2 @@\n-        int p = -10;\n-        for (int i = 1; i < 10; i++) {\n-            if (x > p)\n-                return i + d;\n-            p = 10 * p;\n-        }\n-        return 10 + d;\n+\n+        return 19 + sign;\n@@ -160,24 +146,2 @@\n-    \/**\n-     * Returns the string representation size for a given long value.\n-     *\n-     * @param x long value\n-     * @return string size\n-     *\n-     * @implNote There are other ways to compute this: e.g. binary search,\n-     * but values are biased heavily towards zero, and therefore linear search\n-     * wins. The iteration results are also routinely inlined in the generated\n-     * code after loop unrolling.\n-     *\/\n-    public static int stringSize(long x) {\n-        int d = 1;\n-        if (x >= 0) {\n-            d = 0;\n-            x = -x;\n-        }\n-        long p = -10;\n-        for (int i = 1; i < 19; i++) {\n-            if (x > p)\n-                return i + d;\n-            p = 10 * p;\n-        }\n-        return 19 + d;\n+    public static short digitPair(int i) {\n+        return PACKED_DIGITS[i];\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/DecimalDigits.java","additions":49,"deletions":85,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -38,0 +38,3 @@\n+    @Stable\n+    private static final short[] DIGITS;\n+\n@@ -43,9 +46,0 @@\n-    \/**\n-     * Constructor.\n-     *\/\n-    private OctalDigits() {\n-    }\n-\n-    @Stable\n-    private static final short[] DIGITS;\n-\n@@ -67,0 +61,6 @@\n+    \/**\n+     * Constructor.\n+     *\/\n+    private OctalDigits() {\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/OctalDigits.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"}]}