{"files":[{"patch":"@@ -40,0 +40,3 @@\n+  if (_dependency == UnconditionalDependency) {\n+    return this;\n+  }\n@@ -44,4 +47,1 @@\n-  if (_dependency != RegularDependency) {\n-    return this;\n-  }\n-  return phase->type(in(1))->higher_equal_speculative(_type) ? in(1) : this;\n+  return higher_equal_types(phase, in(1)) ? in(1) : this;\n@@ -104,0 +104,4 @@\n+uint ConstraintCastNode::hash() const {\n+  return TypeNode::hash() + (int)_dependency + (_extra_types != nullptr ? _extra_types->hash() : 0);\n+}\n+\n@@ -105,1 +109,10 @@\n-  return TypeNode::cmp(n) && ((ConstraintCastNode&)n)._dependency == _dependency;\n+  if (!TypeNode::cmp(n)) {\n+    return false;\n+  }\n+  if (((ConstraintCastNode&) n)._dependency != _dependency) {\n+    return false;\n+  }\n+  if (_extra_types == nullptr || ((ConstraintCastNode&) n)._extra_types == nullptr) {\n+    return _extra_types == ((ConstraintCastNode&) n)._extra_types;\n+  }\n+  return _extra_types->eq(((ConstraintCastNode&)n)._extra_types);\n@@ -112,1 +125,2 @@\n-Node* ConstraintCastNode::make_cast(int opcode, Node* c, Node *n, const Type *t, DependencyType dependency) {\n+Node* ConstraintCastNode::make_cast(int opcode, Node* c, Node* n, const Type* t, DependencyType dependency,\n+                                    const TypeTuple* types) {\n@@ -115,1 +129,1 @@\n-    Node* cast = new CastIINode(n, t, dependency);\n+    Node* cast = new CastIINode(n, t, dependency, false, types);\n@@ -120,1 +134,1 @@\n-    Node* cast = new CastLLNode(n, t, dependency);\n+    Node* cast = new CastLLNode(n, t, dependency, types);\n@@ -125,1 +139,1 @@\n-    Node* cast = new CastPPNode(n, t, dependency);\n+    Node* cast = new CastPPNode(n, t, dependency, types);\n@@ -130,1 +144,1 @@\n-    Node* cast = new CastFFNode(n, t, dependency);\n+    Node* cast = new CastFFNode(n, t, dependency, types);\n@@ -135,1 +149,1 @@\n-    Node* cast = new CastDDNode(n, t, dependency);\n+    Node* cast = new CastDDNode(n, t, dependency, types);\n@@ -140,1 +154,1 @@\n-    Node* cast = new CastVVNode(n, t, dependency);\n+    Node* cast = new CastVVNode(n, t, dependency, types);\n@@ -144,1 +158,1 @@\n-  case Op_CheckCastPP: return new CheckCastPPNode(c, n, t, dependency);\n+  case Op_CheckCastPP: return new CheckCastPPNode(c, n, t, dependency, types);\n@@ -154,1 +168,1 @@\n-    return make_cast(Op_CastII, c, n, t, dependency);\n+    return make_cast(Op_CastII, c, n, t, dependency, nullptr);\n@@ -157,1 +171,1 @@\n-    return make_cast(Op_CastLL, c, n, t, dependency);\n+    return make_cast(Op_CastLL, c, n, t, dependency, nullptr);\n@@ -190,1 +204,1 @@\n-        u->bottom_type()->higher_equal(type())) {\n+        higher_equal_types(gvn, u)) {\n@@ -206,0 +220,15 @@\n+bool ConstraintCastNode::higher_equal_types(PhaseGVN* phase, const Node* other) const {\n+  const Type* t = phase->type(other);\n+  if (!t->higher_equal_speculative(type())) {\n+    return false;\n+  }\n+  if (_extra_types != nullptr) {\n+    for (uint i = 0; i < _extra_types->cnt(); ++i) {\n+      if (!t->higher_equal_speculative(_extra_types->field_at(i))) {\n+        return false;\n+      }\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -209,0 +238,4 @@\n+  if (_extra_types != nullptr) {\n+    st->print(\" extra types: \");\n+    _extra_types->dump_on(st);\n+  }\n@@ -527,1 +560,2 @@\n-Node* ConstraintCastNode::make_cast_for_type(Node* c, Node* in, const Type* type, DependencyType dependency) {\n+Node* ConstraintCastNode::make_cast_for_type(Node* c, Node* in, const Type* type, DependencyType dependency,\n+                                             const TypeTuple* types) {\n@@ -530,1 +564,1 @@\n-    cast = make_cast(Op_CastII, c, in, type, dependency);\n+    cast = make_cast(Op_CastII, c, in, type, dependency, types);\n@@ -532,1 +566,1 @@\n-    cast = make_cast(Op_CastLL, c, in, type, dependency);\n+    cast = make_cast(Op_CastLL, c, in, type, dependency, types);\n@@ -534,1 +568,1 @@\n-    cast = make_cast(Op_CastFF, c, in, type, dependency);\n+    cast = make_cast(Op_CastFF, c, in, type, dependency, types);\n@@ -536,1 +570,1 @@\n-    cast = make_cast(Op_CastDD, c, in, type, dependency);\n+    cast = make_cast(Op_CastDD, c, in, type, dependency, types);\n@@ -538,1 +572,1 @@\n-    cast = make_cast(Op_CastVV, c, in, type, dependency);\n+    cast = make_cast(Op_CastVV, c, in, type, dependency, types);\n@@ -540,1 +574,1 @@\n-    cast = make_cast(Op_CastPP, c, in, type, dependency);\n+    cast = make_cast(Op_CastPP, c, in, type, dependency, types);\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":57,"deletions":23,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+  virtual uint hash() const;    \/\/ Check the type\n@@ -48,0 +49,7 @@\n+  private:\n+  \/\/ PhiNode::Ideal() transforms a Phi that merges a single uncasted value into a single cast pinned at the region.\n+  \/\/ The types of cast nodes eliminated as a consequence of this transformation are collected and stored here so the\n+  \/\/ type dependencies carried by the cast are known. The cast can then be eliminated if the type of its input is\n+  \/\/ narrower (or equal) than all the types it carries.\n+  const TypeTuple* _extra_types;\n+\n@@ -49,2 +57,3 @@\n-  ConstraintCastNode(Node *n, const Type *t, DependencyType dependency)\n-    : TypeNode(t,2), _dependency(dependency) {\n+  ConstraintCastNode(Node* n, const Type* t, ConstraintCastNode::DependencyType dependency,\n+                     const TypeTuple* types)\n+          : TypeNode(t,2), _dependency(dependency), _extra_types(types) {\n@@ -62,1 +71,1 @@\n-  static Node* make_cast(int opcode, Node* c, Node *n, const Type *t, DependencyType dependency);\n+  static Node* make_cast(int opcode, Node* c, Node* n, const Type* t, DependencyType dependency, const TypeTuple* types);\n@@ -69,1 +78,2 @@\n-  static Node* make_cast_for_type(Node* c, Node* in, const Type* type, DependencyType dependency);\n+  static Node* make_cast_for_type(Node* c, Node* in, const Type* type, DependencyType dependency,\n+                                  const TypeTuple* types);\n@@ -94,0 +104,10 @@\n+\n+  bool higher_equal_types(PhaseGVN* phase, const Node* other) const;\n+\n+  int nb_extra_types() const {\n+    return _extra_types == nullptr ? 0 : _extra_types->cnt();\n+  }\n+  \n+  const Type* extra_type_at(int i) const {\n+    return _extra_types->field_at(i);\n+  }\n@@ -106,2 +126,2 @@\n-  CastIINode(Node* n, const Type* t, DependencyType dependency = RegularDependency, bool range_check_dependency = false)\n-    : ConstraintCastNode(n, t, dependency), _range_check_dependency(range_check_dependency) {\n+  CastIINode(Node* n, const Type* t, DependencyType dependency = RegularDependency, bool range_check_dependency = false, const TypeTuple* types = nullptr)\n+    : ConstraintCastNode(n, t, dependency, types), _range_check_dependency(range_check_dependency) {\n@@ -111,1 +131,1 @@\n-    : ConstraintCastNode(n, t, dependency), _range_check_dependency(range_check_dependency) {\n+    : ConstraintCastNode(n, t, dependency, nullptr), _range_check_dependency(range_check_dependency) {\n@@ -137,1 +157,1 @@\n-    : ConstraintCastNode(n, t, dependency) {\n+    : ConstraintCastNode(n, t, dependency, nullptr) {\n@@ -141,2 +161,2 @@\n-  CastLLNode(Node* n, const Type* t, DependencyType dependency = RegularDependency)\n-          : ConstraintCastNode(n, t, dependency){\n+  CastLLNode(Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+          : ConstraintCastNode(n, t, dependency, types) {\n@@ -154,2 +174,2 @@\n-  CastFFNode(Node* n, const Type* t, DependencyType dependency = RegularDependency)\n-          : ConstraintCastNode(n, t, dependency){\n+  CastFFNode(Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+          : ConstraintCastNode(n, t, dependency, types) {\n@@ -164,2 +184,2 @@\n-  CastDDNode(Node* n, const Type* t, DependencyType dependency = RegularDependency)\n-          : ConstraintCastNode(n, t, dependency){\n+  CastDDNode(Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+          : ConstraintCastNode(n, t, dependency, types) {\n@@ -174,2 +194,2 @@\n-  CastVVNode(Node* n, const Type* t, DependencyType dependency = RegularDependency)\n-          : ConstraintCastNode(n, t, dependency){\n+  CastVVNode(Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+          : ConstraintCastNode(n, t, dependency, types) {\n@@ -187,2 +207,2 @@\n-  CastPPNode (Node *n, const Type *t, DependencyType dependency = RegularDependency)\n-    : ConstraintCastNode(n, t, dependency) {\n+  CastPPNode (Node *n, const Type *t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+    : ConstraintCastNode(n, t, dependency, types) {\n@@ -198,2 +218,2 @@\n-  CheckCastPPNode(Node *c, Node *n, const Type *t, DependencyType dependency = RegularDependency)\n-    : ConstraintCastNode(n, t, dependency) {\n+  CheckCastPPNode(Node *c, Node *n, const Type *t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+    : ConstraintCastNode(n, t, dependency, types) {\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":40,"deletions":20,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2136,0 +2136,1 @@\n+      const TypeTuple* extra_types = collect_types(phase, r, phi_type);\n@@ -2139,1 +2140,2 @@\n-          cast = ConstraintCastNode::make_cast(Op_CastPP, r, uin, phi_type, ConstraintCastNode::StrongDependency);\n+          cast = ConstraintCastNode::make_cast(Op_CastPP, r, uin, phi_type, ConstraintCastNode::StrongDependency,\n+                                               extra_types);\n@@ -2149,1 +2151,2 @@\n-            cast = ConstraintCastNode::make_cast(Op_CastPP, r, uin, TypePtr::NOTNULL, ConstraintCastNode::StrongDependency);\n+            cast = ConstraintCastNode::make_cast(Op_CastPP, r, uin, TypePtr::NOTNULL,\n+                                                 ConstraintCastNode::StrongDependency, extra_types);\n@@ -2161,1 +2164,2 @@\n-            cast = ConstraintCastNode::make_cast(Op_CheckCastPP, r, n, phi_type, ConstraintCastNode::StrongDependency);\n+            cast = ConstraintCastNode::make_cast(Op_CheckCastPP, r, n, phi_type, ConstraintCastNode::StrongDependency,\n+                                                 extra_types);\n@@ -2164,1 +2168,2 @@\n-            cast = ConstraintCastNode::make_cast(Op_CastPP, r, uin, phi_type, ConstraintCastNode::StrongDependency);\n+            cast = ConstraintCastNode::make_cast(Op_CastPP, r, uin, phi_type, ConstraintCastNode::StrongDependency,\n+                                                 extra_types);\n@@ -2168,1 +2173,1 @@\n-        cast = ConstraintCastNode::make_cast_for_type(r, uin, phi_type, ConstraintCastNode::StrongDependency);\n+        cast = ConstraintCastNode::make_cast_for_type(r, uin, phi_type, ConstraintCastNode::StrongDependency, extra_types);\n@@ -2563,0 +2568,44 @@\n+static int compare_types(const Type* const& e1, const Type* const& e2) {\n+  return (intptr_t)e1 - (intptr_t)e2;\n+}\n+\n+\/\/ Collect types at casts that are going to be eliminated at that Phi and store them in a TypeTuple.\n+\/\/ Sort the types using an arbitrary order so a list of some types always hashes to the same TypeTuple (and TypeTuple\n+\/\/ pointer comparison is enough to tell if 2 list of types are the same or not)\n+const TypeTuple* PhiNode::collect_types(PhaseGVN* phase, const Node* r, const Type* phi_type) const {\n+  ResourceMark rm;\n+  GrowableArray<const Type*> types;\n+  for (uint i = 1; i < req(); i++) {\n+    if (r->in(i) == nullptr || phase->type(r->in(i)) == Type::TOP) {\n+      continue;\n+    }\n+    Node* in = Node::in(i);\n+    const Type* t = phase->type(in);\n+    if (in == nullptr || in == this || t == Type::TOP) {\n+      continue;\n+    }\n+    if (t != phi_type && t->higher_equal_speculative(phi_type)) {\n+      types.insert_sorted<compare_types>(t);\n+    }\n+    while (in != nullptr && in->is_ConstraintCast()) {\n+      Node* next = in->in(1);\n+      if (phase->type(next)->isa_rawptr() && phase->type(in)->isa_oopptr()) {\n+        break;\n+      }\n+      ConstraintCastNode* cast = in->as_ConstraintCast();\n+      for (int j = 0; j < cast->nb_extra_types(); ++j) {\n+        const Type* extra_t = cast->extra_type_at(j);\n+        if (extra_t != phi_type && extra_t->higher_equal_speculative(phi_type)) {\n+          types.insert_sorted<compare_types>(extra_t);\n+        }\n+      }\n+      in = next;\n+    }\n+  }\n+  const Type **flds = (const Type **)(phase->C->type_arena()->AmallocWords(types.length()*sizeof(Type*)));\n+  for (int i = 0; i < types.length(); ++i) {\n+    flds[i] = types.at(i);\n+  }\n+  return TypeTuple::make(types.length(), flds);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":54,"deletions":5,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -271,0 +271,2 @@\n+\n+  const TypeTuple* collect_types(PhaseGVN* phase, const Node* r, const Type* phi_type) const;\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1697,1 +1697,2 @@\n-                cast = ConstraintCastNode::make_cast_for_type(x_ctrl, in, in_t, ConstraintCastNode::UnconditionalDependency);\n+                cast = ConstraintCastNode::make_cast_for_type(x_ctrl, in, in_t,\n+                                                              ConstraintCastNode::UnconditionalDependency, nullptr);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8303737\n+ * @summary C2: cast nodes from PhiNode::Ideal() cause \"Base pointers must match\" assert failure\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -XX:-BackgroundCompilation -XX:LoopMaxUnroll=2 -XX:+UseParallelGC -XX:+UnlockDiagnosticVMOptions -XX:+StressIGVN\n+ *                   -XX:-UseLoopPredicate -XX:-UseProfiledLoopPredicate -XX:StressSeed=2953783466 TestAddPChainMismatchedBase\n+ * @run main\/othervm -XX:-BackgroundCompilation -XX:LoopMaxUnroll=2 -XX:+UseParallelGC -XX:+UnlockDiagnosticVMOptions -XX:+StressIGVN\n+ *                   -XX:-UseLoopPredicate -XX:-UseProfiledLoopPredicate TestAddPChainMismatchedBase\n+ *\/\n+\n+public class TestAddPChainMismatchedBase {\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            test();\n+            testHelper(null, true);\n+            testHelper2(1000);\n+        }\n+    }\n+\n+    private static void test() {\n+        int l;\n+        for (l = 0; l < 5; l++) {\n+            for (int i = 0; i < 2; i++) {\n+            }\n+        }\n+        testHelper2(l);\n+    }\n+\n+    private static void testHelper2(int l) {\n+        int[] array = new int[1000];\n+        if (l == 5) {\n+            l = 4;\n+        } else {\n+            l = 1000;\n+        }\n+        for (int k = 0; k < 2; k++) {\n+            int v = 0;\n+            int i = 0;\n+            for (; ; ) {\n+                synchronized (new Object()) {\n+                }\n+                array = testHelper(array, false);\n+                v += array[i];\n+                int j = i;\n+                i++;\n+                if (i >= l) {\n+                    break;\n+                }\n+                array[j] = v;\n+            }\n+        }\n+    }\n+\n+    private static int[] testHelper(int[] array, boolean flag) {\n+        if (flag) {\n+            return new int[1000];\n+        }\n+        return array;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/controldependency\/TestAddPChainMismatchedBase.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8303737\n+ * @summary C2: cast nodes from PhiNode::Ideal() cause \"Base pointers must match\" assert failure\n+ * @run main\/othervm -XX:-TieredCompilation -XX:+UnlockDiagnosticVMOptions -XX:+StressIGVN -XX:+StressCCP -Xcomp\n+ *                   -XX:CompileOnly=TestAddPChainMismatchedBase2::* -XX:StressSeed=1581936900 TestAddPChainMismatchedBase2\n+ * @run main\/othervm -XX:-TieredCompilation -XX:+UnlockDiagnosticVMOptions -XX:+StressIGVN -XX:+StressCCP -Xcomp\n+ *                   -XX:CompileOnly=TestAddPChainMismatchedBase2::* TestAddPChainMismatchedBase2\n+ *\/\n+\n+public class TestAddPChainMismatchedBase2 {\n+    static final int N = 400;\n+    static int iFld;\n+\n+    public static void main(String[] strArr) {\n+        test(8);\n+    }\n+\n+    static void test(int i2) {\n+        int i12 = 4, iArr1[] = new int[N];\n+        double d1, dArr2[] = new double[N];\n+        do {\n+            iArr1[i12] = 400907;\n+            try {\n+                iArr1[1] = 47 % i2;\n+            } catch (ArithmeticException a_e) {\n+            }\n+            iArr1[i12 + 1] -= d1 = 1;\n+            while ((d1 += 2) < 5) {\n+                iArr1 = iArr1;\n+                iArr1[6] = 3;\n+            }\n+        } while (++i12 < 14);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/controldependency\/TestAddPChainMismatchedBase2.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,195 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8303737\n+ * @summary C2: Load can bypass subtype check that enforces it's from the right object type\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation -XX:-UseOnStackReplacement -XX:CompileOnly=TestLoadBypassesClassCast::test\n+ *                   -XX:CompileThreshold=20000 -XX:LoopMaxUnroll=1 -XX:-LoopUnswitching -XX:+UseParallelGC TestLoadBypassesClassCast\n+ *\n+ *\/\n+\n+public class TestLoadBypassesClassCast {\n+    private static Object saved_o;\n+    private static Object field_o = new A();\n+    private static Object saved_casted_o;\n+    private static float barrier;\n+    private static Object[] memory = new Object[100];\n+\n+    public static void main(String[] args) {\n+        float[] array = new float[100];\n+        A a = new A();\n+        B b = new B();\n+        C c = new C();\n+        D d = new D();\n+\n+        \/\/ create garbage so GC runs\n+        Thread thread = new Thread() {\n+            public void run() {\n+                while (true) {\n+                    int[] array = new int[1000];\n+                }\n+            }\n+        };\n+\n+        thread.setDaemon(true);\n+        thread.start();\n+\n+        for (int i = 0; i < 20_000; i++) {\n+            test(true, a, array, true, false);\n+            test(false, b, array, true, false);\n+            test(false, d, array, true, true);\n+            test(true, a, array, false, false);\n+            test(false, b, array, false, false);\n+            testHelper2(42);\n+            testHelper3(true, 42);\n+        }\n+        for (int j = 0; j < 1000; j++) {\n+            for (int i = 0; i < 1_000_000; i++) {\n+                test(false, d, array, true, true);\n+            }\n+        }\n+    }\n+\n+    private static int test(boolean flag, Object o, float[] array, boolean flag2, boolean flag3) {\n+        int ret = (int)array[2];\n+        if (o == null) {\n+        }\n+        saved_o = o;  \/\/ (CastPP o): cast to not null\n+\n+        \/\/ A.objectField load from o hosted here even though o was not checked to be of type A\n+        \/\/ result of the load doesn't hold an oop if o is not an A\n+        if (flag2) {\n+            for (int i = 1; i < 100; i *= 2) {\n+                \/\/ safepoint here with result of load above live and expected to be an oop. Not the case\n+                \/\/ if o is of type D: crash in gc code\n+            }\n+\n+            if (flag3) {\n+            } else {\n+                saved_casted_o = (A) o;  \/\/ (CheckCastPP (CastPP o)): cast to not null A\n+\n+                int j;\n+                for (j = 1; j < 2; j *= 2) {\n+\n+                }\n+\n+                testHelper3(flag, j);  \/\/ goes away after CCP\n+\n+                int i;\n+                for (i = 0; i < 2; i++) {\n+                }\n+                 \/\/ array[2] after one round of loop opts, control\n+                 \/\/ dependent on range check, range check replaced by\n+                 \/\/ array[2] range check above, control dependent\n+                 \/\/ nodes become control dependent on that range check\n+                ret += array[i];\n+\n+                Object o2;\n+                if (flag) {\n+                    o2 = saved_casted_o; \/\/ (CheckCastPP (CastPP o)): cast to to not null A\n+                } else {\n+                    o2 = testHelper2(i); \/\/ (CastPP o) after 1 round of loop opts: cast to not null\n+                }\n+                \/\/ subtype check split thru Phi. CheckCastPP becomes control dependent on merge point\n+                \/\/ phi becomes (CastPP o) after 1 round of loop opts: cast to not null\n+                \/\/ subtype check from split thru phi in one branch of the if replaced by dominating one\n+                \/\/ empty if blocks, if goes away. CheckCastPP becomes control dependent on range check above\n+                \/\/ CastPP replaced by dominating CastPP for null check\n+                A a = (A) o2;\n+                ret += a.objectField.intField;\n+            }\n+        } else {\n+            \/\/ same logic as above so if this a.objectField load and\n+            \/\/ the one above lose their dependency on the type check\n+            \/\/ they common above all ifs\n+            saved_casted_o = (A) o;\n+\n+            int j;\n+            for (j = 1; j < 2; j *= 2) {\n+\n+            }\n+\n+            testHelper3(flag, j);\n+\n+            int i;\n+            for (i = 0; i < 2; i++) {\n+            }\n+            ret += array[i];\n+\n+            Object o2;\n+            if (flag) {\n+                o2 = saved_casted_o;\n+            } else {\n+                o2 = testHelper2(i);\n+            }\n+            A a = (A) o2;\n+            ret += a.objectField.intField;\n+            ret += barrier;\n+        }\n+\n+        return ret;\n+    }\n+\n+    private static void testHelper3(boolean flag, int j) {\n+        if (j == 2) {\n+            if (flag) {\n+                barrier = 42;\n+            }\n+        }\n+    }\n+\n+    private static Object testHelper2(int i) {\n+        Object o2;\n+        if (i == 2) {\n+            o2 = saved_o;\n+        } else {\n+            o2 = field_o;\n+            if (o2 == null) {\n+            }\n+        }\n+        return o2;\n+    }\n+\n+    private static class C {\n+    }\n+\n+    private static class A extends C {\n+        public E objectField = new E();\n+    }\n+\n+    private static class B extends A {\n+    }\n+\n+    private static class D extends C {\n+        public int neverAccessedField = 0x12345678;\n+\n+    }\n+\n+    private static class E {\n+        public int intField;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/controldependency\/TestLoadBypassesClassCast.java","additions":195,"deletions":0,"binary":false,"changes":195,"status":"added"}]}