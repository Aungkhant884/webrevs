{"files":[{"patch":"@@ -296,3 +296,0 @@\n-    \/\/ NOTE: this is called too early in the bootstrapping process to be\n-    \/\/ guarded by Universe::is_gte_jdk14x_version().\n-    \/\/ Also for lambda generated code, gte jdk8\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -306,0 +306,11 @@\n+     *\n+     * Native accessor, i.e. VM reflection implementation, is used if one of\n+     * the following conditions is met:\n+     * 1. during VM early startup and method handle support is fully initialized\n+     * 2. a Java native method\n+     * 3. -Djdk.reflect.useNativeAccessorOnly=true is set\n+     * 4. the member takes a variable number of arguments and the last parameter\n+     *    is an array (see details below)\n+     * 5. the member's method type has an arity >= 255\n+     *\n+     * Otherwise, direct invocation of method handles is used.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleAccessorFactory.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -543,0 +543,4 @@\n+    \/*\n+     * If -Djdk.reflect.useNativeAccessorOnly is set, use the native accessor only.\n+     * For testing purpose only.\n+     *\/\n@@ -551,5 +555,0 @@\n-    \/\/ New implementation uses direct invocation of method handles\n-    private static final int METHOD_MH_ACCESSOR = 0x1;\n-    private static final int FIELD_MH_ACCESSOR = 0x2;\n-    private static final int ALL_MH_ACCESSORS = METHOD_MH_ACCESSOR | FIELD_MH_ACCESSOR;\n-\n@@ -567,11 +566,0 @@\n-    \/\/ \"Inflation\" mechanism. Loading bytecodes to implement\n-    \/\/ Method.invoke() and Constructor.newInstance() currently costs\n-    \/\/ 3-4x more than an invocation via native code for the first\n-    \/\/ invocation (though subsequent invocations have been benchmarked\n-    \/\/ to be over 20x faster). Unfortunately this cost increases\n-    \/\/ startup time for certain applications that use reflection\n-    \/\/ intensively (but only once per class) to bootstrap themselves.\n-    \/\/ To avoid this penalty we reuse the existing JVM entry points\n-    \/\/ for the first few invocations of Methods and Constructors and\n-    \/\/ then switch to the bytecode-based implementations.\n-\n@@ -602,3 +590,1 @@\n-        \/\/ Defer initialization until module system is initialized so as\n-        \/\/ to avoid inflation and spinning bytecode in unnamed modules\n-        \/\/ during early startup.\n+        \/\/ Always use the default configuration until the module system is initialized.\n@@ -615,3 +601,0 @@\n-        boolean useNativeAccessorOnly = DEFAULT_CONFIG.useNativeAccessorOnly;\n-        boolean disableSerialConstructorChecks = DEFAULT_CONFIG.disableSerialConstructorChecks;\n-\n@@ -619,6 +602,3 @@\n-        String val = props.getProperty(\"jdk.reflect.useNativeAccessorOnly\");\n-        if (val != null && val.equals(\"true\")) {\n-            useNativeAccessorOnly = true;\n-        }\n-\n-        disableSerialConstructorChecks =\n+        boolean useNativeAccessorOnly =\n+            \"true\".equals(props.getProperty(\"jdk.reflect.useNativeAccessorOnly\"));\n+        boolean disableSerialConstructorChecks =\n@@ -627,2 +607,1 @@\n-        return new Config(useNativeAccessorOnly,\n-                          disableSerialConstructorChecks);\n+        return new Config(useNativeAccessorOnly, disableSerialConstructorChecks);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":9,"deletions":30,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm NegativeTest\n+ * @run testng NegativeTest\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/NegativeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}