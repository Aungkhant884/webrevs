{"files":[{"patch":"@@ -83,0 +83,1 @@\n+class RuntimeStub; \/\/ for as_runtime_stub()\n@@ -167,6 +168,7 @@\n-  nmethod* as_nmethod_or_null()                { return is_nmethod() ? (nmethod*) this : NULL; }\n-  nmethod* as_nmethod()                        { assert(is_nmethod(), \"must be nmethod\"); return (nmethod*) this; }\n-  CompiledMethod* as_compiled_method_or_null() { return is_compiled() ? (CompiledMethod*) this : NULL; }\n-  CompiledMethod* as_compiled_method()         { assert(is_compiled(), \"must be compiled\"); return (CompiledMethod*) this; }\n-  CodeBlob* as_codeblob_or_null() const        { return (CodeBlob*) this; }\n-  OptimizedEntryBlob* as_optimized_entry_blob() const             { assert(is_optimized_entry_blob(), \"must be entry blob\"); return (OptimizedEntryBlob*) this; }\n+  nmethod* as_nmethod_or_null()                       { return is_nmethod() ? (nmethod*) this : NULL; }\n+  nmethod* as_nmethod()                               { assert(is_nmethod(), \"must be nmethod\"); return (nmethod*) this; }\n+  CompiledMethod* as_compiled_method_or_null()        { return is_compiled() ? (CompiledMethod*) this : NULL; }\n+  CompiledMethod* as_compiled_method()                { assert(is_compiled(), \"must be compiled\"); return (CompiledMethod*) this; }\n+  CodeBlob* as_codeblob_or_null() const               { return (CodeBlob*) this; }\n+  OptimizedEntryBlob* as_optimized_entry_blob() const { assert(is_optimized_entry_blob(), \"must be entry blob\"); return (OptimizedEntryBlob*) this; }\n+  RuntimeStub* as_runtime_stub() const                { assert(is_runtime_stub(), \"must be runtime blob\"); return (RuntimeStub*) this; }\n@@ -524,0 +526,2 @@\n+  static void free(RuntimeStub* stub) { RuntimeBlob::free(stub); }\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -80,0 +80,10 @@\n+JNI_ENTRY(jboolean, NEP_freeInvoker(JNIEnv* env, jclass _unused, jlong invoker))\n+  \/\/ safe to call without code cache lock, because stub is always alive\n+  CodeBlob* cb = CodeCache::find_blob((char*) invoker);\n+  if (cb == nullptr) {\n+    return false;\n+  }\n+  RuntimeStub::free(cb->as_runtime_stub());\n+  return true;\n+JNI_END\n+\n@@ -88,0 +98,1 @@\n+  {CC \"freeInvoker0\", CC \"(J)Z\", FN_PTR(NEP_freeInvoker)},\n","filename":"src\/hotspot\/share\/prims\/nativeEntryPoint.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,3 +28,1 @@\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodType;\n-\n+import jdk.internal.foreign.abi.AbstractLinker;\n@@ -32,4 +30,0 @@\n-import jdk.internal.foreign.abi.aarch64.linux.LinuxAArch64Linker;\n-import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64Linker;\n-import jdk.internal.foreign.abi.x64.sysv.SysVx64Linker;\n-import jdk.internal.foreign.abi.x64.windows.Windowsx64Linker;\n@@ -40,0 +34,3 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+\n@@ -151,1 +148,1 @@\n-public sealed interface Linker permits Windowsx64Linker, SysVx64Linker, LinuxAArch64Linker, MacOsAArch64Linker {\n+public sealed interface Linker permits AbstractLinker {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi;\n+\n+import jdk.internal.foreign.SystemLookup;\n+import jdk.internal.foreign.abi.aarch64.linux.LinuxAArch64Linker;\n+import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64Linker;\n+import jdk.internal.foreign.abi.x64.sysv.SysVx64Linker;\n+import jdk.internal.foreign.abi.x64.windows.Windowsx64Linker;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.Objects;\n+\n+public abstract sealed class AbstractLinker implements Linker permits LinuxAArch64Linker, MacOsAArch64Linker,\n+                                                                      SysVx64Linker, Windowsx64Linker {\n+\n+    private final SoftReferenceCache<FunctionDescriptor, MethodHandle> DOWNCALL_CACHE = new SoftReferenceCache<>();\n+\n+    @Override\n+    public MethodHandle downcallHandle(FunctionDescriptor function) {\n+        Objects.requireNonNull(function);\n+\n+        return DOWNCALL_CACHE.get(function, fd -> {\n+            MethodType type = SharedUtils.inferMethodType(fd, false);\n+            MethodHandle handle = arrangeDowncall(type, fd);\n+            handle = SharedUtils.maybeInsertAllocator(handle);\n+            return handle;\n+        });\n+    }\n+    protected abstract MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function);\n+\n+    @Override\n+    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, MemorySession scope) {\n+        Objects.requireNonNull(scope);\n+        Objects.requireNonNull(target);\n+        Objects.requireNonNull(function);\n+        SharedUtils.checkExceptions(target);\n+\n+        MethodType type = SharedUtils.inferMethodType(function, true);\n+        if (!type.equals(target.type())) {\n+            throw new IllegalArgumentException(\"Wrong method handle type: \" + target.type());\n+        }\n+        return arrangeUpcall(target, target.type(), function, scope);\n+    }\n+\n+    protected abstract MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType,\n+                                                   FunctionDescriptor function, MemorySession scope);\n+\n+    @Override\n+    public SystemLookup defaultLookup() {\n+        return SystemLookup.getInstance();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -47,3 +47,0 @@\n-import static java.lang.invoke.MethodHandles.collectArguments;\n-import static java.lang.invoke.MethodHandles.filterArguments;\n-import static java.lang.invoke.MethodHandles.insertArguments;\n@@ -206,23 +203,0 @@\n-    private static final MethodHandle MH_UNBOX_ADDRESS;\n-    private static final MethodHandle MH_BOX_ADDRESS;\n-    private static final MethodHandle MH_COPY_BUFFER;\n-    private static final MethodHandle MH_ALLOCATE_BUFFER;\n-    private static final MethodHandle MH_TO_SEGMENT;\n-\n-    static {\n-        try {\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-            MH_UNBOX_ADDRESS = lookup.findVirtual(MemoryAddress.class, \"toRawLongValue\",\n-                    methodType(long.class));\n-            MH_BOX_ADDRESS = lookup.findStatic(MemoryAddress.class, \"ofLong\",\n-                    methodType(MemoryAddress.class, long.class));\n-            MH_COPY_BUFFER = lookup.findStatic(Binding.Copy.class, \"copyBuffer\",\n-                    methodType(MemorySegment.class, MemorySegment.class, long.class, long.class, Context.class));\n-            MH_ALLOCATE_BUFFER = lookup.findStatic(Binding.Allocate.class, \"allocateBuffer\",\n-                    methodType(MemorySegment.class, long.class, long.class, Context.class));\n-            MH_TO_SEGMENT = lookup.findStatic(Binding.ToSegment.class, \"toSegment\",\n-                    methodType(MemorySegment.class, MemoryAddress.class, long.class, Context.class));\n-        } catch (ReflectiveOperationException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n@@ -283,1 +257,1 @@\n-        public static Context ofScope() {\n+        public static Context ofSession() {\n@@ -341,2 +315,0 @@\n-    public abstract MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos);\n-\n@@ -548,5 +520,0 @@\n-        @Override\n-        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n-            return specializedHandle; \/\/ no-op\n-        }\n-\n@@ -583,5 +550,0 @@\n-        @Override\n-        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n-            return specializedHandle; \/\/ no-op\n-        }\n-\n@@ -641,2 +603,2 @@\n-     * Pops a MemorySegment from the operand stack, loads a [type] from\n-     * [offset into memory region] from it, and pushes it onto the operand stack.\n+     * Pops a [type] from the operand stack, then pops a MemorySegment from the operand stack.\n+     * Stores the [type] to [offset into memory region].\n@@ -667,7 +629,0 @@\n-        @Override\n-        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n-            MethodHandle setter = varHandle().toMethodHandle(VarHandle.AccessMode.SET);\n-            setter = setter.asType(methodType(void.class, MemorySegment.class, type()));\n-            return collectArguments(specializedHandle, insertPos + 1, setter);\n-        }\n-\n@@ -710,8 +665,0 @@\n-        @Override\n-        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n-            MethodHandle filter = varHandle()\n-                    .toMethodHandle(VarHandle.AccessMode.GET)\n-                    .asType(methodType(type(), MemorySegment.class));\n-            return filterArguments(specializedHandle, insertPos, filter);\n-        }\n-\n@@ -743,2 +690,1 @@\n-        private static MemorySegment copyBuffer(MemorySegment operand, long size, long alignment,\n-                                                    Context context) {\n+        private static MemorySegment copyBuffer(MemorySegment operand, long size, long alignment, Context context) {\n@@ -781,7 +727,0 @@\n-        @Override\n-        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n-            MethodHandle filter = insertArguments(MH_COPY_BUFFER, 1, size, alignment);\n-            specializedHandle = collectArguments(specializedHandle, insertPos, filter);\n-            return SharedUtils.mergeArguments(specializedHandle, allocatorPos, insertPos + 1);\n-        }\n-\n@@ -850,7 +789,0 @@\n-        @Override\n-        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n-            MethodHandle allocateBuffer = insertArguments(MH_ALLOCATE_BUFFER, 0, size, alignment);\n-            specializedHandle = collectArguments(specializedHandle, insertPos, allocateBuffer);\n-            return SharedUtils.mergeArguments(specializedHandle, allocatorPos, insertPos);\n-        }\n-\n@@ -913,6 +845,0 @@\n-        @Override\n-        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n-            return filterArguments(specializedHandle, insertPos,\n-                    MethodHandles.filterReturnValue(toAddress, MH_UNBOX_ADDRESS));\n-        }\n-\n@@ -949,5 +875,0 @@\n-        @Override\n-        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n-            return filterArguments(specializedHandle, insertPos, MH_BOX_ADDRESS);\n-        }\n-\n@@ -974,0 +895,4 @@\n+        public long size() {\n+            return size;\n+        }\n+\n@@ -993,7 +918,0 @@\n-        @Override\n-        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n-            MethodHandle toSegmentHandle = insertArguments(MH_TO_SEGMENT, 1, size);\n-            specializedHandle = collectArguments(specializedHandle, insertPos, toSegmentHandle);\n-            return SharedUtils.mergeArguments(specializedHandle, allocatorPos, insertPos + 1);\n-        }\n-\n@@ -1044,23 +962,0 @@\n-        \/*\n-         * Fixes up Y-shaped data graphs (produced by DEREFERENCE):\n-         *\n-         * 1. DUP()\n-         * 2. BUFFER_LOAD(0, int.class)\n-         * 3. VM_STORE  (ignored)\n-         * 4. BUFFER_LOAD(4, int.class)\n-         * 5. VM_STORE  (ignored)\n-         *\n-         * (specialized in reverse!)\n-         *\n-         * 5. (int, int) -> void                       insertPos = 1\n-         * 4. (MemorySegment, int) -> void             insertPos = 1\n-         * 3. (MemorySegment, int) -> void             insertPos = 0\n-         * 2. (MemorySegment, MemorySegment) -> void   insertPos = 0\n-         * 1. (MemorySegment) -> void                  insertPos = 0\n-         *\n-         *\/\n-        @Override\n-        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n-            return SharedUtils.mergeArguments(specializedHandle, insertPos, insertPos + 1);\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":8,"deletions":113,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -0,0 +1,976 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi;\n+\n+import jdk.internal.foreign.MemoryAddressImpl;\n+import jdk.internal.foreign.MemorySessionImpl;\n+import jdk.internal.foreign.Scoped;\n+import jdk.internal.misc.VM;\n+import jdk.internal.org.objectweb.asm.ClassReader;\n+import jdk.internal.org.objectweb.asm.ClassWriter;\n+import jdk.internal.org.objectweb.asm.ConstantDynamic;\n+import jdk.internal.org.objectweb.asm.Handle;\n+import jdk.internal.org.objectweb.asm.Label;\n+import jdk.internal.org.objectweb.asm.MethodVisitor;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+import jdk.internal.org.objectweb.asm.Type;\n+import jdk.internal.org.objectweb.asm.util.CheckClassAdapter;\n+import sun.security.action.GetBooleanAction;\n+import sun.security.action.GetPropertyAction;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.foreign.Addressable;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.function.BiPredicate;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.lang.invoke.MethodType.methodType;\n+import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+\n+public class BindingSpecializer {\n+    private static final String DUMP_CLASSES_DIR\n+        = GetPropertyAction.privilegedGetProperty(\"jdk.internal.foreign.abi.Specializer.DUMP_CLASSES_DIR\");\n+    private static final boolean PERFORM_VERIFICATION\n+        = GetBooleanAction.privilegedGetProperty(\"jdk.internal.foreign.abi.Specializer.PERFORM_VERIFICATION\");\n+\n+    \/\/ Bunch of helper constants\n+    private static final int CLASSFILE_VERSION = VM.classFileVersion();\n+\n+    private static final String OBJECT_DESC = Object.class.descriptorString();\n+    private static final String OBJECT_INTRN = Type.getInternalName(Object.class);\n+\n+    private static final String BINDING_CONTEXT_DESC = Binding.Context.class.descriptorString();\n+    private static final String OF_BOUNDED_ALLOCATOR_DESC = methodType(Binding.Context.class, long.class).descriptorString();\n+    private static final String OF_SESSION_DESC = methodType(Binding.Context.class).descriptorString();\n+    private static final String ALLOCATOR_DESC = methodType(SegmentAllocator.class).descriptorString();\n+    private static final String SESSION_DESC = methodType(MemorySession.class).descriptorString();\n+    private static final String SESSION_IMPL_DESC = methodType(MemorySessionImpl.class).descriptorString();\n+    private static final String CLOSE_DESC = methodType(void.class).descriptorString();\n+    private static final String ADDRESS_DESC = methodType(MemoryAddress.class).descriptorString();\n+    private static final String COPY_DESC = methodType(void.class, MemorySegment.class, long.class, MemorySegment.class, long.class, long.class).descriptorString();\n+    private static final String TO_RAW_LONG_VALUE_DESC = methodType(long.class).descriptorString();\n+    private static final String OF_LONG_DESC = methodType(MemoryAddress.class, long.class).descriptorString();\n+    private static final String OF_LONG_UNCHECKED_DESC = methodType(MemorySegment.class, long.class, long.class, MemorySession.class).descriptorString();\n+    private static final String ALLOCATE_DESC = methodType(MemorySegment.class, long.class, long.class).descriptorString();\n+    private static final String HANDLE_UNCAUGHT_EXCEPTION_DESC = methodType(void.class, Throwable.class).descriptorString();\n+    private static final String METHOD_HANDLES_INTRN = Type.getInternalName(MethodHandles.class);\n+    private static final String CLASS_DATA_DESC = methodType(Object.class, MethodHandles.Lookup.class, String.class, Class.class).descriptorString();\n+    private static final String RELEASE0_DESC = methodType(void.class).descriptorString();\n+    private static final String ACQUIRE0_DESC = methodType(void.class).descriptorString();\n+\n+    private static final Handle BSM_CLASS_DATA = new Handle(\n+            H_INVOKESTATIC,\n+            METHOD_HANDLES_INTRN,\n+            \"classData\",\n+            CLASS_DATA_DESC,\n+            false);\n+    private static final ConstantDynamic CLASS_DATA_CONDY = new ConstantDynamic(\n+            ConstantDescs.DEFAULT_NAME,\n+            OBJECT_DESC,\n+            BSM_CLASS_DATA);\n+\n+    private static final String CLASS_NAME_DOWNCALL = \"jdk\/internal\/foreign\/abi\/DowncallStub\";\n+    private static final String CLASS_NAME_UPCALL = \"jdk\/internal\/foreign\/abi\/UpcallStub\";\n+    private static final String METHOD_NAME = \"invoke\";\n+\n+    private static final String SUPER_NAME = OBJECT_INTRN;\n+\n+    private static final SoftReferenceCache<FunctionDescriptor, MethodHandle> UPCALL_WRAPPER_CACHE = new SoftReferenceCache<>();\n+\n+    \/\/ Instance fields start here\n+    private final MethodVisitor mv;\n+    private final MethodType callerMethodType;\n+    private final CallingSequence callingSequence;\n+    private final ABIDescriptor abi;\n+    private final MethodType leafType;\n+\n+    private int localIdx = 0;\n+    private int[] paramIndex2ParamSlot;\n+    private int[] leafArgSlots;\n+    private int[] scopeSlots;\n+    private int curScopeLocalIdx = -1;\n+    private int RETURN_ALLOCATOR_IDX = -1;\n+    private int CONTEXT_IDX = -1;\n+    private int RETURN_BUFFER_IDX = -1;\n+    private int RET_VAL_IDX = -1;\n+    private Deque<Class<?>> typeStack;\n+    private List<Class<?>> leafArgTypes;\n+    private int paramIndex;\n+    private long retBufOffset; \/\/ for needsReturnBuffer\n+\n+    private BindingSpecializer(MethodVisitor mv, MethodType callerMethodType, CallingSequence callingSequence, ABIDescriptor abi, MethodType leafType) {\n+        this.mv = mv;\n+        this.callerMethodType = callerMethodType;\n+        this.callingSequence = callingSequence;\n+        this.abi = abi;\n+        this.leafType = leafType;\n+    }\n+\n+    static MethodHandle specialize(MethodHandle leafHandle, CallingSequence callingSequence, ABIDescriptor abi) {\n+        if (callingSequence.forUpcall()) {\n+            MethodHandle wrapper = UPCALL_WRAPPER_CACHE.get(callingSequence.functionDesc(), fd -> doSpecialize(leafHandle, callingSequence, abi));\n+            return MethodHandles.insertArguments(wrapper, 0, leafHandle); \/\/ lazily customized for leaf handle instances\n+        } else {\n+            return doSpecialize(leafHandle, callingSequence, abi);\n+        }\n+    }\n+\n+    static MethodHandle doSpecialize(MethodHandle leafHandle, CallingSequence callingSequence, ABIDescriptor abi) {\n+        String className = callingSequence.forDowncall() ? CLASS_NAME_DOWNCALL : CLASS_NAME_UPCALL;\n+        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);\n+        cw.visit(CLASSFILE_VERSION, ACC_PUBLIC + ACC_FINAL + ACC_SUPER, className, null, SUPER_NAME, null);\n+\n+        MethodType callerMethodType = callingSequence.callerMethodType();\n+        if (callingSequence.forDowncall()) {\n+            if (callingSequence.needsReturnBuffer()) {\n+                callerMethodType = callerMethodType.dropParameterTypes(0, 1); \/\/ Return buffer does not appear in the parameter list\n+            }\n+            callerMethodType = callerMethodType.insertParameterTypes(0, SegmentAllocator.class);\n+        } else { \/\/ upcall\n+            callerMethodType = callerMethodType.insertParameterTypes(0, MethodHandle.class); \/\/ target\n+        }\n+        String descriptor = callerMethodType.descriptorString();\n+        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, METHOD_NAME, descriptor, null, null);\n+\n+        new BindingSpecializer(mv, callerMethodType, callingSequence, abi, leafHandle.type()).specialize();\n+\n+        mv.visitMaxs(0, 0);\n+        mv.visitEnd();\n+\n+        cw.visitEnd();\n+\n+        byte[] bytes = cw.toByteArray();\n+        if (DUMP_CLASSES_DIR != null) {\n+            String fileName = className + escapeForFileName(callingSequence.functionDesc().toString()) + \".class\";\n+            Path dumpPath = Path.of(DUMP_CLASSES_DIR).resolve(fileName);\n+            try {\n+                Files.createDirectories(dumpPath.getParent());\n+                Files.write(dumpPath, bytes);\n+            } catch (IOException e) {\n+                throw new InternalError(e);\n+            }\n+        }\n+\n+        if (PERFORM_VERIFICATION) {\n+            boolean printResults = false; \/\/ only print in case of exception\n+            CheckClassAdapter.verify(new ClassReader(bytes), null, printResults, new PrintWriter(System.err));\n+        }\n+\n+        try {\n+            MethodHandles.Lookup defineClassLookup = callingSequence.forUpcall()\n+                \/\/ For upcalls, we must initialize the class since the upcall stubs don't have a clinit barrier,\n+                \/\/ and the slow path in the c2i adapter we end up calling can not handle the particular code shape\n+                \/\/ where the caller is an upcall stub.\n+                ? MethodHandles.lookup().defineHiddenClass(bytes, true)\n+                : MethodHandles.lookup().defineHiddenClassWithClassData(bytes, leafHandle, false);\n+            return defineClassLookup.findStatic(defineClassLookup.lookupClass(), METHOD_NAME, callerMethodType);\n+        } catch (IllegalAccessException | NoSuchMethodException e) {\n+            throw new InternalError(\"Should not happen\", e);\n+        }\n+    }\n+\n+    private static String escapeForFileName(String str) {\n+        StringBuilder sb = new StringBuilder(str.length());\n+        for (int i = 0; i < str.length(); i++) {\n+            char c = str.charAt(i);\n+            sb.append(switch (c) {\n+                case ' ' -> '_';\n+                case '[', '<' -> '{';\n+                case ']', '>' -> '}';\n+                case '\/', '\\\\', ':', '*', '?', '\"', '|' -> '!'; \/\/ illegal in Windows file names.\n+                default -> c;\n+            });\n+        }\n+        return sb.toString();\n+    }\n+\n+    \/\/ binding operand stack manipulation\n+\n+    private void pushType(Class<?> type) {\n+        typeStack.push(type);\n+    }\n+\n+    private Class<?> popType(Class<?> expected) {\n+        return popType(expected, ASSERT_EQUALS);\n+    }\n+\n+    private Class<?> popType(Class<?> expected, BiPredicate<Class<?>, Class<?>> typePredicate) {\n+        Class<?> found;\n+        if (!typePredicate.test(expected, found = typeStack.pop())) {\n+            throw new IllegalStateException(\n+                    String.format(\"Invalid type on binding operand stack; found %s - expected %s\",\n+                            found.descriptorString(), expected.descriptorString()));\n+        }\n+        return found;\n+    }\n+\n+    private static final BiPredicate<Class<?>, Class<?>> ASSERT_EQUALS = Class::equals;\n+    private static final BiPredicate<Class<?>, Class<?>> ASSERT_ASSIGNABLE = Class::isAssignableFrom;\n+\n+    \/\/ specialization\n+\n+    private void specialize() {\n+        \/\/ map of parameter indexes to local var table slots\n+        paramIndex2ParamSlot = new int[callerMethodType.parameterCount()];\n+        for (int i = 0; i < callerMethodType.parameterCount(); i++) {\n+            paramIndex2ParamSlot[i] = newLocal(callerMethodType.parameterType(i));\n+        }\n+\n+        \/\/ slots that store the output arguments (passed to the leaf handle)\n+        leafArgSlots = new int[leafType.parameterCount()];\n+        for (int i = 0; i < leafType.parameterCount(); i++) {\n+            leafArgSlots[i] = newLocal(leafType.parameterType(i));\n+        }\n+\n+        \/\/ allocator passed to us for allocating the return MS (downcalls only)\n+        if (callingSequence.forDowncall()) {\n+            RETURN_ALLOCATOR_IDX = 0; \/\/ first param\n+\n+            \/\/ for downcalls we also acquire\/release scoped parameters before\/after the call\n+            \/\/ create a bunch of locals here to keep track of their scopes (to release later)\n+            int[] initialScopeSlots = new int[callerMethodType.parameterCount()];\n+            int numScopes = 0;\n+            for (int i = 0; i < callerMethodType.parameterCount(); i++) {\n+                if (shouldAcquire(callerMethodType.parameterType(i))) {\n+                    int scopeLocal = newLocal(BasicType.L);\n+                    initialScopeSlots[numScopes++] = scopeLocal;\n+                    emitConst(null);\n+                    emitStore(BasicType.L, scopeLocal); \/\/ need to initialize all scope locals here in case an exception occurs\n+                }\n+            }\n+            scopeSlots = Arrays.copyOf(initialScopeSlots, numScopes); \/\/ fit to size\n+            curScopeLocalIdx = 0; \/\/ used from emitGetInput\n+        }\n+\n+        \/\/ create a Binding.Context for this call\n+        if (callingSequence.allocationSize() != 0) {\n+            emitConst(callingSequence.allocationSize());\n+            emitInvokeStatic(Binding.Context.class, \"ofBoundedAllocator\", OF_BOUNDED_ALLOCATOR_DESC);\n+        } else if (callingSequence.forDowncall()) {\n+            emitGetStatic(Binding.Context.class, \"DUMMY\", BINDING_CONTEXT_DESC);\n+        } else {\n+            emitInvokeStatic(Binding.Context.class, \"ofSession\", OF_SESSION_DESC);\n+        }\n+        CONTEXT_IDX = newLocal(BasicType.L);\n+        emitStore(BasicType.L, CONTEXT_IDX);\n+\n+        \/\/ in case the call needs a return buffer, allocate it here.\n+        \/\/ for upcalls the VM wrapper stub allocates the buffer.\n+        if (callingSequence.needsReturnBuffer() && callingSequence.forDowncall()) {\n+            emitLoadInternalAllocator();\n+            emitAllocateCall(callingSequence.returnBufferSize(), 1);\n+            RETURN_BUFFER_IDX = newLocal(BasicType.L);\n+            emitStore(BasicType.L, RETURN_BUFFER_IDX);\n+        }\n+\n+        Label tryStart = new Label();\n+        Label tryEnd = new Label();\n+        Label catchStart = new Label();\n+\n+        mv.visitLabel(tryStart);\n+\n+        \/\/ stack to keep track of types on the bytecode stack between bindings.\n+        \/\/ this is needed to e.g. emit the right DUP instruction,\n+        \/\/ but also used for type checking.\n+        typeStack = new ArrayDeque<>();\n+        \/\/ leaf arg types are the types of the args passed to the leaf handle.\n+        \/\/ these are collected from VM_STORE instructions for downcalls, and\n+        \/\/ recipe outputs for upcalls (see uses emitSetOutput for both)\n+        leafArgTypes = new ArrayList<>();\n+        paramIndex = 1; \/\/ +1 to skip SegmentAllocator or MethodHandle\n+        for (int i = 0; i < callingSequence.argumentBindingsCount(); i++) {\n+            if (callingSequence.forDowncall()) {\n+                \/\/ for downcalls, recipes have an input value, which we set up here\n+                if (callingSequence.needsReturnBuffer() && i == 0) {\n+                    assert RETURN_BUFFER_IDX != -1;\n+                    emitLoad(BasicType.L, RETURN_BUFFER_IDX);\n+                    pushType(MemorySegment.class);\n+                } else {\n+                    emitGetInput();\n+                }\n+            }\n+\n+            \/\/ emit code according to binding recipe\n+            doBindings(callingSequence.argumentBindings(i));\n+\n+            if (callingSequence.forUpcall()) {\n+                \/\/ for upcalls, recipes have a result, which we handle here\n+                if (callingSequence.needsReturnBuffer() && i == 0) {\n+                    \/\/ return buffer ptr is wrapped in a MemorySegment above, but not passed to the leaf handle\n+                    popType(MemorySegment.class);\n+                    RETURN_BUFFER_IDX = newLocal(BasicType.L);\n+                    emitStore(BasicType.L, RETURN_BUFFER_IDX);\n+                } else {\n+                    \/\/ for upcalls the recipe result is an argument to the leaf handle\n+                    emitSetOutput(typeStack.pop());\n+                }\n+            }\n+            assert typeStack.isEmpty();\n+        }\n+\n+        assert leafArgTypes.equals(leafType.parameterList());\n+\n+        \/\/ load the leaf MethodHandle\n+        if (callingSequence.forDowncall()) {\n+            mv.visitLdcInsn(CLASS_DATA_CONDY);\n+        } else {\n+            emitLoad(BasicType.L, 0); \/\/ load target arg\n+        }\n+        emitCheckCast(MethodHandle.class);\n+        \/\/ load all the leaf args\n+        for (int i = 0; i < leafArgSlots.length; i++) {\n+            emitLoad(leafArgTypes.get(i), leafArgSlots[i]);\n+        }\n+        \/\/ call leaf MH\n+        emitInvokeVirtual(MethodHandle.class, \"invokeExact\", leafType.descriptorString());\n+\n+        \/\/ for downcalls, store the result of the leaf handle call away, until\n+        \/\/ it is requested by a VM_LOAD in the return recipe.\n+        if (callingSequence.forDowncall() && leafType.returnType() != void.class) {\n+            emitSaveReturnValue(leafType.returnType());\n+        }\n+        \/\/ for upcalls we leave the return value on the stack to be picked up\n+        \/\/ as an input of the return recipe.\n+\n+        \/\/ return value processing\n+        if (callingSequence.hasReturnBindings()) {\n+            if (callingSequence.forUpcall()) {\n+                pushType(leafType.returnType());\n+            }\n+\n+            retBufOffset = 0; \/\/ offset for reading from return buffer\n+            doBindings(callingSequence.returnBindings());\n+\n+            if (callingSequence.forUpcall() && !callingSequence.needsReturnBuffer()) {\n+                \/\/ was VM_STOREd somewhere in the bindings\n+                emitRestoreReturnValue(callerMethodType.returnType());\n+            }\n+            mv.visitLabel(tryEnd);\n+            \/\/ finally\n+            emitCleanup();\n+\n+            if (callerMethodType.returnType() == void.class) {\n+                \/\/ The case for upcalls that return by return buffer\n+                assert typeStack.isEmpty();\n+                mv.visitInsn(RETURN);\n+            } else {\n+                popType(callerMethodType.returnType());\n+                assert typeStack.isEmpty();\n+                emitReturn(callerMethodType.returnType());\n+            }\n+        } else {\n+            assert callerMethodType.returnType() == void.class;\n+            assert typeStack.isEmpty();\n+            mv.visitLabel(tryEnd);\n+            \/\/ finally\n+            emitCleanup();\n+            mv.visitInsn(RETURN);\n+        }\n+\n+        mv.visitLabel(catchStart);\n+        \/\/ finally\n+        emitCleanup();\n+        if (callingSequence.forDowncall()) {\n+            mv.visitInsn(ATHROW);\n+        } else {\n+           emitInvokeStatic(SharedUtils.class, \"handleUncaughtException\", HANDLE_UNCAUGHT_EXCEPTION_DESC);\n+           if (callerMethodType.returnType() != void.class) {\n+               emitConstZero(callerMethodType.returnType());\n+               emitReturn(callerMethodType.returnType());\n+           } else {\n+               mv.visitInsn(RETURN);\n+           }\n+        }\n+\n+        mv.visitTryCatchBlock(tryStart, tryEnd, catchStart, null);\n+    }\n+\n+    private static boolean shouldAcquire(Class<?> type) {\n+        return type == Addressable.class;\n+    }\n+\n+    private void emitCleanup() {\n+        emitCloseContext();\n+        if (callingSequence.forDowncall()) {\n+            emitReleaseScopes();\n+        }\n+    }\n+\n+    private void doBindings(List<Binding> bindings) {\n+        for (Binding binding : bindings) {\n+            switch (binding.tag()) {\n+                case VM_STORE -> emitVMStore((Binding.VMStore) binding);\n+                case VM_LOAD -> emitVMLoad((Binding.VMLoad) binding);\n+                case BUFFER_STORE -> emitBufferStore((Binding.BufferStore) binding);\n+                case BUFFER_LOAD -> emitBufferLoad((Binding.BufferLoad) binding);\n+                case COPY_BUFFER -> emitCopyBuffer((Binding.Copy) binding);\n+                case ALLOC_BUFFER -> emitAllocBuffer((Binding.Allocate) binding);\n+                case BOX_ADDRESS -> emitBoxAddress();\n+                case UNBOX_ADDRESS -> emitUnboxAddress();\n+                case TO_SEGMENT -> emitToSegment((Binding.ToSegment) binding);\n+                case DUP -> emitDupBinding();\n+            }\n+        }\n+    }\n+\n+    private void emitSetOutput(Class<?> storeType) {\n+        emitStore(BasicType.of(storeType), leafArgSlots[leafArgTypes.size()]);\n+        leafArgTypes.add(storeType);\n+    }\n+\n+    private void emitGetInput() {\n+        Class<?> highLevelType = callerMethodType.parameterType(paramIndex);\n+        emitLoad(BasicType.of(highLevelType), paramIndex2ParamSlot[paramIndex]);\n+\n+        if (shouldAcquire(highLevelType)) {\n+            emitDup(BasicType.L);\n+            emitAcquireScope();\n+        }\n+\n+        pushType(highLevelType);\n+        paramIndex++;\n+    }\n+\n+    private void emitAcquireScope() {\n+        emitCheckCast(Scoped.class);\n+        emitInvokeInterface(Scoped.class, \"sessionImpl\", SESSION_IMPL_DESC);\n+        Label skipAcquire = new Label();\n+        Label end = new Label();\n+\n+        \/\/ start with 1 scope to maybe acquire on the stack\n+        assert curScopeLocalIdx != -1;\n+        boolean hasOtherScopes = curScopeLocalIdx != 0;\n+        for (int i = 0; i < curScopeLocalIdx; i++) {\n+            emitDup(BasicType.L); \/\/ dup for comparison\n+            emitLoad(BasicType.L, scopeSlots[i]);\n+            mv.visitJumpInsn(IF_ACMPEQ, skipAcquire);\n+        }\n+\n+        \/\/ 1 scope to acquire on the stack\n+        emitDup(BasicType.L);\n+        int nextScopeLocal = scopeSlots[curScopeLocalIdx++];\n+        emitStore(BasicType.L, nextScopeLocal); \/\/ store off one to release later\n+        emitInvokeVirtual(MemorySessionImpl.class, \"acquire0\", ACQUIRE0_DESC); \/\/ call acquire on the other\n+\n+        if (hasOtherScopes) { \/\/ avoid ASM generating a bunch of nops for the dead code\n+            mv.visitJumpInsn(GOTO, end);\n+\n+            mv.visitLabel(skipAcquire);\n+            mv.visitInsn(POP); \/\/ drop scope\n+        }\n+\n+        mv.visitLabel(end);\n+    }\n+\n+    private void emitReleaseScopes() {\n+        for (int scopeLocal : scopeSlots) {\n+            Label skipRelease = new Label();\n+\n+            emitLoad(BasicType.L, scopeLocal);\n+            mv.visitJumpInsn(IFNULL, skipRelease);\n+            emitLoad(BasicType.L, scopeLocal);\n+            emitInvokeVirtual(MemorySessionImpl.class, \"release0\", RELEASE0_DESC);\n+            mv.visitLabel(skipRelease);\n+        }\n+    }\n+\n+    private void emitSaveReturnValue(Class<?> storeType) {\n+        RET_VAL_IDX = newLocal(BasicType.of(storeType));\n+        emitStore(BasicType.of(storeType), RET_VAL_IDX);\n+    }\n+\n+    private void emitRestoreReturnValue(Class<?> loadType) {\n+        assert RET_VAL_IDX != -1;\n+        emitLoad(BasicType.of(loadType), RET_VAL_IDX);\n+        pushType(loadType);\n+    }\n+\n+    private int newLocal(Class<?> type) {\n+        return newLocal(BasicType.of(type));\n+    }\n+\n+    private int newLocal(BasicType type) {\n+        int idx = localIdx;\n+        localIdx += (type == BasicType.D || type == BasicType.J) ? 2 : 1;\n+        return idx;\n+    }\n+\n+    private void emitLoadInternalSession() {\n+        assert CONTEXT_IDX != -1;\n+        emitLoad(BasicType.L, CONTEXT_IDX);\n+        emitInvokeVirtual(Binding.Context.class, \"session\", SESSION_DESC);\n+    }\n+\n+    private void emitLoadInternalAllocator() {\n+        assert CONTEXT_IDX != -1;\n+        emitLoad(BasicType.L, CONTEXT_IDX);\n+        emitInvokeVirtual(Binding.Context.class, \"allocator\", ALLOCATOR_DESC);\n+    }\n+\n+    private void emitCloseContext() {\n+        assert CONTEXT_IDX != -1;\n+        emitLoad(BasicType.L, CONTEXT_IDX);\n+        emitInvokeVirtual(Binding.Context.class, \"close\", CLOSE_DESC);\n+    }\n+\n+    private void emitToSegment(Binding.ToSegment binding) {\n+        long size = binding.size();\n+        popType(MemoryAddress.class);\n+\n+        emitToRawLongValue();\n+        emitConst(size);\n+        emitLoadInternalSession();\n+        emitInvokeStatic(MemoryAddressImpl.class, \"ofLongUnchecked\", OF_LONG_UNCHECKED_DESC);\n+\n+        pushType(MemorySegment.class);\n+    }\n+\n+    private void emitToRawLongValue() {\n+        emitInvokeInterface(MemoryAddress.class, \"toRawLongValue\", TO_RAW_LONG_VALUE_DESC);\n+    }\n+\n+    private void emitBoxAddress() {\n+        popType(long.class);\n+        emitInvokeStatic(MemoryAddress.class, \"ofLong\", OF_LONG_DESC);\n+        pushType(MemoryAddress.class);\n+    }\n+\n+    private void emitAllocBuffer(Binding.Allocate binding) {\n+        if (callingSequence.forDowncall()) {\n+            assert RETURN_ALLOCATOR_IDX != -1;\n+            emitLoad(BasicType.L, RETURN_ALLOCATOR_IDX);\n+        } else {\n+            emitLoadInternalAllocator();\n+        }\n+        emitAllocateCall(binding.size(), binding.alignment());\n+        pushType(MemorySegment.class);\n+    }\n+\n+    private void emitBufferStore(Binding.BufferStore bufferStore) {\n+        Class<?> storeType = bufferStore.type();\n+        long offset = bufferStore.offset();\n+\n+        popType(storeType);\n+        popType(MemorySegment.class);\n+        BasicType basicStoreType = BasicType.of(storeType);\n+        int valueIdx = newLocal(basicStoreType);\n+        emitStore(basicStoreType, valueIdx);\n+\n+        Class<?> valueLayoutType = emitLoadLayoutConstant(storeType);\n+        emitConst(offset);\n+        emitLoad(basicStoreType, valueIdx);\n+        String descriptor = methodType(void.class, valueLayoutType, long.class, storeType).descriptorString();\n+        emitInvokeInterface(MemorySegment.class, \"set\", descriptor);\n+    }\n+\n+\n+    \/\/ VM_STORE and VM_LOAD are emulated, which is different for down\/upcalls\n+    private void emitVMStore(Binding.VMStore vmStore) {\n+        Class<?> storeType = vmStore.type();\n+        popType(storeType);\n+\n+        if (callingSequence.forDowncall()) {\n+            \/\/ processing arg\n+            emitSetOutput(storeType);\n+        } else {\n+            \/\/ processing return\n+            if (!callingSequence.needsReturnBuffer()) {\n+                emitSaveReturnValue(storeType);\n+            } else {\n+                BasicType basicStoreType = BasicType.of(storeType);\n+                int valueIdx = newLocal(basicStoreType);\n+                emitStore(basicStoreType, valueIdx); \/\/ store away the stored value, need it later\n+\n+                assert RETURN_BUFFER_IDX != -1;\n+                emitLoad(BasicType.L, RETURN_BUFFER_IDX);\n+                Class<?> valueLayoutType = emitLoadLayoutConstant(storeType);\n+                emitConst(retBufOffset);\n+                emitLoad(basicStoreType, valueIdx);\n+                String descriptor = methodType(void.class, valueLayoutType, long.class, storeType).descriptorString();\n+                emitInvokeInterface(MemorySegment.class, \"set\", descriptor);\n+                retBufOffset += abi.arch.typeSize(vmStore.storage().type());\n+            }\n+        }\n+    }\n+\n+    private void emitVMLoad(Binding.VMLoad vmLoad) {\n+        Class<?> loadType = vmLoad.type();\n+\n+        if (callingSequence.forDowncall()) {\n+            \/\/ processing return\n+            if (!callingSequence.needsReturnBuffer()) {\n+                emitRestoreReturnValue(loadType);\n+            } else {\n+                assert RETURN_BUFFER_IDX != -1;\n+                emitLoad(BasicType.L, RETURN_BUFFER_IDX);\n+                Class<?> valueLayoutType = emitLoadLayoutConstant(loadType);\n+                emitConst(retBufOffset);\n+                String descriptor = methodType(loadType, valueLayoutType, long.class).descriptorString();\n+                emitInvokeInterface(MemorySegment.class, \"get\", descriptor);\n+                retBufOffset += abi.arch.typeSize(vmLoad.storage().type());\n+                pushType(loadType);\n+            }\n+        } else {\n+            \/\/ processing arg\n+            emitGetInput();\n+        }\n+    }\n+    private void emitDupBinding() {\n+        Class<?> dupType = typeStack.peek();\n+        emitDup(BasicType.of(dupType));\n+        pushType(dupType);\n+    }\n+\n+    private void emitUnboxAddress() {\n+        popType(Addressable.class, ASSERT_ASSIGNABLE);\n+        emitInvokeInterface(Addressable.class, \"address\", ADDRESS_DESC);\n+        emitToRawLongValue();\n+        pushType(long.class);\n+    }\n+\n+    private void emitBufferLoad(Binding.BufferLoad bufferLoad) {\n+        Class<?> loadType = bufferLoad.type();\n+        long offset = bufferLoad.offset();\n+\n+        popType(MemorySegment.class);\n+\n+        Class<?> valueLayoutType = emitLoadLayoutConstant(loadType);\n+        emitConst(offset);\n+        String descriptor = methodType(loadType, valueLayoutType, long.class).descriptorString();\n+        emitInvokeInterface(MemorySegment.class, \"get\", descriptor);\n+        pushType(loadType);\n+    }\n+\n+    private void emitCopyBuffer(Binding.Copy copy) {\n+        long size = copy.size();\n+        long alignment = copy.alignment();\n+\n+        popType(MemorySegment.class);\n+\n+        \/\/ operand\/srcSegment is on the stack\n+        \/\/ generating a call to:\n+        \/\/   MemorySegment::copy(MemorySegment srcSegment, long srcOffset, MemorySegment dstSegment, long dstOffset, long bytes)\n+        emitConst(0L);\n+        \/\/ create the dstSegment by allocating it. Similar to:\n+        \/\/   context.allocator().allocate(size, alignment)\n+        emitLoadInternalAllocator();\n+        emitAllocateCall(size, alignment);\n+        emitDup(BasicType.L);\n+        int storeIdx = newLocal(BasicType.L);\n+        emitStore(BasicType.L, storeIdx);\n+        emitConst(0L);\n+        emitConst(size);\n+        emitInvokeStatic(MemorySegment.class, \"copy\", COPY_DESC);\n+\n+        emitLoad(BasicType.L, storeIdx);\n+        pushType(MemorySegment.class);\n+    }\n+\n+    private void emitAllocateCall(long size, long alignment) {\n+        emitConst(size);\n+        emitConst(alignment);\n+        emitInvokeInterface(SegmentAllocator.class, \"allocate\", ALLOCATE_DESC);\n+    }\n+\n+    private Class<?> emitLoadLayoutConstant(Class<?> type) {\n+        Class<?> valueLayoutType = valueLayoutTypeFor(type);\n+        String valueLayoutConstantName = valueLayoutConstantFor(type);\n+        emitGetStatic(BindingSpecializer.class, valueLayoutConstantName, valueLayoutType.descriptorString());\n+        return valueLayoutType;\n+    }\n+\n+    private static String valueLayoutConstantFor(Class<?> type) {\n+        if (type == boolean.class) {\n+            return \"JAVA_BOOLEAN_UNALIGNED\";\n+        } else if (type == byte.class) {\n+            return \"JAVA_BYTE_UNALIGNED\";\n+        } else if (type == short.class) {\n+            return \"JAVA_SHORT_UNALIGNED\";\n+        } else if (type == char.class) {\n+            return \"JAVA_CHAR_UNALIGNED\";\n+        } else if (type == int.class) {\n+            return \"JAVA_INT_UNALIGNED\";\n+        } else if (type == long.class) {\n+            return \"JAVA_LONG_UNALIGNED\";\n+        } else if (type == float.class) {\n+            return \"JAVA_FLOAT_UNALIGNED\";\n+        } else if (type == double.class) {\n+            return \"JAVA_DOUBLE_UNALIGNED\";\n+        } else if (type == MemoryAddress.class) {\n+            return \"ADDRESS_UNALIGNED\";\n+        } else {\n+            throw new IllegalStateException(\"Unknown type: \" + type);\n+        }\n+    }\n+\n+    private static Class<?> valueLayoutTypeFor(Class<?> type) {\n+        if (type == boolean.class) {\n+            return ValueLayout.OfBoolean.class;\n+        } else if (type == byte.class) {\n+            return ValueLayout.OfByte.class;\n+        } else if (type == short.class) {\n+            return ValueLayout.OfShort.class;\n+        } else if (type == char.class) {\n+            return ValueLayout.OfChar.class;\n+        } else if (type == int.class) {\n+            return ValueLayout.OfInt.class;\n+        } else if (type == long.class) {\n+            return ValueLayout.OfLong.class;\n+        } else if (type == float.class) {\n+            return ValueLayout.OfFloat.class;\n+        } else if (type == double.class) {\n+            return ValueLayout.OfDouble.class;\n+        } else if (type == MemoryAddress.class) {\n+            return ValueLayout.OfAddress.class;\n+        } else {\n+            throw new IllegalStateException(\"Unknown type: \" + type);\n+        }\n+    }\n+\n+    private void emitInvokeStatic(Class<?> owner, String methodName, String descriptor) {\n+        mv.visitMethodInsn(INVOKESTATIC, Type.getInternalName(owner), methodName, descriptor, owner.isInterface());\n+    }\n+\n+    private void emitInvokeInterface(Class<?> owner, String methodName, String descriptor) {\n+        mv.visitMethodInsn(INVOKEINTERFACE, Type.getInternalName(owner), methodName, descriptor, true);\n+    }\n+\n+    private void emitInvokeVirtual(Class<?> owner, String methodName, String descriptor) {\n+        mv.visitMethodInsn(INVOKEVIRTUAL, Type.getInternalName(owner), methodName, descriptor, false);\n+    }\n+\n+    private void emitGetStatic(Class<?> owner, String fieldName, String descriptor) {\n+        mv.visitFieldInsn(GETSTATIC, Type.getInternalName(owner), fieldName, descriptor);\n+    }\n+\n+    private void emitCheckCast(Class<?> cls) {\n+        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(cls));\n+    }\n+\n+    private void emitDup(BasicType type) {\n+        if (type == BasicType.D || type == BasicType.J) {\n+            mv.visitInsn(DUP2);\n+        } else {\n+            mv.visitInsn(Opcodes.DUP);\n+        }\n+    }\n+\n+    \/*\n+     * Low-level emit helpers.\n+     *\/\n+\n+    private void emitConstZero(Class<?> type) {\n+        emitConst(switch (BasicType.of(type)) {\n+            case Z, B, S, C, I -> 0;\n+            case J -> 0L;\n+            case F -> 0F;\n+            case D -> 0D;\n+            case L -> null;\n+        });\n+    }\n+\n+    private void emitConst(Object con) {\n+        if (con == null) {\n+            mv.visitInsn(Opcodes.ACONST_NULL);\n+            return;\n+        }\n+        if (con instanceof Integer) {\n+            emitIconstInsn((int) con);\n+            return;\n+        }\n+        if (con instanceof Byte) {\n+            emitIconstInsn((byte)con);\n+            return;\n+        }\n+        if (con instanceof Short) {\n+            emitIconstInsn((short)con);\n+            return;\n+        }\n+        if (con instanceof Character) {\n+            emitIconstInsn((char)con);\n+            return;\n+        }\n+        if (con instanceof Long) {\n+            long x = (long) con;\n+            short sx = (short)x;\n+            if (x == sx) {\n+                if (sx >= 0 && sx <= 1) {\n+                    mv.visitInsn(Opcodes.LCONST_0 + (int) sx);\n+                } else {\n+                    emitIconstInsn((int) x);\n+                    mv.visitInsn(Opcodes.I2L);\n+                }\n+                return;\n+            }\n+        }\n+        if (con instanceof Float) {\n+            float x = (float) con;\n+            short sx = (short)x;\n+            if (x == sx) {\n+                if (sx >= 0 && sx <= 2) {\n+                    mv.visitInsn(Opcodes.FCONST_0 + (int) sx);\n+                } else {\n+                    emitIconstInsn((int) x);\n+                    mv.visitInsn(Opcodes.I2F);\n+                }\n+                return;\n+            }\n+        }\n+        if (con instanceof Double) {\n+            double x = (double) con;\n+            short sx = (short)x;\n+            if (x == sx) {\n+                if (sx >= 0 && sx <= 1) {\n+                    mv.visitInsn(Opcodes.DCONST_0 + (int) sx);\n+                } else {\n+                    emitIconstInsn((int) x);\n+                    mv.visitInsn(Opcodes.I2D);\n+                }\n+                return;\n+            }\n+        }\n+        if (con instanceof Boolean) {\n+            emitIconstInsn((boolean) con ? 1 : 0);\n+            return;\n+        }\n+        \/\/ fall through:\n+        mv.visitLdcInsn(con);\n+    }\n+\n+    private void emitIconstInsn(int cst) {\n+        if (cst >= -1 && cst <= 5) {\n+            mv.visitInsn(Opcodes.ICONST_0 + cst);\n+        } else if (cst >= Byte.MIN_VALUE && cst <= Byte.MAX_VALUE) {\n+            mv.visitIntInsn(Opcodes.BIPUSH, cst);\n+        } else if (cst >= Short.MIN_VALUE && cst <= Short.MAX_VALUE) {\n+            mv.visitIntInsn(Opcodes.SIPUSH, cst);\n+        } else {\n+            mv.visitLdcInsn(cst);\n+        }\n+    }\n+\n+    private void emitLoad(Class<?> type, int index) {\n+        emitLoad(BasicType.of(type), index);\n+    }\n+\n+    private void emitLoad(BasicType type, int index) {\n+        int opcode = loadOpcode(type);\n+        mv.visitVarInsn(opcode, index);\n+    }\n+\n+    private static int loadOpcode(BasicType type) throws InternalError {\n+        return switch (type) {\n+            case Z, B, S, C, I -> ILOAD;\n+            case J -> LLOAD;\n+            case F -> FLOAD;\n+            case D -> DLOAD;\n+            case L -> ALOAD;\n+        };\n+    }\n+\n+    private void emitStore(BasicType type, int index) {\n+        int opcode = storeOpcode(type);\n+        mv.visitVarInsn(opcode, index);\n+    }\n+\n+    private static int storeOpcode(BasicType type) throws InternalError {\n+        return switch (type) {\n+            case Z, B, S, C, I -> ISTORE;\n+            case J -> LSTORE;\n+            case F -> FSTORE;\n+            case D -> DSTORE;\n+            case L -> ASTORE;\n+        };\n+    }\n+\n+    private void emitReturn(Class<?> type) {\n+        int opcode = returnOpcode(BasicType.of(type));\n+        mv.visitInsn(opcode);\n+    }\n+\n+    private static int returnOpcode(BasicType type) {\n+       return switch (type) {\n+            case Z, B, S, C, I -> IRETURN;\n+            case J -> LRETURN;\n+            case F -> FRETURN;\n+            case D -> DRETURN;\n+            case L -> ARETURN;\n+        };\n+    }\n+\n+    private enum BasicType {\n+        Z, B, S, C, I, J, F, D, L;\n+\n+        static BasicType of(Class<?> cls) {\n+            if (cls == boolean.class) {\n+                return Z;\n+            } else if (cls == byte.class) {\n+                return B;\n+            } else if (cls == short.class) {\n+                return S;\n+            } else if (cls == char.class) {\n+                return C;\n+            } else if (cls == int.class) {\n+                return I;\n+            } else if (cls == long.class) {\n+                return J;\n+            } else if (cls == float.class) {\n+                return F;\n+            } else if (cls == double.class) {\n+                return D;\n+            } else {\n+                return L;\n+            }\n+        }\n+    }\n+\n+    \/\/ unaligned constants\n+    public final static ValueLayout.OfBoolean JAVA_BOOLEAN_UNALIGNED = JAVA_BOOLEAN;\n+    public final static ValueLayout.OfByte JAVA_BYTE_UNALIGNED = JAVA_BYTE;\n+    public final static ValueLayout.OfShort JAVA_SHORT_UNALIGNED = JAVA_SHORT.withBitAlignment(8);\n+    public final static ValueLayout.OfChar JAVA_CHAR_UNALIGNED = JAVA_CHAR.withBitAlignment(8);\n+    public final static ValueLayout.OfInt JAVA_INT_UNALIGNED = JAVA_INT.withBitAlignment(8);\n+    public final static ValueLayout.OfLong JAVA_LONG_UNALIGNED = JAVA_LONG.withBitAlignment(8);\n+    public final static ValueLayout.OfFloat JAVA_FLOAT_UNALIGNED = JAVA_FLOAT.withBitAlignment(8);\n+    public final static ValueLayout.OfDouble JAVA_DOUBLE_UNALIGNED = JAVA_DOUBLE.withBitAlignment(8);\n+    public final static ValueLayout.OfAddress ADDRESS_UNALIGNED = ADDRESS.withBitAlignment(8);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":976,"deletions":0,"binary":false,"changes":976,"status":"added"},{"patch":"@@ -34,1 +34,3 @@\n-    private final MethodType mt;\n+    private final boolean forUpcall;\n+    private final MethodType callerMethodType;\n+    private final MethodType calleeMethodType;\n@@ -43,1 +45,1 @@\n-    public CallingSequence(MethodType mt, FunctionDescriptor desc,\n+    public CallingSequence(boolean forUpcall, MethodType callerMethodType, MethodType calleeMethodType, FunctionDescriptor desc,\n@@ -46,1 +48,3 @@\n-        this.mt = mt;\n+        this.forUpcall = forUpcall;\n+        this.callerMethodType = callerMethodType;\n+        this.calleeMethodType = calleeMethodType;\n@@ -55,1 +59,15 @@\n-    public int argumentCount() {\n+    \/**\n+     * An important distinction is that downcalls have 1 recipe per caller parameter and\n+     * each callee parameter corresponds to a VM_STORE. Upcalls have 1 recipe per callee parameter and\n+     * each caller parameter corresponds to a VM_LOAD.\n+     *\n+     * The VM_STOREs are then implemented by the leaf handle for downcalls, and vice versa, the wrapper\n+     * stub that wraps an upcall handle implements the VM_LOADS. In both cases the register values are\n+     * communicated through Java primitives.\n+     *\n+     * The 'argumentBindingsCount' below corresponds to the number of recipes, so it is the\n+     * caller parameter count for downcalls, and the callee parameter count for upcalls.\n+     *\n+     * @return the number of binding recipes in this calling sequence\n+     *\/\n+    public int argumentBindingsCount() {\n@@ -71,2 +89,3 @@\n-    public String asString() {\n-        StringBuilder sb = new StringBuilder();\n+    public boolean forUpcall() {\n+        return forUpcall;\n+    }\n@@ -74,11 +93,3 @@\n-        sb.append(\"CallingSequence: {\\n\");\n-        sb.append(\"  MethodType: \").append(mt);\n-        sb.append(\"  FunctionDescriptor: \").append(desc);\n-        sb.append(\"  Argument Bindings:\\n\");\n-        for (int i = 0; i < mt.parameterCount(); i++) {\n-            sb.append(\"    \").append(i).append(\": \").append(argumentBindings.get(i)).append(\"\\n\");\n-        }\n-        if (mt.returnType() != void.class) {\n-            sb.append(\"    \").append(\"Return: \").append(returnBindings).append(\"\\n\");\n-        }\n-        sb.append(\"}\\n\");\n+    public boolean forDowncall() {\n+        return !forUpcall;\n+    }\n@@ -86,1 +97,14 @@\n-        return sb.toString();\n+    \/**\n+     * Returns the caller method type, which is the high-level method type\n+     * for downcalls (the type of the downcall method handle)\n+     * and the low-level method type (all primitives, VM facing) for upcalls.\n+     *\n+     * Note that for downcalls a single parameter in this method type corresponds\n+     * to a single argument binding recipe in this calling sequence, but it may\n+     * correspond to multiple parameters in the callee method type (for instance\n+     * if a struct is split into multiple register values).\n+     *\n+     * @return the caller method type.\n+     *\/\n+    public MethodType callerMethodType() {\n+        return callerMethodType;\n@@ -89,2 +113,14 @@\n-    public MethodType methodType() {\n-        return mt;\n+    \/**\n+     * Returns the callee method type, which is the low-level method type\n+     * (all primitives, VM facing) for downcalls and the high-level method type\n+     * for upcalls (also the method type of the user-supplied target MH).\n+     *\n+     * Note that for upcalls a single parameter in this method type corresponds\n+     * to a single argument binding recipe in this calling sequence, but it may\n+     * correspond to multiple parameters in the caller method type (for instance\n+     * if a struct is reconstructed from multiple register values).\n+     *\n+     * @return the callee method type.\n+     *\/\n+    public MethodType calleeMethodType() {\n+        return calleeMethodType;\n@@ -97,0 +133,21 @@\n+    \/**\n+     * Whether this calling sequence needs a return buffer.\n+     *\n+     * A return buffer is used to support functions that  return values\n+     * in multiple registers, which is not possible to do just with Java primitives\n+     * (we can only return 1 value in Java, meaning only 1 register value).\n+     *\n+     * To emulate these multi-register returns, we instead use a pre-allocated buffer\n+     * (the return buffer) from\/into which the return values are loaded\/stored.\n+     *\n+     * For downcalls, we allocate the buffer in Java code, and pass the address down\n+     * to the VM stub, which stores the returned register values into this buffer.\n+     * VM_LOADs in the binding recipe for the return value then load the value from this buffer.\n+     *\n+     * For upcalls, the VM stub allocates a buffer (on the stack), and passes the address\n+     * to the Java method handle it calls. VM_STOREs in the return binding recipe then\n+     * store values into this buffer, after which the VM stub moves the values from the buffer\n+     * into the right register.\n+     *\n+     * @return whether this calling sequence needs a return buffer.\n+     *\/\n@@ -101,0 +158,7 @@\n+    \/**\n+     * The size of the return buffer, if one is needed.\n+     *\n+     * {@see #needsReturnBuffer}\n+     *\n+     * @return the return buffer size\n+     *\/\n@@ -105,0 +169,7 @@\n+    \/**\n+     * The amount of bytes this calling sequence needs to allocate during an invocation.\n+     *\n+     * Includes the return buffer size as well as space for any buffer copies in the recipes.\n+     *\n+     * @return the allocation size\n+     *\/\n@@ -108,0 +179,23 @@\n+\n+    public boolean hasReturnBindings() {\n+        return !returnBindings.isEmpty();\n+    }\n+\n+    public String asString() {\n+        StringBuilder sb = new StringBuilder();\n+\n+        sb.append(\"CallingSequence: {\\n\");\n+        sb.append(\"  callerMethodType: \").append(callerMethodType);\n+        sb.append(\"  calleeMethodType: \").append(calleeMethodType);\n+        sb.append(\"  FunctionDescriptor: \").append(desc);\n+        sb.append(\"  Argument Bindings:\\n\");\n+        for (int i = 0; i < argumentBindingsCount(); i++) {\n+            sb.append(\"    \").append(i).append(\": \").append(argumentBindings.get(i)).append(\"\\n\");\n+        }\n+        if (!returnBindings.isEmpty()) {\n+            sb.append(\"    \").append(\"Return: \").append(returnBindings).append(\"\\n\");\n+        }\n+        sb.append(\"}\\n\");\n+\n+        return sb.toString();\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequence.java","additions":114,"deletions":20,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import static java.lang.invoke.MethodType.methodType;\n@@ -95,0 +96,2 @@\n+        MethodType callerMethodType;\n+        MethodType calleeMethodType;\n@@ -104,5 +107,13 @@\n-        } else if (needsReturnBuffer) { \/\/ forUpcall == true\n-            addArgumentBinding(0, MemorySegment.class, ValueLayout.ADDRESS, List.of(\n-                Binding.vmLoad(abi.retBufAddrStorage(), long.class),\n-                Binding.boxAddress(),\n-                Binding.toSegment(returnBufferSize)));\n+\n+            callerMethodType = mt;\n+            calleeMethodType = computeCalleeTypeForDowncall();\n+        } else { \/\/ forUpcall == true\n+            if (needsReturnBuffer) {\n+                addArgumentBinding(0, MemorySegment.class, ValueLayout.ADDRESS, List.of(\n+                        Binding.vmLoad(abi.retBufAddrStorage(), long.class),\n+                        Binding.boxAddress(),\n+                        Binding.toSegment(returnBufferSize)));\n+            }\n+\n+            callerMethodType = computeCallerTypeForUpcall();\n+            calleeMethodType = mt;\n@@ -110,1 +121,28 @@\n-        return new CallingSequence(mt, desc, needsReturnBuffer, returnBufferSize, allocationSize, inputBindings, outputBindings);\n+        return new CallingSequence(forUpcall, callerMethodType, calleeMethodType, desc, needsReturnBuffer,\n+                returnBufferSize, allocationSize, inputBindings, outputBindings);\n+    }\n+\n+    private MethodType computeCallerTypeForUpcall() {\n+        return computeTypeHelper(Binding.VMLoad.class, Binding.VMStore.class);\n+    }\n+\n+    private MethodType computeCalleeTypeForDowncall() {\n+        return computeTypeHelper(Binding.VMStore.class, Binding.VMLoad.class);\n+    }\n+\n+    private MethodType computeTypeHelper(Class<? extends Binding.Move> inputVMClass,\n+                                         Class<? extends Binding.Move> outputVMClass) {\n+        Class<?>[] paramTypes = inputBindings.stream()\n+                .flatMap(List::stream)\n+                .filter(inputVMClass::isInstance)\n+                .map(inputVMClass::cast)\n+                .map(Binding.Move::type)\n+                .toArray(Class<?>[]::new);\n+\n+        Binding.Move[] retMoves = outputBindings.stream()\n+                .filter(outputVMClass::isInstance)\n+                .map(outputVMClass::cast)\n+                .toArray(Binding.Move[]::new);\n+        Class<?> returnType = retMoves.length == 1 ? retMoves[0].type() : void.class;\n+\n+        return methodType(returnType, paramTypes);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequenceBuilder.java","additions":44,"deletions":6,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.ref.CleanerFactory;\n+\n@@ -29,0 +31,1 @@\n+import java.lang.ref.Cleaner;\n@@ -31,2 +34,0 @@\n-import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n@@ -45,1 +46,2 @@\n-    private static final Map<CacheKey, Long> INVOKER_CACHE = new ConcurrentHashMap<>();\n+    private static final Cleaner CLEANER = CleanerFactory.cleaner();\n+    private static final SoftReferenceCache<CacheKey, NativeEntryPoint> INVOKER_CACHE = new SoftReferenceCache<>();\n@@ -66,4 +68,6 @@\n-        long invoker = INVOKER_CACHE.computeIfAbsent(key, k ->\n-            makeInvoker(methodType, abi, argMoves, returnMoves, needsReturnBuffer));\n-\n-        return new NativeEntryPoint(methodType, invoker);\n+        return INVOKER_CACHE.get(key, k -> {\n+            long invoker = makeInvoker(methodType, abi, argMoves, returnMoves, needsReturnBuffer);\n+            NativeEntryPoint nep = new NativeEntryPoint(methodType, invoker);\n+            CLEANER.register(nep, () -> freeInvoker(invoker));\n+            return nep;\n+        });\n@@ -76,0 +80,7 @@\n+    private static native boolean freeInvoker0(long invoker);\n+    private static void freeInvoker(long invoker) {\n+        if (!freeInvoker0(invoker)) {\n+            throw new InternalError(\"Could not free invoker\");\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/NativeEntryPoint.java","additions":18,"deletions":7,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -27,6 +27,0 @@\n-import java.lang.foreign.Addressable;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentAllocator;\n-import java.lang.foreign.ValueLayout;\n-\n@@ -37,0 +31,3 @@\n+import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n@@ -40,2 +37,0 @@\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n@@ -43,1 +38,0 @@\n-import java.util.List;\n@@ -48,1 +42,0 @@\n-import static java.lang.invoke.MethodHandles.dropArguments;\n@@ -66,2 +59,0 @@\n-    private static final MethodHandle MH_WRAP_ALLOCATOR;\n-    private static final MethodHandle MH_ALLOCATE_RETURN_BUFFER;\n@@ -69,1 +60,0 @@\n-\n@@ -77,2 +67,0 @@\n-            MH_WRAP_ALLOCATOR = lookup.findStatic(Binding.Context.class, \"ofAllocator\",\n-                    methodType(Binding.Context.class, SegmentAllocator.class));\n@@ -81,2 +69,0 @@\n-            MH_ALLOCATE_RETURN_BUFFER = lookup.findStatic(ProgrammableInvoker.class, \"allocateReturnBuffer\",\n-                    methodType(MemorySegment.class, Binding.Context.class, long.class));\n@@ -93,0 +79,1 @@\n+        assert callingSequence.forDowncall();\n@@ -98,2 +85,0 @@\n-        Class<?>[] argMoveTypes = Arrays.stream(argMoves).map(Binding.VMStore::type).toArray(Class<?>[]::new);\n-\n@@ -101,1 +86,0 @@\n-        Class<?> returnType = retMoves.length == 1 ? retMoves[0].type() : void.class;\n@@ -103,1 +87,1 @@\n-        MethodType leafType = methodType(returnType, argMoveTypes);\n+        MethodType leafType = callingSequence.calleeMethodType();\n@@ -115,1 +99,1 @@\n-            handle = specialize(handle);\n+            handle = BindingSpecializer.specialize(handle, callingSequence, abi);\n@@ -122,1 +106,1 @@\n-            MethodType interpType = callingSequence.methodType();\n+            MethodType interpType = callingSequence.callerMethodType();\n@@ -142,4 +126,0 @@\n-    private static MemorySegment allocateReturnBuffer(Binding.Context context, long size) {\n-        return context.allocator().allocate(size);\n-    }\n-\n@@ -175,91 +155,0 @@\n-    private MethodHandle specialize(MethodHandle leafHandle) {\n-        MethodType highLevelType = callingSequence.methodType();\n-\n-        int argInsertPos = 0;\n-        int argContextPos = 0;\n-\n-        MethodHandle specializedHandle = dropArguments(leafHandle, argContextPos, Binding.Context.class);\n-        for (int i = 0; i < highLevelType.parameterCount(); i++) {\n-            List<Binding> bindings = callingSequence.argumentBindings(i);\n-            argInsertPos += ((int) bindings.stream().filter(Binding.VMStore.class::isInstance).count()) + 1;\n-            \/\/ We interpret the bindings in reverse since we have to construct a MethodHandle from the bottom up\n-            for (int j = bindings.size() - 1; j >= 0; j--) {\n-                Binding binding = bindings.get(j);\n-                if (binding.tag() == Binding.Tag.VM_STORE) {\n-                    argInsertPos--;\n-                } else {\n-                    specializedHandle = binding.specialize(specializedHandle, argInsertPos, argContextPos);\n-                }\n-            }\n-        }\n-\n-        if (highLevelType.returnType() != void.class) {\n-            MethodHandle returnFilter = identity(highLevelType.returnType());\n-            int retBufPos = -1;\n-            long retBufReadOffset = -1;\n-            int retContextPos = 0;\n-            int retInsertPos = 1;\n-            if (callingSequence.needsReturnBuffer()) {\n-                retBufPos = 0;\n-                retBufReadOffset = callingSequence.returnBufferSize();\n-                retContextPos++;\n-                retInsertPos++;\n-                returnFilter = dropArguments(returnFilter, retBufPos, MemorySegment.class);\n-            }\n-            returnFilter = dropArguments(returnFilter, retContextPos, Binding.Context.class);\n-            List<Binding> bindings = callingSequence.returnBindings();\n-            for (int j = bindings.size() - 1; j >= 0; j--) {\n-                Binding binding = bindings.get(j);\n-                if (callingSequence.needsReturnBuffer() && binding.tag() == Binding.Tag.VM_LOAD) {\n-                    \/\/ spacial case this, since we need to update retBufReadOffset as well\n-                    Binding.VMLoad load = (Binding.VMLoad) binding;\n-                    ValueLayout layout = MemoryLayout.valueLayout(load.type(), ByteOrder.nativeOrder()).withBitAlignment(8);\n-                    \/\/ since we iterate the bindings in reverse, we have to compute the offset in reverse as well\n-                    retBufReadOffset -= abi.arch.typeSize(load.storage().type());\n-                    MethodHandle loadHandle = MethodHandles.insertCoordinates(MethodHandles.memorySegmentViewVarHandle(layout), 1, retBufReadOffset)\n-                            .toMethodHandle(VarHandle.AccessMode.GET);\n-\n-                    returnFilter = MethodHandles.collectArguments(returnFilter, retInsertPos, loadHandle);\n-                    assert returnFilter.type().parameterType(retInsertPos - 1) == MemorySegment.class;\n-                    assert returnFilter.type().parameterType(retInsertPos - 2) == MemorySegment.class;\n-                    returnFilter = SharedUtils.mergeArguments(returnFilter, retBufPos, retInsertPos);\n-                    \/\/ to (... MemorySegment, MemorySegment, <primitive>, ...)\n-                    \/\/ from (... MemorySegment, MemorySegment, ...)\n-                    retInsertPos -= 2; \/\/ set insert pos back to the first MS (later DUP binding will merge the 2 MS)\n-                } else {\n-                    returnFilter = binding.specialize(returnFilter, retInsertPos, retContextPos);\n-                    if (callingSequence.needsReturnBuffer() && binding.tag() == Binding.Tag.BUFFER_STORE) {\n-                        \/\/ from (... MemorySegment, ...)\n-                        \/\/ to (... MemorySegment, MemorySegment, <primitive>, ...)\n-                        retInsertPos += 2; \/\/ set insert pos to <primitive>\n-                        assert returnFilter.type().parameterType(retInsertPos - 1) == MemorySegment.class;\n-                        assert returnFilter.type().parameterType(retInsertPos - 2) == MemorySegment.class;\n-                    }\n-                }\n-            }\n-            \/\/ (R, Context (ret)) -> (MemorySegment?, Context (ret), MemorySegment?, Context (arg), ...)\n-            specializedHandle = MethodHandles.collectArguments(returnFilter, retInsertPos, specializedHandle);\n-            if (callingSequence.needsReturnBuffer()) {\n-                \/\/ (MemorySegment, Context (ret), Context (arg), MemorySegment,  ...) -> (MemorySegment, Context (ret), Context (arg), ...)\n-                specializedHandle = SharedUtils.mergeArguments(specializedHandle, retBufPos, retBufPos + 3);\n-\n-                \/\/ allocate the return buffer from the binding context, and then merge the 2 allocator args\n-                MethodHandle retBufAllocHandle = MethodHandles.insertArguments(MH_ALLOCATE_RETURN_BUFFER, 1, callingSequence.returnBufferSize());\n-                \/\/ (MemorySegment, Context (ret), Context (arg), ...) -> (Context (arg), Context (ret), Context (arg), ...)\n-                specializedHandle = MethodHandles.filterArguments(specializedHandle, retBufPos, retBufAllocHandle);\n-                \/\/ (Context (arg), Context (ret), Context (arg), ...) -> (Context (ret), Context (arg), ...)\n-                specializedHandle = SharedUtils.mergeArguments(specializedHandle, argContextPos + 1, retBufPos); \/\/ +1 to skip return context\n-            }\n-            \/\/ (Context (ret), Context (arg), ...) -> (SegmentAllocator, Context (arg), ...)\n-            specializedHandle = MethodHandles.filterArguments(specializedHandle, 0, MH_WRAP_ALLOCATOR);\n-        } else {\n-            specializedHandle = MethodHandles.dropArguments(specializedHandle, 0, SegmentAllocator.class);\n-        }\n-\n-        \/\/ now bind the internal context parameter\n-\n-        argContextPos++; \/\/ skip over the return SegmentAllocator (inserted by the above code)\n-        specializedHandle = SharedUtils.wrapWithAllocator(specializedHandle, argContextPos, callingSequence.allocationSize(), false);\n-        return specializedHandle;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java","additions":7,"deletions":118,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.foreign.MemoryLayout;\n@@ -33,1 +32,0 @@\n-import java.lang.foreign.ValueLayout;\n@@ -37,2 +35,0 @@\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n@@ -40,1 +36,0 @@\n-import java.util.List;\n@@ -45,1 +40,3 @@\n-import static java.lang.invoke.MethodHandles.*;\n+import static java.lang.invoke.MethodHandles.exactInvoker;\n+import static java.lang.invoke.MethodHandles.insertArguments;\n+import static java.lang.invoke.MethodHandles.lookup;\n@@ -47,1 +44,0 @@\n-import static jdk.internal.foreign.abi.SharedUtils.mergeArguments;\n@@ -69,0 +65,1 @@\n+        assert callingSequence.forUpcall();\n@@ -72,3 +69,1 @@\n-        Class<?> llReturn = retMoves.length == 1 ? retMoves[0].type() : void.class;\n-        Class<?>[] llParams = Arrays.stream(argMoves).map(Binding.Move::type).toArray(Class<?>[]::new);\n-        MethodType llType = methodType(llReturn, llParams);\n+        MethodType llType = callingSequence.callerMethodType();\n@@ -78,1 +73,1 @@\n-            doBindings = specializedBindingHandle(target, callingSequence, llReturn, abi);\n+            doBindings = BindingSpecializer.specialize(target, callingSequence, abi);\n@@ -83,1 +78,1 @@\n-            int spreaderCount = callingSequence.methodType().parameterCount();\n+            int spreaderCount = callingSequence.calleeMethodType().parameterCount();\n@@ -128,62 +123,0 @@\n-    private static MethodHandle specializedBindingHandle(MethodHandle target, CallingSequence callingSequence,\n-                                                         Class<?> llReturn, ABIDescriptor abi) {\n-        MethodType highLevelType = callingSequence.methodType();\n-\n-        MethodHandle specializedHandle = target; \/\/ initial\n-\n-        \/\/ we handle returns first since IMR adds an extra parameter that needs to be specialized as well\n-        if (llReturn != void.class || callingSequence.needsReturnBuffer()) {\n-            int retAllocatorPos = -1; \/\/ assumed not needed\n-            int retInsertPos;\n-            MethodHandle filter;\n-            if (callingSequence.needsReturnBuffer()) {\n-                retInsertPos = 1;\n-                filter = empty(methodType(void.class, MemorySegment.class));\n-            } else {\n-                retInsertPos = 0;\n-                filter = identity(llReturn);\n-            }\n-            long retBufWriteOffset = callingSequence.returnBufferSize();\n-            List<Binding> bindings = callingSequence.returnBindings();\n-            for (int j = bindings.size() - 1; j >= 0; j--) {\n-                Binding binding = bindings.get(j);\n-                if (callingSequence.needsReturnBuffer() && binding.tag() == Binding.Tag.VM_STORE) {\n-                    Binding.VMStore store = (Binding.VMStore) binding;\n-                    ValueLayout layout = MemoryLayout.valueLayout(store.type(), ByteOrder.nativeOrder()).withBitAlignment(8);\n-                    \/\/ since we iterate the bindings in reverse, we have to compute the offset in reverse as well\n-                    retBufWriteOffset -= abi.arch.typeSize(store.storage().type());\n-                    MethodHandle storeHandle = MethodHandles.insertCoordinates(MethodHandles.memorySegmentViewVarHandle(layout), 1, retBufWriteOffset)\n-                            .toMethodHandle(VarHandle.AccessMode.SET);\n-                    filter = collectArguments(filter, retInsertPos, storeHandle);\n-                    filter = mergeArguments(filter, retInsertPos - 1, retInsertPos);\n-                } else {\n-                    filter = binding.specialize(filter, retInsertPos, retAllocatorPos);\n-                }\n-            }\n-            specializedHandle = collectArguments(filter, retInsertPos, specializedHandle);\n-        }\n-\n-        int argAllocatorPos = 0;\n-        int argInsertPos = 1;\n-        specializedHandle = dropArguments(specializedHandle, argAllocatorPos, Binding.Context.class);\n-        for (int i = 0; i < highLevelType.parameterCount(); i++) {\n-            MethodHandle filter = identity(highLevelType.parameterType(i));\n-            int filterAllocatorPos = 0;\n-            int filterInsertPos = 1; \/\/ +1 for allocator\n-            filter = dropArguments(filter, filterAllocatorPos, Binding.Context.class);\n-\n-            List<Binding> bindings = callingSequence.argumentBindings(i);\n-            for (int j = bindings.size() - 1; j >= 0; j--) {\n-                Binding binding = bindings.get(j);\n-                filter = binding.specialize(filter, filterInsertPos, filterAllocatorPos);\n-            }\n-            specializedHandle = MethodHandles.collectArguments(specializedHandle, argInsertPos, filter);\n-            specializedHandle = mergeArguments(specializedHandle, argAllocatorPos, argInsertPos + filterAllocatorPos);\n-            argInsertPos += filter.type().parameterCount() - 1; \/\/ -1 for allocator\n-        }\n-\n-        specializedHandle = SharedUtils.wrapWithAllocator(specializedHandle, argAllocatorPos, callingSequence.allocationSize(), true);\n-\n-        return specializedHandle;\n-    }\n-\n@@ -200,1 +133,1 @@\n-                : Binding.Context.ofScope();\n+                : Binding.Context.ofSession();\n@@ -203,1 +136,1 @@\n-            Object[] highLevelArgs = new Object[invData.callingSequence.methodType().parameterCount()];\n+            Object[] highLevelArgs = new Object[invData.callingSequence.calleeMethodType().parameterCount()];\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler.java","additions":9,"deletions":76,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -27,0 +27,12 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.JavaLangInvokeAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.foreign.CABI;\n+import jdk.internal.foreign.MemoryAddressImpl;\n+import jdk.internal.foreign.MemorySessionImpl;\n+import jdk.internal.foreign.Scoped;\n+import jdk.internal.foreign.abi.aarch64.linux.LinuxAArch64Linker;\n+import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64Linker;\n+import jdk.internal.foreign.abi.x64.sysv.SysVx64Linker;\n+import jdk.internal.foreign.abi.x64.windows.Windowsx64Linker;\n+\n@@ -39,14 +51,0 @@\n-import jdk.internal.foreign.abi.aarch64.linux.LinuxAArch64Linker;\n-import jdk.internal.foreign.abi.x64.sysv.SysVx64Linker;\n-import jdk.internal.foreign.abi.x64.windows.Windowsx64Linker;\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.JavaLangInvokeAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.foreign.MemorySessionImpl;\n-import jdk.internal.foreign.Scoped;\n-import jdk.internal.foreign.CABI;\n-import jdk.internal.foreign.MemoryAddressImpl;\n-import jdk.internal.foreign.Utils;\n-import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64Linker;\n-import jdk.internal.vm.annotation.ForceInline;\n-\n@@ -59,1 +57,0 @@\n-import java.util.ArrayList;\n@@ -61,1 +58,0 @@\n-import java.util.List;\n@@ -65,1 +61,0 @@\n-import java.util.function.UnaryOperator;\n@@ -69,10 +64,2 @@\n-import static java.lang.invoke.MethodHandles.collectArguments;\n-import static java.lang.invoke.MethodHandles.constant;\n-import static java.lang.invoke.MethodHandles.dropArguments;\n-import static java.lang.invoke.MethodHandles.dropReturn;\n-import static java.lang.invoke.MethodHandles.empty;\n-import static java.lang.invoke.MethodHandles.foldArguments;\n-import static java.lang.invoke.MethodHandles.identity;\n-import static java.lang.invoke.MethodHandles.insertArguments;\n-import static java.lang.invoke.MethodHandles.permuteArguments;\n-import static java.lang.invoke.MethodHandles.tryFinally;\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.lang.invoke.MethodHandles.*;\n@@ -80,8 +67,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_BOOLEAN;\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n-import static java.lang.foreign.ValueLayout.JAVA_CHAR;\n-import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n-import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-import static java.lang.foreign.ValueLayout.JAVA_LONG;\n-import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n@@ -97,3 +76,0 @@\n-    private static final MethodHandle MH_MAKE_CONTEXT_NO_ALLOCATOR;\n-    private static final MethodHandle MH_MAKE_CONTEXT_BOUNDED_ALLOCATOR;\n-    private static final MethodHandle MH_CLOSE_CONTEXT;\n@@ -101,3 +77,0 @@\n-    private static final MethodHandle MH_HANDLE_UNCAUGHT_EXCEPTION;\n-    private static final MethodHandle ACQUIRE_MH;\n-    private static final MethodHandle RELEASE_MH;\n@@ -114,6 +87,0 @@\n-            MH_MAKE_CONTEXT_NO_ALLOCATOR = lookup.findStatic(Binding.Context.class, \"ofScope\",\n-                    methodType(Binding.Context.class));\n-            MH_MAKE_CONTEXT_BOUNDED_ALLOCATOR = lookup.findStatic(Binding.Context.class, \"ofBoundedAllocator\",\n-                    methodType(Binding.Context.class, long.class));\n-            MH_CLOSE_CONTEXT = lookup.findVirtual(Binding.Context.class, \"close\",\n-                    methodType(void.class));\n@@ -122,6 +89,0 @@\n-            MH_HANDLE_UNCAUGHT_EXCEPTION = lookup.findStatic(SharedUtils.class, \"handleUncaughtException\",\n-                    methodType(void.class, Throwable.class));\n-            ACQUIRE_MH = MethodHandles.lookup().findStatic(SharedUtils.class, \"acquire\",\n-                    MethodType.methodType(void.class, Scoped[].class));\n-            RELEASE_MH = MethodHandles.lookup().findStatic(SharedUtils.class, \"release\",\n-                    MethodType.methodType(void.class, Scoped[].class));\n@@ -238,0 +199,4 @@\n+        } else {\n+            \/\/ adjust return type so it matches the inferred type of the effective\n+            \/\/ function descriptor\n+            target = target.asType(target.type().changeReturnType(Addressable.class));\n@@ -352,180 +317,0 @@\n-    static MethodHandle wrapWithAllocator(MethodHandle specializedHandle,\n-                                          int allocatorPos, long allocationSize,\n-                                          boolean upcall) {\n-        \/\/ insert try-finally to close the NativeScope used for Binding.Copy\n-        MethodHandle closer;\n-        int insertPos;\n-        if (specializedHandle.type().returnType() == void.class) {\n-            if (!upcall) {\n-                closer = empty(methodType(void.class, Throwable.class)); \/\/ (Throwable) -> void\n-            } else {\n-                closer = MH_HANDLE_UNCAUGHT_EXCEPTION;\n-            }\n-            insertPos = 1;\n-        } else {\n-            closer = identity(specializedHandle.type().returnType()); \/\/ (V) -> V\n-            if (!upcall) {\n-                closer = dropArguments(closer, 0, Throwable.class); \/\/ (Throwable, V) -> V\n-            } else {\n-                closer = collectArguments(closer, 0, MH_HANDLE_UNCAUGHT_EXCEPTION); \/\/ (Throwable, V) -> V\n-            }\n-            insertPos = 2;\n-        }\n-\n-        \/\/ downcalls get the leading SegmentAllocator param as well\n-        if (!upcall) {\n-            closer = dropArguments(closer, insertPos++, SegmentAllocator.class); \/\/ (Throwable, V?, SegmentAllocator, Addressable) -> V\/void\n-        }\n-\n-        closer = collectArguments(closer, insertPos, MH_CLOSE_CONTEXT); \/\/ (Throwable, V?, SegmentAllocator?, BindingContext) -> V\/void\n-\n-        MethodHandle contextFactory;\n-\n-        if (allocationSize > 0) {\n-            contextFactory = MethodHandles.insertArguments(MH_MAKE_CONTEXT_BOUNDED_ALLOCATOR, 0, allocationSize);\n-        } else if (upcall) {\n-            contextFactory = MH_MAKE_CONTEXT_NO_ALLOCATOR;\n-        } else {\n-            \/\/ this path is probably never used now, since ProgrammableInvoker never calls this routine with bufferCopySize == 0\n-            contextFactory = constant(Binding.Context.class, Binding.Context.DUMMY);\n-        }\n-\n-        specializedHandle = tryFinally(specializedHandle, closer);\n-        specializedHandle = collectArguments(specializedHandle, allocatorPos, contextFactory);\n-        return specializedHandle;\n-    }\n-\n-    @ForceInline\n-    @SuppressWarnings(\"fallthrough\")\n-    public static void acquire(Scoped[] args) {\n-        MemorySessionImpl scope4 = null;\n-        MemorySessionImpl scope3 = null;\n-        MemorySessionImpl scope2 = null;\n-        MemorySessionImpl scope1 = null;\n-        MemorySessionImpl scope0 = null;\n-        switch (args.length) {\n-            default:\n-                \/\/ slow path, acquire all remaining addressable parameters in isolation\n-                for (int i = 5 ; i < args.length ; i++) {\n-                    acquire(args[i].sessionImpl());\n-                }\n-            \/\/ fast path, acquire only scopes not seen in other parameters\n-            case 5:\n-                scope4 = args[4].sessionImpl();\n-                acquire(scope4);\n-            case 4:\n-                scope3 = args[3].sessionImpl();\n-                if (scope3 != scope4)\n-                    acquire(scope3);\n-            case 3:\n-                scope2 = args[2].sessionImpl();\n-                if (scope2 != scope3 && scope2 != scope4)\n-                    acquire(scope2);\n-            case 2:\n-                scope1 = args[1].sessionImpl();\n-                if (scope1 != scope2 && scope1 != scope3 && scope1 != scope4)\n-                    acquire(scope1);\n-            case 1:\n-                scope0 = args[0].sessionImpl();\n-                if (scope0 != scope1 && scope0 != scope2 && scope0 != scope3 && scope0 != scope4)\n-                    acquire(scope0);\n-            case 0: break;\n-        }\n-    }\n-\n-    @ForceInline\n-    @SuppressWarnings(\"fallthrough\")\n-    public static void release(Scoped[] args) {\n-        MemorySessionImpl scope4 = null;\n-        MemorySessionImpl scope3 = null;\n-        MemorySessionImpl scope2 = null;\n-        MemorySessionImpl scope1 = null;\n-        MemorySessionImpl scope0 = null;\n-        switch (args.length) {\n-            default:\n-                \/\/ slow path, release all remaining addressable parameters in isolation\n-                for (int i = 5 ; i < args.length ; i++) {\n-                    release(args[i].sessionImpl());\n-                }\n-            \/\/ fast path, release only scopes not seen in other parameters\n-            case 5:\n-                scope4 = args[4].sessionImpl();\n-                release(scope4);\n-            case 4:\n-                scope3 = args[3].sessionImpl();\n-                if (scope3 != scope4)\n-                    release(scope3);\n-            case 3:\n-                scope2 = args[2].sessionImpl();\n-                if (scope2 != scope3 && scope2 != scope4)\n-                    release(scope2);\n-            case 2:\n-                scope1 = args[1].sessionImpl();\n-                if (scope1 != scope2 && scope1 != scope3 && scope1 != scope4)\n-                    release(scope1);\n-            case 1:\n-                scope0 = args[0].sessionImpl();\n-                if (scope0 != scope1 && scope0 != scope2 && scope0 != scope3 && scope0 != scope4)\n-                    release(scope0);\n-            case 0: break;\n-        }\n-    }\n-\n-    @ForceInline\n-    private static void acquire(MemorySessionImpl session) {\n-        session.acquire0();\n-    }\n-\n-    @ForceInline\n-    private static void release(MemorySessionImpl session) {\n-        session.release0();\n-    }\n-\n-    \/*\n-     * This method adds a try\/finally block to a downcall method handle, to make sure that all by-reference\n-     * parameters (including the target address of the native function) are kept alive for the duration of\n-     * the downcall.\n-     *\/\n-    public static MethodHandle wrapDowncall(MethodHandle downcallHandle, FunctionDescriptor descriptor) {\n-        boolean hasReturn = descriptor.returnLayout().isPresent();\n-        MethodHandle tryBlock = downcallHandle;\n-        MethodHandle cleanup = hasReturn ?\n-                MethodHandles.identity(downcallHandle.type().returnType()) :\n-                MethodHandles.empty(MethodType.methodType(void.class));\n-        int addressableCount = 0;\n-        List<UnaryOperator<MethodHandle>> adapters = new ArrayList<>();\n-        for (int i = 0 ; i < downcallHandle.type().parameterCount() ; i++) {\n-            Class<?> ptype = downcallHandle.type().parameterType(i);\n-            if (ptype == Addressable.class) {\n-                addressableCount++;\n-            } else {\n-                int pos = i;\n-                adapters.add(mh -> dropArguments(mh, pos, ptype));\n-            }\n-        }\n-\n-        if (addressableCount > 0) {\n-            cleanup = dropArguments(cleanup, 0, Throwable.class);\n-\n-            MethodType adapterType = MethodType.methodType(void.class);\n-            for (int i = 0 ; i < addressableCount ; i++) {\n-                adapterType = adapterType.appendParameterTypes(Addressable.class);\n-            }\n-\n-            MethodHandle acquireHandle = ACQUIRE_MH.asCollector(Scoped[].class, addressableCount).asType(adapterType);\n-            MethodHandle releaseHandle = RELEASE_MH.asCollector(Scoped[].class, addressableCount).asType(adapterType);\n-\n-            for (UnaryOperator<MethodHandle> adapter : adapters) {\n-                acquireHandle = adapter.apply(acquireHandle);\n-                releaseHandle = adapter.apply(releaseHandle);\n-            }\n-\n-            tryBlock = foldArguments(tryBlock, acquireHandle);\n-            cleanup = collectArguments(cleanup, hasReturn ? 2 : 1, releaseHandle);\n-\n-            return tryFinally(tryBlock, cleanup);\n-        } else {\n-            return downcallHandle;\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":18,"deletions":233,"binary":false,"changes":251,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi;\n+\n+import java.lang.ref.SoftReference;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+\n+class SoftReferenceCache<K, V> {\n+    private final Map<K, Node> cache = new ConcurrentHashMap<>();\n+\n+    public V get(K key, Function<K, V> valueFactory) {\n+        return cache\n+                .computeIfAbsent(key, k -> new Node()) \/\/ short lock (has to be according to ConcurrentHashMap)\n+                .get(key, valueFactory); \/\/ long lock, but just for the particular key\n+    }\n+\n+    private class Node {\n+        private SoftReference<V> ref;\n+\n+        public Node() {\n+        }\n+\n+        public V get(K key, Function<K, V> valueFactory) {\n+            V result;\n+            if (ref == null || (result = ref.get()) == null) {\n+                synchronized (this) { \/\/ don't let threads race on the valueFactory::apply call\n+                    if (ref == null || (result = ref.get()) == null) {\n+                        result = valueFactory.apply(key); \/\/ keep alive\n+                        ref = new SoftReference<>(result);\n+                    }\n+                }\n+            }\n+            return result;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SoftReferenceCache.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -28,1 +28,3 @@\n-import java.lang.foreign.Linker;\n+import jdk.internal.foreign.abi.AbstractLinker;\n+import jdk.internal.foreign.abi.aarch64.CallArranger;\n+\n@@ -34,5 +36,0 @@\n-\n-import jdk.internal.foreign.SystemLookup;\n-import jdk.internal.foreign.abi.SharedUtils;\n-import jdk.internal.foreign.abi.aarch64.CallArranger;\n-\n@@ -40,1 +37,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -42,2 +38,0 @@\n-import java.util.Objects;\n-import java.util.Optional;\n@@ -50,1 +44,1 @@\n-public final class LinuxAArch64Linker implements Linker {\n+public final class LinuxAArch64Linker extends AbstractLinker {\n@@ -53,2 +47,0 @@\n-    static final long ADDRESS_SIZE = 64; \/\/ bits\n-\n@@ -63,6 +55,2 @@\n-    public final MethodHandle downcallHandle(FunctionDescriptor function) {\n-        Objects.requireNonNull(function);\n-        MethodType type = SharedUtils.inferMethodType(function, false);\n-        MethodHandle handle = CallArranger.LINUX.arrangeDowncall(type, function);\n-        handle = SharedUtils.maybeInsertAllocator(handle);\n-        return SharedUtils.wrapDowncall(handle, function);\n+    protected MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function) {\n+        return CallArranger.LINUX.arrangeDowncall(inferredMethodType, function);\n@@ -72,10 +60,2 @@\n-    public final MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, MemorySession session) {\n-        Objects.requireNonNull(session);\n-        Objects.requireNonNull(target);\n-        Objects.requireNonNull(function);\n-        SharedUtils.checkExceptions(target);\n-        MethodType type = SharedUtils.inferMethodType(function, true);\n-        if (!type.equals(target.type())) {\n-            throw new IllegalArgumentException(\"Wrong method handle type: \" + target.type());\n-        }\n-        return CallArranger.LINUX.arrangeUpcall(target, target.type(), function, session);\n+    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, MemorySession scope) {\n+        return CallArranger.LINUX.arrangeUpcall(target, targetType, function, scope);\n@@ -97,5 +77,0 @@\n-\n-    @Override\n-    public SystemLookup defaultLookup() {\n-        return SystemLookup.getInstance();\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":8,"deletions":33,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -28,1 +28,3 @@\n-import java.lang.foreign.Linker;\n+import jdk.internal.foreign.abi.AbstractLinker;\n+import jdk.internal.foreign.abi.aarch64.CallArranger;\n+\n@@ -34,5 +36,0 @@\n-\n-import jdk.internal.foreign.SystemLookup;\n-import jdk.internal.foreign.abi.SharedUtils;\n-import jdk.internal.foreign.abi.aarch64.CallArranger;\n-\n@@ -40,1 +37,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -42,2 +38,0 @@\n-import java.util.Objects;\n-import java.util.Optional;\n@@ -50,1 +44,1 @@\n-public final class MacOsAArch64Linker implements Linker {\n+public final class MacOsAArch64Linker extends AbstractLinker {\n@@ -53,2 +47,0 @@\n-    static final long ADDRESS_SIZE = 64; \/\/ bits\n-\n@@ -63,6 +55,2 @@\n-    public final MethodHandle downcallHandle(FunctionDescriptor function) {\n-        Objects.requireNonNull(function);\n-        MethodType type = SharedUtils.inferMethodType(function, false);\n-        MethodHandle handle = CallArranger.MACOS.arrangeDowncall(type, function);\n-        handle = SharedUtils.maybeInsertAllocator(handle);\n-        return SharedUtils.wrapDowncall(handle, function);\n+    protected MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function) {\n+        return CallArranger.MACOS.arrangeDowncall(inferredMethodType, function);\n@@ -72,9 +60,2 @@\n-    public final MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, MemorySession session) {\n-        Objects.requireNonNull(session);\n-        Objects.requireNonNull(target);\n-        Objects.requireNonNull(function);\n-        MethodType type = SharedUtils.inferMethodType(function, true);\n-        if (!type.equals(target.type())) {\n-            throw new IllegalArgumentException(\"Wrong method handle type: \" + target.type());\n-        }\n-        return CallArranger.MACOS.arrangeUpcall(target, target.type(), function, session);\n+    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, MemorySession scope) {\n+        return CallArranger.MACOS.arrangeUpcall(target, targetType, function, scope);\n@@ -96,5 +77,0 @@\n-\n-    @Override\n-    public SystemLookup defaultLookup() {\n-        return SystemLookup.getInstance();\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":8,"deletions":32,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -60,0 +60,2 @@\n+    public static final int MAX_INTEGER_ARGUMENT_REGISTERS = 6;\n+    public static final int MAX_VECTOR_ARGUMENT_REGISTERS = 8;\n@@ -162,2 +164,2 @@\n-                    SysVx64Linker.MAX_INTEGER_ARGUMENT_REGISTERS :\n-                    SysVx64Linker.MAX_VECTOR_ARGUMENT_REGISTERS;\n+                    MAX_INTEGER_ARGUMENT_REGISTERS :\n+                    MAX_VECTOR_ARGUMENT_REGISTERS;\n@@ -191,1 +193,1 @@\n-            if (this.nIntegerReg + nIntegerReg > SysVx64Linker.MAX_INTEGER_ARGUMENT_REGISTERS) {\n+            if (this.nIntegerReg + nIntegerReg > MAX_INTEGER_ARGUMENT_REGISTERS) {\n@@ -198,1 +200,1 @@\n-            if (this.nVectorReg + nVectorReg > SysVx64Linker.MAX_VECTOR_ARGUMENT_REGISTERS) {\n+            if (this.nVectorReg + nVectorReg > MAX_VECTOR_ARGUMENT_REGISTERS) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n-import java.lang.foreign.Linker;\n+import jdk.internal.foreign.abi.AbstractLinker;\n+\n@@ -34,4 +35,0 @@\n-\n-import jdk.internal.foreign.SystemLookup;\n-import jdk.internal.foreign.abi.SharedUtils;\n-\n@@ -40,2 +37,0 @@\n-import java.util.Objects;\n-import java.util.Optional;\n@@ -47,7 +42,1 @@\n-public final class SysVx64Linker implements Linker {\n-    public static final int MAX_INTEGER_ARGUMENT_REGISTERS = 6;\n-    public static final int MAX_INTEGER_RETURN_REGISTERS = 2;\n-    public static final int MAX_VECTOR_ARGUMENT_REGISTERS = 8;\n-    public static final int MAX_VECTOR_RETURN_REGISTERS = 2;\n-    public static final int MAX_X87_RETURN_REGISTERS = 2;\n-\n+public final class SysVx64Linker extends AbstractLinker {\n@@ -56,2 +45,0 @@\n-    static final long ADDRESS_SIZE = 64; \/\/ bits\n-\n@@ -65,4 +52,3 @@\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, MemorySession session) {\n-        SysVVaList.Builder builder = SysVVaList.builder(session);\n-        actions.accept(builder);\n-        return builder.build();\n+    @Override\n+    protected MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function) {\n+        return CallArranger.arrangeDowncall(inferredMethodType, function);\n@@ -72,6 +58,2 @@\n-    public final MethodHandle downcallHandle(FunctionDescriptor function) {\n-        Objects.requireNonNull(function);\n-        MethodType type = SharedUtils.inferMethodType(function, false);\n-        MethodHandle handle = CallArranger.arrangeDowncall(type, function);\n-        handle = SharedUtils.maybeInsertAllocator(handle);\n-        return SharedUtils.wrapDowncall(handle, function);\n+    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, MemorySession scope) {\n+        return CallArranger.arrangeUpcall(target, targetType, function, scope);\n@@ -80,11 +62,4 @@\n-    @Override\n-    public final MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, MemorySession session) {\n-        Objects.requireNonNull(session);\n-        Objects.requireNonNull(target);\n-        Objects.requireNonNull(function);\n-        SharedUtils.checkExceptions(target);\n-        MethodType type = SharedUtils.inferMethodType(function, true);\n-        if (!type.equals(target.type())) {\n-            throw new IllegalArgumentException(\"Wrong method handle type: \" + target.type());\n-        }\n-        return CallArranger.arrangeUpcall(target, target.type(), function, session);\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, MemorySession scope) {\n+        SysVVaList.Builder builder = SysVVaList.builder(scope);\n+        actions.accept(builder);\n+        return builder.build();\n@@ -100,5 +75,0 @@\n-\n-    @Override\n-    public SystemLookup defaultLookup() {\n-        return SystemLookup.getInstance();\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":12,"deletions":42,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+    public static final int MAX_REGISTER_ARGUMENTS = 4;\n@@ -163,1 +164,1 @@\n-            if (nRegs >= Windowsx64Linker.MAX_REGISTER_ARGUMENTS) {\n+            if (nRegs >= MAX_REGISTER_ARGUMENTS) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n-import java.lang.foreign.Linker;\n+import jdk.internal.foreign.abi.AbstractLinker;\n+\n@@ -33,4 +34,0 @@\n-\n-import jdk.internal.foreign.SystemLookup;\n-import jdk.internal.foreign.abi.SharedUtils;\n-\n@@ -38,1 +35,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -40,2 +36,0 @@\n-import java.util.Objects;\n-import java.util.Optional;\n@@ -47,9 +41,1 @@\n-public final class Windowsx64Linker implements Linker {\n-\n-    public static final int MAX_INTEGER_ARGUMENT_REGISTERS = 4;\n-    public static final int MAX_INTEGER_RETURN_REGISTERS = 1;\n-    public static final int MAX_VECTOR_ARGUMENT_REGISTERS = 4;\n-    public static final int MAX_VECTOR_RETURN_REGISTERS = 1;\n-    public static final int MAX_REGISTER_ARGUMENTS = 4;\n-    public static final int MAX_REGISTER_RETURNS = 1;\n-\n+public final class Windowsx64Linker extends AbstractLinker {\n@@ -58,2 +44,0 @@\n-    static final long ADDRESS_SIZE = 64; \/\/ bits\n-\n@@ -67,4 +51,3 @@\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, MemorySession session) {\n-        WinVaList.Builder builder = WinVaList.builder(session);\n-        actions.accept(builder);\n-        return builder.build();\n+    @Override\n+    protected MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function) {\n+        return CallArranger.arrangeDowncall(inferredMethodType, function);\n@@ -74,6 +57,2 @@\n-    public final MethodHandle downcallHandle(FunctionDescriptor function) {\n-        Objects.requireNonNull(function);\n-        MethodType type = SharedUtils.inferMethodType(function, false);\n-        MethodHandle handle = CallArranger.arrangeDowncall(type, function);\n-        handle = SharedUtils.maybeInsertAllocator(handle);\n-        return SharedUtils.wrapDowncall(handle, function);\n+    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, MemorySession scope) {\n+        return CallArranger.arrangeUpcall(target, targetType, function, scope);\n@@ -82,11 +61,4 @@\n-    @Override\n-    public final MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, MemorySession session) {\n-        Objects.requireNonNull(session);\n-        Objects.requireNonNull(target);\n-        Objects.requireNonNull(function);\n-        SharedUtils.checkExceptions(target);\n-        MethodType type = SharedUtils.inferMethodType(function, true);\n-        if (!type.equals(target.type())) {\n-            throw new IllegalArgumentException(\"Wrong method handle type: \" + target.type());\n-        }\n-        return CallArranger.arrangeUpcall(target, target.type(), function, session);\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, MemorySession scope) {\n+        WinVaList.Builder builder = WinVaList.builder(scope);\n+        actions.accept(builder);\n+        return builder.build();\n@@ -102,5 +74,0 @@\n-\n-    @Override\n-    public SystemLookup defaultLookup() {\n-        return SystemLookup.getInstance();\n-    }\n@@ -108,0 +75,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":13,"deletions":45,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-        assertEquals(callingSequence.argumentCount(), argumentBindings.length);\n+        assertEquals(callingSequence.argumentBindingsCount(), argumentBindings.length);\n@@ -37,1 +37,1 @@\n-        for (int i = 0; i < callingSequence.argumentCount(); i++) {\n+        for (int i = 0; i < callingSequence.argumentBindingsCount(); i++) {\n","filename":"test\/jdk\/java\/foreign\/callarranger\/CallArrangerTestBase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -90,1 +90,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -120,1 +120,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -142,1 +142,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -202,1 +202,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -233,1 +233,1 @@\n-        assertEquals(callingSequence.methodType(), MethodType.methodType(void.class, Addressable.class, MemoryAddress.class));\n+        assertEquals(callingSequence.callerMethodType(), MethodType.methodType(void.class, Addressable.class, MemoryAddress.class));\n@@ -257,1 +257,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, MemorySegment.class, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class, Addressable.class));\n@@ -286,1 +286,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, MemorySegment.class, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class, Addressable.class));\n@@ -324,1 +324,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -378,1 +378,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -407,1 +407,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -430,1 +430,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestAarch64CallArranger.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import java.lang.foreign.Addressable;\n@@ -47,0 +46,1 @@\n+import java.lang.foreign.Addressable;\n@@ -67,1 +67,1 @@\n-        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n@@ -95,1 +95,1 @@\n-        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n@@ -126,1 +126,1 @@\n-        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n@@ -156,1 +156,1 @@\n-        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n@@ -186,1 +186,1 @@\n-        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n@@ -211,1 +211,1 @@\n-        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n@@ -242,1 +242,1 @@\n-        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n@@ -277,1 +277,1 @@\n-        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n@@ -334,1 +334,1 @@\n-        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n@@ -377,1 +377,1 @@\n-        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n@@ -399,1 +399,1 @@\n-        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n@@ -458,1 +458,1 @@\n-        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class, Addressable.class));\n@@ -490,1 +490,1 @@\n-        assertEquals(callingSequence.methodType(), MethodType.methodType(void.class, Addressable.class, MemoryAddress.class, long.class));\n+        assertEquals(callingSequence.callerMethodType(), MethodType.methodType(void.class, Addressable.class, MemoryAddress.class, long.class));\n@@ -514,1 +514,1 @@\n-        assertEquals(callingSequence.methodType(), mt);\n+        assertEquals(callingSequence.calleeMethodType(), mt);\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestSysVCallArranger.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -82,1 +82,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -104,1 +104,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -128,1 +128,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -159,1 +159,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -191,1 +191,1 @@\n-                ADDRESS, C_INT, C_DOUBLE, C_INT, C_DOUBLE, C_DOUBLE);\n+                ADDRESS, C_INT, C_DOUBLE,C_INT, C_DOUBLE, C_DOUBLE);\n@@ -196,1 +196,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -230,1 +230,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -260,1 +260,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -291,1 +291,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -312,1 +312,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -336,1 +336,1 @@\n-        assertEquals(callingSequence.methodType(), MethodType.methodType(void.class, Addressable.class, MemoryAddress.class));\n+        assertEquals(callingSequence.callerMethodType(), MethodType.methodType(void.class, Addressable.class, MemoryAddress.class));\n@@ -365,1 +365,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsCallArranger.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.invoke.MethodHandles.lookup;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n+public class LinkUpcall extends CLayouts {\n+\n+    static final Linker LINKER = Linker.nativeLinker();\n+    static final MethodHandle BLANK;\n+    static final FunctionDescriptor BLANK_DESC = FunctionDescriptor.ofVoid();\n+\n+    static {\n+        try {\n+            BLANK = lookup().findStatic(LinkUpcall.class, \"blank\", MethodType.methodType(void.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+\n+    @Benchmark\n+    public MemorySegment link_blank() {\n+        return LINKER.upcallStub(BLANK, BLANK_DESC, MemorySession.openImplicit());\n+    }\n+\n+    static void blank() {}\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LinkUpcall.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"}]}