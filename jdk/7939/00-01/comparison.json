{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -358,0 +358,47 @@\n+\/\/ Check immediate encoding for movi.\n+\/\/ Return the shift amount which can be {0, 8, 16, 24} for B\/H\/S types. As the D type\n+\/\/ movi does not have shift variant, in this case the return value is the immediate\n+\/\/ after encoding.\n+\/\/ Return -1 if the input imm64 can not be encoded.\n+int Assembler::operand_valid_for_movi_immediate(uint64_t imm64, SIMD_Arrangement T) {\n+  if (T == T1D || T == T2D) {\n+     \/\/ To encode into movi, the 64-bit imm must be in the form of\n+     \/\/ 'aaaaaaaabbbbbbbbccccccccddddddddeeeeeeeeffffffffgggggggghhhhhhhh'\n+     \/\/ and encoded in \"a:b:c:d:e:f:g:h\".\n+     uint64_t tmp = imm64;\n+     uint64_t one_byte = 0;\n+     for (int i = 0; i < 8; i++) {\n+       one_byte = tmp & 0xffULL;\n+       if (one_byte != 0xffULL && one_byte != 0) {\n+         return -1; \/\/ can not be encoded\n+       }\n+       tmp = tmp >> 8;\n+     }\n+\n+     imm64 &= 0x0101010101010101ULL;\n+     imm64 |= (imm64 >> 7);\n+     imm64 |= (imm64 >> 14);\n+     imm64 |= (imm64 >> 28);\n+\n+     return imm64 & 0xff;\n+  }\n+\n+  uint32_t imm32 = imm64 & 0xffffffffULL;\n+  if (T == T8B || T == T16B) {       \/\/ 8-bit variant\n+    if (0 == (imm32 & ~0xff))        return 0;\n+  } else if(T == T4H || T == T8H) {  \/\/ 16-bit variant\n+    if (0 == (imm32 & ~0xff))        return 0;\n+    if (0 == (imm32 & ~0xff00))      return 8;\n+  } else if (T == T2S || T == T4S) { \/\/ 32-bit variant\n+    if (0 == (imm32 & ~0xff))        return 0;\n+    if (0 == (imm32 & ~0xff00))      return 8;\n+    if (0 == (imm32 & ~0xff0000))    return 16;\n+    if (0 == (imm32 & ~0xff000000))  return 24;\n+  } else {\n+    assert(false, \"unsupported\");\n+    ShouldNotReachHere();\n+  }\n+\n+  return -1;\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":48,"deletions":1,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -3760,0 +3760,1 @@\n+  static int  operand_valid_for_movi_immediate(uint64_t imm64, SIMD_Arrangement T);\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1348,0 +1348,1 @@\n+  assert(T != T1Q, \"unsupported\");\n@@ -1349,22 +1350,2 @@\n-    \/\/ To encode into movi, the 64-bit imm must be in the form of\n-    \/\/ 'aaaaaaaabbbbbbbbccccccccddddddddeeeeeeeeffffffffgggggggghhhhhhhh'\n-    \/\/ and encoded in \"a:b:c:d:e:f:g:h\".\n-    bool can_encode = true;\n-    uint64_t tmp = imm64;\n-    uint64_t one_byte = 0;\n-    for (int i = 0; i < 8; i++) {\n-      one_byte = tmp & 0xFFULL;\n-      if (one_byte != 0xFFULL && one_byte != 0) {\n-        can_encode = false;\n-        break;\n-      }\n-      tmp = tmp >> 8;\n-    }\n-\n-    if(can_encode) {\n-      uint64_t imm = imm64;\n-      imm &= 0x0101010101010101ULL;\n-      imm |= (imm >> 7);\n-      imm |= (imm >> 14);\n-      imm |= (imm >> 28);\n-      imm &= 0xFFULL;\n+    int imm = operand_valid_for_movi_immediate(imm64, T);\n+    if (-1 != imm) {\n@@ -1379,33 +1360,12 @@\n-  uint32_t imm32 = imm64 & 0xFFFFFFFFULL;\n-  if (T == T8B || T == T16B) {\n-    assert((imm32 & ~0xff) == 0, \"extraneous bits in unsigned imm32 (T8B\/T16B)\");\n-    movi(Vd, T, imm32 & 0xff, 0);\n-    return;\n-  }\n-  uint32_t nimm32 = ~imm32;\n-  if (T == T4H || T == T8H) {\n-    assert((imm32  & ~0xffff) == 0, \"extraneous bits in unsigned imm32 (T4H\/T8H)\");\n-    imm32 &= 0xffff;\n-    nimm32 &= 0xffff;\n-  }\n-  uint32_t x = imm32;\n-  int movi_cnt = 0;\n-  int movn_cnt = 0;\n-  while (x) { if (x & 0xff) movi_cnt++; x >>= 8; }\n-  x = nimm32;\n-  while (x) { if (x & 0xff) movn_cnt++; x >>= 8; }\n-  if (movn_cnt < movi_cnt) imm32 = nimm32;\n-  unsigned lsl = 0;\n-  while (imm32 && (imm32 & 0xff) == 0) { lsl += 8; imm32 >>= 8; }\n-  if (movn_cnt < movi_cnt)\n-    mvni(Vd, T, imm32 & 0xff, lsl);\n-  else\n-    movi(Vd, T, imm32 & 0xff, lsl);\n-  imm32 >>= 8; lsl += 8;\n-  while (imm32) {\n-    while ((imm32 & 0xff) == 0) { lsl += 8; imm32 >>= 8; }\n-    if (movn_cnt < movi_cnt)\n-      bici(Vd, T, imm32 & 0xff, lsl);\n-    else\n-      orri(Vd, T, imm32 & 0xff, lsl);\n-    lsl += 8; imm32 >>= 8;\n+#ifdef ASSERT\n+  if (T == T8B || T == T16B) assert((imm64 & ~0xff) == 0, \"extraneous bits (T8B\/T16B)\");\n+  if (T == T4H || T == T8H) assert((imm64  & ~0xffff) == 0, \"extraneous bits (T4H\/T8H)\");\n+  if (T == T2S || T == T4S) assert((imm64  & ~0xffffffff) == 0, \"extraneous bits (T2S\/T4S)\");\n+#endif\n+  int shift = operand_valid_for_movi_immediate(imm64, T);\n+  uint32_t imm32 = imm64 & 0xffffffffULL;\n+  if (shift >= 0) {\n+    movi(Vd, T, (imm32 >> shift) & 0xff, shift);\n+  } else {\n+    movw(rscratch1, imm32);\n+    dup(Vd, T, rscratch1);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":15,"deletions":55,"binary":false,"changes":70,"status":"modified"}]}