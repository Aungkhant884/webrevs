{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -139,2 +139,1 @@\n-            if ((uname.startsWith(\"META-INF\/\") ||\n-                 uname.startsWith(\"\/META-INF\/\"))) {\n+            if (isInMetaInf(uname)) {\n@@ -199,0 +198,8 @@\n+    \/**\n+     * Returns true iff the entry resides directly in the META-INF\/ directory\n+     *\/\n+    private boolean isInMetaInf(String uname) {\n+        return (uname.startsWith(\"META-INF\/\") || uname.startsWith(\"\/META-INF\/\") )\n+                && uname.lastIndexOf('\/') < \"META-INF\/\".length();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/jar\/JarVerifier.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1748,0 +1748,5 @@\n+\n+            \/\/ Signature related files must reside directly in META-INF\/\n+            if(signatureRelated && hasSlash(name, off + META_INF_LEN, off + len)) {\n+                signatureRelated = false;\n+            }\n@@ -1750,0 +1755,14 @@\n+        \/*\n+         * Return true if the encoded name contains a '\/' within the byte given range\n+         * This assumes an ASCII-compatible encoding, which is ok here since\n+         * it is already assumed in isMetaName\n+         *\/\n+        private boolean hasSlash(byte[] name, int start, int end) {\n+            for(int i = start; i < end; i++) {\n+                int c = name[i];\n+                if(c == '\/') {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n-        \/\/ we currently only support DSA and RSA PKCS7 blocks\n+        \/\/ we currently only support DSA, RSA or EC PKCS7 blocks\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SignatureFileVerifier.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -734,1 +734,1 @@\n-            if (ze.getName().startsWith(META_INF)) {\n+            if (isInMetaInf(ze)) {\n@@ -962,1 +962,1 @@\n-            if (!ze.getName().startsWith(META_INF)) {\n+            if (!isInMetaInf(ze)) {\n@@ -977,0 +977,7 @@\n+    \/**\n+     * Returns true iff the entry resides directly in the META-INF\/ directory\n+     *\/\n+    private boolean isInMetaInf(ZipEntry ze) {\n+        return ze.getName().startsWith(META_INF) && ze.getName().lastIndexOf('\/') < META_INF.length();\n+    }\n+\n","filename":"src\/jdk.jartool\/share\/classes\/jdk\/security\/jarsigner\/JarSigner.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,234 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Make sure signature related files in subdirectories of META-INF are not considered for verification\n+ * @modules java.base\/jdk.internal.access\n+ * @modules java.base\/sun.security.util\n+ * @modules java.base\/sun.security.tools.keytool\n+ * @compile VerifyUnrelatedSignatureFiles.java\n+ * @run main\/othervm VerifyUnrelatedSignatureFiles\n+ *\/\n+\n+import jdk.internal.access.JavaUtilZipFileAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.security.jarsigner.JarSigner;\n+import sun.security.util.SignatureFileVerifier;\n+\n+import java.io.*;\n+import java.nio.charset.StandardCharsets;\n+import java.security.CodeSigner;\n+import java.security.KeyStore;\n+import java.security.PrivateKey;\n+import java.security.cert.CertPath;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.jar.*;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipInputStream;\n+\n+public class VerifyUnrelatedSignatureFiles {\n+\n+    private static final JavaUtilZipFileAccess JUZA = SharedSecrets.getJavaUtilZipFileAccess();\n+\n+    \/\/ This path resides in a subdirectory of META-INF, so it should not be considered signature related\n+    public static final String SUBDIR_SF_PATH = \"META-INF\/subdirectory\/META-INF\/SIGNER.SF\";\n+\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        File j = createJarFile();\n+        File s = signJarFile(j, \"SIGNER1\", \"signed\");\n+        File m = moveSignatureRelated(s);\n+        File sm = signJarFile(m, \"SIGNER2\", \"modified-signed\");\n+\n+        \/\/ 1: Check ZipFile.Source.isSignatureRelated\n+        try(JarFile jarFile = new JarFile(m)) {\n+            final List<String> manifestAndSignatureRelatedFiles = JUZA.getManifestAndSignatureRelatedFiles(jarFile);\n+            for (String signatureRelatedFile : manifestAndSignatureRelatedFiles) {\n+                String dir = signatureRelatedFile.substring(0, signatureRelatedFile.lastIndexOf(\"\/\"));\n+                if(!\"META-INF\".equals(dir)) {\n+                    throw new Exception(\"Signature related file does not reside directly in META-INF\/ : \" + signatureRelatedFile);\n+                }\n+            }\n+        }\n+\n+        \/\/ 2: Check SignatureFileVerifier.isSigningRelated\n+        if(SignatureFileVerifier.isSigningRelated(SUBDIR_SF_PATH)) {\n+            throw new Exception(\"Signature related file does not reside directly in META-INF\/ : \" + SUBDIR_SF_PATH);\n+        }\n+\n+        \/\/ 3: Check JarInputStream with doVerify = true\n+        try(JarInputStream in = new JarInputStream(new FileInputStream(m), true)) {\n+            while( in.getNextEntry() != null) {\n+                in.transferTo(OutputStream.nullOutputStream());\n+            }\n+        }\n+\n+        \/\/ 4: Check that a JAR containing unrelated .SF, .RSA files is signed as-if it is unsigned\n+        try(ZipFile zf = new ZipFile(sm)) {\n+            final ZipEntry mf = zf.getEntry(\"META-INF\/MANIFEST.MF\");\n+            try(InputStream stream = zf.getInputStream(mf)) {\n+                final String manifest = new String(stream.readAllBytes(), StandardCharsets.UTF_8);\n+                \/\/ When JarSigner considers a jar to not be already signed,\n+                \/\/ the 'Manifest-Version' attributed name will be case-normalized\n+                \/\/ Assert that manifest-version is not in lowercase\n+                if(manifest.startsWith(\"manifest-version\")) {\n+                    throw new Exception(\"JarSigner unexpectedly treated unsigned jar as signed\");\n+                }\n+            }\n+        }\n+\n+        \/\/ 5: Check that a JAR containing non signature related .SF, .RSA files can be signed\n+        try(JarFile jf = new JarFile(sm, true)) {\n+            checkSignedBy(jf, \"a.txt\", \"CN=SIGNER2\");\n+            checkSignedBy(jf, \"META-INF\/subdirectory\/META-INF\/SIGNER1.SF\", \"CN=SIGNER2\");\n+        }\n+    }\n+\n+    \/**\n+     * Check that a path of a given JAR is signed once by the expected signer CN\n+     *\/\n+    private static void checkSignedBy(JarFile jf, String name, String expectedSigner) throws Exception {\n+        JarEntry je = jf.getJarEntry(name);\n+\n+        \/\/ Read the contents to trigger verification\n+        try(InputStream in = jf.getInputStream(je)) {\n+            in.transferTo(OutputStream.nullOutputStream());\n+        }\n+\n+        \/\/ Verify that the entry is signed\n+        CodeSigner[] signers = je.getCodeSigners();\n+        if (signers == null) {\n+            throw new Exception(String.format(\"Expected %s to be signed\", name));\n+        }\n+\n+        \/\/ There should be a single signer\n+        if (signers.length != 1) {\n+            throw new Exception(String.format(\"Expected %s to be signed by exactly one signer\", name));\n+        }\n+\n+        String actualSigner = ((X509Certificate) signers[0]\n+                .getSignerCertPath().getCertificates().get(0))\n+                .getIssuerX500Principal().getName();\n+\n+        if(!actualSigner.equals(expectedSigner)) {\n+            throw new Exception(String.format(\"Expected %s to be signed by %s, was signed by %s\", name, expectedSigner, actualSigner));\n+        }\n+    }\n+\n+    \/**\n+     * Create a jar file with a '*.SF' file residing in META-INF\/subdirectory\/\n+     *\/\n+    private static File createJarFile() throws Exception {\n+\n+        File f = File.createTempFile(\"unrelated-signature-file-\", \".jar\");\n+\n+\n+        Manifest manifest = new Manifest();\n+        manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, \"1.0\");\n+        try(JarOutputStream out = new JarOutputStream(new FileOutputStream(f), manifest)) {\n+            out.putNextEntry(new JarEntry(\"a.txt\"));\n+            out.write(\"a\".getBytes(StandardCharsets.UTF_8));\n+        }\n+\n+        return f;\n+    }\n+    \/**\n+     * Create a signed version of the given jar file\n+     *\/\n+    private static File signJarFile(File f, String signerName, String classifier) throws Exception {\n+        File s = File.createTempFile(\"unrelated-signature-files-\" + classifier +\"-\", \".jar\");\n+\n+        new File(\"ks\").delete();\n+\n+        sun.security.tools.keytool.Main.main(\n+                (\"-keystore ks -storepass changeit -keypass changeit -dname\" +\n+                        \" CN=\" + signerName +\" -alias r -genkeypair -keyalg rsa\").split(\" \"));\n+\n+        char[] pass = \"changeit\".toCharArray();\n+\n+        KeyStore ks = KeyStore.getInstance(\n+                new File(\"ks\"), pass);\n+        PrivateKey pkr = (PrivateKey)ks.getKey(\"r\", pass);\n+\n+        CertPath cp = CertificateFactory.getInstance(\"X.509\")\n+                .generateCertPath(Arrays.asList(ks.getCertificateChain(\"r\")));\n+\n+        JarSigner signer = new JarSigner.Builder(pkr, cp)\n+                .digestAlgorithm(\"SHA-256\")\n+                .signatureAlgorithm(\"SHA256withRSA\")\n+                .signerName(signerName)\n+                .build();\n+\n+        try(ZipFile in = new ZipFile(f);\n+            OutputStream out = new FileOutputStream(s)) {\n+            signer.sign(in, out);\n+        }\n+\n+        return s;\n+    }\n+\n+    \/**\n+     * Create a modified version of a signed jar file where signature-related files\n+     * are moved into a subdirectory of META-INF\/ and the manifest is changed to trigger\n+     * a digest mismatch.\n+     *\n+     * Since the signature related files are moved out of META-INF\/, the returned jar file should\n+     * not be considered signed\n+     *\/\n+    private static File moveSignatureRelated(File s) throws IOException {\n+        File m = File.createTempFile(\"unrelated-signature-files-modified-\", \".jar\");\n+\n+\n+        try(ZipInputStream in = new JarInputStream(new FileInputStream(s));\n+            JarOutputStream out = new JarOutputStream(new FileOutputStream(m))) {\n+\n+            out.putNextEntry(new ZipEntry(\"META-INF\/MANIFEST.MF\"));\n+            out.write(\"manifest-version: 1.0\\n\\n\".getBytes(StandardCharsets.UTF_8));\n+\n+            ZipEntry entry;\n+            while((entry = in.getNextEntry()) != null) {\n+                String name = entry.getName();\n+\n+                \/\/ Skip the existing manifest\n+                if(\"META-INF\/MANIFEST.MF\".equals(name)) {\n+                    continue;\n+                }\n+\n+                \/\/ Move signature related files into subdirectory of META-INF\n+                if(name.endsWith(\".SF\") || name.endsWith(\".RSA\")) {\n+                    name = \"META-INF\/subdirectory\/\" + name;\n+                }\n+\n+                out.putNextEntry(new ZipEntry(name));\n+                in.transferTo(out);\n+            }\n+        }\n+        return m;\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/jar\/JarFile\/VerifyUnrelatedSignatureFiles.java","additions":234,"deletions":0,"binary":false,"changes":234,"status":"added"}]}