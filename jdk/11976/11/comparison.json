{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,2 @@\n+import static sun.security.util.SignatureFileVerifier.isInMetaInf;\n+\n@@ -138,3 +140,2 @@\n-            String uname = name.toUpperCase(Locale.ENGLISH);\n-            if ((uname.startsWith(\"META-INF\/\") ||\n-                 uname.startsWith(\"\/META-INF\/\"))) {\n+\n+            if (isInMetaInf(name)) {\n@@ -146,1 +147,1 @@\n-\n+                String uname = name.toUpperCase(Locale.ENGLISH);\n","filename":"src\/java.base\/share\/classes\/java\/util\/jar\/JarVerifier.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1748,0 +1748,5 @@\n+\n+            \/\/ Signature related files must reside directly in META-INF\/\n+            if(signatureRelated && hasSlash(name, off + META_INF_LEN, off + len)) {\n+                signatureRelated = false;\n+            }\n@@ -1750,0 +1755,14 @@\n+        \/*\n+         * Return true if the encoded name contains a '\/' within the byte given range\n+         * This assumes an ASCII-compatible encoding, which is ok here since\n+         * it is already assumed in isMetaName\n+         *\/\n+        private boolean hasSlash(byte[] name, int start, int end) {\n+            for(int i = start; i < end; i++) {\n+                int c = name[i];\n+                if(c == '\/') {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,0 +84,2 @@\n+    private static final String META_INF = \"META-INF\/\";\n+\n@@ -144,0 +146,12 @@\n+    \/**\n+     * Utility method used by JarVerifier and JarSigner\n+     * to determine if a path is located directly in the\n+     * META-INF\/ directory\n+     *\n+     * @param name the path name to check\n+     * @return true if the path resides in META-INF directly, ignoring case\n+     *\/\n+    public static boolean isInMetaInf(String name) {\n+        return name.regionMatches(true, 0, META_INF, 0, META_INF.length())\n+                && name.lastIndexOf('\/') < META_INF.length();\n+    }\n@@ -156,1 +170,1 @@\n-        \/\/ we currently only support DSA and RSA PKCS7 blocks\n+        \/\/ we currently only support DSA, RSA or EC PKCS7 blocks\n@@ -194,2 +208,1 @@\n-        name = name.toUpperCase(Locale.ENGLISH);\n-        if (!name.startsWith(\"META-INF\/\")) {\n+        if (!isInMetaInf(name)) {\n@@ -198,5 +211,2 @@\n-        name = name.substring(9);\n-        if (name.indexOf('\/') != -1) {\n-            return false;\n-        }\n-        if (isBlockOrSF(name) || name.equals(\"MANIFEST.MF\")) {\n+        name = name.toUpperCase(Locale.ENGLISH);\n+        if (isBlockOrSF(name) || name.equals(\"META-INF\/MANIFEST.MF\")) {\n@@ -204,1 +214,1 @@\n-        } else if (name.startsWith(\"SIG-\")) {\n+        } else if (name.startsWith(\"SIG-\", META_INF.length())) {\n@@ -206,1 +216,1 @@\n-            \/\/ see http:\/\/docs.oracle.com\/javase\/7\/docs\/technotes\/guides\/jar\/jar.html#Digital_Signatures\n+            \/\/ see https:\/\/docs.oracle.com\/en\/java\/javase\/19\/docs\/specs\/jar\/jar.html#digital-signatures\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SignatureFileVerifier.java","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -66,0 +66,2 @@\n+import static sun.security.util.SignatureFileVerifier.isInMetaInf;\n+\n@@ -478,2 +480,0 @@\n-    private static final String META_INF = \"META-INF\/\";\n-\n@@ -734,1 +734,1 @@\n-            if (ze.getName().startsWith(META_INF)) {\n+            if (isInMetaInf(ze.getName())) {\n@@ -962,1 +962,1 @@\n-            if (!ze.getName().startsWith(META_INF)) {\n+            if (!isInMetaInf(ze.getName())) {\n@@ -977,0 +977,1 @@\n+\n","filename":"src\/jdk.jartool\/share\/classes\/jdk\/security\/jarsigner\/JarSigner.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -838,2 +838,1 @@\n-                    hasSignature = hasSignature\n-                            || SignatureFileVerifier.isBlockOrSF(name);\n+                    hasSignature |= signatureRelated(name) && SignatureFileVerifier.isBlockOrSF(name);\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Main.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,357 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8300140\n+ * @summary Make sure signature related files in subdirectories of META-INF are not considered for verification\n+ * @modules java.base\/jdk.internal.access\n+ * @modules java.base\/sun.security.util\n+ * @modules java.base\/sun.security.tools.keytool\n+ * @modules jdk.jartool\/sun.security.tools.jarsigner\n+ * @run main\/othervm IgnoreUnrelatedSignatureFiles\n+ *\/\n+\n+import jdk.internal.access.JavaUtilZipFileAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.security.jarsigner.JarSigner;\n+import sun.security.tools.jarsigner.Main;\n+import sun.security.util.SignatureFileVerifier;\n+\n+import java.io.*;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.CodeSigner;\n+import java.security.KeyStore;\n+import java.security.PrivateKey;\n+import java.security.cert.CertPath;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.jar.Attributes;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+import java.util.jar.JarInputStream;\n+import java.util.jar.JarOutputStream;\n+import java.util.jar.Manifest;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n+\n+public class IgnoreUnrelatedSignatureFiles {\n+\n+    private static final JavaUtilZipFileAccess JUZA = SharedSecrets.getJavaUtilZipFileAccess();\n+\n+    \/\/ This path resides in a subdirectory of META-INF, so it should not be considered signature related\n+    public static final String SUBDIR_SF_PATH = \"META-INF\/subdirectory\/META-INF\/SIGNER.SF\";\n+\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ Regular signed JAR\n+        Path j = createJarFile();\n+        Path s = signJarFile(j, \"SIGNER1\", \"signed\");\n+\n+        \/\/ Singed JAR with unrelated signature files\n+        Path m = moveSignatureRelated(s);\n+        Path sm = signJarFile(m, \"SIGNER2\", \"modified-signed\");\n+\n+        \/\/ Signed JAR with custom SIG-* files\n+        Path ca = createCustomAlgJar();\n+        Path cas = signJarFile(ca, \"SIGNER1\", \"custom-signed\");\n+\n+        \/\/ 0: Sanity check that the basic signed JAR verifies\n+        try (JarFile jf = new JarFile(s.toFile(), true)) {\n+            Map<String, Attributes> entries = jf.getManifest().getEntries();\n+            if(entries.size() != 1) {\n+                throw new Exception(\"Expected a single manifest entry for the digest of a.txt, instead found entries: \" + entries.keySet());\n+            }\n+            JarEntry entry = jf.getJarEntry(\"a.txt\");\n+            try (InputStream in = jf.getInputStream(entry)) {\n+                in.transferTo(OutputStream.nullOutputStream());\n+            }\n+        }\n+        \/\/ 1: Check ZipFile.Source.isSignatureRelated\n+        try (JarFile jarFile = new JarFile(m.toFile())) {\n+            List<String> manifestAndSignatureRelatedFiles = JUZA.getManifestAndSignatureRelatedFiles(jarFile);\n+            for (String signatureRelatedFile : manifestAndSignatureRelatedFiles) {\n+                String dir = signatureRelatedFile.substring(0, signatureRelatedFile.lastIndexOf(\"\/\"));\n+                if (!\"META-INF\".equals(dir)) {\n+                    throw new Exception(\"Signature related file does not reside directly in META-INF\/ : \" + signatureRelatedFile);\n+                }\n+            }\n+        }\n+\n+        \/\/ 2: Check SignatureFileVerifier.isSigningRelated\n+        if (SignatureFileVerifier.isSigningRelated(SUBDIR_SF_PATH)) {\n+            throw new Exception(\"Signature related file does not reside directly in META-INF\/ : \" + SUBDIR_SF_PATH);\n+        }\n+\n+        \/\/ 3: Check JarInputStream with doVerify = true\n+        try (JarInputStream in = new JarInputStream(Files.newInputStream(m), true)) {\n+             while (in.getNextEntry() != null) {\n+                in.transferTo(OutputStream.nullOutputStream());\n+            }\n+        }\n+\n+        \/\/ 4: Check that a JAR containing unrelated .SF, .RSA files is signed as-if it is unsigned\n+        try (ZipFile zf = new ZipFile(sm.toFile())) {\n+            ZipEntry mf = zf.getEntry(\"META-INF\/MANIFEST.MF\");\n+            try (InputStream stream = zf.getInputStream(mf)) {\n+                String manifest = new String(stream.readAllBytes(), StandardCharsets.UTF_8);\n+                \/\/ When JarSigner considers a jar to not be already signed,\n+                \/\/ the 'Manifest-Version' attributed name will be case-normalized\n+                \/\/ Assert that manifest-version is not in lowercase\n+                if (manifest.startsWith(\"manifest-version\")) {\n+                    throw new Exception(\"JarSigner unexpectedly treated unsigned jar as signed\");\n+                }\n+            }\n+        }\n+\n+        \/\/ 5: Check that a JAR containing non signature related .SF, .RSA files can be signed\n+        try (JarFile jf = new JarFile(sm.toFile(), true)) {\n+            checkSignedBy(jf, \"a.txt\", \"CN=SIGNER2\");\n+            checkSignedBy(jf, \"META-INF\/subdirectory\/META-INF\/SIGNER1.SF\", \"CN=SIGNER2\");\n+        }\n+\n+        \/\/ 6: Check that JarSigner does not move unrelated [SF,RSA] files to the beginning of signed JARs\n+        try (JarFile zf = new JarFile(sm.toFile())) {\n+\n+            List<String> actualOrder = zf.stream().map(ZipEntry::getName).toList();\n+\n+            List<String> expectedOrder = List.of(\n+                    \"META-INF\/MANIFEST.MF\",\n+                    \"META-INF\/SIGNER2.SF\",\n+                    \"META-INF\/SIGNER2.RSA\",\n+                    \"META-INF\/subdirectory\/META-INF\/SIGNER1.SF\",\n+                    \"META-INF\/subdirectory\/META-INF\/SIGNER1.RSA\",\n+                    \"a.txt\",\n+                    \"META-INF\/subdirectory2\/META-INF\/SIGNER1.SF\",\n+                    \"META-INF\/subdirectory2\/META-INF\/SIGNER1.RSA\"\n+            );\n+\n+            if (!expectedOrder.equals(actualOrder)) {\n+                String msg = (\"\"\"\n+                        Unexpected file order in JAR with unrelated SF,RSA files\n+                        Expected order: %s\n+                        Actual order: %s\"\"\")\n+                        .formatted(expectedOrder, actualOrder);\n+                throw new Exception(msg);\n+            }\n+        }\n+\n+        \/\/ 7: Check that jarsigner ignores unrelated signature files\n+        String message = jarSignerVerify(m);\n+        if (message.contains(\"WARNING\")) {\n+            throw new Exception(\"jarsigner output contains unexpected  warning: \" +message);\n+        }\n+\n+        \/\/ 8: Check that SignatureFileVerifier.isSigningRelated handles custom SIG-* files correctly\n+        try (JarFile jf = new JarFile(cas.toFile(), true)) {\n+\n+            \/\/ These files are not signature-related and should be signed\n+            Set<String> expectedSigned = Set.of(\"a.txt\",\n+                    \"META-INF\/SIG-CUSTOM2.C-1\",\n+                    \"META-INF\/subdirectory\/SIG-CUSTOM2.SF\",\n+                    \"META-INF\/subdirectory\/SIG-CUSTOM2.CS1\");\n+\n+            Set<String> actualSigned = jf.getManifest().getEntries().keySet();\n+\n+            if(!expectedSigned.equals(actualSigned)) {\n+                throw new Exception(\"Unexpected MANIFEST entries. Expected %s, got %s\"\n+                        .formatted(expectedSigned, actualSigned));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * run \"jarsigner -verify\" on the JAR and return the captured output\n+     *\/\n+    private static String jarSignerVerify(Path m) throws Exception {\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        PrintStream currentOut = System.out;\n+        try {\n+            System.setOut(new PrintStream(out));\n+            Main.main(new String[] {\"-verify\", m.toAbsolutePath().toString()});\n+            return out.toString(StandardCharsets.UTF_8);\n+        } finally {\n+            System.setOut(currentOut);\n+        }\n+    }\n+\n+    \/**\n+     * Check that a path of a given JAR is signed once by the expected signer CN\n+     *\/\n+    private static void checkSignedBy(JarFile jf, String name, String expectedSigner) throws Exception {\n+        JarEntry je = jf.getJarEntry(name);\n+\n+        \/\/ Read the contents to trigger verification\n+        try (InputStream in = jf.getInputStream(je)) {\n+            in.transferTo(OutputStream.nullOutputStream());\n+        }\n+\n+        \/\/ Verify that the entry is signed\n+        CodeSigner[] signers = je.getCodeSigners();\n+        if (signers == null) {\n+            throw new Exception(String.format(\"Expected %s to be signed\", name));\n+        }\n+\n+        \/\/ There should be a single signer\n+        if (signers.length != 1) {\n+            throw new Exception(String.format(\"Expected %s to be signed by exactly one signer\", name));\n+        }\n+\n+        String actualSigner = ((X509Certificate) signers[0]\n+                .getSignerCertPath().getCertificates().get(0))\n+                .getIssuerX500Principal().getName();\n+\n+        if (!actualSigner.equals(expectedSigner)) {\n+            throw new Exception(String.format(\"Expected %s to be signed by %s, was signed by %s\", name, expectedSigner, actualSigner));\n+        }\n+    }\n+\n+    \/**\n+     * Create a jar file with a '*.SF' file residing in META-INF\/subdirectory\/\n+     *\/\n+    private static Path createJarFile() throws Exception {\n+\n+        Path jar = Path.of(\"unrelated-signature-file.jar\");\n+\n+        Manifest manifest = new Manifest();\n+        manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, \"1.0\");\n+        try (JarOutputStream out = new JarOutputStream(Files.newOutputStream(jar), manifest)) {\n+            write(out, \"a.txt\", \"a\");\n+        }\n+\n+        return jar;\n+    }\n+\n+    private static Path createCustomAlgJar() throws Exception {\n+        Path jar = Path.of(\"unrelated-signature-file-custom-sig.jar\");\n+\n+        Manifest manifest = new Manifest();\n+        manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, \"1.0\");\n+        try (JarOutputStream out = new JarOutputStream(Files.newOutputStream(jar), manifest)) {\n+            \/\/ Regular file\n+            write(out, \"a.txt\", \"a\");\n+            \/\/ Custom SIG files with valid extension\n+            write(out, \"META-INF\/SIG-CUSTOM.SF\", \"\");\n+            write(out, \"META-INF\/SIG-CUSTOM.CS1\", \"\");\n+\n+            \/\/ Custom SIG files with invalid extension\n+            write(out, \"META-INF\/SIG-CUSTOM2.SF\", \"\");\n+            write(out, \"META-INF\/SIG-CUSTOM2.C-1\", \"\");\n+\n+            \/\/ Custom SIG files with valid extension, invalid directory\n+            write(out, \"META-INF\/subdirectory\/SIG-CUSTOM2.SF\", \"\");\n+            write(out, \"META-INF\/subdirectory\/SIG-CUSTOM2.CS1\", \"\");\n+\n+        }\n+\n+        return jar;\n+    }\n+\n+    private static void write(JarOutputStream out, String name, String content) throws IOException {\n+        out.putNextEntry(new JarEntry(name));\n+        out.write(content.getBytes(StandardCharsets.UTF_8));\n+    }\n+\n+    \/**\n+     * Create a signed version of the given jar file\n+     *\/\n+    private static Path signJarFile(Path jar, String signerName, String classifier) throws Exception {\n+        Path s = Path.of(\"unrelated-signature-files-\" + classifier +\".jar\");\n+\n+        Files.deleteIfExists(Path.of(\"ks\"));\n+\n+        sun.security.tools.keytool.Main.main(\n+                (\"-keystore ks -storepass changeit -keypass changeit -dname\" +\n+                        \" CN=\" + signerName +\" -alias r -genkeypair -keyalg rsa\").split(\" \"));\n+\n+        char[] pass = \"changeit\".toCharArray();\n+\n+        KeyStore ks = KeyStore.getInstance(\n+                new File(\"ks\"), pass);\n+        PrivateKey pkr = (PrivateKey)ks.getKey(\"r\", pass);\n+\n+        CertPath cp = CertificateFactory.getInstance(\"X.509\")\n+                .generateCertPath(Arrays.asList(ks.getCertificateChain(\"r\")));\n+\n+        JarSigner signer = new JarSigner.Builder(pkr, cp)\n+                .digestAlgorithm(\"SHA-256\")\n+                .signatureAlgorithm(\"SHA256withRSA\")\n+                .signerName(signerName)\n+                .build();\n+\n+        try (ZipFile in = new ZipFile(jar.toFile());\n+            OutputStream out = Files.newOutputStream(s)) {\n+            signer.sign(in, out);\n+        }\n+\n+        return s;\n+    }\n+\n+    \/**\n+     * Create a modified version of a signed jar file where signature-related files\n+     * are moved into a subdirectory of META-INF\/ and the manifest is changed to trigger\n+     * a digest mismatch.\n+     *\n+     * Since the signature related files are moved out of META-INF\/, the returned jar file should\n+     * not be considered signed\n+     *\/\n+    private static Path moveSignatureRelated(Path s) throws Exception {\n+        Path m = Path.of(\"unrelated-signature-files-modified.jar\");\n+\n+        try (ZipFile in = new ZipFile(s.toFile());\n+            ZipOutputStream out = new ZipOutputStream(Files.newOutputStream(m))) {\n+\n+            \/\/ Change the digest of the manifest by lower-casing the Manifest-Version attribute:\n+            out.putNextEntry(new ZipEntry(\"META-INF\/MANIFEST.MF\"));\n+            out.write(\"manifest-version: 1.0\\n\\n\".getBytes(StandardCharsets.UTF_8));\n+\n+            copy(\"META-INF\/SIGNER1.SF\", \"META-INF\/subdirectory\/META-INF\/SIGNER1.SF\", in, out);\n+            copy(\"META-INF\/SIGNER1.RSA\", \"META-INF\/subdirectory\/META-INF\/SIGNER1.RSA\", in, out);\n+\n+            \/\/ Copy over the regular a.txt file\n+            copy(\"a.txt\", \"a.txt\", in, out);\n+\n+            \/\/ These are also just regular files in their new location, but putting them at end\n+            \/\/ allows us to verify that JarSigner does not move them to the beginning of the signed JAR\n+            copy(\"META-INF\/SIGNER1.SF\", \"META-INF\/subdirectory2\/META-INF\/SIGNER1.SF\", in, out);\n+            copy(\"META-INF\/SIGNER1.RSA\", \"META-INF\/subdirectory2\/META-INF\/SIGNER1.RSA\", in, out);\n+        }\n+        return m;\n+    }\n+\n+    \/\/ Copy a file from a ZipFile into a ZipOutputStream\n+    private static void copy(String from, String to, ZipFile in, ZipOutputStream out) throws Exception {\n+        out.putNextEntry(new ZipEntry(to));\n+        try (InputStream zi = in.getInputStream(new ZipEntry(from))) {\n+            zi.transferTo(out);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/jar\/JarFile\/IgnoreUnrelatedSignatureFiles.java","additions":357,"deletions":0,"binary":false,"changes":357,"status":"added"}]}