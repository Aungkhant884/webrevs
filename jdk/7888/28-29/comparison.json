{"files":[{"patch":"@@ -388,25 +388,0 @@\n-    \/**\n-     * Creates a <em>strided<\/em> access var handle that can be used to dereference memory at the layout selected by the given layout path,\n-     * where the path is considered rooted in this layout. The returned var handle can effectively dereference multiple memory\n-     * locations, using a <em>dynamic<\/em> index (of type {@code long}), which is multiplied by this layout size and then added\n-     * to the offset of the selected layout. Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * MemoryLayout.sequenceLayout(0, this)\n-     *             .varHandle(PathElement.sequenceElement());\n-     * }\n-     *\n-     * @param elements the layout path elements.\n-     * @return a var handle which can be used to dereference memory at the (possibly nested) layout selected by the layout path in {@code elements}.\n-     * @throws UnsupportedOperationException if the layout path has one or more elements with incompatible alignment constraints.\n-     * @throws IllegalArgumentException if the layout path in {@code elements} does not select a value layout (see {@link ValueLayout}).\n-     * @see MethodHandles#memorySegmentViewVarHandle\n-     *\/\n-    default VarHandle arrayElementVarHandle(PathElement... elements) {\n-        Objects.requireNonNull(elements);\n-        PathElement[] newElements = new PathElement[elements.length + 1];\n-        newElements[0] = PathElement.sequenceElement();\n-        System.arraycopy(elements, 0, newElements, 1, elements.length);\n-        return computePathOp(LayoutPath.rootPath(MemoryLayout.sequenceLayout(0, this)),\n-                LayoutPath::dereferenceHandle, Set.of(), newElements);\n-    }\n-\n@@ -670,1 +645,3 @@\n-     * Creates a sequence layout with the given element layout and element count.\n+     * Creates a sequence layout with the given element layout and element count. If the element count has the\n+     * special value {@code -1}, the element count is inferred to be the biggest possible count such that\n+     * the sequence layout size does not overflow, using the following formula:\n@@ -672,1 +649,5 @@\n-     * @param elementCount the sequence element count.\n+     * <blockquote><pre>{@code\n+     * inferredElementCount = Long.MAX_VALUE \/ elementLayout.bitSize();\n+     * }<\/pre><\/blockquote>\n+     *\n+     * @param elementCount the sequence element count; if set to {@code -1}, the sequence element count is inferred.\n@@ -675,2 +656,2 @@\n-     * @throws IllegalArgumentException if {@code elementCount < 0}.\n-     * @throws IllegalArgumentException if the computation {@code elementCount * elementLayout.bitSize()} overflows.\n+     * @throws IllegalArgumentException if {@code elementCount < -1}.\n+     * @throws IllegalArgumentException if {@code elementCount != -1} and the computation {@code elementCount * elementLayout.bitSize()} overflows.\n@@ -679,3 +660,10 @@\n-        AbstractLayout.checkSize(elementCount, true);\n-        return wrapOverflow(() ->\n-                new SequenceLayout(elementCount, Objects.requireNonNull(elementLayout)));\n+        if (elementCount == -1) {\n+            \/\/ inferred element count\n+            long inferredElementCount = Long.MAX_VALUE \/ elementLayout.bitSize();\n+            return new SequenceLayout(inferredElementCount, elementLayout);\n+        } else {\n+            \/\/ explicit element count\n+            AbstractLayout.checkSize(elementCount, true);\n+            return wrapOverflow(() ->\n+                    new SequenceLayout(elementCount, Objects.requireNonNull(elementLayout)));\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":20,"deletions":32,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -30,0 +31,2 @@\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -119,0 +122,56 @@\n+    \/**\n+     * Creates a <em>strided<\/em> access var handle that can be used to dereference a multi-dimensional array. The\n+     * layout of this array is a sequence layout with {@code shape.length} nested sequence layouts. The element\n+     * layout of the sequence layout at depth {@code shape.length} is this value layout.\n+     * As a result, if {@code shape.length == 0}, the array layout will feature only one dimension.\n+     * <p>\n+     * The resulting var handle will feature {@code sizes.length + 1} coordinates of type {@code long}, which are\n+     * used as indices into a multi-dimensional array.\n+     * <p>\n+     * For instance, the following method call:\n+     *\n+     * {@snippet lang=java :\n+     * VarHandle arrayHandle = ValueLayout.JAVA_INT.arrayElementVarHandle(10, 20);\n+     * }\n+     *\n+     * Can be used to access a multi-dimensional array whose layout is as follows:\n+     *\n+     * {@snippet lang=java :\n+     * MemoryLayout arrayLayout = MemoryLayout.sequenceLayout(-1,\n+     *                                      MemoryLayout.sequenceLayout(10,\n+     *                                                  MemoryLayout.sequenceLayout(20, ValueLayout.JAVA_INT)));\n+     * }\n+     *\n+     * The resulting var handle {@code arrayHandle} will feature 3 coordinates of type {@code long}; each coordinate\n+     * is interpreted as an index into the corresponding sequence layout. If we refer to the var handle coordinates, from left\n+     * to right, as {@code x}, {@code y} and {@code z} respectively, the final offset dereferenced by the var handle can be\n+     * computed with the following formula:\n+     *\n+     * <blockquote><pre>{@code\n+     * offset = (10 * 20 * 4 * x) + (20 * 4 * y) + (4 * z)\n+     * }<\/pre><\/blockquote>\n+     *\n+     * @param shape the size of each nested array dimension.\n+     * @return a var handle which can be used to dereference a multi-dimensional array, featuring {@code shape.length + 1}\n+     * {@code long} coordinates.\n+     * @throws IllegalArgumentException if {@code shape[i] < 0}, for at least one index {@code i}.\n+     * @throws UnsupportedOperationException if the layout path has one or more elements with incompatible alignment constraints.\n+     * @see MethodHandles#memorySegmentViewVarHandle\n+     * @see MemoryLayout#varHandle(PathElement...)\n+     * @see SequenceLayout\n+     *\/\n+    public VarHandle arrayElementVarHandle(int... shape) {\n+        Objects.requireNonNull(shape);\n+        MemoryLayout layout = this;\n+        List<PathElement> path = new ArrayList<>();\n+        for (int i = shape.length ; i > 0 ; i--) {\n+            int size = shape[i - 1];\n+            if (size < 0) throw new IllegalArgumentException(\"Invalid shape size: \" + size);\n+            layout = MemoryLayout.sequenceLayout(size, layout);\n+            path.add(PathElement.sequenceElement());\n+        }\n+        layout = MemoryLayout.sequenceLayout(-1, layout);\n+        path.add(PathElement.sequenceElement());\n+        return layout.varHandle(path.toArray(new PathElement[0]));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -133,0 +133,12 @@\n+    @Test\n+    public void testSequenceBadCount() {\n+        assertThrows(IllegalArgumentException.class, \/\/ negative\n+                () -> MemoryLayout.sequenceLayout(-2, JAVA_SHORT));\n+    }\n+\n+    @Test(dataProvider = \"basicLayouts\")\n+    public void testSequenceInferredCount(MemoryLayout layout) {\n+        assertEquals(MemoryLayout.sequenceLayout(-1, layout),\n+                     MemoryLayout.sequenceLayout(Long.MAX_VALUE \/ layout.bitSize(), layout));\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -75,0 +75,6 @@\n+    @Test(dataProvider = \"arrayElements\")\n+    public void testArrayAccessAlt(Function<MemorySegment, MemorySegment> viewFactory, ValueLayout elemLayout, ArrayChecker checker) {\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(10, elemLayout.withName(\"elem\"));\n+        testArrayAccessInternal(viewFactory, seq, elemLayout.arrayElementVarHandle(), checker);\n+    }\n+\n@@ -161,0 +167,7 @@\n+    @Test(dataProvider = \"matrixElements\")\n+    public void testMatrixAccessAlt(Function<MemorySegment, MemorySegment> viewFactory, ValueLayout elemLayout, MatrixChecker checker) {\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(20,\n+                MemoryLayout.sequenceLayout(10, elemLayout.withName(\"elem\")));\n+        testMatrixAccessInternal(viewFactory, seq, elemLayout.arrayElementVarHandle(10), checker);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccess.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"}]}