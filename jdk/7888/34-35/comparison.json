{"files":[{"patch":"@@ -30,1 +30,0 @@\n-import java.util.Optional;\n@@ -44,1 +43,1 @@\n- * Foreign functions typically reside in shared libraries that can be loaded on-demand. Each shared library conforms to\n+ * Foreign functions typically reside in libraries that can be loaded on-demand. Each library conforms to\n@@ -58,1 +57,5 @@\n- *\n+ * In addition, a linker provides a way to look up foreign functions in libraries that conform to the ABI. Each linker\n+ * chooses a set of libraries that are commonly used on the OS and processor combination associated with the ABI.\n+ * For example, a linker for Linux\/x64 might choose two libraries: {@code libc} and {@code libm}. The functions in these\n+ * libraries are exposed via a {@linkplain #defaultLookup() symbol lookup}.\n+ * <p>\n@@ -60,1 +63,2 @@\n- * is currently executing.\n+ * is currently executing. This linker also provides access, via its {@linkplain #defaultLookup() default lookup},\n+ * to the native libraries loaded with the Java runtime.\n@@ -147,1 +151,1 @@\n-public sealed interface Linker extends SymbolLookup permits Windowsx64Linker, SysVx64Linker, LinuxAArch64Linker, MacOsAArch64Linker {\n+public sealed interface Linker permits Windowsx64Linker, SysVx64Linker, LinuxAArch64Linker, MacOsAArch64Linker {\n@@ -184,0 +188,3 @@\n+     * @implNote The libraries exposed by the {@linkplain #defaultLookup() default lookup} associated with the returned\n+     * linker are the native libraries loaded in the process where the Java runtime is currently executing. For example,\n+     * on Linux, these libraries typically include {@code libc}, {@code libm} and {@code libdl}.\n@@ -267,3 +274,11 @@\n-     * Look up a symbol in the set of standard libraries associated with this linker instance. The set of symbols\n-     * available for lookup is unspecified, as it depends on the platform and on the operating system.\n-     * @return a symbol in one of the standard libraries associated with this linker (if any).\n+     * Returns a symbol lookup for symbols in a set of commonly used libraries.\n+     * <p>\n+     * Each {@link Linker} is responsible for choosing libraries that are widely recognized as useful on the OS\n+     * and processor combination supported by the {@link Linker}. Accordingly, the precise set of symbols exposed by the\n+     * symbol lookup is unspecified; it varies from one {@link Linker} to another.\n+     * @implNote It is strongly recommended that the result of {@link #defaultLookup} exposes a set of symbols that is stable over time.\n+     * Clients of {@link #defaultLookup()} are likely to fail if a symbol that was previously exposed by the symbol lookup is no longer exposed.\n+     * <p>If an implementer provides {@link Linker} implementations for multiple OS and processor combinations, then it is strongly\n+     * recommended that the result of {@link #defaultLookup()} exposes, as much as possible, a consistent set of symbols\n+     * across all the OS and processor combinations.\n+     * @return a symbol lookup for symbols in a set of commonly used libraries.\n@@ -271,2 +286,1 @@\n-    @Override\n-    Optional<MemorySegment> lookup(String name);\n+    SymbolLookup defaultLookup();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":24,"deletions":10,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -45,5 +45,2 @@\n- * An object that may be used to look up symbols in one or more loaded libraries. A symbol lookup allows for searching\n- * symbols by name, see {@link SymbolLookup#lookup(String)}. A library symbol is modelled as a zero-length {@linkplain MemorySegment memory segment};\n- * it can be used directly to create a {@linkplain Linker#downcallHandle(Addressable, FunctionDescriptor) downcall method handle},\n- * or it can be {@linkplain MemorySegment#ofAddress(MemoryAddress, long, MemorySession) resized} accordingly, if it models\n- * a <em>global variable<\/em> that needs to be dereferenced.\n+ * A <em>symbol lookup<\/em> is an object that may be used to retrieve the address of a symbol in one or more libraries.\n+ * A symbol is a named entity, such as a function or a global variable.\n@@ -51,3 +48,2 @@\n- * Clients can obtain a {@linkplain #loaderLookup() loader lookup},\n- * which can be used to find symbols in libraries loaded by the current classloader (e.g. using {@link System#load(String)},\n- * or {@link System#loadLibrary(String)}).\n+ * A symbol lookup is created with respect to a particular library (or libraries). Subsequently, the {@link SymbolLookup#lookup(String)}\n+ * method takes the name of a symbol and returns the address of the symbol in that library.\n@@ -55,2 +51,23 @@\n- * Alternatively, clients can search symbols in the standard libraries associated with a {@link Linker} instance.\n- * The set of symbols available in a linker lookup is unspecified, as it depends on the platform and on the operating system.\n+ * The address of a symbol is modelled as a zero-length {@linkplain MemorySegment memory segment}. The segment can be used in different ways:\n+ * <ul>\n+ *     <li>It can be passed to a {@link Linker} to create a downcall method handle, which can then be used to call the foreign function at the segment's base address.<\/li>\n+ *     <li>It can be passed to an existing {@linkplain Linker#downcallHandle(FunctionDescriptor) downcall method handle}, as an argument to the underlying foreign function.<\/li>\n+ *     <li>It can be {@linkplain MemorySegment#set(ValueLayout.OfAddress, long, Addressable) stored} inside another memory segment.<\/li>\n+ *     <li>It can be used to dereference memory associated with a global variable (this might require\n+ *     {@link MemorySegment#ofAddress(MemoryAddress, long, MemorySession) resizing} the segment first).<\/li>\n+ * <\/ul>\n+ *\n+ * <h2>Obtaining a symbol lookup<\/h2>\n+ *\n+ * The factory methods {@link #libraryLookup(String, MemorySession)} and {@link #libraryLookup(Path, MemorySession)}\n+ * create a symbol lookup for a library known to the operating system. The library is specified by either its name or a path.\n+ * The library is loaded if not already loaded. The symbol lookup, which is known as a <em>library lookup<\/em>, is associated\n+ * with a {@linkplain  MemorySession memory session}; when the session is {@linkplain MemorySession#close() closed}, the library is unloaded:\n+ *\n+ * {@snippet lang=java :\n+ * try (MemorySession session = MemorySession.openConfined()) {\n+ *     SymbolLookup libGL = SymbolLookup.libraryLookup(\"libGL.so\"); \/\/ libGL.so loaded here\n+ *     MemorySegment glGetString = libGL.lookup(\"glGetString\");\n+ *     ...\n+ * } \/\/  libGL.so unloaded here\n+ * }\n@@ -58,3 +75,43 @@\n- * Finally, clients can load a library and obtain a {@linkplain #libraryLookup(Path, MemorySession) library lookup} which can be used\n- * to find symbols in that library. A library lookup is associated with a {@linkplain  MemorySession memory session},\n- * and the library it refers to is unloaded when the session is {@linkplain MemorySession#close() closed}.\n+ * If a library was previously loaded through JNI, i.e., by {@link System#load(String)}\n+ * or {@link System#loadLibrary(String)}, then the library was also associated with a particular class loader. The factory\n+ * method {@link #loaderLookup()} creates a symbol lookup for all the libraries associated with the caller's class loader:\n+ *\n+ * {@snippet lang=java :\n+ * System.loadLibrary(\"GL\"); \/\/ libGL.so loaded here\n+ * ...\n+ * SymbolLookup libGL = SymbolLookup.loaderLookup();\n+ * MemorySegment glGetString = libGL.lookup(\"glGetString\");\n+ * }\n+ *\n+ * This symbol lookup, which is known as a <em>loader lookup<\/em>, is dynamic with respect to the libraries associated\n+ * with the class loader. If other libraries are subsequently loaded through JNI and associated with the class loader,\n+ * then the loader lookup will expose their symbols automatically.\n+ * <p>\n+ * Note that a loader lookup only exposes symbols in libraries that were previously loaded through JNI, i.e.,\n+ * by {@link System#load(String)} or {@link System#loadLibrary(String)}. A loader lookup does not expose symbols in libraries\n+ * that were loaded in the course of creating a library lookup:\n+ *\n+ * {@snippet lang=java :\n+ * libraryLookup(\"libGL.so\", session).lookup(\"glGetString\").isPresent(); \/\/ true\n+ * loaderLookup().lookup(\"glGetString\").isPresent(); \/\/ false\n+ * }\n+ *\n+ * Note also that a library lookup for library {@code L} exposes symbols in {@code L} even if {@code L} was previously loaded\n+ * through JNI (the association with a class loader is immaterial to the library lookup):\n+ *\n+ * {@snippet lang=java :\n+ * System.loadLibrary(\"GL\"); \/\/ libGL.so loaded here\n+ * libraryLookup(\"libGL.so\", session).lookup(\"glGetString\").isPresent(); \/\/ true\n+ * }\n+ *\n+ * <p>\n+ * Finally, each {@link Linker} provides a symbol lookup for libraries that are commonly used on the OS and processor\n+ * combination supported by that {@link Linker}. This symbol lookup, which is known as a <em>default lookup<\/em>,\n+ * helps clients to quickly find addresses of well-known symbols. For example, a {@link Linker} for Linux\/x64 might choose to\n+ * expose symbols in {@code libc} through the default lookup:\n+ *\n+ * {@snippet lang=java :\n+ * Linker nativeLinker = Linker.nativeLinker();\n+ * SymbolLookup stdlib = nativeLinker.defaultLookup();\n+ * MemorySegment malloc = stdlib.lookup(\"malloc\");\n+ * }\n@@ -67,2 +124,1 @@\n-     * Looks up a symbol with the given name in this lookup.\n-     *\n+     * Returns the address of the symbol with the given name.\n@@ -70,1 +126,1 @@\n-     * @return the lookup symbol (if any).\n+     * @return a zero-length memory segment whose base address indicates the address of the symbol, if found.\n@@ -75,3 +131,14 @@\n-     * Returns a symbol lookup suitable to find symbols in shared libraries associated with the caller's classloader.\n-     * The returned lookup returns symbols backed by a non-closeable, shared scope which keeps the caller's classloader\n-     * <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">reachable<\/a>.\n+     * Returns a symbol lookup for symbols in the libraries associated with the caller's class loader.\n+     * <p>\n+     * A library is associated with a class loader {@code CL} when the library is loaded via an invocation of\n+     * {@link System#load(String)} or {@link System#loadLibrary(String)} from code in a class defined by {@code CL}.\n+     * If that code makes further invocations of {@link System#load(String)} or {@link System#loadLibrary(String)},\n+     * then more libraries are loaded and associated with {@code CL}. The symbol lookup returned by this method is always\n+     * current: it reflects all the libraries associated with the relevant class loader, even if they were loaded after\n+     * this method returned.\n+     * <p>\n+     * Libraries associated with a class loader are unloaded when the class loader becomes\n+     * <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>. The symbol lookup\n+     * returned by this method is backed by a {@linkplain MemorySession#asNonCloseable() non-closeable}, shared memory\n+     * session which keeps the caller's class loader reachable. Therefore, libraries associated with the caller's class\n+     * loader are kept loaded (and their symbols available) as long as a loader lookup for that class loader is reachable.\n@@ -79,1 +146,1 @@\n-     * @return a symbol lookup suitable to find symbols in libraries loaded by the caller's classloader.\n+     * @return a symbol lookup for symbols in the libraries associated with the caller's class loader.\n@@ -99,4 +166,6 @@\n-     * Loads a library with the given name and creates a symbol lookup suitable to find symbols in that library.\n-     * The library will be unloaded when the provided memory session is {@linkplain MemorySession#close() closed}.\n-     * @apiNote The process of resolving a library name is platform-specific. For instance, on POSIX\n-     * systems, the library name is resolved according to the specification of the {@code dlopen} function.\n+     * Loads a library with the given name (if not already loaded) and creates a symbol lookup for symbols in that library.\n+     * The library will be unloaded when the provided memory session is {@linkplain MemorySession#close() closed},\n+     * if no other library lookup is still using it.\n+     * @implNote The process of resolving a library name is OS-specific. For instance, in a POSIX-compliant OS,\n+     * the library name is resolved according to the specification of the {@code dlopen} function for that OS.\n+     * In Windows, the library name is resolved according to the specification of the {@code LoadLibrary} function.\n@@ -108,0 +177,1 @@\n+     *\n@@ -123,2 +193,3 @@\n-     * Loads a library with the given path and creates a symbol lookup suitable to find symbols in that library.\n-     * The library will be unloaded when the provided memory session is {@linkplain MemorySession#close() closed}.\n+     * Loads a library from the given path (if not already loaded) and creates a symbol lookup for symbols\n+     * in that library. The library will be unloaded when the provided memory session is {@linkplain MemorySession#close() closed},\n+     * if no other library lookup is still using it.\n@@ -130,0 +201,3 @@\n+     *\n+     * @implNote On Linux, the functionalities provided by this factory method and the returned symbol lookup are\n+     * implemented using the {@code dlopen}, {@code dlsym} and {@code dlclose} functions.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":100,"deletions":26,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n- * inside shared libraries; the second is used to model the signature of foreign functions, while the third provides\n+ * inside libraries; the second is used to model the signature of foreign functions, while the third provides\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -102,2 +102,2 @@\n-    public Optional<MemorySegment> lookup(String name) {\n-        return SystemLookup.getInstance().lookup(name);\n+    public SystemLookup defaultLookup() {\n+        return SystemLookup.getInstance();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -101,2 +101,2 @@\n-    public Optional<MemorySegment> lookup(String name) {\n-        return SystemLookup.getInstance().lookup(name);\n+    public SystemLookup defaultLookup() {\n+        return SystemLookup.getInstance();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -106,2 +106,2 @@\n-    public Optional<MemorySegment> lookup(String name) {\n-        return SystemLookup.getInstance().lookup(name);\n+    public SystemLookup defaultLookup() {\n+        return SystemLookup.getInstance();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -107,2 +107,2 @@\n-    public Optional<MemorySegment> lookup(String name) {\n-        return SystemLookup.getInstance().lookup(name);\n+    public SystemLookup defaultLookup() {\n+        return SystemLookup.getInstance();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-    public final static class ScopedAccessError extends Error {\n+    public static final class ScopedAccessError extends Error {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-            LINKER.lookup(\"free\").get(), FunctionDescriptor.ofVoid(ValueLayout.ADDRESS));\n+            LINKER.defaultLookup().lookup(\"free\").get(), FunctionDescriptor.ofVoid(ValueLayout.ADDRESS));\n@@ -92,1 +92,1 @@\n-            LINKER.lookup(\"malloc\").get(), FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.JAVA_LONG));\n+            LINKER.defaultLookup().lookup(\"malloc\").get(), FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.JAVA_LONG));\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-        final static MethodHandle strcat = abi.downcallHandle(abi.lookup(\"strcat\").get(),\n+        final static MethodHandle strcat = abi.downcallHandle(abi.defaultLookup().lookup(\"strcat\").get(),\n@@ -159,1 +159,2 @@\n-        final static MethodHandle strcmp = abi.downcallHandle(abi.lookup(\"strcmp\").get(),\n+\n+        final static MethodHandle strcmp = abi.downcallHandle(abi.defaultLookup().lookup(\"strcmp\").get(),\n@@ -162,1 +163,1 @@\n-        final static MethodHandle puts = abi.downcallHandle(abi.lookup(\"puts\").get(),\n+        final static MethodHandle puts = abi.downcallHandle(abi.defaultLookup().lookup(\"puts\").get(),\n@@ -165,1 +166,1 @@\n-        final static MethodHandle strlen = abi.downcallHandle(abi.lookup(\"strlen\").get(),\n+        final static MethodHandle strlen = abi.downcallHandle(abi.defaultLookup().lookup(\"strlen\").get(),\n@@ -168,1 +169,1 @@\n-        final static MethodHandle gmtime = abi.downcallHandle(abi.lookup(\"gmtime\").get(),\n+        final static MethodHandle gmtime = abi.downcallHandle(abi.defaultLookup().lookup(\"gmtime\").get(),\n@@ -171,1 +172,1 @@\n-        final static MethodHandle qsort = abi.downcallHandle(abi.lookup(\"qsort\").get(),\n+        final static MethodHandle qsort = abi.downcallHandle(abi.defaultLookup().lookup(\"qsort\").get(),\n@@ -178,1 +179,1 @@\n-        final static MethodHandle rand = abi.downcallHandle(abi.lookup(\"rand\").get(),\n+        final static MethodHandle rand = abi.downcallHandle(abi.defaultLookup().lookup(\"rand\").get(),\n@@ -181,1 +182,1 @@\n-        final static MethodHandle vprintf = abi.downcallHandle(abi.lookup(\"vprintf\").get(),\n+        final static MethodHandle vprintf = abi.downcallHandle(abi.defaultLookup().lookup(\"vprintf\").get(),\n@@ -184,1 +185,1 @@\n-        final static Addressable printfAddr = abi.lookup(\"printf\").get();\n+        final static Addressable printfAddr = abi.defaultLookup().lookup(\"printf\").get();\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import java.lang.foreign.SymbolLookup;\n@@ -42,1 +41,1 @@\n-        assertTrue(Linker.nativeLinker().lookup(\"nonExistentSymbol\").isEmpty());\n+        assertTrue(Linker.nativeLinker().defaultLookup().lookup(\"nonExistentSymbol\").isEmpty());\n","filename":"test\/jdk\/java\/foreign\/TestFallbackLookup.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-            LINKER.lookup(\"free\").get(), FunctionDescriptor.ofVoid(ValueLayout.ADDRESS));\n+            LINKER.defaultLookup().lookup(\"free\").get(), FunctionDescriptor.ofVoid(ValueLayout.ADDRESS));\n@@ -78,1 +78,1 @@\n-            LINKER.lookup(\"malloc\").get(), FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.JAVA_LONG));\n+            LINKER.defaultLookup().lookup(\"malloc\").get(), FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.JAVA_LONG));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CLayouts.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-    static Addressable qsort_addr = abi.lookup(\"qsort\").get();\n+    static Addressable qsort_addr = abi.defaultLookup().lookup(\"qsort\").get();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/QSort.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-        STRLEN = abi.downcallHandle(abi.lookup(\"strlen\").get(),\n+        STRLEN = abi.downcallHandle(abi.defaultLookup().lookup(\"strlen\").get(),\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/StrLenTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}