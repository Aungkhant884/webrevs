{"files":[{"patch":"@@ -34,2 +34,2 @@\n- * The {@link Addressable} type is used by the {@linkplain CLinker C linker} to model the types of\n- * {@linkplain CLinker#downcallHandle(FunctionDescriptor) downcall handle} parameters that must be passed <em>by reference<\/em>\n+ * The {@link Addressable} type is used by the {@linkplain Linker C linker} to model the types of\n+ * {@linkplain Linker#downcallHandle(FunctionDescriptor) downcall handle} parameters that must be passed <em>by reference<\/em>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Addressable.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,248 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package java.lang.foreign;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodType;\n-\n-import jdk.internal.foreign.abi.SharedUtils;\n-import jdk.internal.foreign.abi.aarch64.linux.LinuxAArch64Linker;\n-import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64Linker;\n-import jdk.internal.foreign.abi.x64.sysv.SysVx64Linker;\n-import jdk.internal.foreign.abi.x64.windows.Windowsx64Linker;\n-import jdk.internal.javac.PreviewFeature;\n-import jdk.internal.reflect.CallerSensitive;\n-import jdk.internal.reflect.Reflection;\n-\n-\/**\n- * A C linker implements the C Application Binary Interface (ABI) calling conventions.\n- * Instances of this interface can be used to link foreign functions in native libraries that\n- * follow the JVM's target platform C ABI. A C linker provides two main capabilities: first, it allows Java code\n- * to <em>link<\/em> foreign functions into a so called <em>downcall method handle<\/em>; secondly, it allows\n- * native code to call Java method handles via the generation of <em>upcall stubs<\/em>.\n- *\n- * <h2><a id = \"downcall-method-handles\">Downcall method handles<\/a><\/h2>\n- *\n- * {@linkplain #downcallHandle(FunctionDescriptor) Linking a foreign function} is a process which requires a function descriptor,\n- * a set of memory layouts which, together, specify the signature of the foreign function to be linked, and returns,\n- * when complete, a downcall method handle, that is, a method handle that can be used to invoke the target native function.\n- * The Java {@linkplain java.lang.invoke.MethodType method type} associated with the returned method handle is\n- * {@linkplain #downcallType(FunctionDescriptor) derived} from the argument and return layouts in the function descriptor.\n- * More specifically, given each layout {@code L} in the function descriptor, a corresponding carrier {@code C} is inferred,\n- * as described below:\n- * <ul>\n- * <li>if {@code L} is a {@link ValueLayout} with carrier {@code E} then there are two cases:\n- *     <ul>\n- *         <li>if {@code L} occurs in a parameter position and {@code E} is {@code MemoryAddress.class},\n- *         then {@code C = Addressable.class};<\/li>\n- *         <li>otherwise, {@code C = E};\n- *     <\/ul><\/li>\n- * <li>or, if {@code L} is a {@link GroupLayout}, then {@code C} is set to {@code MemorySegment.class}<\/li>\n- * <\/ul>\n- * <p>\n- * The downcall method handle type, derived as above, might be decorated by additional leading parameters,\n- * in the given order if both are present:\n- * <ul>\n- * <li>If the downcall method handle is created {@linkplain #downcallHandle(FunctionDescriptor) without specifying a target address},\n- * the downcall method handle type features a leading parameter of type {@link Addressable}, from which the\n- * address of the target native function can be derived.<\/li>\n- * <li>If the function descriptor's return layout is a group layout, the resulting downcall method handle accepts\n- * an additional leading parameter of type {@link SegmentAllocator}, which is used by the linker runtime to allocate the\n- * memory region associated with the struct returned by the downcall method handle.<\/li>\n- * <\/ul>\n- * <p>Variadic functions, declared in C either with a trailing ellipses ({@code ...}) at the end of the formal parameter\n- * list or with an empty formal parameter list, are not supported directly. However, it is possible to link a native\n- * variadic function by using a {@linkplain FunctionDescriptor#asVariadic(MemoryLayout...) <em>variadic<\/em>} function descriptor,\n- * in which the specialized signature of a given variable arity callsite is described in full. Alternatively,\n- * if the foreign library allows it, clients might also be able to interact with variable arity methods\n- * by passing a trailing parameter of type {@link VaList}.\n- *\n- * <h2><a id = \"upcall-stubs\">Upcall stubs<\/a><\/h2>\n- *\n- * {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, MemorySession) Creating an upcall stub} requires a method\n- * handle and a function descriptor; in this case, the set of memory layouts in the function descriptor\n- * specify the signature of the function pointer associated with the upcall stub.\n- * <p>\n- * The type of the provided method handle has to match the Java {@linkplain java.lang.invoke.MethodType method type}\n- * associated with the upcall stub, which is derived from the argument and return layouts in the function descriptor.\n- * More specifically, given each layout {@code L} in the function descriptor, a corresponding carrier {@code C} is inferred, as described below:\n- * <ul>\n- * <li>if {@code L} is a {@link ValueLayout} with carrier {@code E} then there are two cases:\n- *     <ul>\n- *         <li>if {@code L} occurs in a return position and {@code E} is {@code MemoryAddress.class},\n- *         then {@code C = Addressable.class};<\/li>\n- *         <li>otherwise, {@code C = E};\n- *     <\/ul><\/li>\n- * <li>or, if {@code L} is a {@link GroupLayout}, then {@code C} is set to {@code MemorySegment.class}<\/li>\n- * <\/ul>\n- * Upcall stubs are modelled by instances of type {@link MemorySegment}; upcall stubs can be passed by reference to other\n- * downcall method handles (as {@link MemorySegment} implements the {@link Addressable} interface) and,\n- * when no longer required, they can be {@linkplain MemorySession#close() released}, via their associated {@linkplain MemorySession session}.\n- *\n- * <h2>Safety considerations<\/h2>\n- *\n- * Creating a downcall method handle is intrinsically unsafe. A symbol in a native library does not, in general,\n- * contain enough signature information (e.g. arity and types of native function parameters). As a consequence,\n- * the linker runtime cannot validate linkage requests. When a client interacts with a downcall method handle obtained\n- * through an invalid linkage request (e.g. by specifying a function descriptor featuring too many argument layouts),\n- * the result of such interaction is unspecified and can lead to JVM crashes. On downcall handle invocation,\n- * the linker runtime guarantees the following for any argument that is a memory resource {@code R} (of type {@link MemorySegment}\n- * or {@link VaList}):\n- * <ul>\n- *     <li>The memory session of {@code R} is {@linkplain MemorySession#isAlive() alive}. Otherwise, the invocation throws\n- *     {@link IllegalStateException};<\/li>\n- *     <li>The invocation occurs in same thread as the one {@linkplain MemorySession#ownerThread() owning} the memory session of {@code R},\n- *     if said session is confined. Otherwise, the invocation throws {@link IllegalStateException}; and<\/li>\n- *     <li>The memory session of {@code R} is {@linkplain MemorySession#whileAlive(Runnable) kept alive} (and cannot be closed) during the invocation.<\/li>\n- *<\/ul>\n- * <p>\n- * When creating upcall stubs the linker runtime validates the type of the target method handle against the provided\n- * function descriptor and report an error if any mismatch is detected. As for downcalls, JVM crashes might occur,\n- * if the native code casts the function pointer associated with an upcall stub to a type\n- * that is incompatible with the provided function descriptor. Moreover, if the target method\n- * handle associated with an upcall stub returns a {@linkplain MemoryAddress native address}, clients must ensure\n- * that this address cannot become invalid after the upcall completes. This can lead to unspecified behavior,\n- * and even JVM crashes, since an upcall is typically executed in the context of a downcall method handle invocation.\n- *\n- * @implSpec\n- * Implementations of this interface are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n- *\n- * @implNote\n- * On unsupported platforms this class will fail to initialize with an {@link ExceptionInInitializerError}.\n- *\n- * @since 19\n- *\/\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-public sealed interface CLinker permits Windowsx64Linker, SysVx64Linker, LinuxAArch64Linker, MacOsAArch64Linker {\n-\n-    \/**\n-     * Returns the C linker for the current platform.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @return a linker for this system.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    static CLinker systemCLinker() {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), CLinker.class, \"systemCLinker\");\n-        return SharedUtils.getSystemLinker();\n-    }\n-\n-    \/**\n-     * Creates a method handle which can be used to call a target foreign function with the given signature and address.\n-     * <p>\n-     * If the provided method type's return type is {@code MemorySegment}, then the resulting method handle features\n-     * an additional prefix parameter, of type {@link SegmentAllocator}, which will be used by the linker runtime\n-     * to allocate structs returned by-value.\n-     * <p>\n-     * Calling this method is equivalent to the following code:\n-     * {@snippet lang=java :\n-     * linker.downcallHandle(function).bindTo(symbol);\n-     * }\n-     *\n-     * @param symbol the address of the target function.\n-     * @param function the function descriptor of the target function.\n-     * @return a downcall method handle. The method handle type is <a href=\"CLinker.html#downcall-method-handles\"><em>inferred<\/em><\/a>\n-     * @throws IllegalArgumentException if the provided function descriptor contains either a sequence or a padding layout,\n-     * or if the symbol is {@link MemoryAddress#NULL}\n-     *\/\n-    default MethodHandle downcallHandle(Addressable symbol, FunctionDescriptor function) {\n-        SharedUtils.checkSymbol(symbol);\n-        return downcallHandle(function).bindTo(symbol);\n-    }\n-\n-    \/**\n-     * Creates a method handle which can be used to call a target foreign function with the given signature.\n-     * The resulting method handle features a prefix parameter (as the first parameter) corresponding to the foreign function\n-     * entry point, of type {@link Addressable}, which is used to specify the address of the target function\n-     * to be called.\n-     * <p>\n-     * If the provided function descriptor's return layout is a {@link GroupLayout}, then the resulting method handle features an\n-     * additional prefix parameter (inserted immediately after the address parameter), of type {@link SegmentAllocator}),\n-     * which will be used by the linker runtime to allocate structs returned by-value.\n-     * <p>\n-     * The returned method handle will throw an {@link IllegalArgumentException} if the {@link Addressable} parameter passed to it is\n-     * associated with the {@link MemoryAddress#NULL} address, or a {@link NullPointerException} if that parameter is {@code null}.\n-     *\n-     * @param function the function descriptor of the target function.\n-     * @return a downcall method handle. The method handle type is <a href=\"CLinker.html#downcall-method-handles\"><em>inferred<\/em><\/a>\n-     * from the provided function descriptor.\n-     * @throws IllegalArgumentException if the provided function descriptor contains either a sequence or a padding layout.\n-     *\/\n-    MethodHandle downcallHandle(FunctionDescriptor function);\n-\n-    \/**\n-     * Creates a native stub which can be passed to other foreign functions as a function pointer, with the given\n-     * memory session. Calling such a function pointer from native code will result in the execution of the provided\n-     * method handle.\n-     * <p>\n-     * The returned memory segment's base address points to the newly allocated native stub, and is associated with\n-     * the provided memory session. When such session is closed, the corresponding native stub will be deallocated.\n-     * <p>\n-     * The target method handle should not throw any exceptions. If the target method handle does throw an exception,\n-     * the VM will exit with a non-zero exit code. To avoid the VM aborting due to an uncaught exception, clients\n-     * could wrap all code in the target method handle in a try\/catch block that catches any {@link Throwable}, for\n-     * instance by using the {@link java.lang.invoke.MethodHandles#catchException(MethodHandle, Class, MethodHandle)}\n-     * method handle combinator, and handle exceptions as desired in the corresponding catch block.\n-     *\n-     * @param target the target method handle.\n-     * @param function the upcall stub function descriptor.\n-     * @param session the upcall stub memory session.\n-     * @return a zero-length segment whose base address is the address of the native stub.\n-     * @throws IllegalArgumentException if the provided descriptor contains either a sequence or a padding layout,\n-     * or if it is determined that the target method handle can throw an exception, or if the target method handle\n-     * has a type that does not match the upcall stub <a href=\"CLinker.html#upcall-stubs\"><em>inferred type<\/em><\/a>.\n-     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}, or if access occurs from\n-     * a thread other than the thread {@linkplain MemorySession#ownerThread() owning} {@code session}.\n-     *\/\n-    MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, MemorySession session);\n-\n-    \/**\n-     * {@return the downcall method handle {@linkplain MethodType type} associated with the given function descriptor}\n-     * @param functionDescriptor a function descriptor.\n-     * @throws IllegalArgumentException if one or more layouts in the function descriptor are not supported\n-     * (e.g. if they are sequence layouts or padding layouts).\n-     *\/\n-    static MethodType downcallType(FunctionDescriptor functionDescriptor) {\n-        return SharedUtils.inferMethodType(functionDescriptor, false);\n-    }\n-\n-    \/**\n-     * {@return the method handle {@linkplain MethodType type} associated with an upcall stub with the given function descriptor}\n-     * @param functionDescriptor a function descriptor.\n-     * @throws IllegalArgumentException if one or more layouts in the function descriptor are not supported\n-     * (e.g. if they are sequence layouts or padding layouts).\n-     *\/\n-    static MethodType upcallType(FunctionDescriptor functionDescriptor) {\n-        return SharedUtils.inferMethodType(functionDescriptor, true);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/CLinker.java","additions":0,"deletions":248,"binary":false,"changes":248,"status":"deleted"},{"patch":"@@ -42,2 +42,2 @@\n- * {@linkplain CLinker#downcallHandle(Addressable, FunctionDescriptor) downcall method handles} or\n- * {@linkplain CLinker#upcallStub(MethodHandle, FunctionDescriptor, MemorySession) upcall stubs}.\n+ * {@linkplain Linker#downcallHandle(Addressable, FunctionDescriptor) downcall method handles} or\n+ * {@linkplain Linker#upcallStub(MethodHandle, FunctionDescriptor, MemorySession) upcall stubs}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/FunctionDescriptor.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n- *     <li>By invoking a {@linkplain CLinker#downcallHandle(FunctionDescriptor) downcall method handle} which returns a pointer;<\/li>\n+ *     <li>By invoking a {@linkplain Linker#downcallHandle(FunctionDescriptor) downcall method handle} which returns a pointer;<\/li>\n@@ -43,1 +43,1 @@\n- *     <li>By the invocation of an {@linkplain CLinker#upcallStub(MethodHandle, FunctionDescriptor, MemorySession) upcall stub} which accepts a pointer.<\/li>\n+ *     <li>By the invocation of an {@linkplain Linker#upcallStub(MethodHandle, FunctionDescriptor, MemorySession) upcall stub} which accepts a pointer.<\/li>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryAddress.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -227,1 +227,1 @@\n- * custom mapped memory segment factories; using {@link CLinker}, e.g. on Linux, it is possible to call {@code mmap}\n+ * custom mapped memory segment factories; using {@link Linker}, e.g. on Linux, it is possible to call {@code mmap}\n@@ -587,1 +587,1 @@\n-     * different from the native order, a byte swap operation will be performed on each array element.\n+     * different from the {@linkplain ByteOrder#nativeOrder native order}, a byte swap operation will be performed on each array element.\n@@ -599,1 +599,1 @@\n-     * different from the native order, a byte swap operation will be performed on each array element.\n+     * different from the {@linkplain ByteOrder#nativeOrder native order}, a byte swap operation will be performed on each array element.\n@@ -611,1 +611,1 @@\n-     * different from the native order, a byte swap operation will be performed on each array element.\n+     * different from the {@linkplain ByteOrder#nativeOrder native order}, a byte swap operation will be performed on each array element.\n@@ -623,1 +623,1 @@\n-     * different from the native order, a byte swap operation will be performed on each array element.\n+     * different from the {@linkplain ByteOrder#nativeOrder native order}, a byte swap operation will be performed on each array element.\n@@ -635,1 +635,1 @@\n-     * different from the native order, a byte swap operation will be performed on each array element.\n+     * different from the {@linkplain ByteOrder#nativeOrder native order}, a byte swap operation will be performed on each array element.\n@@ -647,1 +647,1 @@\n-     * different from the native order, a byte swap operation will be performed on each array element.\n+     * different from the {@linkplain ByteOrder#nativeOrder native order}, a byte swap operation will be performed on each array element.\n@@ -659,1 +659,1 @@\n-     * different from the native order, a byte swap operation will be performed on each array element.\n+     * different from the {@linkplain ByteOrder#nativeOrder native order}, a byte swap operation will be performed on each array element.\n@@ -807,3 +807,4 @@\n-     * This method can be useful when interacting with custom\n-     * native memory sources (e.g. custom allocators), where an address to some\n-     * underlying memory region is typically obtained from native code (often as a plain {@code long} value).\n+     * This method can be useful when interacting with custom memory sources (e.g. custom allocators),\n+     * where an address to some underlying memory region is typically obtained from foreign code\n+     * (often as a plain {@code long} value).\n+     * <p>\n@@ -1735,1 +1736,1 @@\n-     * different from the native order, a byte swap operation will be performed on each array element.\n+     * different from the {@linkplain ByteOrder#nativeOrder native order}, a byte swap operation will be performed on each array element.\n@@ -1787,1 +1788,1 @@\n-     * different from the native order, a byte swap operation will be performed on each array element.\n+     * different from the {@linkplain ByteOrder#nativeOrder native order}, a byte swap operation will be performed on each array element.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n- * @see CLinker\n+ * @see Linker\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySession.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,4 +43,2 @@\n- * This interface can be seen as a thin wrapper around the basic capabilities for\n- * {@linkplain MemorySegment#allocateNative(long, long, MemorySession) creating} native segments;\n- * since {@link SegmentAllocator} is a <em>functional interface<\/em>,\n- * clients can easily obtain a native allocator by using either a lambda expression or a method reference.\n+ * This interface is a {@linkplain FunctionalInterface functional interface}: clients can easily obtain a new segment allocator\n+ * by using either a lambda expression or a method reference.\n@@ -50,1 +48,1 @@\n- *     <li>{@link #newNativeArena(MemorySession)} creates a more efficient arena-style native allocator, where memory\n+ *     <li>{@link #newNativeArena(MemorySession)} creates a more efficient arena-style allocator, where off-heap memory\n@@ -52,1 +50,3 @@\n- *     <li>{@link #prefixAllocator(MemorySegment)} creates an allocator which wraps a segment (either on-heap or off-heap)\n+ *     <li>{@link #implicitAllocator()} obtains an allocator which allocates native memory segment in independent,\n+ *     {@linkplain MemorySession#openImplicit() implicit memory sessions}; and<\/li>\n+ *     <li>{@link #prefixAllocator(MemorySegment)} obtains an allocator which wraps a segment (either on-heap or off-heap)\n@@ -58,3 +58,3 @@\n- * {@linkplain CLinker#downcallHandle(FunctionDescriptor) downcall method handles} can accept an additional\n- * {@link SegmentAllocator} parameter if the underlying native function is known to return a struct by-value. Effectively,\n- * the allocator parameter tells the linker runtime where to store the return value of the native function.\n+ * {@linkplain Linker#downcallHandle(FunctionDescriptor) downcall method handles} can accept an additional\n+ * {@link SegmentAllocator} parameter if the underlying foreign function is known to return a struct by-value. Effectively,\n+ * the allocator parameter tells the linker runtime where to store the return value of the foreign function.\n@@ -340,2 +340,3 @@\n-     * Creates a native unbounded arena-based allocator, with predefined block size and maximum arena size,\n-     * associated with the provided memory session. Equivalent to the following code:\n+     * Creates an unbounded arena-based allocator used to allocate native memory segments.\n+     * The returned allocator features a predefined block size and maximum arena size, and the segments it allocates\n+     * are associated with the provided memory session. Equivalent to the following code:\n@@ -346,1 +347,1 @@\n-     * @param session the memory session associated with the segments returned by the arena-based allocator.\n+     * @param session the memory session associated with the segments allocated by the arena-based allocator.\n@@ -356,2 +357,3 @@\n-     * Creates a native unbounded arena-based allocator, with block size set to the specified arena size, associated with\n-     * the provided memory session, with the given arena size. Equivalent to the following code:\n+     * Creates an arena-based allocator used to allocate native memory segments.\n+     * The returned allocator features a block size set to the specified arena size, and the native segments\n+     * it allocates are associated with the provided memory session. Equivalent to the following code:\n@@ -363,1 +365,1 @@\n-     * @param session the memory session associated with the segments returned by the arena-based allocator.\n+     * @param session the memory session associated with the segments allocated by the arena-based allocator.\n@@ -374,2 +376,3 @@\n-     * Creates a native arena-based allocator, associated with the provided memory session,\n-     * with the given arena size and block size.\n+     * Creates an arena-based allocator used to allocate native memory segments. The returned allocator features\n+     * the given block size {@code B} and the given arena size {@code A}, and the native segments\n+     * it allocates are associated with the provided memory session.\n@@ -377,2 +380,2 @@\n-     * The returned allocator {@linkplain MemorySegment#allocateNative(long, MemorySession) allocates} a memory segment\n-     * {@code S} of the specified block size and then responds to allocation requests in one of the following ways:\n+     * The allocator arena is first initialized by {@linkplain MemorySegment#allocateNative(long, MemorySession) allocating} a\n+     * native memory segment {@code S} of size {@code B}. The allocator then responds to allocation requests in one of the following ways:\n@@ -383,1 +386,1 @@\n-     *     slices which fits that allocation request, allocate a new segment {@code S'}, which has same size as {@code S}\n+     *     slices which fits that allocation request, allocate a new segment {@code S'}, with size {@code B},\n@@ -393,1 +396,1 @@\n-     * exceeds the arena size, or the system capacity. Furthermore, the returned allocator is not thread safe.\n+     * exceeds the arena size {@code A}, or the system capacity. Furthermore, the returned allocator is not thread safe.\n@@ -441,1 +444,1 @@\n-     * Returns a native allocator which allocates segments in independent {@linkplain MemorySession#openImplicit() implicit memory sessions}.\n+     * Returns an allocator which allocates native segments in independent {@linkplain MemorySession#openImplicit() implicit memory sessions}.\n@@ -447,1 +450,1 @@\n-     * @return a native allocator which allocates segments in independent {@linkplain MemorySession#openImplicit() implicit memory sessions}.\n+     * @return an allocator which allocates native segments in independent {@linkplain MemorySession#openImplicit() implicit memory sessions}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":26,"deletions":23,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n- * it can be used directly to create a {@linkplain CLinker#downcallHandle(Addressable, FunctionDescriptor) downcall method handle},\n+ * it can be used directly to create a {@linkplain Linker#downcallHandle(Addressable, FunctionDescriptor) downcall method handle},\n@@ -54,3 +54,2 @@\n- * Alternatively, clients can search symbols in the standard C library using a {@linkplain SymbolLookup#systemLookup() system lookup},\n- * which conveniently implements this interface. The set of symbols available in the system lookup is unspecified,\n- * as it depends on the platform and on the operating system.\n+ * Alternatively, clients can search symbols in the standard libraries associated with a {@link Linker} instance.\n+ * The set of symbols available in a linker lookup is unspecified, as it depends on the platform and on the operating system.\n@@ -75,2 +74,2 @@\n-     * Returns a symbol lookup suitable to find symbols in native libraries associated with the caller's classloader.\n-     * The returned lookup returns native symbols backed by a non-closeable, shared scope which keeps the caller's classloader\n+     * Returns a symbol lookup suitable to find symbols in shared libraries associated with the caller's classloader.\n+     * The returned lookup returns symbols backed by a non-closeable, shared scope which keeps the caller's classloader\n@@ -98,9 +97,0 @@\n-    \/**\n-     * Returns a system lookup suitable to find symbols in the standard C libraries. The set of symbols\n-     * available for lookup is unspecified, as it depends on the platform and on the operating system.\n-     * @return a system-specific library lookup which is suitable to find symbols in the standard C libraries.\n-     *\/\n-    static SymbolLookup systemLookup() {\n-        return SystemLookup.getInstance();\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":5,"deletions":15,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- * can be passed by reference e.g. to a {@linkplain CLinker#downcallHandle(FunctionDescriptor) downcall method handle}.\n+ * can be passed by reference e.g. to a {@linkplain Linker#downcallHandle(FunctionDescriptor) downcall method handle}.\n@@ -193,1 +193,1 @@\n-     * If this method needs to allocate native memory, such memory will be managed by the given\n+     * If this method needs to allocate memory, such memory will be managed by the given\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/VaList.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -99,2 +99,2 @@\n- * {@link java.lang.foreign.FunctionDescriptor} and {@link java.lang.foreign.CLinker}. The first is used to look up symbols\n- * inside native libraries; the second is used to model the signature of foreign functions, while the third provides\n+ * {@link java.lang.foreign.FunctionDescriptor} and {@link java.lang.foreign.Linker}. The first is used to look up symbols\n+ * inside shared libraries; the second is used to model the signature of foreign functions, while the third provides\n@@ -102,1 +102,1 @@\n- * so that clients can perform foreign function calls directly in Java, without the need for intermediate layers of native\n+ * so that clients can perform foreign function calls directly in Java, without the need for intermediate layers of C\/C++\n@@ -109,1 +109,1 @@\n- * var linker = CLinker.systemCLinker();\n+ * var linker = Linker.nativeLinker();\n@@ -111,1 +111,1 @@\n- *     SymbolLookup.systemLookup().lookup(\"strlen\").get(),\n+ *     linker.lookup(\"strlen\").get(),\n@@ -122,1 +122,1 @@\n- * Here, we obtain a {@linkplain java.lang.foreign.SymbolLookup#systemLookup() system lookup} and we use it\n+ * Here, we obtain a {@linkplain java.lang.foreign.Linker#nativeLinker() native linker} and we use it\n@@ -125,1 +125,1 @@\n- * {@linkplain java.lang.foreign.CLinker#downcallHandle(java.lang.foreign.FunctionDescriptor) obtained}.\n+ * {@linkplain java.lang.foreign.Linker#downcallHandle(java.lang.foreign.FunctionDescriptor) obtained}.\n@@ -130,1 +130,1 @@\n- * into a foreign function call, according to the rules specified by the platform C ABI.\n+ * into a foreign function call, according to the rules specified by the ABI of the underlying platform.\n@@ -132,2 +132,2 @@\n- * interacting with native code, such as converting Java strings\n- * {@linkplain java.lang.foreign.MemorySegment#setUtf8String(long, java.lang.String) into} native strings and\n+ * interacting with foreign code, such as converting Java strings\n+ * {@linkplain java.lang.foreign.MemorySegment#setUtf8String(long, java.lang.String) into} zero-terminated, UTF-8 strings and\n@@ -139,1 +139,1 @@\n- * are fully known at segment creation. But when interacting with native libraries, clients will often receive <em>raw<\/em> pointers.\n+ * are fully known at segment creation. But when interacting with foreign functions, clients will often receive <em>raw<\/em> pointers.\n@@ -150,1 +150,1 @@\n- * MemoryAddress addr = ... \/\/ obtain address from native code\n+ * MemoryAddress addr = ... \/\/ obtain address from foreign function call\n@@ -158,1 +158,1 @@\n- * Here is how an unsafe segment can be created from a native address:\n+ * Here is how an unsafe segment can be created from a memory address:\n@@ -162,1 +162,1 @@\n- * MemoryAddress addr = ... \/\/ obtain address from native code\n+ * MemoryAddress addr = ... \/\/ obtain address from foreign function call\n@@ -168,1 +168,1 @@\n- * The {@link java.lang.foreign.CLinker} interface also allows clients to turn an existing method handle (which might point\n+ * The {@link java.lang.foreign.Linker} interface also allows clients to turn an existing method handle (which might point\n@@ -193,1 +193,1 @@\n- * {@linkplain java.lang.foreign.CLinker#upcallType(java.lang.foreign.FunctionDescriptor) derive} a method type\n+ * {@linkplain java.lang.foreign.Linker#upcallType(java.lang.foreign.FunctionDescriptor) derive} a method type\n@@ -197,1 +197,1 @@\n- * using the {@link java.lang.foreign.CLinker} interface, as follows:\n+ * using the {@link java.lang.foreign.Linker} interface, as follows:\n@@ -201,1 +201,1 @@\n- * Addressable comparFunc = CLinker.systemCLinker().upcallStub(\n+ * Addressable comparFunc = CLinker.nativeLinker().upcallStub(\n@@ -207,1 +207,1 @@\n- * {@linkplain java.lang.foreign.CLinker#upcallStub(java.lang.invoke.MethodHandle, java.lang.foreign.FunctionDescriptor, java.lang.foreign.MemorySession) create}\n+ * {@linkplain java.lang.foreign.Linker#upcallStub(java.lang.invoke.MethodHandle, java.lang.foreign.FunctionDescriptor, java.lang.foreign.MemorySession) create}\n@@ -209,1 +209,2 @@\n- * allow foreign code to call the stub for {@code intCompareHandle} according to the rules specified by the platform C ABI.\n+ * allow foreign code to call the stub for {@code intCompareHandle} according to the rules specified by the ABI of the\n+ * underlying platform.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":21,"deletions":20,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-            throw new ExceptionInInitializerError(\n+            throw new UnsupportedOperationException(\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/CABI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.foreign.CLinker;\n+import java.lang.foreign.Linker;\n@@ -270,1 +270,1 @@\n-    public static CLinker getSystemLinker() {\n+    public static Linker getSystemLinker() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.foreign.CLinker;\n+import java.lang.foreign.Linker;\n@@ -34,0 +34,2 @@\n+\n+import jdk.internal.foreign.SystemLookup;\n@@ -41,0 +43,1 @@\n+import java.util.Optional;\n@@ -47,1 +50,1 @@\n-public final class LinuxAArch64Linker implements CLinker {\n+public final class LinuxAArch64Linker implements Linker {\n@@ -98,0 +101,4 @@\n+    @Override\n+    public Optional<MemorySegment> lookup(String name) {\n+        return SystemLookup.getInstance().lookup(name);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.foreign.CLinker;\n+import java.lang.foreign.Linker;\n@@ -34,0 +34,2 @@\n+\n+import jdk.internal.foreign.SystemLookup;\n@@ -41,0 +43,1 @@\n+import java.util.Optional;\n@@ -47,1 +50,1 @@\n-public final class MacOsAArch64Linker implements CLinker {\n+public final class MacOsAArch64Linker implements Linker {\n@@ -97,0 +100,4 @@\n+    @Override\n+    public Optional<MemorySegment> lookup(String name) {\n+        return SystemLookup.getInstance().lookup(name);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.foreign.CLinker;\n+import java.lang.foreign.Linker;\n@@ -34,0 +34,2 @@\n+\n+import jdk.internal.foreign.SystemLookup;\n@@ -40,0 +42,1 @@\n+import java.util.Optional;\n@@ -45,1 +48,1 @@\n-public final class SysVx64Linker implements CLinker {\n+public final class SysVx64Linker implements Linker {\n@@ -101,0 +104,5 @@\n+\n+    @Override\n+    public Optional<MemorySegment> lookup(String name) {\n+        return SystemLookup.getInstance().lookup(name);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.foreign.CLinker;\n+import java.lang.foreign.Linker;\n@@ -33,0 +33,2 @@\n+\n+import jdk.internal.foreign.SystemLookup;\n@@ -39,0 +41,1 @@\n+import java.util.Optional;\n@@ -44,1 +47,1 @@\n-public final class Windowsx64Linker implements CLinker {\n+public final class Windowsx64Linker implements Linker {\n@@ -102,0 +105,5 @@\n+\n+    @Override\n+    public Optional<MemorySegment> lookup(String name) {\n+        return SystemLookup.getInstance().lookup(name);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-import java.lang.foreign.CLinker;\n+import java.lang.foreign.Linker;\n@@ -51,1 +51,1 @@\n-    final static CLinker abi = CLinker.systemCLinker();\n+    final static Linker abi = Linker.systemCLinker();\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestLinkToNativeRBP.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.foreign.CLinker;\n+import java.lang.foreign.Linker;\n@@ -456,1 +456,1 @@\n-    MethodHandle downcallHandle(CLinker abi, Addressable symbol, SegmentAllocator allocator, FunctionDescriptor descriptor) {\n+    MethodHandle downcallHandle(Linker abi, Addressable symbol, SegmentAllocator allocator, FunctionDescriptor descriptor) {\n","filename":"test\/jdk\/java\/foreign\/CallGeneratorHelper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.foreign.CLinker;\n+import java.lang.foreign.Linker;\n@@ -49,1 +49,1 @@\n-    static final MethodHandle INC = CLinker.systemCLinker().downcallHandle(FunctionDescriptor.ofVoid());\n+    static final MethodHandle INC = Linker.nativeLinker().downcallHandle(FunctionDescriptor.ofVoid());\n","filename":"test\/jdk\/java\/foreign\/LibraryLookupTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import java.lang.foreign.CLinker;\n@@ -28,0 +27,1 @@\n+import java.lang.foreign.Linker;\n@@ -86,1 +86,1 @@\n-    private static CLinker LINKER = CLinker.systemCLinker();\n+    private static Linker LINKER = Linker.nativeLinker();\n@@ -89,1 +89,1 @@\n-            SymbolLookup.systemLookup().lookup(\"free\").get(), FunctionDescriptor.ofVoid(ValueLayout.ADDRESS));\n+            LINKER.lookup(\"free\").get(), FunctionDescriptor.ofVoid(ValueLayout.ADDRESS));\n@@ -92,1 +92,1 @@\n-            SymbolLookup.systemLookup().lookup(\"malloc\").get(), FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.JAVA_LONG));\n+            LINKER.lookup(\"malloc\").get(), FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.JAVA_LONG));\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.CLinker;\n+import java.lang.foreign.Linker;\n@@ -63,1 +63,1 @@\n-        MethodHandle handle = CLinker.systemCLinker().downcallHandle(\n+        MethodHandle handle = Linker.nativeLinker().downcallHandle(\n@@ -72,1 +72,1 @@\n-        MethodHandle handle = CLinker.systemCLinker().downcallHandle(\n+        MethodHandle handle = Linker.nativeLinker().downcallHandle(\n@@ -114,1 +114,1 @@\n-        MethodHandle handle = CLinker.systemCLinker().downcallHandle(\n+        MethodHandle handle = Linker.nativeLinker().downcallHandle(\n@@ -126,1 +126,1 @@\n-            upcall = CLinker.systemCLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), session);\n+            upcall = Linker.nativeLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), session);\n@@ -129,1 +129,1 @@\n-        MethodHandle handle = CLinker.systemCLinker().downcallHandle(\n+        MethodHandle handle = Linker.nativeLinker().downcallHandle(\n@@ -140,1 +140,1 @@\n-        MethodHandle handle = CLinker.systemCLinker().downcallHandle(\n+        MethodHandle handle = Linker.nativeLinker().downcallHandle(\n@@ -152,1 +152,1 @@\n-        MethodHandle handle = CLinker.systemCLinker().downcallHandle(\n+        MethodHandle handle = Linker.nativeLinker().downcallHandle(\n@@ -164,1 +164,1 @@\n-        MethodHandle handle = CLinker.systemCLinker().downcallHandle(\n+        MethodHandle handle = Linker.nativeLinker().downcallHandle(\n@@ -170,1 +170,1 @@\n-            MemorySegment upcall = CLinker.systemCLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), session);\n+            MemorySegment upcall = Linker.nativeLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), session);\n@@ -180,1 +180,1 @@\n-            return CLinker.systemCLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), MemorySession.openImplicit());\n+            return Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), MemorySession.openImplicit());\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    final static CLinker abi = CLinker.systemCLinker();\n+    final static Linker abi = Linker.nativeLinker();\n@@ -155,3 +155,1 @@\n-        final static SymbolLookup stdlib = SymbolLookup.systemLookup();\n-\n-        final static MethodHandle strcat = abi.downcallHandle(stdlib.lookup(\"strcat\").get(),\n+        final static MethodHandle strcat = abi.downcallHandle(abi.lookup(\"strcat\").get(),\n@@ -161,1 +159,1 @@\n-        final static MethodHandle strcmp = abi.downcallHandle(stdlib.lookup(\"strcmp\").get(),\n+        final static MethodHandle strcmp = abi.downcallHandle(abi.lookup(\"strcmp\").get(),\n@@ -164,1 +162,1 @@\n-        final static MethodHandle puts = abi.downcallHandle(stdlib.lookup(\"puts\").get(),\n+        final static MethodHandle puts = abi.downcallHandle(abi.lookup(\"puts\").get(),\n@@ -167,1 +165,1 @@\n-        final static MethodHandle strlen = abi.downcallHandle(stdlib.lookup(\"strlen\").get(),\n+        final static MethodHandle strlen = abi.downcallHandle(abi.lookup(\"strlen\").get(),\n@@ -170,1 +168,1 @@\n-        final static MethodHandle gmtime = abi.downcallHandle(stdlib.lookup(\"gmtime\").get(),\n+        final static MethodHandle gmtime = abi.downcallHandle(abi.lookup(\"gmtime\").get(),\n@@ -173,1 +171,1 @@\n-        final static MethodHandle qsort = abi.downcallHandle(stdlib.lookup(\"qsort\").get(),\n+        final static MethodHandle qsort = abi.downcallHandle(abi.lookup(\"qsort\").get(),\n@@ -180,1 +178,1 @@\n-        final static MethodHandle rand = abi.downcallHandle(stdlib.lookup(\"rand\").get(),\n+        final static MethodHandle rand = abi.downcallHandle(abi.lookup(\"rand\").get(),\n@@ -183,1 +181,1 @@\n-        final static MethodHandle vprintf = abi.downcallHandle(stdlib.lookup(\"vprintf\").get(),\n+        final static MethodHandle vprintf = abi.downcallHandle(abi.lookup(\"vprintf\").get(),\n@@ -186,1 +184,1 @@\n-        final static Addressable printfAddr = stdlib.lookup(\"printf\").get();\n+        final static Addressable printfAddr = abi.lookup(\"printf\").get();\n@@ -194,1 +192,1 @@\n-                        CLinker.upcallType(qsortComparFunction));\n+                        Linker.upcallType(qsortComparFunction));\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import java.lang.foreign.CLinker;\n+import java.lang.foreign.Linker;\n@@ -60,1 +60,1 @@\n-    static CLinker abi = CLinker.systemCLinker();\n+    static Linker abi = Linker.nativeLinker();\n","filename":"test\/jdk\/java\/foreign\/TestDowncall.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import java.lang.foreign.CLinker;\n+import java.lang.foreign.Linker;\n@@ -40,1 +40,1 @@\n-        \/\/ we request a CLinker, forcing OS name to be \"Windows\". This should trigger an exception when\n+        \/\/ we request a Linker, forcing OS name to be \"Windows\". This should trigger an exception when\n@@ -42,1 +42,1 @@\n-        assertTrue(SymbolLookup.systemLookup().lookup(\"nonExistentSymbol\").isEmpty());\n+        assertTrue(Linker.nativeLinker().lookup(\"nonExistentSymbol\").isEmpty());\n","filename":"test\/jdk\/java\/foreign\/TestFallbackLookup.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import java.lang.foreign.CLinker;\n+import java.lang.foreign.Linker;\n@@ -46,1 +46,1 @@\n-    private static final CLinker ABI = CLinker.systemCLinker();\n+    private static final Linker ABI = Linker.nativeLinker();\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import java.lang.foreign.CLinker;\n+import java.lang.foreign.Linker;\n@@ -53,1 +53,1 @@\n-    static final CLinker abi = CLinker.systemCLinker();\n+    static final Linker abi = Linker.nativeLinker();\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import java.lang.foreign.CLinker;\n+import java.lang.foreign.Linker;\n@@ -43,1 +43,1 @@\n-    static final CLinker LINKER = CLinker.systemCLinker();\n+    static final Linker LINKER = Linker.nativeLinker();\n","filename":"test\/jdk\/java\/foreign\/TestNULLAddress.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,3 +30,3 @@\n-       System.out.println(\"Trying to get CLinker\");\n-       CLinker.systemCLinker();\n-       System.out.println(\"Got CLinker\");\n+       System.out.println(\"Trying to get Linker\");\n+       Linker.nativeLinker();\n+       System.out.println(\"Got Linker\");\n","filename":"test\/jdk\/java\/foreign\/TestNoForeignUnsafeOverride.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-            CLinker.class,\n+            Linker.class,\n@@ -181,1 +181,1 @@\n-        addDefaultMapping(CLinker.class, CLinker.systemCLinker());\n+        addDefaultMapping(Linker.class, Linker.nativeLinker());\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.CLinker;\n+import java.lang.foreign.Linker;\n@@ -42,1 +42,1 @@\n-        CLinker.systemCLinker(); \/\/ trigger initialization\n+        Linker.nativeLinker(); \/\/ trigger initialization\n","filename":"test\/jdk\/java\/foreign\/TestUnsupportedPlatform.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import java.lang.foreign.CLinker;\n+import java.lang.foreign.Linker;\n@@ -75,1 +75,1 @@\n-            Addressable callback = ABI.upcallStub(mh.asType(CLinker.upcallType(callbackDesc)), callbackDesc, session);\n+            Addressable callback = ABI.upcallStub(mh.asType(Linker.upcallType(callbackDesc)), callbackDesc, session);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallAsync.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.foreign.CLinker;\n+import java.lang.foreign.Linker;\n@@ -48,1 +48,1 @@\n-    static CLinker ABI = CLinker.systemCLinker();\n+    static Linker ABI = Linker.nativeLinker();\n","filename":"test\/jdk\/java\/foreign\/TestUpcallBase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-import java.lang.foreign.CLinker;\n+import java.lang.foreign.Linker;\n@@ -57,1 +57,1 @@\n-    static final CLinker LINKER = CLinker.systemCLinker();\n+    static final Linker LINKER = Linker.nativeLinker();\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import java.lang.foreign.CLinker;\n+import java.lang.foreign.Linker;\n@@ -58,1 +58,1 @@\n-    static final CLinker LINKER = CLinker.systemCLinker();\n+    static final Linker LINKER = Linker.nativeLinker();\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import java.lang.foreign.CLinker;\n+import java.lang.foreign.Linker;\n@@ -63,1 +63,1 @@\n-    static final CLinker abi = CLinker.systemCLinker();\n+    static final Linker abi = Linker.nativeLinker();\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-import java.lang.foreign.CLinker;\n+import java.lang.foreign.Linker;\n@@ -41,1 +41,1 @@\n-        downcallVoid = CLinker.systemCLinker().downcallHandle(\n+        downcallVoid = Linker.nativeLinker().downcallHandle(\n@@ -45,1 +45,1 @@\n-        downcallNonVoid = CLinker.systemCLinker().downcallHandle(\n+        downcallNonVoid = Linker.nativeLinker().downcallHandle(\n@@ -76,1 +76,1 @@\n-            Addressable stub = CLinker.systemCLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), session);\n+            Addressable stub = Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), session);\n@@ -89,1 +89,1 @@\n-            Addressable stub = CLinker.systemCLinker().upcallStub(handle, FunctionDescriptor.of(C_INT, C_INT), session);\n+            Addressable stub = Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.of(C_INT, C_INT), session);\n","filename":"test\/jdk\/java\/foreign\/ThrowingUpcall.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-       Method method = CLinker.class.getDeclaredMethod(\"systemCLinker\");\n+       Method method = Linker.class.getDeclaredMethod(\"nativeLinker\");\n@@ -45,1 +45,1 @@\n-       Method method = CLinker.class.getDeclaredMethod(\"systemCLinker\");\n+       Method method = Linker.class.getDeclaredMethod(\"nativeLinker\");\n@@ -51,3 +51,3 @@\n-       var mh = MethodHandles.lookup().findStatic(CLinker.class, \"systemCLinker\",\n-           MethodType.methodType(CLinker.class));\n-       var linker = (CLinker)mh.invokeExact();\n+       var mh = MethodHandles.lookup().findStatic(Linker.class, \"nativeLinker\",\n+           MethodType.methodType(Linker.class));\n+       var linker = (Linker)mh.invokeExact();\n@@ -57,1 +57,1 @@\n-       CLinker.systemCLinker();\n+       Linker.nativeLinker();\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/org\/openjdk\/foreigntest\/PanamaMainUnnamedModule.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,3 +30,3 @@\n-       System.out.println(\"Trying to get CLinker\");\n-       CLinker.systemCLinker();\n-       System.out.println(\"Got CLinker\");\n+       System.out.println(\"Trying to get Linker\");\n+       Linker.nativeLinker();\n+       System.out.println(\"Got Linker\");\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMain.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,3 +35,3 @@\n-        System.out.println(\"Trying to get CLinker\");\n-        CLinker.systemCLinker();\n-        System.out.println(\"Got CLinker\");\n+        System.out.println(\"Trying to get Linker\");\n+        Linker.nativeLinker();\n+        System.out.println(\"Got Linker\");\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainDirect.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-       testInvokeCLinker();\n+       testInvokenativeLinker();\n@@ -35,6 +35,6 @@\n-    public static void testInvokeCLinker() throws Throwable {\n-        System.out.println(\"Trying to get CLinker\");\n-        var mh = MethodHandles.lookup().findStatic(CLinker.class, \"systemCLinker\",\n-                MethodType.methodType(CLinker.class));\n-        var linker = (CLinker)mh.invokeExact();\n-        System.out.println(\"Got CLinker\");\n+    public static void testInvokenativeLinker() throws Throwable {\n+        System.out.println(\"Trying to get Linker\");\n+        var mh = MethodHandles.lookup().findStatic(Linker.class, \"nativeLinker\",\n+                MethodType.methodType(Linker.class));\n+        var linker = (Linker)mh.invokeExact();\n+        System.out.println(\"Got Linker\");\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainInvoke.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-       testReflectionCLinker();\n+       testReflectionnativeLinker();\n@@ -35,3 +35,3 @@\n-    public static void testReflectionCLinker() throws Throwable {\n-        System.out.println(\"Trying to get CLinker\");\n-        Method method = CLinker.class.getDeclaredMethod(\"systemCLinker\");\n+    public static void testReflectionnativeLinker() throws Throwable {\n+        System.out.println(\"Trying to get Linker\");\n+        Method method = Linker.class.getDeclaredMethod(\"nativeLinker\");\n@@ -39,1 +39,1 @@\n-        System.out.println(\"Got CLinker\");\n+        System.out.println(\"Got Linker\");\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainReflection.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.foreign.CLinker;\n+import java.lang.foreign.Linker;\n@@ -67,1 +67,1 @@\n-        addDefaultMapping(CLinker.class, CLinker.systemCLinker());\n+        addDefaultMapping(Linker.class, Linker.nativeLinker());\n","filename":"test\/jdk\/java\/foreign\/handles\/invoker_module\/handle\/invoker\/MethodHandleInvoker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.foreign.CLinker;\n+import java.lang.foreign.Linker;\n@@ -55,2 +55,2 @@\n-                    { MethodHandles.lookup().findStatic(CLinker.class, \"systemCLinker\",\n-                            MethodType.methodType(CLinker.class)), \"CLinker::systemCLinker\" },\n+                    { MethodHandles.lookup().findStatic(Linker.class, \"nativeLinker\",\n+                            MethodType.methodType(Linker.class)), \"Linker::nativeLinker\" },\n","filename":"test\/jdk\/java\/foreign\/handles\/lookup_module\/handle\/lookup\/MethodHandleLookup.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-        var linker = CLinker.systemCLinker();\n+        var linker = Linker.nativeLinker();\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/invoker\/Invoker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.CLinker;\n+import java.lang.foreign.Linker;\n@@ -50,1 +50,1 @@\n-        MH_my_malloc = CLinker.systemCLinker().downcallHandle(\n+        MH_my_malloc = Linker.nativeLinker().downcallHandle(\n","filename":"test\/jdk\/java\/foreign\/malloc\/TestMixedMallocFree.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-import java.lang.foreign.CLinker;\n+import java.lang.foreign.Linker;\n@@ -98,1 +98,1 @@\n-    static final CLinker linker = CLinker.systemCLinker();\n+    static final Linker linker = Linker.nativeLinker();\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestAsyncStackWalk.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-import java.lang.foreign.CLinker;\n+import java.lang.foreign.Linker;\n@@ -98,1 +98,1 @@\n-    static final CLinker linker = CLinker.systemCLinker();\n+    static final Linker linker = Linker.nativeLinker();\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-import java.lang.foreign.CLinker;\n+import java.lang.foreign.Linker;\n@@ -59,1 +59,1 @@\n-    static final CLinker linker = CLinker.systemCLinker();\n+    static final Linker linker = Linker.nativeLinker();\n","filename":"test\/jdk\/java\/foreign\/upcalldeopt\/TestUpcallDeopt.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-    private static final CLinker abi = CLinker.systemCLinker();\n+    private static final Linker abi = Linker.nativeLinker();\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.CLinker;\n+import java.lang.foreign.Linker;\n@@ -46,1 +46,1 @@\n-    static final CLinker abi = CLinker.systemCLinker();\n+    static final Linker abi = Linker.nativeLinker();\n","filename":"test\/jdk\/java\/foreign\/virtual\/TestVirtualCalls.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.foreign.CLinker;\n+import java.lang.foreign.Linker;\n@@ -30,1 +30,0 @@\n-import java.lang.foreign.SymbolLookup;\n@@ -73,1 +72,1 @@\n-    private static CLinker LINKER = CLinker.systemCLinker();\n+    private static Linker LINKER = Linker.nativeLinker();\n@@ -76,1 +75,1 @@\n-            SymbolLookup.systemLookup().lookup(\"free\").get(), FunctionDescriptor.ofVoid(ValueLayout.ADDRESS));\n+            LINKER.lookup(\"free\").get(), FunctionDescriptor.ofVoid(ValueLayout.ADDRESS));\n@@ -79,1 +78,1 @@\n-            SymbolLookup.systemLookup().lookup(\"malloc\").get(), FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.JAVA_LONG));\n+            LINKER.lookup(\"malloc\").get(), FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.JAVA_LONG));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CLayouts.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.foreign.CLinker;\n+import java.lang.foreign.Linker;\n@@ -41,1 +41,1 @@\n-    static final CLinker abi = CLinker.systemCLinker();\n+    static final Linker abi = Linker.nativeLinker();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadHelper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import java.lang.foreign.CLinker;\n+import java.lang.foreign.Linker;\n@@ -67,1 +67,1 @@\n-        CLinker abi = CLinker.systemCLinker();\n+        Linker abi = Linker.nativeLinker();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/PointerInvoke.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.foreign.CLinker;\n+import java.lang.foreign.Linker;\n@@ -57,1 +57,1 @@\n-    static final CLinker abi = CLinker.systemCLinker();\n+    static final Linker abi = Linker.nativeLinker();\n@@ -66,1 +66,1 @@\n-    static Addressable qsort_addr = SymbolLookup.systemLookup().lookup(\"qsort\").get();\n+    static Addressable qsort_addr = abi.lookup(\"qsort\").get();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/QSort.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import java.lang.foreign.CLinker;\n+import java.lang.foreign.Linker;\n@@ -47,1 +47,0 @@\n-import java.lang.foreign.SymbolLookup;\n@@ -77,2 +76,2 @@\n-        CLinker abi = CLinker.systemCLinker();\n-        STRLEN = abi.downcallHandle(SymbolLookup.systemLookup().lookup(\"strlen\").get(),\n+        Linker abi = Linker.nativeLinker();\n+        STRLEN = abi.downcallHandle(abi.lookup(\"strlen\").get(),\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/StrLenTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.foreign.CLinker;\n+import java.lang.foreign.Linker;\n@@ -53,1 +53,1 @@\n-    static final CLinker abi = CLinker.systemCLinker();\n+    static final Linker abi = Linker.nativeLinker();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/Upcalls.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.foreign.CLinker;\n+import java.lang.foreign.Linker;\n@@ -28,1 +28,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -51,1 +50,1 @@\n-    static final CLinker linker = CLinker.systemCLinker();\n+    static final Linker linker = Linker.nativeLinker();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/VaList.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.foreign.CLinker;\n+import java.lang.foreign.Linker;\n@@ -52,1 +52,1 @@\n-        CLinker abi = CLinker.systemCLinker();\n+        Linker abi = Linker.nativeLinker();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/support\/PanamaPoint.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}