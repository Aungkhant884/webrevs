{"files":[{"patch":"@@ -70,1 +70,1 @@\n-     * {@return the argument layouts associated with this function descriptor}.\n+     * {@return the argument layouts associated with this function descriptor (as an immutable list)}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/FunctionDescriptor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -103,1 +103,2 @@\n-     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param offset offset in bytes (relative to this address). Might be negative.\n+     *               The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n@@ -126,1 +127,2 @@\n-     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param offset offset in bytes (relative to this address). Might be negative.\n+     *               The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n@@ -176,1 +178,2 @@\n-     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param offset offset in bytes (relative to this address). Might be negative.\n+     *               The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n@@ -196,1 +199,2 @@\n-     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param offset offset in bytes (relative to this address). Might be negative.\n+     *               The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n@@ -216,1 +220,2 @@\n-     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param offset offset in bytes (relative to this address). Might be negative.\n+     *               The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n@@ -236,1 +241,2 @@\n-     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param offset offset in bytes (relative to this address). Might be negative.\n+     *               The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n@@ -256,1 +262,2 @@\n-     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param offset offset in bytes (relative to this address). Might be negative.\n+     *               The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n@@ -276,1 +283,2 @@\n-     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param offset offset in bytes (relative to this address). Might be negative.\n+     *               The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n@@ -296,1 +304,2 @@\n-     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param offset offset in bytes (relative to this address). Might be negative.\n+     *               The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n@@ -316,1 +325,2 @@\n-     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param offset offset in bytes (relative to this address). Might be negative.\n+     *               The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n@@ -336,1 +346,2 @@\n-     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param offset offset in bytes (relative to this address). Might be negative.\n+     *               The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n@@ -356,1 +367,2 @@\n-     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param offset offset in bytes (relative to this address). Might be negative.\n+     *               The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n@@ -376,1 +388,2 @@\n-     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param offset offset in bytes (relative to this address). Might be negative.\n+     *               The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n@@ -396,1 +409,2 @@\n-     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param offset offset in bytes (relative to this address). Might be negative.\n+     *               The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n@@ -416,1 +430,2 @@\n-     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param offset offset in bytes (relative to this address). Might be negative.\n+     *               The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n@@ -436,1 +451,2 @@\n-     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param offset offset in bytes (relative to this address). Might be negative.\n+     *               The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n@@ -456,1 +472,2 @@\n-     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param offset offset in bytes (relative to this address). Might be negative.\n+     *               The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n@@ -476,1 +493,2 @@\n-     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param offset offset in bytes (relative to this address). Might be negative.\n+     *               The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n@@ -496,1 +514,2 @@\n-     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param offset offset in bytes (relative to this address). Might be negative.\n+     *               The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n@@ -516,1 +535,2 @@\n-     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param offset offset in bytes (relative to this address). Might be negative.\n+     *               The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n@@ -536,1 +556,2 @@\n-     * @param index index in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @param index index in bytes (relative to this address). Might be negative.\n+     *              The final address of this read operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n@@ -557,1 +578,2 @@\n-     * @param index index in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @param index index in bytes (relative to this address). Might be negative.\n+     *              The final address of this write operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n@@ -578,1 +600,2 @@\n-     * @param index index in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @param index index in bytes (relative to this address). Might be negative.\n+     *              The final address of this read operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n@@ -599,1 +622,2 @@\n-     * @param index index in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @param index index in bytes (relative to this address). Might be negative.\n+     *              The final address of this write operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n@@ -620,1 +644,2 @@\n-     * @param index index in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @param index index in bytes (relative to this address). Might be negative.\n+     *              The final address of this read operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n@@ -641,1 +666,2 @@\n-     * @param index index in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @param index index in bytes (relative to this address). Might be negative.\n+     *              The final address of this write operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n@@ -662,1 +688,2 @@\n-     * @param index index in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @param index index in bytes (relative to this address). Might be negative.\n+     *              The final address of this read operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n@@ -683,1 +710,2 @@\n-     * @param index index in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @param index index in bytes (relative to this address). Might be negative.\n+     *              The final address of this write operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n@@ -704,1 +732,2 @@\n-     * @param index index in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @param index index in bytes (relative to this address). Might be negative.\n+     *              The final address of this read operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n@@ -725,1 +754,2 @@\n-     * @param index index in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @param index index in bytes (relative to this address). Might be negative.\n+     *              The final address of this write operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n@@ -746,1 +776,2 @@\n-     * @param index index in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @param index index in bytes (relative to this address). Might be negative.\n+     *              The final address of this read operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n@@ -767,1 +798,2 @@\n-     * @param index index in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @param index index in bytes (relative to this address). Might be negative.\n+     *              The final address of this write operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n@@ -788,1 +820,2 @@\n-     * @param index index in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @param index index in bytes (relative to this address). Might be negative.\n+     *              The final address of this read operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n@@ -809,1 +842,2 @@\n-     * @param index index in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @param index index in bytes (relative to this address). Might be negative.\n+     *              The final address of this write operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryAddress.java","additions":68,"deletions":34,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n- *     <li>for a sequence layout <em>S<\/em> whose element layout is <em>E<\/em> and size is L,\n+ *     <li>for a sequence layout <em>S<\/em> whose element layout is <em>E<\/em> and size is <em>L<\/em>,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.util.Optional;\n@@ -371,1 +372,1 @@\n-     * @return a slice of this segment, or {@code null} if no overlap occurs.\n+     * @return a slice of this segment (where overlapping occurs).\n@@ -373,1 +374,1 @@\n-    MemorySegment asOverlappingSlice(MemorySegment other);\n+    Optional<MemorySegment> asOverlappingSlice(MemorySegment other);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,3 +39,3 @@\n- * Memory sessions can be closed, either implicitly (e.g. when a session is no longer reachable), or explicitly.\n- * When a memory session is closed, it is no longer {@linkplain #isAlive() alive}, and subsequent operations on resources\n- * associated with that session (e.g. attempting to access a {@link MemorySegment} instance) will fail with {@link IllegalStateException}.\n+ * Memory sessions can be closed. When a memory session is closed, it is no longer {@linkplain #isAlive() alive},\n+ * and subsequent operations on resources associated with that session (e.g. attempting to access a {@link MemorySegment} instance)\n+ * will fail with {@link IllegalStateException}.\n@@ -45,1 +45,1 @@\n- * When a memory session is closed (either explicitly, or implicitly), the {@linkplain #addCloseAction(Runnable) close actions}\n+ * When a memory session is closed, the {@linkplain #addCloseAction(Runnable) close actions}\n@@ -50,1 +50,1 @@\n- * The {@linkplain #global() global session} is a memory session that cannot be closed, either explicitly or implicitly.\n+ * The {@linkplain #global() global session} is a memory session that cannot be closed.\n@@ -63,1 +63,1 @@\n- * owner thread will result in a runtime failure.\n+ * owner thread will fail with {@link IllegalStateException}.\n@@ -69,1 +69,1 @@\n- * <h2>Deterministic deallocation<\/h2>\n+ * <h2>Closeable memory sessions<\/h2>\n@@ -74,1 +74,1 @@\n- * Closeable memory sessions are memory sessions that can be {@linkplain MemorySession#close() closed} explicitly, as demonstrated\n+ * Closeable memory sessions are memory sessions that can be {@linkplain MemorySession#close() closed} deterministically, as demonstrated\n@@ -89,5 +89,5 @@\n- * Closeable memory sessions, while powerful, must be used with caution. Clients must remember to\n- * {@linkplain MemorySession#close() close} a closeable memory session explicitly, when the session\n- * is no longer in use. A failure to do so might result in memory leaks. To mitigate this problem,\n- * closeable memory sessions can be associated with a {@link Cleaner} instance, so that they are also closed automatically,\n- * once the session instance becomes <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n+ * Closeable memory sessions, while powerful, must be used with caution. Closeable memory sessions must be closed\n+ * when no longer in use, either explicitly (by calling the {@link #close} method), or implicitly (by wrapping the use of\n+ * a closeable memory session in a <em>try-with-resources construct<\/em>). A failure to do so might result in memory leaks.\n+ * To mitigate this problem, closeable memory sessions can be associated with a {@link Cleaner} instance,\n+ * so that they are also closed automatically, once the session instance becomes <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n@@ -95,1 +95,1 @@\n- * native memory leaks. In case a managed memory session is closed explicitly, no further action will be taken when\n+ * native memory leaks. In case a client closes a memory session managed by a cleaner, no further action will be taken when\n@@ -99,1 +99,1 @@\n- * <h2>Restricting access to memory sessions<\/h2>\n+ * <h2>Non-closeable views<\/h2>\n@@ -138,1 +138,1 @@\n-     * {@return {@code true}, if this session can be {@linkplain #close() closed} explicitly}\n+     * {@return {@code true}, if this session is a closeable memory session}.\n@@ -196,2 +196,3 @@\n-     * object is also a memory session, and it refers to the same memory session as this memory session. This method\n-     * is especially useful when operating on {@linkplain #asNonCloseable() non-closeable} session views.\n+     * object is also a memory session, and it refers to the same memory session as this memory session.\n+     * {@linkplain #asNonCloseable() A non-closeable view} {@code V} of a memory session {@code S} is considered\n+     * equal to {@code S}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySession.java","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n- * Per the C specification (see C standard 6.5.2.2 Function calls - item 6),\n+ * Per the C specification (see C99 standard 6.5.2.2 Function calls - item 6),\n@@ -48,1 +48,1 @@\n- * which erases integral types by way of integer promotion (see C standard 6.3.1.1 - item 2),\n+ * which erases integral types by way of integer promotion (see C99 standard 6.3.1.1 - item 2),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/VaList.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1021,1 +1021,1 @@\n-     *         {@code offset + size < 0}.\n+     *         {@code offset + size} overflows the range of {@code long}.\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/FileChannel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -255,1 +255,1 @@\n-    public final MemorySegment asOverlappingSlice(MemorySegment other) {\n+    public final Optional<MemorySegment> asOverlappingSlice(MemorySegment other) {\n@@ -266,1 +266,1 @@\n-                return asSlice(newOffset, Math.min(this.byteSize() - newOffset, that.byteSize() + offsetToThat));\n+                return Optional.of(asSlice(newOffset, Math.min(this.byteSize() - newOffset, that.byteSize() + offsetToThat)));\n@@ -269,1 +269,1 @@\n-        return null;\n+        return Optional.empty();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -90,3 +90,3 @@\n-        assertNull(s1.asOverlappingSlice(s2));\n-        assertNull(s2.asOverlappingSlice(s1));\n-        assertNull(s1.asOverlappingSlice(sOther));\n+        assertTrue(s1.asOverlappingSlice(s2).isEmpty());\n+        assertTrue(s2.asOverlappingSlice(s1).isEmpty());\n+        assertTrue(s1.asOverlappingSlice(sOther).isEmpty());\n@@ -100,2 +100,2 @@\n-        assertEquals(s1.asOverlappingSlice(s2).byteSize(), s1.byteSize());\n-        assertEquals(s1.asOverlappingSlice(s2).session(), s1.session());\n+        assertEquals(s1.asOverlappingSlice(s2).get().byteSize(), s1.byteSize());\n+        assertEquals(s1.asOverlappingSlice(s2).get().session(), s1.session());\n@@ -103,2 +103,2 @@\n-        assertEquals(s2.asOverlappingSlice(s1).byteSize(), s2.byteSize());\n-        assertEquals(s2.asOverlappingSlice(s1).session(), s2.session());\n+        assertEquals(s2.asOverlappingSlice(s1).get().byteSize(), s2.byteSize());\n+        assertEquals(s2.asOverlappingSlice(s1).get().session(), s2.session());\n@@ -107,2 +107,2 @@\n-            assertEquals(s1.asOverlappingSlice(s2).address(), s1.address());\n-            assertEquals(s2.asOverlappingSlice(s1).address(), s2.address());\n+            assertEquals(s1.asOverlappingSlice(s2).get().address(), s1.address());\n+            assertEquals(s2.asOverlappingSlice(s1).get().address(), s2.address());\n@@ -119,2 +119,2 @@\n-            assertEquals(s1.asOverlappingSlice(slice).byteSize(), s1.byteSize() - offset);\n-            assertEquals(s1.asOverlappingSlice(slice).session(), s1.session());\n+            assertEquals(s1.asOverlappingSlice(slice).get().byteSize(), s1.byteSize() - offset);\n+            assertEquals(s1.asOverlappingSlice(slice).get().session(), s1.session());\n@@ -122,2 +122,2 @@\n-            assertEquals(slice.asOverlappingSlice(s1).byteSize(), slice.byteSize());\n-            assertEquals(slice.asOverlappingSlice(s1).session(), slice.session());\n+            assertEquals(slice.asOverlappingSlice(s1).get().byteSize(), slice.byteSize());\n+            assertEquals(slice.asOverlappingSlice(s1).get().session(), slice.session());\n@@ -126,2 +126,2 @@\n-                assertEquals(s1.asOverlappingSlice(slice).address(), s1.address().addOffset(offset));\n-                assertEquals(slice.asOverlappingSlice(s1).address(), slice.address());\n+                assertEquals(s1.asOverlappingSlice(slice).get().address(), s1.address().addOffset(offset));\n+                assertEquals(slice.asOverlappingSlice(s1).get().address(), slice.address());\n@@ -129,1 +129,1 @@\n-            assertNull(s2.asOverlappingSlice(slice));\n+            assertTrue(s2.asOverlappingSlice(slice).isEmpty());\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOverlap.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"}]}