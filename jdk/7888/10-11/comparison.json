{"files":[{"patch":"@@ -758,1 +758,0 @@\n-    bool should_detach;\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,0 +39,20 @@\n+\/\/ When an upcall is invoked from a thread that is not attached to the VM, we need to attach it,\n+\/\/ and then to detach it at some point later. Detaching a thread as soon as the upcall completes\n+\/\/ is suboptimal, as the same thread could later upcall to Java again, at which point the VM would\n+\/\/ create multiple Java views of the same native thread. For this reason, we use thread local storage\n+\/\/ to keep track of the fact that we have attached a native thread to the VM. When the thread local\n+\/\/ storage is destroyed (which happens when the native threads is terminated), we check if the\n+\/\/ storage has an attached thread and, if so, we detach it from the VM.\n+struct UpcallContext {\n+  Thread* attachedThread;\n+\n+  ~UpcallContext() {\n+    if (attachedThread != NULL) {\n+      JavaVM_ *vm = (JavaVM *)(&main_vm);\n+      vm->functions->DetachCurrentThread(vm);\n+    }\n+  }\n+};\n+\n+APPROVED_CPP_THREAD_LOCAL UpcallContext threadContext;\n+\n@@ -54,1 +74,1 @@\n-JavaThread* ProgrammableUpcallHandler::maybe_attach_and_get_thread(bool* should_detach) {\n+JavaThread* ProgrammableUpcallHandler::maybe_attach_and_get_thread() {\n@@ -61,1 +81,0 @@\n-    *should_detach = true;\n@@ -63,0 +82,1 @@\n+    threadContext.attachedThread = thread;\n@@ -64,2 +84,0 @@\n-  } else {\n-    *should_detach = false;\n@@ -70,5 +88,0 @@\n-void ProgrammableUpcallHandler::detach_current_thread() {\n-  JavaVM_ *vm = (JavaVM *)(&main_vm);\n-  vm->functions->DetachCurrentThread(vm);\n-}\n-\n@@ -77,1 +90,1 @@\n-  JavaThread* thread = maybe_attach_and_get_thread(&context->should_detach);\n+  JavaThread* thread = maybe_attach_and_get_thread();\n@@ -135,4 +148,0 @@\n-\n-  if (context->should_detach) {\n-    detach_current_thread();\n-  }\n@@ -142,2 +151,1 @@\n-  bool should_detach = false;\n-  JavaThread* thread = maybe_attach_and_get_thread(&should_detach);\n+  JavaThread* thread = maybe_attach_and_get_thread();\n@@ -149,4 +157,0 @@\n-\n-  if (should_detach) {\n-    detach_current_thread();\n-  }\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.cpp","additions":24,"deletions":20,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -51,2 +51,1 @@\n-  static JavaThread* maybe_attach_and_get_thread(bool* should_detach);\n-  static void detach_current_thread();\n+  static JavaThread* maybe_attach_and_get_thread();\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,7 +28,0 @@\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.ConstantDesc;\n-import java.lang.constant.DirectMethodHandleDesc;\n-import java.lang.constant.DynamicConstantDesc;\n-import java.lang.constant.MethodHandleDesc;\n-import java.lang.constant.MethodTypeDesc;\n-import java.nio.ByteOrder;\n@@ -40,6 +33,0 @@\n-import static java.lang.constant.ConstantDescs.BSM_GET_STATIC_FINAL;\n-import static java.lang.constant.ConstantDescs.BSM_INVOKE;\n-import static java.lang.constant.ConstantDescs.CD_Class;\n-import static java.lang.constant.ConstantDescs.CD_String;\n-import static java.lang.constant.ConstantDescs.CD_long;\n-\n@@ -125,13 +112,0 @@\n-    <T> DynamicConstantDesc<T> decorateLayoutConstant(DynamicConstantDesc<T> desc) {\n-        if (!hasNaturalAlignment()) {\n-            desc = DynamicConstantDesc.ofNamed(BSM_INVOKE, \"withBitAlignment\", desc.constantType(), MH_WITH_BIT_ALIGNMENT,\n-                    desc, bitAlignment());\n-        }\n-        if (name().isPresent()) {\n-            desc = DynamicConstantDesc.ofNamed(BSM_INVOKE, \"withName\", desc.constantType(), MH_WITH_NAME,\n-                    desc, name().get().describeConstable().orElseThrow());\n-        }\n-\n-        return desc;\n-    }\n-\n@@ -189,45 +163,0 @@\n-\n-    \/*** Helper constants for implementing Layout::describeConstable ***\/\n-\n-    static final ClassDesc CD_MEMORY_LAYOUT = MemoryLayout.class.describeConstable().get();\n-\n-    static final ClassDesc CD_VALUE_LAYOUT = ValueLayout.class.describeConstable().get();\n-\n-    static final ClassDesc CD_SEQUENCE_LAYOUT = SequenceLayout.class.describeConstable().get();\n-\n-    static final ClassDesc CD_GROUP_LAYOUT = GroupLayout.class.describeConstable().get();\n-\n-    static final ClassDesc CD_BYTEORDER = ByteOrder.class.describeConstable().get();\n-\n-    static final ClassDesc CD_FUNCTION_DESC = FunctionDescriptor.class.describeConstable().get();\n-\n-    static final ConstantDesc BIG_ENDIAN = DynamicConstantDesc.ofNamed(BSM_GET_STATIC_FINAL, \"BIG_ENDIAN\", CD_BYTEORDER, CD_BYTEORDER);\n-\n-    static final ConstantDesc LITTLE_ENDIAN = DynamicConstantDesc.ofNamed(BSM_GET_STATIC_FINAL, \"LITTLE_ENDIAN\", CD_BYTEORDER, CD_BYTEORDER);\n-\n-    static final MethodHandleDesc MH_PADDING = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, \"paddingLayout\",\n-                MethodTypeDesc.of(CD_MEMORY_LAYOUT, CD_long));\n-\n-    static final MethodHandleDesc MH_SIZED_SEQUENCE = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, \"sequenceLayout\",\n-                MethodTypeDesc.of(CD_SEQUENCE_LAYOUT, CD_long, CD_MEMORY_LAYOUT));\n-\n-    static final MethodHandleDesc MH_STRUCT = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, \"structLayout\",\n-                MethodTypeDesc.of(CD_GROUP_LAYOUT, CD_MEMORY_LAYOUT.arrayType()));\n-\n-    static final MethodHandleDesc MH_UNION = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, \"unionLayout\",\n-                MethodTypeDesc.of(CD_GROUP_LAYOUT, CD_MEMORY_LAYOUT.arrayType()));\n-\n-    static final MethodHandleDesc MH_VALUE = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, \"valueLayout\",\n-            MethodTypeDesc.of(CD_VALUE_LAYOUT, CD_Class, CD_BYTEORDER));\n-\n-    static final MethodHandleDesc MH_VOID_FUNCTION = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC, CD_FUNCTION_DESC, \"ofVoid\",\n-                MethodTypeDesc.of(CD_FUNCTION_DESC, CD_MEMORY_LAYOUT.arrayType()));\n-\n-    static final MethodHandleDesc MH_FUNCTION = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC, CD_FUNCTION_DESC, \"of\",\n-                MethodTypeDesc.of(CD_FUNCTION_DESC, CD_MEMORY_LAYOUT, CD_MEMORY_LAYOUT.arrayType()));\n-\n-    static final MethodHandleDesc MH_WITH_BIT_ALIGNMENT = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_VIRTUAL, CD_MEMORY_LAYOUT, \"withBitAlignment\",\n-                MethodTypeDesc.of(CD_MEMORY_LAYOUT, CD_long));\n-\n-    static final MethodHandleDesc MH_WITH_NAME = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_VIRTUAL, CD_MEMORY_LAYOUT, \"withName\",\n-                MethodTypeDesc.of(CD_MEMORY_LAYOUT, CD_String));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/AbstractLayout.java","additions":0,"deletions":71,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -27,4 +27,0 @@\n-import java.lang.constant.Constable;\n-import java.lang.constant.ConstantDesc;\n-import java.lang.constant.ConstantDescs;\n-import java.lang.constant.DynamicConstantDesc;\n@@ -55,1 +51,1 @@\n-public sealed class FunctionDescriptor implements Constable permits FunctionDescriptor.VariadicFunction {\n+public sealed class FunctionDescriptor permits FunctionDescriptor.VariadicFunction {\n@@ -216,17 +212,0 @@\n-     \/**\n-     * {@return the nominal descriptor for this function descriptor, if one can be constructed}\n-     *\/\n-    @Override\n-    public Optional<DynamicConstantDesc<FunctionDescriptor>> describeConstable() {\n-        List<ConstantDesc> constants = new ArrayList<>();\n-        constants.add(resLayout == null ? AbstractLayout.MH_VOID_FUNCTION : AbstractLayout.MH_FUNCTION);\n-        if (resLayout != null) {\n-            constants.add(resLayout.describeConstable().get());\n-        }\n-        for (MemoryLayout argLayout : argLayouts) {\n-            constants.add(argLayout.describeConstable().get());\n-        }\n-        return Optional.of(DynamicConstantDesc.ofNamed(\n-                ConstantDescs.BSM_INVOKE, \"function\", AbstractLayout.CD_FUNCTION_DESC, constants.toArray(new ConstantDesc[0])));\n-    }\n-\n@@ -267,5 +246,0 @@\n-\n-        @Override\n-        public Optional<DynamicConstantDesc<FunctionDescriptor>> describeConstable() {\n-            return Optional.empty();\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/FunctionDescriptor.java","additions":1,"deletions":27,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -28,4 +28,0 @@\n-import java.lang.constant.ConstantDesc;\n-import java.lang.constant.ConstantDescs;\n-import java.lang.constant.DynamicConstantDesc;\n-import java.lang.constant.MethodHandleDesc;\n@@ -61,1 +57,1 @@\n-        STRUCT(\"\", MH_STRUCT, Long::sum),\n+        STRUCT(\"\", Long::sum),\n@@ -65,1 +61,1 @@\n-        UNION(\"|\", MH_UNION, Math::max);\n+        UNION(\"|\", Math::max);\n@@ -68,1 +64,0 @@\n-        final MethodHandleDesc mhDesc;\n@@ -71,1 +66,1 @@\n-        Kind(String delimTag, MethodHandleDesc mhDesc, LongBinaryOperator sizeOp) {\n+        Kind(String delimTag, LongBinaryOperator sizeOp) {\n@@ -73,1 +68,0 @@\n-            this.mhDesc = mhDesc;\n@@ -176,12 +170,0 @@\n-    @Override\n-    public Optional<DynamicConstantDesc<GroupLayout>> describeConstable() {\n-        ConstantDesc[] constants = new ConstantDesc[1 + elements.size()];\n-        constants[0] = kind.mhDesc;\n-        for (int i = 0 ; i < elements.size() ; i++) {\n-            constants[i + 1] = elements.get(i).describeConstable().get();\n-        }\n-        return Optional.of(decorateLayoutConstant(DynamicConstantDesc.ofNamed(\n-                    ConstantDescs.BSM_INVOKE, kind.name().toLowerCase(),\n-                CD_GROUP_LAYOUT, constants)));\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/GroupLayout.java","additions":3,"deletions":21,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.lang.constant.Constable;\n-import java.lang.constant.DynamicConstantDesc;\n@@ -169,7 +167,1 @@\n-public sealed interface MemoryLayout extends Constable permits AbstractLayout, SequenceLayout, GroupLayout, PaddingLayout, ValueLayout {\n-\n-    \/**\n-     * {@return the nominal descriptor for this layout, if one can be constructed}\n-     *\/\n-    @Override\n-    Optional<? extends DynamicConstantDesc<? extends MemoryLayout>> describeConstable();\n+public sealed interface MemoryLayout permits AbstractLayout, SequenceLayout, GroupLayout, PaddingLayout, ValueLayout {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.lang.constant.ConstantDescs;\n-import java.lang.constant.DynamicConstantDesc;\n@@ -84,6 +82,0 @@\n-    @Override\n-    public Optional<DynamicConstantDesc<MemoryLayout>> describeConstable() {\n-        return Optional.of(decorateLayoutConstant(DynamicConstantDesc.ofNamed(ConstantDescs.BSM_INVOKE, \"padding\",\n-                CD_MEMORY_LAYOUT, MH_PADDING, bitSize())));\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/PaddingLayout.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.lang.constant.ConstantDescs;\n-import java.lang.constant.DynamicConstantDesc;\n@@ -240,7 +238,0 @@\n-    @Override\n-    public Optional<DynamicConstantDesc<SequenceLayout>> describeConstable() {\n-        return Optional.of(decorateLayoutConstant(\n-                DynamicConstantDesc.ofNamed(ConstantDescs.BSM_INVOKE, \"value\",\n-                        CD_SEQUENCE_LAYOUT, MH_SIZED_SEQUENCE, elemCount, elementLayout.describeConstable().get())));\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SequenceLayout.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.lang.constant.ConstantDescs;\n-import java.lang.constant.DynamicConstantDesc;\n@@ -138,6 +136,0 @@\n-    @Override\n-    public Optional<DynamicConstantDesc<ValueLayout>> describeConstable() {\n-        return Optional.of(decorateLayoutConstant(DynamicConstantDesc.ofNamed(ConstantDescs.BSM_INVOKE, \"value\",\n-                CD_VALUE_LAYOUT, MH_VALUE, carrier().describeConstable().get(), order == ByteOrder.BIG_ENDIAN ? BIG_ENDIAN : LITTLE_ENDIAN)));\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,94 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/*\n- * @test\n- * @enablePreview\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @run testng TestCondy\n- *\/\n-\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.MemoryLayout;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-import java.lang.constant.Constable;\n-import java.lang.constant.ConstantDesc;\n-import java.lang.invoke.MethodHandles;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-\n-import static java.lang.foreign.ValueLayout.ADDRESS;\n-import static java.lang.foreign.ValueLayout.JAVA_BOOLEAN;\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n-import static java.lang.foreign.ValueLayout.JAVA_CHAR;\n-import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n-import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-import static java.lang.foreign.ValueLayout.JAVA_LONG;\n-import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n-import static org.testng.Assert.assertEquals;\n-\n-public class TestCondy {\n-\n-    @Test(dataProvider = \"constables\")\n-    public void testPublicResolve(Constable constable) throws ReflectiveOperationException {\n-        ConstantDesc desc = constable.describeConstable().orElseThrow();\n-        Object result = desc.resolveConstantDesc(MethodHandles.publicLookup());\n-        assertEquals(result, constable);\n-    }\n-\n-\n-    private static final MemoryLayout[] constants = {\n-        JAVA_BOOLEAN,\n-        JAVA_CHAR,\n-        JAVA_BYTE,\n-        JAVA_SHORT,\n-        JAVA_INT,\n-        JAVA_FLOAT,\n-        JAVA_LONG,\n-        JAVA_DOUBLE,\n-        ADDRESS\n-    };\n-\n-    @DataProvider\n-    public static Object[][] constables() {\n-        List<Constable> testValues = new ArrayList<>();\n-\n-        testValues.addAll(Arrays.asList(constants));\n-\n-        testValues.add(MemoryLayout.structLayout(constants));\n-        testValues.add(MemoryLayout.unionLayout(constants));\n-\n-        for (MemoryLayout ml : constants) {\n-            testValues.add(MemoryLayout.sequenceLayout(10, ml));\n-        }\n-\n-        testValues.add(FunctionDescriptor.ofVoid(constants));\n-        testValues.add(FunctionDescriptor.of(JAVA_BYTE, constants));\n-\n-        return testValues.stream().map(e -> new Object[] { e }).toArray(Object[][]::new);\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestCondy.java","additions":0,"deletions":94,"binary":false,"changes":94,"status":"deleted"},{"patch":"@@ -1,126 +0,0 @@\n-\/*\n- *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/*\n- * @test\n- * @enablePreview\n- * @run testng TestLayoutConstants\n- *\/\n-\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.ValueLayout;\n-import java.lang.invoke.MethodHandles;\n-import java.nio.ByteOrder;\n-\n-import org.testng.annotations.*;\n-import static org.testng.Assert.*;\n-\n-public class TestLayoutConstants {\n-\n-    @Test(dataProvider = \"layouts\")\n-    public void testDescribeResolve(MemoryLayout expected) {\n-        try {\n-            MemoryLayout actual = expected.describeConstable().get()\n-                    .resolveConstantDesc(MethodHandles.lookup());\n-            assertEquals(actual, expected);\n-        } catch (ReflectiveOperationException ex) {\n-            throw new AssertionError(ex);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"functions\")\n-    public void testDescribeResolveFunction(MemoryLayout layout, boolean isVoid) {\n-        FunctionDescriptor expected = isVoid ?\n-                FunctionDescriptor.ofVoid(layout) :\n-                FunctionDescriptor.of(layout, layout);\n-        try {\n-            FunctionDescriptor actual = expected.describeConstable().get()\n-                    .resolveConstantDesc(MethodHandles.lookup());\n-            assertEquals(actual, expected);\n-        } catch (ReflectiveOperationException ex) {\n-            throw new AssertionError(ex);\n-        }\n-    }\n-\n-    @DataProvider(name = \"layouts\")\n-    public Object[][] createLayouts() {\n-        return new Object[][] {\n-                \/\/padding\n-                {MemoryLayout.paddingLayout(32)},\n-                { MemoryLayout.sequenceLayout(5, MemoryLayout.paddingLayout(32)) },\n-                { MemoryLayout.structLayout(MemoryLayout.paddingLayout(32), MemoryLayout.paddingLayout(32)) },\n-                { MemoryLayout.unionLayout(MemoryLayout.paddingLayout(32), MemoryLayout.paddingLayout(32)) },\n-                \/\/values, big endian\n-                { ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN) },\n-                { MemoryLayout.structLayout(\n-                        ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN),\n-                        ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN)) },\n-                { MemoryLayout.unionLayout(\n-                        ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN),\n-                        ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN)) },\n-                \/\/values, little endian\n-                { ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN) },\n-                { MemoryLayout.structLayout(\n-                        ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN),\n-                        ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN)) },\n-                { MemoryLayout.unionLayout(\n-                        ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN),\n-                        ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN)) },\n-                \/\/deeply nested\n-                { MemoryLayout.structLayout(\n-                        MemoryLayout.paddingLayout(16),\n-                        MemoryLayout.structLayout(\n-                                MemoryLayout.paddingLayout(8),\n-                                ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN))) },\n-                { MemoryLayout.unionLayout(\n-                        MemoryLayout.paddingLayout(16),\n-                        MemoryLayout.structLayout(\n-                                MemoryLayout.paddingLayout(8),\n-                                ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN))) },\n-                { MemoryLayout.sequenceLayout(5,\n-                        MemoryLayout.structLayout(\n-                                MemoryLayout.paddingLayout(8),\n-                                ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN))) },\n-                { ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN).withName(\"myInt\") },\n-                { ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN).withBitAlignment(8) },\n-        };\n-    }\n-\n-    @DataProvider(name = \"functions\")\n-    public Object[][] createFunctions() {\n-        Object[][] layouts = createLayouts();\n-        Object[][] functions = new Object[layouts.length * 2][];\n-        boolean[] values = new boolean[] { true, false };\n-        for (int i = 0 ; i < layouts.length ; i++) {\n-            for (boolean isVoid : values) {\n-                int offset = 0;\n-                if (isVoid) {\n-                    offset += 1;\n-                }\n-                functions[i * 2 + offset] = new Object[] { layouts[i][0], isVoid };\n-            }\n-        }\n-        return functions;\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestLayoutConstants.java","additions":0,"deletions":126,"binary":false,"changes":126,"status":"deleted"}]}