{"files":[{"patch":"@@ -0,0 +1,295 @@\n+\/*\n+ *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package java.lang.foreign;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.Optional;\n+\n+import jdk.internal.foreign.abi.SharedUtils;\n+import jdk.internal.foreign.abi.aarch64.linux.LinuxAArch64Linker;\n+import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64Linker;\n+import jdk.internal.foreign.abi.x64.sysv.SysVx64Linker;\n+import jdk.internal.foreign.abi.x64.windows.Windowsx64Linker;\n+import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n+\n+\/**\n+ * A linker provides access to foreign functions from Java code, and access to Java code from foreign functions.\n+ * <p>\n+ * Foreign functions typically reside in shared libraries that can be loaded on-demand. Each shared library conforms to\n+ * a specific ABI (Application Binary Interface). An ABI is a set of calling conventions and data types associated with\n+ * the compiler, OS, and processor where the library was built. For example, a C compiler on Linux\/x64 usually\n+ * builds libraries that conform to the SystemV ABI.\n+ * <p>\n+ * A linker has detailed knowledge of the calling conventions and data types used by a specific ABI.\n+ * For any library which conforms to that ABI, the linker can mediate between Java code running\n+ * in the JVM and foreign functions in the library. In particular:\n+ * <ul>\n+ * <li>A linker allows Java code to link against foreign functions, via\n+ * {@linkplain #downcallHandle(Addressable, FunctionDescriptor) downcall method handles}; and<\/li>\n+ * <li>A linker allows foreign functions to call Java method handles,\n+ * via the generation of {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, MemorySession) upcall stubs}.<\/li>\n+ * <\/ul>\n+ *\n+ * The {@link #nativeLinker()} method provides a linker for the ABI associated with the OS and processor where the Java runtime\n+ * is currently executing.\n+ *\n+ * <h2><a id = \"downcall-method-handles\">Downcall method handles<\/a><\/h2>\n+ *\n+ * {@linkplain #downcallHandle(FunctionDescriptor) Linking a foreign function} is a process which requires a function descriptor,\n+ * a set of memory layouts which, together, specify the signature of the foreign function to be linked, and returns,\n+ * when complete, a downcall method handle, that is, a method handle that can be used to invoke the target foreign function.\n+ * <p>\n+ * The Java {@linkplain java.lang.invoke.MethodType method type} associated with the returned method handle is\n+ * {@linkplain #downcallType(FunctionDescriptor) derived} from the argument and return layouts in the function descriptor.\n+ * More specifically, given each layout {@code L} in the function descriptor, a corresponding carrier {@code C} is inferred,\n+ * as described below:\n+ * <ul>\n+ * <li>if {@code L} is a {@link ValueLayout} with carrier {@code E} then there are two cases:\n+ *     <ul>\n+ *         <li>if {@code L} occurs in a parameter position and {@code E} is {@code MemoryAddress.class},\n+ *         then {@code C = Addressable.class};<\/li>\n+ *         <li>otherwise, {@code C = E};\n+ *     <\/ul><\/li>\n+ * <li>or, if {@code L} is a {@link GroupLayout}, then {@code C} is set to {@code MemorySegment.class}<\/li>\n+ * <\/ul>\n+ * <p>\n+ * The downcall method handle type, derived as above, might be decorated by additional leading parameters,\n+ * in the given order if both are present:\n+ * <ul>\n+ * <li>If the downcall method handle is created {@linkplain #downcallHandle(FunctionDescriptor) without specifying a target address},\n+ * the downcall method handle type features a leading parameter of type {@link Addressable}, from which the\n+ * address of the target foreign function can be derived.<\/li>\n+ * <li>If the function descriptor's return layout is a group layout, the resulting downcall method handle accepts\n+ * an additional leading parameter of type {@link SegmentAllocator}, which is used by the linker runtime to allocate the\n+ * memory region associated with the struct returned by the downcall method handle.<\/li>\n+ * <\/ul>\n+ *\n+ * <h2><a id = \"upcall-stubs\">Upcall stubs<\/a><\/h2>\n+ *\n+ * {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, MemorySession) Creating an upcall stub} requires a method\n+ * handle and a function descriptor; in this case, the set of memory layouts in the function descriptor\n+ * specify the signature of the function pointer associated with the upcall stub.\n+ * <p>\n+ * The type of the provided method handle has to {@linkplain #upcallType(FunctionDescriptor) match} the Java\n+ * {@linkplain java.lang.invoke.MethodType method type} associated with the upcall stub, which is derived from the argument\n+ * and return layouts in the function descriptor. More specifically, given each layout {@code L} in the function descriptor,\n+ * a corresponding carrier {@code C} is inferred, as described below:\n+ * <ul>\n+ * <li>If {@code L} is a {@link ValueLayout} with carrier {@code E} then there are two cases:\n+ *     <ul>\n+ *         <li>If {@code L} occurs in a return position and {@code E} is {@code MemoryAddress.class},\n+ *         then {@code C = Addressable.class};<\/li>\n+ *         <li>Otherwise, {@code C = E};\n+ *     <\/ul><\/li>\n+ * <li>Or, if {@code L} is a {@link GroupLayout}, then {@code C} is set to {@code MemorySegment.class}<\/li>\n+ * <\/ul>\n+ * Upcall stubs are modelled by instances of type {@link MemorySegment}; upcall stubs can be passed by reference to other\n+ * downcall method handles (as {@link MemorySegment} implements the {@link Addressable} interface) and,\n+ * when no longer required, they can be {@linkplain MemorySession#close() released}, via their associated {@linkplain MemorySession session}.\n+ *\n+ * <h2>Safety considerations<\/h2>\n+ *\n+ * Creating a downcall method handle is intrinsically unsafe. A symbol in a foreign library does not, in general,\n+ * contain enough signature information (e.g. arity and types of foreign function parameters). As a consequence,\n+ * the linker runtime cannot validate linkage requests. When a client interacts with a downcall method handle obtained\n+ * through an invalid linkage request (e.g. by specifying a function descriptor featuring too many argument layouts),\n+ * the result of such interaction is unspecified and can lead to JVM crashes. On downcall handle invocation,\n+ * the linker runtime guarantees the following for any argument that is a memory resource {@code R} (of type {@link MemorySegment}\n+ * or {@link VaList}):\n+ * <ul>\n+ *     <li>The memory session of {@code R} is {@linkplain MemorySession#isAlive() alive}. Otherwise, the invocation throws\n+ *     {@link IllegalStateException};<\/li>\n+ *     <li>The invocation occurs in same thread as the one {@linkplain MemorySession#ownerThread() owning} the memory session of {@code R},\n+ *     if said session is confined. Otherwise, the invocation throws {@link IllegalStateException}; and<\/li>\n+ *     <li>The memory session of {@code R} is {@linkplain MemorySession#whileAlive(Runnable) kept alive} (and cannot be closed) during the invocation.<\/li>\n+ *<\/ul>\n+ * <p>\n+ * When creating upcall stubs the linker runtime validates the type of the target method handle against the provided\n+ * function descriptor and report an error if any mismatch is detected. As for downcalls, JVM crashes might occur,\n+ * if the foreign code casts the function pointer associated with an upcall stub to a type\n+ * that is incompatible with the provided function descriptor. Moreover, if the target method\n+ * handle associated with an upcall stub returns a {@linkplain MemoryAddress memory address}, clients must ensure\n+ * that this address cannot become invalid after the upcall completes. This can lead to unspecified behavior,\n+ * and even JVM crashes, since an upcall is typically executed in the context of a downcall method handle invocation.\n+ *\n+ * @implSpec\n+ * Implementations of this interface are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ *\n+ * @implNote\n+ * On unsupported platforms this class will fail to initialize with an {@link ExceptionInInitializerError}.\n+ *\n+ * @since 19\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n+public sealed interface Linker extends SymbolLookup permits Windowsx64Linker, SysVx64Linker, LinuxAArch64Linker, MacOsAArch64Linker {\n+\n+    \/**\n+     * Returns a linker for the ABI associated with the underlying native platform. The underlying native platform\n+     * is the combination of OS and processor where the Java runtime is currently executing.\n+     * <p>\n+     * When interacting with the returned linker, clients must describe the signature of a foreign function using a\n+     * {@link FunctionDescriptor function descriptor} whose argument and return layouts are specified as follows:\n+     * <ul>\n+     *     <li>Scalar types are modelled by a {@linkplain ValueLayout value layout} instance of a suitable carrier. Example\n+     *     of scalar types in C are {@code int}, {@code long}, {@code size_t}, etc. The mapping between a scalar type\n+     *     and its corresponding layout is dependent on the ABI of the returned linker;\n+     *     <li>Composite types are modelled by a {@linkplain GroupLayout group layout}. Depending on the ABI of the\n+     *     returned linker, additional {@linkplain MemoryLayout#paddingLayout(long) padding} member layouts might be required to conform\n+     *     to the size and alignment constraints of a composite type definition in C (e.g. using {@code struct} or {@code union}); and<\/li>\n+     *     <li>Pointer types are modelled by a {@linkplain ValueLayout value layout} instance with carrier {@link MemoryAddress}.\n+     *     Examples of pointer types in C are {@code int**} and {@code int(*)(size_t*, size_t*)};<\/li>\n+     * <\/ul>\n+     * <p>\n+     * Any layout not listed above is <em>unsupported<\/em>; function descriptors containing unsupported layouts\n+     * will cause an {@link IllegalArgumentException} to be thrown, when used to create a\n+     * {@link #downcallHandle(Addressable, FunctionDescriptor) downcall method handle} or an\n+     * {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, MemorySession) upcall stub}.\n+     * <p>\n+     * Variadic functions (e.g. a C function declared with a trailing ellipses {@code ...} at the end of the formal parameter\n+     * list or with an empty formal parameter list) are not supported directly. However, it is possible to link a\n+     * variadic function by using a {@linkplain FunctionDescriptor#asVariadic(MemoryLayout...) <em>variadic<\/em>}\n+     * function descriptor, in which the specialized signature of a given variable arity callsite is described in full.\n+     * Alternatively, where the foreign library allows it, clients might be able to interact with variadic functions by\n+     * passing a trailing parameter of type {@link VaList} (e.g. as in {@code vsprintf}).\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @apiNote It is not currently possible to obtain a linker for a different combination of OS and processor.\n+     *\n+     * @return a linker for the ABI associated with the OS and processor where the Java runtime is currently executing.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    static Linker nativeLinker() {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass(), Linker.class, \"nativeLinker\");\n+        return SharedUtils.getSystemLinker();\n+    }\n+\n+    \/**\n+     * Creates a method handle which can be used to call a target foreign function with the given signature and address.\n+     * <p>\n+     * If the provided method type's return type is {@code MemorySegment}, then the resulting method handle features\n+     * an additional prefix parameter, of type {@link SegmentAllocator}, which will be used by the linker runtime\n+     * to allocate structs returned by-value.\n+     * <p>\n+     * Calling this method is equivalent to the following code:\n+     * {@snippet lang=java :\n+     * linker.downcallHandle(function).bindTo(symbol);\n+     * }\n+     *\n+     * @param symbol the address of the target function.\n+     * @param function the function descriptor of the target function.\n+     * @return a downcall method handle. The method handle type is <a href=\"CLinker.html#downcall-method-handles\"><em>inferred<\/em><\/a>\n+     * @throws IllegalArgumentException if the provided function descriptor is not supported by this linker.\n+     * or if the symbol is {@link MemoryAddress#NULL}\n+     *\/\n+    default MethodHandle downcallHandle(Addressable symbol, FunctionDescriptor function) {\n+        SharedUtils.checkSymbol(symbol);\n+        return downcallHandle(function).bindTo(symbol);\n+    }\n+\n+    \/**\n+     * Creates a method handle which can be used to call a target foreign function with the given signature.\n+     * The resulting method handle features a prefix parameter (as the first parameter) corresponding to the foreign function\n+     * entry point, of type {@link Addressable}, which is used to specify the address of the target function\n+     * to be called.\n+     * <p>\n+     * If the provided function descriptor's return layout is a {@link GroupLayout}, then the resulting method handle features an\n+     * additional prefix parameter (inserted immediately after the address parameter), of type {@link SegmentAllocator}),\n+     * which will be used by the linker runtime to allocate structs returned by-value.\n+     * <p>\n+     * The returned method handle will throw an {@link IllegalArgumentException} if the {@link Addressable} parameter passed to it is\n+     * associated with the {@link MemoryAddress#NULL} address, or a {@link NullPointerException} if that parameter is {@code null}.\n+     *\n+     * @param function the function descriptor of the target function.\n+     * @return a downcall method handle. The method handle type is <a href=\"CLinker.html#downcall-method-handles\"><em>inferred<\/em><\/a>\n+     * from the provided function descriptor.\n+     * @throws IllegalArgumentException if the provided function descriptor is not supported by this linker.\n+     *\/\n+    MethodHandle downcallHandle(FunctionDescriptor function);\n+\n+    \/**\n+     * Creates a stub which can be passed to other foreign functions as a function pointer, with the given\n+     * memory session. Calling such a function pointer from foreign code will result in the execution of the provided\n+     * method handle.\n+     * <p>\n+     * The returned memory segment's base address points to the newly allocated upcall stub, and is associated with\n+     * the provided memory session. When such session is closed, the corresponding upcall stub will be deallocated.\n+     * <p>\n+     * The target method handle should not throw any exceptions. If the target method handle does throw an exception,\n+     * the VM will exit with a non-zero exit code. To avoid the VM aborting due to an uncaught exception, clients\n+     * could wrap all code in the target method handle in a try\/catch block that catches any {@link Throwable}, for\n+     * instance by using the {@link java.lang.invoke.MethodHandles#catchException(MethodHandle, Class, MethodHandle)}\n+     * method handle combinator, and handle exceptions as desired in the corresponding catch block.\n+     *\n+     * @param target the target method handle.\n+     * @param function the upcall stub function descriptor.\n+     * @param session the upcall stub memory session.\n+     * @return a zero-length segment whose base address is the address of the upcall stub.\n+     * @throws IllegalArgumentException if the provided function descriptor is not supported by this linker.\n+     * @throws IllegalArgumentException if it is determined that the target method handle can throw an exception, or if the target method handle\n+     * has a type that does not match the upcall stub <a href=\"CLinker.html#upcall-stubs\"><em>inferred type<\/em><\/a>.\n+     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}, or if access occurs from\n+     * a thread other than the thread {@linkplain MemorySession#ownerThread() owning} {@code session}.\n+     *\/\n+    MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, MemorySession session);\n+\n+    \/**\n+     * Look up a symbol in the set of standard libraries associated with this linker instance. The set of symbols\n+     * available for lookup is unspecified, as it depends on the platform and on the operating system.\n+     * @return a symbol in one of the standard libraries associated with this linker (if any).\n+     *\/\n+    @Override\n+    Optional<MemorySegment> lookup(String name);\n+\n+    \/**\n+     * {@return the downcall method handle {@linkplain MethodType type} associated with the given function descriptor}\n+     * @param functionDescriptor a function descriptor.\n+     * @throws IllegalArgumentException if one or more layouts in the function descriptor are not supported\n+     * (e.g. if they are sequence layouts or padding layouts).\n+     *\/\n+    static MethodType downcallType(FunctionDescriptor functionDescriptor) {\n+        return SharedUtils.inferMethodType(functionDescriptor, false);\n+    }\n+\n+    \/**\n+     * {@return the method handle {@linkplain MethodType type} associated with an upcall stub with the given function descriptor}\n+     * @param functionDescriptor a function descriptor.\n+     * @throws IllegalArgumentException if one or more layouts in the function descriptor are not supported\n+     * (e.g. if they are sequence layouts or padding layouts).\n+     *\/\n+    static MethodType upcallType(FunctionDescriptor functionDescriptor) {\n+        return SharedUtils.inferMethodType(functionDescriptor, true);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":295,"deletions":0,"binary":false,"changes":295,"status":"added"}]}