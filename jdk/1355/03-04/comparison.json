{"files":[{"patch":"@@ -177,7 +177,1 @@\n-                            if (result.charAt(result.length() - 1) != '\\n')\n-                                result.append(\"\\n\");\n-                            result.append(\"\\n\");\n-                            result.append(escape(CODE_UNDERLINE))\n-                                  .append(docSections.get(current))\n-                                  .append(escape(CODE_RESET))\n-                                  .append(\"\\n\");\n+                            startSection(current);\n@@ -189,0 +183,8 @@\n+                if (current == Sections.RETURNS && !seenAny) {\n+                    List<? extends DocTree> firstSentence = node.getFirstSentence();\n+                    if (firstSentence.size() == 1\n+                            && firstSentence.get(0).getKind() == DocTree.Kind.RETURN) {\n+                        startSection(current);\n+                        scan(firstSentence.get(0), true);\n+                    }\n+                }\n@@ -193,0 +195,11 @@\n+        private void startSection(Sections current) {\n+            if (result.charAt(result.length() - 1) != '\\n')\n+                result.append(\"\\n\");\n+            result.append(\"\\n\");\n+            result.append(escape(CODE_UNDERLINE))\n+                    .append(docSections.get(current))\n+                    .append(escape(CODE_RESET))\n+                    .append(\"\\n\");\n+\n+        }\n+\n@@ -253,0 +266,10 @@\n+        \/**\n+         * {@inheritDoc}\n+         * {@code @return} is a bimodfal tage and can be used as either a block tag or an inline\n+         * tag. If the parameter {@code p} is {@code null}, the node will be formatted according to\n+         * the value of {@link ReturnTree#isInline()}. If the parameter is not null, the node will\n+         * be formatted as a block tag.\n+         * @param node  {@inheritDoc}\n+         * @param p     not {@code null} to force the node to be formatted as a block tag\n+         * @return\n+         *\/\n@@ -255,5 +278,16 @@\n-            reflownTo = result.length();\n-            try {\n-                return super.visitReturn(node, p);\n-            } finally {\n-                reflow(result, reflownTo, 0, limit);\n+            if (node.isInline() && p == null) {\n+                String MARKER = \"{0}\";\n+                int p0 = inlineReturns.indexOf(MARKER);\n+                result.append(inlineReturns, 0, p0);\n+                try {\n+                    return super.visitReturn(node, p);\n+                } finally {\n+                    result.append(inlineReturns.substring(p0 + MARKER.length()));\n+                }\n+            } else {\n+                reflownTo = result.length();\n+                try {\n+                    return super.visitReturn(node, p);\n+                } finally {\n+                    reflow(result, reflownTo, 0, limit);\n+                }\n@@ -572,0 +606,1 @@\n+    private static final String inlineReturns;\n@@ -580,0 +615,1 @@\n+        inlineReturns = bundle.getString(\"Inline_Returns\");\n","filename":"src\/jdk.compiler\/share\/classes\/jdk\/internal\/shellsupport\/doc\/JavadocFormatter.java","additions":48,"deletions":12,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+Inline_Returns=Returns {0}.\n","filename":"src\/jdk.compiler\/share\/classes\/jdk\/internal\/shellsupport\/doc\/resources\/javadocformatter.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}