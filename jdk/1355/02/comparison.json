{"files":[{"patch":"@@ -33,3 +33,4 @@\n- * <pre>\n- *    &#064;return description\n- * <\/pre>\n+ * <pre>{@code\n+ *    @return description\n+ *    {@return description}\n+ * }<\/pre>\n@@ -39,1 +40,12 @@\n-public interface ReturnTree extends BlockTagTree {\n+public interface ReturnTree extends BlockTagTree, InlineTagTree {\n+    \/**\n+     * Returns whether this instance is an inline tag.\n+     *\n+     * @return {@code true} if this instance is an inline tag\n+     * @implSpec this implementation returns {@code false}.\n+     * @since 16\n+     *\/\n+    default boolean isInline() {\n+        return false;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/doctree\/ReturnTree.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -268,0 +268,20 @@\n+    \/**\n+     * Creates a new {@code ReturnTree} object, to represent a {@code @return} tag\n+     * or {@code {@return} } tag.\n+     *\n+     * @implSpec This implementation throws {@code UnsupportedOperationException} if\n+     * {@code isInline} is {@code true}, and calls {@link #newReturnTree(List)} otherwise.\n+     *\n+     * @param description the description of the return value of a method\n+     * @return a {@code ReturnTree} object\n+     * @throws UnsupportedOperationException if inline {@code {@return} } tags are\n+     *      not supported\n+     * @since 16\n+     *\/\n+    default ReturnTree newReturnTree(boolean isInline, List<? extends DocTree> description) {\n+        if (isInline) {\n+            throw new UnsupportedOperationException();\n+        }\n+        return newReturnTree(description);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/DocTreeFactory.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -272,4 +272,3 @@\n-                    switch (tp.getKind()) {\n-                        case BLOCK:\n-                            return tp.parse(p);\n-                        case INLINE:\n+                    if (tp.allowsBlock()) {\n+                        return tp.parse(p, TagParser.Kind.BLOCK);\n+                    } else {\n@@ -314,5 +313,12 @@\n-            if (isIdentifierStart(ch)) {\n-                Name name = readTagName();\n-                TagParser tp = tagParsers.get(name);\n-\n-                if (tp == null) {\n+            if (!isIdentifierStart(ch)) {\n+                return erroneous(\"dc.no.tag.name\", p);\n+            }\n+            Name name = readTagName();\n+            TagParser tp = tagParsers.get(name);\n+            if (tp == null) {\n+                skipWhitespace();\n+                DCTree text = inlineText(WhitespaceRetentionPolicy.REMOVE_ALL);\n+                nextChar();\n+                return m.at(p).newUnknownInlineTagTree(name, List.of(text)).setEndPos(bp);\n+            } else {\n+                if (!tp.retainWhiteSpace) {\n@@ -320,18 +326,8 @@\n-                    DCTree text = inlineText(WhitespaceRetentionPolicy.REMOVE_ALL);\n-                    if (text != null) {\n-                        nextChar();\n-                        return m.at(p).newUnknownInlineTagTree(name, List.of(text)).setEndPos(bp);\n-                    }\n-                } else {\n-                    if (!tp.retainWhiteSpace) {\n-                        skipWhitespace();\n-                    }\n-                    if (tp.getKind() == TagParser.Kind.INLINE) {\n-                        DCEndPosTree<?> tree = (DCEndPosTree<?>) tp.parse(p);\n-                        if (tree != null) {\n-                            return tree.setEndPos(bp);\n-                        }\n-                    } else { \/\/ handle block tags (for example, @see) in inline content\n-                        inlineText(WhitespaceRetentionPolicy.REMOVE_ALL); \/\/ skip content\n-                        nextChar();\n-                    }\n+                }\n+                if (tp.allowsInline()) {\n+                    DCEndPosTree<?> tree = (DCEndPosTree<?>) tp.parse(p, TagParser.Kind.INLINE);\n+                    return tree.setEndPos(bp);\n+                } else { \/\/ handle block tags (for example, @see) in inline content\n+                    DCTree text = inlineText(WhitespaceRetentionPolicy.REMOVE_ALL); \/\/ skip content\n+                    nextChar();\n+                    return m.at(p).newUnknownInlineTagTree(name, List.of(text)).setEndPos(bp);\n@@ -340,1 +336,0 @@\n-            return erroneous(\"dc.no.tag.name\", p);\n@@ -577,0 +572,1 @@\n+     * Nested tags are not permitted.\n@@ -578,1 +574,0 @@\n-    @SuppressWarnings(\"fallthrough\")\n@@ -580,0 +575,12 @@\n+        return inlineContent(false);\n+    }\n+\n+    \/**\n+     * Read general text content of an inline tag, including HTML entities and elements.\n+     * Matching pairs of { } are skipped; the text is terminated by the first\n+     * unmatched }. It is an error if the beginning of the next tag is detected.\n+     *\n+     * @param allowNestedTags whether or not to allow nested tags\n+     *\/\n+    @SuppressWarnings(\"fallthrough\")\n+    private List<DCTree> inlineContent(boolean allowNestedTags) {\n@@ -607,0 +614,2 @@\n+                    textStart = bp;\n+                    lastNonWhite = -1;\n@@ -613,1 +622,0 @@\n-                    depth++;\n@@ -615,0 +623,8 @@\n+                    if (ch == '@' && allowNestedTags) {\n+                        addPendingText(trees, bp - 2);\n+                        trees.add(inlineTag());\n+                        textStart = bp;\n+                        lastNonWhite = -1;\n+                    } else {\n+                        depth++;\n+                    }\n@@ -1074,1 +1090,1 @@\n-        enum Kind { INLINE, BLOCK }\n+        enum Kind { INLINE, BLOCK, EITHER }\n@@ -1092,2 +1108,6 @@\n-        Kind getKind() {\n-            return kind;\n+        boolean allowsBlock() {\n+            return kind != Kind.INLINE;\n+        }\n+\n+        boolean allowsInline() {\n+            return kind != Kind.BLOCK;\n@@ -1100,1 +1120,9 @@\n-        abstract DCTree parse(int pos) throws ParseException;\n+        DCTree parse(int pos, Kind kind) throws ParseException {\n+            if (kind != this.kind && this.kind != Kind.EITHER) {\n+                throw new IllegalArgumentException(kind.toString());\n+            }\n+            return parse(pos);\n+        }\n+        DCTree parse(int pos) throws ParseException {\n+            throw new UnsupportedOperationException();\n+        }\n@@ -1104,1 +1132,1 @@\n-     * @see <a href=\"https:\/\/docs.oracle.com\/en\/java\/javase\/14\/docs\/specs\/javadoc\/doc-comment-spec.html\">Javadoc Tags<\/a>\n+     * @see <a href=\"https:\/\/docs.oracle.com\/en\/java\/javase\/14\/docs\/specs\/javadoc\/doc-comment-spec.html\">JavaDoc Tags<\/a>\n@@ -1274,2 +1302,2 @@\n-            \/\/ @return description\n-            new TagParser(TagParser.Kind.BLOCK, DCTree.Kind.RETURN) {\n+            \/\/ @return description  -or-  {@return description}\n+            new TagParser(TagParser.Kind.EITHER, DCTree.Kind.RETURN) {\n@@ -1277,3 +1305,13 @@\n-                public DCTree parse(int pos) {\n-                    List<DCTree> description = blockContent();\n-                    return m.at(pos).newReturnTree(description);\n+                public DCTree parse(int pos, Kind kind) {\n+                    List<DCTree> description;\n+                    switch (kind) {\n+                        case BLOCK:\n+                            description = blockContent();\n+                            break;\n+                        case INLINE:\n+                            description = inlineContent(true);\n+                            break;\n+                        default:\n+                            throw new IllegalArgumentException(kind.toString());\n+                    }\n+                    return m.at(pos).newReturnTree(kind == Kind.INLINE, description);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/DocCommentParser.java","additions":78,"deletions":40,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -680,1 +680,2 @@\n-    public static class DCReturn extends DCBlockTag implements ReturnTree {\n+    public static class DCReturn extends DCEndPosTree<DCReturn> implements ReturnTree {\n+        public final boolean inline;\n@@ -683,1 +684,2 @@\n-        DCReturn(List<DCTree> description) {\n+        DCReturn(boolean inline, List<DCTree> description) {\n+            this.inline = inline;\n@@ -687,0 +689,5 @@\n+        @Override\n+        public String getTagName() {\n+            return \"return\";\n+        }\n+\n@@ -697,0 +704,5 @@\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public boolean isInline() {\n+            return inline;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/DCTree.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -402,0 +402,3 @@\n+            if (node.isInline()) {\n+                print(\"{\");\n+            }\n@@ -405,0 +408,3 @@\n+            if (node.isInline()) {\n+                print(\"}\");\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/DocPretty.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -389,1 +389,6 @@\n-        DCReturn tree = new DCReturn(cast(description));\n+        return newReturnTree(false, description);\n+    }\n+\n+    @Override @DefinedBy(Api.COMPILER_TREE)\n+    public DCReturn newReturnTree(boolean isInline, List<? extends DocTree> description) {\n+        DCReturn tree = new DCReturn(isInline, cast(description));\n@@ -536,0 +541,1 @@\n+                    case RETURN:\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/DocTreeMaker.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1387,3 +1387,2 @@\n-                            jdk.javadoc.internal.doclint.HtmlTag htag =\n-                                    jdk.javadoc.internal.doclint.HtmlTag.get(name);\n-                            return htag != null && htag.equals(jdk.javadoc.internal.doclint.HtmlTag.A);\n+                            HtmlTag htag = HtmlTag.get(name);\n+                            return htag != null && htag.equals(HtmlTag.A);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-    public Content returnTagOutput(Element element, ReturnTree returnTag) {\n+    public Content returnTagOutput(Element element, ReturnTree returnTag, boolean inline) {\n@@ -215,4 +215,5 @@\n-        return new ContentBuilder(\n-                HtmlTree.DT(contents.returns),\n-                HtmlTree.DD(htmlWriter.commentTagsToContent(\n-                        returnTag, element, ch.getDescription(returnTag), false, inSummary)));\n+        List<? extends DocTree> desc = ch.getDescription(returnTag);\n+        Content content = htmlWriter.commentTagsToContent(returnTag, element, desc , false, inSummary);\n+        return inline\n+                ? new ContentBuilder(contents.getContent(\"doclet.Returns_0\", content))\n+                : new ContentBuilder(HtmlTree.DT(contents.returns), HtmlTree.DD(content));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TagletWriterImpl.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -103,0 +103,1 @@\n+doclet.Returns_0=Returns {0}.\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n- * A taglet that represents the @return tag.\n+ * A taglet that represents the {@code @return} and {@code {@return }} tags.\n@@ -57,1 +57,6 @@\n-        super(DocTree.Kind.RETURN, false, EnumSet.of(Location.METHOD));\n+        super(DocTree.Kind.RETURN, true, EnumSet.of(Location.METHOD));\n+    }\n+\n+    @Override\n+    public boolean isBlockTag() {\n+        return true;\n@@ -62,2 +67,5 @@\n-        List<? extends ReturnTree> tags = input.utils.getReturnTrees(input.element);\n-        CommentHelper ch = input.utils.getCommentHelper(input.element);\n+        Utils utils = input.utils;\n+        CommentHelper ch = utils.getCommentHelper(input.element);\n+\n+        ReturnTree tag = null;\n+        List<? extends ReturnTree> tags = utils.getReturnTrees(input.element);\n@@ -65,0 +73,9 @@\n+            tag = tags.get(0);\n+        } else {\n+            List<? extends DocTree> firstSentence = utils.getFirstSentenceTrees(input.element);\n+            if (firstSentence.size() == 1 && firstSentence.get(0).getKind() == DocTree.Kind.RETURN) {\n+                tag = (ReturnTree) firstSentence.get(0);\n+            }\n+        }\n+\n+        if (tag != null) {\n@@ -66,1 +83,1 @@\n-            output.holderTag = tags.get(0);\n+            output.holderTag = tag;\n@@ -73,0 +90,5 @@\n+    @Override\n+    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter writer) {\n+        return writer.returnTagOutput(element, (ReturnTree) tag, true);\n+    }\n+\n@@ -77,1 +99,0 @@\n-        TypeMirror returnType = utils.getReturnType(writer.getCurrentPageElement(), (ExecutableElement)holder);\n@@ -80,1 +101,2 @@\n-        \/\/Make sure we are not using @return tag on method with void return type.\n+        \/\/ Make sure we are not using @return tag on method with void return type.\n+        TypeMirror returnType = utils.getReturnType(writer.getCurrentPageElement(), (ExecutableElement)holder);\n@@ -87,4 +109,12 @@\n-        if (!tags.isEmpty())\n-            return writer.returnTagOutput(holder, tags.get(0));\n-        \/\/Inherit @return tag if necessary.\n-        List<DocTree> ntags = new ArrayList<>();\n+\n+        if (!tags.isEmpty()) {\n+            return writer.returnTagOutput(holder, tags.get(0), false);\n+        }\n+\n+        \/\/ Check for inline tag in first sentence.\n+        List<? extends DocTree> firstSentence = utils.getFirstSentenceTrees(holder);\n+        if (firstSentence.size() == 1 && firstSentence.get(0).getKind() == DocTree.Kind.RETURN) {\n+            return writer.returnTagOutput(holder, (ReturnTree) firstSentence.get(0), false);\n+        }\n+\n+        \/\/ Inherit @return tag if necessary.\n@@ -96,1 +126,1 @@\n-            ntags.add(inheritedDoc.holderTag);\n+            return writer.returnTagOutput(holder, (ReturnTree) inheritedDoc.holderTag, false);\n@@ -98,1 +128,1 @@\n-        return !ntags.isEmpty() ? writer.returnTagOutput(holder, (ReturnTree) ntags.get(0)) : null;\n+        return null;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ReturnTaglet.java","additions":43,"deletions":13,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -736,1 +736,2 @@\n-            String name = t.isInlineTag() ? \"{@\" + t.getName() + \"}\" : \"@\" + t.getName();\n+            \/\/ give preference to simpler block form if a tag can be either\n+            String name = t.isBlockTag() ? \"@\" + t.getName() : \"{@\" + t.getName() + \"}\";\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/TagletManager.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-     * @param element   The element that owns the doc comment\n+     * @param element   the element that owns the doc comment\n@@ -150,0 +150,1 @@\n+     * @param inline    whether this should be written as an inline instance or block instance\n@@ -153,1 +154,1 @@\n-    protected abstract Content returnTagOutput(Element element, ReturnTree returnTag);\n+    protected abstract Content returnTagOutput(Element element, ReturnTree returnTag, boolean inline);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/TagletWriter.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -942,0 +942,6 @@\n+        if (tree.isInline()) {\n+            DocCommentTree dct = getCurrentPath().getDocComment();\n+            if (tree != dct.getFirstSentence().get(0)) {\n+                env.messages.warning(REFERENCE, tree, \"dc.return.not.first\");\n+            }\n+        }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/Checker.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+dc.return.not.first = '{@return'} not at beginning of description\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/resources\/doclint.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,5 +26,5 @@\n- * @bug      4490068\n- * @summary  Warn when a return tag is used on a method without a return type.\n- * @library  ..\/..\/lib\n- * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n- * @build    javadoc.tester.*\n+ * @bug      4490068 8075778\n+ * @summary  General tests for inline or block at-return tag\n+ * @library  \/tools\/lib ..\/..\/lib\n+ * @modules  jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build    toolbox.ToolBox javadoc.tester.*\n@@ -34,0 +34,3 @@\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n@@ -35,0 +38,1 @@\n+import toolbox.ToolBox;\n@@ -38,7 +42,0 @@\n-    \/**\n-     * Trigger warning message when return tag is used on a void method.\n-     *\n-     * @return I really don't return anything.\n-     *\/\n-    public void method() {}\n-\n@@ -47,1 +44,1 @@\n-        tester.runTests();\n+        tester.runTests(m -> new Object[] { Path.of(m.getName()) });\n@@ -50,2 +47,18 @@\n-    @Test\n-    public void tests() {\n+    ToolBox tb = new ToolBox();\n+\n+    @Test \/\/ 4490068\n+    public void testInvalidReturn(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    \/** Comment. *\/\n+                    public class C {\n+                        \/**\n+                         * Trigger warning message when return tag is used on a void method.\n+                         *\n+                         * @return I really don't return anything.\n+                         *\/\n+                        public void method() {}\n+                    }\n+                    \"\"\");\n+\n@@ -53,3 +66,3 @@\n-                \"-d\", \"out\",\n-                \"-sourcepath\", testSrc,\n-                testSrc(\"TestReturnTag.java\"));\n+                \"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                src.resolve(\"C.java\").toString());\n@@ -61,0 +74,357 @@\n+\n+    @Test\n+    public void testBlock(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    \/** Comment. *\/\n+                    public class C {\n+                        \/**\n+                         * First sentence. Second sentence.\n+                         * @return the result\n+                         *\/\n+                        public int m() { return 0; }\n+                    }\n+                    \"\"\");\n+\n+        javadoc(\"-Xdoclint:none\",\n+                \"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                src.resolve(\"C.java\").toString());\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"C.html\", true,\n+                \"\"\"\n+                    <div class=\"block\">First sentence. Second sentence.<\/div>\n+                    <dl class=\"notes\">\n+                    <dt>Returns:<\/dt>\n+                    <dd>the result<\/dd>\n+                    <\/dl>\n+                    \"\"\");\n+    }\n+\n+    @Test\n+    public void testInlineShort(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    \/** Comment. *\/\n+                    public class C {\n+                        \/**\n+                         * {@return the result}\n+                         *\/\n+                        public int m() { return 0; }\n+                    }\n+                    \"\"\");\n+\n+        javadoc(\"-Xdoclint:none\",\n+                \"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                src.resolve(\"C.java\").toString());\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"C.html\", true,\n+                \"\"\"\n+                    <div class=\"block\">Returns the result.<\/div>\n+                    <dl class=\"notes\">\n+                    <dt>Returns:<\/dt>\n+                    <dd>the result<\/dd>\n+                    <\/dl>\n+                    \"\"\");\n+    }\n+\n+    @Test\n+    public void testInlineLong(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    \/** Comment. *\/\n+                    public class C {\n+                        \/**\n+                         * {@return the result} More text.\n+                         *\/\n+                        public int m() { return 0; }\n+                    }\n+                    \"\"\");\n+\n+        javadoc(\"-Xdoclint:none\",\n+                \"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                src.resolve(\"C.java\").toString());\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"C.html\", true,\n+                \"\"\"\n+                    <div class=\"block\">Returns the result. More text.<\/div>\n+                    <dl class=\"notes\">\n+                    <dt>Returns:<\/dt>\n+                    <dd>the result<\/dd>\n+                    <\/dl>\n+                    \"\"\");\n+    }\n+\n+    @Test\n+    public void testInlineMarkup(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    \/** Comment. *\/\n+                    public class C {\n+                        \/**\n+                         * {@return abc {@code def} <b>ghi<\/b> jkl}\n+                         *\/\n+                        public int m() { return 0; }\n+                    }\n+                    \"\"\");\n+\n+        javadoc(\"-Xdoclint:none\",\n+                \"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                src.resolve(\"C.java\").toString());\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"C.html\", true,\n+                \"\"\"\n+                    <div class=\"block\">Returns abc <code>def<\/code> <b>ghi<\/b> jkl.<\/div>\n+                    <dl class=\"notes\">\n+                    <dt>Returns:<\/dt>\n+                    <dd>abc <code>def<\/code> <b>ghi<\/b> jkl<\/dd>\n+                    <\/dl>\n+                    \"\"\");\n+    }\n+\n+    @Test\n+    public void testBlockMarkup(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    \/** Comment. *\/\n+                    public class C {\n+                        \/**\n+                         * @return abc {@code def} <b>ghi<\/b> jkl\n+                         *\/\n+                        public int m() { return 0; }\n+                    }\n+                    \"\"\");\n+\n+        javadoc(\"-Xdoclint:none\",\n+                \"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                src.resolve(\"C.java\").toString());\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"C.html\", true,\n+                \"\"\"\n+                    <dl class=\"notes\">\n+                    <dt>Returns:<\/dt>\n+                    <dd>abc <code>def<\/code> <b>ghi<\/b> jkl<\/dd>\n+                    <\/dl>\n+                    \"\"\");\n+    }\n+\n+    @Test\n+    public void testEmptyInline(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    \/** Comment. *\/\n+                    public class C {\n+                        \/**\n+                         * {@return}\n+                         *\/\n+                        public int m() { return 0; }\n+                    }\n+                    \"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                src.resolve(\"C.java\").toString());\n+        checkExit(Exit.OK);\n+\n+        checkOutput(Output.OUT, true,\n+                \"C.java:4: warning: no description for @return\");\n+\n+        checkOutput(\"C.html\", true,\n+                \"\"\"\n+                    <div class=\"block\">Returns .<\/div>\n+                    <dl class=\"notes\">\n+                    <dt>Returns:<\/dt>\n+                    <\/dl>\n+                    \"\"\");\n+    }\n+\n+    @Test\n+    public void testInlineNotFirst(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    \/** Comment. *\/\n+                    public class C {\n+                        \/**\n+                         * Some text. {@return the result} More text.\n+                         *\/\n+                        public int m() { return 0; }\n+                    }\n+                    \"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                src.resolve(\"C.java\").toString());\n+        checkExit(Exit.OK);\n+\n+        checkOutput(Output.OUT, true,\n+                \"C.java:4: warning: {@return} not at beginning of description\");\n+\n+        checkOutput(\"C.html\", true,\n+                \"\"\"\n+                    <div class=\"block\">Some text. Returns the result. More text.<\/div>\n+                    <\/section>\n+                    \"\"\");\n+    }\n+\n+    @Test\n+    public void testDuplicate(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    \/** Comment. *\/\n+                    public class C {\n+                        \/**\n+                         * {@return the result} More text.\n+                         * @return again\n+                         *\/\n+                        public int m() { return 0; }\n+                    }\n+                    \"\"\");\n+\n+        javadoc( \"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                src.resolve(\"C.java\").toString());\n+        checkExit(Exit.OK);\n+\n+        checkOutput(Output.OUT, true,\n+                \"C.java:5: warning: @return has already been specified\");\n+\n+        checkOutput(\"C.html\", true,\n+            \"\"\"\n+                <div class=\"block\">Returns the result. More text.<\/div>\n+                <dl class=\"notes\">\n+                <dt>Returns:<\/dt>\n+                <dd>again<\/dd>\n+                \"\"\");\n+    }\n+\n+    @Test\n+    public void testSimpleInheritBlock(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    \/** Comment. *\/\n+                    public class Super {\n+                        \/**\n+                         * @return the result\n+                         *\/\n+                        public int m() { return 0; }\n+                    }\n+                    \"\"\",\n+                \"\"\"\n+                    \/** Comment. *\/\n+                    public class C extends Super {\n+                        @Override\n+                        public int m() { return 1; }\n+                    }\n+                    \"\"\");\n+\n+        javadoc( \"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                src.resolve(\"C.java\").toString());\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"C.html\", true,\n+                \"\"\"\n+                    <dl class=\"notes\">\n+                    <dt>Overrides:<\/dt>\n+                    <dd><code>m<\/code>&nbsp;in class&nbsp;<code>Super<\/code><\/dd>\n+                    <dt>Returns:<\/dt>\n+                    <dd>the result<\/dd>\n+                    <\/dl>\n+                    \"\"\");\n+    }\n+\n+    @Test\n+    public void testSimpleInheritInline(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    \/** Comment. *\/\n+                    public class Super {\n+                        \/**\n+                         * {@return the result}\n+                         *\/\n+                        public int m() { return 0; }\n+                    }\n+                    \"\"\",\n+                \"\"\"\n+                    \/** Comment. *\/\n+                    public class C extends Super {\n+                        @Override\n+                        public int m() { return 1; }\n+                    }\n+                    \"\"\");\n+\n+        javadoc( \"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                src.resolve(\"C.java\").toString());\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"C.html\", true,\n+                \"\"\"\n+                    <div class=\"block\"><span class=\"descfrm-type-label\">Description copied from class:&nbsp;<code>Super<\/code><\/span><\/div>\n+                    <div class=\"block\">Returns the result.<\/div>\n+                    <dl class=\"notes\">\n+                    <dt>Overrides:<\/dt>\n+                    <dd><code>m<\/code>&nbsp;in class&nbsp;<code>Super<\/code><\/dd>\n+                    <dt>Returns:<\/dt>\n+                    <dd>the result<\/dd>\"\"\");\n+    }\n+\n+    @Test\n+    public void testPreferInlineOverInherit(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    \/** Comment. *\/\n+                    public class Super {\n+                        \/**\n+                         * {@return the result}\n+                         *\/\n+                        public int m() { return 0; }\n+                    }\n+                    \"\"\",\n+                \"\"\"\n+                    \/** Comment. *\/\n+                    public class C extends Super {\n+                        \/**\n+                         * {@return the overriding result}\n+                         *\/\n+                        @Override\n+                        public int m() { return 1; }\n+                    }\n+                    \"\"\");\n+\n+        javadoc( \"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                src.resolve(\"C.java\").toString());\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"C.html\", true,\n+                \"\"\"\n+                    <div class=\"block\">Returns the overriding result.<\/div>\n+                    <dl class=\"notes\">\n+                    <dt>Overrides:<\/dt>\n+                    <dd><code>m<\/code>&nbsp;in class&nbsp;<code>Super<\/code><\/dd>\n+                    <dt>Returns:<\/dt>\n+                    <dd>the overriding result<\/dd>\n+                    <\/dl>\n+                    \"\"\");\n+    }\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testReturnTag\/TestReturnTag.java","additions":388,"deletions":18,"binary":false,"changes":406,"status":"modified"},{"patch":"@@ -17,1 +17,1 @@\n-             @return: block ........ ...... ....... .... ........... method ..... ...... ........\n+             @return: block ........ ...... ....... .... ........... method ..... inline ........\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTaglets\/TestTaglets.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -105,0 +105,3 @@\n+            case \"ReturnTree\" ->\n+                    test(d, type, \"{@return abc}\");\n+\n","filename":"test\/langtools\/tools\/doclint\/EmptyHtmlTest.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}