{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, Red Hat Inc. All rights reserved.\n@@ -26,1 +26,2 @@\n- * @bug 8204479 8253191\n+ * @bug 8204479\n+ * @summary Bitwise AND on byte value sometimes produces wrong result\n@@ -28,4 +29,3 @@\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.vm.annotation\n- *\n- * @run main\/bootclasspath\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-TieredCompilation compiler.c2.TestUnsignedByteCompare\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-TieredCompilation\n+ *      -XX:-UseOnStackReplacement -XX:-BackgroundCompilation -Xcomp -XX:-Inline\n+ *      compiler.c2.TestUnsignedByteCompare\n@@ -33,1 +33,0 @@\n-package compiler.c2;\n@@ -35,3 +34,1 @@\n-import java.lang.invoke.*;\n-import jdk.internal.vm.annotation.DontInline;\n-import jdk.test.lib.Asserts;\n+package compiler.c2;\n@@ -41,6 +38,1 @@\n-    @DontInline static boolean testByteGT0(byte[] val) { return (val[0] & mask()) >  0; }\n-    @DontInline static boolean testByteGE0(byte[] val) { return (val[0] & mask()) >= 0; }\n-    @DontInline static boolean testByteEQ0(byte[] val) { return (val[0] & mask()) == 0; }\n-    @DontInline static boolean testByteNE0(byte[] val) { return (val[0] & mask()) != 0; }\n-    @DontInline static boolean testByteLE0(byte[] val) { return (val[0] & mask()) <= 0; }\n-    @DontInline static boolean testByteLT0(byte[] val) { return (val[0] & mask()) <  0; }\n+    static int p, n;\n@@ -48,8 +40,3 @@\n-    static void testValue(byte b) {\n-        byte[] bs = new byte[] { b };\n-        Asserts.assertEquals(((b & mask()) >  0), testByteGT0(bs), errorMessage(b, \"GT0\"));\n-        Asserts.assertEquals(((b & mask()) >= 0), testByteGE0(bs), errorMessage(b, \"GE0\"));\n-        Asserts.assertEquals(((b & mask()) == 0), testByteEQ0(bs), errorMessage(b, \"EQ0\"));\n-        Asserts.assertEquals(((b & mask()) != 0), testByteNE0(bs), errorMessage(b, \"NE0\"));\n-        Asserts.assertEquals(((b & mask()) <= 0), testByteLE0(bs), errorMessage(b, \"LE0\"));\n-        Asserts.assertEquals(((b & mask()) <  0), testByteLT0(bs), errorMessage(b, \"LT0\"));\n+    static void report(byte[] ba, int i, boolean failed) {\n+        \/\/ Enable for debugging:\n+        \/\/ System.out.println((failed ? \"Failed\" : \"Passed\") + \" with: \" + ba[i] + \" at \" + i);\n@@ -58,5 +45,8 @@\n-    public static void main(String[] args) {\n-        for (int mask = 0; mask <= 0xFF; mask++) {\n-            setMask(mask);\n-            for (int i = 0; i < 20_000; i++) {\n-                testValue((byte) i);\n+    static void m1(byte[] ba) {\n+        for (int i = 0; i < ba.length; i++) {\n+            if ((ba[i] & 0xFF) < 0x10) {\n+               p++;\n+               report(ba, i, true);\n+            } else {\n+               n++;\n+               report(ba, i, false);\n@@ -65,1 +55,0 @@\n-        System.out.println(\"TEST PASSED\");\n@@ -68,2 +57,10 @@\n-    static String errorMessage(byte b, String type) {\n-        return String.format(\"%s: val=0x%x mask=0x%x\", type, b, mask());\n+    static void m2(byte[] ba) {\n+        for (int i = 0; i < ba.length; i++) {\n+            if (((ba[i] & 0xFF) & 0x80) < 0) {\n+               p++;\n+               report(ba, i, true);\n+            } else {\n+               n++;\n+               report(ba, i, false);\n+            }\n+        }\n@@ -72,1 +69,3 @@\n-    \/\/ Mutable mask as a compile-time constant.\n+    static public void main(String[] args) {\n+        final int tries = 1_000;\n+        final int count = 1_000;\n@@ -74,2 +73,1 @@\n-    private static final CallSite     MASK_CS = new MutableCallSite(MethodType.methodType(int.class));\n-    private static final MethodHandle MASK_MH = MASK_CS.dynamicInvoker();\n+        byte[] ba = new byte[count];\n@@ -77,5 +75,3 @@\n-    static int mask() {\n-        try {\n-            return (int) MASK_MH.invokeExact();\n-        } catch (Throwable t) {\n-            throw new InternalError(t); \/\/ should NOT happen\n+        for (int i = 0; i < count; i++) {\n+            int v = -(i % 126 + 1);\n+            ba[i] = (byte)v;\n@@ -83,1 +79,0 @@\n-    }\n@@ -85,3 +80,13 @@\n-    static void setMask(int mask) {\n-        MethodHandle constant = MethodHandles.constant(int.class, mask);\n-        MASK_CS.setTarget(constant);\n+        for (int t = 0; t < tries; t++) {\n+            m1(ba);\n+            if (p != 0) {\n+                throw new IllegalStateException(\"m1 error: p = \" + p + \", n = \" + n);\n+            }\n+        }\n+\n+        for (int t = 0; t < tries; t++) {\n+            m2(ba);\n+            if (p != 0) {\n+                throw new IllegalStateException(\"m2 error: p = \" + p + \", n = \" + n);\n+            }\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestUnsignedByteCompare.java","additions":49,"deletions":44,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8204479 8253191\n+ * @bug 8253191\n@@ -31,1 +31,1 @@\n- * @run main\/bootclasspath\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-TieredCompilation compiler.c2.TestUnsignedByteCompare\n+ * @run main\/bootclasspath\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-TieredCompilation compiler.c2.TestUnsignedByteCompare1\n@@ -39,1 +39,1 @@\n-public class TestUnsignedByteCompare {\n+public class TestUnsignedByteCompare1 {\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestUnsignedByteCompare1.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestUnsignedByteCompare.java","status":"copied"}]}