{"files":[{"patch":"@@ -43,0 +43,1 @@\n+\n@@ -45,0 +46,1 @@\n+\n@@ -657,0 +659,51 @@\n+\n+        \/**\n+         * Returns a {@code BodyPublisher} that publishes a request\n+         * body consisting of the concatenation of the request bodies\n+         * published by a sequence of publishers.\n+         *\n+         * <p> If the sequence is empty an {@linkplain #noBody() empty} publisher\n+         * is returned. Otherwise, if the sequence contains a single element,\n+         * that publisher is returned. Otherwise a <em>concatenation publisher<\/em>\n+         * is returned.\n+         *\n+         * <p> The request body published by a <em>concatenation publisher<\/em>\n+         * is logically equivalent to the request body that would have\n+         * been published by concatenating all the bytes of each publisher\n+         * in sequence.\n+         *\n+         * <p> Each publisher is lazily subscribed to in turn,\n+         * until all the body bytes are published, an error occurs, or the\n+         * concatenation publisher's subscription is cancelled.\n+         * The concatenation publisher may be subscribed to more than once,\n+         * which in turn may result in the publishers in the sequence being\n+         * subscribed to more than once.\n+         *\n+         * <p> The concatenation publisher has a known content\n+         * length only if all publishers in the sequence have a known content\n+         * length. The {@link BodyPublisher#contentLength() contentLength}\n+         * reported by the concatenation publisher is computed as follows:\n+         * <ul>\n+         *     <li> If any of the publishers reports an <em>{@linkplain\n+         *         BodyPublisher#contentLength() unknown}<\/em> content length,\n+         *         or if the sum of the known content lengths would exceed\n+         *         {@link Long#MAX_VALUE}, the resulting\n+         *         content length is <em>unknown<\/em>.<\/li>\n+         *     <li> Otherwise, the resulting content length is the sum of the\n+         *         known content lengths, a number between\n+         *         {@code 0} and {@link Long#MAX_VALUE}, inclusive.<\/li>\n+         * <\/ul>\n+         *\n+         * @implNote If the concatenation publisher's subscription is\n+         * {@linkplain Flow.Subscription#cancel() cancelled}, or an error occurs\n+         * while publishing the bytes, not all publishers in the sequence may\n+         * be subscribed to.\n+         *\n+         * @param publishers a sequence of publishers.\n+         * @return An aggregate publisher that publishes a request body\n+         * logically equivalent to the concatenation of all bytes published\n+         * by each publisher in the sequence.\n+         *\/\n+        public static BodyPublisher concat(BodyPublisher... publishers) {\n+            return RequestPublishers.concat(Objects.requireNonNull(publishers));\n+        }\n","filename":"src\/java.net.http\/share\/classes\/java\/net\/http\/HttpRequest.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.net.http.HttpRequest.BodyPublisher;\n@@ -50,0 +51,1 @@\n+import java.util.Queue;\n@@ -53,0 +55,1 @@\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -55,1 +58,3 @@\n-import java.net.http.HttpRequest.BodyPublisher;\n+\n+import jdk.internal.net.http.common.Demand;\n+import jdk.internal.net.http.common.SequentialScheduler;\n@@ -494,0 +499,161 @@\n+\n+\n+    public static BodyPublisher concat(BodyPublisher... publishers) {\n+        if (publishers.length == 0) {\n+            return new EmptyPublisher();\n+        } else if (publishers.length == 1) {\n+            return Objects.requireNonNull(publishers[0]);\n+        } else {\n+            return new AggregatePublisher(List.of(publishers));\n+        }\n+    }\n+\n+    \/**\n+     * An aggregate publisher acts as a proxy between a subscriber\n+     * and a list of publishers. It lazily subscribes to each publisher\n+     * in sequence in order to publish a request body that is\n+     * composed from all the bytes obtained from each publisher.\n+     * For instance, the following two publishers are equivalent, even\n+     * though they may result in a different count of {@code onNext}\n+     * invocations.\n+     * <pre>{@code\n+     *   var bp1 = BodyPublishers.ofString(\"ab\");\n+     *   var bp2 = BodyPublishers.concat(BodyPublishers.ofString(\"a\"),\n+     *                                   BodyPublisher.ofByteArray(new byte[] {(byte)'b'}));\n+     * }<\/pre>\n+     *\n+     *\/\n+    private static final class AggregatePublisher implements BodyPublisher {\n+        final List<BodyPublisher> bodies;\n+        AggregatePublisher(List<BodyPublisher> bodies) {\n+            this.bodies = bodies;\n+        }\n+\n+        \/\/ -1 must be returned if any publisher returns -1\n+        \/\/ Otherwise, we can just sum the contents.\n+        @Override\n+        public long contentLength() {\n+            long length =  bodies.stream()\n+                    .mapToLong(BodyPublisher::contentLength)\n+                    .reduce((a,b) -> a < 0 || b < 0 ? -1 : a + b)\n+                    .orElse(0);\n+            \/\/ In case of overflow in any operation but the last, length\n+            \/\/ will be -1.\n+            \/\/ In case of overflow in the last reduce operation, length\n+            \/\/ will be negative, but not necessarily -1: in that case,\n+            \/\/ return -1\n+            if (length < 0) return -1;\n+            return length;\n+        }\n+\n+        @Override\n+        public void subscribe(Flow.Subscriber<? super ByteBuffer> subscriber) {\n+            subscriber.onSubscribe(new AggregateSubscription(bodies, subscriber));\n+        }\n+    }\n+\n+    private static final class AggregateSubscription\n+            implements Flow.Subscription, Flow.Subscriber<ByteBuffer> {\n+        final Flow.Subscriber<? super ByteBuffer> subscriber; \/\/ upstream\n+        final Queue<BodyPublisher> bodies;\n+        final SequentialScheduler scheduler;\n+        final Demand demand = new Demand(); \/\/ from upstream\n+        final Demand demanded = new Demand(); \/\/ requested downstream\n+        final AtomicReference<Throwable> error = new AtomicReference<>();\n+        volatile BodyPublisher publisher; \/\/ downstream\n+        volatile Flow.Subscription subscription; \/\/ downstream\n+        volatile boolean cancelled;\n+        AggregateSubscription(List<BodyPublisher> bodies, Flow.Subscriber<? super ByteBuffer> subscriber) {\n+            this.bodies = new ConcurrentLinkedQueue<>(bodies);\n+            this.subscriber = subscriber;\n+            this.scheduler = SequentialScheduler.synchronizedScheduler(this::run);\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            if (cancelled || publisher == null && bodies.isEmpty()) {\n+                return;\n+            }\n+            demand.increase(n);\n+            scheduler.runOrSchedule();\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            cancelled = true;\n+            scheduler.runOrSchedule();\n+        }\n+\n+        public void run() {\n+            try {\n+                while (error.get() == null\n+                        && (!demand.isFulfilled()\n+                        || (publisher == null && !bodies.isEmpty()))) {\n+                    boolean cancelled = this.cancelled;\n+                    BodyPublisher publisher = this.publisher;\n+                    Flow.Subscription subscription = this.subscription;\n+                    if (cancelled) {\n+                        this.publisher = null;\n+                        bodies.removeIf((b) -> true);\n+                        if (subscription != null) {\n+                            subscription.cancel();\n+                        }\n+                        scheduler.stop();\n+                        return;\n+                    }\n+                    if (publisher == null && !bodies.isEmpty()) {\n+                        this.publisher = publisher = bodies.poll();\n+                        publisher.subscribe(this);\n+                        subscription = this.subscription;\n+                    } else if (publisher == null) {\n+                        return;\n+                    }\n+                    if (subscription == null) return;\n+                    if (!demand.isFulfilled()) {\n+                        long n = demand.decreaseAndGet(demand.get());\n+                        demanded.increase(n);\n+                        subscription.request(n);\n+                    }\n+                }\n+            } catch (Throwable t) {\n+                onError(t);\n+            }\n+        }\n+\n+\n+        @Override\n+        public void onSubscribe(Flow.Subscription subscription) {\n+            this.subscription = subscription;\n+            scheduler.runOrSchedule();\n+        }\n+\n+        @Override\n+        public void onNext(ByteBuffer item) {\n+            demanded.tryDecrement();\n+            subscriber.onNext(item);\n+        }\n+\n+        @Override\n+        public void onError(Throwable throwable) {\n+            if (error.compareAndSet(null, throwable)) {\n+                subscriber.onError(throwable);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            if (publisher != null && !bodies.isEmpty()) {\n+                while (!demanded.isFulfilled()) {\n+                    demand.increase(demanded.decreaseAndGet(demanded.get()));\n+                }\n+                publisher = null;\n+                subscription = null;\n+                scheduler.runOrSchedule();\n+            } else {\n+                publisher = null;\n+                subscription = null;\n+                subscriber.onComplete();\n+                scheduler.stop();\n+            }\n+        }\n+    }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/RequestPublishers.java","additions":167,"deletions":1,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -0,0 +1,771 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8252374\n+ * @library \/test\/lib http2\/server\n+ * @build jdk.test.lib.net.SimpleSSLContext HttpServerAdapters\n+ *       ReferenceTracker AggregateRequestBodyTest\n+ * @modules java.base\/sun.net.www.http\n+ *          java.net.http\/jdk.internal.net.http.common\n+ *          java.net.http\/jdk.internal.net.http.frame\n+ *          java.net.http\/jdk.internal.net.http.hpack\n+ * @run testng\/othervm -Djdk.internal.httpclient.debug=true\n+ *                     -Djdk.httpclient.HttpClient.log=requests,responses,errors\n+ *                     AggregateRequestBodyTest\n+ * @summary Tests HttpRequest.BodyPublishers::concat\n+ *\/\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpRequest.BodyPublisher;\n+import java.net.http.HttpRequest.BodyPublishers;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.nio.ByteBuffer;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedDeque;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Flow;\n+import java.util.concurrent.Flow.Subscriber;\n+import java.util.concurrent.Flow.Subscription;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import java.util.stream.LongStream;\n+import java.util.stream.Stream;\n+import javax.net.ssl.SSLContext;\n+\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.HttpsConfigurator;\n+import com.sun.net.httpserver.HttpsServer;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.testng.Assert;\n+import org.testng.ITestContext;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static java.lang.System.out;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.expectThrows;\n+\n+public class AggregateRequestBodyTest implements HttpServerAdapters {\n+\n+    SSLContext sslContext;\n+    HttpTestServer http1TestServer;   \/\/ HTTP\/1.1 ( http )\n+    HttpTestServer https1TestServer;  \/\/ HTTPS\/1.1 ( https  )\n+    HttpTestServer http2TestServer;   \/\/ HTTP\/2 ( h2c )\n+    HttpTestServer https2TestServer;  \/\/ HTTP\/2 ( h2  )\n+    String http1URI;\n+    String https1URI;\n+    String http2URI;\n+    String https2URI;\n+\n+    static final int RESPONSE_CODE = 200;\n+    static final int ITERATION_COUNT = 4;\n+    static final Class<IllegalArgumentException> IAE = IllegalArgumentException.class;\n+    \/\/ a shared executor helps reduce the amount of threads created by the test\n+    static final Executor executor = new TestExecutor(Executors.newCachedThreadPool());\n+    static final ConcurrentMap<String, Throwable> FAILURES = new ConcurrentHashMap<>();\n+    static volatile boolean tasksFailed;\n+    static final AtomicLong serverCount = new AtomicLong();\n+    static final AtomicLong clientCount = new AtomicLong();\n+    static final long start = System.nanoTime();\n+    public static String now() {\n+        long now = System.nanoTime() - start;\n+        long secs = now \/ 1000_000_000;\n+        long mill = (now % 1000_000_000) \/ 1000_000;\n+        long nan = now % 1000_000;\n+        return String.format(\"[%d s, %d ms, %d ns] \", secs, mill, nan);\n+    }\n+\n+    final ReferenceTracker TRACKER = ReferenceTracker.INSTANCE;\n+    private volatile HttpClient sharedClient;\n+\n+    static class TestExecutor implements Executor {\n+        final AtomicLong tasks = new AtomicLong();\n+        Executor executor;\n+        TestExecutor(Executor executor) {\n+            this.executor = executor;\n+        }\n+\n+        @Override\n+        public void execute(Runnable command) {\n+            long id = tasks.incrementAndGet();\n+            executor.execute(() -> {\n+                try {\n+                    command.run();\n+                } catch (Throwable t) {\n+                    tasksFailed = true;\n+                    System.out.printf(now() + \"Task %s failed: %s%n\", id, t);\n+                    System.err.printf(now() + \"Task %s failed: %s%n\", id, t);\n+                    FAILURES.putIfAbsent(\"Task \" + id, t);\n+                    throw t;\n+                }\n+            });\n+        }\n+    }\n+\n+    protected boolean stopAfterFirstFailure() {\n+        return Boolean.getBoolean(\"jdk.internal.httpclient.debug\");\n+    }\n+\n+    @BeforeMethod\n+    void beforeMethod(ITestContext context) {\n+        if (stopAfterFirstFailure() && context.getFailedTests().size() > 0) {\n+            throw new RuntimeException(\"some tests failed\");\n+        }\n+    }\n+\n+    @AfterClass\n+    static final void printFailedTests() {\n+        out.println(\"\\n=========================\");\n+        try {\n+            out.printf(\"%n%sCreated %d servers and %d clients%n\",\n+                    now(), serverCount.get(), clientCount.get());\n+            if (FAILURES.isEmpty()) return;\n+            out.println(\"Failed tests: \");\n+            FAILURES.entrySet().forEach((e) -> {\n+                out.printf(\"\\t%s: %s%n\", e.getKey(), e.getValue());\n+                e.getValue().printStackTrace(out);\n+                e.getValue().printStackTrace();\n+            });\n+            if (tasksFailed) {\n+                System.out.println(\"WARNING: Some tasks failed\");\n+            }\n+        } finally {\n+            out.println(\"\\n=========================\\n\");\n+        }\n+    }\n+\n+    private String[] uris() {\n+        return new String[] {\n+                http1URI,\n+                https1URI,\n+                http2URI,\n+                https2URI,\n+        };\n+    }\n+\n+    static AtomicLong URICOUNT = new AtomicLong();\n+\n+    @DataProvider(name = \"variants\")\n+    public Object[][] variants(ITestContext context) {\n+        if (stopAfterFirstFailure() && context.getFailedTests().size() > 0) {\n+            return new Object[0][];\n+        }\n+        String[] uris = uris();\n+        Object[][] result = new Object[uris.length * 2][];\n+        int i = 0;\n+        for (boolean sameClient : List.of(false, true)) {\n+            for (String uri : uris()) {\n+                result[i++] = new Object[]{uri, sameClient};\n+            }\n+        }\n+        assert i == uris.length * 2;\n+        return result;\n+    }\n+\n+    private HttpClient makeNewClient() {\n+        clientCount.incrementAndGet();\n+        HttpClient client =  HttpClient.newBuilder()\n+                .proxy(HttpClient.Builder.NO_PROXY)\n+                .executor(executor)\n+                .sslContext(sslContext)\n+                .build();\n+        return TRACKER.track(client);\n+    }\n+\n+    HttpClient newHttpClient(boolean share) {\n+        if (!share) return makeNewClient();\n+        HttpClient shared = sharedClient;\n+        if (shared != null) return shared;\n+        synchronized (this) {\n+            shared = sharedClient;\n+            if (shared == null) {\n+                shared = sharedClient = makeNewClient();\n+            }\n+            return shared;\n+        }\n+    }\n+\n+    static final List<String> BODIES = List.of(\n+            \"Lorem ipsum\",\n+            \"dolor sit amet\",\n+            \"consectetur adipiscing elit, sed do eiusmod tempor\",\n+            \"quis nostrud exercitation ullamco\",\n+            \"laboris nisi\",\n+            \"ut\",\n+            \"aliquip ex ea commodo consequat.\" +\n+                    \"Duis aute irure dolor in reprehenderit in voluptate velit esse\" +\n+                    \"cillum dolore eu fugiat nulla pariatur.\",\n+            \"Excepteur sint occaecat cupidatat non proident.\"\n+    );\n+\n+    static BodyPublisher[] publishers(String... content) {\n+        if (content == null) return null;\n+        BodyPublisher[] result = new BodyPublisher[content.length];\n+        for (int i=0; i < content.length ; i++) {\n+            result[i] = content[i] == null ? null : BodyPublishers.ofString(content[i]);\n+        }\n+        return result;\n+    }\n+\n+    static String[] strings(String... s) {\n+        return s;\n+    }\n+\n+    @DataProvider(name = \"sparseContent\")\n+    Object[][] nulls() {\n+        return new Object[][] {\n+                {\"null array\", null},\n+                {\"null element\", strings((String)null)},\n+                {\"null first element\", strings(null, \"one\")},\n+                {\"null second element\", strings( \"one\", null)},\n+                {\"null third element\", strings( \"one\", \"two\", null)},\n+                {\"null fourth element\", strings( \"one\", \"two\", \"three\", null)},\n+                {\"null random element\", strings( \"one\", \"two\", \"three\", null, \"five\")},\n+        };\n+    }\n+\n+    static List<Long> lengths(long... lengths) {\n+        return LongStream.of(lengths)\n+                .mapToObj(Long::valueOf)\n+                .collect(Collectors.toList());\n+    }\n+\n+    @DataProvider(name = \"contentLengths\")\n+    Object[][] contentLengths() {\n+        return new Object[][] {\n+                {-1, lengths(-1)},\n+                {-42, lengths(-42)},\n+                {42, lengths(42)},\n+                {42, lengths(10, 0, 20, 0, 12)},\n+                {-1, lengths(10, 0, 20, -1, 12)},\n+                {-1, lengths(-1, 0, 20, 10, 12)},\n+                {-1, lengths(10, 0, 20, 12, -1)},\n+                {-1, lengths(10, 0, 20, -10, 12)},\n+                {-1, lengths(-10, 0, 20, 10, 12)},\n+                {-1, lengths(10, 0, 20, 12, -10)},\n+                {-1, lengths(10, 0, Long.MIN_VALUE, -1, 12)},\n+                {-1, lengths(-1, 0, Long.MIN_VALUE, 10, 12)},\n+                {-1, lengths(10, Long.MIN_VALUE, 20, 12, -1)},\n+                {Long.MAX_VALUE, lengths(10, Long.MAX_VALUE - 42L, 20, 0, 12)},\n+                {-1, lengths(10, Long.MAX_VALUE - 40L, 20, 0, 12)},\n+                {-1, lengths(10, Long.MAX_VALUE - 12L, 20, 0, 12)},\n+                {-1, lengths(10, Long.MAX_VALUE\/2L, Long.MAX_VALUE\/2L + 1L, 0, 12)},\n+                {-1, lengths(10, Long.MAX_VALUE\/2L, -1, Long.MAX_VALUE\/2L + 1L, 12)},\n+                {-1, lengths(10, Long.MAX_VALUE, 12, Long.MAX_VALUE, 20)},\n+                {-1, lengths(10, Long.MAX_VALUE, Long.MAX_VALUE, 12, 20)},\n+                {-1, lengths(0, Long.MAX_VALUE, Long.MAX_VALUE, 12, 20)},\n+                {-1, lengths(Long.MAX_VALUE, Long.MAX_VALUE, 12, 0, 20)}\n+        };\n+    }\n+\n+    @DataProvider(name=\"negativeRequests\")\n+    Object[][] negativeRequests() {\n+        return new Object[][] {\n+                {0L}, {-1L}, {-2L}, {Long.MIN_VALUE + 1L}, {Long.MIN_VALUE}\n+        };\n+    }\n+\n+\n+    static class ContentLengthPublisher implements BodyPublisher {\n+        final long length;\n+        ContentLengthPublisher(long length) {\n+            this.length = length;\n+        }\n+        @Override\n+        public long contentLength() {\n+            return length;\n+        }\n+\n+        @Override\n+        public void subscribe(Subscriber<? super ByteBuffer> subscriber) {\n+        }\n+\n+        static ContentLengthPublisher[] of(List<Long> lengths) {\n+            return lengths.stream()\n+                    .map(ContentLengthPublisher::new)\n+                    .toArray(ContentLengthPublisher[]::new);\n+        }\n+    }\n+\n+    \/**\n+     * A dummy publisher that allows to call onError on its subscriber (or not...).\n+     *\/\n+    static class PublishWithError implements BodyPublisher {\n+        final ConcurrentHashMap<Subscriber<?>, ErrorSubscription> subscribers = new ConcurrentHashMap<>();\n+        final long length;\n+        final List<String> content;\n+        final int errorAt;\n+        final Supplier<? extends Throwable> errorSupplier;\n+        PublishWithError(List<String> content, int errorAt, Supplier<? extends Throwable> supplier) {\n+            this.content = content;\n+            this.errorAt = errorAt;\n+            this.errorSupplier = supplier;\n+            length = content.stream().mapToInt(String::length).sum();\n+        }\n+\n+        boolean hasErrors() {\n+            return errorAt < content.size();\n+        }\n+\n+        @Override\n+        public long contentLength() {\n+            return length;\n+        }\n+\n+        @Override\n+        public void subscribe(Subscriber<? super ByteBuffer> subscriber) {\n+            ErrorSubscription subscription = new ErrorSubscription(subscriber);\n+            subscribers.put(subscriber, subscription);\n+            subscriber.onSubscribe(subscription);\n+        }\n+\n+        class ErrorSubscription implements Flow.Subscription {\n+            volatile boolean cancelled;\n+            volatile int at;\n+            final Subscriber<? super ByteBuffer> subscriber;\n+            ErrorSubscription(Subscriber<? super ByteBuffer> subscriber) {\n+                this.subscriber = subscriber;\n+            }\n+            @Override\n+            public void request(long n) {\n+                while (!cancelled && --n >= 0 && at <= Math.min(errorAt, content.size())) {\n+                    if (at++ == errorAt) {\n+                        subscriber.onError(errorSupplier.get());\n+                    } else if (at <= content.size()){\n+                        subscriber.onNext(ByteBuffer.wrap(\n+                                content.get(at-1).getBytes()));\n+                        if (at == content.size()) {\n+                            subscriber.onComplete();\n+                        }\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void cancel() {\n+                cancelled = true;\n+            }\n+        }\n+    }\n+\n+    static class RequestSubscriber implements Flow.Subscriber<ByteBuffer> {\n+        CompletableFuture<Subscription> subscriptionCF = new CompletableFuture<>();\n+        ConcurrentLinkedDeque<ByteBuffer> items = new ConcurrentLinkedDeque<>();\n+        CompletableFuture<List<ByteBuffer>> resultCF = new CompletableFuture<>();\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            this.subscriptionCF.complete(subscription);\n+        }\n+\n+        @Override\n+        public void onNext(ByteBuffer item) {\n+            items.addLast(item);\n+        }\n+\n+        @Override\n+        public void onError(Throwable throwable) {\n+            resultCF.completeExceptionally(throwable);\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            resultCF.complete(items.stream().collect(Collectors.toUnmodifiableList()));\n+        }\n+\n+        CompletableFuture<List<ByteBuffer>> resultCF() { return resultCF; }\n+    }\n+\n+    static String stringFromBuffer(ByteBuffer buffer) {\n+        byte[] bytes = new byte[buffer.remaining()];\n+        buffer.get(bytes);\n+        return new String(bytes);\n+    }\n+\n+    String stringFromBytes(Stream<ByteBuffer> buffers) {\n+        return buffers.map(AggregateRequestBodyTest::stringFromBuffer)\n+                .collect(Collectors.joining());\n+    }\n+\n+    static PublishWithError withNoError(String content) {\n+        return new PublishWithError(List.of(content), 1,\n+                () -> new AssertionError(\"Should not happen!\"));\n+    }\n+\n+    @Test(dataProvider = \"sparseContent\") \/\/ checks that NPE is thrown\n+    public void testNullPointerException(String description, String[] content) {\n+        BodyPublisher[] publishers = publishers(content);\n+        Assert.assertThrows(NullPointerException.class, () -> BodyPublishers.concat(publishers));\n+    }\n+\n+    \/\/ Verifies that an empty array creates a \"noBody\" publisher\n+    @Test\n+    public void testEmpty() {\n+        BodyPublisher publisher = BodyPublishers.concat();\n+        RequestSubscriber subscriber = new RequestSubscriber();\n+        assertEquals(publisher.contentLength(), 0);\n+        publisher.subscribe(subscriber);\n+        subscriber.subscriptionCF.thenAccept(s -> s.request(1));\n+        List<ByteBuffer> result = subscriber.resultCF.join();\n+        assertEquals(result, List.of());\n+        assertTrue(subscriber.items.isEmpty());;\n+    }\n+\n+    \/\/ verifies that error emitted by upstream publishers are propagated downstream.\n+    @Test(dataProvider = \"sparseContent\") \/\/ nulls are replaced with error publisher\n+    public void testOnError(String description, String[] content) {\n+        final RequestSubscriber subscriber = new RequestSubscriber();\n+        final PublishWithError errorPublisher;\n+        final BodyPublisher[] publishers;\n+        String result = BODIES.stream().collect(Collectors.joining());\n+        if (content == null) {\n+            content = List.of(result).toArray(String[]::new);\n+            errorPublisher = new PublishWithError(BODIES, BODIES.size(),\n+                    () -> new AssertionError(\"Unexpected!!\"));\n+            publishers = List.of(errorPublisher).toArray(new BodyPublisher[0]);\n+            description = \"No error\";\n+        } else {\n+            publishers = publishers(content);\n+            description = description.replace(\"null\", \"error at\");\n+            errorPublisher = new PublishWithError(BODIES, 2, () -> new Exception(\"expected\"));\n+        }\n+        result = \"\";\n+        boolean hasErrors = false;\n+        for (int i=0; i < content.length; i++) {\n+            if (content[i] == null) {\n+                publishers[i] = errorPublisher;\n+                if (hasErrors) continue;\n+                if (!errorPublisher.hasErrors()) {\n+                    result = result + errorPublisher\n+                            .content.stream().collect(Collectors.joining());\n+                } else {\n+                    result = result + errorPublisher.content\n+                            .stream().limit(errorPublisher.errorAt)\n+                            .collect(Collectors.joining());\n+                    result = result + \"<error>\";\n+                    hasErrors = true;\n+                }\n+            } else if (!hasErrors) {\n+                result = result + content[i];\n+            }\n+        }\n+        BodyPublisher publisher = BodyPublishers.concat(publishers);\n+        publisher.subscribe(subscriber);\n+        subscriber.subscriptionCF.thenAccept(s -> s.request(Long.MAX_VALUE));\n+        if (errorPublisher.hasErrors()) {\n+            CompletionException ce = expectThrows(CompletionException.class,\n+                    () -> subscriber.resultCF.join());\n+            out.println(description + \": got expected \" + ce);\n+            assertEquals(ce.getCause().getClass(), Exception.class);\n+            assertEquals(stringFromBytes(subscriber.items.stream()) + \"<error>\", result);\n+        } else {\n+            assertEquals(stringFromBytes(subscriber.resultCF.join().stream()), result);\n+            out.println(description + \": got expected result: \" + result);\n+        }\n+    }\n+\n+    \/\/ Verifies that if an upstream publisher has an unknown length, the\n+    \/\/ aggregate publisher will have an unknown length as well. Otherwise\n+    \/\/ the length should be known.\n+    @Test(dataProvider = \"sparseContent\") \/\/ nulls are replaced with unknown length\n+    public void testUnknownContentLength(String description, String[] content) {\n+        if (content == null) {\n+            content = BODIES.toArray(String[]::new);\n+            description = \"BODIES (known length)\";\n+        } else {\n+            description = description.replace(\"null\", \"length(-1)\");\n+        }\n+        BodyPublisher[] publishers = publishers(content);\n+        BodyPublisher nolength = new BodyPublisher() {\n+            final BodyPublisher missing = BodyPublishers.ofString(\"missing\");\n+            @Override\n+            public long contentLength() { return -1; }\n+            @Override\n+            public void subscribe(Subscriber<? super ByteBuffer> subscriber) {\n+                missing.subscribe(subscriber);\n+            }\n+        };\n+        long length = 0;\n+        for (int i=0; i < content.length; i++) {\n+            if (content[i] == null) {\n+                publishers[i] = nolength;\n+                length = -1;\n+            } else if (length >= 0) {\n+                length += content[i].length();\n+            }\n+        }\n+        out.printf(\"testUnknownContentLength(%s): %d%n\", description, length);\n+        BodyPublisher publisher = BodyPublishers.concat(publishers);\n+        assertEquals(publisher.contentLength(), length,\n+                description.replace(\"null\", \"length(-1)\"));\n+    }\n+\n+    @Test(dataProvider = \"negativeRequests\")\n+    public void testNegativeRequest(long n) {\n+        assert n <= 0 : \"test for negative request called with n > 0 : \" + n;\n+        BodyPublisher[] publishers = ContentLengthPublisher.of(List.of(1L, 2L, 3L));\n+        BodyPublisher publisher = BodyPublishers.concat(publishers);\n+        RequestSubscriber subscriber = new RequestSubscriber();\n+        publisher.subscribe(subscriber);\n+        Subscription subscription = subscriber.subscriptionCF.join();\n+        IllegalArgumentException iae = expectThrows(IAE, () -> subscription.request(n));\n+        System.out.printf(\"Got expected IAE for %d: %s%n\", n, iae);\n+    }\n+\n+    @Test(dataProvider = \"contentLengths\")\n+    public void testContentLength(long expected, List<Long> lengths) {\n+        BodyPublisher[] publishers = ContentLengthPublisher.of(lengths);\n+        BodyPublisher aggregate = BodyPublishers.concat(publishers);\n+        assertEquals(aggregate.contentLength(), expected,\n+                \"Unexpected result for %s\".formatted(lengths));\n+    }\n+\n+    \/\/ Verifies that cancelling the subscription ensure that downstream\n+    \/\/ publishers are no longer subscribed etc...\n+    @Test\n+    public void testCancel() {\n+        BodyPublisher[] publishers = BODIES.stream()\n+                .map(BodyPublishers::ofString)\n+                .toArray(BodyPublisher[]::new);\n+        BodyPublisher publisher = BodyPublishers.concat(publishers);\n+\n+        assertEquals(publisher.contentLength(),\n+                BODIES.stream().mapToInt(String::length).sum());\n+        Map<RequestSubscriber, String> subscribers = new LinkedHashMap<>();\n+\n+        for (int n=0; n < BODIES.size(); n++) {\n+\n+            String description = String.format(\n+                    \"cancel after %d\/%d onNext() invocations\",\n+                    n, BODIES.size());\n+            RequestSubscriber subscriber = new RequestSubscriber();\n+            publisher.subscribe(subscriber);\n+            Subscription subscription = subscriber.subscriptionCF.join();\n+            subscribers.put(subscriber, description);\n+\n+            \/\/ receive half the data\n+            for (int i = 0; i < n; i++) {\n+                subscription.request(1);\n+                ByteBuffer buffer = subscriber.items.pop();\n+            }\n+\n+            \/\/ cancel subscription\n+            subscription.cancel();\n+            \/\/ request the rest...\n+            subscription.request(Long.MAX_VALUE);\n+        }\n+\n+        CompletableFuture[] results = subscribers.keySet()\n+                .stream().map(RequestSubscriber::resultCF)\n+                .toArray(CompletableFuture[]::new);\n+        CompletableFuture<?> any = CompletableFuture.anyOf(results);\n+\n+        \/\/ subscription was cancelled, so nothing should be received...\n+        try {\n+            TimeoutException x = Assert.expectThrows(TimeoutException.class,\n+                    () -> any.get(5, TimeUnit.SECONDS));\n+            out.println(\"Got expected \" + x);\n+        } finally {\n+            subscribers.keySet().stream()\n+                    .filter(rs -> rs.resultCF.isDone())\n+                    .forEach(rs -> System.err.printf(\n+                            \"Failed: %s completed with %s\",\n+                            subscribers.get(rs), rs.resultCF));\n+        }\n+        Consumer<RequestSubscriber> check = (rs) -> {\n+            Assert.assertTrue(rs.items.isEmpty(), subscribers.get(rs) + \" has items\");\n+            Assert.assertFalse(rs.resultCF.isDone(), subscribers.get(rs) + \" was not cancelled\");\n+            out.println(subscribers.get(rs) + \": PASSED\");\n+        };\n+        subscribers.keySet().stream().forEach(check);\n+\n+    }\n+\n+    \/\/ Verifies that cancelling the subscription is propagated downstream\n+    @Test\n+    public void testCancelSubscription() {\n+        PublishWithError upstream = new PublishWithError(BODIES, BODIES.size(),\n+                () -> new AssertionError(\"should not come here\"));\n+        BodyPublisher publisher = BodyPublishers.concat(upstream);\n+\n+        assertEquals(publisher.contentLength(),\n+                BODIES.stream().mapToInt(String::length).sum());\n+        Map<RequestSubscriber, String> subscribers = new LinkedHashMap<>();\n+\n+        for (int n=0; n < BODIES.size(); n++) {\n+\n+            String description = String.format(\n+                    \"cancel after %d\/%d onNext() invocations\",\n+                    n, BODIES.size());\n+            RequestSubscriber subscriber = new RequestSubscriber();\n+            publisher.subscribe(subscriber);\n+            Subscription subscription = subscriber.subscriptionCF.join();\n+            subscribers.put(subscriber, description);\n+\n+            \/\/ receive half the data\n+            for (int i = 0; i < n; i++) {\n+                subscription.request(1);\n+                ByteBuffer buffer = subscriber.items.pop();\n+            }\n+\n+            \/\/ cancel subscription\n+            subscription.cancel();\n+            \/\/ request the rest...\n+            subscription.request(Long.MAX_VALUE);\n+            assertTrue(upstream.subscribers.get(subscriber).cancelled,\n+                    description + \" upstream subscription not cancelled\");\n+            out.println(description + \" upstream subscription was properly cancelled\");\n+        }\n+\n+        CompletableFuture[] results = subscribers.keySet()\n+                .stream().map(RequestSubscriber::resultCF)\n+                .toArray(CompletableFuture[]::new);\n+        CompletableFuture<?> any = CompletableFuture.anyOf(results);\n+\n+        \/\/ subscription was cancelled, so nothing should be received...\n+        try {\n+            TimeoutException x = Assert.expectThrows(TimeoutException.class,\n+                    () -> any.get(5, TimeUnit.SECONDS));\n+            out.println(\"Got expected \" + x);\n+        } finally {\n+            subscribers.keySet().stream()\n+                    .filter(rs -> rs.resultCF.isDone())\n+                    .forEach(rs -> System.err.printf(\n+                            \"Failed: %s completed with %s\",\n+                            subscribers.get(rs), rs.resultCF));\n+        }\n+        Consumer<RequestSubscriber> check = (rs) -> {\n+            Assert.assertTrue(rs.items.isEmpty(), subscribers.get(rs) + \" has items\");\n+            Assert.assertFalse(rs.resultCF.isDone(), subscribers.get(rs) + \" was not cancelled\");\n+            out.println(subscribers.get(rs) + \": PASSED\");\n+        };\n+        subscribers.keySet().stream().forEach(check);\n+\n+    }\n+\n+    @Test(dataProvider = \"variants\")\n+    public void test(String uri, boolean sameClient) throws Exception {\n+        System.out.println(\"Request to \" + uri);\n+\n+        HttpClient client = newHttpClient(sameClient);\n+\n+        BodyPublisher publisher = BodyPublishers.concat(\n+                BODIES.stream()\n+                        .map(BodyPublishers::ofString)\n+                        .toArray(HttpRequest.BodyPublisher[]::new)\n+                );\n+        HttpRequest request = HttpRequest.newBuilder(URI.create(uri))\n+                .POST(publisher)\n+                .build();\n+        for (int i = 0; i < ITERATION_COUNT; i++) {\n+            System.out.println(\"Iteration: \" + i);\n+            HttpResponse<String> response = client.send(request, BodyHandlers.ofString());\n+            int expectedResponse =  RESPONSE_CODE;\n+            if (response.statusCode() != expectedResponse)\n+                throw new RuntimeException(\"wrong response code \" + Integer.toString(response.statusCode()));\n+            assertEquals(response.body(), BODIES.stream().collect(Collectors.joining()));\n+        }\n+        System.out.println(\"test: DONE\");\n+    }\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        sslContext = new SimpleSSLContext().get();\n+        if (sslContext == null)\n+            throw new AssertionError(\"Unexpected null sslContext\");\n+\n+        HttpTestHandler handler = new HttpTestEchoHandler();\n+        InetSocketAddress loopback = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n+\n+        HttpServer http1 = HttpServer.create(loopback, 0);\n+        http1TestServer = HttpTestServer.of(http1);\n+        http1TestServer.addHandler(handler, \"\/http1\/echo\/\");\n+        http1URI = \"http:\/\/\" + http1TestServer.serverAuthority() + \"\/http1\/echo\/x\";\n+\n+        HttpsServer https1 = HttpsServer.create(loopback, 0);\n+        https1.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n+        https1TestServer = HttpTestServer.of(https1);\n+        https1TestServer.addHandler(handler, \"\/https1\/echo\/\");\n+        https1URI = \"https:\/\/\" + https1TestServer.serverAuthority() + \"\/https1\/echo\/x\";\n+\n+        \/\/ HTTP\/2\n+        http2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer.addHandler(handler, \"\/http2\/echo\/\");\n+        http2URI = \"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/echo\/x\";\n+\n+        https2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer.addHandler(handler, \"\/https2\/echo\/\");\n+        https2URI = \"https:\/\/\" + https2TestServer.serverAuthority() + \"\/https2\/echo\/x\";\n+\n+        serverCount.addAndGet(4);\n+        http1TestServer.start();\n+        https1TestServer.start();\n+        http2TestServer.start();\n+        https2TestServer.start();\n+    }\n+\n+    @AfterTest\n+    public void teardown() throws Exception {\n+        String sharedClientName =\n+                sharedClient == null ? null : sharedClient.toString();\n+        sharedClient = null;\n+        Thread.sleep(100);\n+        AssertionError fail = TRACKER.check(500);\n+        try {\n+            http1TestServer.stop();\n+            https1TestServer.stop();\n+            http2TestServer.stop();\n+            https2TestServer.stop();\n+        } finally {\n+            if (fail != null) {\n+                if (sharedClientName != null) {\n+                    System.err.println(\"Shared client name is: \" + sharedClientName);\n+                }\n+                throw fail;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/AggregateRequestBodyTest.java","additions":771,"deletions":0,"binary":false,"changes":771,"status":"added"}]}