{"files":[{"patch":"@@ -559,2 +559,0 @@\n-  heap->rem_set()->prepare_for_younger_refs_iterate(false);\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,1 +100,0 @@\n-  rem_set()->at_younger_refs_iterate();\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-  if(!ct->scanned_concurrently()) {\n+  if (!ct->scanned_concurrently()) {\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/cardTableBarrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -312,1 +312,1 @@\n-  \/\/ \"sp\" that point into younger generations.\n+  \/\/ \"sp\" that point into the young generation.\n","filename":"src\/hotspot\/share\/gc\/shared\/cardGeneration.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,40 +41,0 @@\n-CardTable::CardValue CardTableRS::find_unused_youngergenP_card_value() {\n-  for (CardValue v = youngergenP1_card;\n-       v < cur_youngergen_and_prev_nonclean_card;\n-       v++) {\n-    bool seen = false;\n-    for (int g = 0; g < _regions_to_iterate; g++) {\n-      if (_last_cur_val_in_gen[g] == v) {\n-        seen = true;\n-        break;\n-      }\n-    }\n-    if (!seen) {\n-      return v;\n-    }\n-  }\n-  ShouldNotReachHere();\n-  return 0;\n-}\n-\n-void CardTableRS::prepare_for_younger_refs_iterate(bool parallel) {\n-  \/\/ Parallel or sequential, we must always set the prev to equal the\n-  \/\/ last one written.\n-  if (parallel) {\n-    \/\/ Find a parallel value to be used next.\n-    jbyte next_val = find_unused_youngergenP_card_value();\n-    set_cur_youngergen_card_val(next_val);\n-\n-  } else {\n-    \/\/ In an sequential traversal we will always write youngergen, so that\n-    \/\/ the inline barrier is  correct.\n-    set_cur_youngergen_card_val(youngergen_card);\n-  }\n-}\n-\n-void CardTableRS::at_younger_refs_iterate() {\n-  \/\/ The indexing in this array is slightly odd. We want to access\n-  \/\/ the old generation record here, which is at index 2.\n-  _last_cur_val_in_gen[2] = cur_youngergen_card_val();\n-}\n-\n@@ -83,5 +43,2 @@\n-  assert(entry_val != CardTableRS::clean_card_val(),\n-         \"We shouldn't be looking at clean cards, and this should \"\n-         \"be the only place they get cleaned.\");\n-  assert(entry_val != CardTableRS::cur_youngergen_and_prev_nonclean_card,\n-         \"This should be possible in the sequential case.\");\n+  assert(entry_val == CardTableRS::dirty_card_val(),\n+         \"Only look at dirty cards.\");\n@@ -483,16 +440,1 @@\n-  CardTable(whole_heap, scanned_concurrently),\n-  _cur_youngergen_card_val(youngergenP1_card),\n-  \/\/ LNC functionality\n-  _lowest_non_clean(NULL),\n-  _lowest_non_clean_chunk_size(NULL),\n-  _lowest_non_clean_base_chunk_index(NULL),\n-  _last_LNC_resizing_collection(NULL)\n-{\n-  \/\/ max_gens is really GenCollectedHeap::heap()->gen_policy()->number_of_generations()\n-  \/\/ (which is always 2, young & old), but GenCollectedHeap has not been initialized yet.\n-  uint max_gens = 2;\n-  _last_cur_val_in_gen = NEW_C_HEAP_ARRAY(CardValue, max_gens + 1, mtGC);\n-  for (uint i = 0; i < max_gens + 1; i++) {\n-    _last_cur_val_in_gen[i] = clean_card_val();\n-  }\n-}\n+  CardTable(whole_heap, scanned_concurrently) { }\n@@ -500,7 +442,1 @@\n-CardTableRS::~CardTableRS() {\n-  FREE_C_HEAP_ARRAY(CardValue, _last_cur_val_in_gen);\n-  FREE_C_HEAP_ARRAY(CardArr, _lowest_non_clean);\n-  FREE_C_HEAP_ARRAY(size_t, _lowest_non_clean_chunk_size);\n-  FREE_C_HEAP_ARRAY(uintptr_t, _lowest_non_clean_base_chunk_index);\n-  FREE_C_HEAP_ARRAY(int, _last_LNC_resizing_collection);\n-}\n+CardTableRS::~CardTableRS() { }\n@@ -510,25 +446,0 @@\n-  _lowest_non_clean =\n-    NEW_C_HEAP_ARRAY(CardArr, _max_covered_regions, mtGC);\n-  _lowest_non_clean_chunk_size =\n-    NEW_C_HEAP_ARRAY(size_t, _max_covered_regions, mtGC);\n-  _lowest_non_clean_base_chunk_index =\n-    NEW_C_HEAP_ARRAY(uintptr_t, _max_covered_regions, mtGC);\n-  _last_LNC_resizing_collection =\n-    NEW_C_HEAP_ARRAY(int, _max_covered_regions, mtGC);\n-\n-  for (int i = 0; i < _max_covered_regions; i++) {\n-    _lowest_non_clean[i] = NULL;\n-    _lowest_non_clean_chunk_size[i] = 0;\n-    _last_LNC_resizing_collection[i] = -1;\n-  }\n-}\n-\n-bool CardTableRS::card_will_be_scanned(CardValue cv) {\n-  return card_is_dirty_wrt_gen_iter(cv) || is_prev_nonclean_card_val(cv);\n-}\n-\n-bool CardTableRS::card_may_have_been_dirty(CardValue cv) {\n-  return\n-    cv != clean_card &&\n-    (card_is_dirty_wrt_gen_iter(cv) ||\n-     CardTableRS::youngergen_may_have_been_dirty(cv));\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableRS.cpp","additions":5,"deletions":94,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-class CardTableRS: public CardTable {\n+class CardTableRS : public CardTable {\n@@ -47,40 +47,0 @@\n-  enum ExtendedCardValue {\n-    youngergen_card   = CT_MR_BS_last_reserved + 1,\n-    \/\/ These are for parallel collection.\n-    \/\/ There are three P (parallel) youngergen card values.  In general, this\n-    \/\/ needs to be more than the number of generations (including the perm\n-    \/\/ gen) that might have younger_refs_do invoked on them separately.  So\n-    \/\/ if we add more gens, we have to add more values.\n-    youngergenP1_card  = CT_MR_BS_last_reserved + 2,\n-    youngergenP2_card  = CT_MR_BS_last_reserved + 3,\n-    youngergenP3_card  = CT_MR_BS_last_reserved + 4,\n-    cur_youngergen_and_prev_nonclean_card =\n-      CT_MR_BS_last_reserved + 5\n-  };\n-\n-  \/\/ An array that contains, for each generation, the card table value last\n-  \/\/ used as the current value for a younger_refs_do iteration of that\n-  \/\/ portion of the table. The perm gen is index 0. The young gen is index 1,\n-  \/\/ but will always have the value \"clean_card\". The old gen is index 2.\n-  CardValue* _last_cur_val_in_gen;\n-\n-  CardValue _cur_youngergen_card_val;\n-\n-  \/\/ Number of generations, plus one for lingering PermGen issues in CardTableRS.\n-  static const int _regions_to_iterate = 3;\n-\n-  CardValue cur_youngergen_card_val() {\n-    return _cur_youngergen_card_val;\n-  }\n-  void set_cur_youngergen_card_val(CardValue v) {\n-    _cur_youngergen_card_val = v;\n-  }\n-  bool is_prev_youngergen_card_val(CardValue v) {\n-    return\n-      youngergen_card <= v &&\n-      v < cur_youngergen_and_prev_nonclean_card &&\n-      v != _cur_youngergen_card_val;\n-  }\n-  \/\/ Return a youngergen_card_value that is not currently in use.\n-  CardValue find_unused_youngergenP_card_value();\n-\n@@ -95,6 +55,0 @@\n-  \/\/ Override.\n-  void prepare_for_younger_refs_iterate(bool parallel);\n-\n-  \/\/ Card table entries are cleared before application;\n-  void at_younger_refs_iterate();\n-\n@@ -103,4 +57,1 @@\n-    *byte = youngergen_card;\n-  }\n-  void write_ref_field_gc_work(void* field, oop new_val) {\n-    inline_write_ref_field_gc(field, new_val);\n+    *byte = dirty_card_val();\n@@ -120,27 +71,0 @@\n-  bool is_prev_nonclean_card_val(CardValue v) {\n-    return\n-      youngergen_card <= v &&\n-      v <= cur_youngergen_and_prev_nonclean_card &&\n-      v != _cur_youngergen_card_val;\n-  }\n-\n-  static bool youngergen_may_have_been_dirty(CardValue cv) {\n-    return cv == CardTableRS::cur_youngergen_and_prev_nonclean_card;\n-  }\n-\n-  \/\/ *** Support for parallel card scanning.\n-\n-  \/\/ dirty and precleaned are equivalent wrt younger_refs_iter.\n-  static bool card_is_dirty_wrt_gen_iter(CardValue cv) {\n-    return cv == dirty_card;\n-  }\n-\n-  \/\/ Returns \"true\" iff the value \"cv\" will cause the card containing it\n-  \/\/ to be scanned in the current traversal.  May be overridden by\n-  \/\/ subtypes.\n-  bool card_will_be_scanned(CardValue cv);\n-\n-  \/\/ Returns \"true\" iff the value \"cv\" may have represented a dirty card at\n-  \/\/ some point.\n-  bool card_may_have_been_dirty(CardValue cv);\n-\n@@ -156,12 +80,0 @@\n-  \/\/ This is an array, one element per covered region of the card table.\n-  \/\/ Each entry is itself an array, with one element per chunk in the\n-  \/\/ covered region.  Each entry of these arrays is the lowest non-clean\n-  \/\/ card of the corresponding chunk containing part of an object from the\n-  \/\/ previous chunk, or else NULL.\n-  typedef CardValue* CardPtr;\n-  typedef CardPtr* CardArr;\n-  CardArr* _lowest_non_clean;\n-  size_t*  _lowest_non_clean_chunk_size;\n-  uintptr_t* _lowest_non_clean_base_chunk_index;\n-  volatile int* _last_LNC_resizing_collection;\n-\n@@ -182,3 +94,0 @@\n-  \/\/ Work methods called by the clear_card()\n-  inline bool clear_card_serial(CardValue* entry);\n-  inline bool clear_card_parallel(CardValue* entry);\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableRS.hpp","additions":3,"deletions":94,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -282,2 +282,0 @@\n-  declare_constant(CardTableRS::youngergen_card)                            \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shared\/vmStructs_gc.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}