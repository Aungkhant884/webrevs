{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,0 +60,1 @@\n+    \/\/ using a monitor here is fine: no logging while holding it\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/BufferingSubscriber.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -60,0 +61,1 @@\n+    private final ReentrantLock stateLock = new ReentrantLock();\n@@ -64,1 +66,1 @@\n-    boolean stopped;\n+    volatile boolean stopped;\n@@ -142,1 +144,1 @@\n-    synchronized void start() {\n+    void start() {\n@@ -152,3 +154,15 @@\n-    synchronized HttpConnection getConnection(boolean secure,\n-                                              InetSocketAddress addr,\n-                                              InetSocketAddress proxy) {\n+    HttpConnection getConnection(boolean secure,\n+                                 InetSocketAddress addr,\n+                                 InetSocketAddress proxy) {\n+        if (stopped) return null;\n+        stateLock.lock();\n+        try {\n+            return getConnection0(secure, addr, proxy);\n+        } finally {\n+            stateLock.unlock();\n+        }\n+    }\n+\n+    private HttpConnection getConnection0(boolean secure,\n+                                          InetSocketAddress addr,\n+                                          InetSocketAddress proxy) {\n@@ -188,1 +202,2 @@\n-        synchronized(this) {\n+        stateLock.lock();\n+        try {\n@@ -206,0 +221,2 @@\n+        } finally {\n+            stateLock.unlock();\n@@ -246,1 +263,1 @@\n-        assert Thread.holdsLock(this);\n+        assert stateLock.isHeldByCurrentThread();\n@@ -291,1 +308,2 @@\n-        synchronized (this) {\n+        stateLock.lock();\n+        try {\n@@ -305,0 +323,2 @@\n+        } finally {\n+            stateLock.unlock();\n@@ -319,1 +339,2 @@\n-            synchronized (this) {\n+            stateLock.lock();\n+            try {\n@@ -327,0 +348,2 @@\n+            } finally {\n+                stateLock.unlock();\n@@ -357,1 +380,1 @@\n-        \/\/ Does not require synchronizing on the ConnectionPool.\n+        \/\/ Does not require holding the ConnectionPool stateLock.\n@@ -363,2 +386,1 @@\n-        \/\/ should only be called while holding a synchronization\n-        \/\/ lock on the ConnectionPool\n+        \/\/ should only be called while holding the ConnectionPool stateLock.\n@@ -370,2 +392,1 @@\n-        \/\/ should only be called while holding a synchronization\n-        \/\/ lock on the ConnectionPool\n+        \/\/ should only be called while holding the ConnectionPool stateLock.\n@@ -377,2 +398,1 @@\n-        \/\/ should only be called while holding a synchronization\n-        \/\/ lock on the ConnectionPool\n+        \/\/ should only be called while holding the ConnectionPool stateLock.\n@@ -411,2 +431,1 @@\n-        \/\/ should only be called while holding a synchronization\n-        \/\/ lock on the ConnectionPool\n+        \/\/ should only be called while holding the ConnectionPool stateLock.\n@@ -426,2 +445,1 @@\n-        \/\/ should only be called while holding a synchronization\n-        \/\/ lock on the ConnectionPool.\n+        \/\/ should only be called while holding the ConnectionPool stateLock.\n@@ -453,2 +471,1 @@\n-        \/\/ should only be called while holding a synchronization\n-        \/\/ lock on the ConnectionPool\n+        \/\/ should only be called while holding the ConnectionPool stateLock.\n@@ -459,2 +476,1 @@\n-        \/\/ should only be called while holding a synchronization\n-        \/\/ lock on the ConnectionPool\n+        \/\/ should only be called while holding the ConnectionPool stateLock.\n@@ -468,2 +484,1 @@\n-    \/\/ should only be called while holding a synchronization\n-    \/\/ lock on the ConnectionPool\n+    \/\/ should only be called while holding the ConnectionPool stateLock.\n@@ -471,1 +486,1 @@\n-        assert Thread.holdsLock(this);\n+        assert stateLock.isHeldByCurrentThread();\n@@ -481,1 +496,10 @@\n-    synchronized boolean contains(HttpConnection c) {\n+    boolean contains(HttpConnection c) {\n+        stateLock.lock();\n+        try {\n+            return contains0(c);\n+        } finally {\n+            stateLock.unlock();\n+        }\n+    }\n+\n+    private boolean contains0(HttpConnection c) {\n@@ -497,1 +521,2 @@\n-        synchronized(this) {\n+        stateLock.lock();\n+        try {\n@@ -500,0 +525,2 @@\n+        } finally {\n+            stateLock.unlock();\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ConnectionPool.java","additions":57,"deletions":30,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -291,1 +291,1 @@\n-            synchronized(this) {\n+            synchronized (this) {\n@@ -374,1 +374,1 @@\n-            synchronized(Exchange.this) {\n+            synchronized (Exchange.this) {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Exchange.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -422,1 +422,1 @@\n-        synchronized(this) {\n+        synchronized (this) {\n@@ -446,1 +446,2 @@\n-        synchronized(this) {\n+        boolean unsubscribed = false;\n+        synchronized (this) {\n@@ -448,1 +449,0 @@\n-                if (debug.on()) debug.log(\"Unsubscribed %s\", delegate);\n@@ -450,0 +450,1 @@\n+                unsubscribed = true;\n@@ -452,0 +453,3 @@\n+        if (unsubscribed) {\n+            if (debug.on()) debug.log(\"Unsubscribed %s\", delegate);\n+        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http1AsyncReceiver.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -42,1 +42,2 @@\n-import java.util.concurrent.Flow.Subscription;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -71,1 +72,1 @@\n-    private Throwable failed;\n+    private final AtomicReference<Throwable> failedRef = new AtomicReference<>();\n@@ -75,1 +76,1 @@\n-    private final Object lock = new Object();\n+    private final ReentrantLock lock = new ReentrantLock();\n@@ -271,2 +272,3 @@\n-        synchronized (lock) {\n-            failed = this.failed;\n+        lock.lock();\n+        try {\n+            failed = failedRef.get();\n@@ -276,0 +278,2 @@\n+        } finally {\n+            lock.unlock();\n@@ -311,2 +315,3 @@\n-            synchronized (lock) {\n-                if ((cancelled = failed) == null) {\n+            lock.lock();\n+            try {\n+                if ((cancelled = failedRef.get()) == null) {\n@@ -315,0 +320,2 @@\n+            } finally {\n+                lock.unlock();\n@@ -345,1 +352,2 @@\n-                        synchronized (lock) {\n+                        lock.lock();\n+                        try {\n@@ -347,0 +355,2 @@\n+                        } finally {\n+                            lock.unlock();\n@@ -413,1 +423,2 @@\n-        synchronized (lock) {\n+        lock.lock();\n+        try {\n@@ -415,2 +426,3 @@\n-            cause = failed;\n-            failed = null;\n+            cause = failedRef.compareAndExchange(failedRef.get(), null);\n+        } finally {\n+            lock.unlock();\n@@ -472,1 +484,2 @@\n-        synchronized (lock) {\n+        lock.lock();\n+        try {\n@@ -475,0 +488,2 @@\n+        } finally {\n+            lock.unlock();\n@@ -521,1 +536,2 @@\n-        synchronized (lock) {\n+        lock.lock();\n+        try {\n@@ -523,3 +539,2 @@\n-            if ((error = failed) == null) {\n-                failed = error = cause;\n-            }\n+            failedRef.compareAndSet(null, cause);\n+            error = failedRef.get();\n@@ -554,0 +569,2 @@\n+        } finally {\n+            lock.unlock();\n@@ -604,3 +621,1 @@\n-        synchronized (lock) {\n-            return failed != null;\n-        }\n+        return failedRef.get() != null;\n@@ -611,3 +626,1 @@\n-        synchronized (lock) {\n-            return failed;\n-        }\n+        return failedRef.get();\n@@ -677,3 +690,1 @@\n-            synchronized (lock) {\n-                state = State.ERROR;\n-            }\n+            switchState(State.ERROR);\n@@ -690,3 +701,1 @@\n-                synchronized (lock) {\n-                    state = State.BODY;\n-                }\n+                switchState(State.BODY);\n@@ -699,3 +708,1 @@\n-                    synchronized (lock) {\n-                        state = State.COMPLETING;\n-                    }\n+                    switchState(State.COMPLETING);\n@@ -719,0 +726,19 @@\n+    State switchState(State newState) {\n+        lock.lock();\n+        try {\n+            return state = newState;\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    State switchAssertState(State expected, State newState) {\n+        lock.lock();\n+        try {\n+            assert state == expected : \"Unexpected state:\" + state + \", expected: \" + expected;\n+            return state = newState;\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n@@ -811,4 +837,1 @@\n-                            synchronized (lock) {\n-                                assert state == State.COMPLETING : \"Unexpected state:\" + state;\n-                                state = State.COMPLETED;\n-                            }\n+                            switchAssertState(State.COMPLETING, State.COMPLETED);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http1Exchange.java","additions":58,"deletions":35,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n@@ -117,2 +119,3 @@\n-    private final class ClientRefCountTracker {\n-        final HttpClientImpl client = connection.client();\n+    private static final class ClientRefCountTracker {\n+        final HttpClientImpl client;\n+        final Logger debug;\n@@ -121,1 +124,1 @@\n-        byte state;\n+        volatile byte state;\n@@ -123,2 +126,7 @@\n-        public synchronized boolean acquire() {\n-            if (state == 0) {\n+        ClientRefCountTracker(HttpClientImpl client, Logger logger) {\n+            this.client = client;\n+            this.debug = logger;\n+        }\n+\n+        public boolean acquire() {\n+            if (STATE.compareAndSet(this, (byte)0, (byte)0x01)) {\n@@ -131,1 +139,0 @@\n-                state = 0x01;\n@@ -142,2 +149,2 @@\n-        public synchronized void tryRelease() {\n-            if (state == 0x01) {\n+        public void tryRelease() {\n+            if (STATE.compareAndSet(this, (byte)0x01, (byte)0x03)) {\n@@ -153,1 +160,1 @@\n-                    debug.log(\"Operation finished: releasing ref count for %s\", client);\n+                    debug.log(\"Operation not started: releasing ref count for %s\", client);\n@@ -158,1 +165,10 @@\n-            state |= 0x02;\n+        }\n+\n+        private static final VarHandle STATE;\n+        static {\n+            try {\n+                STATE = MethodHandles.lookup().findVarHandle(\n+                        ClientRefCountTracker.class, \"state\", byte.class);\n+            } catch (NoSuchFieldException | IllegalAccessException e) {\n+                throw new ExceptionInInitializerError(e);\n+            }\n@@ -304,1 +320,1 @@\n-        ClientRefCountTracker refCountTracker = new ClientRefCountTracker();\n+        ClientRefCountTracker refCountTracker = new ClientRefCountTracker(connection.client(), debug);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http1Response.java","additions":28,"deletions":12,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import java.util.concurrent.locks.ReentrantLock;\n+\n@@ -70,1 +72,1 @@\n-    \/\/ only accessed from within synchronized blocks\n+    \/\/ only accessed from within lock protected blocks\n@@ -73,0 +75,2 @@\n+    private final ReentrantLock lock = new ReentrantLock();\n+\n@@ -102,1 +106,2 @@\n-        synchronized (this) {\n+        lock();\n+        try {\n@@ -128,0 +133,2 @@\n+        } finally {\n+            unlock();\n@@ -132,1 +139,2 @@\n-                    synchronized (Http2ClientImpl.this) {\n+                    lock();\n+                    try {\n@@ -145,0 +153,2 @@\n+                    } finally {\n+                        unlock();\n@@ -165,1 +175,2 @@\n-        synchronized(this) {\n+        lock();\n+        try {\n@@ -186,0 +197,2 @@\n+        } finally {\n+            unlock();\n@@ -192,1 +205,2 @@\n-        synchronized (this) {\n+        lock();\n+        try {\n@@ -197,0 +211,2 @@\n+        } finally {\n+            unlock();\n@@ -205,1 +221,6 @@\n-        synchronized (this) {stopping = true;}\n+        lock();\n+        try {\n+            stopping = true;\n+        } finally {\n+            unlock();\n+        }\n@@ -296,0 +317,8 @@\n+\n+    private void lock() {\n+        lock.lock();\n+    }\n+\n+    private void unlock() {\n+        lock.unlock();\n+    }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2ClientImpl.java","additions":35,"deletions":6,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-import java.util.Set;\n@@ -51,0 +50,2 @@\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -61,1 +62,0 @@\n-import jdk.internal.net.http.common.HttpHeadersBuilder;\n@@ -236,1 +236,2 @@\n-                synchronized (this) {\n+                stateLock.lock();\n+                try {\n@@ -246,0 +247,2 @@\n+                } finally {\n+                    stateLock.unlock();\n@@ -255,1 +258,1 @@\n-            \/\/ No additional synchronization is therefore necessary here.\n+            \/\/ No additional locking is therefore necessary here.\n@@ -277,1 +280,2 @@\n-            synchronized (this) {\n+            stateLock.lock();\n+            try {\n@@ -279,0 +283,2 @@\n+            } finally {\n+                stateLock.unlock();\n@@ -283,0 +289,1 @@\n+\n@@ -286,0 +293,1 @@\n+    private final Lock stateLock = new ReentrantLock();\n@@ -472,1 +480,10 @@\n-    synchronized boolean reserveStream(boolean clientInitiated) throws IOException {\n+    boolean reserveStream(boolean clientInitiated) throws IOException {\n+        stateLock.lock();\n+        try {\n+            return reserveStream0(clientInitiated);\n+        } finally {\n+            stateLock.unlock();\n+        }\n+    }\n+\n+    private boolean reserveStream0(boolean clientInitiated) throws IOException {\n@@ -559,2 +576,7 @@\n-    synchronized boolean finalStream() {\n-        return finalStream;\n+    boolean finalStream() {\n+        stateLock.lock();\n+        try {\n+            return finalStream;\n+        } finally {\n+            stateLock.unlock();\n+        }\n@@ -567,2 +589,7 @@\n-    synchronized void setFinalStream() {\n-        finalStream = true;\n+    void setFinalStream() {\n+        stateLock.lock();\n+        try {\n+            finalStream = true;\n+        } finally {\n+            stateLock.unlock();\n+        }\n@@ -1004,1 +1031,10 @@\n-    synchronized void decrementStreamsCount(int streamid) {\n+    void decrementStreamsCount(int streamid) {\n+        stateLock.lock();\n+        try {\n+            decrementStreamsCount0(streamid);\n+        } finally {\n+            stateLock.unlock();\n+        }\n+\n+    }\n+    private void decrementStreamsCount0(int streamid) {\n@@ -1036,1 +1072,2 @@\n-        synchronized (this) {\n+        stateLock.lock();\n+        try {\n@@ -1045,0 +1082,2 @@\n+        } finally {\n+            stateLock.unlock();\n@@ -1057,2 +1096,3 @@\n-            synchronized (this) {\n-                \/\/ idleConnectionTimerEvent is always accessed within a synchronized block\n+            stateLock.lock();\n+            try {\n+                \/\/ idleConnectionTimerEvent is always accessed within a lock protected block\n@@ -1066,0 +1106,2 @@\n+            } finally {\n+                stateLock.unlock();\n@@ -1251,1 +1293,2 @@\n-        synchronized (this) {\n+        stateLock.lock();\n+        try {\n@@ -1258,1 +1301,1 @@\n-                \/\/ idleConnectionTimerEvent is always accessed within a synchronized block\n+                \/\/ idleConnectionTimerEvent is always accessed within a lock protected block\n@@ -1265,0 +1308,2 @@\n+        } finally {\n+            stateLock.unlock();\n@@ -1381,1 +1426,1 @@\n-    private final Object sendlock = new Object();\n+    private final Lock sendlock = new ReentrantLock();\n@@ -1386,1 +1431,2 @@\n-            synchronized (sendlock) {\n+            sendlock.lock();\n+            try {\n@@ -1398,0 +1444,2 @@\n+            } finally {\n+                sendlock.unlock();\n@@ -1427,1 +1475,1 @@\n-     * Direct call of the method bypasses synchronization on \"sendlock\" and\n+     * Direct call of the method bypasses locking on \"sendlock\" and\n@@ -1544,2 +1592,7 @@\n-    synchronized boolean isActive() {\n-        return numReservedClientStreams > 0 || numReservedServerStreams > 0;\n+    boolean isActive() {\n+        stateLock.lock();\n+        try {\n+            return numReservedClientStreams > 0 || numReservedServerStreams > 0;\n+        } finally {\n+            stateLock.unlock();\n+        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":74,"deletions":21,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -569,1 +570,2 @@\n-            synchronized (selmgr) {\n+            selmgr.lock();\n+            try {\n@@ -579,0 +581,2 @@\n+            } finally {\n+                selmgr.unlock();\n@@ -1106,0 +1110,1 @@\n+        private final ReentrantLock lock = new ReentrantLock();\n@@ -1154,1 +1159,2 @@\n-                synchronized (this) {\n+                lock.lock();\n+                try {\n@@ -1159,0 +1165,2 @@\n+                } finally {\n+                    lock.unlock();\n@@ -1186,1 +1194,2 @@\n-            synchronized (this) {\n+            lock.lock();\n+            try {\n@@ -1198,0 +1207,2 @@\n+            } finally {\n+                lock.unlock();\n@@ -1217,1 +1228,2 @@\n-                synchronized (this) {\n+                lock.lock();\n+                try {\n@@ -1222,0 +1234,2 @@\n+                } finally {\n+                    lock.unlock();\n@@ -1243,1 +1257,2 @@\n-                    synchronized (this) {\n+                    lock.lock();\n+                    try {\n@@ -1293,0 +1308,2 @@\n+                    } finally {\n+                        lock.unlock();\n@@ -1453,0 +1470,8 @@\n+\n+        void lock() {\n+            lock.lock();\n+        }\n+\n+        void unlock() {\n+            lock.unlock();\n+        }\n@@ -1695,1 +1720,1 @@\n-    synchronized void registerTimer(TimeoutEvent event) {\n+    void registerTimer(TimeoutEvent event) {\n@@ -1697,2 +1722,4 @@\n-        timeouts.add(event);\n-        selmgr.wakeupSelector();\n+        synchronized (this) {\n+            timeouts.add(event);\n+            selmgr.wakeupSelector();\n+        }\n@@ -1701,1 +1728,1 @@\n-    synchronized void cancelTimer(TimeoutEvent event) {\n+    void cancelTimer(TimeoutEvent event) {\n@@ -1703,1 +1730,3 @@\n-        timeouts.remove(event);\n+        synchronized (this) {\n+            timeouts.remove(event);\n+        }\n@@ -1716,1 +1745,1 @@\n-        synchronized(this) {\n+        synchronized (this) {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientImpl.java","additions":40,"deletions":11,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-            synchronized(operations) {\n+            synchronized (operations) {\n@@ -107,1 +107,1 @@\n-            synchronized(operations) {\n+            synchronized (operations) {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpConnection.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -126,1 +126,1 @@\n-    public synchronized RawChannel rawChannel() throws IOException {\n+    public RawChannel rawChannel() throws IOException {\n@@ -150,1 +150,1 @@\n-    public synchronized void closeRawChannel() throws IOException {\n+    public void closeRawChannel() throws IOException {\n@@ -183,0 +183,1 @@\n+        private final ReentrantLock stateLock = new ReentrantLock();\n@@ -196,1 +197,10 @@\n-        public synchronized RawChannel rawChannel() {\n+        public RawChannel rawChannel() {\n+            stateLock.lock();\n+            try {\n+                return rawChannel0();\n+            } finally {\n+                stateLock.unlock();\n+            }\n+        }\n+\n+        private RawChannel rawChannel0() {\n@@ -216,1 +226,1 @@\n-        public synchronized void closeRawChannel() throws IOException {\n+        public void closeRawChannel() throws IOException {\n@@ -219,2 +229,7 @@\n-            if (rawchan != null) rawchan.close();\n-            else connection.close();\n+            stateLock.lock();\n+            try {\n+                if (rawchan != null) rawchan.close();\n+                else connection.close();\n+            } finally {\n+                stateLock.unlock();\n+            }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpResponseImpl.java","additions":23,"deletions":8,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -214,4 +214,5 @@\n-    private synchronized void setExchange(Exchange<T> exchange) {\n-        if (this.exchange != null && exchange != this.exchange) {\n-            this.exchange.released();\n-            if (cancelled) exchange.cancel();\n+    private void setExchange(Exchange<T> exchange) {\n+        Exchange<T> previousExchange;\n+        synchronized (this) {\n+            previousExchange = this.exchange;\n+            this.exchange = exchange;\n@@ -219,1 +220,4 @@\n-        this.exchange = exchange;\n+        if (previousExchange != null && exchange != previousExchange) {\n+            previousExchange.released();\n+        }\n+        if (cancelled) exchange.cancel();\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/MultiExchange.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,0 @@\n-    private final Object reading = new Object();\n@@ -58,1 +57,1 @@\n-    private final PlainHttpPublisher writePublisher = new PlainHttpPublisher(reading);\n+    private final PlainHttpPublisher writePublisher = new PlainHttpPublisher();\n@@ -60,1 +59,1 @@\n-    private boolean closed;\n+    private volatile boolean closed;\n@@ -246,3 +245,3 @@\n-            if (!closed) {\n-                client().connectionOpened(this);\n-            }\n+        }\n+        if (!closed) {\n+            client().connectionOpened(this);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/PlainHttpConnection.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.security.AccessControlContext;\n@@ -36,0 +35,1 @@\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -45,1 +45,0 @@\n-    private final HttpRequest initiatingRequest;\n@@ -47,1 +46,3 @@\n-    final CompletableFuture<Void> noMorePushesCF;\n+    private final ReentrantLock stateLock = new ReentrantLock();\n+\n+    private final HttpRequest initiatingRequest;\n@@ -58,1 +59,0 @@\n-    boolean noMorePushes = false;\n@@ -71,1 +71,0 @@\n-        this.noMorePushesCF = new MinimalFuture<>();\n@@ -120,1 +119,2 @@\n-        synchronized (this) {\n+        stateLock.lock();\n+        try {\n@@ -126,0 +126,2 @@\n+        } finally {\n+            stateLock.unlock();\n@@ -129,20 +131,8 @@\n-    \/\/ This is called when the main body response completes because it means\n-    \/\/ no more PUSH_PROMISEs are possible\n-\n-    synchronized void noMorePushes(boolean noMore) {\n-        noMorePushes = noMore;\n-        checkIfCompleted();\n-        noMorePushesCF.complete(null);\n-    }\n-\n-    synchronized CompletableFuture<Void> pushesCF() {\n-        return noMorePushesCF;\n-    }\n-\n-    synchronized boolean noMorePushes() {\n-        return noMorePushes;\n-    }\n-\n-    synchronized void pushCompleted() {\n-        remainingPushes--;\n-        checkIfCompleted();\n+    void pushCompleted() {\n+        stateLock.lock();\n+        try {\n+            remainingPushes--;\n+            checkIfCompleted();\n+        } finally {\n+            stateLock.unlock();\n+        }\n@@ -151,1 +141,2 @@\n-    synchronized void checkIfCompleted() {\n+    private void checkIfCompleted() {\n+        assert stateLock.isHeldByCurrentThread();\n@@ -153,1 +144,1 @@\n-            Log.logTrace(\"PushGroup remainingPushes={0} error={1} noMorePushes={2}\",\n+            Log.logTrace(\"PushGroup remainingPushes={0} error={1}\",\n@@ -155,2 +146,1 @@\n-                         (error==null)?error:error.getClass().getSimpleName(),\n-                         noMorePushes);\n+                         (error==null)?error:error.getClass().getSimpleName());\n@@ -158,1 +148,1 @@\n-        if (remainingPushes == 0 && error == null && noMorePushes) {\n+        if (remainingPushes == 0 && error == null) {\n@@ -165,1 +155,1 @@\n-    synchronized void pushError(Throwable t) {\n+    void pushError(Throwable t) {\n@@ -169,1 +159,6 @@\n-        this.error = t;\n+        stateLock.lock();\n+        try {\n+            this.error = t;\n+        } finally {\n+            stateLock.unlock();\n+        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/PushGroup.java","additions":29,"deletions":34,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import java.util.concurrent.locks.ReentrantLock;\n+\n@@ -38,0 +40,1 @@\n+    private final ReentrantLock stateLock = new ReentrantLock();\n@@ -61,4 +64,6 @@\n-    public synchronized void request(HttpRequestImpl r, MultiExchange<?> e) throws IOException {\n-        this.request = r;\n-        this.client = e.client();\n-        this.policy = client.followRedirects();\n+    public void request(HttpRequestImpl r, MultiExchange<?> e) throws IOException {\n+        stateLock.lock();\n+        try {\n+            this.request = r;\n+            this.client = e.client();\n+            this.policy = client.followRedirects();\n@@ -66,3 +71,6 @@\n-        this.method = r.method();\n-        this.uri = r.uri();\n-        this.exchange = e;\n+            this.method = r.method();\n+            this.uri = r.uri();\n+            this.exchange = e;\n+        } finally {\n+            stateLock.unlock();\n+        }\n@@ -72,2 +80,7 @@\n-    public synchronized HttpRequestImpl response(Response r) throws IOException {\n-        return handleResponse(r);\n+    public HttpRequestImpl response(Response r) throws IOException {\n+        stateLock.lock();\n+        try {\n+            return handleResponse(r);\n+        } finally {\n+            stateLock.unlock();\n+        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/RedirectFilter.java","additions":23,"deletions":10,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,0 +56,1 @@\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -198,1 +199,1 @@\n-                synchronized(this) {\n+                synchronized (this) {\n@@ -390,0 +391,1 @@\n+        final ReentrantLock stateLock = new ReentrantLock();\n@@ -436,1 +438,10 @@\n-        public synchronized boolean hasNext() {\n+        public boolean hasNext() {\n+            stateLock.lock();\n+            try {\n+                return hasNext0();\n+            } finally {\n+                stateLock.unlock();\n+            }\n+        }\n+\n+        private boolean hasNext0() {\n@@ -457,3 +468,10 @@\n-        public synchronized ByteBuffer next() {\n-            if (!hasNext()) {\n-                throw new NoSuchElementException();\n+        public ByteBuffer next() {\n+            stateLock.lock();\n+            try {\n+                if (!hasNext()) {\n+                    throw new NoSuchElementException();\n+                }\n+                need2Read = true;\n+                return nextBuffer;\n+            } finally {\n+                stateLock.unlock();\n@@ -461,2 +479,0 @@\n-            need2Read = true;\n-            return nextBuffer;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/RequestPublishers.java","additions":24,"deletions":8,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -498,0 +498,1 @@\n+                if (debug.on()) debug.log(\"write: resetting demand to 0\");\n@@ -500,1 +501,0 @@\n-                    if (debug.on()) debug.log(\"write: resetting demand to 0\");\n@@ -1266,1 +1266,1 @@\n-        synchronized(lock) {\n+        synchronized (lock) {\n@@ -1283,1 +1283,1 @@\n-        synchronized(lock) {\n+        synchronized (lock) {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/SocketTube.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -47,0 +47,2 @@\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -151,1 +153,2 @@\n-    private final Object sendLock = new Object();\n+    private final Lock sendLock = new ReentrantLock();\n+    private final Lock stateLock = new ReentrantLock();\n@@ -394,1 +397,2 @@\n-        synchronized (sendLock) {\n+        sendLock.lock();\n+        try {\n@@ -396,0 +400,2 @@\n+        } finally {\n+            sendLock.unlock();\n@@ -400,1 +406,2 @@\n-         synchronized (sendLock) {\n+        sendLock.lock();\n+         try {\n@@ -405,1 +412,3 @@\n-        }\n+        } finally {\n+             sendLock.unlock();\n+         }\n@@ -588,1 +597,2 @@\n-            synchronized (this) {\n+            stateLock.lock();\n+            try {\n@@ -594,0 +604,2 @@\n+            } finally {\n+                stateLock.lock();\n@@ -1121,0 +1133,1 @@\n+    final Lock response_cfs_lock = new ReentrantLock();\n@@ -1127,1 +1140,2 @@\n-        synchronized (response_cfs) {\n+        response_cfs_lock.lock();\n+        try {\n@@ -1142,0 +1156,2 @@\n+        } finally {\n+            response_cfs_lock.unlock();\n@@ -1161,1 +1177,2 @@\n-        synchronized (response_cfs) {\n+        response_cfs_lock.lock();\n+        try {\n@@ -1182,0 +1199,2 @@\n+        } finally {\n+            response_cfs_lock.unlock();\n@@ -1187,8 +1206,11 @@\n-    synchronized void requestSent() {\n-        requestSent = true;\n-        if (responseReceived) {\n-            if (debug.on()) debug.log(\"requestSent: streamid=%d\", streamid);\n-            close();\n-        } else {\n-            if (debug.on()) {\n-                debug.log(\"requestSent: streamid=%d but response not received\", streamid);\n+    void requestSent() {\n+        stateLock.lock();\n+        try {\n+            requestSent = true;\n+            if (responseReceived) {\n+                if (debug.on()) debug.log(\"requestSent: streamid=%d\", streamid);\n+                close();\n+            } else {\n+                if (debug.on()) {\n+                    debug.log(\"requestSent: streamid=%d but response not received\", streamid);\n+                }\n@@ -1196,0 +1218,2 @@\n+        } finally {\n+            stateLock.unlock();\n@@ -1199,8 +1223,11 @@\n-    synchronized void responseReceived() {\n-        responseReceived = true;\n-        if (requestSent) {\n-            if (debug.on()) debug.log(\"responseReceived: streamid=%d\", streamid);\n-            close();\n-        } else {\n-            if (debug.on()) {\n-                debug.log(\"responseReceived: streamid=%d but request not sent\", streamid);\n+    void responseReceived() {\n+        stateLock.lock();\n+        try {\n+            responseReceived = true;\n+            if (requestSent) {\n+                if (debug.on()) debug.log(\"responseReceived: streamid=%d\", streamid);\n+                close();\n+            } else {\n+                if (debug.on()) {\n+                    debug.log(\"responseReceived: streamid=%d but request not sent\", streamid);\n+                }\n@@ -1208,0 +1235,2 @@\n+        } finally {\n+            stateLock.unlock();\n@@ -1215,1 +1244,2 @@\n-        synchronized (response_cfs) {\n+        response_cfs_lock.lock();\n+        try {\n@@ -1227,0 +1257,2 @@\n+        } finally {\n+            response_cfs_lock.unlock();\n@@ -1311,1 +1343,2 @@\n-            synchronized (this) {\n+            stateLock.lock();\n+            try {\n@@ -1315,0 +1348,2 @@\n+            } finally {\n+                stateLock.unlock();\n@@ -1371,1 +1406,2 @@\n-        synchronized(this) {\n+        stateLock.lock();\n+        try {\n@@ -1374,0 +1410,2 @@\n+        } finally {\n+            stateLock.unlock();\n@@ -1402,1 +1440,1 @@\n-        HttpResponse.BodyHandler<T> pushHandler;\n+        volatile HttpResponse.BodyHandler<T> pushHandler;\n@@ -1421,1 +1459,1 @@\n-        synchronized void setPushHandler(HttpResponse.BodyHandler<T> pushHandler) {\n+        void setPushHandler(HttpResponse.BodyHandler<T> pushHandler) {\n@@ -1425,1 +1463,1 @@\n-        synchronized HttpResponse.BodyHandler<T> getPushHandler() {\n+        HttpResponse.BodyHandler<T> getPushHandler() {\n@@ -1491,5 +1529,0 @@\n-\/\/        @Override\n-\/\/        synchronized void responseReceived() {\n-\/\/            super.responseReceived();\n-\/\/        }\n-\n@@ -1573,1 +1606,1 @@\n-    synchronized boolean isCanceled() {\n+     boolean isCanceled() {\n@@ -1581,1 +1614,1 @@\n-    synchronized Throwable getCancelCause() {\n+    Throwable getCancelCause() {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":69,"deletions":36,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -43,0 +44,1 @@\n+    final ReentrantLock sendLock = new ReentrantLock();\n@@ -73,1 +75,2 @@\n-            synchronized (this) {\n+            sendLock.lock();\n+            try {\n@@ -79,0 +82,2 @@\n+            } finally {\n+                sendLock.unlock();\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/WindowUpdateSender.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,0 +52,1 @@\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -262,1 +263,1 @@\n-        final Object readBufferLock = new Object();\n+        final ReentrantLock readBufferLock = new ReentrantLock();\n@@ -343,1 +344,2 @@\n-            synchronized (readBufferLock) {\n+            readBufferLock.lock();\n+            try {\n@@ -360,0 +362,2 @@\n+            } finally {\n+                readBufferLock.unlock();\n@@ -426,1 +430,2 @@\n-                        synchronized (readBufferLock) {\n+                        readBufferLock.lock();\n+                        try {\n@@ -439,0 +444,2 @@\n+                        } finally {\n+                            readBufferLock.unlock();\n@@ -451,1 +458,2 @@\n-                            synchronized (readBufferLock) {\n+                            readBufferLock.lock();\n+                            try {\n@@ -468,0 +476,2 @@\n+                            } finally {\n+                                readBufferLock.unlock();\n@@ -503,1 +513,2 @@\n-                    synchronized (readBufferLock) {\n+                    readBufferLock.lock();\n+                    try {\n@@ -505,0 +516,2 @@\n+                    } finally {\n+                        readBufferLock.unlock();\n@@ -757,1 +770,1 @@\n-            synchronized(writeList) {\n+            synchronized (writeList) {\n@@ -1176,1 +1189,3 @@\n-                    synchronized (reader.readBufferLock) {\n+                    var readerLock = reader.readBufferLock;\n+                    readerLock.lock();\n+                    try {\n@@ -1178,0 +1193,2 @@\n+                    } finally {\n+                        readerLock.unlock();\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/SSLFlowDelegate.java","additions":25,"deletions":8,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -532,1 +532,1 @@\n-            synchronized(this) {\n+            synchronized (this) {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/SSLTube.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -159,23 +159,0 @@\n-    \/**\n-     * A task that runs its main loop within a synchronized block to provide\n-     * memory visibility between runs. Since the main loop can't run concurrently,\n-     * the lock shouldn't be contended and no deadlock should ever be possible.\n-     *\/\n-    public static final class SynchronizedRestartableTask\n-            extends CompleteRestartableTask {\n-\n-        private final Runnable mainLoop;\n-        private final Object lock = new Object();\n-\n-        public SynchronizedRestartableTask(Runnable mainLoop) {\n-            this.mainLoop = mainLoop;\n-        }\n-\n-        @Override\n-        protected void run() {\n-            synchronized(lock) {\n-                mainLoop.run();\n-            }\n-        }\n-    }\n-\n@@ -379,16 +356,0 @@\n-    \/**\n-     * Returns a new {@code SequentialScheduler} that executes the provided\n-     * {@code mainLoop} from within a {@link SynchronizedRestartableTask}.\n-     *\n-     * @apiNote This is equivalent to calling\n-     * {@code new SequentialScheduler(new SynchronizedRestartableTask(mainLoop))}\n-     * The main loop must not perform any blocking operation.\n-     *\n-     * @param mainLoop The main loop of the new sequential scheduler\n-     * @return a new {@code SequentialScheduler} that executes the provided\n-     * {@code mainLoop} from within a {@link SynchronizedRestartableTask}.\n-     *\/\n-    public static SequentialScheduler synchronizedScheduler(Runnable mainLoop) {\n-        return new SequentialScheduler(new SynchronizedRestartableTask(mainLoop));\n-    }\n-\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/SequentialScheduler.java","additions":1,"deletions":40,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -285,1 +285,1 @@\n-                synchronized(this) {\n+                synchronized (this) {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/SubscriberWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,1 @@\n-    public synchronized String toString() {\n+    public String toString() {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/SubscriptionBase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import java.lang.System.Logger.Level;\n@@ -43,0 +42,1 @@\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -76,1 +76,1 @@\n-    private final Object closeLock = new Object();\n+    private final ReentrantLock closeLock = new ReentrantLock();\n@@ -305,1 +305,2 @@\n-        synchronized (closeLock) {\n+        closeLock.lock();\n+        try {\n@@ -317,0 +318,2 @@\n+        } finally {\n+            closeLock.unlock();\n@@ -332,1 +335,2 @@\n-        synchronized (closeLock) {\n+        closeLock.lock();\n+        try {\n@@ -346,0 +350,2 @@\n+        } finally {\n+            closeLock.unlock();\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/websocket\/TransportImpl.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.httpclient.test.lib.http2.Http2TestServer;\n@@ -37,1 +36,0 @@\n-import com.sun.net.httpserver.HttpServer;\n@@ -58,0 +56,1 @@\n+ * -Djdk.tracePinnedThreads=full\n@@ -93,1 +92,3 @@\n-    ExecutorService executor = Executors.newCachedThreadPool();\n+    ExecutorService serverExecutor = Executors.newCachedThreadPool();\n+    ExecutorService virtualExecutor = Executors.newThreadPerTaskExecutor(Thread.ofVirtual()\n+            .name(\"HttpClient-Worker\", 0).factory());\n@@ -111,0 +112,1 @@\n+                .executor(virtualExecutor)\n@@ -125,1 +127,1 @@\n-            http1Server = HttpTestServer.create(HTTP_1_1, null, executor);\n+            http1Server = HttpTestServer.create(HTTP_1_1, null, serverExecutor);\n@@ -133,1 +135,1 @@\n-            sserver1.setExecutor(executor);\n+            sserver1.setExecutor(serverExecutor);\n@@ -178,1 +180,2 @@\n-        client = null;\n+        client.close();\n+        virtualExecutor.close();\n@@ -270,1 +273,1 @@\n-    static class MyAuthenticator extends Authenticator {\n+    static final class MyAuthenticator extends Authenticator {\n@@ -278,1 +281,0 @@\n-            System.out.println(\"Authenticator called: \" + ++count);\n@@ -283,0 +285,21 @@\n+        @Override\n+        public PasswordAuthentication requestPasswordAuthenticationInstance(String host,\n+                                                                            InetAddress addr,\n+                                                                            int port,\n+                                                                            String protocol,\n+                                                                            String prompt,\n+                                                                            String scheme,\n+                                                                            URL url,\n+                                                                            RequestorType reqType) {\n+            PasswordAuthentication passwordAuthentication;\n+            int count;\n+            synchronized (this) {\n+                count = ++this.count;\n+                passwordAuthentication = super.requestPasswordAuthenticationInstance(\n+                        host, addr, port, protocol, prompt, scheme, url, reqType);\n+            }\n+            \/\/ log outside of synchronized block\n+            System.out.println(\"Authenticator called: \" + count);\n+            return passwordAuthentication;\n+        }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/AuthFilterCacheTest.java","additions":31,"deletions":8,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ *      -Djdk.tracePinnedThreads=full\n@@ -48,0 +49,2 @@\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n@@ -49,0 +52,1 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -63,1 +67,0 @@\n-import jdk.httpclient.test.lib.common.HttpServerAdapters;\n@@ -89,0 +92,1 @@\n+    static final AtomicInteger IDS = new AtomicInteger();\n@@ -152,1 +156,7 @@\n-        HttpClient client = HttpClient.newBuilder().sslContext(sslContext).build();\n+        int id = IDS.getAndIncrement();\n+        ExecutorService virtualExecutor = Executors.newThreadPerTaskExecutor(Thread.ofVirtual()\n+                .name(\"HttpClient-\" + id + \"-Worker\", 0).factory());\n+        HttpClient client = HttpClient.newBuilder()\n+                .sslContext(sslContext)\n+                .executor(virtualExecutor)\n+                .build();\n@@ -171,0 +181,2 @@\n+        client.close();\n+        virtualExecutor.close();\n@@ -177,1 +189,6 @@\n-        HttpClient client = HttpClient.newBuilder().sslContext(sslContext).build();\n+        int id = IDS.getAndIncrement();\n+        ExecutorService virtualExecutor = Executors.newThreadPerTaskExecutor(Thread.ofVirtual()\n+                .name(\"HttpClient-\" + id + \"-Worker\", 0).factory());\n+        HttpClient client = HttpClient.newBuilder()\n+                .executor(virtualExecutor)\n+                .sslContext(sslContext).build();\n@@ -196,0 +213,2 @@\n+        client.close();\n+        virtualExecutor.close();\n","filename":"test\/jdk\/java\/net\/httpclient\/ConcurrentResponses.java","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * @run testng\/othervm ExpectContinueTest\n+ * @run testng\/othervm -Djdk.internal.httpclient.debug=err ExpectContinueTest\n@@ -38,2 +38,0 @@\n-import com.sun.net.httpserver.HttpServer;\n-\n@@ -66,1 +64,0 @@\n-import jdk.httpclient.test.lib.http2.Http2TestServer;\n","filename":"test\/jdk\/java\/net\/httpclient\/ExpectContinueTest.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -24,3 +24,0 @@\n-import com.sun.net.httpserver.HttpServer;\n-import com.sun.net.httpserver.HttpsConfigurator;\n-import com.sun.net.httpserver.HttpsServer;\n@@ -36,0 +33,1 @@\n+import java.io.Closeable;\n@@ -37,1 +35,0 @@\n-import java.net.InetSocketAddress;\n@@ -42,1 +39,0 @@\n-import java.nio.charset.StandardCharsets;\n@@ -49,0 +45,1 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -50,0 +47,2 @@\n+import java.util.function.Supplier;\n+\n@@ -51,1 +50,0 @@\n-import jdk.httpclient.test.lib.http2.Http2TestServer;\n@@ -75,0 +73,1 @@\n+ *      -Djdk.tracePinnedThreads=full\n@@ -89,0 +88,1 @@\n+    private static final AtomicInteger IDS = new AtomicInteger();\n@@ -188,1 +188,1 @@\n-                    newBuilder(configureClientSSL).build(),\n+                    newBuilder(configureClientSSL).provider(),\n@@ -194,1 +194,1 @@\n-                    newBuilder(configureClientSSL).localAddress(null).build(),\n+                    newBuilder(configureClientSSL).localAddress(null).provider(),\n@@ -203,1 +203,1 @@\n-                            .build(),\n+                            .provider(),\n@@ -214,1 +214,1 @@\n-                                .build(),\n+                                .provider(),\n@@ -225,1 +225,1 @@\n-                                .build(),\n+                                .provider(),\n@@ -234,1 +234,86 @@\n-    private static HttpClient.Builder newBuilder(boolean configureClientSSL) {\n+    \/\/ An object that holds a client and that can be closed\n+    \/\/ Used when closing the client might require closing additional\n+    \/\/ resources, such as an executor\n+    sealed interface ClientCloseable extends Closeable {\n+\n+        HttpClient client();\n+\n+        @Override\n+        void close();\n+\n+        \/\/ a reusable client that does nothing when close() is called,\n+        \/\/ so that the underlying client can be reused\n+        record ReusableClient(HttpClient client) implements ClientCloseable {\n+            \/\/ do not close the client so that it can be reused\n+            @Override\n+            public void close() { }\n+        }\n+\n+        \/\/ a client configured with an executor, that closes both the client\n+        \/\/ and the executor when close() is called\n+        record ClientWithExecutor(HttpClient client, ExecutorService service)\n+                implements ClientCloseable {\n+            \/\/ close both the client and executor\n+            @Override\n+            public void close() {\n+                client.close();\n+                service.close();\n+            }\n+        }\n+\n+        static ReusableClient reusable(HttpClient client) {\n+            return new ReusableClient(client);\n+        }\n+\n+        static ClientWithExecutor withExecutor(HttpClient client, ExecutorService service) {\n+            return new ClientWithExecutor(client, service);\n+        }\n+    }\n+\n+    \/\/ A supplier of ClientCloseable\n+    sealed interface ClientProvider extends Supplier<ClientCloseable> {\n+\n+        ClientCloseable get();\n+\n+        \/\/ a ClientProvider that returns reusable clients wrapping the given clieny\n+        record ReusableClientProvider(HttpClient client) implements ClientProvider {\n+            @Override\n+            public ClientCloseable get() {\n+                return ClientCloseable.reusable(client);\n+            }\n+        }\n+\n+        \/\/ A ClientProvider that builds a new ClientWithExecutor for every call to get()\n+        record ClientBuilder(HttpClient.Builder builder) implements ClientProvider {\n+            ClientCloseable build() {\n+                int id = IDS.getAndIncrement();\n+                ExecutorService virtualExecutor = Executors.newThreadPerTaskExecutor(Thread.ofVirtual()\n+                        .name(\"HttpClient-\" + id + \"-Worker\", 0).factory());\n+                builder.executor(virtualExecutor);\n+                return ClientCloseable.withExecutor(builder.build(), virtualExecutor);\n+            }\n+\n+            public ClientBuilder localAddress(InetAddress localAddress) {\n+                builder.localAddress(localAddress);\n+                return this;\n+            }\n+\n+            public ClientProvider provider() { return this; }\n+\n+            @Override\n+            public ClientCloseable get() { return build(); }\n+        }\n+\n+        static ReusableClientProvider reusable(HttpClient client) {\n+            return new ReusableClientProvider(client);\n+        }\n+\n+        static ClientBuilder builder(HttpClient.Builder builder) {\n+            return new ClientBuilder(builder);\n+        }\n+    }\n+\n+\n+\n+\n+    private static ClientProvider.ClientBuilder newBuilder(boolean configureClientSSL) {\n@@ -242,1 +327,1 @@\n-        return builder;\n+        return ClientProvider.builder(builder);\n@@ -252,11 +337,14 @@\n-    public void testSend(HttpClient client, URI requestURI, InetAddress localAddress) throws Exception {\n-        System.out.println(\"Testing using a HTTP client \" + client.version() + \" with local address \" + localAddress\n-                + \" against request URI \" + requestURI);\n-        \/\/ GET request\n-        var req = HttpRequest.newBuilder(requestURI).build();\n-        var resp = client.send(req, HttpResponse.BodyHandlers.ofByteArray());\n-        Assert.assertEquals(resp.statusCode(), 200, \"Unexpected status code\");\n-        \/\/ verify the address only if a specific one was set on the client\n-        if (localAddress != null && !localAddress.isAnyLocalAddress()) {\n-            Assert.assertEquals(resp.body(), localAddress.getAddress(),\n-                    \"Unexpected client address seen by the server handler\");\n+    public void testSend(ClientProvider clientProvider, URI requestURI, InetAddress localAddress) throws Exception {\n+        try (var c = clientProvider.get()) {\n+            HttpClient client = c.client();\n+            System.out.println(\"Testing using a HTTP client \" + client.version() + \" with local address \" + localAddress\n+                    + \" against request URI \" + requestURI);\n+            \/\/ GET request\n+            var req = HttpRequest.newBuilder(requestURI).build();\n+            var resp = client.send(req, HttpResponse.BodyHandlers.ofByteArray());\n+            Assert.assertEquals(resp.statusCode(), 200, \"Unexpected status code\");\n+            \/\/ verify the address only if a specific one was set on the client\n+            if (localAddress != null && !localAddress.isAnyLocalAddress()) {\n+                Assert.assertEquals(resp.body(), localAddress.getAddress(),\n+                        \"Unexpected client address seen by the server handler\");\n+            }\n@@ -273,13 +361,17 @@\n-    public void testSendAsync(HttpClient client, URI requestURI, InetAddress localAddress) throws Exception {\n-        System.out.println(\"Testing using a HTTP client \" + client.version() + \" with local address \" + localAddress\n-                + \" against request URI \" + requestURI);\n-        \/\/ GET request\n-        var req = HttpRequest.newBuilder(requestURI).build();\n-        var cf = client.sendAsync(req,\n-                HttpResponse.BodyHandlers.ofByteArray());\n-        var resp = cf.get();\n-        Assert.assertEquals(resp.statusCode(), 200, \"Unexpected status code\");\n-        \/\/ verify the address only if a specific one was set on the client\n-        if (localAddress != null && !localAddress.isAnyLocalAddress()) {\n-            Assert.assertEquals(resp.body(), localAddress.getAddress(),\n-                    \"Unexpected client address seen by the server handler\");\n+    public void testSendAsync(ClientProvider clientProvider, URI requestURI, InetAddress localAddress) throws Exception {\n+        try (var c = clientProvider.get()) {\n+            HttpClient client = c.client();\n+            System.out.println(\"Testing using a HTTP client \" + client.version()\n+                    + \" with local address \" + localAddress\n+                    + \" against request URI \" + requestURI);\n+            \/\/ GET request\n+            var req = HttpRequest.newBuilder(requestURI).build();\n+            var cf = client.sendAsync(req,\n+                    HttpResponse.BodyHandlers.ofByteArray());\n+            var resp = cf.get();\n+            Assert.assertEquals(resp.statusCode(), 200, \"Unexpected status code\");\n+            \/\/ verify the address only if a specific one was set on the client\n+            if (localAddress != null && !localAddress.isAnyLocalAddress()) {\n+                Assert.assertEquals(resp.body(), localAddress.getAddress(),\n+                        \"Unexpected client address seen by the server handler\");\n+            }\n@@ -290,1 +382,1 @@\n-     * Invokes the {@link #testSend(HttpClient)} and {@link #testSendAsync(HttpClient)}\n+     * Invokes the {@link #testSend} and {@link #testSendAsync}\n@@ -296,1 +388,3 @@\n-    public void testMultiSendRequests(HttpClient client, URI requestURI, InetAddress localAddress) throws Exception {\n+    public void testMultiSendRequests(ClientProvider clientProvider,\n+                                      URI requestURI,\n+                                      InetAddress localAddress) throws Exception {\n@@ -300,1 +394,3 @@\n-        try {\n+        try (var c = clientProvider.get()) {\n+            \/\/ prevents testSend\/testSendAsync from closing the client\n+            ClientProvider client = ClientProvider.reusable(c.client());\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpClientLocalAddrTest.java","additions":136,"deletions":40,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,4 +35,8 @@\n- * @run main\/othervm\/timeout=40 -Djdk.httpclient.HttpClient.log=ssl,channel ManyRequests\n- * @run main\/othervm\/timeout=40 -Djdk.httpclient.HttpClient.log=channel -Dtest.insertDelay=true ManyRequests\n- * @run main\/othervm\/timeout=40 -Djdk.httpclient.HttpClient.log=channel -Dtest.chunkSize=64 ManyRequests\n- * @run main\/othervm\/timeout=40 -Djdk.httpclient.HttpClient.log=channel -Dtest.insertDelay=true -Dtest.chunkSize=64 ManyRequests\n+ * @run main\/othervm\/timeout=40 -Djdk.tracePinnedThreads=full\n+ *                              -Djdk.httpclient.HttpClient.log=ssl,channel ManyRequests\n+ * @run main\/othervm\/timeout=40 -Djdk.tracePinnedThreads=full\n+ *                              -Djdk.httpclient.HttpClient.log=channel -Dtest.insertDelay=true ManyRequests\n+ * @run main\/othervm\/timeout=40 -Djdk.tracePinnedThreads=full\n+ *                              -Djdk.httpclient.HttpClient.log=channel -Dtest.chunkSize=64 ManyRequests\n+ * @run main\/othervm\/timeout=40 -Djdk.tracePinnedThreads=full\n+ *                              -Djdk.httpclient.HttpClient.log=channel -Dtest.insertDelay=true -Dtest.chunkSize=64 ManyRequests\n@@ -87,1 +91,1 @@\n-    static final int MAX_COUNT = 20;\n+    static final int MAX_COUNT = 50;\n@@ -98,0 +102,2 @@\n+        String osName = System.getProperty(\"os.name\", \"\");\n+        System.out.println(\"Running on: \" + osName);\n@@ -109,0 +115,2 @@\n+        ExecutorService virtualExecutor = Executors.newThreadPerTaskExecutor(Thread.ofVirtual()\n+                .name(\"HttpClient-Worker\", 0).factory());\n@@ -113,0 +121,1 @@\n+                                      .executor(virtualExecutor)\n@@ -119,0 +128,1 @@\n+            client.close();\n@@ -120,0 +130,1 @@\n+            virtualExecutor.close();\n@@ -263,1 +274,1 @@\n-                if (LIMIT.get() < REQUESTS) throw e;\n+                if (LIMIT.get() < MAX_LIMIT) throw e;\n@@ -269,1 +280,1 @@\n-                        LIMIT.set(REQUESTS\/2);\n+                        LIMIT.set(LIMIT.get()\/2);\n@@ -329,1 +340,1 @@\n-                for (int i=0; i<toRelease; i++) {\n+                for (int i=0; i<toRelease && !waiters.isEmpty(); i++) {\n","filename":"test\/jdk\/java\/net\/httpclient\/ManyRequests.java","additions":20,"deletions":9,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+ *                              -Djdk.tracePinnedThreads=full\n@@ -39,0 +40,1 @@\n+ *                              -Djdk.tracePinnedThreads=full\n@@ -41,0 +43,1 @@\n+ *                              -Djdk.tracePinnedThreads=full\n@@ -42,1 +45,2 @@\n- * @run main\/othervm\/timeout=40 -Djdk.internal.httpclient.debug=true\n+ * @run main\/othervm\/timeout=400 -Djdk.internal.httpclient.debug=true\n+ *                              -Djdk.tracePinnedThreads=full\n","filename":"test\/jdk\/java\/net\/httpclient\/ManyRequests2.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,3 @@\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -56,1 +59,1 @@\n- * @run main\/othervm PlainProxyConnectionTest\n+ * @run main\/othervm -Djdk.tracePinnedThreads=full PlainProxyConnectionTest\n@@ -64,0 +67,1 @@\n+    private static final AtomicInteger IDS = new AtomicInteger();\n@@ -199,0 +203,12 @@\n+        int id = IDS.getAndIncrement();\n+        ExecutorService virtualExecutor = Executors.newThreadPerTaskExecutor(Thread.ofVirtual()\n+                .name(\"HttpClient-\" + id + \"-Worker\", 0).factory());\n+        CountingProxySelector ps = CountingProxySelector.of(\n+                InetSocketAddress.createUnresolved(\n+                        server.getAddress().getAddress().getHostAddress(),\n+                        server.getAddress().getPort()));\n+        HttpClient client = HttpClient.newBuilder()\n+                .version(version)\n+                .executor(virtualExecutor)\n+                .proxy(ps)\n+                .build();\n@@ -209,8 +225,0 @@\n-            CountingProxySelector ps = CountingProxySelector.of(\n-                    InetSocketAddress.createUnresolved(\n-                            server.getAddress().getAddress().getHostAddress(),\n-                            server.getAddress().getPort()));\n-            HttpClient client = HttpClient.newBuilder()\n-                    .version(version)\n-                    .proxy(ps)\n-                    .build();\n@@ -271,0 +279,2 @@\n+            client.close();\n+            virtualExecutor.close();\n","filename":"test\/jdk\/java\/net\/httpclient\/PlainProxyConnectionTest.java","additions":20,"deletions":10,"binary":false,"changes":30,"status":"modified"}]}