{"files":[{"patch":"@@ -163,6 +163,21 @@\n-\n-        Map<HttpRequest, String> requests = new HashMap<>();\n-        for (int i=0;i<CONCURRENT_REQUESTS; i++) {\n-            HttpRequest request = HttpRequest.newBuilder(URI.create(uri + \"?\" + i))\n-                                             .build();\n-            requests.put(request, BODIES[i]);\n+        try {\n+            Map<HttpRequest, String> requests = new HashMap<>();\n+            for (int i = 0; i < CONCURRENT_REQUESTS; i++) {\n+                HttpRequest request = HttpRequest.newBuilder(URI.create(uri + \"?\" + i))\n+                        .build();\n+                requests.put(request, BODIES[i]);\n+            }\n+\n+            \/\/ initial connection to seed the cache so next parallel connections reuse it\n+            client.sendAsync(HttpRequest.newBuilder(URI.create(uri)).build(), discarding()).join();\n+\n+            \/\/ will reuse connection cached from the previous request ( when HTTP\/2 )\n+            CompletableFuture.allOf(requests.keySet().parallelStream()\n+                            .map(request -> client.sendAsync(request, BodyHandlers.ofString()))\n+                            .map(cf -> cf.thenCompose(ConcurrentResponses::assert200ResponseCode))\n+                            .map(cf -> cf.thenCompose(response -> assertbody(response, requests.get(response.request()))))\n+                            .toArray(CompletableFuture<?>[]::new))\n+                    .join();\n+        } finally {\n+            client.close();\n+            virtualExecutor.close();\n@@ -170,13 +185,0 @@\n-\n-        \/\/ initial connection to seed the cache so next parallel connections reuse it\n-        client.sendAsync(HttpRequest.newBuilder(URI.create(uri)).build(), discarding()).join();\n-\n-        \/\/ will reuse connection cached from the previous request ( when HTTP\/2 )\n-        CompletableFuture.allOf(requests.keySet().parallelStream()\n-                .map(request -> client.sendAsync(request, BodyHandlers.ofString()))\n-                .map(cf -> cf.thenCompose(ConcurrentResponses::assert200ResponseCode))\n-                .map(cf -> cf.thenCompose(response -> assertbody(response, requests.get(response.request()))))\n-                .toArray(CompletableFuture<?>[]::new))\n-                .join();\n-        client.close();\n-        virtualExecutor.close();\n@@ -195,6 +197,21 @@\n-\n-        Map<HttpRequest, String> requests = new HashMap<>();\n-        for (int i=0;i<CONCURRENT_REQUESTS; i++) {\n-            HttpRequest request = HttpRequest.newBuilder(URI.create(uri + \"?\" + i))\n-                    .build();\n-            requests.put(request, BODIES[i]);\n+        try {\n+            Map<HttpRequest, String> requests = new HashMap<>();\n+            for (int i = 0; i < CONCURRENT_REQUESTS; i++) {\n+                HttpRequest request = HttpRequest.newBuilder(URI.create(uri + \"?\" + i))\n+                        .build();\n+                requests.put(request, BODIES[i]);\n+            }\n+\n+            \/\/ initial connection to seed the cache so next parallel connections reuse it\n+            client.sendAsync(HttpRequest.newBuilder(URI.create(uri)).build(), discarding()).join();\n+\n+            \/\/ will reuse connection cached from the previous request ( when HTTP\/2 )\n+            CompletableFuture.allOf(requests.keySet().parallelStream()\n+                            .map(request -> client.sendAsync(request, CustomSubscriber.handler))\n+                            .map(cf -> cf.thenCompose(ConcurrentResponses::assert200ResponseCode))\n+                            .map(cf -> cf.thenCompose(response -> assertbody(response, requests.get(response.request()))))\n+                            .toArray(CompletableFuture<?>[]::new))\n+                    .join();\n+        } finally {\n+            client.close();\n+            virtualExecutor.close();\n@@ -202,13 +219,0 @@\n-\n-        \/\/ initial connection to seed the cache so next parallel connections reuse it\n-        client.sendAsync(HttpRequest.newBuilder(URI.create(uri)).build(), discarding()).join();\n-\n-        \/\/ will reuse connection cached from the previous request ( when HTTP\/2 )\n-        CompletableFuture.allOf(requests.keySet().parallelStream()\n-                .map(request -> client.sendAsync(request, CustomSubscriber.handler))\n-                .map(cf -> cf.thenCompose(ConcurrentResponses::assert200ResponseCode))\n-                .map(cf -> cf.thenCompose(response -> assertbody(response, requests.get(response.request()))))\n-                .toArray(CompletableFuture<?>[]::new))\n-                .join();\n-        client.close();\n-        virtualExecutor.close();\n@@ -217,0 +221,1 @@\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/ConcurrentResponses.java","additions":43,"deletions":38,"binary":false,"changes":81,"status":"modified"}]}