{"files":[{"patch":"@@ -432,1 +432,1 @@\n-  ZStatHeap::set_at_relocate_end(_page_allocator.stats());\n+  ZStatHeap::set_at_relocate_end(_page_allocator.stats(), _object_allocator.relocated());\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -117,2 +117,2 @@\n-  uintptr_t alloc_object_non_blocking(size_t size);\n-  void undo_alloc_object(uintptr_t addr, size_t size);\n+  uintptr_t alloc_object_for_relocation(size_t size);\n+  void undo_alloc_object_for_relocation(uintptr_t addr, size_t size);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,2 +82,2 @@\n-inline uintptr_t ZHeap::alloc_object_non_blocking(size_t size) {\n-  uintptr_t addr = _object_allocator.alloc_object_non_blocking(size);\n+inline uintptr_t ZHeap::alloc_object_for_relocation(size_t size) {\n+  const uintptr_t addr = _object_allocator.alloc_object_for_relocation(&_page_table, size);\n@@ -88,1 +88,1 @@\n-inline void ZHeap::undo_alloc_object(uintptr_t addr, size_t size) {\n+inline void ZHeap::undo_alloc_object_for_relocation(uintptr_t addr, size_t size) {\n@@ -90,1 +90,1 @@\n-  _object_allocator.undo_alloc_object(page, addr, size);\n+  _object_allocator.undo_alloc_object_for_relocation(page, addr, size);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"gc\/z\/zPageTable.inline.hpp\"\n@@ -46,0 +47,2 @@\n+    _alloc_for_relocation(0),\n+    _undo_alloc_for_relocation(0),\n@@ -57,0 +60,11 @@\n+void ZObjectAllocator::register_alloc_for_relocation(const ZPageTable* page_table, uintptr_t addr, size_t size) {\n+  const ZPage* const page = page_table->get(addr);\n+  const size_t aligned_size = align_up(size, page->object_alignment());\n+  Atomic::add(_alloc_for_relocation.addr(), aligned_size);\n+}\n+\n+void ZObjectAllocator::register_undo_alloc_for_relocation(const ZPage* page, size_t size) {\n+  const size_t aligned_size = align_up(size, page->object_alignment());\n+  Atomic::add(_undo_alloc_for_relocation.addr(), aligned_size);\n+}\n+\n@@ -163,1 +177,1 @@\n-uintptr_t ZObjectAllocator::alloc_object_non_blocking(size_t size) {\n+uintptr_t ZObjectAllocator::alloc_object_for_relocation(const ZPageTable* page_table, size_t size) {\n@@ -166,1 +180,7 @@\n-  return alloc_object(size, flags);\n+\n+  const uintptr_t addr = alloc_object(size, flags);\n+  if (addr != 0) {\n+    register_alloc_for_relocation(page_table, addr, size);\n+  }\n+\n+  return addr;\n@@ -169,1 +189,1 @@\n-void ZObjectAllocator::undo_alloc_object(ZPage* page, uintptr_t addr, size_t size) {\n+void ZObjectAllocator::undo_alloc_object_for_relocation(ZPage* page, uintptr_t addr, size_t size) {\n@@ -173,0 +193,1 @@\n+    register_undo_alloc_for_relocation(page, size);\n@@ -177,0 +198,1 @@\n+      register_undo_alloc_for_relocation(page, size);\n@@ -212,0 +234,19 @@\n+size_t ZObjectAllocator::relocated() const {\n+  size_t total_alloc = 0;\n+  size_t total_undo_alloc = 0;\n+\n+  ZPerCPUConstIterator<size_t> iter_alloc(&_alloc_for_relocation);\n+  for (const size_t* alloc; iter_alloc.next(&alloc);) {\n+    total_alloc += Atomic::load(alloc);\n+  }\n+\n+  ZPerCPUConstIterator<size_t> iter_undo_alloc(&_undo_alloc_for_relocation);\n+  for (const size_t* undo_alloc; iter_undo_alloc.next(&undo_alloc);) {\n+    total_undo_alloc += Atomic::load(undo_alloc);\n+  }\n+\n+  assert(total_alloc >= total_undo_alloc, \"Mismatch\");\n+\n+  return total_alloc - total_undo_alloc;\n+}\n+\n@@ -219,0 +260,4 @@\n+  \/\/ Reset relocated bytes\n+  _alloc_for_relocation.set_all(0);\n+  _undo_alloc_for_relocation.set_all(0);\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zObjectAllocator.cpp","additions":49,"deletions":4,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+class ZPageTable;\n@@ -37,0 +38,2 @@\n+  ZPerCPU<size_t>    _alloc_for_relocation;\n+  ZPerCPU<size_t>    _undo_alloc_for_relocation;\n@@ -43,0 +46,3 @@\n+  void register_alloc_for_relocation(const ZPageTable* page_table, uintptr_t addr, size_t size);\n+  void register_undo_alloc_for_relocation(const ZPage* page, size_t size);\n+\n@@ -63,2 +69,2 @@\n-  uintptr_t alloc_object_non_blocking(size_t size);\n-  void undo_alloc_object(ZPage* page, uintptr_t addr, size_t size);\n+  uintptr_t alloc_object_for_relocation(const ZPageTable* page_table, size_t size);\n+  void undo_alloc_object_for_relocation(ZPage* page, uintptr_t addr, size_t size);\n@@ -68,0 +74,1 @@\n+  size_t relocated() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zObjectAllocator.hpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-  const uintptr_t to_addr = ZHeap::heap()->alloc_object_non_blocking(size);\n+  const uintptr_t to_addr = ZHeap::heap()->alloc_object_for_relocation(size);\n@@ -80,1 +80,1 @@\n-    ZHeap::heap()->undo_alloc_object(to_addr, size);\n+    ZHeap::heap()->undo_alloc_object_for_relocation(to_addr, size);\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,0 @@\n-  void start();\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1329,1 +1329,3 @@\n-void ZStatHeap::set_at_relocate_end(const ZPageAllocatorStats& stats) {\n+void ZStatHeap::set_at_relocate_end(const ZPageAllocatorStats& stats, size_t non_worker_relocated) {\n+  const size_t reclaimed = stats.reclaimed() - MIN2(non_worker_relocated, stats.reclaimed());\n+\n@@ -1339,3 +1341,3 @@\n-  _at_relocate_end.allocated = allocated(stats.used(), stats.reclaimed());\n-  _at_relocate_end.garbage = garbage(stats.reclaimed());\n-  _at_relocate_end.reclaimed = stats.reclaimed();\n+  _at_relocate_end.allocated = allocated(stats.used(), reclaimed);\n+  _at_relocate_end.garbage = garbage(reclaimed);\n+  _at_relocate_end.reclaimed = reclaimed;\n","filename":"src\/hotspot\/share\/gc\/z\/zStat.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -544,1 +544,1 @@\n-  static void set_at_relocate_end(const ZPageAllocatorStats& stats);\n+  static void set_at_relocate_end(const ZPageAllocatorStats& stats, size_t non_worker_relocated);\n","filename":"src\/hotspot\/share\/gc\/z\/zStat.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}