{"files":[{"patch":"@@ -4773,1 +4773,1 @@\n-  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n@@ -4778,0 +4778,9 @@\n+void Assembler::vpmovzxwq(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(vector_len == AVX_128bit? VM_Version::supports_avx() :\n+  vector_len == AVX_256bit? VM_Version::supports_avx2() :\n+  vector_len == AVX_512bit? VM_Version::supports_evex() : 0, \" \");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x34, (0xC0 | encode));\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1825,2 +1825,1 @@\n-  void vpmovzxbw( XMMRegister dst, Address src, int vector_len);\n-  void pmovzxdq(XMMRegister dst, XMMRegister src);\n+  void vpmovzxbw(XMMRegister dst, Address src, int vector_len);\n@@ -1828,1 +1827,0 @@\n-  void vpmovzxdq(XMMRegister dst, XMMRegister src, int vector_len);\n@@ -1831,0 +1829,4 @@\n+  void vpmovzxwd(XMMRegister dst, XMMRegister src, int vector_len);\n+  void vpmovzxwq(XMMRegister dst, XMMRegister src, int vector_len);\n+  void pmovzxdq(XMMRegister dst, XMMRegister src);\n+  void vpmovzxdq(XMMRegister dst, XMMRegister src, int vector_len);\n@@ -1847,3 +1849,0 @@\n-\n-  void vpmovzxwd(XMMRegister dst, XMMRegister src, int vector_len);\n-\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -4077,0 +4077,27 @@\n+void C2_MacroAssembler::vector_unsigned_cast(XMMRegister dst, XMMRegister src, int vlen_enc,\n+                                             BasicType from_elem_bt, BasicType to_elem_bt) {\n+  switch (from_elem_bt) {\n+    case T_BYTE:\n+      switch (to_elem_bt) {\n+        case T_SHORT: vpmovzxbw(dst, src, vlen_enc); break;\n+        case T_INT:   vpmovzxbd(dst, src, vlen_enc); break;\n+        case T_LONG:  vpmovzxbq(dst, src, vlen_enc); break;\n+        default: ShouldNotReachHere();\n+      }\n+      break;\n+    case T_SHORT:\n+      switch (to_elem_bt) {\n+        case T_INT:  vpmovzxwd(dst, src, vlen_enc); break;\n+        case T_LONG: vpmovzxwq(dst, src, vlen_enc); break;\n+        default: ShouldNotReachHere();\n+      }\n+      break;\n+    case T_INT:\n+      assert(to_elem_bt == T_LONG, \"\");\n+      vpmovzxdq(dst, src, vlen_enc);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -309,0 +309,3 @@\n+  void vector_unsigned_cast(XMMRegister dst, XMMRegister src, int vlen_enc,\n+                            BasicType from_elem_bt, BasicType to_elem_bt);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1460,0 +1460,3 @@\n+    case Op_VectorUCastB2X:\n+    case Op_VectorUCastS2X:\n+    case Op_VectorUCastI2X:\n@@ -7266,0 +7269,16 @@\n+instruct vucast(vec dst, vec src) %{\n+  match(Set dst (VectorUCastB2X src));\n+  match(Set dst (VectorUCastS2X src));\n+  match(Set dst (VectorUCastI2X src));\n+  format %{ \"vector_ucast $dst,$src\\t!\" %}\n+  ins_encode %{\n+    assert(UseAVX > 0, \"required\");\n+\n+    BasicType from_elem_bt = Matcher::vector_element_basic_type(this, $src);\n+    BasicType to_elem_bt = Matcher::vector_element_basic_type(this);\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vector_unsigned_cast($dst$$XMMRegister, $src$$XMMRegister, vlen_enc, from_elem_bt, to_elem_bt);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -4237,0 +4237,1 @@\n+    \"VectorUCastB2X\", \"VectorUCastS2X\", \"VectorUCastI2X\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -482,0 +482,3 @@\n+macro(VectorUCastB2X)\n+macro(VectorUCastS2X)\n+macro(VectorUCastI2X)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2373,1 +2373,2 @@\n-  assert(opr->get_con() == VectorSupport::VECTOR_OP_CAST ||\n+  assert(opr->get_con() == VectorSupport::VECTOR_OP_CAST  ||\n+         opr->get_con() == VectorSupport::VECTOR_OP_UCAST ||\n@@ -2375,1 +2376,2 @@\n-  bool is_cast = (opr->get_con() == VectorSupport::VECTOR_OP_CAST);\n+  bool is_cast = (opr->get_con() == VectorSupport::VECTOR_OP_CAST || opr->get_con() == VectorSupport::VECTOR_OP_UCAST);\n+  bool is_ucast = (opr->get_con() == VectorSupport::VECTOR_OP_UCAST);\n@@ -2460,1 +2462,1 @@\n-    int cast_vopc = VectorCastNode::opcode(new_elem_bt_from);\n+    int cast_vopc = VectorCastNode::opcode(new_elem_bt_from, !is_ucast);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1096,6 +1096,9 @@\n-    case Op_VectorCastB2X: return new VectorCastB2XNode(n1, vt);\n-    case Op_VectorCastS2X: return new VectorCastS2XNode(n1, vt);\n-    case Op_VectorCastI2X: return new VectorCastI2XNode(n1, vt);\n-    case Op_VectorCastL2X: return new VectorCastL2XNode(n1, vt);\n-    case Op_VectorCastF2X: return new VectorCastF2XNode(n1, vt);\n-    case Op_VectorCastD2X: return new VectorCastD2XNode(n1, vt);\n+    case Op_VectorCastB2X:  return new VectorCastB2XNode(n1, vt);\n+    case Op_VectorCastS2X:  return new VectorCastS2XNode(n1, vt);\n+    case Op_VectorCastI2X:  return new VectorCastI2XNode(n1, vt);\n+    case Op_VectorCastL2X:  return new VectorCastL2XNode(n1, vt);\n+    case Op_VectorCastF2X:  return new VectorCastF2XNode(n1, vt);\n+    case Op_VectorCastD2X:  return new VectorCastD2XNode(n1, vt);\n+    case Op_VectorUCastB2X: return new VectorUCastB2XNode(n1, vt);\n+    case Op_VectorUCastS2X: return new VectorUCastS2XNode(n1, vt);\n+    case Op_VectorUCastI2X: return new VectorUCastI2XNode(n1, vt);\n@@ -1108,1 +1111,2 @@\n-int VectorCastNode::opcode(BasicType bt) {\n+int VectorCastNode::opcode(BasicType bt, bool is_signed) {\n+  assert((is_integral_type(bt) && bt != T_LONG) || is_signed, \"\");\n@@ -1110,3 +1114,3 @@\n-    case T_BYTE:   return Op_VectorCastB2X;\n-    case T_SHORT:  return Op_VectorCastS2X;\n-    case T_INT:    return Op_VectorCastI2X;\n+    case T_BYTE:   return is_signed ? Op_VectorCastB2X : Op_VectorUCastB2X;\n+    case T_SHORT:  return is_signed ? Op_VectorCastS2X : Op_VectorUCastS2X;\n+    case T_INT:    return is_signed ? Op_VectorCastI2X : Op_VectorUCastI2X;\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1471,1 +1471,1 @@\n-  static int  opcode(BasicType bt);\n+  static int  opcode(BasicType bt, bool is_signed = true);\n@@ -1525,0 +1525,24 @@\n+class VectorUCastB2XNode : public VectorCastNode {\n+ public:\n+  VectorUCastB2XNode(Node* in, const TypeVect* vt) : VectorCastNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_BYTE, \"must be byte\");\n+  }\n+  virtual int Opcode() const;\n+};\n+\n+class VectorUCastS2XNode : public VectorCastNode {\n+ public:\n+  VectorUCastS2XNode(Node* in, const TypeVect* vt) : VectorCastNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_SHORT, \"must be short\");\n+  }\n+  virtual int Opcode() const;\n+};\n+\n+class VectorUCastI2XNode : public VectorCastNode {\n+ public:\n+  VectorUCastI2XNode(Node* in, const TypeVect* vt) : VectorCastNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_INT, \"must be int\");\n+  }\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -79,1 +79,2 @@\n-    VECTOR_OP_REINTERPRET = 18,\n+    VECTOR_OP_UCAST       = 18,\n+    VECTOR_OP_REINTERPRET = 19,\n@@ -82,4 +83,4 @@\n-    VECTOR_OP_MASK_TRUECOUNT = 19,\n-    VECTOR_OP_MASK_FIRSTTRUE = 20,\n-    VECTOR_OP_MASK_LASTTRUE  = 21,\n-    VECTOR_OP_MASK_TOLONG    = 22,\n+    VECTOR_OP_MASK_TRUECOUNT = 20,\n+    VECTOR_OP_MASK_FIRSTTRUE = 21,\n+    VECTOR_OP_MASK_LASTTRUE  = 22,\n+    VECTOR_OP_MASK_TOLONG    = 23,\n@@ -88,2 +89,2 @@\n-    VECTOR_OP_LROTATE = 23,\n-    VECTOR_OP_RROTATE = 24,\n+    VECTOR_OP_LROTATE = 24,\n+    VECTOR_OP_RROTATE = 25,\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1849,0 +1849,3 @@\n+  declare_c2_type(VectorUCastB2XNode, VectorNode)                         \\\n+  declare_c2_type(VectorUCastS2XNode, VectorNode)                         \\\n+  declare_c2_type(VectorUCastI2XNode, VectorNode)                         \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -66,1 +66,2 @@\n-    public static final int VECTOR_OP_REINTERPRET = 18;\n+    public static final int VECTOR_OP_UCAST       = 18;\n+    public static final int VECTOR_OP_REINTERPRET = 19;\n@@ -69,4 +70,4 @@\n-    public static final int VECTOR_OP_MASK_TRUECOUNT = 19;\n-    public static final int VECTOR_OP_MASK_FIRSTTRUE = 20;\n-    public static final int VECTOR_OP_MASK_LASTTRUE  = 21;\n-    public static final int VECTOR_OP_MASK_TOLONG    = 22;\n+    public static final int VECTOR_OP_MASK_TRUECOUNT = 20;\n+    public static final int VECTOR_OP_MASK_FIRSTTRUE = 21;\n+    public static final int VECTOR_OP_MASK_LASTTRUE  = 22;\n+    public static final int VECTOR_OP_MASK_TOLONG    = 23;\n@@ -75,2 +76,2 @@\n-    public static final int VECTOR_OP_LROTATE = 23;\n-    public static final int VECTOR_OP_RROTATE = 24;\n+    public static final int VECTOR_OP_LROTATE = 24;\n+    public static final int VECTOR_OP_RROTATE = 25;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -642,0 +642,19 @@\n+    \/**\n+     * Helper function for all sorts of lane-wise unsigned conversions.\n+     * This function kicks in after intrinsic failure.\n+     *\/\n+    \/*package-private*\/\n+    @ForceInline\n+    final <F>\n+    AbstractVector<F> defaultUCast(AbstractSpecies<F> dsp) {\n+        AbstractSpecies<?> vsp = this.vspecies();\n+        if (vsp.elementSize() >= dsp.elementSize()) {\n+            \/\/ clip in place\n+            return this.convert0('C', dsp);\n+        } else {\n+            \/\/ extend in place, but remove unwanted sign extension\n+            long mask = -1L >>> -vsp.elementSize();\n+            return (AbstractVector<F>) this.convert0('C', dsp).lanewise(AND, dsp.broadcast(mask));\n+        }\n+    }\n+\n@@ -668,1 +687,0 @@\n-            \/\/ Maybe this should be an intrinsic also.\n@@ -670,1 +688,15 @@\n-            AbstractVector<?> bitv = resizeLanes0(this, rspi);\n+            AbstractSpecies<?> vsp = this.vspecies();\n+            AbstractSpecies<?> vspi = vsp.asIntegral();\n+            AbstractVector<?> biti = vspi == vsp ? this.check0(vspi) : this.convert0('X', vspi);\n+            rtype = rspi.elementType();\n+            rlength = rspi.laneCount();\n+            etype = vspi.elementType();\n+            vlength = vspi.laneCount();\n+            Class<?> vtype = vspi.dummyVector().getClass();\n+            rvtype = rspi.dummyVector().getClass();\n+            int opc = vspi.elementSize() < rspi.elementSize() ? VectorSupport.VECTOR_OP_UCAST : VectorSupport.VECTOR_OP_CAST;\n+            AbstractVector<?> bitv = VectorSupport.convert(opc,\n+                    vtype, etype, vlength,\n+                    rvtype, rtype, rlength,\n+                    biti, rspi,\n+                    AbstractVector::defaultUCast);\n@@ -698,18 +730,0 @@\n-    @ForceInline\n-    private static <F>\n-    AbstractVector<F>\n-    resizeLanes0(AbstractVector<?> v, AbstractSpecies<F> rspi) {\n-        AbstractSpecies<?> dsp = v.vspecies();\n-        int sizeChange = rspi.elementSize() - dsp.elementSize();\n-        AbstractSpecies<?> dspi = dsp.asIntegral();\n-        if (dspi != dsp)  v = v.convert0('R', dspi);\n-        if (sizeChange <= 0) {  \/\/ clip in place\n-            return v.convert0('C', rspi);\n-        }\n-        \/\/ extend in place, but remove unwanted sign extension\n-        long mask = -1L >>> -dsp.elementSize();\n-        return (AbstractVector<F>)\n-            v.convert0('C', rspi)\n-            .lanewise(AND, rspi.broadcast(mask));\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractVector.java","additions":34,"deletions":20,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -166,0 +166,3 @@\n+    public static final String VECTOR_UCAST_B2X = START + \"VectorUCastB2X\" + MID + END;\n+    public static final String VECTOR_UCAST_S2X = START + \"VectorUCastS2X\" + MID + END;\n+    public static final String VECTOR_UCAST_I2X = START + \"VectorUCastI2X\" + MID + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1365,0 +1365,264 @@\n+\n+    @Test\n+    @IR(counts = {UB2X_NODE, \"1\"})\n+    public static void testUB64toS64(byte[] input, short[] output) {\n+        vectorCast(ZERO_EXTEND_B2S, BSPEC64, SSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testUB64toS64\")\n+    public static void runUB64toS64() throws Throwable {\n+        runCastHelper(ZERO_EXTEND_B2S, BSPEC64, SSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {UB2X_NODE, \"1\"})\n+    public static void testUB64toS128(byte[] input, short[] output) {\n+        vectorCast(ZERO_EXTEND_B2S, BSPEC64, SSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testUB64toS128\")\n+    public static void runUB64toS128() throws Throwable {\n+        runCastHelper(ZERO_EXTEND_B2S, BSPEC64, SSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {UB2X_NODE, \"1\"})\n+    public static void testUB128toS256(byte[] input, short[] output) {\n+        vectorCast(ZERO_EXTEND_B2S, BSPEC128, SSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testUB128toS256\")\n+    public static void runUB128toS256() throws Throwable {\n+        runCastHelper(ZERO_EXTEND_B2S, BSPEC128, SSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {UB2X_NODE, \"1\"})\n+    public static void testUB256toS512(byte[] input, short[] output) {\n+        vectorCast(ZERO_EXTEND_B2S, BSPEC256, SSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testUB256toS512\")\n+    public static void runUB256toS512() throws Throwable {\n+        runCastHelper(ZERO_EXTEND_B2S, BSPEC256, SSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {UB2X_NODE, \"1\"})\n+    public static void testUB64toI64(byte[] input, int[] output) {\n+        vectorCast(ZERO_EXTEND_B2I, BSPEC64, ISPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testUB64toI64\")\n+    public static void runUB64toI64() throws Throwable {\n+        runCastHelper(ZERO_EXTEND_B2I, BSPEC64, ISPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {UB2X_NODE, \"1\"})\n+    public static void testUB64toI128(byte[] input, int[] output) {\n+        vectorCast(ZERO_EXTEND_B2I, BSPEC64, ISPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testUB64toI128\")\n+    public static void runUB64toI128() throws Throwable {\n+        runCastHelper(ZERO_EXTEND_B2I, BSPEC64, ISPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {UB2X_NODE, \"1\"})\n+    public static void testUB64toI256(byte[] input, int[] output) {\n+        vectorCast(ZERO_EXTEND_B2I, BSPEC64, ISPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testUB64toI256\")\n+    public static void runUB64toI256() throws Throwable {\n+        runCastHelper(ZERO_EXTEND_B2I, BSPEC64, ISPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {UB2X_NODE, \"1\"})\n+    public static void testUB128toI512(byte[] input, int[] output) {\n+        vectorCast(ZERO_EXTEND_B2I, BSPEC128, ISPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testUB128toI512\")\n+    public static void runUB128toI512() throws Throwable {\n+        runCastHelper(ZERO_EXTEND_B2I, BSPEC128, ISPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {UB2X_NODE, \"1\"})\n+    public static void testUB64toL64(byte[] input, long[] output) {\n+        vectorCast(ZERO_EXTEND_B2L, BSPEC64, LSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testUB64toL64\")\n+    public static void runUB64toL64() throws Throwable {\n+        runCastHelper(ZERO_EXTEND_B2L, BSPEC64, LSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {UB2X_NODE, \"1\"})\n+    public static void testUB64toL128(byte[] input, long[] output) {\n+        vectorCast(ZERO_EXTEND_B2L, BSPEC64, LSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testUB64toL128\")\n+    public static void runUB64toL128() throws Throwable {\n+        runCastHelper(ZERO_EXTEND_B2L, BSPEC64, LSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {UB2X_NODE, \"1\"})\n+    public static void testUB64toL256(byte[] input, long[] output) {\n+        vectorCast(ZERO_EXTEND_B2L, BSPEC64, LSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testUB64toL256\")\n+    public static void runUB64toL256() throws Throwable {\n+        runCastHelper(ZERO_EXTEND_B2L, BSPEC64, LSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {UB2X_NODE, \"1\"})\n+    public static void testUB64toL512(byte[] input, long[] output) {\n+        vectorCast(ZERO_EXTEND_B2L, BSPEC64, LSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testUB64toL512\")\n+    public static void runUB64toL512() throws Throwable {\n+        runCastHelper(ZERO_EXTEND_B2L, BSPEC64, LSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {US2X_NODE, \"1\"})\n+    public static void testUS64toI64(short[] input, int[] output) {\n+        vectorCast(ZERO_EXTEND_S2I, SSPEC64, ISPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testUS64toI64\")\n+    public static void runUS64toI64() throws Throwable {\n+        runCastHelper(ZERO_EXTEND_S2I, SSPEC64, ISPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {US2X_NODE, \"1\"})\n+    public static void testUS64toI128(short[] input, int[] output) {\n+        vectorCast(ZERO_EXTEND_S2I, SSPEC64, ISPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testUS64toI128\")\n+    public static void runUS64toI128() throws Throwable {\n+        runCastHelper(ZERO_EXTEND_S2I, SSPEC64, ISPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {US2X_NODE, \"1\"})\n+    public static void testUS128toI256(short[] input, int[] output) {\n+        vectorCast(ZERO_EXTEND_S2I, SSPEC128, ISPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testUS128toI256\")\n+    public static void runUS128toI256() throws Throwable {\n+        runCastHelper(ZERO_EXTEND_S2I, SSPEC128, ISPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {US2X_NODE, \"1\"})\n+    public static void testUS256toI512(short[] input, int[] output) {\n+        vectorCast(ZERO_EXTEND_S2I, SSPEC256, ISPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testUS256toI512\")\n+    public static void runUS256toI512() throws Throwable {\n+        runCastHelper(ZERO_EXTEND_S2I, SSPEC256, ISPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {US2X_NODE, \"1\"})\n+    public static void testUS64toL64(short[] input, long[] output) {\n+        vectorCast(ZERO_EXTEND_S2L, SSPEC64, LSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testUS64toL64\")\n+    public static void runUS64toL64() throws Throwable {\n+        runCastHelper(ZERO_EXTEND_S2L, SSPEC64, LSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {US2X_NODE, \"1\"})\n+    public static void testUS64toL128(short[] input, long[] output) {\n+        vectorCast(ZERO_EXTEND_S2L, SSPEC64, LSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testUS64toL128\")\n+    public static void runUS64toL128() throws Throwable {\n+        runCastHelper(ZERO_EXTEND_S2L, SSPEC64, LSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {US2X_NODE, \"1\"})\n+    public static void testUS64toL256(short[] input, long[] output) {\n+        vectorCast(ZERO_EXTEND_S2L, SSPEC64, LSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testUS64toL256\")\n+    public static void runUS64toL256() throws Throwable {\n+        runCastHelper(ZERO_EXTEND_S2L, SSPEC64, LSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {US2X_NODE, \"1\"})\n+    public static void testUS128toL512(short[] input, long[] output) {\n+        vectorCast(ZERO_EXTEND_S2L, SSPEC128, LSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testUS128toL512\")\n+    public static void runUS128toL512() throws Throwable {\n+        runCastHelper(ZERO_EXTEND_S2L, SSPEC128, LSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {UI2X_NODE, \"1\"})\n+    public static void testUI64toL64(int[] input, long[] output) {\n+        vectorCast(ZERO_EXTEND_I2L, ISPEC64, LSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testUI64toL64\")\n+    public static void runUI64toL64() throws Throwable {\n+        runCastHelper(ZERO_EXTEND_I2L, ISPEC64, LSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {UI2X_NODE, \"1\"})\n+    public static void testUI64toL128(int[] input, long[] output) {\n+        vectorCast(ZERO_EXTEND_I2L, ISPEC64, LSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testUI64toL128\")\n+    public static void runUI64toL128() throws Throwable {\n+        runCastHelper(ZERO_EXTEND_I2L, ISPEC64, LSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {UI2X_NODE, \"1\"})\n+    public static void testUI128toL256(int[] input, long[] output) {\n+        vectorCast(ZERO_EXTEND_I2L, ISPEC128, LSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testUI128toL256\")\n+    public static void runUI128toL256() throws Throwable {\n+        runCastHelper(ZERO_EXTEND_I2L, ISPEC128, LSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {UI2X_NODE, \"1\"})\n+    public static void testUI256toL512(int[] input, long[] output) {\n+        vectorCast(ZERO_EXTEND_I2L, ISPEC256, LSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testUI256toL512\")\n+    public static void runUI256toL512() throws Throwable {\n+        runCastHelper(ZERO_EXTEND_I2L, ISPEC256, LSPEC512);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/tests\/TestVectorCast.java","additions":264,"deletions":0,"binary":false,"changes":264,"status":"modified"},{"patch":"@@ -66,1 +66,8 @@\n-            makePair(DSPEC256, FSPEC128)\n+            makePair(DSPEC256, FSPEC128),\n+            makePair(BSPEC64, SSPEC64, true),\n+            makePair(BSPEC64, SSPEC128, true),\n+            makePair(BSPEC64, ISPEC128, true),\n+            makePair(SSPEC64, ISPEC64, true),\n+            makePair(SSPEC64, ISPEC128, true),\n+            makePair(SSPEC64, LSPEC128, true),\n+            makePair(ISPEC64, LSPEC128, true)\n@@ -85,1 +92,7 @@\n-            makePair(FSPEC256, ISPEC256)\n+            makePair(FSPEC256, ISPEC256),\n+            makePair(BSPEC128, SSPEC256, true),\n+            makePair(BSPEC64, ISPEC256, true),\n+            makePair(BSPEC64, LSPEC256, true),\n+            makePair(SSPEC128, ISPEC256, true),\n+            makePair(SSPEC64, LSPEC256, true),\n+            makePair(ISPEC128, LSPEC256, true)\n@@ -107,1 +120,6 @@\n-            makePair(DSPEC512, FSPEC256)\n+            makePair(DSPEC512, FSPEC256),\n+            makePair(BSPEC128, ISPEC512, true),\n+            makePair(BSPEC64, LSPEC512, true),\n+            makePair(SSPEC256, ISPEC512, true),\n+            makePair(SSPEC128, LSPEC512, true),\n+            makePair(ISPEC256, LSPEC512, true)\n@@ -112,1 +130,2 @@\n-            makePair(SSPEC512, BSPEC256)\n+            makePair(SSPEC512, BSPEC256),\n+            makePair(BSPEC256, SSPEC512, true)\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/utils\/TestCastMethods.java","additions":23,"deletions":4,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -78,0 +78,3 @@\n+    public static final String UB2X_NODE = IRNode.VECTOR_UCAST_B2X;\n+    public static final String US2X_NODE = IRNode.VECTOR_UCAST_S2X;\n+    public static final String UI2X_NODE = IRNode.VECTOR_UCAST_I2X;\n@@ -107,1 +110,1 @@\n-        String testMethodName = VectorSpeciesPair.makePair(isp, osp).format();\n+        String testMethodName = VectorSpeciesPair.makePair(isp, osp, isUnsignedCast).format();\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/utils\/VectorReshapeHelper.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}