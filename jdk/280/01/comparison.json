{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2018, 2020, Red Hat, Inc. All rights reserved.\n@@ -51,1 +51,10 @@\n-  ShenandoahBarrierSet::assembler()->cmpxchg_oop(masm->masm(), addr, cmpval, newval, \/*acquire*\/ false, \/*release*\/ true, \/*is_cae*\/ false, result);\n+  ShenandoahBarrierSet::assembler()->cmpxchg_oop(masm->masm(), addr, cmpval, newval, \/*acquire*\/ true, \/*release*\/ true, \/*is_cae*\/ false, result);\n+\n+  if (is_c1_or_interpreter_only()) {\n+    \/\/ The membar here is necessary to prevent reordering between the\n+    \/\/ release store in the CAS above and a subsequent volatile load.\n+    \/\/ However for tiered compilation C1 inserts a full barrier before\n+    \/\/ volatile loads which means we don't need an additional barrier\n+    \/\/ here (see LIRGenerator::volatile_field_load()).\n+    __ membar(__ AnyAny);\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1_aarch64.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -462,33 +462,4 @@\n-\/\/ By default, this operation implements sequential consistency and the\n-\/\/ value held in the result register following execution of the\n-\/\/ generated code sequence is 0 to indicate failure of CAS, non-zero\n-\/\/ to indicate success.  Arguments support variations on this theme:\n-\/\/\n-\/\/  acquire: Allow relaxation of the memory ordering on CAS from\n-\/\/           sequential consistency.  This can be useful when\n-\/\/           sequential consistency is not required, such as when\n-\/\/           another sequentially consistent operation is already\n-\/\/           present in the execution stream.  If acquire, successful\n-\/\/           execution has the side effect of assuring that memory\n-\/\/           values updated by other threads and \"released\" will be\n-\/\/           visible to any read operations perfomed by this thread\n-\/\/           which follow this operation in program order.  This is a\n-\/\/           special optimization that should not be enabled by default.\n-\/\/  release: Allow relaxation of the memory ordering on CAS from\n-\/\/           sequential consistency.  This can be useful when\n-\/\/           sequential consistency is not required, such as when\n-\/\/           another sequentially consistent operation is already\n-\/\/           present in the execution stream.  If release, successful\n-\/\/           completion of this operation has the side effect of\n-\/\/           assuring that all writes to memory performed by this\n-\/\/           thread that precede this operation in program order are\n-\/\/           visible to all other threads that subsequently \"acquire\"\n-\/\/           before reading the respective memory values.  This is a\n-\/\/           special optimization that should not be enabled by default.\n-\/\/  is_cae:  This turns CAS (compare and swap) into CAE (compare and\n-\/\/           exchange).  This HotSpot convention is that CAE makes\n-\/\/           available to the caller the \"failure witness\", which is\n-\/\/           the value that was stored in memory which did not match\n-\/\/           the expected value.  If is_cae, the result is the value\n-\/\/           most recently fetched from addr rather than a boolean\n-\/\/           success indicator.\n+\/\/ By default the value held in the result register following execution\n+\/\/ of the generated code sequence is 0 to indicate failure of CAS,\n+\/\/ non-zero to indicate success. If is_cae, the result is the value most\n+\/\/ recently fetched from addr rather than a boolean success indicator.\n@@ -529,5 +500,4 @@\n-  \/\/ from addr (which is now held in tmp1) is no longer the from-space\n-  \/\/ pointer held in tmp2.  If a different thread replaced the\n-  \/\/ in-memory value with its equivalent to-space pointer, then CAS\n-  \/\/ may still be able to succeed.  The value held in the expected\n-  \/\/ register has not changed.\n+  \/\/ from addr is no longer the from-space pointer held in tmp2.  If a\n+  \/\/ different thread replaced the in-memory value with its equivalent\n+  \/\/ to-space pointer, then CAS may still be able to succeed.  The\n+  \/\/ value held in the expected register has not changed.\n@@ -606,2 +576,2 @@\n-  __ cmpxchg(addr, tmp2, new_val, size, acquire, release, false, tmp1);\n-  \/\/ EQ flag set iff success.  tmp2 holds value fetched.\n+  __ cmpxchg(addr, tmp2, new_val, size, acquire, release, false, noreg);\n+  \/\/ EQ flag set iff success.  tmp2 holds value fetched, tmp1 (rscratch1) clobbered.\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":10,"deletions":40,"binary":false,"changes":50,"status":"modified"}]}