{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,0 +95,4 @@\n+    \/** Indicate protected access should be unconditionally allowed.\n+     *\/\n+    boolean allowProtectedAccess = false;\n+\n@@ -152,0 +156,1 @@\n+        info.allowProtectedAccess = allowProtectedAccess;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/AttrContext.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -502,40 +502,43 @@\n-            make.at(pos.getStartPosition());\n-            JCClassDecl owner = classDef((ClassSymbol)mapVar.owner);\n-\n-            \/\/ synthetic static final int[] $SwitchMap$Color = new int[Color.values().length];\n-            MethodSymbol valuesMethod = lookupMethod(pos,\n-                                                     names.values,\n-                                                     forEnum.type,\n-                                                     List.nil());\n-            JCExpression size = make \/\/ Color.values().length\n-                .Select(make.App(make.QualIdent(valuesMethod)),\n-                        syms.lengthVar);\n-            JCExpression mapVarInit = make\n-                .NewArray(make.Type(syms.intType), List.of(size), null)\n-                .setType(new ArrayType(syms.intType, syms.arrayClass));\n-\n-            \/\/ try { $SwitchMap$Color[red.ordinal()] = 1; } catch (java.lang.NoSuchFieldError ex) {}\n-            ListBuffer<JCStatement> stmts = new ListBuffer<>();\n-            Symbol ordinalMethod = lookupMethod(pos,\n-                                                names.ordinal,\n-                                                forEnum.type,\n-                                                List.nil());\n-            List<JCCatch> catcher = List.<JCCatch>nil()\n-                .prepend(make.Catch(make.VarDef(new VarSymbol(PARAMETER, names.ex,\n-                                                              syms.noSuchFieldErrorType,\n-                                                              syms.noSymbol),\n-                                                null),\n-                                    make.Block(0, List.nil())));\n-            for (Map.Entry<VarSymbol,Integer> e : values.entrySet()) {\n-                VarSymbol enumerator = e.getKey();\n-                Integer mappedValue = e.getValue();\n-                JCExpression assign = make\n-                    .Assign(make.Indexed(mapVar,\n-                                         make.App(make.Select(make.QualIdent(enumerator),\n-                                                              ordinalMethod))),\n-                            make.Literal(mappedValue))\n-                    .setType(syms.intType);\n-                JCStatement exec = make.Exec(assign);\n-                JCStatement _try = make.Try(make.Block(0, List.of(exec)), catcher, null);\n-                stmts.append(_try);\n-            }\n+            boolean prevAllowProtectedAccess = attrEnv.info.allowProtectedAccess;\n+            try {\n+                make.at(pos.getStartPosition());\n+                attrEnv.info.allowProtectedAccess = true;\n+                JCClassDecl owner = classDef((ClassSymbol)mapVar.owner);\n+\n+                \/\/ synthetic static final int[] $SwitchMap$Color = new int[Color.values().length];\n+                MethodSymbol valuesMethod = lookupMethod(pos,\n+                                                         names.values,\n+                                                         forEnum.type,\n+                                                         List.nil());\n+                JCExpression size = make \/\/ Color.values().length\n+                    .Select(make.App(make.QualIdent(valuesMethod)),\n+                            syms.lengthVar);\n+                JCExpression mapVarInit = make\n+                    .NewArray(make.Type(syms.intType), List.of(size), null)\n+                    .setType(new ArrayType(syms.intType, syms.arrayClass));\n+\n+                \/\/ try { $SwitchMap$Color[red.ordinal()] = 1; } catch (java.lang.NoSuchFieldError ex) {}\n+                ListBuffer<JCStatement> stmts = new ListBuffer<>();\n+                Symbol ordinalMethod = lookupMethod(pos,\n+                                                    names.ordinal,\n+                                                    forEnum.type,\n+                                                    List.nil());\n+                List<JCCatch> catcher = List.<JCCatch>nil()\n+                    .prepend(make.Catch(make.VarDef(new VarSymbol(PARAMETER, names.ex,\n+                                                                  syms.noSuchFieldErrorType,\n+                                                                  syms.noSymbol),\n+                                                    null),\n+                                        make.Block(0, List.nil())));\n+                for (Map.Entry<VarSymbol,Integer> e : values.entrySet()) {\n+                    VarSymbol enumerator = e.getKey();\n+                    Integer mappedValue = e.getValue();\n+                    JCExpression assign = make\n+                        .Assign(make.Indexed(mapVar,\n+                                             make.App(make.Select(make.QualIdent(enumerator),\n+                                                                  ordinalMethod))),\n+                                make.Literal(mappedValue))\n+                        .setType(syms.intType);\n+                    JCStatement exec = make.Exec(assign);\n+                    JCStatement _try = make.Try(make.Block(0, List.of(exec)), catcher, null);\n+                    stmts.append(_try);\n+                }\n@@ -543,3 +546,6 @@\n-            owner.defs = owner.defs\n-                .prepend(make.Block(STATIC, stmts.toList()))\n-                .prepend(make.VarDef(mapVar, mapVarInit));\n+                owner.defs = owner.defs\n+                    .prepend(make.Block(STATIC, stmts.toList()))\n+                    .prepend(make.VarDef(mapVar, mapVarInit));\n+            } finally {\n+                attrEnv.info.allowProtectedAccess = prevAllowProtectedAccess;\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":49,"deletions":43,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -362,1 +362,3 @@\n-                    isInnerSubClass(env.enclClass.sym, c.owner);\n+                    isInnerSubClass(env.enclClass.sym, c.owner)\n+                    ||\n+                    env.info.allowProtectedAccess;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8178701\n+ * @summary Check javac can generate code for protected enums accessible through subclassing.\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main EnumAccessible\n+*\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import toolbox.TestRunner;\n+import toolbox.JavacTask;\n+import toolbox.JavaTask;\n+import toolbox.Task;\n+import toolbox.ToolBox;\n+\n+public class EnumAccessible extends TestRunner {\n+\n+    ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new EnumAccessible().runTests();\n+    }\n+\n+    EnumAccessible() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testPattern(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          package foo;\n+                          import bar.D.E;\n+                          public class A {\n+                              public static class B {\n+                                  protected enum C {\n+                                      X, Y, Z\n+                                  }\n+                              }\n+                              public static void main(String... args) {\n+                                  new E().run(B.C.X);\n+                              }\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package bar;\n+                          import foo.A.B;\n+                          public class D {\n+                              public static class E extends B {\n+                                  public void run(C arg) {\n+                                      switch (arg) {\n+                                          default: System.out.println(\"OK\");\n+                                      }\n+                                  }\n+                              }\n+                          }\n+                          \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        new JavacTask(tb)\n+            .options(\"-doe\")\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run(Task.Expect.SUCCESS)\n+            .writeAll();\n+\n+        var out = new JavaTask(tb)\n+                .classpath(classes.toString())\n+                .className(\"foo.A\")\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.STDOUT);\n+\n+        var expectedOut = List.of(\"OK\");\n+\n+        if (!Objects.equals(expectedOut, out)) {\n+            throw new AssertionError(\"Incorrect Output, expected: \" + expectedOut +\n+                                      \", actual: \" + out);\n+\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/EnumAccessible.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"}]}