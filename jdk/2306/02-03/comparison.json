{"files":[{"patch":"@@ -101,3 +101,6 @@\n-    \/\/ This function also checks the encoding of the array, throwing a\n-    \/\/ ZipException if there's a decoding error\n-    int checkedHash(byte[] a, int off, int len) throws ZipException {\n+    \/\/\n+    \/\/ Does encoding error checking and hashing in a single pass for efficiency.\n+    \/\/ On an error, this function will throw CharacterCodingException while the\n+    \/\/ UTF8ZipCoder override will throw IllegalArgumentException, so we declare\n+    \/\/ throws Exception to keep things simple.\n+    int checkedHash(byte[] a, int off, int len) throws Exception {\n@@ -108,16 +111,8 @@\n-        try {\n-            int h = 0;\n-            \/\/ cb will be a newly allocated CharBuffer with pos == 0,\n-            \/\/ arrayOffset == 0, backed by an array.\n-            CharBuffer cb = decoder().decode(ByteBuffer.wrap(a, off, len));\n-            int limit = cb.limit();\n-            char[] decoded = cb.array();\n-            for (int i = 0; i < limit; i++) {\n-                h = 31 * h + decoded[i];\n-            }\n-            if (limit > 0 && decoded[limit - 1] != '\/') {\n-                h = 31 * h + '\/';\n-            }\n-            return h;\n-        } catch (CharacterCodingException cce) {\n-            throw new ZipException(\"invalid CEN header (bad entry name)\");\n+        int h = 0;\n+        \/\/ cb will be a newly allocated CharBuffer with pos == 0,\n+        \/\/ arrayOffset == 0, backed by an array.\n+        CharBuffer cb = decoder().decode(ByteBuffer.wrap(a, off, len));\n+        int limit = cb.limit();\n+        char[] decoded = cb.array();\n+        for (int i = 0; i < limit; i++) {\n+            h = 31 * h + decoded[i];\n@@ -125,0 +120,4 @@\n+        if (limit > 0 && decoded[limit - 1] != '\/') {\n+            h = 31 * h + '\/';\n+        }\n+        return h;\n@@ -209,1 +208,1 @@\n-        int checkedHash(byte[] a, int off, int len) throws ZipException {\n+        int checkedHash(byte[] a, int off, int len) throws Exception {\n@@ -214,17 +213,15 @@\n-            try {\n-                int end = off + len;\n-                int h = 0;\n-                while (off < end) {\n-                    byte b = a[off];\n-                    if (b >= 0) {\n-                        \/\/ ASCII, keep going\n-                        h = 31 * h + b;\n-                        off++;\n-                    } else {\n-                        \/\/ Non-ASCII, fall back to decoding a String\n-                        \/\/ We avoid using decoder() here since the UTF8ZipCoder is\n-                        \/\/ shared and that decoder is not thread safe.\n-                        \/\/ We use the JLA.newStringUTF8NoRepl variant to throw\n-                        \/\/ exceptions eagerly when opening ZipFiles\n-                        return hash(JLA.newStringUTF8NoRepl(a, end - len, len));\n-                    }\n+            int end = off + len;\n+            int h = 0;\n+            while (off < end) {\n+                byte b = a[off];\n+                if (b >= 0) {\n+                    \/\/ ASCII, keep going\n+                    h = 31 * h + b;\n+                    off++;\n+                } else {\n+                    \/\/ Non-ASCII, fall back to decoding a String\n+                    \/\/ We avoid using decoder() here since the UTF8ZipCoder is\n+                    \/\/ shared and that decoder is not thread safe.\n+                    \/\/ We use the JLA.newStringUTF8NoRepl variant to throw\n+                    \/\/ exceptions eagerly when opening ZipFiles\n+                    return hash(JLA.newStringUTF8NoRepl(a, end - len, len));\n@@ -232,0 +229,1 @@\n+            }\n@@ -233,6 +231,2 @@\n-                if (a[end - 1] != '\/') {\n-                    h = 31 * h + '\/';\n-                }\n-                return h;\n-            } catch(Exception e) {\n-                throw new ZipException(\"invalid CEN header (bad entry name)\");\n+            if (a[end - 1] != '\/') {\n+                h = 31 * h + '\/';\n@@ -240,0 +234,1 @@\n+            return h;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipCoder.java","additions":38,"deletions":43,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.nio.charset.CharacterCodingException;\n@@ -1161,1 +1162,2 @@\n-            if (CENSIG(cen, pos) != CENSIG)\n+            byte[] cen = this.cen;\n+            if (CENSIG(cen, pos) != CENSIG) {\n@@ -1163,0 +1165,1 @@\n+            }\n@@ -1165,1 +1168,1 @@\n-            if ((flag & 1) != 0)\n+            if ((flag & 1) != 0) {\n@@ -1167,1 +1170,2 @@\n-            if (method != STORED && method != DEFLATED)\n+            }\n+            if (method != STORED && method != DEFLATED) {\n@@ -1169,1 +1173,1 @@\n-\n+            }\n@@ -1172,1 +1176,1 @@\n-            if (entryPos + nlen > cen.length - ENDHDR)\n+            if (entryPos + nlen > cen.length - ENDHDR) {\n@@ -1174,9 +1178,14 @@\n-            ZipCoder zcp = zipCoderForPos(pos);\n-            int hash = zcp.checkedHash(cen, entryPos, nlen);\n-            int hsh = (hash & 0x7fffffff) % tablelen;\n-            int next = table[hsh];\n-            table[hsh] = index;\n-            \/\/ Record the CEN offset and the name hash in our hash cell.\n-            entries[index++] = hash;\n-            entries[index++] = next;\n-            entries[index++] = pos;\n+            }\n+            try {\n+                ZipCoder zcp = zipCoderForPos(pos);\n+                int hash = zcp.checkedHash(cen, entryPos, nlen);\n+                int hsh = (hash & 0x7fffffff) % tablelen;\n+                int next = table[hsh];\n+                table[hsh] = index;\n+                \/\/ Record the CEN offset and the name hash in our hash cell.\n+                entries[index++] = hash;\n+                entries[index++] = next;\n+                entries[index  ] = pos;\n+            } catch (Exception e) {\n+                zerror(\"invalid CEN header (bad entry name)\");\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":23,"deletions":14,"binary":false,"changes":37,"status":"modified"}]}