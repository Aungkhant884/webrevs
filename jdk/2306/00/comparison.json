{"files":[{"patch":"@@ -57,8 +57,0 @@\n-    void checkEncoding(byte[] a, int pos, int nlen) throws ZipException {\n-        try {\n-            toString(a, pos, nlen);\n-        } catch(Exception e) {\n-            throw new ZipException(\"invalid CEN header (bad entry name)\");\n-        }\n-    }\n-\n@@ -101,4 +93,0 @@\n-    static String toStringUTF8(byte[] ba, int off, int len) {\n-        return UTF8.toString(ba, off, len);\n-    }\n-\n@@ -113,1 +101,3 @@\n-    int normalizedHash(byte[] a, int off, int len) {\n+    \/\/ This function also checks the encoding of the array, throwing a\n+    \/\/ ZipException if there's an decoding error\n+    int normalizedHash(byte[] a, int off, int len) throws ZipException {\n@@ -117,1 +107,18 @@\n-        return normalizedHashDecode(0, a, off, off + len);\n+\n+        try {\n+            int h = 0;\n+            \/\/ cb will be a newly allocated CharBuffer with pos == 0,\n+            \/\/ arrayOffset == 0, backed by an array.\n+            CharBuffer cb = decoder().decode(ByteBuffer.wrap(a, off, len));\n+            int limit = cb.limit();\n+            char[] decoded = cb.array();\n+            for (int i = 0; i < limit; i++) {\n+                h = 31 * h + decoded[i];\n+            }\n+            if (limit > 0 && decoded[limit - 1] != '\/') {\n+                h = 31 * h + '\/';\n+            }\n+            return h;\n+        } catch (CharacterCodingException cce) {\n+            throw new ZipException(\"invalid CEN header (bad entry name)\");\n+        }\n@@ -136,23 +143,0 @@\n-    \/\/ Implements normalizedHash by decoding byte[] to char[] and then computing\n-    \/\/ the hash. This is a slow-path used for non-UTF8 charsets and also when\n-    \/\/ aborting the ASCII fast-path in the UTF8 implementation, so {@code h}\n-    \/\/ might be a partially calculated hash code\n-    int normalizedHashDecode(int h, byte[] a, int off, int end) {\n-        try {\n-            \/\/ cb will be a newly allocated CharBuffer with pos == 0,\n-            \/\/ arrayOffset == 0, backed by an array.\n-            CharBuffer cb = decoder().decode(ByteBuffer.wrap(a, off, end - off));\n-            int limit = cb.limit();\n-            char[] decoded = cb.array();\n-            for (int i = 0; i < limit; i++) {\n-                h = 31 * h + decoded[i];\n-            }\n-            if (limit > 0 && decoded[limit - 1] != '\/') {\n-                h = 31 * h + '\/';\n-            }\n-        } catch (CharacterCodingException cce) {\n-            \/\/ Ignore - return the hash code generated so far.\n-        }\n-        return h;\n-    }\n-\n@@ -214,19 +198,0 @@\n-        @Override\n-        void checkEncoding(byte[] a, int pos, int len) throws ZipException {\n-            try {\n-                int end = pos + len;\n-                while (pos < end) {\n-                    \/\/ ASCII fast-path: When checking that a range of bytes is\n-                    \/\/ valid UTF-8, we can avoid some allocation by skipping\n-                    \/\/ past bytes in the 0-127 range\n-                    if (a[pos] < 0) {\n-                        ZipCoder.toStringUTF8(a, pos, end - pos);\n-                        break;\n-                    }\n-                    pos++;\n-                }\n-            } catch(Exception e) {\n-                throw new ZipException(\"invalid CEN header (bad entry name)\");\n-            }\n-        }\n-\n@@ -244,1 +209,1 @@\n-        int normalizedHash(byte[] a, int off, int len) {\n+        int normalizedHash(byte[] a, int off, int len) throws ZipException {\n@@ -249,16 +214,16 @@\n-            int end = off + len;\n-            int h = 0;\n-            while (off < end) {\n-                byte b = a[off];\n-                if (b < 0) {\n-                    \/\/ Non-ASCII, fall back to decoding a String\n-                    \/\/ We avoid using decoder() here since the UTF8ZipCoder is\n-                    \/\/ shared and that decoder is not thread safe.\n-                    \/\/ We also avoid the JLA.newStringUTF8NoRepl variant at\n-                    \/\/ this point to avoid throwing exceptions eagerly when\n-                    \/\/ opening ZipFiles (exceptions are expected when accessing\n-                    \/\/ malformed entries.)\n-                    return normalizedHash(new String(a, end - len, len, UTF_8.INSTANCE));\n-                } else {\n-                    h = 31 * h + b;\n-                    off++;\n+            try {\n+                int end = off + len;\n+                int h = 0;\n+                while (off < end) {\n+                    byte b = a[off];\n+                    if (b < 0) {\n+                        \/\/ Non-ASCII, fall back to decoding a String\n+                        \/\/ We avoid using decoder() here since the UTF8ZipCoder is\n+                        \/\/ shared and that decoder is not thread safe.\n+                        \/\/ We use the JLA.newStringUTF8NoRepl variant to throw\n+                        \/\/ exceptions eagerly when opening ZipFiles\n+                        return normalizedHash(JLA.newStringUTF8NoRepl(a, end - len, len));\n+                    } else {\n+                        h = 31 * h + b;\n+                        off++;\n+                    }\n@@ -266,1 +231,0 @@\n-            }\n@@ -268,2 +232,7 @@\n-            if (a[end - 1] != '\/') {\n-                h = 31 * h + '\/';\n+                if (a[end - 1] != '\/') {\n+                    h = 31 * h + '\/';\n+                }\n+                return h;\n+\n+            } catch(Exception e) {\n+                throw new ZipException(\"invalid CEN header (bad entry name)\");\n@@ -271,1 +240,0 @@\n-            return h;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipCoder.java","additions":45,"deletions":77,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -1155,1 +1155,7 @@\n-        private int addEntry(int index, int hash, int next, int pos) {\n+        private int addEntry(int index, int[] table, int nlen, int pos, int entryPos) throws ZipException {\n+            ZipCoder zcp = zipCoderForPos(pos);\n+            \/\/ Record the CEN offset and the name hash in our hash cell.\n+            int hash = zcp.normalizedHash(cen, entryPos, nlen);\n+            int hsh = (hash & 0x7fffffff) % tablelen;\n+            int next = table[hsh];\n+            table[hsh] = index;\n@@ -1447,1 +1453,1 @@\n-                total = end.centot;\n+                this.total = end.centot;\n@@ -1450,1 +1456,1 @@\n-                total = knownTotal;\n+                this.total = knownTotal;\n@@ -1453,1 +1459,2 @@\n-            entries  = new int[total * 3];\n+            int entriesLength = this.total * 3;\n+            entries = new int[entriesLength];\n@@ -1455,2 +1462,2 @@\n-            this.tablelen = ((total\/2) | 1); \/\/ Odd -> fewer collisions\n-            int tablelen = this.tablelen;\n+            int tablelen = ((total\/2) | 1); \/\/ Odd -> fewer collisions\n+            this.tablelen = tablelen;\n@@ -1458,2 +1465,2 @@\n-            this.table = new int[tablelen];\n-            int[] table = this.table;\n+            int[] table = new int[tablelen];\n+            this.table = table;\n@@ -1462,3 +1469,0 @@\n-            int idx = 0;\n-            int hash;\n-            int next;\n@@ -1472,2 +1476,1 @@\n-            int i = 0;\n-            int hsh;\n+            int idx = 0;\n@@ -1478,1 +1481,1 @@\n-                if (i >= total) {\n+                if (idx >= entriesLength) {\n@@ -1498,8 +1501,1 @@\n-                ZipCoder zcp = zipCoderForPos(pos);\n-                zcp.checkEncoding(cen, pos + CENHDR, nlen);\n-                \/\/ Record the CEN offset and the name hash in our hash cell.\n-                hash = zcp.normalizedHash(cen, entryPos, nlen);\n-                hsh = (hash & 0x7fffffff) % tablelen;\n-                next = table[hsh];\n-                table[hsh] = idx;\n-                idx = addEntry(idx, hash, next, pos);\n+                idx = addEntry(idx, table, nlen, pos, entryPos);\n@@ -1534,1 +1530,0 @@\n-                i++;\n@@ -1536,1 +1531,1 @@\n-            total = i;\n+            this.total = idx \/ 3;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":19,"deletions":24,"binary":false,"changes":43,"status":"modified"}]}