{"files":[{"patch":"@@ -57,8 +57,0 @@\n-    void checkEncoding(byte[] a, int pos, int nlen) throws ZipException {\n-        try {\n-            toString(a, pos, nlen);\n-        } catch(Exception e) {\n-            throw new ZipException(\"invalid CEN header (bad entry name)\");\n-        }\n-    }\n-\n@@ -101,4 +93,0 @@\n-    static String toStringUTF8(byte[] ba, int off, int len) {\n-        return UTF8.toString(ba, off, len);\n-    }\n-\n@@ -113,1 +101,3 @@\n-    int normalizedHash(byte[] a, int off, int len) {\n+    \/\/ This function also checks the encoding of the array, throwing a\n+    \/\/ ZipException if there's a decoding error\n+    int checkedHash(byte[] a, int off, int len) throws ZipException {\n@@ -117,2 +107,0 @@\n-        return normalizedHashDecode(0, a, off, off + len);\n-    }\n@@ -120,21 +108,0 @@\n-    \/\/ Matching normalized hash code function for Strings\n-    static int normalizedHash(String name) {\n-        int hsh = name.hashCode();\n-        int len = name.length();\n-        if (len > 0 && name.charAt(len - 1) != '\/') {\n-            hsh = hsh * 31 + '\/';\n-        }\n-        return hsh;\n-    }\n-\n-    boolean hasTrailingSlash(byte[] a, int end) {\n-        byte[] slashBytes = slashBytes();\n-        return end >= slashBytes.length &&\n-            Arrays.mismatch(a, end - slashBytes.length, end, slashBytes, 0, slashBytes.length) == -1;\n-    }\n-\n-    \/\/ Implements normalizedHash by decoding byte[] to char[] and then computing\n-    \/\/ the hash. This is a slow-path used for non-UTF8 charsets and also when\n-    \/\/ aborting the ASCII fast-path in the UTF8 implementation, so {@code h}\n-    \/\/ might be a partially calculated hash code\n-    int normalizedHashDecode(int h, byte[] a, int off, int end) {\n@@ -142,0 +109,1 @@\n+            int h = 0;\n@@ -144,1 +112,1 @@\n-            CharBuffer cb = decoder().decode(ByteBuffer.wrap(a, off, end - off));\n+            CharBuffer cb = decoder().decode(ByteBuffer.wrap(a, off, len));\n@@ -153,0 +121,1 @@\n+            return h;\n@@ -154,1 +123,1 @@\n-            \/\/ Ignore - return the hash code generated so far.\n+            throw new ZipException(\"invalid CEN header (bad entry name)\");\n@@ -156,1 +125,16 @@\n-        return h;\n+    }\n+\n+    \/\/ Hash function equivalent of checkedHash for String inputs\n+    static int hash(String name) {\n+        int hsh = name.hashCode();\n+        int len = name.length();\n+        if (len > 0 && name.charAt(len - 1) != '\/') {\n+            hsh = hsh * 31 + '\/';\n+        }\n+        return hsh;\n+    }\n+\n+    boolean hasTrailingSlash(byte[] a, int end) {\n+        byte[] slashBytes = slashBytes();\n+        return end >= slashBytes.length &&\n+            Arrays.mismatch(a, end - slashBytes.length, end, slashBytes, 0, slashBytes.length) == -1;\n@@ -214,19 +198,0 @@\n-        @Override\n-        void checkEncoding(byte[] a, int pos, int len) throws ZipException {\n-            try {\n-                int end = pos + len;\n-                while (pos < end) {\n-                    \/\/ ASCII fast-path: When checking that a range of bytes is\n-                    \/\/ valid UTF-8, we can avoid some allocation by skipping\n-                    \/\/ past bytes in the 0-127 range\n-                    if (a[pos] < 0) {\n-                        ZipCoder.toStringUTF8(a, pos, end - pos);\n-                        break;\n-                    }\n-                    pos++;\n-                }\n-            } catch(Exception e) {\n-                throw new ZipException(\"invalid CEN header (bad entry name)\");\n-            }\n-        }\n-\n@@ -244,1 +209,1 @@\n-        int normalizedHash(byte[] a, int off, int len) {\n+        int checkedHash(byte[] a, int off, int len) throws ZipException {\n@@ -249,16 +214,17 @@\n-            int end = off + len;\n-            int h = 0;\n-            while (off < end) {\n-                byte b = a[off];\n-                if (b < 0) {\n-                    \/\/ Non-ASCII, fall back to decoding a String\n-                    \/\/ We avoid using decoder() here since the UTF8ZipCoder is\n-                    \/\/ shared and that decoder is not thread safe.\n-                    \/\/ We also avoid the JLA.newStringUTF8NoRepl variant at\n-                    \/\/ this point to avoid throwing exceptions eagerly when\n-                    \/\/ opening ZipFiles (exceptions are expected when accessing\n-                    \/\/ malformed entries.)\n-                    return normalizedHash(new String(a, end - len, len, UTF_8.INSTANCE));\n-                } else {\n-                    h = 31 * h + b;\n-                    off++;\n+            try {\n+                int end = off + len;\n+                int h = 0;\n+                while (off < end) {\n+                    byte b = a[off];\n+                    if (b >= 0) {\n+                        \/\/ ASCII, keep going\n+                        h = 31 * h + b;\n+                        off++;\n+                    } else {\n+                        \/\/ Non-ASCII, fall back to decoding a String\n+                        \/\/ We avoid using decoder() here since the UTF8ZipCoder is\n+                        \/\/ shared and that decoder is not thread safe.\n+                        \/\/ We use the JLA.newStringUTF8NoRepl variant to throw\n+                        \/\/ exceptions eagerly when opening ZipFiles\n+                        return hash(JLA.newStringUTF8NoRepl(a, end - len, len));\n+                    }\n@@ -266,1 +232,0 @@\n-            }\n@@ -268,2 +233,6 @@\n-            if (a[end - 1] != '\/') {\n-                h = 31 * h + '\/';\n+                if (a[end - 1] != '\/') {\n+                    h = 31 * h + '\/';\n+                }\n+                return h;\n+            } catch(Exception e) {\n+                throw new ZipException(\"invalid CEN header (bad entry name)\");\n@@ -271,1 +240,0 @@\n-            return h;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipCoder.java","additions":47,"deletions":79,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -1118,1 +1118,1 @@\n-        private static final int META_INF_LENGTH = 9;\n+        private static final int META_INF_LEN = 9;\n@@ -1151,1 +1151,1 @@\n-        \/\/ {@code hash}, {@code next and {@code \"pos for each entry. The entry can then be\n+        \/\/ {@code hash}, {@code next} and {@code pos} for each entry. The entry can then be\n@@ -1155,1 +1155,25 @@\n-        private int addEntry(int index, int hash, int next, int pos) {\n+\n+        \/\/ Checks the entry at offset pos in the CEN, calculates the Entry values as per above,\n+        \/\/ then returns the length of the entry name.\n+        private int checkAndAddEntry(int pos, int index)\n+            throws ZipException\n+        {\n+            if (CENSIG(cen, pos) != CENSIG)\n+                zerror(\"invalid CEN header (bad signature)\");\n+            int method = CENHOW(cen, pos);\n+            int flag   = CENFLG(cen, pos);\n+            if ((flag & 1) != 0)\n+                zerror(\"invalid CEN header (encrypted entry)\");\n+            if (method != STORED && method != DEFLATED)\n+                zerror(\"invalid CEN header (bad compression method: \" + method + \")\");\n+\n+            int entryPos = pos + CENHDR;\n+            int nlen = CENNAM(cen, pos);\n+            if (entryPos + nlen > cen.length - ENDHDR)\n+                zerror(\"invalid CEN header (bad header size)\");\n+            ZipCoder zcp = zipCoderForPos(pos);\n+            int hash = zcp.checkedHash(cen, entryPos, nlen);\n+            int hsh = (hash & 0x7fffffff) % tablelen;\n+            int next = table[hsh];\n+            table[hsh] = index;\n+            \/\/ Record the CEN offset and the name hash in our hash cell.\n@@ -1159,1 +1183,1 @@\n-            return index;\n+            return nlen;\n@@ -1161,0 +1185,1 @@\n+\n@@ -1416,2 +1441,1 @@\n-            zerror(\"zip END header not found\");\n-            return null; \/\/make compiler happy\n+            throw new ZipException(\"zip END header not found\");\n@@ -1447,1 +1471,1 @@\n-                total = end.centot;\n+                this.total = end.centot;\n@@ -1450,1 +1474,1 @@\n-                total = knownTotal;\n+                this.total = knownTotal;\n@@ -1453,1 +1477,2 @@\n-            entries  = new int[total * 3];\n+            int entriesLength = this.total * 3;\n+            entries = new int[entriesLength];\n@@ -1455,2 +1480,2 @@\n-            this.tablelen = ((total\/2) | 1); \/\/ Odd -> fewer collisions\n-            int tablelen = this.tablelen;\n+            int tablelen = ((total\/2) | 1); \/\/ Odd -> fewer collisions\n+            this.tablelen = tablelen;\n@@ -1458,2 +1483,2 @@\n-            this.table = new int[tablelen];\n-            int[] table = this.table;\n+            int[] table = new int[tablelen];\n+            this.table = table;\n@@ -1462,3 +1487,0 @@\n-            int idx = 0;\n-            int hash;\n-            int next;\n@@ -1472,2 +1494,1 @@\n-            int i = 0;\n-            int hsh;\n+            int idx = 0; \/\/ Index into the entries array\n@@ -1478,1 +1499,1 @@\n-                if (i >= total) {\n+                if (idx >= entriesLength) {\n@@ -1485,21 +1506,5 @@\n-                if (CENSIG(cen, pos) != CENSIG)\n-                    zerror(\"invalid CEN header (bad signature)\");\n-                int method = CENHOW(cen, pos);\n-                int nlen   = CENNAM(cen, pos);\n-                int elen   = CENEXT(cen, pos);\n-                int clen   = CENCOM(cen, pos);\n-                int flag   = CENFLG(cen, pos);\n-                if ((flag & 1) != 0)\n-                    zerror(\"invalid CEN header (encrypted entry)\");\n-                if (method != STORED && method != DEFLATED)\n-                    zerror(\"invalid CEN header (bad compression method: \" + method + \")\");\n-                if (entryPos + nlen > limit)\n-                    zerror(\"invalid CEN header (bad header size)\");\n-                ZipCoder zcp = zipCoderForPos(pos);\n-                zcp.checkEncoding(cen, pos + CENHDR, nlen);\n-                \/\/ Record the CEN offset and the name hash in our hash cell.\n-                hash = zcp.normalizedHash(cen, entryPos, nlen);\n-                hsh = (hash & 0x7fffffff) % tablelen;\n-                next = table[hsh];\n-                table[hsh] = idx;\n-                idx = addEntry(idx, hash, next, pos);\n+\n+                \/\/ Checks the entry and adds values to entries[idx ... idx+2]\n+                int nlen = checkAndAddEntry(pos, idx);\n+                idx += 3;\n+\n@@ -1509,2 +1514,1 @@\n-                    if (isManifestName(cen, entryPos + META_INF_LENGTH,\n-                            nlen - META_INF_LENGTH)) {\n+                    if (isManifestName(entryPos + META_INF_LEN, nlen - META_INF_LEN)) {\n@@ -1513,1 +1517,1 @@\n-                        if (isSignatureRelated(cen, entryPos, nlen)) {\n+                        if (isSignatureRelated(entryPos, nlen)) {\n@@ -1522,2 +1526,1 @@\n-                        int version = getMetaVersion(cen,\n-                            entryPos + META_INF_LENGTH, nlen - META_INF_LENGTH);\n+                        int version = getMetaVersion(entryPos + META_INF_LEN, nlen - META_INF_LEN);\n@@ -1531,2 +1534,2 @@\n-                \/\/ skip ext and comment\n-                pos = entryPos + nlen + elen + clen;\n+                \/\/ skip to the start of the next entry\n+                pos = nextEntryPos(pos, entryPos, nlen);\n@@ -1534,1 +1537,0 @@\n-                i++;\n@@ -1536,1 +1538,4 @@\n-            total = i;\n+\n+            \/\/ Adjust the total entries\n+            this.total = idx \/ 3;\n+\n@@ -1558,0 +1563,4 @@\n+        private int nextEntryPos(int pos, int entryPos, int nlen) {\n+            return entryPos + nlen + CENCOM(cen, pos) + CENEXT(cen, pos);\n+        }\n+\n@@ -1571,1 +1580,1 @@\n-            int hsh = ZipCoder.normalizedHash(name);\n+            int hsh = ZipCoder.hash(name);\n@@ -1623,1 +1632,1 @@\n-            return len > META_INF_LENGTH       \/\/ \"META-INF\/\".length()\n+            return len > META_INF_LEN       \/\/ \"META-INF\/\".length()\n@@ -1639,1 +1648,2 @@\n-        private static boolean isManifestName(byte[] name, int off, int len) {\n+        private boolean isManifestName(int off, int len) {\n+            byte[] name = cen;\n@@ -1654,1 +1664,1 @@\n-        private static boolean isSignatureRelated(byte[] name, int off, int len) {\n+        private boolean isSignatureRelated(int off, int len) {\n@@ -1659,0 +1669,1 @@\n+            byte[] name = cen;\n@@ -1688,1 +1699,2 @@\n-        private static int getMetaVersion(byte[] name, int off, int len) {\n+        private int getMetaVersion(int off, int len) {\n+            byte[] name = cen;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":66,"deletions":54,"binary":false,"changes":120,"status":"modified"}]}