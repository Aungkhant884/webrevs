{"files":[{"patch":"@@ -57,8 +57,0 @@\n-    void checkEncoding(byte[] a, int pos, int nlen) throws ZipException {\n-        try {\n-            toString(a, pos, nlen);\n-        } catch(Exception e) {\n-            throw new ZipException(\"invalid CEN header (bad entry name)\");\n-        }\n-    }\n-\n@@ -101,4 +93,0 @@\n-    static String toStringUTF8(byte[] ba, int off, int len) {\n-        return UTF8.toString(ba, off, len);\n-    }\n-\n@@ -113,1 +101,6 @@\n-    int normalizedHash(byte[] a, int off, int len) {\n+    \/\/\n+    \/\/ Does encoding error checking and hashing in a single pass for efficiency.\n+    \/\/ On an error, this function will throw CharacterCodingException while the\n+    \/\/ UTF8ZipCoder override will throw IllegalArgumentException, so we declare\n+    \/\/ throws Exception to keep things simple.\n+    int checkedHash(byte[] a, int off, int len) throws Exception {\n@@ -117,1 +110,14 @@\n-        return normalizedHashDecode(0, a, off, off + len);\n+\n+        int h = 0;\n+        \/\/ cb will be a newly allocated CharBuffer with pos == 0,\n+        \/\/ arrayOffset == 0, backed by an array.\n+        CharBuffer cb = decoder().decode(ByteBuffer.wrap(a, off, len));\n+        int limit = cb.limit();\n+        char[] decoded = cb.array();\n+        for (int i = 0; i < limit; i++) {\n+            h = 31 * h + decoded[i];\n+        }\n+        if (limit > 0 && decoded[limit - 1] != '\/') {\n+            h = 31 * h + '\/';\n+        }\n+        return h;\n@@ -120,2 +126,2 @@\n-    \/\/ Matching normalized hash code function for Strings\n-    static int normalizedHash(String name) {\n+    \/\/ Hash function equivalent of checkedHash for String inputs\n+    static int hash(String name) {\n@@ -136,23 +142,0 @@\n-    \/\/ Implements normalizedHash by decoding byte[] to char[] and then computing\n-    \/\/ the hash. This is a slow-path used for non-UTF8 charsets and also when\n-    \/\/ aborting the ASCII fast-path in the UTF8 implementation, so {@code h}\n-    \/\/ might be a partially calculated hash code\n-    int normalizedHashDecode(int h, byte[] a, int off, int end) {\n-        try {\n-            \/\/ cb will be a newly allocated CharBuffer with pos == 0,\n-            \/\/ arrayOffset == 0, backed by an array.\n-            CharBuffer cb = decoder().decode(ByteBuffer.wrap(a, off, end - off));\n-            int limit = cb.limit();\n-            char[] decoded = cb.array();\n-            for (int i = 0; i < limit; i++) {\n-                h = 31 * h + decoded[i];\n-            }\n-            if (limit > 0 && decoded[limit - 1] != '\/') {\n-                h = 31 * h + '\/';\n-            }\n-        } catch (CharacterCodingException cce) {\n-            \/\/ Ignore - return the hash code generated so far.\n-        }\n-        return h;\n-    }\n-\n@@ -214,19 +197,0 @@\n-        @Override\n-        void checkEncoding(byte[] a, int pos, int len) throws ZipException {\n-            try {\n-                int end = pos + len;\n-                while (pos < end) {\n-                    \/\/ ASCII fast-path: When checking that a range of bytes is\n-                    \/\/ valid UTF-8, we can avoid some allocation by skipping\n-                    \/\/ past bytes in the 0-127 range\n-                    if (a[pos] < 0) {\n-                        ZipCoder.toStringUTF8(a, pos, end - pos);\n-                        break;\n-                    }\n-                    pos++;\n-                }\n-            } catch(Exception e) {\n-                throw new ZipException(\"invalid CEN header (bad entry name)\");\n-            }\n-        }\n-\n@@ -244,1 +208,1 @@\n-        int normalizedHash(byte[] a, int off, int len) {\n+        int checkedHash(byte[] a, int off, int len) throws Exception {\n@@ -253,1 +217,5 @@\n-                if (b < 0) {\n+                if (b >= 0) {\n+                    \/\/ ASCII, keep going\n+                    h = 31 * h + b;\n+                    off++;\n+                } else {\n@@ -257,8 +225,3 @@\n-                    \/\/ We also avoid the JLA.newStringUTF8NoRepl variant at\n-                    \/\/ this point to avoid throwing exceptions eagerly when\n-                    \/\/ opening ZipFiles (exceptions are expected when accessing\n-                    \/\/ malformed entries.)\n-                    return normalizedHash(new String(a, end - len, len, UTF_8.INSTANCE));\n-                } else {\n-                    h = 31 * h + b;\n-                    off++;\n+                    \/\/ We use the JLA.newStringUTF8NoRepl variant to throw\n+                    \/\/ exceptions eagerly when opening ZipFiles\n+                    return hash(JLA.newStringUTF8NoRepl(a, end - len, len));\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipCoder.java","additions":31,"deletions":68,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.nio.charset.CharacterCodingException;\n@@ -1118,1 +1119,1 @@\n-        private static final int META_INF_LENGTH = 9;\n+        private static final int META_INF_LEN = 9;\n@@ -1151,1 +1152,1 @@\n-        \/\/ {@code hash}, {@code next and {@code \"pos for each entry. The entry can then be\n+        \/\/ {@code hash}, {@code next} and {@code pos} for each entry. The entry can then be\n@@ -1155,5 +1156,37 @@\n-        private int addEntry(int index, int hash, int next, int pos) {\n-            entries[index++] = hash;\n-            entries[index++] = next;\n-            entries[index++] = pos;\n-            return index;\n+\n+        \/\/ Checks the entry at offset pos in the CEN, calculates the Entry values as per above,\n+        \/\/ then returns the length of the entry name.\n+        private int checkAndAddEntry(int pos, int index)\n+            throws ZipException\n+        {\n+            byte[] cen = this.cen;\n+            if (CENSIG(cen, pos) != CENSIG) {\n+                zerror(\"invalid CEN header (bad signature)\");\n+            }\n+            int method = CENHOW(cen, pos);\n+            int flag   = CENFLG(cen, pos);\n+            if ((flag & 1) != 0) {\n+                zerror(\"invalid CEN header (encrypted entry)\");\n+            }\n+            if (method != STORED && method != DEFLATED) {\n+                zerror(\"invalid CEN header (bad compression method: \" + method + \")\");\n+            }\n+            int entryPos = pos + CENHDR;\n+            int nlen = CENNAM(cen, pos);\n+            if (entryPos + nlen > cen.length - ENDHDR) {\n+                zerror(\"invalid CEN header (bad header size)\");\n+            }\n+            try {\n+                ZipCoder zcp = zipCoderForPos(pos);\n+                int hash = zcp.checkedHash(cen, entryPos, nlen);\n+                int hsh = (hash & 0x7fffffff) % tablelen;\n+                int next = table[hsh];\n+                table[hsh] = index;\n+                \/\/ Record the CEN offset and the name hash in our hash cell.\n+                entries[index++] = hash;\n+                entries[index++] = next;\n+                entries[index  ] = pos;\n+            } catch (Exception e) {\n+                zerror(\"invalid CEN header (bad entry name)\");\n+            }\n+            return nlen;\n@@ -1161,0 +1194,1 @@\n+\n@@ -1416,2 +1450,1 @@\n-            zerror(\"zip END header not found\");\n-            return null; \/\/make compiler happy\n+            throw new ZipException(\"zip END header not found\");\n@@ -1447,1 +1480,1 @@\n-                total = end.centot;\n+                this.total = end.centot;\n@@ -1450,1 +1483,1 @@\n-                total = knownTotal;\n+                this.total = knownTotal;\n@@ -1453,1 +1486,2 @@\n-            entries  = new int[total * 3];\n+            int entriesLength = this.total * 3;\n+            entries = new int[entriesLength];\n@@ -1455,2 +1489,2 @@\n-            this.tablelen = ((total\/2) | 1); \/\/ Odd -> fewer collisions\n-            int tablelen = this.tablelen;\n+            int tablelen = ((total\/2) | 1); \/\/ Odd -> fewer collisions\n+            this.tablelen = tablelen;\n@@ -1458,2 +1492,2 @@\n-            this.table = new int[tablelen];\n-            int[] table = this.table;\n+            int[] table = new int[tablelen];\n+            this.table = table;\n@@ -1462,3 +1496,0 @@\n-            int idx = 0;\n-            int hash;\n-            int next;\n@@ -1472,2 +1503,1 @@\n-            int i = 0;\n-            int hsh;\n+            int idx = 0; \/\/ Index into the entries array\n@@ -1478,1 +1508,1 @@\n-                if (i >= total) {\n+                if (idx >= entriesLength) {\n@@ -1485,21 +1515,5 @@\n-                if (CENSIG(cen, pos) != CENSIG)\n-                    zerror(\"invalid CEN header (bad signature)\");\n-                int method = CENHOW(cen, pos);\n-                int nlen   = CENNAM(cen, pos);\n-                int elen   = CENEXT(cen, pos);\n-                int clen   = CENCOM(cen, pos);\n-                int flag   = CENFLG(cen, pos);\n-                if ((flag & 1) != 0)\n-                    zerror(\"invalid CEN header (encrypted entry)\");\n-                if (method != STORED && method != DEFLATED)\n-                    zerror(\"invalid CEN header (bad compression method: \" + method + \")\");\n-                if (entryPos + nlen > limit)\n-                    zerror(\"invalid CEN header (bad header size)\");\n-                ZipCoder zcp = zipCoderForPos(pos);\n-                zcp.checkEncoding(cen, pos + CENHDR, nlen);\n-                \/\/ Record the CEN offset and the name hash in our hash cell.\n-                hash = zcp.normalizedHash(cen, entryPos, nlen);\n-                hsh = (hash & 0x7fffffff) % tablelen;\n-                next = table[hsh];\n-                table[hsh] = idx;\n-                idx = addEntry(idx, hash, next, pos);\n+\n+                \/\/ Checks the entry and adds values to entries[idx ... idx+2]\n+                int nlen = checkAndAddEntry(pos, idx);\n+                idx += 3;\n+\n@@ -1509,2 +1523,1 @@\n-                    if (isManifestName(cen, entryPos + META_INF_LENGTH,\n-                            nlen - META_INF_LENGTH)) {\n+                    if (isManifestName(entryPos + META_INF_LEN, nlen - META_INF_LEN)) {\n@@ -1513,1 +1526,1 @@\n-                        if (isSignatureRelated(cen, entryPos, nlen)) {\n+                        if (isSignatureRelated(entryPos, nlen)) {\n@@ -1522,2 +1535,1 @@\n-                        int version = getMetaVersion(cen,\n-                            entryPos + META_INF_LENGTH, nlen - META_INF_LENGTH);\n+                        int version = getMetaVersion(entryPos + META_INF_LEN, nlen - META_INF_LEN);\n@@ -1531,2 +1543,2 @@\n-                \/\/ skip ext and comment\n-                pos = entryPos + nlen + elen + clen;\n+                \/\/ skip to the start of the next entry\n+                pos = nextEntryPos(pos, entryPos, nlen);\n@@ -1534,1 +1546,0 @@\n-                i++;\n@@ -1536,1 +1547,4 @@\n-            total = i;\n+\n+            \/\/ Adjust the total entries\n+            this.total = idx \/ 3;\n+\n@@ -1558,0 +1572,4 @@\n+        private int nextEntryPos(int pos, int entryPos, int nlen) {\n+            return entryPos + nlen + CENCOM(cen, pos) + CENEXT(cen, pos);\n+        }\n+\n@@ -1571,1 +1589,1 @@\n-            int hsh = ZipCoder.normalizedHash(name);\n+            int hsh = ZipCoder.hash(name);\n@@ -1623,1 +1641,1 @@\n-            return len > META_INF_LENGTH       \/\/ \"META-INF\/\".length()\n+            return len > META_INF_LEN       \/\/ \"META-INF\/\".length()\n@@ -1639,1 +1657,2 @@\n-        private static boolean isManifestName(byte[] name, int off, int len) {\n+        private boolean isManifestName(int off, int len) {\n+            byte[] name = cen;\n@@ -1654,1 +1673,1 @@\n-        private static boolean isSignatureRelated(byte[] name, int off, int len) {\n+        private boolean isSignatureRelated(int off, int len) {\n@@ -1659,0 +1678,1 @@\n+            byte[] name = cen;\n@@ -1688,1 +1708,2 @@\n-        private static int getMetaVersion(byte[] name, int off, int len) {\n+        private int getMetaVersion(int off, int len) {\n+            byte[] name = cen;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":78,"deletions":57,"binary":false,"changes":135,"status":"modified"}]}