{"files":[{"patch":"@@ -70,14 +70,3 @@\n-bool ClassPrelinker::can_archive_resolved_vm_class(InstanceKlass* cp_holder, InstanceKlass* resolved_klass) {\n-  if (!is_vm_class(resolved_klass)) {\n-    return false;\n-  }\n-  if (!cp_holder->is_shared_boot_class() &&\n-      !cp_holder->is_shared_platform_class() &&\n-      !cp_holder->is_shared_app_class()) {\n-    \/\/ Custom loaders are not guaranteed to resolve the vmClasses to the\n-    \/\/ ones resolved by the boot loader.\n-    return false;\n-  }\n-  if (cp_holder->class_loader_data() != resolved_klass->class_loader_data()) {\n-    \/\/ If they are defined by different loaders, it's possible for resolved_klass\n-    \/\/ to be already defined, but is not yet resolved in cp_holder->class_loader().\n+bool ClassPrelinker::can_archive_resolved_klass(ConstantPool* cp, int cp_index) {\n+  assert(!is_in_archivebuilder_buffer(cp), \"sanity\");\n+  assert(cp->tag_at(cp_index).is_klass(), \"must be resolved\");\n@@ -85,4 +74,2 @@\n-    \/\/ TODO: this check can be removed if we preload the vmClasses into\n-    \/\/ platform and app loaders during VM bootstrap.\n-    return false;\n-  }\n+  Klass* resolved_klass = cp->resolved_klass_at(cp_index);\n+  assert(resolved_klass != NULL, \"must be\");\n@@ -90,1 +77,1 @@\n-  return true;\n+  return can_archive_resolved_klass(cp->pool_holder(), resolved_klass);\n@@ -99,2 +86,11 @@\n-    if (can_archive_resolved_vm_class(cp_holder, ik)) {\n-      return true;\n+    if (is_vm_class(ik)) { \/\/ These are safe to resolve. See is_vm_class declaration.\n+      assert(ik->is_shared_boot_class(), \"vmClasses must be loaded by boot loader\");\n+      if (cp_holder->is_shared_boot_class()) {\n+        \/\/ For now, do this for boot loader only. Other loaders\n+        \/\/ must go through ConstantPool::klass_at_impl at runtime\n+        \/\/ to put this class in their directory.\n+\n+        \/\/ TODO: we can support the platform and app loaders as well, if we\n+        \/\/ preload the vmClasses into these two loaders during VM bootstrap.\n+        return true;\n+      }\n@@ -102,0 +98,1 @@\n+\n@@ -114,23 +111,0 @@\n-Klass* ClassPrelinker::get_resolved_klass_or_null(ConstantPool* cp, int cp_index) {\n-  if (cp->tag_at(cp_index).is_klass()) {\n-    CPKlassSlot kslot = cp->klass_slot_at(cp_index);\n-    int resolved_klass_index = kslot.resolved_klass_index();\n-    return cp->resolved_klasses()->at(resolved_klass_index);\n-  } else {\n-    \/\/ klass is not resolved yet\n-    assert(cp->tag_at(cp_index).is_unresolved_klass() ||\n-           cp->tag_at(cp_index).is_unresolved_klass_in_error(), \"must be\");\n-    return NULL;\n-  }\n-}\n-\n-bool ClassPrelinker::can_archive_resolved_klass(ConstantPool* cp, int cp_index) {\n-  assert(!is_in_archivebuilder_buffer(cp), \"sanity\");\n-  assert(cp->tag_at(cp_index).is_klass(), \"must be resolved\");\n-\n-  Klass* resolved_klass = get_resolved_klass_or_null(cp, cp_index);\n-  assert(resolved_klass != NULL, \"must be\");\n-\n-  return can_archive_resolved_klass(cp->pool_holder(), resolved_klass);\n-}\n-\n@@ -192,3 +166,1 @@\n-  CPKlassSlot kslot = cp->klass_slot_at(cp_index);\n-  int name_index = kslot.name_index();\n-  Symbol* name = cp->symbol_at(name_index);\n+  Symbol* name = cp->klass_name_at(cp_index);\n@@ -197,1 +169,1 @@\n-    Klass* k = ConstantPool::klass_at_impl(cp, cp_index, CHECK_NULL); \/\/ Should fail only with OOM\n+    Klass* k = cp->klass_at(cp_index, CHECK_NULL); \/\/ Should fail only with OOM\n","filename":"src\/hotspot\/share\/cds\/classPrelinker.cpp","additions":20,"deletions":48,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-  bool can_archive_resolved_vm_class(InstanceKlass* cp_holder, InstanceKlass* resolved_klass);\n@@ -70,1 +69,0 @@\n-  Klass* get_resolved_klass_or_null(ConstantPool* cp, int cp_index);\n","filename":"src\/hotspot\/share\/cds\/classPrelinker.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}