{"files":[{"patch":"@@ -1234,174 +1234,0 @@\n-\/\/ Different signatures may require very different orders for the move\n-\/\/ to avoid clobbering other arguments.  There's no simple way to\n-\/\/ order them safely.  Compute a safe order for issuing stores and\n-\/\/ break any cycles in those stores.  This code is fairly general but\n-\/\/ it's not necessary on the other platforms so we keep it in the\n-\/\/ platform dependent code instead of moving it into a shared file.\n-\/\/ (See bugs 7013347 & 7145024.)\n-\/\/ Note that this code is specific to LP64.\n-class ComputeMoveOrder: public StackObj {\n-  class MoveOperation: public ResourceObj {\n-    friend class ComputeMoveOrder;\n-   private:\n-    VMRegPair        _src;\n-    VMRegPair        _dst;\n-    int              _src_index;\n-    int              _dst_index;\n-    bool             _processed;\n-    MoveOperation*  _next;\n-    MoveOperation*  _prev;\n-\n-    static int get_id(VMRegPair r) {\n-      return r.first()->value();\n-    }\n-\n-   public:\n-    MoveOperation(int src_index, VMRegPair src, int dst_index, VMRegPair dst):\n-      _src(src)\n-    , _dst(dst)\n-    , _src_index(src_index)\n-    , _dst_index(dst_index)\n-    , _processed(false)\n-    , _next(NULL)\n-    , _prev(NULL) {\n-    }\n-\n-    VMRegPair src() const              { return _src; }\n-    int src_id() const                 { return get_id(src()); }\n-    int src_index() const              { return _src_index; }\n-    VMRegPair dst() const              { return _dst; }\n-    void set_dst(int i, VMRegPair dst) { _dst_index = i, _dst = dst; }\n-    int dst_index() const              { return _dst_index; }\n-    int dst_id() const                 { return get_id(dst()); }\n-    MoveOperation* next() const       { return _next; }\n-    MoveOperation* prev() const       { return _prev; }\n-    void set_processed()               { _processed = true; }\n-    bool is_processed() const          { return _processed; }\n-\n-    \/\/ insert\n-    void break_cycle(VMRegPair temp_register) {\n-      \/\/ create a new store following the last store\n-      \/\/ to move from the temp_register to the original\n-      MoveOperation* new_store = new MoveOperation(-1, temp_register, dst_index(), dst());\n-\n-      \/\/ break the cycle of links and insert new_store at the end\n-      \/\/ break the reverse link.\n-      MoveOperation* p = prev();\n-      assert(p->next() == this, \"must be\");\n-      _prev = NULL;\n-      p->_next = new_store;\n-      new_store->_prev = p;\n-\n-      \/\/ change the original store to save it's value in the temp.\n-      set_dst(-1, temp_register);\n-    }\n-\n-    void link(GrowableArray<MoveOperation*>& killer) {\n-      \/\/ link this store in front the store that it depends on\n-      MoveOperation* n = killer.at_grow(src_id(), NULL);\n-      if (n != NULL) {\n-        assert(_next == NULL && n->_prev == NULL, \"shouldn't have been set yet\");\n-        _next = n;\n-        n->_prev = this;\n-      }\n-    }\n-  };\n-\n- private:\n-  GrowableArray<MoveOperation*> edges;\n-\n- public:\n-  ComputeMoveOrder(int total_in_args, const VMRegPair* in_regs, int total_c_args, VMRegPair* out_regs,\n-                  const BasicType* in_sig_bt, GrowableArray<int>& arg_order, VMRegPair tmp_vmreg) {\n-    \/\/ Move operations where the dest is the stack can all be\n-    \/\/ scheduled first since they can't interfere with the other moves.\n-    for (int i = total_in_args - 1, c_arg = total_c_args - 1; i >= 0; i--, c_arg--) {\n-      if (in_sig_bt[i] == T_ARRAY) {\n-        c_arg--;\n-        if (out_regs[c_arg].first()->is_stack() &&\n-            out_regs[c_arg + 1].first()->is_stack()) {\n-          arg_order.push(i);\n-          arg_order.push(c_arg);\n-        } else {\n-          if (out_regs[c_arg].first()->is_stack() ||\n-              in_regs[i].first() == out_regs[c_arg].first()) {\n-            add_edge(i, in_regs[i].first(), c_arg, out_regs[c_arg + 1]);\n-          } else {\n-            add_edge(i, in_regs[i].first(), c_arg, out_regs[c_arg]);\n-          }\n-        }\n-      } else if (in_sig_bt[i] == T_VOID) {\n-        arg_order.push(i);\n-        arg_order.push(c_arg);\n-      } else {\n-        if (out_regs[c_arg].first()->is_stack() ||\n-            in_regs[i].first() == out_regs[c_arg].first()) {\n-          arg_order.push(i);\n-          arg_order.push(c_arg);\n-        } else {\n-          add_edge(i, in_regs[i].first(), c_arg, out_regs[c_arg]);\n-        }\n-      }\n-    }\n-    \/\/ Break any cycles in the register moves and emit the in the\n-    \/\/ proper order.\n-    GrowableArray<MoveOperation*>* stores = get_store_order(tmp_vmreg);\n-    for (int i = 0; i < stores->length(); i++) {\n-      arg_order.push(stores->at(i)->src_index());\n-      arg_order.push(stores->at(i)->dst_index());\n-    }\n- }\n-\n-  \/\/ Collected all the move operations\n-  void add_edge(int src_index, VMRegPair src, int dst_index, VMRegPair dst) {\n-    if (src.first() == dst.first()) return;\n-    edges.append(new MoveOperation(src_index, src, dst_index, dst));\n-  }\n-\n-  \/\/ Walk the edges breaking cycles between moves.  The result list\n-  \/\/ can be walked in order to produce the proper set of loads\n-  GrowableArray<MoveOperation*>* get_store_order(VMRegPair temp_register) {\n-    \/\/ Record which moves kill which values\n-    GrowableArray<MoveOperation*> killer;\n-    for (int i = 0; i < edges.length(); i++) {\n-      MoveOperation* s = edges.at(i);\n-      assert(killer.at_grow(s->dst_id(), NULL) == NULL, \"only one killer\");\n-      killer.at_put_grow(s->dst_id(), s, NULL);\n-    }\n-    assert(killer.at_grow(MoveOperation::get_id(temp_register), NULL) == NULL,\n-           \"make sure temp isn't in the registers that are killed\");\n-\n-    \/\/ create links between loads and stores\n-    for (int i = 0; i < edges.length(); i++) {\n-      edges.at(i)->link(killer);\n-    }\n-\n-    \/\/ at this point, all the move operations are chained together\n-    \/\/ in a doubly linked list.  Processing it backwards finds\n-    \/\/ the beginning of the chain, forwards finds the end.  If there's\n-    \/\/ a cycle it can be broken at any point,  so pick an edge and walk\n-    \/\/ backward until the list ends or we end where we started.\n-    GrowableArray<MoveOperation*>* stores = new GrowableArray<MoveOperation*>();\n-    for (int e = 0; e < edges.length(); e++) {\n-      MoveOperation* s = edges.at(e);\n-      if (!s->is_processed()) {\n-        MoveOperation* start = s;\n-        \/\/ search for the beginning of the chain or cycle\n-        while (start->prev() != NULL && start->prev() != s) {\n-          start = start->prev();\n-        }\n-        if (start->prev() == s) {\n-          start->break_cycle(temp_register);\n-        }\n-        \/\/ walk the chain forward inserting to store list\n-        while (start != NULL) {\n-          stores->append(start);\n-          start->set_processed();\n-          start = start->next();\n-        }\n-      }\n-    }\n-    return stores;\n-  }\n-};\n-\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":0,"deletions":174,"binary":false,"changes":174,"status":"modified"}]}