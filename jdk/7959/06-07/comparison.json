{"files":[{"patch":"@@ -55,2 +55,2 @@\n-  loadArray(inputStorage, INTEGER_TYPE, abi._integer_argument_registers, to_Register);\n-  loadArray(inputStorage, VECTOR_TYPE, abi._vector_argument_registers, as_FloatRegister);\n+  parse_register_array(inputStorage, INTEGER_TYPE, abi._integer_argument_registers, to_Register);\n+  parse_register_array(inputStorage, VECTOR_TYPE, abi._vector_argument_registers, as_FloatRegister);\n@@ -59,2 +59,2 @@\n-  loadArray(outputStorage, INTEGER_TYPE, abi._integer_return_registers, to_Register);\n-  loadArray(outputStorage, VECTOR_TYPE, abi._vector_return_registers, as_FloatRegister);\n+  parse_register_array(outputStorage, INTEGER_TYPE, abi._integer_return_registers, to_Register);\n+  parse_register_array(outputStorage, VECTOR_TYPE, abi._vector_return_registers, as_FloatRegister);\n@@ -63,2 +63,2 @@\n-  loadArray(volatileStorage, INTEGER_TYPE, abi._integer_additional_volatile_registers, to_Register);\n-  loadArray(volatileStorage, VECTOR_TYPE, abi._vector_additional_volatile_registers, as_FloatRegister);\n+  parse_register_array(volatileStorage, INTEGER_TYPE, abi._integer_additional_volatile_registers, to_Register);\n+  parse_register_array(volatileStorage, VECTOR_TYPE, abi._vector_additional_volatile_registers, as_FloatRegister);\n","filename":"src\/hotspot\/cpu\/aarch64\/foreign_globals_aarch64.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -379,1 +379,1 @@\n-    reinterpret_cast<char*>(frame.unextended_sp()) + in_bytes(_frame_data_offset));\n+    reinterpret_cast<address>(frame.unextended_sp()) + in_bytes(_frame_data_offset));\n@@ -399,4 +399,1 @@\n-  if (!jfa->walkable()) {\n-    \/\/ Capture _last_Java_pc (if needed) and mark anchor walkable.\n-    jfa->capture_last_Java_pc();\n-  }\n+  jfa->make_walkable();\n@@ -405,1 +402,0 @@\n-  vmassert(jfa->last_Java_pc() != NULL, \"not walkable\");\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -5531,3 +5531,3 @@\n-\/\/ On 64 bit we will store integer like items to the stack as\n-\/\/ 64 bits items (Aarch64 abi) even though java would only store\n-\/\/ 32bits for a parameter. On 32bit it will simply be 32 bits\n+\/\/ On64 bit we will store integer like items to the stack as\n+\/\/ 64bits items (AArch64 ABI) even though java would only store\n+\/\/ 32bits for a parameter. On 32bit it will simply be 32bits\n@@ -5547,2 +5547,0 @@\n-    \/\/ Do we really have to sign extend???\n-    \/\/ __ movslq(src.first()->as_Register(), src.first()->as_Register());\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -140,2 +140,2 @@\n-  JavaCallConv in_conv;\n-  NativeCallConv out_conv(_input_registers);\n+  JavaCallingConvention in_conv;\n+  NativeCallingConvention out_conv(_input_registers);\n","filename":"src\/hotspot\/cpu\/aarch64\/universalNativeInvoker_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -130,2 +130,2 @@\n-  JavaCallConv out_conv;\n-  NativeCallConv in_conv(call_regs._arg_regs, call_regs._args_length);\n+  JavaCallingConvention out_conv;\n+  NativeCallingConvention in_conv(call_regs._arg_regs);\n@@ -152,2 +152,2 @@\n-  RegSpiller arg_spilller(call_regs._arg_regs, call_regs._args_length);\n-  RegSpiller result_spiller(call_regs._ret_regs, call_regs._rets_length);\n+  RegSpiller arg_spilller(call_regs._arg_regs);\n+  RegSpiller result_spiller(call_regs._ret_regs);\n@@ -242,1 +242,1 @@\n-    if (call_regs._rets_length == 1) { \/\/ 0 or 1\n+    if (call_regs._ret_regs.length() == 1) { \/\/ 0 or 1\n@@ -262,2 +262,2 @@\n-      assert(call_regs._ret_regs[0] == j_expected_result_reg,\n-      \"unexpected result register: %s != %s\", call_regs._ret_regs[0]->name(), j_expected_result_reg->name());\n+      assert(call_regs._ret_regs.at(0) == j_expected_result_reg,\n+      \"unexpected result register: %s != %s\", call_regs._ret_regs.at(0)->name(), j_expected_result_reg->name());\n@@ -270,2 +270,2 @@\n-    for (int i = 0; i < call_regs._rets_length; i++) {\n-      VMReg reg = call_regs._ret_regs[i];\n+    for (int i = 0; i < call_regs._ret_regs.length(); i++) {\n+      VMReg reg = call_regs._ret_regs.at(i);\n","filename":"src\/hotspot\/cpu\/aarch64\/universalUpcallHandler_aarch64.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -30,4 +30,0 @@\n-class outputStream;\n-\n-constexpr size_t xmm_reg_size = 16; \/\/ size of XMM reg\n-\n","filename":"src\/hotspot\/cpu\/x86\/foreign_globals_x86.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,29 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifndef CPU_X86_VM_FOREIGN_GLOBALS_X86_32_HPP\n-#define CPU_X86_VM_FOREIGN_GLOBALS_X86_32_HPP\n-\n-struct ABIDescriptor {};\n-\n-#endif \/\/ CPU_X86_VM_FOREIGN_GLOBALS_X86_32_HPP\n","filename":"src\/hotspot\/cpu\/x86\/foreign_globals_x86_32.hpp","additions":0,"deletions":29,"binary":false,"changes":29,"status":"deleted"},{"patch":"@@ -52,2 +52,2 @@\n-  loadArray(inputStorage, INTEGER_TYPE, abi._integer_argument_registers, as_Register);\n-  loadArray(inputStorage, VECTOR_TYPE, abi._vector_argument_registers, as_XMMRegister);\n+  parse_register_array(inputStorage, INTEGER_TYPE, abi._integer_argument_registers, as_Register);\n+  parse_register_array(inputStorage, VECTOR_TYPE, abi._vector_argument_registers, as_XMMRegister);\n@@ -56,2 +56,2 @@\n-  loadArray(outputStorage, INTEGER_TYPE, abi._integer_return_registers, as_Register);\n-  loadArray(outputStorage, VECTOR_TYPE, abi._vector_return_registers, as_XMMRegister);\n+  parse_register_array(outputStorage, INTEGER_TYPE, abi._integer_return_registers, as_Register);\n+  parse_register_array(outputStorage, VECTOR_TYPE, abi._vector_return_registers, as_XMMRegister);\n@@ -62,2 +62,2 @@\n-  loadArray(volatileStorage, INTEGER_TYPE, abi._integer_additional_volatile_registers, as_Register);\n-  loadArray(volatileStorage, VECTOR_TYPE, abi._vector_additional_volatile_registers, as_XMMRegister);\n+  parse_register_array(volatileStorage, INTEGER_TYPE, abi._integer_additional_volatile_registers, as_Register);\n+  parse_register_array(volatileStorage, VECTOR_TYPE, abi._vector_additional_volatile_registers, as_XMMRegister);\n","filename":"src\/hotspot\/cpu\/x86\/foreign_globals_x86_64.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,54 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifndef CPU_X86_VM_FOREIGN_GLOBALS_X86_HPP\n-#define CPU_X86_VM_FOREIGN_GLOBALS_X86_HPP\n-\n-#include \"asm\/macroAssembler.hpp\"\n-#include \"utilities\/growableArray.hpp\"\n-\n-class outputStream;\n-\n-constexpr size_t xmm_reg_size = 16; \/\/ size of XMM reg\n-\n-struct ABIDescriptor {\n-  GrowableArray<Register> _integer_argument_registers;\n-  GrowableArray<Register> _integer_return_registers;\n-  GrowableArray<XMMRegister> _vector_argument_registers;\n-  GrowableArray<XMMRegister> _vector_return_registers;\n-  size_t _X87_return_registers_noof;\n-\n-  GrowableArray<Register> _integer_additional_volatile_registers;\n-  GrowableArray<XMMRegister> _vector_additional_volatile_registers;\n-\n-  int32_t _stack_alignment_bytes;\n-  int32_t _shadow_space_bytes;\n-\n-  Register _target_addr_reg;\n-  Register _ret_buf_addr_reg;\n-\n-  bool is_volatile_reg(Register reg) const;\n-  bool is_volatile_reg(XMMRegister reg) const;\n-};\n-\n-#endif \/\/ CPU_X86_VM_FOREIGN_GLOBALS_X86_HPP\n","filename":"src\/hotspot\/cpu\/x86\/foreign_globals_x86_64.hpp","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -373,1 +373,1 @@\n-    reinterpret_cast<char*>(frame.unextended_sp()) + in_bytes(_frame_data_offset));\n+    reinterpret_cast<address>(frame.unextended_sp()) + in_bytes(_frame_data_offset));\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -933,1 +933,1 @@\n-       src.first()->name(), src.second()->name(), dst.first()->name(), dst.second()->name());\n+        src.first()->name(), src.second()->name(), dst.first()->name(), dst.second()->name());\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"compiler\/disassembler.hpp\"\n@@ -44,1 +43,0 @@\n-#include \"logging\/logStream.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -136,2 +136,2 @@\n-  JavaCallConv in_conv;\n-  NativeCallConv out_conv(_input_registers);\n+  JavaCallingConvention in_conv;\n+  NativeCallingConvention out_conv(_input_registers);\n","filename":"src\/hotspot\/cpu\/x86\/universalNativeInvoker_x86_64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -182,2 +182,2 @@\n-  JavaCallConv out_conv;\n-  NativeCallConv in_conv(call_regs._arg_regs, call_regs._args_length);\n+  JavaCallingConvention out_conv;\n+  NativeCallingConvention in_conv(call_regs._arg_regs);\n@@ -204,2 +204,2 @@\n-  RegSpiller arg_spilller(call_regs._arg_regs, call_regs._args_length);\n-  RegSpiller result_spiller(call_regs._ret_regs, call_regs._rets_length);\n+  RegSpiller arg_spilller(call_regs._arg_regs);\n+  RegSpiller result_spiller(call_regs._ret_regs);\n@@ -298,1 +298,1 @@\n-    if (call_regs._rets_length == 1) { \/\/ 0 or 1\n+    if (call_regs._ret_regs.length() == 1) { \/\/ 0 or 1\n@@ -318,2 +318,2 @@\n-      assert(call_regs._ret_regs[0] == j_expected_result_reg,\n-      \"unexpected result register: %s != %s\", call_regs._ret_regs[0]->name(), j_expected_result_reg->name());\n+      assert(call_regs._ret_regs.at(0) == j_expected_result_reg,\n+        \"unexpected result register: %s != %s\", call_regs._ret_regs.at(0)->name(), j_expected_result_reg->name());\n@@ -326,2 +326,2 @@\n-    for (int i = 0; i < call_regs._rets_length; i++) {\n-      VMReg reg = call_regs._ret_regs[i];\n+    for (int i = 0; i < call_regs._ret_regs.length(); i++) {\n+      VMReg reg = call_regs._ret_regs.at(i);\n","filename":"src\/hotspot\/cpu\/x86\/universalUpcallHandler_x86_64.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -4230,1 +4230,1 @@\n-    print_inlining(callee, \"Native call\", \/*success*\/ false);\n+    print_inlining(callee, \"native call\", \/*success*\/ false);\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,3 +37,3 @@\n-  CallRegs result;\n-  result._args_length = arg_regs_oop->length();\n-  result._arg_regs = NEW_RESOURCE_ARRAY(VMReg, result._args_length);\n+  int num_args = arg_regs_oop->length();\n+  int num_rets = ret_regs_oop->length();\n+  CallRegs result(num_args, num_rets);\n@@ -41,5 +41,2 @@\n-  result._rets_length = ret_regs_oop->length();\n-  result._ret_regs = NEW_RESOURCE_ARRAY(VMReg, result._rets_length);\n-\n-  for (int i = 0; i < result._args_length; i++) {\n-    result._arg_regs[i] = parse_vmstorage(arg_regs_oop->obj_at(i));\n+  for (int i = 0; i < num_args; i++) {\n+    result._arg_regs.push(parse_vmstorage(arg_regs_oop->obj_at(i)));\n@@ -48,2 +45,2 @@\n-  for (int i = 0; i < result._rets_length; i++) {\n-    result._ret_regs[i] = parse_vmstorage(ret_regs_oop->obj_at(i));\n+  for (int i = 0; i < num_rets; i++) {\n+    result._ret_regs.push(parse_vmstorage(ret_regs_oop->obj_at(i)));\n@@ -61,1 +58,1 @@\n-int RegSpiller::compute_spill_area(const VMReg* regs, int num_regs) {\n+int RegSpiller::compute_spill_area(const GrowableArray<VMReg>& regs) {\n@@ -63,2 +60,2 @@\n-  for (int i = 0; i < num_regs; i++) {\n-    result_size += pd_reg_size(regs[i]);\n+  for (int i = 0; i < regs.length(); i++) {\n+    result_size += pd_reg_size(regs.at(i));\n@@ -72,2 +69,2 @@\n-  for (int i = 0; i < _num_regs; i++) {\n-    VMReg reg = _regs[i];\n+  for (int i = 0; i < _regs.length(); i++) {\n+    VMReg reg = _regs.at(i);\n@@ -105,1 +102,1 @@\n-int NativeCallConv::calling_convention(BasicType* sig_bt, VMRegPair* out_regs, int num_args) const {\n+int NativeCallingConvention::calling_convention(BasicType* sig_bt, VMRegPair* out_regs, int num_args) const {\n@@ -116,2 +113,2 @@\n-        assert(src_pos < _input_regs_length, \"oob\");\n-        VMReg reg = _input_regs[src_pos++];\n+        assert(src_pos < _input_regs.length(), \"oob\");\n+        VMReg reg = _input_regs.at(src_pos++);\n@@ -126,2 +123,2 @@\n-        assert(src_pos < _input_regs_length, \"oob\");\n-        VMReg reg = _input_regs[src_pos++];\n+        assert(src_pos < _input_regs.length(), \"oob\");\n+        VMReg reg = _input_regs.at(src_pos++);\n@@ -145,3 +142,1 @@\n-\/\/ based on ComputeMoveOrder from x86_64 shared runtime code.\n-\/\/ with some changes.\n-class ForeignCMO: public StackObj {\n+class ComputeMoveOrder: public StackObj {\n@@ -149,1 +144,1 @@\n-    friend class ForeignCMO;\n+    friend class ComputeMoveOrder;\n@@ -151,6 +146,6 @@\n-    VMRegPair        _src;\n-    VMRegPair        _dst;\n-    bool             _processed;\n-    MoveOperation*  _next;\n-    MoveOperation*  _prev;\n-    BasicType        _bt;\n+    VMRegPair      _src;\n+    VMRegPair      _dst;\n+    bool           _processed;\n+    MoveOperation* _next;\n+    MoveOperation* _prev;\n+    BasicType      _bt;\n@@ -163,8 +158,2 @@\n-    MoveOperation(VMRegPair src, VMRegPair dst, BasicType bt):\n-      _src(src)\n-    , _dst(dst)\n-    , _processed(false)\n-    , _next(NULL)\n-    , _prev(NULL)\n-    , _bt(bt) {\n-    }\n+    MoveOperation(VMRegPair src, VMRegPair dst, BasicType bt)\n+      : _src(src), _dst(dst), _processed(false), _next(NULL), _prev(NULL), _bt(bt) {}\n@@ -213,0 +202,6 @@\n+  int _total_in_args;\n+  const VMRegPair* _in_regs;\n+  int _total_out_args;\n+  const VMRegPair* _out_regs;\n+  const BasicType* _in_sig_bt;\n+  VMRegPair _tmp_vmreg;\n@@ -216,4 +211,14 @@\n- public:\n-  ForeignCMO(int total_in_args, const VMRegPair* in_regs, int total_out_args, VMRegPair* out_regs,\n-             const BasicType* in_sig_bt, VMRegPair tmp_vmreg) : _edges(total_in_args), _moves(total_in_args) {\n-    assert(total_out_args >= total_in_args, \"can only add prefix args\");\n+  ComputeMoveOrder(int total_in_args, const VMRegPair* in_regs, int total_out_args, VMRegPair* out_regs,\n+                   const BasicType* in_sig_bt, VMRegPair tmp_vmreg) :\n+      _total_in_args(total_in_args),\n+      _in_regs(in_regs),\n+      _total_out_args(total_out_args),\n+      _out_regs(out_regs),\n+      _in_sig_bt(in_sig_bt),\n+      _tmp_vmreg(tmp_vmreg),\n+      _edges(total_in_args),\n+      _moves(total_in_args) {\n+  }\n+\n+  void compute() {\n+    assert(_total_out_args >= _total_in_args, \"can only add prefix args\");\n@@ -227,2 +232,2 @@\n-    for (int in_idx = total_in_args - 1, out_idx = total_out_args - 1; in_idx >= 0; in_idx--, out_idx--) {\n-      BasicType bt = in_sig_bt[in_idx];\n+    for (int in_idx = _total_in_args - 1, out_idx = _total_out_args - 1; in_idx >= 0; in_idx--, out_idx--) {\n+      BasicType bt = _in_sig_bt[in_idx];\n@@ -230,2 +235,2 @@\n-      VMRegPair in_reg = in_regs[in_idx];\n-      VMRegPair out_reg = out_regs[out_idx];\n+      VMRegPair in_reg = _in_regs[in_idx];\n+      VMRegPair out_reg = _out_regs[out_idx];\n@@ -252,1 +257,1 @@\n-    compute_store_order(tmp_vmreg);\n+    compute_store_order(_tmp_vmreg);\n@@ -301,2 +306,7 @@\n-  GrowableArray<Move> moves() {\n-    return _moves;\n+public:\n+  static GrowableArray<Move> compute_move_order(int total_in_args, const VMRegPair* in_regs,\n+                                                int total_out_args, VMRegPair* out_regs,\n+                                                const BasicType* in_sig_bt, VMRegPair tmp_vmreg) {\n+    ComputeMoveOrder cmo(total_in_args, in_regs, total_out_args, out_regs, in_sig_bt, tmp_vmreg);\n+    cmo.compute();\n+    return cmo._moves;\n@@ -311,2 +321,2 @@\n-    const CallConvClosure* input_conv,\n-    const CallConvClosure* output_conv,\n+    const CallingConventionClosure* input_conv,\n+    const CallingConventionClosure* output_conv,\n@@ -325,1 +335,1 @@\n-  \/\/ Note that ForeignCMO ignores the upper half of our VMRegPairs.\n+  \/\/ Note that ComputeMoveOrder ignores the upper half of our VMRegPairs.\n@@ -330,4 +340,3 @@\n-  ForeignCMO order(num_in_args, in_regs,\n-                   num_out_args, out_regs,\n-                   in_sig_bt, tmp_vmreg);\n-  _moves = order.moves();\n+  _moves = ComputeMoveOrder::compute_move_order(num_in_args, in_regs,\n+                                                num_out_args, out_regs,\n+                                                in_sig_bt, tmp_vmreg);\n","filename":"src\/hotspot\/share\/prims\/foreign_globals.cpp","additions":65,"deletions":56,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-class CallConvClosure {\n+class CallingConventionClosure {\n@@ -41,2 +41,2 @@\n-  VMReg* _arg_regs;\n-  int _args_length;\n+  GrowableArray<VMReg> _arg_regs;\n+  GrowableArray<VMReg> _ret_regs;\n@@ -44,2 +44,2 @@\n-  VMReg* _ret_regs;\n-  int _rets_length;\n+  CallRegs(int num_args, int num_rets)\n+    : _arg_regs(num_args), _ret_regs(num_rets) {}\n@@ -51,1 +51,1 @@\n-  static void loadArray(objArrayOop jarray, int type_index, GrowableArray<T>& array, Func converter);\n+  static void parse_register_array(objArrayOop jarray, int type_index, GrowableArray<T>& array, Func converter);\n@@ -62,1 +62,1 @@\n-class JavaCallConv : public CallConvClosure {\n+class JavaCallingConvention : public CallingConventionClosure {\n@@ -69,3 +69,2 @@\n-class NativeCallConv : public CallConvClosure {\n-  const VMReg* _input_regs;\n-  int _input_regs_length;\n+class NativeCallingConvention : public CallingConventionClosure {\n+  GrowableArray<VMReg> _input_regs;\n@@ -73,6 +72,2 @@\n-  NativeCallConv(const VMReg* input_regs, int input_regs_length) :\n-    _input_regs(input_regs),\n-    _input_regs_length(input_regs_length) {\n-  }\n-  NativeCallConv(const GrowableArray<VMReg>& input_regs)\n-   : NativeCallConv(input_regs.data(), input_regs.length()) {}\n+  NativeCallingConvention(const GrowableArray<VMReg>& input_regs)\n+   : _input_regs(input_regs) {}\n@@ -84,2 +79,1 @@\n-  const VMReg* _regs;\n-  int _num_regs;\n+  GrowableArray<VMReg> _regs;\n@@ -88,5 +82,1 @@\n-  RegSpiller(const VMReg* regs, int num_regs) :\n-    _regs(regs), _num_regs(num_regs),\n-    _spill_size_bytes(compute_spill_area(regs, num_regs)) {\n-  }\n-  RegSpiller(const GrowableArray<VMReg>& regs) : RegSpiller(regs.data(), regs.length()) {\n+  RegSpiller(const GrowableArray<VMReg>& regs) : _regs(regs), _spill_size_bytes(compute_spill_area(regs)) {\n@@ -100,1 +90,1 @@\n-  static int compute_spill_area(const VMReg* regs, int num_regs);\n+  static int compute_spill_area(const GrowableArray<VMReg>& regs);\n@@ -122,1 +112,1 @@\n-    const CallConvClosure* input_conv, const CallConvClosure* output_conv,\n+    const CallingConventionClosure* input_conv, const CallingConventionClosure* output_conv,\n","filename":"src\/hotspot\/share\/prims\/foreign_globals.hpp","additions":15,"deletions":25,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-void ForeignGlobals::loadArray(objArrayOop jarray, int type_index, GrowableArray<T>& array, Func converter) {\n+void ForeignGlobals::parse_register_array(objArrayOop jarray, int type_index, GrowableArray<T>& array, Func converter) {\n","filename":"src\/hotspot\/share\/prims\/foreign_globals.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,2 +60,2 @@\n-      \/\/ NativeCallConv ignores them, but they are needed\n-      \/\/ for JavaCallConv\n+      \/\/ NativeCallingConvention ignores them, but they are needed\n+      \/\/ for JavaCallingConvention\n","filename":"src\/hotspot\/share\/prims\/nativeEntryPoint.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -144,8 +144,0 @@\n-  E* data() {\n-    return _data;\n-  }\n-\n-  const E* data() const {\n-    return _data;\n-  }\n-\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -313,1 +313,1 @@\n-        if (destIndex < sourceIndex)\n+        if (destIndex < sourceIndex) {\n@@ -315,0 +315,1 @@\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -169,1 +169,1 @@\n-                targetAddrStorage, retBufAddrStorage);\n+            targetAddrStorage, retBufAddrStorage);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64Architecture.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n-                targetAddrStorage, retBufAddrStorage);\n+            targetAddrStorage, retBufAddrStorage);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/X86_64Architecture.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}