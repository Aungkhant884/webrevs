{"files":[{"patch":"@@ -28,1 +28,1 @@\n- * @library \/test\/lib\n+ * @library \/test\/lib \/test\/jdk\/com\/sun\/jdi\n@@ -48,1 +48,1 @@\n-import jdk.test.lib.util.ClassTransformer;\n+import lib.jdb.ClassTransformer;\n","filename":"test\/jdk\/java\/lang\/instrument\/RetransformWithMethodParametersTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,163 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.test.lib.util;\n-\n-import jdk.test.lib.compiler.CompilerUtils;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.text.MessageFormat;\n-import java.util.Arrays;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-import java.util.stream.Collectors;\n-\n-\/\/ ClassTransformer provides functionality to transform java source and compile it.\n-\/\/ We cannot use InMemoryJavaCompiler as test files usually contain 2 classes (the test itself and debuggee)\n-\/\/ and InMemoryJavaCompiler cannot compile them.\n-public class ClassTransformer {\n-\n-    private final List<String> lines;\n-    private String fileName;\n-    private String workDir = \"ver{0}\";\n-    private static final String LINE_SEPARATOR = System.getProperty(\"line.separator\");\n-\n-    private ClassTransformer(List<String> lines) {\n-        this.lines = lines;\n-    }\n-\n-    public ClassTransformer setFileName(String fileName) {\n-        this.fileName = fileName;\n-        return this;\n-    }\n-\n-    \/\/ workDir is a MessageFormat pattern, id (int) is an {0} arg of the pattern.\n-    \/\/ can be relative (relatively \"scratch\" dir) or absolute.\n-    public ClassTransformer setWorkDir(String dir) {\n-        workDir = dir;\n-        return this;\n-    }\n-\n-    public static ClassTransformer fromString(String content) {\n-        return new ClassTransformer(Arrays.asList(content.split(\"\\\\R\")));\n-    }\n-\n-    public static ClassTransformer fromFile(Path filePath) {\n-        try {\n-            return new ClassTransformer(Files.readAllLines(filePath))\n-                    .setFileName(filePath.getFileName().toString());\n-        } catch (IOException e) {\n-            throw new RuntimeException(\"failed to read \" + filePath, e);\n-        }\n-    }\n-    public static ClassTransformer fromFile(String filePath) {\n-        return fromFile(Paths.get(filePath));\n-    }\n-\n-    public static ClassTransformer fromTestSource(String fileName) {\n-        return fromFile(Paths.get(System.getProperty(\"test.src\")).resolve(fileName));\n-    }\n-\n-    \/\/ returns path to the .class file of the transformed class\n-    public String transform(int id, String className, String... compilerOptions) {\n-        Path subdir = Paths.get(\".\").resolve(MessageFormat.format(workDir, id));\n-        Path transformedSrc = subdir.resolve(fileName);\n-        try {\n-            Files.createDirectories(subdir);\n-            Files.write(transformedSrc, transform(id).getBytes());\n-        } catch (IOException e) {\n-            throw new RuntimeException(\"failed to write transformed \" + transformedSrc, e);\n-        }\n-        try {\n-            \/\/ need to add extra classpath args\n-            List<String> args = new LinkedList<>(Arrays.asList(compilerOptions));\n-            args.add(\"-cp\");\n-            args.add(System.getProperty(\"java.class.path\"));\n-            CompilerUtils.compile(subdir, subdir, false, args.toArray(new String[args.size()]));\n-        } catch (IOException e) {\n-            throw new RuntimeException(\"failed to compile \" + transformedSrc, e);\n-        }\n-        return subdir.resolve(className + \".class\").toString();\n-    }\n-\n-    \/*\n-    * To do RedefineClasses operations, embed @1 tags in the .java\n-    * file to tell this script how to modify it to produce the 2nd\n-    * version of the .class file to be used in the redefine operation.\n-    * Here are examples of each editing tag and what change\n-    * it causes in the new file.  Note that blanks are not preserved\n-    * in these editing operations.\n-    *\n-    * @1 uncomment\n-    *  orig:   \/\/ @1 uncomment   gus = 89;\n-    *  new:         gus = 89;\n-    *\n-    * @1 commentout\n-    *  orig:   gus = 89      \/\/ @1 commentout\n-    *  new: \/\/ gus = 89      \/\/ @1 commentout\n-    *\n-    * @1 delete\n-    *  orig:  gus = 89      \/\/ @1 delete\n-    *  new:   entire line deleted\n-    *\n-    * @1 newline\n-    *  orig:  gus = 89;     \/\/ @1 newline gus++;\n-    *  new:   gus = 89;     \/\/\n-    *         gus++;\n-    *\n-    * @1 replace\n-    *  orig:  gus = 89;     \/\/ @1 replace gus = 90;\n-    *  new:   gus = 90;\n-    *\/\n-    public String transform(int id) {\n-        Pattern delete = Pattern.compile(\"@\" + id + \" *delete\");\n-        Pattern uncomment = Pattern.compile(\"\/\/ *@\" + id + \" *uncomment (.*)\");\n-        Pattern commentout = Pattern.compile(\".* @\" + id + \" *commentout\");\n-        Pattern newline = Pattern.compile(\"(.*) @\" + id + \" *newline (.*)\");\n-        Pattern replace = Pattern.compile(\"@\" + id + \" *replace (.*)\");\n-        return lines.stream()\n-                .filter(s -> !delete.matcher(s).find())     \/\/ @1 delete\n-                .map(s -> {\n-                    Matcher m = uncomment.matcher(s);       \/\/ @1 uncomment\n-                    return m.find() ? m.group(1) : s;\n-                })\n-                .map(s-> {\n-                    Matcher m = commentout.matcher(s);      \/\/ @1 commentout\n-                    return m.find() ? \"\/\/\" + s : s;\n-                })\n-                .map(s -> {\n-                    Matcher m = newline.matcher(s);         \/\/ @1 newline\n-                    return m.find() ? m.group(1) + LINE_SEPARATOR + m.group(2) : s;\n-                })\n-                .map(s -> {\n-                    Matcher m = replace.matcher(s);         \/\/ @1 replace\n-                    return m.find() ? m.group(1) : s;\n-                })\n-                .collect(Collectors.joining(LINE_SEPARATOR));\n-    }\n-\n-}\n","filename":"test\/lib\/jdk\/test\/lib\/util\/ClassTransformer.java","additions":0,"deletions":163,"binary":false,"changes":163,"status":"deleted"}]}