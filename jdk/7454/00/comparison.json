{"files":[{"patch":"@@ -3650,0 +3650,2 @@\n+  Node* cast = NULL;\n+  Node* conv = NULL;\n@@ -3665,3 +3667,6 @@\n-      int opc = n->Opcode();\n-      if (opc == Op_StoreP || opc == Op_StoreN || opc == Op_StoreNKlass || opc == Op_StoreCM) {\n-        msg = \"oop fills not handled\";\n+      \/\/ Make sure there is an appropriate fill routine(StubRoutines::select_fill_function)\n+      BasicType t = n->as_Mem()->memory_type();\n+      const char* fill_name;\n+      if (StubRoutines::select_fill_function(t, false, fill_name) == NULL) {\n+        msg = \"unsupported store\";\n+        msg_node = n;\n@@ -3670,0 +3675,1 @@\n+      \/\/ Make sure invariant value stored into an array\n@@ -3671,0 +3677,2 @@\n+      Node* addr = n->in(MemNode::Address);\n+      Node* mem = n->in(MemNode::Memory);\n@@ -3673,1 +3681,3 @@\n-      } else if (!_igvn.type(n->in(MemNode::Address))->isa_aryptr()) {\n+        msg_node = value;\n+        break;\n+      } else if (!_igvn.type(addr)->isa_aryptr()) {\n@@ -3675,0 +3685,12 @@\n+        msg_node = addr;\n+        break;\n+      }\n+      if (!addr->is_AddP()) {\n+        msg = \"can't handle store address\";\n+        msg_node = addr;\n+        break;\n+      }\n+      if (!mem->is_Phi() || mem->in(LoopNode::LoopBackControl) != n) {\n+        msg = \"store memory isn't proper phi\";\n+        msg_node = mem;\n+        break;\n@@ -3676,52 +3698,0 @@\n-      store = n;\n-      store_value = value;\n-    } else if (n->is_If() && n != head->loopexit_or_null()) {\n-      msg = \"extra control flow\";\n-      msg_node = n;\n-    }\n-  }\n-\n-  if (store == NULL) {\n-    \/\/ No store in loop\n-    return false;\n-  }\n-\n-  if (msg == NULL && head->stride_con() != 1) {\n-    \/\/ could handle negative strides too\n-    if (head->stride_con() < 0) {\n-      msg = \"negative stride\";\n-    } else {\n-      msg = \"non-unit stride\";\n-    }\n-  }\n-\n-  if (msg == NULL && !store->in(MemNode::Address)->is_AddP()) {\n-    msg = \"can't handle store address\";\n-    msg_node = store->in(MemNode::Address);\n-  }\n-\n-  if (msg == NULL &&\n-      (!store->in(MemNode::Memory)->is_Phi() ||\n-       store->in(MemNode::Memory)->in(LoopNode::LoopBackControl) != store)) {\n-    msg = \"store memory isn't proper phi\";\n-    msg_node = store->in(MemNode::Memory);\n-  }\n-\n-  \/\/ Make sure there is an appropriate fill routine\n-  BasicType t = store->as_Mem()->memory_type();\n-  const char* fill_name;\n-  if (msg == NULL &&\n-      StubRoutines::select_fill_function(t, false, fill_name) == NULL) {\n-    msg = \"unsupported store\";\n-    msg_node = store;\n-  }\n-\n-  if (msg != NULL) {\n-#ifndef PRODUCT\n-    if (TraceOptimizeFill) {\n-      tty->print_cr(\"not fill intrinsic candidate: %s\", msg);\n-      if (msg_node != NULL) msg_node->dump();\n-    }\n-#endif\n-    return false;\n-  }\n@@ -3729,17 +3699,9 @@\n-  \/\/ Make sure the address expression can be handled.  It should be\n-  \/\/ head->phi * elsize + con.  head->phi might have a ConvI2L(CastII()).\n-  Node* elements[4];\n-  Node* cast = NULL;\n-  Node* conv = NULL;\n-  bool found_index = false;\n-  int count = store->in(MemNode::Address)->as_AddP()->unpack_offsets(elements, ARRAY_SIZE(elements));\n-  for (int e = 0; e < count; e++) {\n-    Node* n = elements[e];\n-    if (n->is_Con() && con == NULL) {\n-      con = n;\n-    } else if (n->Opcode() == Op_LShiftX && shift == NULL) {\n-      Node* value = n->in(1);\n-#ifdef _LP64\n-      if (value->Opcode() == Op_ConvI2L) {\n-        conv = value;\n-        value = value->in(1);\n+      \/\/ Make sure the address expression can be handled.  It should be\n+      \/\/ head->phi * elsize + con.  head->phi might have a ConvI2L(CastII()).\n+      bool found_index = false;\n+      Node* elements[4];\n+      int count = addr->as_AddP()->unpack_offsets(elements, ARRAY_SIZE(elements));\n+      if (count != 2) {\n+        msg = \"malformed address expression\";\n+        msg_node = addr;\n+        break;\n@@ -3747,5 +3709,6 @@\n-      if (value->Opcode() == Op_CastII &&\n-          value->as_CastII()->has_range_check()) {\n-        \/\/ Skip range check dependent CastII nodes\n-        cast = value;\n-        value = value->in(1);\n+      if (elements[0]->is_Con()) {\n+        con = elements[0];\n+      } else {\n+        msg = \"malformed address expression: expect a Con\";\n+        msg_node = addr;\n+        break;\n@@ -3753,0 +3716,28 @@\n+      if (elements[1]->Opcode() == Op_ConvI2L) {\n+        conv = elements[1];\n+        Node* tmp = elements[1]->in(1);\n+        if (tmp->Opcode() == Op_CastII &&\n+            tmp->as_CastII()->has_range_check()) {\n+          \/\/ Skip range check dependent CastII nodes\n+          cast = tmp;\n+          tmp = tmp->in(1);\n+        }\n+        if (tmp == head->phi()) {\n+          found_index = true;\n+        } else {\n+          msg = \"unhandled input to ConvI2L\";\n+          break;\n+        }\n+      } else if (elements[1]->Opcode() == Op_LShiftX) {\n+        Node* value = elements[1]->in(1);\n+#ifdef _LP64\n+        if (value->Opcode() == Op_ConvI2L) {\n+          conv = value;\n+          value = value->in(1);\n+        }\n+        if (value->Opcode() == Op_CastII &&\n+            value->as_CastII()->has_range_check()) {\n+          \/\/ Skip range check dependent CastII nodes\n+          cast = value;\n+          value = value->in(1);\n+        }\n@@ -3754,5 +3745,3 @@\n-      if (value != head->phi()) {\n-        msg = \"unhandled shift in address\";\n-      } else {\n-        if (type2aelembytes(store->as_Mem()->memory_type(), true) != (1 << n->in(2)->get_int())) {\n-          msg = \"scale doesn't match\";\n+        if (value != head->phi()) {\n+          msg = \"unhandled shift in address\";\n+          break;\n@@ -3760,2 +3749,7 @@\n-          found_index = true;\n-          shift = n;\n+          if (type2aelembytes(n->as_Mem()->memory_type(), true) != (1 << elements[1]->in(2)->get_int())) {\n+            msg = \"scale doesn't match\";\n+            break;\n+          } else {\n+            found_index = true;\n+            shift = elements[1];\n+          }\n@@ -3763,11 +3757,1 @@\n-      }\n-    } else if (n->Opcode() == Op_ConvI2L && conv == NULL) {\n-      conv = n;\n-      n = n->in(1);\n-      if (n->Opcode() == Op_CastII &&\n-          n->as_CastII()->has_range_check()) {\n-        \/\/ Skip range check dependent CastII nodes\n-        cast = n;\n-        n = n->in(1);\n-      }\n-      if (n == head->phi()) {\n+      } else if(value != head->phi()) {\n@@ -3775,0 +3759,1 @@\n+        break;\n@@ -3776,1 +3761,3 @@\n-        msg = \"unhandled input to ConvI2L\";\n+        msg = \"malformed address expression: expect either a LShift or ConvI2L\";\n+        msg_node = store;\n+        break;\n@@ -3778,5 +3765,14 @@\n-    } else if (n == head->phi()) {\n-      \/\/ no shift, check below for allowed cases\n-      found_index = true;\n-    } else {\n-      msg = \"unhandled node in address\";\n+      if (!found_index) {\n+        msg = \"missing use of index\";\n+      }\n+      \/\/ byte sized items won't have a shift\n+      if (shift == NULL && t != T_BYTE && t != T_BOOLEAN) {\n+        msg = \"can't find shift\";\n+        msg_node = store;\n+        break;\n+      }\n+      \/\/ It's a valid Store node\n+      store = n;\n+      store_value = value;\n+    } else if (n->is_If() && n != head->loopexit_or_null()) {\n+      msg = \"extra control flow\";\n@@ -3784,0 +3780,1 @@\n+      break;\n@@ -3787,13 +3784,3 @@\n-  if (count == -1) {\n-    msg = \"malformed address expression\";\n-    msg_node = store;\n-  }\n-\n-  if (!found_index) {\n-    msg = \"missing use of index\";\n-  }\n-\n-  \/\/ byte sized items won't have a shift\n-  if (msg == NULL && shift == NULL && t != T_BYTE && t != T_BOOLEAN) {\n-    msg = \"can't find shift\";\n-    msg_node = store;\n+  if (store == NULL) {\n+    \/\/ No store in loop\n+    return false;\n@@ -3828,0 +3815,1 @@\n+  ok.set(loop_exit->proj_out(1)->_idx); \/\/ Backedge projection is ok\n@@ -3839,2 +3827,0 @@\n-    \/\/ Backedge projection is ok\n-    if (n->is_IfTrue() && n->in(0) == loop_exit) continue;\n@@ -3890,1 +3876,1 @@\n-  \/\/ Must have constant stride\n+  \/\/ Must have constant unit stride\n@@ -3892,1 +3878,2 @@\n-  if (!head->is_valid_counted_loop(T_INT) || !head->is_normal_loop()) {\n+  if (!head->is_valid_counted_loop(T_INT) || !head->is_normal_loop() || head->stride_con() != 1 ||\n+      head->loopexit()->proj_out_or_null(0) == NULL) {\n@@ -3908,5 +3895,0 @@\n-  Node* exit = head->loopexit()->proj_out_or_null(0);\n-  if (exit == NULL) {\n-    return false;\n-  }\n-\n@@ -3955,1 +3937,1 @@\n-  \/\/ Convert float\/double to int\/long for fill routines\n+  \/\/ Convert float to int for fill routines\n@@ -3960,2 +3942,1 @@\n-    store_value = new MoveD2LNode(store_value);\n-    _igvn.register_new_node_with_optimizer(store_value);\n+    ShouldNotReachHere();\n@@ -4034,1 +4015,1 @@\n-  lazy_replace(exit, result_ctrl);\n+  lazy_replace(head->loopexit()->proj_out_or_null(0), result_ctrl);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":109,"deletions":128,"binary":false,"changes":237,"status":"modified"},{"patch":"@@ -1404,1 +1404,1 @@\n-        Node* elements[4];\n+        Node* elements[2];\n@@ -1407,4 +1407,7 @@\n-        if (count > 0 && elements[0]->is_Con() &&\n-            (count == 1 ||\n-             (count == 2 && elements[1]->Opcode() == Op_LShiftX &&\n-                            elements[1]->in(2) == igvn->intcon(shift)))) {\n+        if (count != -1) {\n+          assert(count <= 2, \"malformed address expr\");\n+          assert(elements[0]->is_Con(), \"malformed address expr\");\n+          if (count == 2) {\n+            assert(elements[1]->Opcode() == Op_LShiftX &&  elements[1]->in(2) == igvn->intcon(shift),\n+                  \"malformed address expr\");\n+          }\n@@ -1434,1 +1437,1 @@\n-           \/\/ Add up all the offsets making of the address of the load\n+            \/\/ Add up all the offsets making of the address of the load\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2022, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test array filling optimization\n+ * @requires vm.compiler2.enabled & vm.debug\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+OptimizeFill -XX:LoopUnrollLimit=0 -XX:+TraceOptimizeFill compiler.c2.TestOptimizeFill\n+ *\/\n+\n+package compiler.c2;\n+\n+public class TestOptimizeFill {\n+    static int[] a = new int[500];\n+    static boolean[] b = new boolean[100];\n+\n+    static int[] test1(int x) {\n+        float[] f = new float[100];\n+        byte[] t = new byte[600];\n+\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = a.length;\n+        }\n+        for (int i = 0; i < b.length; i++) {\n+            b[i] =  true;\n+        }\n+        for (int i = 0; i < f.length; i++) {\n+            f[i] =  3.14f;\n+        }\n+        for (int i = 0; i < t.length; i++) {\n+            t[i] =  (byte)x;\n+        }\n+        java.util.Arrays.fill(a, x);\n+        return a;\n+    }\n+\n+    static int[] test2(int x) {\n+        for (;;) {\n+            int[] k = new int[1024];\n+            for (int i = 0; i < k.length; i++) {\n+                k[i] =  k.length;\n+            }\n+            return k;\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        int k = 0;\n+        for (int i = 0; i < 10000; i++) {\n+            k += test1(i)[i%100];\n+            k += test2(i)[i%100];\n+        }\n+        System.out.println(k);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestOptimizeFill.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"}]}