{"files":[{"patch":"@@ -1926,1 +1926,1 @@\n-  assert(UsePartialInlineSize <= 64,\"\");\n+  assert(ArrayOperationPartailInlineSize <= 64,\"\");\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1409,6 +1409,6 @@\n-      if (FLAG_IS_DEFAULT(UsePartialInlineSize) ||\n-          (!FLAG_IS_DEFAULT(UsePartialInlineSize) &&\n-           UsePartialInlineSize != 0 &&\n-           UsePartialInlineSize != 32 &&\n-           UsePartialInlineSize != 16 &&\n-           UsePartialInlineSize != 64)) {\n+      if (FLAG_IS_DEFAULT(ArrayOperationPartailInlineSize) ||\n+          (!FLAG_IS_DEFAULT(ArrayOperationPartailInlineSize) &&\n+           ArrayOperationPartailInlineSize != 0 &&\n+           ArrayOperationPartailInlineSize != 16 &&\n+           ArrayOperationPartailInlineSize != 32 &&\n+           ArrayOperationPartailInlineSize != 64)) {\n@@ -1423,2 +1423,2 @@\n-        if(!FLAG_IS_DEFAULT(UsePartialInlineSize)) {\n-          warning(\"Setting UsePartialInlineSize as %d\", inline_size);\n+        if(!FLAG_IS_DEFAULT(ArrayOperationPartailInlineSize)) {\n+          warning(\"Setting ArrayOperationPartailInlineSize as %d\", inline_size);\n@@ -1426,1 +1426,1 @@\n-        UsePartialInlineSize = inline_size;\n+        ArrayOperationPartailInlineSize = inline_size;\n@@ -1429,4 +1429,4 @@\n-      if (UsePartialInlineSize > MaxVectorSize) {\n-        UsePartialInlineSize = MaxVectorSize >= 16 ? MaxVectorSize : 0;\n-        if (UsePartialInlineSize) {\n-          warning(\"Setting UsePartialInlineSize as MaxVectorSize\" INTX_FORMAT \")\", MaxVectorSize);\n+      if (ArrayOperationPartailInlineSize > MaxVectorSize) {\n+        ArrayOperationPartailInlineSize = MaxVectorSize >= 16 ? MaxVectorSize : 0;\n+        if (ArrayOperationPartailInlineSize) {\n+          warning(\"Setting ArrayOperationPartailInlineSize as MaxVectorSize\" INTX_FORMAT \")\", MaxVectorSize);\n@@ -1434,1 +1434,1 @@\n-          warning(\"Setting UsePartialInlineSize as \" INTX_FORMAT, UsePartialInlineSize);\n+          warning(\"Setting ArrayOperationPartailInlineSize as \" INTX_FORMAT, ArrayOperationPartailInlineSize);\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1671,0 +1671,1 @@\n+    case Op_VectorCmpMasked:\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -741,1 +741,1 @@\n-  int lane_count = UsePartialInlineSize\/type2aelembytes(type);\n+  int lane_count = ArrayOperationPartailInlineSize\/type2aelembytes(type);\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,2 +85,3 @@\n-  product(intx, UsePartialInlineSize, -1, DIAGNOSTIC,                       \\\n-          \"Partial inline size used for array copy acceleration.\")          \\\n+  product(intx, ArrayOperationPartailInlineSize, -1, DIAGNOSTIC,            \\\n+          \"Partial inline size used for small array operations\"             \\\n+          \"(e.g. copy,cmp) acceleration.\")                                  \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -5218,30 +5218,22 @@\n-  assert(scale->bottom_type()->isa_int() &&\n-         scale->bottom_type()->is_int()->is_con(),\n-         \"non-constant scale value\");\n-\n-  int scale_val = scale->bottom_type()->is_int()->get_con();\n-  BasicType prim_types[] = {T_BYTE, T_SHORT, T_INT, T_LONG};\n-  BasicType vec_basictype = prim_types[scale_val];\n-  const Type* vec_type = Type::get_const_basic_type(vec_basictype);\n-  int vec_len = UsePartialInlineSize \/ type2aelembytes(vec_basictype);\n-\n-  Node* length_in_bytes = _gvn.transform(new LShiftINode(length, scale));\n-  Node* length_cmp = _gvn.transform(new CmpINode(length_in_bytes, intcon(UsePartialInlineSize)));\n-  Node* cmp_res = _gvn.transform(new BoolNode(length_cmp, BoolTest::le));\n-\n-  \/\/ Enable partial in-lining if compare size is less than UsePartialInlineSize(default 32 bytes).\n-  bool enable_pi = (UsePartialInlineSize > 32) ? (NULL != vec_type->isa_int())\n-                                               : is_subword_type(vec_basictype);\n-  if (enable_pi && Type::cmp(TypeInt::ZERO, cmp_res->bottom_type()) &&\n-      (Matcher::match_rule_supported_vector(Op_VectorMaskGen , vec_len, vec_basictype) &&\n-       Matcher::match_rule_supported_vector(Op_LoadVectorMasked , vec_len, vec_basictype) &&\n-       Matcher::match_rule_supported_vector(Op_VectorCmpMasked, vec_len, vec_basictype))) {\n-\n-    Node* fast_path = NULL;\n-    Node* slow_path = NULL;\n-    bool gen_slow_path = Type::cmp(TypeInt::ONE, cmp_res->bottom_type());\n-    if (gen_slow_path) {\n-      fast_path = generate_guard(cmp_res, NULL, PROB_MAX);\n-      slow_path = control();\n-    } else {\n-      fast_path = slow_path = control();\n+  bool enable_pi = false;\n+  Node* fast_path = top();\n+  Node* fastcomp_result = top();\n+  Node* init_mem = map()->memory();\n+\n+  assert(scale->bottom_type()->isa_int(), \"scale must be integer\");\n+  if (scale->bottom_type()->is_int()->is_con()) {\n+    int scale_val = scale->bottom_type()->is_int()->get_con();\n+    BasicType prim_types[] = {T_BYTE, T_SHORT, T_INT, T_LONG};\n+    BasicType vec_basictype = prim_types[scale_val];\n+    const Type* vec_type = Type::get_const_basic_type(vec_basictype);\n+    int vec_len = ArrayOperationPartailInlineSize \/ type2aelembytes(vec_basictype);\n+\n+    \/\/ Enable partial in-lining if compare size is less than\n+    \/\/ ArrayOperationPartailInlineSize(default 32 bytes).\n+    \/\/ If ArrayOperationPartailInlineSize > 32 inlining is enabled\n+    \/\/ for all integral types (byte\/short\/char\/int), else for default\n+    \/\/ value inlining is enabled for subword types (byte\/short\/char).\n+    if (ArrayOperationPartailInlineSize > 32) {\n+      enable_pi = NULL != vec_type->isa_int();\n+    } else if (ArrayOperationPartailInlineSize) {\n+      enable_pi = is_subword_type(vec_basictype);\n@@ -5249,24 +5241,31 @@\n-    assert(fast_path && slow_path, \"\");\n-\n-    const TypeVect* vt = TypeVect::make(vec_basictype, vec_len);\n-    Node* mask_gen = _gvn.transform(new VectorMaskGenNode(ConvI2L(length), TypeVect::VECTMASK, vec_type));\n-\n-    const TypePtr* ptr_type_a = obja_adr->Value(&_gvn)->isa_ptr();\n-    const TypePtr* ptr_type_b = objb_adr->Value(&_gvn)->isa_ptr();\n-\n-    int alias_idx = C->get_alias_index(top_a);\n-    Node* mm = memory(alias_idx);\n-    Node* masked_load1 = _gvn.transform(new LoadVectorMaskedNode(fast_path, mm, obja_adr,\n-                                                                 ptr_type_a, vt, mask_gen));\n-    alias_idx = C->get_alias_index(top_b);\n-    mm = memory(alias_idx);\n-    Node* masked_load2 = _gvn.transform(new LoadVectorMaskedNode(fast_path, mm, objb_adr,\n-                                                                 ptr_type_b, vt, mask_gen));\n-\n-    Node* fastcomp_result = _gvn.transform(new VectorCmpMaskedNode(masked_load1, masked_load2,\n-                                                                   mask_gen, TypeInt::INT));\n-    if (!gen_slow_path) {\n-      set_result(fastcomp_result);\n-      C->set_max_vector_size(UsePartialInlineSize);\n-      clear_upper_avx();\n-      return true;\n+\n+    if (enable_pi &&\n+        Matcher::match_rule_supported_vector(Op_VectorMaskGen , vec_len, vec_basictype) &&\n+        Matcher::match_rule_supported_vector(Op_LoadVectorMasked , vec_len, vec_basictype) &&\n+        Matcher::match_rule_supported_vector(Op_VectorCmpMasked, vec_len, vec_basictype)) {\n+\n+      Node* length_in_bytes = _gvn.transform(new LShiftINode(length, scale));\n+      Node* pi_size = intcon(ArrayOperationPartailInlineSize);\n+      Node* length_cmp = _gvn.transform(new CmpINode(length_in_bytes, pi_size));\n+      Node* cmp_res = _gvn.transform(new BoolNode(length_cmp, BoolTest::le));\n+\n+      fast_path = generate_guard(cmp_res, NULL, PROB_MAX);\n+\n+      const TypeVect* vt = TypeVect::make(vec_basictype, vec_len);\n+      Node* mask_gen = _gvn.transform(new VectorMaskGenNode(ConvI2L(length), TypeVect::VECTMASK, vec_type));\n+\n+      const TypePtr* ptr_type_a = obja_adr->Value(&_gvn)->isa_ptr();\n+      const TypePtr* ptr_type_b = objb_adr->Value(&_gvn)->isa_ptr();\n+\n+      int alias_idx = C->get_alias_index(top_a);\n+      Node* mm = memory(alias_idx);\n+      Node* masked_load1 = _gvn.transform(new LoadVectorMaskedNode(fast_path, mm, obja_adr,\n+                                                                   ptr_type_a, vt, mask_gen));\n+      alias_idx = C->get_alias_index(top_b);\n+      mm = memory(alias_idx);\n+      Node* masked_load2 = _gvn.transform(new LoadVectorMaskedNode(fast_path, mm, objb_adr,\n+                                                                   ptr_type_b, vt, mask_gen));\n+\n+      fastcomp_result = _gvn.transform(new VectorCmpMaskedNode(masked_load1, masked_load2,\n+                                                               mask_gen, TypeInt::INT));\n+      C->set_max_vector_size(MAX2((uint)ArrayOperationPartailInlineSize, C->max_vector_size()));\n@@ -5274,0 +5273,1 @@\n+  }\n@@ -5275,1 +5275,1 @@\n-    Node* init_mem = map()->memory();\n+  if (!stopped()) {\n@@ -5277,3 +5277,3 @@\n-                             OptoRuntime::vectorizedMismatch_Type(),\n-                             stubAddr, stubName, TypePtr::BOTTOM,\n-                             obja_adr, objb_adr, length, scale);\n+                                   OptoRuntime::vectorizedMismatch_Type(),\n+                                   stubAddr, stubName, TypePtr::BOTTOM,\n+                                   obja_adr, objb_adr, length, scale);\n@@ -5298,1 +5298,0 @@\n-    C->set_max_vector_size(UsePartialInlineSize);\n@@ -5300,2 +5299,2 @@\n-    set_result(((RegionNode*)exit_block), ((PhiNode*)result));\n-    clear_upper_avx();\n+    set_control(exit_block);\n+    set_result(result);\n@@ -5303,7 +5302,2 @@\n-    Node* call = make_runtime_call(RC_LEAF,\n-                             OptoRuntime::vectorizedMismatch_Type(),\n-                             stubAddr, stubName, TypePtr::BOTTOM,\n-                             obja_adr, objb_adr, length, scale);\n-\n-    Node* call_result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));\n-    set_result(call_result);\n+    set_control(fast_path);\n+    set_result(fastcomp_result);\n@@ -5311,0 +5305,1 @@\n+  clear_upper_avx();\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":63,"deletions":68,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -177,2 +177,2 @@\n-\/\/ length(in bytes) less than UsePartialInlineSize.\n-\/\/  if (length <= UsePartialInlineSize) {\n+\/\/ length(in bytes) less than ArrayOperationPartailInlineSize.\n+\/\/  if (length <= ArrayOperationPartailInlineSize) {\n@@ -219,1 +219,1 @@\n-  if ( const_len > UsePartialInlineSize ||\n+  if ( const_len > ArrayOperationPartailInlineSize ||\n@@ -229,1 +229,1 @@\n-  Node* cmp_le = new CmpULNode(copy_bytes, longcon(UsePartialInlineSize));\n+  Node* cmp_le = new CmpULNode(copy_bytes, longcon(ArrayOperationPartailInlineSize));\n@@ -1190,1 +1190,1 @@\n-  if (UsePartialInlineSize > 0 && is_subword_type(basic_elem_type) &&\n+  if (ArrayOperationPartailInlineSize > 0 && is_subword_type(basic_elem_type) &&\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}