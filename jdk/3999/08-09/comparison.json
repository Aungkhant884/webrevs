{"files":[{"patch":"@@ -1926,1 +1926,1 @@\n-  assert(ArrayOperationPartialInlineSize <= 64,\"\");\n+  assert(ArrayOperationPartialInlineSize > 0 && ArrayOperationPartialInlineSize <= 64, \"invalid\");\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8057,0 +8057,3 @@\n+    assert(vector_length_encoding(this, $src1) == vector_length_encoding(this, $src2), \"mismatch\");\n+    assert(vector_element_basic_type(this, $src1) == vector_element_basic_type(this, $src2), \"mismatch\");\n+\n@@ -8058,5 +8061,3 @@\n-    const MachNode* src1_node = static_cast<const MachNode*>(this->in(this->operand_index($src1)));\n-    const MachNode* src2_node = static_cast<const MachNode*>(this->in(this->operand_index($src2)));\n-    assert(0 == Type::cmp(src1_node->bottom_type(), src2_node->bottom_type()), \"\");\n-    int vector_len = vector_length_encoding(src1_node);\n-    BasicType elmType =  src1_node->bottom_type()->is_vect()->element_basic_type();\n+    int vlen_enc = vector_length_encoding(this, $src1);\n+    BasicType elem_bt = vector_element_basic_type(this, $src1);\n+\n@@ -8065,1 +8066,1 @@\n-    __ evpcmp(elmType, $ktmp1$$KRegister, $mask$$KRegister, $src1$$XMMRegister, $src2$$XMMRegister, Assembler::eq, vector_len);\n+    __ evpcmp(elem_bt, $ktmp1$$KRegister, $mask$$KRegister, $src1$$XMMRegister, $src2$$XMMRegister, Assembler::eq, vlen_enc);\n@@ -8076,0 +8077,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-  product(intx, ArrayOperationPartialInlineSize, -1, DIAGNOSTIC,            \\\n+  product(intx, ArrayOperationPartialInlineSize, 0, DIAGNOSTIC,             \\\n@@ -88,1 +88,1 @@\n-          range(-1, 64)                                                     \\\n+          range(0, 64)                                                      \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,0 +81,5 @@\n+  CastIINode(Node* ctrl, Node* n, const Type* t, bool carry_dependency = false, bool range_check_dependency = false)\n+    : ConstraintCastNode(n, t, carry_dependency), _range_check_dependency(range_check_dependency) {\n+    init_class_id(Class_CastII);\n+    init_req(0, ctrl);\n+  }\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -5189,6 +5190,0 @@\n-  address stubAddr = StubRoutines::vectorizedMismatch();\n-  if (stubAddr == NULL) {\n-    return false; \/\/ Intrinsic's stub is not implemented on this platform\n-  }\n-  const char* stubName = \"vectorizedMismatch\";\n-  int size_l = callee()->signature()->size();\n@@ -5196,14 +5191,11 @@\n-\n-  Node* obja = argument(0);\n-  Node* aoffset = argument(1);\n-  Node* objb = argument(3);\n-  Node* boffset = argument(4);\n-  Node* length = argument(6);\n-  Node* scale = argument(7);\n-\n-  const Type* a_type = obja->Value(&_gvn);\n-  const Type* b_type = objb->Value(&_gvn);\n-  const TypeAryPtr* top_a = a_type->isa_aryptr();\n-  const TypeAryPtr* top_b = b_type->isa_aryptr();\n-  if (top_a == NULL || top_a->klass() == NULL ||\n-      top_b == NULL || top_b->klass() == NULL ||\n+  Node* obja    = argument(0); \/\/ Object\n+  Node* aoffset = argument(1); \/\/ long\n+  Node* objb    = argument(3); \/\/ Object\n+  Node* boffset = argument(4); \/\/ long\n+  Node* length  = argument(6); \/\/ int\n+  Node* scale   = argument(7); \/\/ int\n+\n+  const TypeAryPtr* obja_t = _gvn.type(obja)->isa_aryptr();\n+  const TypeAryPtr* objb_t = _gvn.type(objb)->isa_aryptr();\n+  if (obja_t == NULL || obja_t->klass() == NULL ||\n+      objb_t == NULL || objb_t->klass() == NULL ||\n@@ -5211,2 +5203,1 @@\n-    \/\/ failed array check\n-    return false;\n+    return false; \/\/ failed input validation\n@@ -5214,1 +5205,0 @@\n-  jvms()->set_should_reexecute(true);\n@@ -5219,24 +5209,24 @@\n-  bool enable_pi = false;\n-  Node* fast_path = top();\n-  Node* fastcomp_result = top();\n-  Node* init_mem = map()->memory();\n-\n-  assert(scale->bottom_type()->isa_int(), \"scale must be integer\");\n-  int scale_val = scale->bottom_type()->is_int()->is_con() ?\n-                  scale->bottom_type()->is_int()->get_con() :\n-                  -1;\n-  if (scale_val >= 0 && scale_val < 4) {\n-    BasicType prim_types[] = {T_BYTE, T_SHORT, T_INT, T_LONG};\n-    BasicType elem_bt = prim_types[scale_val];\n-    int vec_len = ArrayOperationPartialInlineSize \/ type2aelembytes(elem_bt);\n-\n-    \/\/ Enable partial in-lining if compare size is less than\n-    \/\/ ArrayOperationPartialInlineSize(default 32 bytes).\n-    \/\/ If ArrayOperationPartialInlineSize > 32 in-lining is enabled\n-    \/\/ for all integral types (byte\/short\/char\/int), else for default\n-    \/\/ value in-lining is enabled for sub-word types (byte\/short\/char).\n-    if (ArrayOperationPartialInlineSize > 32) {\n-      enable_pi = is_subword_type(elem_bt) || elem_bt == T_INT;\n-    } else if (ArrayOperationPartialInlineSize > 0) {\n-      enable_pi = is_subword_type(elem_bt);\n-    }\n+  \/\/ Partial inlining handling for inputs smaller than ArrayOperationPartialInlineSize bytes in size.\n+  \/\/\n+  \/\/    inline_limit = ArrayOperationPartialInlineSize \/ element_size;\n+  \/\/    if (length <= inline_limit) {\n+  \/\/      inline_path:\n+  \/\/        vmask   = VectorMaskGen length\n+  \/\/        vload1  = LoadVectorMasked obja, vmask\n+  \/\/        vload2  = LoadVectorMasked objb, vmask\n+  \/\/        result1 = VectorCmpMasked vload1, vload2, vmask\n+  \/\/    } else {\n+  \/\/      call_stub_path:\n+  \/\/        result2 = call vectorizedMismatch_stub(obja, objb, length, scale)\n+  \/\/    }\n+  \/\/    exit_block:\n+  \/\/      return Phi(result1, result2);\n+  \/\/\n+  enum { inline_path = 1,  \/\/ input is small enough to process it all at once\n+         stub_path   = 2,  \/\/ input is too large; call into the VM\n+         PATH_LIMIT  = 3\n+  };\n+\n+  Node* exit_block = new RegionNode(PATH_LIMIT);\n+  Node* result_phi = new PhiNode(exit_block, TypeInt::INT);\n+  Node* memory_phi = new PhiNode(exit_block, Type::MEMORY, TypePtr::BOTTOM);\n@@ -5244,35 +5234,13 @@\n-    if (enable_pi &&\n-        Matcher::match_rule_supported_vector(Op_VectorMaskGen , vec_len, elem_bt) &&\n-        Matcher::match_rule_supported_vector(Op_LoadVectorMasked , vec_len, elem_bt) &&\n-        Matcher::match_rule_supported_vector(Op_VectorCmpMasked, vec_len, elem_bt)) {\n-\n-      Node* length_in_bytes = _gvn.transform(new LShiftINode(length, scale));\n-      Node* pi_size = intcon(ArrayOperationPartialInlineSize);\n-      Node* length_cmp = _gvn.transform(new CmpINode(length_in_bytes, pi_size));\n-      Node* cmp_res = _gvn.transform(new BoolNode(length_cmp, BoolTest::le));\n-\n-      \/\/ When the cmp_res is evaluated to false then fast_path will be NULL\n-      \/\/ and only slow path exist (i.e. implicit control), so all the nodes control\n-      \/\/ dependent on fast path will be sweeped out during GVN. When cmp_res is\n-      \/\/ evaluated to true fast_path is chosen and slow_path (control()) is NULL and\n-      \/\/ thus before exit control is explicitly set to fast_path.\n-      fast_path = generate_guard(cmp_res, NULL, PROB_MAX);\n-\n-      const TypeVect* vt = TypeVect::make(elem_bt, vec_len);\n-      Node* mask_gen = _gvn.transform(new VectorMaskGenNode(ConvI2L(length), TypeVect::VECTMASK, elem_bt));\n-\n-      const TypePtr* ptr_type_a = obja_adr->Value(&_gvn)->isa_ptr();\n-      const TypePtr* ptr_type_b = objb_adr->Value(&_gvn)->isa_ptr();\n-\n-      int alias_idx = C->get_alias_index(top_a);\n-      Node* mm = memory(alias_idx);\n-      Node* masked_load1 = _gvn.transform(new LoadVectorMaskedNode(fast_path, mm, obja_adr,\n-                                                                   ptr_type_a, vt, mask_gen));\n-      alias_idx = C->get_alias_index(top_b);\n-      mm = memory(alias_idx);\n-      Node* masked_load2 = _gvn.transform(new LoadVectorMaskedNode(fast_path, mm, objb_adr,\n-                                                                   ptr_type_b, vt, mask_gen));\n-\n-      fastcomp_result = _gvn.transform(new VectorCmpMaskedNode(masked_load1, masked_load2,\n-                                                               mask_gen, TypeInt::INT));\n-      C->set_max_vector_size(MAX2((uint)ArrayOperationPartialInlineSize, C->max_vector_size()));\n+  Node* call_stub_path = control();\n+\n+  BasicType elem_bt = T_ILLEGAL;\n+\n+  const TypeInt* scale_t = _gvn.type(scale)->is_int();\n+  if (scale_t->is_con()) {\n+    switch (scale_t->get_con()) {\n+      case 0: elem_bt = T_BYTE;  break;\n+      case 1: elem_bt = T_SHORT; break;\n+      case 2: elem_bt = T_INT;   break;\n+      case 3: elem_bt = T_LONG;  break;\n+\n+      default: elem_bt = T_ILLEGAL; break; \/\/ not supported\n@@ -5282,6 +5250,6 @@\n-  if (stopped()) {\n-    \/\/ Slow path is dead.\n-    set_control(fast_path);\n-    set_result(fastcomp_result);\n-    clear_upper_avx();\n-    return true;\n+  int inline_limit = 0;\n+  bool do_partial_inline = false;\n+\n+  if (elem_bt != T_ILLEGAL && ArrayOperationPartialInlineSize > 0) {\n+    inline_limit = ArrayOperationPartialInlineSize \/ type2aelembytes(elem_bt);\n+    do_partial_inline = inline_limit >= 16;\n@@ -5290,5 +5258,2 @@\n-  \/\/ Proceed with expanding slow path.\n-  Node* call = make_runtime_call(RC_LEAF,\n-                                 OptoRuntime::vectorizedMismatch_Type(),\n-                                 stubAddr, stubName, TypePtr::BOTTOM,\n-                                 obja_adr, objb_adr, length, scale);\n+  if (do_partial_inline) {\n+    assert(elem_bt != T_ILLEGAL, \"sanity\");\n@@ -5296,2 +5261,1 @@\n-  Node* call_result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));\n-  Node* call_mem = map()->memory();\n+    const TypeVect* vt = TypeVect::make(elem_bt, inline_limit);\n@@ -5299,4 +5263,3 @@\n-  Node* exit_block = new RegionNode(3);\n-  exit_block->init_req(1, fast_path);\n-  exit_block->init_req(2, control());\n-  exit_block = _gvn.transform(exit_block);\n+    if (Matcher::match_rule_supported_vector(Op_VectorMaskGen,    inline_limit, elem_bt) &&\n+        Matcher::match_rule_supported_vector(Op_LoadVectorMasked, inline_limit, elem_bt) &&\n+        Matcher::match_rule_supported_vector(Op_VectorCmpMasked,  inline_limit, elem_bt)) {\n@@ -5304,4 +5267,28 @@\n-  Node* result = new PhiNode(exit_block, TypeInt::INT);\n-  result->init_req(1, fastcomp_result);\n-  result->init_req(2, call_result);\n-  result = _gvn.transform(result);\n+      Node* cmp_length = _gvn.transform(new CmpINode(length, intcon(inline_limit)));\n+      Node* bol_gt     = _gvn.transform(new BoolNode(cmp_length, BoolTest::gt));\n+\n+      call_stub_path = generate_guard(bol_gt, NULL, PROB_MIN);\n+\n+      if (!stopped()) {\n+        const TypePtr* obja_adr_t = _gvn.type(obja_adr)->isa_ptr();\n+        const TypePtr* objb_adr_t = _gvn.type(objb_adr)->isa_ptr();\n+        Node* obja_adr_mem = memory(C->get_alias_index(obja_adr_t));\n+        Node* objb_adr_mem = memory(C->get_alias_index(objb_adr_t));\n+\n+        Node* vmask      = _gvn.transform(new VectorMaskGenNode(ConvI2X(length), TypeVect::VECTMASK, elem_bt));\n+        Node* vload_obja = _gvn.transform(new LoadVectorMaskedNode(control(), obja_adr_mem, obja_adr, obja_adr_t, vt, vmask));\n+        Node* vload_objb = _gvn.transform(new LoadVectorMaskedNode(control(), objb_adr_mem, objb_adr, objb_adr_t, vt, vmask));\n+        Node* result     = _gvn.transform(new VectorCmpMaskedNode(vload_obja, vload_objb, vmask, TypeInt::INT));\n+\n+        exit_block->init_req(inline_path, control());\n+        memory_phi->init_req(inline_path, map()->memory());\n+        result_phi->init_req(inline_path, result);\n+\n+        C->set_max_vector_size(MAX2((uint)ArrayOperationPartialInlineSize, C->max_vector_size()));\n+        clear_upper_avx();\n+      }\n+    }\n+  }\n+\n+  if (call_stub_path != NULL) {\n+    set_control(call_stub_path);\n@@ -5309,3 +5296,13 @@\n-  Node* mem_phi = new PhiNode(exit_block, Type::MEMORY, TypePtr::BOTTOM);\n-  mem_phi->init_req(1, init_mem);\n-  mem_phi->init_req(2, call_mem);\n+    Node* call = make_runtime_call(RC_LEAF,\n+                                   OptoRuntime::vectorizedMismatch_Type(),\n+                                   StubRoutines::vectorizedMismatch(), \"vectorizedMismatch\", TypePtr::BOTTOM,\n+                                   obja_adr, objb_adr, length, scale);\n+\n+    exit_block->init_req(stub_path, control());\n+    memory_phi->init_req(stub_path, map()->memory());\n+    result_phi->init_req(stub_path, _gvn.transform(new ProjNode(call, TypeFunc::Parms)));\n+  }\n+\n+  exit_block = _gvn.transform(exit_block);\n+  memory_phi = _gvn.transform(memory_phi);\n+  result_phi = _gvn.transform(result_phi);\n@@ -5313,1 +5310,0 @@\n-  set_all_memory(_gvn.transform(mem_phi));\n@@ -5315,1 +5311,3 @@\n-  set_result(result);\n+  set_all_memory(memory_phi);\n+  set_result(result_phi);\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":106,"deletions":108,"binary":false,"changes":214,"status":"modified"},{"patch":"@@ -724,11 +724,13 @@\n-  Node* mask_len = in(3)->in(1);\n-  const TypeLong* ty = phase->type(mask_len)->isa_long();\n-  if (ty && ty->is_con()) {\n-    BasicType mask_bt = ((VectorMaskGenNode*)in(3))->get_elem_type();\n-    uint load_sz      = type2aelembytes(mask_bt) * ty->get_con();\n-    if ( load_sz == 32 || load_sz == 64) {\n-      assert(load_sz == 32 || MaxVectorSize > 32, \"Unexpected load size\");\n-      Node* ctr = in(MemNode::Control);\n-      Node* mem = in(MemNode::Memory);\n-      Node* adr = in(MemNode::Address);\n-      return phase->transform(new LoadVectorNode(ctr, mem, adr, adr_type(), vect_type()));\n+  if (!in(3)->is_top() && in(3)->Opcode() == Op_VectorMaskGen) {\n+    Node* mask_len = in(3)->in(1);\n+    const TypeLong* ty = phase->type(mask_len)->isa_long();\n+    if (ty && ty->is_con()) {\n+      BasicType mask_bt = ((VectorMaskGenNode*)in(3))->get_elem_type();\n+      uint load_sz      = type2aelembytes(mask_bt) * ty->get_con();\n+      if ( load_sz == 32 || load_sz == 64) {\n+        assert(load_sz == 32 || MaxVectorSize > 32, \"Unexpected load size\");\n+        Node* ctr = in(MemNode::Control);\n+        Node* mem = in(MemNode::Memory);\n+        Node* adr = in(MemNode::Address);\n+        return phase->transform(new LoadVectorNode(ctr, mem, adr, adr_type(), vect_type()));\n+      }\n@@ -741,12 +743,14 @@\n-  Node* mask_len = in(4)->in(1);\n-  const TypeLong* ty = phase->type(mask_len)->isa_long();\n-  if (ty && ty->is_con()) {\n-    BasicType mask_bt = ((VectorMaskGenNode*)in(4))->get_elem_type();\n-    uint load_sz      = type2aelembytes(mask_bt) * ty->get_con();\n-    if ( load_sz == 32 || load_sz == 64) {\n-      assert(load_sz == 32 || MaxVectorSize > 32, \"Unexpected store size\");\n-      Node* ctr = in(MemNode::Control);\n-      Node* mem = in(MemNode::Memory);\n-      Node* adr = in(MemNode::Address);\n-      Node* val = in(MemNode::ValueIn);\n-      return phase->transform(new StoreVectorNode(ctr, mem, adr, adr_type(), val));\n+  if (!in(4)->is_top() && in(4)->Opcode() == Op_VectorMaskGen) {\n+    Node* mask_len = in(4)->in(1);\n+    const TypeLong* ty = phase->type(mask_len)->isa_long();\n+    if (ty && ty->is_con()) {\n+      BasicType mask_bt = ((VectorMaskGenNode*)in(4))->get_elem_type();\n+      uint load_sz      = type2aelembytes(mask_bt) * ty->get_con();\n+      if ( load_sz == 32 || load_sz == 64) {\n+        assert(load_sz == 32 || MaxVectorSize > 32, \"Unexpected store size\");\n+        Node* ctr = in(MemNode::Control);\n+        Node* mem = in(MemNode::Memory);\n+        Node* adr = in(MemNode::Address);\n+        Node* val = in(MemNode::ValueIn);\n+        return phase->transform(new StoreVectorNode(ctr, mem, adr, adr_type(), val));\n+      }\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":27,"deletions":23,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:UsePartialInlineSize=0 -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=0 -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOptions\n@@ -36,1 +36,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:UsePartialInlineSize=0 -XX:MaxVectorSize=64\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=0 -XX:MaxVectorSize=64\n@@ -39,1 +39,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:UsePartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOption\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOption\n@@ -42,1 +42,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:UsePartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=64\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=64\n@@ -45,1 +45,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:UsePartialInlineSize=64 -XX:MaxVectorSize=64\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=64 -XX:MaxVectorSize=64\n@@ -48,1 +48,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:UsePartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOption -XX:ArrayCopyLoadStoreMaxElem=16\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOption -XX:ArrayCopyLoadStoreMaxElem=16\n@@ -51,1 +51,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:UsePartialInlineSize=64 -XX:MaxVectorSize=64 -XX:ArrayCopyLoadStoreMaxElem=16\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=64 -XX:MaxVectorSize=64 -XX:ArrayCopyLoadStoreMaxElem=16\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestArrayCopyConjoint.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:UsePartialInlineSize=0 -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=0 -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOptions\n@@ -36,1 +36,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:UsePartialInlineSize=0 -XX:MaxVectorSize=64\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=0 -XX:MaxVectorSize=64\n@@ -39,1 +39,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:UsePartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOption\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOption\n@@ -42,1 +42,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:UsePartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=64\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=64\n@@ -45,1 +45,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:UsePartialInlineSize=64 -XX:MaxVectorSize=64\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=64 -XX:MaxVectorSize=64\n@@ -48,1 +48,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:UsePartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOption -XX:ArrayCopyLoadStoreMaxElem=16\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOption -XX:ArrayCopyLoadStoreMaxElem=16\n@@ -51,1 +51,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:UsePartialInlineSize=64 -XX:MaxVectorSize=64 -XX:ArrayCopyLoadStoreMaxElem=16\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=64 -XX:MaxVectorSize=64 -XX:ArrayCopyLoadStoreMaxElem=16\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestArrayCopyDisjoint.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,288 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.intrinsics;\n+\n+\/*\n+ * @test\n+ * @requires vm.opt.final.UseVectorizedMismatchIntrinsic == true\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.base\/jdk.internal.util\n+ *\n+ *  @run main\/othervm -XX:CompileCommand=quiet -XX:CompileCommand=compileonly,*::test*\n+ *                    -Xbatch -XX:-TieredCompilation\n+ *                    -XX:UseAVX=3\n+ *                     compiler.intrinsics.VectorizedMismatchTest\n+ *\n+ *  @run main\/othervm -XX:CompileCommand=quiet -XX:CompileCommand=compileonly,*::test*\n+ *                    -Xbatch -XX:-TieredCompilation\n+ *                    -XX:UseAVX=3 -XX:AVX3Threshold=0\n+ *                     compiler.intrinsics.VectorizedMismatchTest\n+ *\/\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.util.ArraysSupport;\n+\n+public class VectorizedMismatchTest {\n+    private boolean[] boolean_a = new boolean[128];\n+    private boolean[] boolean_b = new boolean[128];\n+\n+    int testBooleanConstantLength(int length) {\n+        boolean[] obja = boolean_a;\n+        boolean[] objb = boolean_b;\n+        long offset = Unsafe.ARRAY_BOOLEAN_BASE_OFFSET;\n+        int scale = ArraysSupport.LOG2_ARRAY_BOOLEAN_INDEX_SCALE;\n+        return ArraysSupport.vectorizedMismatch(obja, offset, objb, offset, length, scale);\n+    }\n+\n+    int testBooleanConstantLength0()   { return testBooleanConstantLength(0);   }\n+    int testBooleanConstantLength1()   { return testBooleanConstantLength(1);   }\n+    int testBooleanConstantLength64()  { return testBooleanConstantLength(64);  }\n+    int testBooleanConstantLength128() { return testBooleanConstantLength(128); }\n+\n+    \/* ==================================================================================== *\/\n+\n+    private byte[] byte_a = new byte[128];\n+    private byte[] byte_b = new byte[128];\n+\n+    int testByteConstantLength(int length) {\n+        byte[] obja = byte_a;\n+        byte[] objb = byte_b;\n+        long offset = Unsafe.ARRAY_BYTE_BASE_OFFSET;\n+        int scale = ArraysSupport.LOG2_ARRAY_BYTE_INDEX_SCALE;\n+        return ArraysSupport.vectorizedMismatch(obja, offset, objb, offset, length, scale);\n+    }\n+\n+    int testByteConstantLength0()   { return testByteConstantLength(0);   }\n+    int testByteConstantLength1()   { return testByteConstantLength(1);   }\n+    int testByteConstantLength64()  { return testByteConstantLength(64);  }\n+    int testByteConstantLength128() { return testByteConstantLength(128); }\n+\n+    \/* ==================================================================================== *\/\n+\n+    private short[] short_a = new short[64];\n+    private short[] short_b = new short[64];\n+\n+    int testShortConstantLength(int length) {\n+        short[] obja = short_a;\n+        short[] objb = short_b;\n+        long offset = Unsafe.ARRAY_SHORT_BASE_OFFSET;\n+        int scale = ArraysSupport.LOG2_ARRAY_SHORT_INDEX_SCALE;\n+        return ArraysSupport.vectorizedMismatch(obja, offset, objb, offset, length, scale);\n+    }\n+\n+    int testShortConstantLength0()  { return testShortConstantLength(0);  }\n+    int testShortConstantLength1()  { return testShortConstantLength(1);  }\n+    int testShortConstantLength32() { return testShortConstantLength(32); }\n+    int testShortConstantLength64() { return testShortConstantLength(64); }\n+\n+    \/* ==================================================================================== *\/\n+\n+    private char[] char_a = new char[64];\n+    private char[] char_b = new char[64];\n+\n+    int testCharConstantLength(int length) {\n+        char[] obja = char_a;\n+        char[] objb = char_b;\n+        long offset = Unsafe.ARRAY_CHAR_BASE_OFFSET;\n+        int scale = ArraysSupport.LOG2_ARRAY_CHAR_INDEX_SCALE;\n+        return ArraysSupport.vectorizedMismatch(obja, offset, objb, offset, length, scale);\n+    }\n+\n+    int testCharConstantLength0()  { return testCharConstantLength(0);  }\n+    int testCharConstantLength1()  { return testCharConstantLength(1);  }\n+    int testCharConstantLength32() { return testCharConstantLength(32); }\n+    int testCharConstantLength64() { return testCharConstantLength(64); }\n+\n+    \/* ==================================================================================== *\/\n+\n+    private int[] int_a = new int[32];\n+    private int[] int_b = new int[32];\n+\n+    int testIntConstantLength(int length) {\n+        int[] obja = int_a;\n+        int[] objb = int_b;\n+        long offset = Unsafe.ARRAY_INT_BASE_OFFSET;\n+        int scale = ArraysSupport.LOG2_ARRAY_INT_INDEX_SCALE;\n+        return ArraysSupport.vectorizedMismatch(obja, offset, objb, offset, length, scale);\n+    }\n+\n+    int testIntConstantLength0()  { return testIntConstantLength(0);  }\n+    int testIntConstantLength1()  { return testIntConstantLength(1);  }\n+    int testIntConstantLength16() { return testIntConstantLength(16); }\n+    int testIntConstantLength32() { return testIntConstantLength(32); }\n+\n+    \/* ==================================================================================== *\/\n+\n+    private float[] float_a = new float[32];\n+    private float[] float_b = new float[32];\n+\n+    int testFloatConstantLength(int length) {\n+        float[] obja = float_a;\n+        float[] objb = float_b;\n+        long offset = Unsafe.ARRAY_FLOAT_BASE_OFFSET;\n+        int scale = ArraysSupport.LOG2_ARRAY_FLOAT_INDEX_SCALE;\n+        return ArraysSupport.vectorizedMismatch(obja, offset, objb, offset, length, scale);\n+    }\n+\n+    int testFloatConstantLength0()  { return testFloatConstantLength(0);  }\n+    int testFloatConstantLength1()  { return testFloatConstantLength(1);  }\n+    int testFloatConstantLength16() { return testFloatConstantLength(16); }\n+    int testFloatConstantLength32() { return testFloatConstantLength(32); }\n+\n+    \/* ==================================================================================== *\/\n+\n+    private long[] long_a = new long[16];\n+    private long[] long_b = new long[16];\n+\n+    int testLongConstantLength(int length) {\n+        long[] obja = long_a;\n+        long[] objb = long_b;\n+        long offset = Unsafe.ARRAY_LONG_BASE_OFFSET;\n+        int scale = ArraysSupport.LOG2_ARRAY_LONG_INDEX_SCALE;\n+        return ArraysSupport.vectorizedMismatch(obja, offset, objb, offset, length, scale);\n+    }\n+\n+    int testLongConstantLength0()  { return testLongConstantLength(0);  }\n+    int testLongConstantLength1()  { return testLongConstantLength(1);  }\n+    int testLongConstantLength8()  { return testLongConstantLength(8);  }\n+    int testLongConstantLength16() { return testLongConstantLength(16); }\n+\n+    \/* ==================================================================================== *\/\n+\n+    private double[] double_a = new double[16];\n+    private double[] double_b = new double[16];\n+\n+    int testDoubleConstantLength(int length) {\n+        double[] obja = double_a;\n+        double[] objb = double_b;\n+        long offset = Unsafe.ARRAY_DOUBLE_BASE_OFFSET;\n+        int  scale  = ArraysSupport.LOG2_ARRAY_DOUBLE_INDEX_SCALE;\n+        return ArraysSupport.vectorizedMismatch(obja, offset, objb, offset, length, scale);\n+    }\n+\n+    int testDoubleConstantLength0()  { return testDoubleConstantLength(0);  }\n+    int testDoubleConstantLength1()  { return testDoubleConstantLength(1);  }\n+    int testDoubleConstantLength8()  { return testDoubleConstantLength(8);  }\n+    int testDoubleConstantLength16() { return testDoubleConstantLength(16); }\n+\n+    \/* ==================================================================================== *\/\n+\n+    static class ClassInitTest {\n+        static final int LENGTH = 64;\n+        static final int RESULT;\n+        static {\n+            byte[] arr1 = new byte[LENGTH];\n+            byte[] arr2 = new byte[LENGTH];\n+            for (int i = 0; i < 20_000; i++) {\n+                test(arr1, arr2);\n+            }\n+            RESULT = test(arr1, arr2);\n+        }\n+\n+        static int test(byte[] obja, byte[] objb) {\n+            long offset = Unsafe.ARRAY_BYTE_BASE_OFFSET;\n+            int  scale  = ArraysSupport.LOG2_ARRAY_BYTE_INDEX_SCALE;\n+            return ArraysSupport.vectorizedMismatch(obja, offset, objb, offset, LENGTH, scale); \/\/ LENGTH is not considered a constant\n+        }\n+    }\n+\n+    int testConstantBeingInitialized() {\n+        return ClassInitTest.RESULT; \/\/ trigger class initialization\n+    }\n+\n+    \/* ==================================================================================== *\/\n+\n+    int testLoopUnswitch(int length) {\n+        long offset = Unsafe.ARRAY_BYTE_BASE_OFFSET;\n+        int  scale  = ArraysSupport.LOG2_ARRAY_BYTE_INDEX_SCALE;\n+\n+        int acc = 0;\n+        for (int i = 0; i < 32; i++) {\n+            acc += ArraysSupport.vectorizedMismatch(byte_a, offset, byte_b, offset, length, scale);\n+        }\n+        return acc;\n+    }\n+\n+    int testLoopHoist(int length, int stride) {\n+        long offset = Unsafe.ARRAY_BYTE_BASE_OFFSET;\n+        int  scale  = ArraysSupport.LOG2_ARRAY_BYTE_INDEX_SCALE;\n+\n+        int acc = 0;\n+\n+        for (int i = 0; i < 32; i += stride) {\n+            acc += ArraysSupport.vectorizedMismatch(byte_a, offset, byte_b, offset, length, scale);\n+        }\n+        return acc;\n+    }\n+\n+    \/* ==================================================================================== *\/\n+\n+    public static void main(String[] args) {\n+        VectorizedMismatchTest t = new VectorizedMismatchTest();\n+        for (int i = 0; i < 20_000; i++) {\n+            t.testBooleanConstantLength0();\n+            t.testBooleanConstantLength1();\n+            t.testBooleanConstantLength64();\n+            t.testBooleanConstantLength128();\n+\n+            t.testByteConstantLength0();\n+            t.testByteConstantLength1();\n+            t.testByteConstantLength64();\n+            t.testByteConstantLength128();\n+\n+            t.testShortConstantLength0();\n+            t.testShortConstantLength1();\n+            t.testShortConstantLength32();\n+            t.testShortConstantLength64();\n+\n+            t.testCharConstantLength0();\n+            t.testCharConstantLength1();\n+            t.testCharConstantLength32();\n+            t.testCharConstantLength64();\n+\n+            t.testIntConstantLength0();\n+            t.testIntConstantLength1();\n+            t.testIntConstantLength16();\n+            t.testIntConstantLength32();\n+\n+            t.testFloatConstantLength0();\n+            t.testFloatConstantLength1();\n+            t.testFloatConstantLength16();\n+            t.testFloatConstantLength32();\n+\n+            t.testLongConstantLength0();\n+            t.testLongConstantLength1();\n+            t.testLongConstantLength8();\n+            t.testLongConstantLength16();\n+\n+            t.testDoubleConstantLength0();\n+            t.testDoubleConstantLength1();\n+            t.testDoubleConstantLength8();\n+            t.testDoubleConstantLength16();\n+\n+            t.testLoopUnswitch(32);\n+            t.testLoopHoist(128, 2);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/VectorizedMismatchTest.java","additions":288,"deletions":0,"binary":false,"changes":288,"status":"added"},{"patch":"@@ -314,0 +314,1 @@\n+        vmOptFinalFlag(map, \"UseVectorizedMismatchIntrinsic\");\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}