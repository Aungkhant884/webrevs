{"files":[{"patch":"@@ -2575,0 +2575,7 @@\n+void Assembler::knotql(KRegister dst, KRegister src) {\n+  assert(VM_Version::supports_avx512bw(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x44, (0xC0 | encode));\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1483,0 +1483,1 @@\n+  void knotql(KRegister dst, KRegister src);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1926,1 +1926,1 @@\n-  assert(ArrayCopyPartialInlineSize <= 64,\"\");\n+  assert(UsePartialInlineSize <= 64,\"\");\n@@ -2143,0 +2143,24 @@\n+void C2_MacroAssembler::evpcmp(BasicType typ, KRegister kdmask, KRegister ksmask, XMMRegister src1, XMMRegister src2, int comparison, int vector_len) {\n+  switch(typ) {\n+    case T_BYTE:\n+    case T_BOOLEAN:\n+      evpcmpb(kdmask, ksmask, src1, src2, comparison, vector_len);\n+      break;\n+    case T_SHORT:\n+    case T_CHAR:\n+      evpcmpw(kdmask, ksmask, src1, src2, comparison, vector_len);\n+      break;\n+    case T_INT:\n+    case T_FLOAT:\n+      evpcmpd(kdmask, ksmask, src1, src2, comparison, vector_len);\n+      break;\n+    case T_LONG:\n+    case T_DOUBLE:\n+      evpcmpq(kdmask, ksmask, src1, src2, comparison, vector_len);\n+      break;\n+    default:\n+      assert(false,\"Should not reach here.\");\n+      break;\n+  }\n+}\n+\n@@ -2145,0 +2169,1 @@\n+    case T_BOOLEAN:\n@@ -2148,0 +2173,1 @@\n+    case T_CHAR:\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -142,0 +142,1 @@\n+  void evpcmp(BasicType typ, KRegister kdmask, KRegister ksmask, XMMRegister src1, XMMRegister src2, int comparison, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1409,6 +1409,6 @@\n-      if (FLAG_IS_DEFAULT(ArrayCopyPartialInlineSize) ||\n-          (!FLAG_IS_DEFAULT(ArrayCopyPartialInlineSize) &&\n-           ArrayCopyPartialInlineSize != 0 &&\n-           ArrayCopyPartialInlineSize != 32 &&\n-           ArrayCopyPartialInlineSize != 16 &&\n-           ArrayCopyPartialInlineSize != 64)) {\n+      if (FLAG_IS_DEFAULT(UsePartialInlineSize) ||\n+          (!FLAG_IS_DEFAULT(UsePartialInlineSize) &&\n+           UsePartialInlineSize != 0 &&\n+           UsePartialInlineSize != 32 &&\n+           UsePartialInlineSize != 16 &&\n+           UsePartialInlineSize != 64)) {\n@@ -1423,2 +1423,2 @@\n-        if(!FLAG_IS_DEFAULT(ArrayCopyPartialInlineSize)) {\n-          warning(\"Setting ArrayCopyPartialInlineSize as %d\", inline_size);\n+        if(!FLAG_IS_DEFAULT(UsePartialInlineSize)) {\n+          warning(\"Setting UsePartialInlineSize as %d\", inline_size);\n@@ -1426,1 +1426,1 @@\n-        ArrayCopyPartialInlineSize = inline_size;\n+        UsePartialInlineSize = inline_size;\n@@ -1429,4 +1429,4 @@\n-      if (ArrayCopyPartialInlineSize > MaxVectorSize) {\n-        ArrayCopyPartialInlineSize = MaxVectorSize >= 16 ? MaxVectorSize : 0;\n-        if (ArrayCopyPartialInlineSize) {\n-          warning(\"Setting ArrayCopyPartialInlineSize as MaxVectorSize\" INTX_FORMAT \")\", MaxVectorSize);\n+      if (UsePartialInlineSize > MaxVectorSize) {\n+        UsePartialInlineSize = MaxVectorSize >= 16 ? MaxVectorSize : 0;\n+        if (UsePartialInlineSize) {\n+          warning(\"Setting UsePartialInlineSize as MaxVectorSize\" INTX_FORMAT \")\", MaxVectorSize);\n@@ -1434,1 +1434,1 @@\n-          warning(\"Setting ArrayCopyPartialInlineSize as \" INTX_FORMAT, ArrayCopyPartialInlineSize);\n+          warning(\"Setting UsePartialInlineSize as \" INTX_FORMAT, UsePartialInlineSize);\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1577,0 +1577,1 @@\n+    case Op_VectorCmpMasked:\n@@ -8048,1 +8049,26 @@\n-\/\/ ---------------------------------- Masked Block Copy ------------------------------------\n+\/\/ ---------------------------------- Masked Operations ------------------------------------\n+\n+instruct vmask_cmp_node(rRegI dst, vec src1, vec src2, kReg mask, kReg ktmp1, kReg ktmp2, rFlagsReg cr) %{\n+  match(Set dst (VectorCmpMasked src1 (Binary src2 mask)));\n+  effect(TEMP_DEF dst, TEMP ktmp1, TEMP ktmp2, KILL cr);\n+  format %{ \"vector_mask_cmp $src1, $src2, $mask \\t! vector mask comparison\" %}\n+  ins_encode %{\n+    Label DONE;\n+    const MachNode* src1_node = static_cast<const MachNode*>(this->in(this->operand_index($src1)));\n+    const MachNode* src2_node = static_cast<const MachNode*>(this->in(this->operand_index($src2)));\n+    assert(0 == Type::cmp(src1_node->bottom_type(), src2_node->bottom_type()), \"\");\n+    int vector_len = vector_length_encoding(src1_node);\n+    BasicType elmType =  src1_node->bottom_type()->is_vect()->element_basic_type();\n+    __ knotql($ktmp2$$KRegister, $mask$$KRegister);\n+    __ mov64($dst$$Register, -1L);\n+    __ evpcmp(elmType, $ktmp1$$KRegister, $mask$$KRegister, $src1$$XMMRegister, $src2$$XMMRegister, Assembler::eq, vector_len);\n+    __ kortestql($ktmp2$$KRegister, $ktmp1$$KRegister);\n+    __ jccb(Assembler::carrySet, DONE);\n+    __ kmovql($dst$$Register, $ktmp1$$KRegister);\n+    __ notq($dst$$Register);\n+    __ tzcntq($dst$$Register, $dst$$Register);\n+    __ bind(DONE);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -785,0 +785,1 @@\n+       !strcmp(_matrule->_rChild->_opType,\"VectorCmpMasked\")||\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -741,1 +741,1 @@\n-  int lane_count = ArrayCopyPartialInlineSize\/type2aelembytes(type);\n+  int lane_count = UsePartialInlineSize\/type2aelembytes(type);\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-  product(intx, ArrayCopyPartialInlineSize, -1, DIAGNOSTIC,                 \\\n+  product(intx, UsePartialInlineSize, -1, DIAGNOSTIC,                       \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -416,0 +416,1 @@\n+macro(VectorCmpMasked)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3412,0 +3412,1 @@\n+  case Op_VectorCmpMasked:\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -5209,1 +5209,1 @@\n-    top_b == NULL || top_b->klass() == NULL) {\n+      top_b == NULL || top_b->klass() == NULL) {\n@@ -5213,2 +5213,0 @@\n-\n-  Node* call;\n@@ -5220,4 +5218,56 @@\n-  call = make_runtime_call(RC_LEAF,\n-    OptoRuntime::vectorizedMismatch_Type(),\n-    stubAddr, stubName, TypePtr::BOTTOM,\n-    obja_adr, objb_adr, length, scale);\n+  assert(scale->bottom_type()->isa_int() &&\n+         scale->bottom_type()->is_int()->is_con(),\n+         \"non-constant scale value\");\n+\n+  int scale_val = scale->bottom_type()->is_int()->get_con();\n+  BasicType prim_types[] = {T_BYTE, T_SHORT, T_INT, T_LONG};\n+  BasicType vec_basictype = prim_types[scale_val];\n+  const Type* vec_type = Type::get_const_basic_type(vec_basictype);\n+  int vec_len = UsePartialInlineSize \/ type2aelembytes(vec_basictype);\n+\n+  Node* length_in_bytes = _gvn.transform(new LShiftINode(length, scale));\n+  Node* length_cmp = _gvn.transform(new CmpINode(length_in_bytes, intcon(UsePartialInlineSize)));\n+  Node* cmp_res = _gvn.transform(new BoolNode(length_cmp, BoolTest::le));\n+\n+  \/\/ Enable partial in-lining if compare size is less than UsePartialInlineSize(default 32 bytes).\n+  bool enable_pi = (UsePartialInlineSize > 32) ? (NULL != vec_type->isa_int())\n+                                               : is_subword_type(vec_basictype);\n+  if (enable_pi && Type::cmp(TypeInt::ZERO, cmp_res->bottom_type()) &&\n+      (Matcher::match_rule_supported_vector(Op_VectorMaskGen , vec_len, vec_basictype) &&\n+       Matcher::match_rule_supported_vector(Op_LoadVectorMasked , vec_len, vec_basictype) &&\n+       Matcher::match_rule_supported_vector(Op_VectorCmpMasked, vec_len, vec_basictype))) {\n+\n+    Node* fast_path = NULL;\n+    Node* slow_path = NULL;\n+    bool gen_slow_path = Type::cmp(TypeInt::ONE, cmp_res->bottom_type());\n+    if (gen_slow_path) {\n+      fast_path = generate_guard(cmp_res, NULL, PROB_MAX);\n+      slow_path = control();\n+    } else {\n+      fast_path = slow_path = control();\n+    }\n+    assert(fast_path && slow_path, \"\");\n+\n+    const TypeVect* vt = TypeVect::make(vec_basictype, vec_len);\n+    Node* mask_gen = _gvn.transform(new VectorMaskGenNode(ConvI2L(length), TypeVect::VECTMASK, vec_type));\n+\n+    const TypePtr* ptr_type_a = obja_adr->Value(&_gvn)->isa_ptr();\n+    const TypePtr* ptr_type_b = objb_adr->Value(&_gvn)->isa_ptr();\n+\n+    int alias_idx = C->get_alias_index(top_a);\n+    Node* mm = memory(alias_idx);\n+    Node* masked_load1 = _gvn.transform(new LoadVectorMaskedNode(fast_path, mm, obja_adr,\n+                                                                 ptr_type_a, vt, mask_gen));\n+    alias_idx = C->get_alias_index(top_b);\n+    mm = memory(alias_idx);\n+    Node* masked_load2 = _gvn.transform(new LoadVectorMaskedNode(fast_path, mm, objb_adr,\n+                                                                 ptr_type_b, vt, mask_gen));\n+\n+    Node* fastcomp_result = _gvn.transform(new VectorCmpMaskedNode(masked_load1, masked_load2,\n+                                                                   mask_gen, TypeInt::INT));\n+    if (!gen_slow_path) {\n+      set_result(fastcomp_result);\n+      C->set_max_vector_size(UsePartialInlineSize);\n+      clear_upper_avx();\n+      return true;\n+    }\n@@ -5225,2 +5275,36 @@\n-  Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));\n-  set_result(result);\n+    Node* init_mem = map()->memory();\n+    Node* call = make_runtime_call(RC_LEAF,\n+                             OptoRuntime::vectorizedMismatch_Type(),\n+                             stubAddr, stubName, TypePtr::BOTTOM,\n+                             obja_adr, objb_adr, length, scale);\n+\n+    Node* call_result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));\n+    Node* call_mem = map()->memory();\n+\n+    Node* exit_block = new RegionNode(3);\n+    exit_block->init_req(1, fast_path);\n+    exit_block->init_req(2, control());\n+    exit_block = _gvn.transform(exit_block);\n+\n+    Node* result = new PhiNode(exit_block, TypeInt::INT);\n+    result->init_req(1, fastcomp_result);\n+    result->init_req(2, call_result);\n+    result = _gvn.transform(result);\n+\n+    Node* mem_phi = new PhiNode(exit_block, Type::MEMORY, TypePtr::BOTTOM);\n+    mem_phi->init_req(1, init_mem);\n+    mem_phi->init_req(2, call_mem);\n+\n+    C->set_max_vector_size(UsePartialInlineSize);\n+    set_all_memory(_gvn.transform(mem_phi));\n+    set_result(((RegionNode*)exit_block), ((PhiNode*)result));\n+    clear_upper_avx();\n+  } else {\n+    Node* call = make_runtime_call(RC_LEAF,\n+                             OptoRuntime::vectorizedMismatch_Type(),\n+                             stubAddr, stubName, TypePtr::BOTTOM,\n+                             obja_adr, objb_adr, length, scale);\n+\n+    Node* call_result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));\n+    set_result(call_result);\n+  }\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":93,"deletions":9,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -177,2 +177,2 @@\n-\/\/ length(in bytes) less than ArrayCopyPartialInlineSize.\n-\/\/  if (length <= ArrayCopyPartialInlineSize) {\n+\/\/ length(in bytes) less than UsePartialInlineSize.\n+\/\/  if (length <= UsePartialInlineSize) {\n@@ -219,1 +219,1 @@\n-  if ( const_len > ArrayCopyPartialInlineSize ||\n+  if ( const_len > UsePartialInlineSize ||\n@@ -229,1 +229,1 @@\n-  Node* cmp_le = new CmpULNode(copy_bytes, longcon(ArrayCopyPartialInlineSize));\n+  Node* cmp_le = new CmpULNode(copy_bytes, longcon(UsePartialInlineSize));\n@@ -1190,1 +1190,1 @@\n-  if (ArrayCopyPartialInlineSize > 0 && is_subword_type(basic_elem_type) &&\n+  if (UsePartialInlineSize > 0 && is_subword_type(basic_elem_type) &&\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2219,0 +2219,1 @@\n+    case Op_VectorCmpMasked:\n@@ -2312,0 +2313,6 @@\n+    case Op_VectorCmpMasked: {\n+      Node* pair1 = new BinaryNode(n->in(2), n->in(3));\n+      n->set_req(2, pair1);\n+      n->del_req(3);\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -839,0 +839,12 @@\n+class VectorCmpMaskedNode : public TypeNode {\n+  public:\n+   VectorCmpMaskedNode(Node* src1, Node* src2, Node* mask, const Type* ty): TypeNode(ty, 4)  {\n+     init_req(1, src1);\n+     init_req(2, src2);\n+     init_req(3, mask);\n+   }\n+\n+  virtual int Opcode() const;\n+};\n+\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=0 -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:UsePartialInlineSize=0 -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOptions\n@@ -36,1 +36,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=0 -XX:MaxVectorSize=64\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:UsePartialInlineSize=0 -XX:MaxVectorSize=64\n@@ -39,1 +39,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOption\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:UsePartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOption\n@@ -42,1 +42,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=64\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:UsePartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=64\n@@ -45,1 +45,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=64 -XX:MaxVectorSize=64\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:UsePartialInlineSize=64 -XX:MaxVectorSize=64\n@@ -48,1 +48,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOption -XX:ArrayCopyLoadStoreMaxElem=16\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:UsePartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOption -XX:ArrayCopyLoadStoreMaxElem=16\n@@ -51,1 +51,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=64 -XX:MaxVectorSize=64 -XX:ArrayCopyLoadStoreMaxElem=16\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:UsePartialInlineSize=64 -XX:MaxVectorSize=64 -XX:ArrayCopyLoadStoreMaxElem=16\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestArrayCopyConjoint.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=0 -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:UsePartialInlineSize=0 -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOptions\n@@ -36,1 +36,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=0 -XX:MaxVectorSize=64\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:UsePartialInlineSize=0 -XX:MaxVectorSize=64\n@@ -39,1 +39,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOption\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:UsePartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOption\n@@ -42,1 +42,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=64\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:UsePartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=64\n@@ -45,1 +45,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=64 -XX:MaxVectorSize=64\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:UsePartialInlineSize=64 -XX:MaxVectorSize=64\n@@ -48,1 +48,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOption -XX:ArrayCopyLoadStoreMaxElem=16\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:UsePartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOption -XX:ArrayCopyLoadStoreMaxElem=16\n@@ -51,1 +51,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=64 -XX:MaxVectorSize=64 -XX:ArrayCopyLoadStoreMaxElem=16\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:UsePartialInlineSize=64 -XX:MaxVectorSize=64 -XX:ArrayCopyLoadStoreMaxElem=16\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestArrayCopyDisjoint.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -45,2 +45,2 @@\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n@@ -50,1 +50,1 @@\n-    @Param({\"90\", \"800\"})\n+    @Param({\"16\", \"32\", \"64\", \"90\", \"800\"})\n@@ -65,2 +65,2 @@\n-        rightStartRange = size \/ 4 + 10;\n-        rightEndRange = size - size \/ 4 + 10;\n+        rightStartRange = size \/ 4 + 1;\n+        rightEndRange = size - size \/ 4 + 1;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/ArraysMismatch.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+public class ArraysMismatchPartialInlining {\n+\n+    @Param({\"3\", \"4\", \"5\", \"6\", \"7\", \"15\", \"31\", \"63\", \"95\", \"800\"})\n+    private static int size;\n+\n+    byte [] barray1;\n+    char [] carray1;\n+    short [] sarray1;\n+    int [] iarray1;\n+    long [] larray1;\n+    float [] farray1;\n+    double [] darray1;\n+\n+    byte [] barray2;\n+    char [] carray2;\n+    short [] sarray2;\n+    int [] iarray2;\n+    long [] larray2;\n+    float [] farray2;\n+    double [] darray2;\n+\n+    @Setup\n+    public void setup() {\n+      barray1 = new byte[size];\n+      carray1 = new char[size];\n+      sarray1 = new short[size];\n+      iarray1 = new int[size];\n+      larray1 = new long[size];\n+      farray1 = new float[size];\n+      darray1 = new double[size];\n+\n+      barray2 = new byte[size];\n+      carray2 = new char[size];\n+      sarray2 = new short[size];\n+      iarray2 = new int[size];\n+      larray2 = new long[size];\n+      farray2 = new float[size];\n+      darray2 = new double[size];\n+\n+      Arrays.fill(barray1 , (byte)0xF);\n+      Arrays.fill(carray1 , (char)0xFF);\n+      Arrays.fill(sarray1 , (short)0xFF);\n+      Arrays.fill(iarray1 , -1);\n+      Arrays.fill(larray1 , -1L);\n+      Arrays.fill(farray1 , -1.0f);\n+      Arrays.fill(darray1, -1.0);\n+\n+      Arrays.fill(barray2 , (byte)0xF);\n+      Arrays.fill(carray2 , (char)0xFF);\n+      Arrays.fill(sarray2 , (short)0xFF);\n+      Arrays.fill(iarray2 , -1);\n+      Arrays.fill(larray2 , -1L);\n+      Arrays.fill(farray2 , -1.0F);\n+      Arrays.fill(darray2, -1.0);\n+\n+      barray2[size-1] = (byte)1;\n+      carray2[size-1] = (char)1;\n+      sarray2[size-1] = (short)1;\n+      iarray2[size-1] = 1;\n+      larray2[size-1] = 1L;\n+      farray2[size-1] = 1.0f;\n+      darray2[size-1] = 1.0;\n+    }\n+\n+    @Benchmark\n+    public int testByteMatch() {\n+      return Arrays.mismatch(barray1, barray2);\n+    }\n+\n+    @Benchmark\n+    public int testCharMatch() {\n+      return Arrays.mismatch(carray1, carray2);\n+    }\n+\n+    @Benchmark\n+    public int testShortMatch() {\n+      return Arrays.mismatch(sarray1, sarray2);\n+    }\n+\n+    @Benchmark\n+    public int testIntMatch() {\n+      return Arrays.mismatch(iarray1, iarray2);\n+    }\n+\n+    @Benchmark\n+    public int testLongMatch() {\n+      return Arrays.mismatch(larray1, larray2);\n+    }\n+\n+    @Benchmark\n+    public int testFloatMatch() {\n+      return Arrays.mismatch(farray1, farray2);\n+    }\n+\n+    @Benchmark\n+    public int testDoubleMatch() {\n+      return Arrays.mismatch(darray1, darray2);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/ArraysMismatchPartialInlining.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"}]}