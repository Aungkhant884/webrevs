{"files":[{"patch":"@@ -2575,0 +2575,7 @@\n+void Assembler::knotql(KRegister dst, KRegister src) {\n+  assert(VM_Version::supports_avx512bw(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x44, (0xC0 | encode));\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1483,0 +1483,1 @@\n+  void knotql(KRegister dst, KRegister src);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1926,1 +1926,1 @@\n-  assert(ArrayCopyPartialInlineSize <= 64,\"\");\n+  assert(ArrayOperationPartialInlineSize > 0 && ArrayOperationPartialInlineSize <= 64, \"invalid\");\n@@ -2143,0 +2143,24 @@\n+void C2_MacroAssembler::evpcmp(BasicType typ, KRegister kdmask, KRegister ksmask, XMMRegister src1, XMMRegister src2, int comparison, int vector_len) {\n+  switch(typ) {\n+    case T_BYTE:\n+    case T_BOOLEAN:\n+      evpcmpb(kdmask, ksmask, src1, src2, comparison, vector_len);\n+      break;\n+    case T_SHORT:\n+    case T_CHAR:\n+      evpcmpw(kdmask, ksmask, src1, src2, comparison, vector_len);\n+      break;\n+    case T_INT:\n+    case T_FLOAT:\n+      evpcmpd(kdmask, ksmask, src1, src2, comparison, vector_len);\n+      break;\n+    case T_LONG:\n+    case T_DOUBLE:\n+      evpcmpq(kdmask, ksmask, src1, src2, comparison, vector_len);\n+      break;\n+    default:\n+      assert(false,\"Should not reach here.\");\n+      break;\n+  }\n+}\n+\n@@ -2145,0 +2169,1 @@\n+    case T_BOOLEAN:\n@@ -2148,0 +2173,1 @@\n+    case T_CHAR:\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -142,0 +142,1 @@\n+  void evpcmp(BasicType typ, KRegister kdmask, KRegister ksmask, XMMRegister src1, XMMRegister src2, int comparison, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1409,6 +1409,6 @@\n-      if (FLAG_IS_DEFAULT(ArrayCopyPartialInlineSize) ||\n-          (!FLAG_IS_DEFAULT(ArrayCopyPartialInlineSize) &&\n-           ArrayCopyPartialInlineSize != 0 &&\n-           ArrayCopyPartialInlineSize != 32 &&\n-           ArrayCopyPartialInlineSize != 16 &&\n-           ArrayCopyPartialInlineSize != 64)) {\n+      if (FLAG_IS_DEFAULT(ArrayOperationPartialInlineSize) ||\n+          (!FLAG_IS_DEFAULT(ArrayOperationPartialInlineSize) &&\n+           ArrayOperationPartialInlineSize != 0 &&\n+           ArrayOperationPartialInlineSize != 16 &&\n+           ArrayOperationPartialInlineSize != 32 &&\n+           ArrayOperationPartialInlineSize != 64)) {\n@@ -1423,2 +1423,2 @@\n-        if(!FLAG_IS_DEFAULT(ArrayCopyPartialInlineSize)) {\n-          warning(\"Setting ArrayCopyPartialInlineSize as %d\", inline_size);\n+        if(!FLAG_IS_DEFAULT(ArrayOperationPartialInlineSize)) {\n+          warning(\"Setting ArrayOperationPartialInlineSize as %d\", inline_size);\n@@ -1426,1 +1426,1 @@\n-        ArrayCopyPartialInlineSize = inline_size;\n+        ArrayOperationPartialInlineSize = inline_size;\n@@ -1429,4 +1429,4 @@\n-      if (ArrayCopyPartialInlineSize > MaxVectorSize) {\n-        ArrayCopyPartialInlineSize = MaxVectorSize >= 16 ? MaxVectorSize : 0;\n-        if (ArrayCopyPartialInlineSize) {\n-          warning(\"Setting ArrayCopyPartialInlineSize as MaxVectorSize\" INTX_FORMAT \")\", MaxVectorSize);\n+      if (ArrayOperationPartialInlineSize > MaxVectorSize) {\n+        ArrayOperationPartialInlineSize = MaxVectorSize >= 16 ? MaxVectorSize : 0;\n+        if (ArrayOperationPartialInlineSize) {\n+          warning(\"Setting ArrayOperationPartialInlineSize as MaxVectorSize\" INTX_FORMAT \")\", MaxVectorSize);\n@@ -1434,1 +1434,1 @@\n-          warning(\"Setting ArrayCopyPartialInlineSize as \" INTX_FORMAT, ArrayCopyPartialInlineSize);\n+          warning(\"Setting ArrayOperationPartialInlineSize as \" INTX_FORMAT, ArrayOperationPartialInlineSize);\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1577,0 +1577,1 @@\n+    case Op_VectorCmpMasked:\n@@ -1670,0 +1671,1 @@\n+    case Op_VectorCmpMasked:\n@@ -8048,1 +8050,28 @@\n-\/\/ ---------------------------------- Masked Block Copy ------------------------------------\n+\/\/ ---------------------------------- Masked Operations ------------------------------------\n+\n+instruct vmask_cmp_node(rRegI dst, vec src1, vec src2, kReg mask, kReg ktmp1, kReg ktmp2, rFlagsReg cr) %{\n+  match(Set dst (VectorCmpMasked src1 (Binary src2 mask)));\n+  effect(TEMP_DEF dst, TEMP ktmp1, TEMP ktmp2, KILL cr);\n+  format %{ \"vector_mask_cmp $src1, $src2, $mask \\t! vector mask comparison\" %}\n+  ins_encode %{\n+    assert(vector_length_encoding(this, $src1) == vector_length_encoding(this, $src2), \"mismatch\");\n+    assert(vector_element_basic_type(this, $src1) == vector_element_basic_type(this, $src2), \"mismatch\");\n+\n+    Label DONE;\n+    int vlen_enc = vector_length_encoding(this, $src1);\n+    BasicType elem_bt = vector_element_basic_type(this, $src1);\n+\n+    __ knotql($ktmp2$$KRegister, $mask$$KRegister);\n+    __ mov64($dst$$Register, -1L);\n+    __ evpcmp(elem_bt, $ktmp1$$KRegister, $mask$$KRegister, $src1$$XMMRegister, $src2$$XMMRegister, Assembler::eq, vlen_enc);\n+    __ kortestql($ktmp2$$KRegister, $ktmp1$$KRegister);\n+    __ jccb(Assembler::carrySet, DONE);\n+    __ kmovql($dst$$Register, $ktmp1$$KRegister);\n+    __ notq($dst$$Register);\n+    __ tzcntq($dst$$Register, $dst$$Register);\n+    __ bind(DONE);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -785,0 +785,1 @@\n+       !strcmp(_matrule->_rChild->_opType,\"VectorCmpMasked\")||\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -741,1 +741,1 @@\n-  int lane_count = ArrayCopyPartialInlineSize\/type2aelembytes(type);\n+  int lane_count = ArrayOperationPartialInlineSize\/type2aelembytes(type);\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,3 +85,4 @@\n-  product(intx, ArrayCopyPartialInlineSize, -1, DIAGNOSTIC,                 \\\n-          \"Partial inline size used for array copy acceleration.\")          \\\n-          range(-1, 64)                                                     \\\n+  product(intx, ArrayOperationPartialInlineSize, 0, DIAGNOSTIC,             \\\n+          \"Partial inline size used for small array operations\"             \\\n+          \"(e.g. copy,cmp) acceleration.\")                                  \\\n+          range(0, 64)                                                      \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -81,0 +81,5 @@\n+  CastIINode(Node* ctrl, Node* n, const Type* t, bool carry_dependency = false, bool range_check_dependency = false)\n+    : ConstraintCastNode(n, t, carry_dependency), _range_check_dependency(range_check_dependency) {\n+    init_class_id(Class_CastII);\n+    init_req(0, ctrl);\n+  }\n@@ -106,0 +111,5 @@\n+  CastLLNode(Node* ctrl, Node* n, const Type* t, bool carry_dependency = false)\n+    : ConstraintCastNode(n, t, carry_dependency) {\n+    init_class_id(Class_CastLL);\n+    init_req(0, ctrl);\n+  }\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -416,0 +416,1 @@\n+macro(VectorCmpMasked)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3412,0 +3412,1 @@\n+  case Op_VectorCmpMasked:\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -5187,1 +5188,1 @@\n-  assert(UseVectorizedMismatchIntrinsic, \"not implementated on this platform\");\n+  assert(UseVectorizedMismatchIntrinsic, \"not implemented on this platform\");\n@@ -5189,6 +5190,0 @@\n-  address stubAddr = StubRoutines::vectorizedMismatch();\n-  if (stubAddr == NULL) {\n-    return false; \/\/ Intrinsic's stub is not implemented on this platform\n-  }\n-  const char* stubName = \"vectorizedMismatch\";\n-  int size_l = callee()->signature()->size();\n@@ -5196,0 +5191,6 @@\n+  Node* obja    = argument(0); \/\/ Object\n+  Node* aoffset = argument(1); \/\/ long\n+  Node* objb    = argument(3); \/\/ Object\n+  Node* boffset = argument(4); \/\/ long\n+  Node* length  = argument(6); \/\/ int\n+  Node* scale   = argument(7); \/\/ int\n@@ -5197,15 +5198,6 @@\n-  Node* obja = argument(0);\n-  Node* aoffset = argument(1);\n-  Node* objb = argument(3);\n-  Node* boffset = argument(4);\n-  Node* length = argument(6);\n-  Node* scale = argument(7);\n-\n-  const Type* a_type = obja->Value(&_gvn);\n-  const Type* b_type = objb->Value(&_gvn);\n-  const TypeAryPtr* top_a = a_type->isa_aryptr();\n-  const TypeAryPtr* top_b = b_type->isa_aryptr();\n-  if (top_a == NULL || top_a->klass() == NULL ||\n-    top_b == NULL || top_b->klass() == NULL) {\n-    \/\/ failed array check\n-    return false;\n+  const TypeAryPtr* obja_t = _gvn.type(obja)->isa_aryptr();\n+  const TypeAryPtr* objb_t = _gvn.type(objb)->isa_aryptr();\n+  if (obja_t == NULL || obja_t->klass() == NULL ||\n+      objb_t == NULL || objb_t->klass() == NULL ||\n+      scale == top()) {\n+    return false; \/\/ failed input validation\n@@ -5214,3 +5206,0 @@\n-  Node* call;\n-  jvms()->set_should_reexecute(true);\n-\n@@ -5220,4 +5209,106 @@\n-  call = make_runtime_call(RC_LEAF,\n-    OptoRuntime::vectorizedMismatch_Type(),\n-    stubAddr, stubName, TypePtr::BOTTOM,\n-    obja_adr, objb_adr, length, scale);\n+  \/\/ Partial inlining handling for inputs smaller than ArrayOperationPartialInlineSize bytes in size.\n+  \/\/\n+  \/\/    inline_limit = ArrayOperationPartialInlineSize \/ element_size;\n+  \/\/    if (length <= inline_limit) {\n+  \/\/      inline_path:\n+  \/\/        vmask   = VectorMaskGen length\n+  \/\/        vload1  = LoadVectorMasked obja, vmask\n+  \/\/        vload2  = LoadVectorMasked objb, vmask\n+  \/\/        result1 = VectorCmpMasked vload1, vload2, vmask\n+  \/\/    } else {\n+  \/\/      call_stub_path:\n+  \/\/        result2 = call vectorizedMismatch_stub(obja, objb, length, scale)\n+  \/\/    }\n+  \/\/    exit_block:\n+  \/\/      return Phi(result1, result2);\n+  \/\/\n+  enum { inline_path = 1,  \/\/ input is small enough to process it all at once\n+         stub_path   = 2,  \/\/ input is too large; call into the VM\n+         PATH_LIMIT  = 3\n+  };\n+\n+  Node* exit_block = new RegionNode(PATH_LIMIT);\n+  Node* result_phi = new PhiNode(exit_block, TypeInt::INT);\n+  Node* memory_phi = new PhiNode(exit_block, Type::MEMORY, TypePtr::BOTTOM);\n+\n+  Node* call_stub_path = control();\n+\n+  BasicType elem_bt = T_ILLEGAL;\n+\n+  const TypeInt* scale_t = _gvn.type(scale)->is_int();\n+  if (scale_t->is_con()) {\n+    switch (scale_t->get_con()) {\n+      case 0: elem_bt = T_BYTE;  break;\n+      case 1: elem_bt = T_SHORT; break;\n+      case 2: elem_bt = T_INT;   break;\n+      case 3: elem_bt = T_LONG;  break;\n+\n+      default: elem_bt = T_ILLEGAL; break; \/\/ not supported\n+    }\n+  }\n+\n+  int inline_limit = 0;\n+  bool do_partial_inline = false;\n+\n+  if (elem_bt != T_ILLEGAL && ArrayOperationPartialInlineSize > 0) {\n+    inline_limit = ArrayOperationPartialInlineSize \/ type2aelembytes(elem_bt);\n+    do_partial_inline = inline_limit >= 16;\n+  }\n+\n+  if (do_partial_inline) {\n+    assert(elem_bt != T_ILLEGAL, \"sanity\");\n+\n+    const TypeVect* vt = TypeVect::make(elem_bt, inline_limit);\n+\n+    if (Matcher::match_rule_supported_vector(Op_VectorMaskGen,    inline_limit, elem_bt) &&\n+        Matcher::match_rule_supported_vector(Op_LoadVectorMasked, inline_limit, elem_bt) &&\n+        Matcher::match_rule_supported_vector(Op_VectorCmpMasked,  inline_limit, elem_bt)) {\n+\n+      Node* cmp_length = _gvn.transform(new CmpINode(length, intcon(inline_limit)));\n+      Node* bol_gt     = _gvn.transform(new BoolNode(cmp_length, BoolTest::gt));\n+\n+      call_stub_path = generate_guard(bol_gt, NULL, PROB_MIN);\n+\n+      if (!stopped()) {\n+        Node* casted_length = _gvn.transform(new CastIINode(control(), length, TypeInt::make(0, inline_limit, Type::WidenMin)));\n+\n+        const TypePtr* obja_adr_t = _gvn.type(obja_adr)->isa_ptr();\n+        const TypePtr* objb_adr_t = _gvn.type(objb_adr)->isa_ptr();\n+        Node* obja_adr_mem = memory(C->get_alias_index(obja_adr_t));\n+        Node* objb_adr_mem = memory(C->get_alias_index(objb_adr_t));\n+\n+        Node* vmask      = _gvn.transform(new VectorMaskGenNode(ConvI2X(casted_length), TypeVect::VECTMASK, elem_bt));\n+        Node* vload_obja = _gvn.transform(new LoadVectorMaskedNode(control(), obja_adr_mem, obja_adr, obja_adr_t, vt, vmask));\n+        Node* vload_objb = _gvn.transform(new LoadVectorMaskedNode(control(), objb_adr_mem, objb_adr, objb_adr_t, vt, vmask));\n+        Node* result     = _gvn.transform(new VectorCmpMaskedNode(vload_obja, vload_objb, vmask, TypeInt::INT));\n+\n+        exit_block->init_req(inline_path, control());\n+        memory_phi->init_req(inline_path, map()->memory());\n+        result_phi->init_req(inline_path, result);\n+\n+        C->set_max_vector_size(MAX2((uint)ArrayOperationPartialInlineSize, C->max_vector_size()));\n+        clear_upper_avx();\n+      }\n+    }\n+  }\n+\n+  if (call_stub_path != NULL) {\n+    set_control(call_stub_path);\n+\n+    Node* call = make_runtime_call(RC_LEAF,\n+                                   OptoRuntime::vectorizedMismatch_Type(),\n+                                   StubRoutines::vectorizedMismatch(), \"vectorizedMismatch\", TypePtr::BOTTOM,\n+                                   obja_adr, objb_adr, length, scale);\n+\n+    exit_block->init_req(stub_path, control());\n+    memory_phi->init_req(stub_path, map()->memory());\n+    result_phi->init_req(stub_path, _gvn.transform(new ProjNode(call, TypeFunc::Parms)));\n+  }\n+\n+  exit_block = _gvn.transform(exit_block);\n+  memory_phi = _gvn.transform(memory_phi);\n+  result_phi = _gvn.transform(result_phi);\n+\n+  set_control(exit_block);\n+  set_all_memory(memory_phi);\n+  set_result(result_phi);\n@@ -5225,2 +5316,0 @@\n-  Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));\n-  set_result(result);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":120,"deletions":31,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"opto\/castnode.hpp\"\n@@ -177,2 +178,2 @@\n-\/\/ length(in bytes) less than ArrayCopyPartialInlineSize.\n-\/\/  if (length <= ArrayCopyPartialInlineSize) {\n+\/\/ length(in bytes) less than ArrayOperationPartialInlineSize.\n+\/\/  if (length <= ArrayOperationPartialInlineSize) {\n@@ -219,1 +220,1 @@\n-  if ( const_len > ArrayCopyPartialInlineSize ||\n+  if ( const_len > ArrayOperationPartialInlineSize ||\n@@ -226,0 +227,3 @@\n+  int inline_limit = ArrayOperationPartialInlineSize \/ type2aelembytes(type);\n+  Node* casted_length = new CastLLNode(*ctrl, length, TypeLong::make(0, inline_limit, Type::WidenMin));\n+  transform_later(casted_length);\n@@ -229,1 +233,1 @@\n-  Node* cmp_le = new CmpULNode(copy_bytes, longcon(ArrayCopyPartialInlineSize));\n+  Node* cmp_le = new CmpULNode(copy_bytes, longcon(ArrayOperationPartialInlineSize));\n@@ -236,1 +240,1 @@\n-  Node* mask_gen =  new VectorMaskGenNode(length, TypeVect::VECTMASK, Type::get_const_basic_type(type));\n+  Node* mask_gen =  new VectorMaskGenNode(casted_length, TypeVect::VECTMASK, type);\n@@ -1190,1 +1194,1 @@\n-  if (ArrayCopyPartialInlineSize > 0 && is_subword_type(basic_elem_type) &&\n+  if (ArrayOperationPartialInlineSize > 0 && is_subword_type(basic_elem_type) &&\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2219,0 +2219,1 @@\n+    case Op_VectorCmpMasked:\n@@ -2312,0 +2313,6 @@\n+    case Op_VectorCmpMasked: {\n+      Node* pair1 = new BinaryNode(n->in(2), n->in(3));\n+      n->set_req(2, pair1);\n+      n->del_req(3);\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -724,11 +724,13 @@\n-  Node* mask_len = in(3)->in(1);\n-  const TypeLong* ty = phase->type(mask_len)->isa_long();\n-  if (ty && ty->is_con()) {\n-    BasicType mask_bt = ((VectorMaskGenNode*)in(3))->get_elem_type()->array_element_basic_type();\n-    uint load_sz      = type2aelembytes(mask_bt) * ty->get_con();\n-    if ( load_sz == 32 || load_sz == 64) {\n-      assert(load_sz == 32 || MaxVectorSize > 32, \"Unexpected load size\");\n-      Node* ctr = in(MemNode::Control);\n-      Node* mem = in(MemNode::Memory);\n-      Node* adr = in(MemNode::Address);\n-      return phase->transform(new LoadVectorNode(ctr, mem, adr, adr_type(), vect_type()));\n+  if (!in(3)->is_top() && in(3)->Opcode() == Op_VectorMaskGen) {\n+    Node* mask_len = in(3)->in(1);\n+    const TypeLong* ty = phase->type(mask_len)->isa_long();\n+    if (ty && ty->is_con()) {\n+      BasicType mask_bt = ((VectorMaskGenNode*)in(3))->get_elem_type();\n+      uint load_sz      = type2aelembytes(mask_bt) * ty->get_con();\n+      if ( load_sz == 32 || load_sz == 64) {\n+        assert(load_sz == 32 || MaxVectorSize > 32, \"Unexpected load size\");\n+        Node* ctr = in(MemNode::Control);\n+        Node* mem = in(MemNode::Memory);\n+        Node* adr = in(MemNode::Address);\n+        return phase->transform(new LoadVectorNode(ctr, mem, adr, adr_type(), vect_type()));\n+      }\n@@ -741,12 +743,14 @@\n-  Node* mask_len = in(4)->in(1);\n-  const TypeLong* ty = phase->type(mask_len)->isa_long();\n-  if (ty && ty->is_con()) {\n-    BasicType mask_bt = ((VectorMaskGenNode*)in(4))->get_elem_type()->array_element_basic_type();\n-    uint load_sz      = type2aelembytes(mask_bt) * ty->get_con();\n-    if ( load_sz == 32 || load_sz == 64) {\n-      assert(load_sz == 32 || MaxVectorSize > 32, \"Unexpected store size\");\n-      Node* ctr = in(MemNode::Control);\n-      Node* mem = in(MemNode::Memory);\n-      Node* adr = in(MemNode::Address);\n-      Node* val = in(MemNode::ValueIn);\n-      return phase->transform(new StoreVectorNode(ctr, mem, adr, adr_type(), val));\n+  if (!in(4)->is_top() && in(4)->Opcode() == Op_VectorMaskGen) {\n+    Node* mask_len = in(4)->in(1);\n+    const TypeLong* ty = phase->type(mask_len)->isa_long();\n+    if (ty && ty->is_con()) {\n+      BasicType mask_bt = ((VectorMaskGenNode*)in(4))->get_elem_type();\n+      uint load_sz      = type2aelembytes(mask_bt) * ty->get_con();\n+      if ( load_sz == 32 || load_sz == 64) {\n+        assert(load_sz == 32 || MaxVectorSize > 32, \"Unexpected store size\");\n+        Node* ctr = in(MemNode::Control);\n+        Node* mem = in(MemNode::Memory);\n+        Node* adr = in(MemNode::Address);\n+        Node* val = in(MemNode::ValueIn);\n+        return phase->transform(new StoreVectorNode(ctr, mem, adr, adr_type(), val));\n+      }\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":27,"deletions":23,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -803,0 +803,2 @@\n+\/\/------------------------------StoreVectorMaskedNode--------------------------------\n+\/\/ Store Vector to memory under the influence of a predicate register(mask).\n@@ -821,0 +823,2 @@\n+\/\/------------------------------LoadVectorMaskedNode--------------------------------\n+\/\/ Load Vector from memory under the influence of a predicate register(mask).\n@@ -839,0 +843,15 @@\n+\n+\/\/------------------------------VectorCmpMaskedNode--------------------------------\n+\/\/ Vector Comparison under the influence of a predicate register(mask).\n+class VectorCmpMaskedNode : public TypeNode {\n+  public:\n+   VectorCmpMaskedNode(Node* src1, Node* src2, Node* mask, const Type* ty): TypeNode(ty, 4)  {\n+     init_req(1, src1);\n+     init_req(2, src2);\n+     init_req(3, mask);\n+   }\n+\n+  virtual int Opcode() const;\n+};\n+\n+\n@@ -841,1 +860,1 @@\n-  VectorMaskGenNode(Node* length, const Type* ty, const Type* ety): TypeNode(ty, 2), _elemType(ety) {\n+  VectorMaskGenNode(Node* length, const Type* ty, BasicType ety): TypeNode(ty, 2), _elemType(ety) {\n@@ -846,1 +865,1 @@\n-  const Type* get_elem_type()  { return _elemType;}\n+  BasicType get_elem_type()  { return _elemType;}\n@@ -853,1 +872,1 @@\n-   const Type* _elemType;\n+   BasicType _elemType;\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=0 -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=0 -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOptions\n@@ -36,1 +36,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=0 -XX:MaxVectorSize=64\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=0 -XX:MaxVectorSize=64\n@@ -39,1 +39,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOption\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOption\n@@ -42,1 +42,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=64\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=64\n@@ -45,1 +45,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=64 -XX:MaxVectorSize=64\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=64 -XX:MaxVectorSize=64\n@@ -48,1 +48,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOption -XX:ArrayCopyLoadStoreMaxElem=16\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOption -XX:ArrayCopyLoadStoreMaxElem=16\n@@ -51,1 +51,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=64 -XX:MaxVectorSize=64 -XX:ArrayCopyLoadStoreMaxElem=16\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=64 -XX:MaxVectorSize=64 -XX:ArrayCopyLoadStoreMaxElem=16\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestArrayCopyConjoint.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=0 -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=0 -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOptions\n@@ -36,1 +36,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=0 -XX:MaxVectorSize=64\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=0 -XX:MaxVectorSize=64\n@@ -39,1 +39,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOption\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOption\n@@ -42,1 +42,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=64\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=64\n@@ -45,1 +45,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=64 -XX:MaxVectorSize=64\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=64 -XX:MaxVectorSize=64\n@@ -48,1 +48,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOption -XX:ArrayCopyLoadStoreMaxElem=16\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOption -XX:ArrayCopyLoadStoreMaxElem=16\n@@ -51,1 +51,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=64 -XX:MaxVectorSize=64 -XX:ArrayCopyLoadStoreMaxElem=16\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=64 -XX:MaxVectorSize=64 -XX:ArrayCopyLoadStoreMaxElem=16\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestArrayCopyDisjoint.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,288 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.intrinsics;\n+\n+\/*\n+ * @test\n+ * @requires vm.opt.final.UseVectorizedMismatchIntrinsic == true\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.base\/jdk.internal.util\n+ *\n+ *  @run main\/othervm -XX:CompileCommand=quiet -XX:CompileCommand=compileonly,*::test*\n+ *                    -Xbatch -XX:-TieredCompilation\n+ *                    -XX:UseAVX=3\n+ *                     compiler.intrinsics.VectorizedMismatchTest\n+ *\n+ *  @run main\/othervm -XX:CompileCommand=quiet -XX:CompileCommand=compileonly,*::test*\n+ *                    -Xbatch -XX:-TieredCompilation\n+ *                    -XX:UseAVX=3 -XX:AVX3Threshold=0\n+ *                     compiler.intrinsics.VectorizedMismatchTest\n+ *\/\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.util.ArraysSupport;\n+\n+public class VectorizedMismatchTest {\n+    private boolean[] boolean_a = new boolean[128];\n+    private boolean[] boolean_b = new boolean[128];\n+\n+    int testBooleanConstantLength(int length) {\n+        boolean[] obja = boolean_a;\n+        boolean[] objb = boolean_b;\n+        long offset = Unsafe.ARRAY_BOOLEAN_BASE_OFFSET;\n+        int scale = ArraysSupport.LOG2_ARRAY_BOOLEAN_INDEX_SCALE;\n+        return ArraysSupport.vectorizedMismatch(obja, offset, objb, offset, length, scale);\n+    }\n+\n+    int testBooleanConstantLength0()   { return testBooleanConstantLength(0);   }\n+    int testBooleanConstantLength1()   { return testBooleanConstantLength(1);   }\n+    int testBooleanConstantLength64()  { return testBooleanConstantLength(64);  }\n+    int testBooleanConstantLength128() { return testBooleanConstantLength(128); }\n+\n+    \/* ==================================================================================== *\/\n+\n+    private byte[] byte_a = new byte[128];\n+    private byte[] byte_b = new byte[128];\n+\n+    int testByteConstantLength(int length) {\n+        byte[] obja = byte_a;\n+        byte[] objb = byte_b;\n+        long offset = Unsafe.ARRAY_BYTE_BASE_OFFSET;\n+        int scale = ArraysSupport.LOG2_ARRAY_BYTE_INDEX_SCALE;\n+        return ArraysSupport.vectorizedMismatch(obja, offset, objb, offset, length, scale);\n+    }\n+\n+    int testByteConstantLength0()   { return testByteConstantLength(0);   }\n+    int testByteConstantLength1()   { return testByteConstantLength(1);   }\n+    int testByteConstantLength64()  { return testByteConstantLength(64);  }\n+    int testByteConstantLength128() { return testByteConstantLength(128); }\n+\n+    \/* ==================================================================================== *\/\n+\n+    private short[] short_a = new short[64];\n+    private short[] short_b = new short[64];\n+\n+    int testShortConstantLength(int length) {\n+        short[] obja = short_a;\n+        short[] objb = short_b;\n+        long offset = Unsafe.ARRAY_SHORT_BASE_OFFSET;\n+        int scale = ArraysSupport.LOG2_ARRAY_SHORT_INDEX_SCALE;\n+        return ArraysSupport.vectorizedMismatch(obja, offset, objb, offset, length, scale);\n+    }\n+\n+    int testShortConstantLength0()  { return testShortConstantLength(0);  }\n+    int testShortConstantLength1()  { return testShortConstantLength(1);  }\n+    int testShortConstantLength32() { return testShortConstantLength(32); }\n+    int testShortConstantLength64() { return testShortConstantLength(64); }\n+\n+    \/* ==================================================================================== *\/\n+\n+    private char[] char_a = new char[64];\n+    private char[] char_b = new char[64];\n+\n+    int testCharConstantLength(int length) {\n+        char[] obja = char_a;\n+        char[] objb = char_b;\n+        long offset = Unsafe.ARRAY_CHAR_BASE_OFFSET;\n+        int scale = ArraysSupport.LOG2_ARRAY_CHAR_INDEX_SCALE;\n+        return ArraysSupport.vectorizedMismatch(obja, offset, objb, offset, length, scale);\n+    }\n+\n+    int testCharConstantLength0()  { return testCharConstantLength(0);  }\n+    int testCharConstantLength1()  { return testCharConstantLength(1);  }\n+    int testCharConstantLength32() { return testCharConstantLength(32); }\n+    int testCharConstantLength64() { return testCharConstantLength(64); }\n+\n+    \/* ==================================================================================== *\/\n+\n+    private int[] int_a = new int[32];\n+    private int[] int_b = new int[32];\n+\n+    int testIntConstantLength(int length) {\n+        int[] obja = int_a;\n+        int[] objb = int_b;\n+        long offset = Unsafe.ARRAY_INT_BASE_OFFSET;\n+        int scale = ArraysSupport.LOG2_ARRAY_INT_INDEX_SCALE;\n+        return ArraysSupport.vectorizedMismatch(obja, offset, objb, offset, length, scale);\n+    }\n+\n+    int testIntConstantLength0()  { return testIntConstantLength(0);  }\n+    int testIntConstantLength1()  { return testIntConstantLength(1);  }\n+    int testIntConstantLength16() { return testIntConstantLength(16); }\n+    int testIntConstantLength32() { return testIntConstantLength(32); }\n+\n+    \/* ==================================================================================== *\/\n+\n+    private float[] float_a = new float[32];\n+    private float[] float_b = new float[32];\n+\n+    int testFloatConstantLength(int length) {\n+        float[] obja = float_a;\n+        float[] objb = float_b;\n+        long offset = Unsafe.ARRAY_FLOAT_BASE_OFFSET;\n+        int scale = ArraysSupport.LOG2_ARRAY_FLOAT_INDEX_SCALE;\n+        return ArraysSupport.vectorizedMismatch(obja, offset, objb, offset, length, scale);\n+    }\n+\n+    int testFloatConstantLength0()  { return testFloatConstantLength(0);  }\n+    int testFloatConstantLength1()  { return testFloatConstantLength(1);  }\n+    int testFloatConstantLength16() { return testFloatConstantLength(16); }\n+    int testFloatConstantLength32() { return testFloatConstantLength(32); }\n+\n+    \/* ==================================================================================== *\/\n+\n+    private long[] long_a = new long[16];\n+    private long[] long_b = new long[16];\n+\n+    int testLongConstantLength(int length) {\n+        long[] obja = long_a;\n+        long[] objb = long_b;\n+        long offset = Unsafe.ARRAY_LONG_BASE_OFFSET;\n+        int scale = ArraysSupport.LOG2_ARRAY_LONG_INDEX_SCALE;\n+        return ArraysSupport.vectorizedMismatch(obja, offset, objb, offset, length, scale);\n+    }\n+\n+    int testLongConstantLength0()  { return testLongConstantLength(0);  }\n+    int testLongConstantLength1()  { return testLongConstantLength(1);  }\n+    int testLongConstantLength8()  { return testLongConstantLength(8);  }\n+    int testLongConstantLength16() { return testLongConstantLength(16); }\n+\n+    \/* ==================================================================================== *\/\n+\n+    private double[] double_a = new double[16];\n+    private double[] double_b = new double[16];\n+\n+    int testDoubleConstantLength(int length) {\n+        double[] obja = double_a;\n+        double[] objb = double_b;\n+        long offset = Unsafe.ARRAY_DOUBLE_BASE_OFFSET;\n+        int  scale  = ArraysSupport.LOG2_ARRAY_DOUBLE_INDEX_SCALE;\n+        return ArraysSupport.vectorizedMismatch(obja, offset, objb, offset, length, scale);\n+    }\n+\n+    int testDoubleConstantLength0()  { return testDoubleConstantLength(0);  }\n+    int testDoubleConstantLength1()  { return testDoubleConstantLength(1);  }\n+    int testDoubleConstantLength8()  { return testDoubleConstantLength(8);  }\n+    int testDoubleConstantLength16() { return testDoubleConstantLength(16); }\n+\n+    \/* ==================================================================================== *\/\n+\n+    static class ClassInitTest {\n+        static final int LENGTH = 64;\n+        static final int RESULT;\n+        static {\n+            byte[] arr1 = new byte[LENGTH];\n+            byte[] arr2 = new byte[LENGTH];\n+            for (int i = 0; i < 20_000; i++) {\n+                test(arr1, arr2);\n+            }\n+            RESULT = test(arr1, arr2);\n+        }\n+\n+        static int test(byte[] obja, byte[] objb) {\n+            long offset = Unsafe.ARRAY_BYTE_BASE_OFFSET;\n+            int  scale  = ArraysSupport.LOG2_ARRAY_BYTE_INDEX_SCALE;\n+            return ArraysSupport.vectorizedMismatch(obja, offset, objb, offset, LENGTH, scale); \/\/ LENGTH is not considered a constant\n+        }\n+    }\n+\n+    int testConstantBeingInitialized() {\n+        return ClassInitTest.RESULT; \/\/ trigger class initialization\n+    }\n+\n+    \/* ==================================================================================== *\/\n+\n+    int testLoopUnswitch(int length) {\n+        long offset = Unsafe.ARRAY_BYTE_BASE_OFFSET;\n+        int  scale  = ArraysSupport.LOG2_ARRAY_BYTE_INDEX_SCALE;\n+\n+        int acc = 0;\n+        for (int i = 0; i < 32; i++) {\n+            acc += ArraysSupport.vectorizedMismatch(byte_a, offset, byte_b, offset, length, scale);\n+        }\n+        return acc;\n+    }\n+\n+    int testLoopHoist(int length, int stride) {\n+        long offset = Unsafe.ARRAY_BYTE_BASE_OFFSET;\n+        int  scale  = ArraysSupport.LOG2_ARRAY_BYTE_INDEX_SCALE;\n+\n+        int acc = 0;\n+\n+        for (int i = 0; i < 32; i += stride) {\n+            acc += ArraysSupport.vectorizedMismatch(byte_a, offset, byte_b, offset, length, scale);\n+        }\n+        return acc;\n+    }\n+\n+    \/* ==================================================================================== *\/\n+\n+    public static void main(String[] args) {\n+        VectorizedMismatchTest t = new VectorizedMismatchTest();\n+        for (int i = 0; i < 20_000; i++) {\n+            t.testBooleanConstantLength0();\n+            t.testBooleanConstantLength1();\n+            t.testBooleanConstantLength64();\n+            t.testBooleanConstantLength128();\n+\n+            t.testByteConstantLength0();\n+            t.testByteConstantLength1();\n+            t.testByteConstantLength64();\n+            t.testByteConstantLength128();\n+\n+            t.testShortConstantLength0();\n+            t.testShortConstantLength1();\n+            t.testShortConstantLength32();\n+            t.testShortConstantLength64();\n+\n+            t.testCharConstantLength0();\n+            t.testCharConstantLength1();\n+            t.testCharConstantLength32();\n+            t.testCharConstantLength64();\n+\n+            t.testIntConstantLength0();\n+            t.testIntConstantLength1();\n+            t.testIntConstantLength16();\n+            t.testIntConstantLength32();\n+\n+            t.testFloatConstantLength0();\n+            t.testFloatConstantLength1();\n+            t.testFloatConstantLength16();\n+            t.testFloatConstantLength32();\n+\n+            t.testLongConstantLength0();\n+            t.testLongConstantLength1();\n+            t.testLongConstantLength8();\n+            t.testLongConstantLength16();\n+\n+            t.testDoubleConstantLength0();\n+            t.testDoubleConstantLength1();\n+            t.testDoubleConstantLength8();\n+            t.testDoubleConstantLength16();\n+\n+            t.testLoopUnswitch(32);\n+            t.testLoopHoist(128, 2);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/VectorizedMismatchTest.java","additions":288,"deletions":0,"binary":false,"changes":288,"status":"added"},{"patch":"@@ -314,0 +314,1 @@\n+        vmOptFinalFlag(map, \"UseVectorizedMismatchIntrinsic\");\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+public class ArraysMismatchPartialInlining {\n+\n+    @Param({\"3\", \"4\", \"5\", \"6\", \"7\", \"15\", \"31\", \"63\", \"95\", \"800\"})\n+    private static int size;\n+\n+    byte [] barray1;\n+    char [] carray1;\n+    short [] sarray1;\n+    int [] iarray1;\n+    long [] larray1;\n+    float [] farray1;\n+    double [] darray1;\n+\n+    byte [] barray2;\n+    char [] carray2;\n+    short [] sarray2;\n+    int [] iarray2;\n+    long [] larray2;\n+    float [] farray2;\n+    double [] darray2;\n+\n+    @Setup\n+    public void setup() {\n+      barray1 = new byte[size];\n+      carray1 = new char[size];\n+      sarray1 = new short[size];\n+      iarray1 = new int[size];\n+      larray1 = new long[size];\n+      farray1 = new float[size];\n+      darray1 = new double[size];\n+\n+      barray2 = new byte[size];\n+      carray2 = new char[size];\n+      sarray2 = new short[size];\n+      iarray2 = new int[size];\n+      larray2 = new long[size];\n+      farray2 = new float[size];\n+      darray2 = new double[size];\n+\n+      Arrays.fill(barray1 , (byte)0xF);\n+      Arrays.fill(carray1 , (char)0xFF);\n+      Arrays.fill(sarray1 , (short)0xFF);\n+      Arrays.fill(iarray1 , -1);\n+      Arrays.fill(larray1 , -1L);\n+      Arrays.fill(farray1 , -1.0f);\n+      Arrays.fill(darray1, -1.0);\n+\n+      Arrays.fill(barray2 , (byte)0xF);\n+      Arrays.fill(carray2 , (char)0xFF);\n+      Arrays.fill(sarray2 , (short)0xFF);\n+      Arrays.fill(iarray2 , -1);\n+      Arrays.fill(larray2 , -1L);\n+      Arrays.fill(farray2 , -1.0F);\n+      Arrays.fill(darray2, -1.0);\n+\n+      barray2[size-1] = (byte)1;\n+      carray2[size-1] = (char)1;\n+      sarray2[size-1] = (short)1;\n+      iarray2[size-1] = 1;\n+      larray2[size-1] = 1L;\n+      farray2[size-1] = 1.0f;\n+      darray2[size-1] = 1.0;\n+    }\n+\n+    @Benchmark\n+    public int testByteMatch() {\n+      return Arrays.mismatch(barray1, barray2);\n+    }\n+\n+    @Benchmark\n+    public int testCharMatch() {\n+      return Arrays.mismatch(carray1, carray2);\n+    }\n+\n+    @Benchmark\n+    public int testShortMatch() {\n+      return Arrays.mismatch(sarray1, sarray2);\n+    }\n+\n+    @Benchmark\n+    public int testIntMatch() {\n+      return Arrays.mismatch(iarray1, iarray2);\n+    }\n+\n+    @Benchmark\n+    public int testLongMatch() {\n+      return Arrays.mismatch(larray1, larray2);\n+    }\n+\n+    @Benchmark\n+    public int testFloatMatch() {\n+      return Arrays.mismatch(farray1, farray2);\n+    }\n+\n+    @Benchmark\n+    public int testDoubleMatch() {\n+      return Arrays.mismatch(darray1, darray2);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/ArraysMismatchPartialInlining.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"}]}