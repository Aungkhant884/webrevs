{"files":[{"patch":"@@ -2474,0 +2474,1 @@\n+    case Op_VectorLongToMask:\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -156,0 +156,2 @@\n+      case Op_VectorLongToMask:\n+        if (UseSVE < 2 || vlen > 64 || !VM_Version::supports_svebitperm()) return false;\n@@ -5678,0 +5680,14 @@\n+instruct vmask_fromlong(pRegGov dst, iRegL src, vReg vtmp1, vReg vtmp2) %{\n+  match(Set dst (VectorLongToMask src));\n+  effect(TEMP vtmp1, TEMP vtmp2);\n+  ins_cost(10 * SVE_COST);\n+  format %{ \"vmask_fromlong $dst, $src\\t# vector mask fromlong (sve2)\" %}\n+  ins_encode %{\n+    __ sve_vmask_fromlong(as_PRegister($dst$$reg), as_Register($src$$reg),\n+                          Matcher::vector_element_basic_type(this),\n+                          Matcher::vector_length(this),\n+                          as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -151,0 +151,2 @@\n+      case Op_VectorLongToMask:\n+        if (UseSVE < 2 || vlen > 64 || !VM_Version::supports_svebitperm()) return false;\n@@ -3171,0 +3173,14 @@\n+instruct vmask_fromlong(pRegGov dst, iRegL src, vReg vtmp1, vReg vtmp2) %{\n+  match(Set dst (VectorLongToMask src));\n+  effect(TEMP vtmp1, TEMP vtmp2);\n+  ins_cost(10 * SVE_COST);\n+  format %{ \"vmask_fromlong $dst, $src\\t# vector mask fromlong (sve2)\" %}\n+  ins_encode %{\n+    __ sve_vmask_fromlong(as_PRegister($dst$$reg), as_Register($src$$reg),\n+                          Matcher::vector_element_basic_type(this),\n+                          Matcher::vector_length(this),\n+                          as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3864,0 +3864,1 @@\n+  INSN(sve_bdep, 0b01);\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1033,0 +1033,60 @@\n+\/\/ Unpack the mask, a long value in src, into predicate register dst based on the\n+\/\/ corresponding data type. Note that dst can support at most 64 lanes.\n+\/\/ Below example gives the expected dst predicate register in different types, with\n+\/\/ a valid src(0x658D) on a 1024-bit vector size machine.\n+\/\/ BYTE:  dst = 0x00 00 00 00 00 00 00 00 00 00 00 00 00 00 65 8D\n+\/\/ SHORT: dst = 0x00 00 00 00 00 00 00 00 00 00 00 00 14 11 40 51\n+\/\/ INT:   dst = 0x00 00 00 00 00 00 00 00 01 10 01 01 10 00 11 01\n+\/\/ LONG:  dst = 0x00 01 01 00 00 01 00 01 01 00 00 00 01 01 00 01\n+\/\/\n+\/\/ The number of significant bits of src must be equal to lane_cnt. E.g., 0xFF658D which\n+\/\/ has 24 significant bits would be an invalid input if dst predicate register refers to\n+\/\/ a LONG type 1024-bit vector, which has at most 16 lanes.\n+void C2_MacroAssembler::sve_vmask_fromlong(PRegister dst, Register src, BasicType bt, int lane_cnt,\n+                                           FloatRegister vtmp1, FloatRegister vtmp2) {\n+  assert(UseSVE == 2 && VM_Version::supports_svebitperm() &&\n+         lane_cnt <= 64 && is_power_of_2(lane_cnt), \"unsupported\");\n+  Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);\n+  \/\/ Example:   src = 0x658D, bt = T_BYTE, size = B, lane_cnt = 16\n+  \/\/ Expected:  dst = 0b01101001 10001101\n+\n+  \/\/ Put long value from general purpose register into the first lane of vector.\n+  \/\/ vtmp1 = 0x0000000000000000 | 0x000000000000658D\n+  sve_dup(vtmp1, B, 0);\n+  mov(vtmp1, D, 0, src);\n+\n+  \/\/ As sve_cmp generates mask value with the minimum unit in byte, we should\n+  \/\/ transform the value in the first lane which is mask in bit now to the\n+  \/\/ mask in byte, which can be done by SVE2's BDEP instruction.\n+\n+  \/\/ The first source input of BDEP instruction. Deposite each byte in every 8 bytes.\n+  \/\/ vtmp1 = 0x0000000000000065 | 0x000000000000008D\n+  if (lane_cnt <= 8) {\n+    \/\/ Nothing. As only one byte exsits.\n+  } else if (lane_cnt <= 16) {\n+    ins(vtmp1, B, vtmp1, 8, 1);\n+    mov(vtmp1, B, 1, zr);\n+  } else {\n+    sve_vector_extend(vtmp1, D, vtmp1, B);\n+  }\n+\n+  \/\/ The second source input of BDEP instruction, initialized with 0x01 for each byte.\n+  \/\/ vtmp2 = 0x01010101 0x01010101 0x01010101 0x01010101\n+  sve_dup(vtmp2, B, 1);\n+\n+  \/\/ BDEP vtmp1.D, vtmp1.D, vtmp2.D\n+  \/\/ vtmp1 = 0x0000000000000065 | 0x000000000000008D\n+  \/\/ vtmp2 = 0x0101010101010101 | 0x0101010101010101\n+  \/\/         ---------------------------------------\n+  \/\/ vtmp1 = 0x0001010000010001 | 0x0100000001010001\n+  sve_bdep(vtmp1, D, vtmp1, vtmp2);\n+\n+  if (bt != T_BYTE) {\n+    sve_vector_extend(vtmp1, size, vtmp1, B);\n+  }\n+  \/\/ Generate mask according to the given vector, in which the elements have been\n+  \/\/ extended to expected type.\n+  \/\/ dst = 0b01101001 10001101\n+  sve_cmp(Assembler::NE, dst, size, ptrue, vtmp1, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -67,0 +67,5 @@\n+  \/\/ Unpack the mask, a long value in src, into predicate register dst based on the\n+  \/\/ corresponding data type. Note that dst can support at most 64 lanes.\n+  void sve_vmask_fromlong(PRegister dst, Register src, BasicType bt, int lane_cnt,\n+                          FloatRegister vtmp1, FloatRegister vtmp2);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1911,0 +1911,1 @@\n+                       [\"bdep\", \"ZZZ\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1198,0 +1198,1 @@\n+    __ sve_bdep(z4, __ D, z20, z13);                   \/\/       bdep    z4.d, z20.d, z13.d\n@@ -1200,9 +1201,9 @@\n-    __ sve_andv(v4, __ D, p5, z13);                    \/\/       andv d4, p5, z13.d\n-    __ sve_orv(v22, __ D, p7, z30);                    \/\/       orv d22, p7, z30.d\n-    __ sve_eorv(v17, __ H, p4, z14);                   \/\/       eorv h17, p4, z14.h\n-    __ sve_smaxv(v12, __ B, p7, z20);                  \/\/       smaxv b12, p7, z20.b\n-    __ sve_sminv(v1, __ B, p3, z13);                   \/\/       sminv b1, p3, z13.b\n-    __ sve_fminv(v7, __ D, p2, z11);                   \/\/       fminv d7, p2, z11.d\n-    __ sve_fmaxv(v4, __ S, p6, z15);                   \/\/       fmaxv s4, p6, z15.s\n-    __ sve_fadda(v3, __ D, p7, z0);                    \/\/       fadda d3, p7, d3, z0.d\n-    __ sve_uaddv(v5, __ D, p5, z30);                   \/\/       uaddv d5, p5, z30.d\n+    __ sve_andv(v22, __ D, p7, z30);                   \/\/       andv d22, p7, z30.d\n+    __ sve_orv(v17, __ H, p4, z14);                    \/\/       orv h17, p4, z14.h\n+    __ sve_eorv(v12, __ B, p7, z20);                   \/\/       eorv b12, p7, z20.b\n+    __ sve_smaxv(v1, __ B, p3, z13);                   \/\/       smaxv b1, p3, z13.b\n+    __ sve_sminv(v7, __ S, p2, z11);                   \/\/       sminv s7, p2, z11.s\n+    __ sve_fminv(v4, __ S, p6, z15);                   \/\/       fminv s4, p6, z15.s\n+    __ sve_fmaxv(v3, __ D, p7, z0);                    \/\/       fmaxv d3, p7, z0.d\n+    __ sve_fadda(v5, __ D, p5, z30);                   \/\/       fadda d5, p5, d5, z30.d\n+    __ sve_uaddv(v13, __ H, p3, z8);                   \/\/       uaddv d13, p3, z8.h\n@@ -1227,7 +1228,7 @@\n-    0x14000000,     0x17ffffd7,     0x140003f0,     0x94000000,\n-    0x97ffffd4,     0x940003ed,     0x3400000a,     0x34fffa2a,\n-    0x34007d4a,     0x35000008,     0x35fff9c8,     0x35007ce8,\n-    0xb400000b,     0xb4fff96b,     0xb4007c8b,     0xb500001d,\n-    0xb5fff91d,     0xb5007c3d,     0x10000013,     0x10fff8b3,\n-    0x10007bd3,     0x90000013,     0x36300016,     0x3637f836,\n-    0x36307b56,     0x3758000c,     0x375ff7cc,     0x37587aec,\n+    0x14000000,     0x17ffffd7,     0x140003f1,     0x94000000,\n+    0x97ffffd4,     0x940003ee,     0x3400000a,     0x34fffa2a,\n+    0x34007d6a,     0x35000008,     0x35fff9c8,     0x35007d08,\n+    0xb400000b,     0xb4fff96b,     0xb4007cab,     0xb500001d,\n+    0xb5fff91d,     0xb5007c5d,     0x10000013,     0x10fff8b3,\n+    0x10007bf3,     0x90000013,     0x36300016,     0x3637f836,\n+    0x36307b76,     0x3758000c,     0x375ff7cc,     0x37587b0c,\n@@ -1238,13 +1239,13 @@\n-    0x540078c0,     0x54000001,     0x54fff541,     0x54007861,\n-    0x54000002,     0x54fff4e2,     0x54007802,     0x54000002,\n-    0x54fff482,     0x540077a2,     0x54000003,     0x54fff423,\n-    0x54007743,     0x54000003,     0x54fff3c3,     0x540076e3,\n-    0x54000004,     0x54fff364,     0x54007684,     0x54000005,\n-    0x54fff305,     0x54007625,     0x54000006,     0x54fff2a6,\n-    0x540075c6,     0x54000007,     0x54fff247,     0x54007567,\n-    0x54000008,     0x54fff1e8,     0x54007508,     0x54000009,\n-    0x54fff189,     0x540074a9,     0x5400000a,     0x54fff12a,\n-    0x5400744a,     0x5400000b,     0x54fff0cb,     0x540073eb,\n-    0x5400000c,     0x54fff06c,     0x5400738c,     0x5400000d,\n-    0x54fff00d,     0x5400732d,     0x5400000e,     0x54ffefae,\n-    0x540072ce,     0x5400000f,     0x54ffef4f,     0x5400726f,\n+    0x540078e0,     0x54000001,     0x54fff541,     0x54007881,\n+    0x54000002,     0x54fff4e2,     0x54007822,     0x54000002,\n+    0x54fff482,     0x540077c2,     0x54000003,     0x54fff423,\n+    0x54007763,     0x54000003,     0x54fff3c3,     0x54007703,\n+    0x54000004,     0x54fff364,     0x540076a4,     0x54000005,\n+    0x54fff305,     0x54007645,     0x54000006,     0x54fff2a6,\n+    0x540075e6,     0x54000007,     0x54fff247,     0x54007587,\n+    0x54000008,     0x54fff1e8,     0x54007528,     0x54000009,\n+    0x54fff189,     0x540074c9,     0x5400000a,     0x54fff12a,\n+    0x5400746a,     0x5400000b,     0x54fff0cb,     0x5400740b,\n+    0x5400000c,     0x54fff06c,     0x540073ac,     0x5400000d,\n+    0x54fff00d,     0x5400734d,     0x5400000e,     0x54ffefae,\n+    0x540072ee,     0x5400000f,     0x54ffef4f,     0x5400728f,\n@@ -1477,3 +1478,3 @@\n-    0x4593b271,     0x04da35a4,     0x04d83fd6,     0x045931d1,\n-    0x04083e8c,     0x040a2da1,     0x65c72967,     0x658639e4,\n-    0x65d83c03,     0x04c137c5,\n+    0x4593b271,     0x45cdb684,     0x04da3fd6,     0x045831d1,\n+    0x04193e8c,     0x04082da1,     0x048a2967,     0x658739e4,\n+    0x65c63c03,     0x65d837c5,     0x04412d0d,\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":33,"deletions":32,"binary":false,"changes":65,"status":"modified"}]}