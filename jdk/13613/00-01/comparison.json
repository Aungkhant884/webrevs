{"files":[{"patch":"@@ -52,0 +52,11 @@\n+template <typename OopT>\n+static oop read_oop_local(OopT* p) {\n+  \/\/ We can't do a native access directly from p because load barriers\n+  \/\/ may self-heal. If that happens on a base pointer for compressed oops,\n+  \/\/ then there will be a crash later on. Only the stack watermark API is\n+  \/\/ allowed to heal oops, because it heals derived pointers before their\n+  \/\/ corresponding base pointers.\n+  oop obj = RawAccess<>::oop_load(p);\n+  return NativeAccess<>::oop_load(&obj);\n+}\n+\n@@ -83,13 +94,1 @@\n-  oop val = *(oop*)addr;\n-\n-#if INCLUDE_SHENANDOAHGC\n-  if (UseShenandoahGC) {\n-    \/\/ Pass the value through the barrier to avoid capturing bad oops as\n-    \/\/ stack values. Note: do not heal the location, to avoid accidentally\n-    \/\/ corrupting the stack. Stack watermark barriers are supposed to handle\n-    \/\/ the healing.\n-    val = ShenandoahBarrierSet::barrier_set()->load_reference_barrier(val);\n-  }\n-#endif\n-\n-  return val;\n+  return read_oop_local((oop*)addr);\n@@ -120,13 +119,1 @@\n-  oop val = CompressedOops::decode(*narrow_addr);\n-\n-#if INCLUDE_SHENANDOAHGC\n-  if (UseShenandoahGC) {\n-    \/\/ Pass the value through the barrier to avoid capturing bad oops as\n-    \/\/ stack values. Note: do not heal the location, to avoid accidentally\n-    \/\/ corrupting the stack. Stack watermark barriers are supposed to handle\n-    \/\/ the healing.\n-    val = ShenandoahBarrierSet::barrier_set()->load_reference_barrier(val);\n-  }\n-#endif\n-\n-  return val;\n+  return read_oop_local((narrowOop*)addr);\n","filename":"src\/hotspot\/share\/runtime\/stackValue.cpp","additions":13,"deletions":26,"binary":false,"changes":39,"status":"modified"}]}