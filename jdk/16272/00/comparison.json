{"files":[{"patch":"@@ -272,1 +272,1 @@\n- * <h2 id=\"variable-length\">Working with variable-length structs<\/h2>\n+ * <h2 id=\"variable-length\">Working with variable-length arrays<\/h2>\n@@ -274,3 +274,74 @@\n- * Memory layouts allow clients to describe the contents of a region of memory whose size is known <em>statically<\/em>.\n- * There are, however, cases, where the size of a region of memory is only known <em>dynamically<\/em>, as it depends\n- * on the value of one or more struct fields. Consider the following struct declaration in C:\n+ * We have seen how sequence layouts are used to describe the contents of an array whose size is known <em>statically<\/em>.\n+ * There are cases, however, where the array size is only known <em>dynamically<\/em>. We call such arrays <em>variable-length arrays<\/em>.\n+ * There are two common kinds of variable-length arrays:\n+ * <ul>\n+ *     <li>a <em>toplevel<\/em> variable-length array whose size depends on the value of some unrelated variable, or parameter;<\/li>\n+ *     <li>an variable-length array <em>nested<\/em> in a struct, whose size depends on the value of some other field in the enclosing struct.<\/li>\n+ * <\/ul>\n+ * While variable-length arrays cannot be modelled directly using sequence layouts, clients can still enjoy structured\n+ * access to elements of variable-length arrays using var handles as demonstrated in the following sections.\n+ *\n+ * <h3 id=\"variable-length-toplevel\">Toplevel variable-length arrays<\/h3>\n+ *\n+ * Consider the following struct declaration in C:\n+ *\n+ * {@snippet lang=c :\n+ * typedef struct {\n+ *     int x;\n+ *     int y;\n+ * } Point;\n+ * }\n+ *\n+ * In the above code, a point is modelled as two coordinates ({@code x} and {@code y} respectively). Now consider\n+ * the following snippet of C code:\n+ *\n+ * {@snippet lang=c :\n+ * int size = ...\n+ * Point *points = (Point*)malloc(sizeof(Point) * size);\n+ * for (int i = 0 ; i < size ; i++) {\n+ *    ... points[i].x ...\n+ * }\n+ * }\n+ *\n+ * Here, we allocate an array of point ({@code points}). Crucially, the size of the array is dynamically bound to the value\n+ * of the {@code size} variable. Inside the loop, the {@code x} coordinate of all the points in the array is accessed.\n+ * <p>\n+ * To model this code in Java, let's start by defining a layout for the {@code Point} struct, as follows:\n+ *\n+ * {@snippet lang=java :\n+ * StructLayout POINT = MemoryLayout.structLayout(\n+ *             ValueLayout.JAVA_INT.withName(\"x\"),\n+ *             ValueLayout.JAVA_INT.withName(\"y\")\n+ * );\n+ * }\n+ *\n+ * Since we know we need to create and access an array of points, it would be tempting to create a sequence layout modelling\n+ * the variable-length array, and then derive the necessary access var handles from the sequence layout. But this approach\n+ * is problematic, as the size of the variable-length array is not known. Instead, a var handle that provides structured\n+ * access to the elements of a variable-length array can be obtained directly from the layout describing the array elements\n+ * (e.g. the point layout), as demonstrated below:\n+ *\n+ * {@snippet lang=java :\n+ * VarHandle POINT_ARR_X = POINT.arrayElementVarHandle(PathElement.groupElement(\"x\"));\n+ *\n+ * int size = ...\n+ * MemorySegment points = ...\n+ * for (int i = 0 ; i < size ; i++) {\n+ *     ... POINT_ARR_X.get(segment, 0L, (long)i) ...\n+ * }\n+ * }\n+ *\n+ * Here, the coordinate {@code x} of subsequent point in the array are accessed using the {@code POINT_ARR_X} var\n+ * handle, which is obtained using the {@link #arrayElementVarHandle(PathElement...)} method. This var handle\n+ * features two {@code long} coordinates: the first is a base offset (set to {@code 0L}), while the\n+ * second is a logical index that can be used to stride over all the elements of the point array.\n+ * <p>\n+ * The base offset coordinate allows clients to express complex access operations, by injecting additional offset\n+ * computation into the var handle (we will see an example of that below). In cases where the base offset is constant\n+ * (as in the previous example) clients can, if desired, drop the base offset parameter and make the access expression\n+ * simpler. This is achieved using the {@link java.lang.invoke.MethodHandles#insertCoordinates(VarHandle, int, Object...)}\n+ * var handle adapter.\n+ *\n+ * <h3 id=\"variable-length-nested\">Nested variable-length arrays<\/h3>\n+ *\n+ * Consider the following struct declaration in C:\n@@ -281,4 +352,1 @@\n- *     struct {\n- *         int x;\n- *         int y;\n- *     } points[];\n+ *     Point points[];\n@@ -293,3 +361,2 @@\n- * Memory layouts do not support sequence layouts whose size is unknown. As such, it is not possible to model\n- * the above struct directly. That said, clients can still enjoy structured access provided by memory layouts, as\n- * demonstrated below:\n+ * Again, clients can perform structured access to elements in the nested variable-length array using the\n+ * {@link #arrayElementVarHandle(PathElement...)} method, as demonstrated below:\n@@ -298,5 +365,0 @@\n- * StructLayout POINT = MemoryLayout.structLayout(\n- *             ValueLayout.JAVA_INT.withName(\"x\"),\n- *             ValueLayout.JAVA_INT.withName(\"y\")\n- * );\n- *\n@@ -309,1 +371,0 @@\n- * VarHandle POINT_X = POINT.varHandle(PathElement.groupElement(\"x\"));\n@@ -313,6 +374,4 @@\n- * Note how we have split the polygon struct in two. The {@code POLYGON} layout contains a sequence layout\n- * of size <em>zero<\/em>. The element layout of the sequence layout is the {@code POINT} layout, which defines\n- * the {@code x} and {@code y} coordinates, accordingly. The first layout is used to obtain a var handle\n- * that provides access to the polygon size; the second layout is used to obtain a var handle that provides\n- * access to the {@code x} coordinate of a point struct. Finally, an offset to the start of the variable-length\n- * {@code points} array is also obtained.\n+ * The {@code POLYGON} layout contains a sequence layout of size <em>zero<\/em>. The element layout of the sequence layout\n+ * is the {@code POINT} layout, shown previously. The polygon layout is used to obtain a var handle\n+ * that provides access to the polygon size, as well as an offset ({@code POINTS_OFFSET}) to the start of the\n+ * variable-length {@code points} array.\n@@ -325,1 +384,1 @@\n- *     int x = POINT_X.get(polygon, POINT.scaleOffset(POINTS_OFFSET, i));\n+ *     ... POINT_ARR_X.get(polygon, POINTS_OFFSET, (long)i) ...\n@@ -329,3 +388,4 @@\n- * the {@code x} coordinates of all the points in the polygon. This is done by providing a custom base offset to\n- * the {@code POINT_X} var handle. The custom offset is computed as {@code POINTS_OFFSET + (i * POINT.byteSize())}, where\n- * {@code i} is the loop induction variable.\n+ * the {@code x} coordinates of all the points in the polygon. This is done by providing a custom offset\n+ * (namely, {@code POINTS_OFFSET}) to the offset coordinate of the {@code POINT_ARR_X} var handle. As before,\n+ * the loop induction variable {@code i} is passed as the index of the {@code POINT_ARR_X} var handle,\n+ * to stride over all the elements of the variable-length array.\n@@ -547,0 +607,43 @@\n+    \/**\n+     * Creates a var handle that accesses adjacent elements in a memory segment at offsets selected by the given layout path,\n+     * where the accessed elements have this layout, and where the initial layout in the path is this layout.\n+     * <p>\n+     * The returned var handle has the following characteristics:\n+     * <ul>\n+     *     <li>its type is derived from the {@linkplain ValueLayout#carrier() carrier} of the\n+     *     selected value layout;<\/li>\n+     *     <li>it has a leading parameter of type {@code MemorySegment} representing the accessed segment<\/li>\n+     *     <li>a following {@code long} parameter, corresponding to the base offset, denoted as {@code B};<\/li>\n+     *     <li>a following {@code long} parameter, corresponding to the array index, denoted as {@code I0}. The array\n+     *     index is used to scale the accessed offset by this layout size;<\/li>\n+     *     <li>it has zero or more trailing access coordinates of type {@code long}, one for each\n+     *     <a href=#open-path-elements>open path element<\/a> in the provided layout path, denoted as\n+     *     {@code I1, I2, ... In}, respectively. The order of these access coordinates corresponds to the order\n+     *     in which the open path elements occur in the provided layout path.\n+     * <\/ul>\n+     * <p>\n+     * If the provided layout path {@code P} contains no dereference elements, then the offset {@code O} of the access\n+     * operation is computed as follows:\n+     *\n+     * {@snippet lang = \"java\":\n+     * O = this.offsetHandle(P).invokeExact(this.scale(B, I0), I1, I2, ... In);\n+     * }\n+     * <p>\n+     * More formally, this method can be obtained from the {@link #varHandle(PathElement...)}, as follows:\n+     * {@snippet lang = \"java\":\n+     * MethodHandles.collectCoordinates(varHandle(elements), 1, scaleHandle())\n+     * }\n+     *\n+     * @apiNote\n+     * As the leading index coordinate {@code I0} is not bound by any sequence layout, it can assume <em>any<\/em> non-negative\n+     * value - provided that the resulting offset computation does not overflow, or that the computed offset does not fall\n+     * outside the spatial bound of the accessed memory segment. As such, the var handles returned from this method can\n+     * be especially useful when accessing <a href=\"#variable-length\">variable-length arrays<\/a>.\n+     *\n+     * @param elements the layout path elements.\n+     * @return a var handle that accesses adjacent elements in a memory segment at offsets selected by the given layout path.\n+     * @throws IllegalArgumentException if the layout path is not <a href=\"#well-formedness\">well-formed<\/a> for this layout.\n+     * @throws IllegalArgumentException if the layout selected by the provided path is not a {@linkplain ValueLayout value layout}.\n+     *\/\n+    VarHandle arrayElementVarHandle(PathElement... elements);\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":130,"deletions":27,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n@@ -49,2 +47,0 @@\n-import jdk.internal.foreign.StringSupport;\n-import jdk.internal.foreign.Utils;\n@@ -137,3 +133,1 @@\n- * The var handle returned by {@link ValueLayout#varHandle()} features a <em>base offset<\/em> parameter. This parameter\n- * allows clients to express complex access operations, by injecting additional offset computation into the var handle.\n- * For instance, a var handle that can be used to access an element of an {@code int} array at a given logical\n+ * Alternatively, a var handle that can be used to access an element of an {@code int} array at a given logical\n@@ -143,1 +137,1 @@\n- * MethodHandle scale = ValueLayout.JAVA_INT.scaleHandle();              \/\/ (long, long)long\n+ * MethodHandle scale = ValueLayout.JAVA_INT.scaleHandle();\n@@ -145,2 +139,2 @@\n- *         MethodHandles.collectCoordinates(intAtOffsetHandle, 1, scale); \/\/ (MemorySegment, long, long)\n- * int value = (int) intAtOffsetAndIndexHandle.get(segment, 2L, 3L);     \/\/ segment.get(ValueLayout.JAVA_INT, 2L + (3L * 4L))\n+ *         ValueLayout.JAVA_INT.arrayElementVarHandle();             \/\/ (MemorySegment, long, long)\n+ * int value = (int) intAtOffsetAndIndexHandle.get(segment, 2L, 3L); \/\/ segment.get(ValueLayout.JAVA_INT, 2L + (3L * 4L))\n@@ -151,1 +145,1 @@\n- * implement access operation such as {@link #getAtIndex(OfInt, long)}:\n+ * implement access operations such as {@link #getAtIndex(OfInt, long)}:\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -199,0 +199,4 @@\n+    public VarHandle arrayElementVarHandle(PathElement... elements) {\n+        return MethodHandles.collectCoordinates(varHandle(elements), 1, scaleHandle());\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractLayout.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -85,2 +85,2 @@\n-    static final VarHandle intHandleIndexed = MethodHandles.collectCoordinates(ValueLayout.JAVA_INT.varHandle(),\n-            1, MethodHandles.insertArguments(ValueLayout.JAVA_INT.scaleHandle(), 0, 0L));\n+    static final VarHandle intHandleIndexed = MethodHandles.insertCoordinates(\n+            ValueLayout.JAVA_INT.arrayElementVarHandle(), 1, 0L);\n","filename":"test\/jdk\/java\/foreign\/TestAdaptVarHandles.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -295,2 +295,1 @@\n-        return MethodHandles.collectCoordinates(layout.varHandle(),\n-                1, MethodHandles.insertArguments(layout.scaleHandle(), 0, 0L));\n+        return MethodHandles.insertCoordinates(layout.arrayElementVarHandle(), 1, 0L);\n","filename":"test\/jdk\/java\/foreign\/TestArrayCopy.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,2 +47,1 @@\n-        return MethodHandles.collectCoordinates(layout.varHandle(),\n-            1, MethodHandles.insertArguments(layout.scaleHandle(), 0, 0L));\n+        return MethodHandles.insertCoordinates(layout.arrayElementVarHandle(), 1, 0L);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/JavaLayouts.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}