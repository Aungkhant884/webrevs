{"files":[{"patch":"@@ -24,2 +24,0 @@\n-import static java.lang.String.format;\n-\n@@ -42,0 +40,3 @@\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n@@ -44,0 +45,6 @@\n+import static java.lang.String.format;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertThrows;\n+import static org.testng.Assert.assertTrue;\n+\n@@ -48,1 +55,1 @@\n- * @run main TransferTo\n+ * @run testng TransferTo\n@@ -62,9 +69,12 @@\n-    public static void main(String[] args) throws Exception {\n-        test(fileChannelInput(), fileChannelOutput());\n-        test(readableByteChannelInput(), defaultOutput());\n-    }\n-\n-    private static void test(InputStreamProvider inputStreamProvider, OutputStreamProvider outputStreamProvider)\n-            throws Exception {\n-        testNullPointerException(inputStreamProvider);\n-        testStreamContents(inputStreamProvider, outputStreamProvider);\n+    \/*\n+     * Provides test scenarios, i. e. combinations of input and output streams to be tested.\n+     *\/\n+    @DataProvider\n+    public static Object[][] streamCombinations() throws Exception {\n+        return new Object[][] {\n+            \/\/ tests FileChannel.transferTo(FileChannel) optimized case\n+            { fileChannelInput(), fileChannelOutput() },\n+\n+            \/\/ tests InputStream.transferTo(OutputStream) default case\n+            { readableByteChannelInput(), defaultOutput() }\n+        };\n@@ -73,4 +83,8 @@\n-    private static void testNullPointerException(InputStreamProvider inputStreamProvider) throws Exception {\n-        try (InputStream in = inputStreamProvider.input()) {\n-            assertThrowsNPE(() -> in.transferTo(null), \"out\");\n-        }\n+    \/*\n+     * Testing API compliance: Input stream must throw NullPointerException when parameter \"out\" is null.\n+     *\/\n+    @Test(dataProvider = \"streamCombinations\")\n+    public void testNullPointerException(InputStreamProvider inputStreamProvider,\n+            OutputStreamProvider outputStreamProvider) throws Exception {\n+        \/\/ tests empty input stream\n+        assertThrows(NullPointerException.class, () -> inputStreamProvider.input().transferTo(null));\n@@ -78,3 +92,2 @@\n-        try (InputStream in = inputStreamProvider.input((byte) 1)) {\n-            assertThrowsNPE(() -> in.transferTo(null), \"out\");\n-        }\n+        \/\/ tests single-byte input stream\n+        assertThrows(NullPointerException.class, () -> inputStreamProvider.input((byte) 1).transferTo(null));\n@@ -82,3 +95,2 @@\n-        try (InputStream in = inputStreamProvider.input((byte) 1, (byte) 2)) {\n-            assertThrowsNPE(() -> in.transferTo(null), \"out\");\n-        }\n+        \/\/ tests dual-byte input stream\n+        assertThrows(NullPointerException.class, () -> inputStreamProvider.input((byte) 1, (byte) 2).transferTo(null));\n@@ -87,1 +99,5 @@\n-    private static void testStreamContents(InputStreamProvider inputStreamProvider,\n+    \/*\n+     * Testing API compliance: Complete content of input stream must be transferred to output stream.\n+     *\/\n+    @Test(dataProvider = \"streamCombinations\")\n+    public void testStreamContents(InputStreamProvider inputStreamProvider,\n@@ -89,0 +105,1 @@\n+        \/\/ tests empty input stream\n@@ -90,0 +107,2 @@\n+\n+        \/\/ tests input stream with a length between 1k and 4k\n@@ -92,1 +111,1 @@\n-        \/\/ to span through several batches\n+        \/\/ tests input stream with several data chunks, as 16k is more than a single chunk can hold\n@@ -95,1 +114,1 @@\n-        \/\/ randomly chosen starting positions within source and target\n+        \/\/ tests randomly chosen starting positions within source and target stream\n@@ -103,1 +122,1 @@\n-        \/\/ beyond source EOF\n+        \/\/ tests reading beyond source EOF (must not transfer any bytes)\n@@ -106,1 +125,1 @@\n-        \/\/ beyond target EOF\n+        \/\/ tests writing beyond target EOF (must extend output stream)\n@@ -110,0 +129,5 @@\n+    \/*\n+     * Asserts that the transferred content is correct, i. e. compares the actually transferred bytes\n+     * to the expected assumption. The position of the input and output stream before the transfer is\n+     * the start of stream (BOF).\n+     *\/\n@@ -115,0 +139,5 @@\n+    \/*\n+     * Asserts that the transferred content is correct, i. e. compares the actually transferred bytes\n+     * to the expected assumption. The position of the input and output stream before the transfer is\n+     * provided by the caller.\n+     *\/\n@@ -127,3 +156,1 @@\n-            if (reported != count)\n-                throw new AssertionError(\n-                        format(\"reported %d bytes but should report %d\", reported, count));\n+            assertEquals(reported, count, format(\"reported %d bytes but should report %d\", reported, count));\n@@ -132,3 +159,2 @@\n-            if (!Arrays.equals(inBytes, posIn, posIn + count, outBytes, posOut, posOut + count))\n-                throw new AssertionError(\n-                        format(\"inBytes.length=%d, outBytes.length=%d\", count, outBytes.length));\n+            assertTrue(Arrays.equals(inBytes, posIn, posIn + count, outBytes, posOut, posOut + count),\n+                format(\"inBytes.length=%d, outBytes.length=%d\", count, outBytes.length));\n@@ -138,0 +164,3 @@\n+    \/*\n+     * Creates an array of random size (between min and min + maxRandomAdditive) filled with random bytes\n+     *\/\n@@ -152,0 +181,3 @@\n+    \/*\n+     * Creates a provider for an output stream which does not wrap a channel\n+     *\/\n@@ -163,0 +195,3 @@\n+    \/*\n+     * Creates a provider for an input stream which wraps a file channel\n+     *\/\n@@ -175,0 +210,3 @@\n+    \/*\n+     * Creates a provider for an input stream which wraps a readable byte channel but is not a file channel\n+     *\/\n@@ -184,0 +222,3 @@\n+    \/*\n+     * Creates a provider for an output stream which wraps a file channel\n+     *\/\n@@ -201,27 +242,0 @@\n-    public interface Thrower {\n-        public void run() throws Throwable;\n-    }\n-\n-    public static void assertThrowsNPE(Thrower thrower, String message) {\n-        assertThrows(thrower, NullPointerException.class, message);\n-    }\n-\n-    public static <T extends Throwable> void assertThrows(Thrower thrower, Class<T> throwable, String message) {\n-        Throwable thrown;\n-        try {\n-            thrower.run();\n-            thrown = null;\n-        } catch (Throwable caught) {\n-            thrown = caught;\n-        }\n-\n-        if (!throwable.isInstance(thrown)) {\n-            String caught = thrown == null ? \"nothing\" : thrown.getClass().getCanonicalName();\n-            throw new AssertionError(format(\"Expected to catch %s, but caught %s\", throwable, caught), thrown);\n-        }\n-\n-        if (thrown != null && !message.equals(thrown.getMessage())) {\n-            throw new AssertionError(\n-                    format(\"Expected exception message to be '%s', but it's '%s'\", message, thrown.getMessage()));\n-        }\n-    }\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/TransferTo.java","additions":74,"deletions":60,"binary":false,"changes":134,"status":"modified"}]}