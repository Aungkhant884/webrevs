{"files":[{"patch":"@@ -2262,0 +2262,2 @@\n+  \/\/ handles frames until vf->sender() is null.\n+  bool process_frames(vframe* vf);\n@@ -2370,0 +2372,11 @@\n+bool StackRefCollector::process_frames(vframe* vf) {\n+  while (vf != nullptr) {\n+    if (!do_frame(vf)) {\n+      return false;\n+    }\n+    vf = vf->sender();\n+  }\n+  return true;\n+}\n+\n+\n@@ -2798,1 +2811,0 @@\n-\n@@ -2802,1 +2814,0 @@\n-\n@@ -2807,37 +2818,5 @@\n-  } else {\n-    \/\/ vframes are resource allocated\n-    Thread* current_thread = Thread::current();\n-    ResourceMark rm(current_thread);\n-    HandleMark hm(current_thread);\n-\n-    \/\/ first handle mounted vthread (if any)\n-    if (mounted_vt != nullptr) {\n-      RegisterMap reg_map(java_thread,\n-                          RegisterMap::UpdateMap::include,\n-                          RegisterMap::ProcessFrames::include,\n-                          RegisterMap::WalkContinuation::skip);\n-\n-      frame f = java_thread->last_frame();\n-      vframe* vf = vframe::new_vframe(&f, &reg_map, java_thread);\n-      \/\/ report virtual thread as JVMTI_HEAP_REFERENCE_OTHER.\n-      if (!stack_collector.set_thread(JVMTI_HEAP_REFERENCE_OTHER, mounted_vt)) {\n-        return false;\n-      }\n-      \/\/ split virtual thread and carrier thread stacks by vthread entry (\"enterSpecial\") frame,\n-      \/\/ consider vthread entry frame as the last vthread stack frame.\n-      while (vf != nullptr) {\n-        if (!stack_collector.do_frame(vf)) {\n-          return false;\n-        }\n-        if (vf->is_vthread_entry()) {\n-          break;\n-        }\n-        vf = vf->sender();\n-      }\n-    }\n-\n-    \/\/ Platform or carrier thread\n-    RegisterMap reg_map(java_thread,\n-                        RegisterMap::UpdateMap::include,\n-                        RegisterMap::ProcessFrames::include,\n-                        RegisterMap::WalkContinuation::skip);\n+  }\n+  \/\/ vframes are resource allocated\n+  Thread* current_thread = Thread::current();\n+  ResourceMark rm(current_thread);\n+  HandleMark hm(current_thread);\n@@ -2845,2 +2824,11 @@\n-    vframe* vf = JvmtiEnvBase::get_cthread_last_java_vframe(java_thread, &reg_map);\n-    if (!stack_collector.set_thread(JVMTI_HEAP_REFERENCE_THREAD, threadObj)) {\n+  RegisterMap reg_map(java_thread,\n+                      RegisterMap::UpdateMap::include,\n+                      RegisterMap::ProcessFrames::include,\n+                      RegisterMap::WalkContinuation::include);\n+\n+  \/\/ first handle mounted vthread (if any).\n+  if (mounted_vt != nullptr) {\n+    frame f = java_thread->last_frame();\n+    vframe* vf = vframe::new_vframe(&f, &reg_map, java_thread);\n+    \/\/ report virtual thread as JVMTI_HEAP_REFERENCE_OTHER.\n+    if (!stack_collector.set_thread(JVMTI_HEAP_REFERENCE_OTHER, mounted_vt)) {\n@@ -2849,0 +2837,2 @@\n+    \/\/ split virtual thread and carrier thread stacks by vthread entry (\"enterSpecial\") frame,\n+    \/\/ consider vthread entry frame as the last vthread stack frame.\n@@ -2853,0 +2843,3 @@\n+      if (vf->is_vthread_entry()) {\n+        break;\n+      }\n@@ -2856,2 +2849,6 @@\n-\n-  return true;\n+  \/\/ Platform or carrier thread.\n+  vframe* vf = JvmtiEnvBase::get_cthread_last_java_vframe(java_thread, &reg_map);\n+  if (!stack_collector.set_thread(JVMTI_HEAP_REFERENCE_THREAD, threadObj)) {\n+    return false;\n+  }\n+  return stack_collector.process_frames(vf);\n@@ -2910,7 +2907,1 @@\n-  while (vf != nullptr) {\n-    if (!stack_collector.do_frame(vf)) {\n-      return false;\n-    }\n-    vf = vf->sender();\n-  }\n-  return true;\n+  return stack_collector.process_frames(vf);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":41,"deletions":50,"binary":false,"changes":91,"status":"modified"}]}