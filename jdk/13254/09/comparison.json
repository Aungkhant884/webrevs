{"files":[{"patch":"@@ -52,0 +52,1 @@\n+#include \"runtime\/continuationWrapper.inline.hpp\"\n@@ -63,0 +64,1 @@\n+#include \"runtime\/stackChunkFrameStream.inline.hpp\"\n@@ -2228,0 +2230,132 @@\n+\/\/ Helper class to collect\/report stack roots.\n+class StackRootCollector {\n+private:\n+  JvmtiTagMap* _tag_map;\n+  JNILocalRootsClosure* _blk;\n+  \/\/ java_thread is needed only to report JNI local on top native frame;\n+  \/\/ I.e. it's required only for platform\/carrier threads or mounted virtual threads.\n+  JavaThread* _java_thread;\n+\n+  oop _threadObj;\n+  jlong _thread_tag;\n+  jlong _tid;\n+\n+  bool _is_top_frame;\n+  int _depth;\n+  frame* _last_entry_frame;\n+\n+  bool report_stack_refs(StackValueCollection* values, jmethodID method, jlocation bci, jint slot_offset);\n+\n+public:\n+  StackRootCollector(JvmtiTagMap* tag_map, JNILocalRootsClosure* blk, JavaThread* java_thread)\n+    : _tag_map(tag_map), _blk(blk), _java_thread(java_thread),\n+      _threadObj(nullptr), _thread_tag(0), _tid(0),\n+      _is_top_frame(true), _depth(0), _last_entry_frame(nullptr)\n+  {\n+  }\n+\n+  bool set_thread(oop o);\n+  \/\/ sets the thread and reports the reference to it with the specified kind.\n+  bool set_thread(jvmtiHeapReferenceKind kind, oop o);\n+\n+  bool do_frame(vframe* vf);\n+};\n+\n+bool StackRootCollector::set_thread(oop o) {\n+  _threadObj = o;\n+  _thread_tag = tag_for(_tag_map, _threadObj);\n+  _tid = java_lang_Thread::thread_id(_threadObj);\n+\n+  _is_top_frame = true;\n+  _depth = 0;\n+  _last_entry_frame = nullptr;\n+\n+  return true;\n+}\n+\n+bool StackRootCollector::set_thread(jvmtiHeapReferenceKind kind, oop o) {\n+  return set_thread(o)\n+         && CallbackInvoker::report_simple_root(kind, _threadObj);\n+}\n+\n+bool StackRootCollector::report_stack_refs(StackValueCollection* values, jmethodID method, jlocation bci, jint slot_offset) {\n+  for (int index = 0; index < values->size(); index++) {\n+    if (values->at(index)->type() == T_OBJECT) {\n+      oop o = values->obj_at(index)();\n+      if (o == nullptr) {\n+        continue;\n+      }\n+\n+      \/\/ stack reference\n+      if (!CallbackInvoker::report_stack_ref_root(_thread_tag, _tid, _depth, method,\n+                                                  bci, slot_offset + index, o)) {\n+        return false;\n+      }\n+    }\n+  }\n+  return true;\n+}\n+\n+bool StackRootCollector::do_frame(vframe* vf) {\n+  if (vf->is_java_frame()) {\n+    \/\/ java frame (interpreted, compiled, ...)\n+    javaVFrame* jvf = javaVFrame::cast(vf);\n+\n+    \/\/ the jmethodID\n+    jmethodID method = jvf->method()->jmethod_id();\n+\n+    if (!(jvf->method()->is_native())) {\n+      jlocation bci = (jlocation)jvf->bci();\n+      StackValueCollection* locals = jvf->locals();\n+      if (!report_stack_refs(locals, method, bci, 0)) {\n+        return false;\n+      }\n+      if (!report_stack_refs(jvf->expressions(), method, bci, locals->size())) {\n+        return false;\n+      }\n+\n+      \/\/ Follow oops from compiled nmethod\n+      if (jvf->cb() != nullptr && jvf->cb()->is_nmethod()) {\n+        _blk->set_context(_thread_tag, _tid, _depth, method);\n+        jvf->cb()->as_nmethod()->oops_do(_blk);\n+        if (_blk->stopped()) {\n+          return false;\n+        }\n+      }\n+    } else {\n+      \/\/ native frame\n+      _blk->set_context(_thread_tag, _tid, _depth, method);\n+      if (_is_top_frame) {\n+        \/\/ JNI locals for the top frame.\n+        assert(_java_thread != nullptr, \"sanity\");\n+        _java_thread->active_handles()->oops_do(_blk);\n+        if (_blk->stopped()) {\n+          return false;\n+        }\n+      } else {\n+        if (_last_entry_frame != nullptr) {\n+          \/\/ JNI locals for the entry frame\n+          assert(_last_entry_frame->is_entry_frame(), \"checking\");\n+          _last_entry_frame->entry_frame_call_wrapper()->handles()->oops_do(_blk);\n+          if (_blk->stopped()) {\n+            return false;\n+          }\n+        }\n+      }\n+    }\n+    _last_entry_frame = nullptr;\n+    _depth++;\n+  } else {\n+    \/\/ externalVFrame - for an entry frame then we report the JNI locals\n+    \/\/ when we find the corresponding javaVFrame\n+    frame* fr = vf->frame_pointer();\n+    assert(fr != nullptr, \"sanity check\");\n+    if (fr->is_entry_frame()) {\n+      _last_entry_frame = fr;\n+    }\n+  }\n+\n+  _is_top_frame = false;\n+\n+  return true;\n+}\n@@ -2292,0 +2426,1 @@\n+  inline bool collect_vthread_stack_roots(oop vt);\n@@ -2640,2 +2775,3 @@\n-\/\/ Walk the stack of a given thread and find all references (locals\n-\/\/ and JNI calls) and report these as stack references\n+\/\/ Reports the thread as JVMTI_HEAP_REFERENCE_THREAD,\n+\/\/ walks the stack of the thread, finds all references (locals\n+\/\/ and JNI calls) and reports these as stack references\n@@ -2646,0 +2782,4 @@\n+  oop mounted_vt = java_thread->is_vthread_mounted() ? java_thread->vthread() : nullptr;\n+  if (mounted_vt != nullptr && !JvmtiEnvBase::is_vthread_alive(mounted_vt)) {\n+    mounted_vt = nullptr;\n+  }\n@@ -2648,5 +2788,1 @@\n-  \/\/ only need to get the thread's tag once per thread\n-  jlong thread_tag = tag_for(_tag_map, threadObj);\n-\n-  \/\/ also need the thread id\n-  jlong tid = java_lang_Thread::thread_id(threadObj);\n+  StackRootCollector stack_collector(tag_map(), blk, java_thread);\n@@ -2654,0 +2790,1 @@\n+  if (!java_thread->has_last_Java_frame()) {\n@@ -2655,1 +2792,3 @@\n-  if (java_thread->has_last_Java_frame()) {\n+    if (!stack_collector.set_thread(JVMTI_HEAP_REFERENCE_THREAD, threadObj)) {\n+        return false;\n+    }\n@@ -2657,0 +2796,5 @@\n+    \/\/ no last java frame but there may be JNI locals\n+    blk->set_context(tag_for(_tag_map, threadObj), java_lang_Thread::thread_id(threadObj), 0, (jmethodID)nullptr);\n+    java_thread->active_handles()->oops_do(blk);\n+    return !blk->stopped();\n+  } else {\n@@ -2662,0 +2806,27 @@\n+    \/\/ first handle mounted vthread (if any)\n+    if (mounted_vt != nullptr) {\n+      RegisterMap reg_map(java_thread,\n+                          RegisterMap::UpdateMap::include,\n+                          RegisterMap::ProcessFrames::include,\n+                          RegisterMap::WalkContinuation::skip);\n+\n+      frame f = java_thread->last_frame();\n+      vframe* vf = vframe::new_vframe(&f, &reg_map, java_thread);\n+      \/\/ report virtual thread as JVMTI_HEAP_REFERENCE_OTHER.\n+      if (!stack_collector.set_thread(JVMTI_HEAP_REFERENCE_OTHER, mounted_vt)) {\n+        return false;\n+      }\n+      \/\/ split virtual thread and carrier thread stacks by vthread entry (\"enterSpecial\") frame,\n+      \/\/ consider vthread entry frame as the last vthread stack frame.\n+      while (vf != nullptr) {\n+        if (!stack_collector.do_frame(vf)) {\n+          return false;\n+        }\n+        if (vf->is_vthread_entry()) {\n+          break;\n+        }\n+        vf = vf->sender();\n+      }\n+    }\n+\n+    \/\/ Platform or carrier thread\n@@ -2666,6 +2837,0 @@\n-    frame f = java_thread->last_frame();\n-    vframe* vf = vframe::new_vframe(&f, &reg_map, java_thread);\n-\n-    bool is_top_frame = true;\n-    int depth = 0;\n-    frame* last_entry_frame = nullptr;\n@@ -2673,0 +2838,4 @@\n+    vframe* vf = JvmtiEnvBase::get_cthread_last_java_vframe(java_thread, &reg_map);\n+    if (!stack_collector.set_thread(JVMTI_HEAP_REFERENCE_THREAD, threadObj)) {\n+      return false;\n+    }\n@@ -2674,70 +2843,2 @@\n-      if (vf->is_java_frame()) {\n-\n-        \/\/ java frame (interpreted, compiled, ...)\n-        javaVFrame *jvf = javaVFrame::cast(vf);\n-\n-        \/\/ the jmethodID\n-        jmethodID method = jvf->method()->jmethod_id();\n-\n-        if (!(jvf->method()->is_native())) {\n-          jlocation bci = (jlocation)jvf->bci();\n-          StackValueCollection* locals = jvf->locals();\n-          for (int slot=0; slot<locals->size(); slot++) {\n-            if (locals->at(slot)->type() == T_OBJECT) {\n-              oop o = locals->obj_at(slot)();\n-              if (o == nullptr) {\n-                continue;\n-              }\n-\n-              \/\/ stack reference\n-              if (!CallbackInvoker::report_stack_ref_root(thread_tag, tid, depth, method,\n-                                                   bci, slot, o)) {\n-                return false;\n-              }\n-            }\n-          }\n-\n-          StackValueCollection* exprs = jvf->expressions();\n-          for (int index=0; index < exprs->size(); index++) {\n-            if (exprs->at(index)->type() == T_OBJECT) {\n-              oop o = exprs->obj_at(index)();\n-              if (o == nullptr) {\n-                continue;\n-              }\n-\n-              \/\/ stack reference\n-              if (!CallbackInvoker::report_stack_ref_root(thread_tag, tid, depth, method,\n-                                                   bci, locals->size() + index, o)) {\n-                return false;\n-              }\n-            }\n-          }\n-\n-          \/\/ Follow oops from compiled nmethod\n-          if (jvf->cb() != nullptr && jvf->cb()->is_nmethod()) {\n-            blk->set_context(thread_tag, tid, depth, method);\n-            jvf->cb()->as_nmethod()->oops_do(blk);\n-          }\n-        } else {\n-          blk->set_context(thread_tag, tid, depth, method);\n-          if (is_top_frame) {\n-            \/\/ JNI locals for the top frame.\n-            java_thread->active_handles()->oops_do(blk);\n-          } else {\n-            if (last_entry_frame != nullptr) {\n-              \/\/ JNI locals for the entry frame\n-              assert(last_entry_frame->is_entry_frame(), \"checking\");\n-              last_entry_frame->entry_frame_call_wrapper()->handles()->oops_do(blk);\n-            }\n-          }\n-        }\n-        last_entry_frame = nullptr;\n-        depth++;\n-      } else {\n-        \/\/ externalVFrame - for an entry frame then we report the JNI locals\n-        \/\/ when we find the corresponding javaVFrame\n-        frame* fr = vf->frame_pointer();\n-        assert(fr != nullptr, \"sanity check\");\n-        if (fr->is_entry_frame()) {\n-          last_entry_frame = fr;\n-        }\n+      if (!stack_collector.do_frame(vf)) {\n+        return false;\n@@ -2745,1 +2846,0 @@\n-\n@@ -2747,1 +2847,0 @@\n-      is_top_frame = false;\n@@ -2749,4 +2848,0 @@\n-  } else {\n-    \/\/ no last java frame but there may be JNI locals\n-    blk->set_context(thread_tag, tid, 0, (jmethodID)nullptr);\n-    java_thread->active_handles()->oops_do(blk);\n@@ -2754,0 +2849,1 @@\n+\n@@ -2766,6 +2862,0 @@\n-      \/\/ Collect the simple root for this thread before we\n-      \/\/ collect its stack roots\n-      if (!CallbackInvoker::report_simple_root(JVMTI_HEAP_REFERENCE_THREAD,\n-                                               threadObj)) {\n-        return false;\n-      }\n@@ -2780,0 +2870,48 @@\n+\/\/ Reports the unmounted virtual thread as JVMTI_HEAP_REFERENCE_THREAD,\n+\/\/ walks the stack of the thread, finds all references (locals\n+\/\/ and JNI calls) and reports these as stack references.\n+inline bool VM_HeapWalkOperation::collect_vthread_stack_roots(oop vt) {\n+  if (!JvmtiEnvBase::is_vthread_alive(vt)) {\n+    return true;\n+  }\n+  ContinuationWrapper c(java_lang_VirtualThread::continuation(vt));\n+  if (c.is_empty()) {\n+    return true;\n+  }\n+  assert(!c.is_mounted(), \"sanity check\");\n+\n+  stackChunkOop chunk = c.last_nonempty_chunk();\n+  if (chunk == nullptr || chunk->is_empty()) {\n+    return true;\n+  }\n+\n+  \/\/ vframes are resource allocated\n+  Thread* current_thread = Thread::current();\n+  ResourceMark rm(current_thread);\n+  HandleMark hm(current_thread);\n+\n+  StackChunkFrameStream<ChunkFrames::Mixed> fs(chunk);\n+  RegisterMap reg_map(nullptr,\n+                      RegisterMap::UpdateMap::include,\n+                      RegisterMap::ProcessFrames::include,\n+                      RegisterMap::WalkContinuation::include);\n+  fs.initialize_register_map(&reg_map);\n+\n+  JNILocalRootsClosure blk;\n+  \/\/ JavaThread is not required for unmounted virtual threads\n+  StackRootCollector stack_collector(tag_map(), &blk, nullptr);\n+  \/\/ reference to the vthread is already reported.\n+  if (!stack_collector.set_thread(vt)) {\n+    return false;\n+  }\n+\n+  for (; !fs.is_done(); fs.next(&reg_map)) {\n+    frame fr = fs.to_frame();\n+    vframe* vf = vframe::new_vframe(&fr, &reg_map, nullptr);\n+    if (!stack_collector.do_frame(vf)) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -2798,0 +2936,5 @@\n+      if (is_advanced_heap_walk() && java_lang_VirtualThread::is_subclass(o->klass())) {\n+        if (!collect_vthread_stack_roots(o)) {\n+          return false;\n+        }\n+      }\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":239,"deletions":96,"binary":false,"changes":335,"status":"modified"},{"patch":"@@ -0,0 +1,249 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test id=default\n+ * @requires vm.jvmti\n+ * @requires vm.continuations\n+ * @enablePreview\n+ * @run main\/othervm\/native\n+ *      -Djdk.virtualThreadScheduler.parallelism=1\n+ *      -agentlib:VThreadStackRefTest\n+ *      VThreadStackRefTest\n+ *\/\n+\n+\/**\n+ * @test id=no-vmcontinuations\n+ * @requires vm.jvmti\n+ * @enablePreview\n+ * @run main\/othervm\/native\n+ *      -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations\n+ *      -Djdk.virtualThreadScheduler.parallelism=1\n+ *      -agentlib:VThreadStackRefTest\n+ *      VThreadStackRefTest NoMountCheck\n+ *\/\n+\n+import java.lang.ref.Reference;\n+import java.util.stream.Stream;\n+import java.util.concurrent.CountDownLatch;\n+\n+\/*\n+ * The test verifies JVMTI FollowReferences function reports references from\n+ * mounted and unmounted virtual threads and reports correct thread id\n+ * (for mounted vthread it should be vthread id, and not carrier thread id).\n+ * Additionally tests that references from platform threads are reported correctly\n+ * and that references from terminated vthread are not reported.\n+ * To get both mounted and unmounted vthreads the test:\n+ * - limits the number of carrier threads to 1;\n+ * - starts vthread that creates a stack local and JNI local\n+ *   and then waits in CountDownLatch.await();\n+ * - starts another vthread that create stack local and JNI local (on top frame)\n+ *   and waits in native to avoid unmounting.\n+ *\/\n+public class VThreadStackRefTest {\n+\n+    \/\/ Currently we cannot test JNI locals for unmounted threads\n+    \/\/ as native calls pin virtual thread.\n+    \/\/ TODO: revise if this changes.\n+    static final boolean testUnmountedJNILocals = false;\n+\n+    \/\/ The flag is set by createObjAndWait method.\n+    static volatile boolean mountedVthreadReady = false;\n+\n+    public static void main(String[] args) throws InterruptedException {\n+        boolean noMountCheck = args.length > 0\n+                               && args[0].equalsIgnoreCase(\"NoMountCheck\");\n+        CountDownLatch dumpedLatch = new CountDownLatch(1);\n+\n+        CountDownLatch unmountedThreadReady = new CountDownLatch(1);\n+        \/\/ Unmounted virtual thread with stack local.\n+        Thread vthreadUnmounted = Thread.ofVirtual().start(() -> {\n+            Object referenced = new VThreadUnmountedReferenced();\n+            System.out.println(\"created \" + referenced.getClass());\n+            if (testUnmountedJNILocals) {\n+                createObjAndCallback(VThreadUnmountedJNIReferenced.class,\n+                    new Runnable() {\n+                        public void run() {\n+                            unmountedThreadReady.countDown();\n+                            await(dumpedLatch);\n+                        }\n+                    });\n+            } else {\n+                unmountedThreadReady.countDown();\n+                await(dumpedLatch);\n+            }\n+            Reference.reachabilityFence(referenced);\n+        });\n+        \/\/ Wait until unmounted thread is ready.\n+        unmountedThreadReady.await();\n+\n+        \/\/ Ended virtual thread with stack local - should not be reported.\n+        Thread vthreadEnded = Thread.ofVirtual().start(() -> {\n+            Object referenced = new VThreadUnmountedEnded();\n+            System.out.println(\"created \" + referenced.getClass());\n+            Reference.reachabilityFence(referenced);\n+        });\n+        \/\/ Make sure this vthread has exited so we can test\n+        \/\/ that it no longer holds any stack references.\n+        vthreadEnded.join();\n+\n+        \/\/ Mounted virtual thread with stack local and JNI local on top frame.\n+        Thread vthreadMounted = Thread.ofVirtual().start(() -> {\n+            Object referenced = new VThreadMountedReferenced();\n+            System.out.println(\"created \" + referenced.getClass());\n+            createObjAndWait(VThreadMountedJNIReferenced.class);\n+            Reference.reachabilityFence(referenced);\n+        });\n+        \/\/ Wait until mounted vthread is ready.\n+        while (!mountedVthreadReady) {\n+            Thread.sleep(10);\n+        }\n+\n+        CountDownLatch pThreadReady = new CountDownLatch(1);\n+        \/\/ Sanity check - reference from platform thread stack.\n+        Thread pthread = Thread.ofPlatform().start(() -> {\n+            Object referenced = new PThreadReferenced();\n+            System.out.println(\"created \" + referenced.getClass());\n+            pThreadReady.countDown();\n+            await(dumpedLatch);\n+            Reference.reachabilityFence(referenced);\n+        });\n+        \/\/ Wait until platform thread is ready.\n+        pThreadReady.await();\n+\n+        System.out.println(\"threads:\");\n+        System.out.println(\"  - vthreadUnmounted: \" + vthreadUnmounted);\n+        System.out.println(\"  - vthreadEnded: \" + vthreadEnded);\n+        System.out.println(\"  - vthreadMounted: \" + vthreadMounted);\n+        System.out.println(\"  - pthread: \" + pthread);\n+\n+        TestCase[] testCases = new TestCase[] {\n+            new TestCase(VThreadUnmountedReferenced.class, 1, vthreadUnmounted.getId()),\n+            new TestCase(VThreadUnmountedJNIReferenced.class,\n+                         testUnmountedJNILocals ? 1 : 0,\n+                         testUnmountedJNILocals ? vthreadUnmounted.getId() : 0),\n+            new TestCase(VThreadMountedReferenced.class, 1, vthreadMounted.getId()),\n+            new TestCase(VThreadMountedJNIReferenced.class, 1, vthreadMounted.getId()),\n+            new TestCase(PThreadReferenced.class, 1, pthread.getId()),\n+            \/\/ expected to be unreported as stack local\n+            new TestCase(VThreadUnmountedEnded.class, 0, 0)\n+        };\n+\n+        Class[] testClasses = Stream.of(testCases).map(c -> c.cls()).toArray(Class[]::new);\n+        System.out.println(\"test classes:\");\n+        for (int i = 0; i < testClasses.length; i++) {\n+            System.out.println(\"  (\" + i + \") \" + testClasses[i]);\n+        }\n+\n+        try {\n+            if (noMountCheck) {\n+                System.out.println(\"INFO: No mount\/unmount checks\");\n+            } else {\n+                verifyVthreadMounted(vthreadUnmounted, false);\n+                verifyVthreadMounted(vthreadMounted, true);\n+            }\n+\n+            test(testClasses);\n+        } finally {\n+            \/\/ Finish all threads\n+            endWait();               \/\/ signal mounted vthread to exit\n+            dumpedLatch.countDown(); \/\/ signal unmounted vthread and platform thread to exit\n+        }\n+\n+        vthreadMounted.join();\n+        vthreadUnmounted.join();\n+        pthread.join();\n+\n+        boolean failed = false;\n+        for (int i = 0; i < testCases.length; i++) {\n+            int refCount = getRefCount(i);\n+            long threadId = getRefThreadID(i);\n+            String status = \"OK\";\n+            if (refCount != testCases[i].expectedCount()\n+                    || threadId != testCases[i].expectedThreadId()) {\n+                failed = true;\n+                status = \"ERROR\";\n+            }\n+            System.out.println(\"  (\" + i + \") \" + status\n+                               + \" \" + testCases[i].cls()\n+                               + \": ref count = \" + refCount\n+                               + \" (expected \" + testCases[i].expectedCount() + \")\"\n+                               + \", thread id = \" + threadId\n+                               + \" (expected \" + testCases[i].expectedThreadId() + \")\");\n+        }\n+        if (failed) {\n+            throw new RuntimeException(\"Test failed\");\n+        }\n+    }\n+\n+    private static void await(CountDownLatch dumpedLatch) {\n+        try {\n+            dumpedLatch.await();\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static void verifyVthreadMounted(Thread t, boolean expectedMounted) {\n+        \/\/ Hucky, but simple.\n+        \/\/ If virtual thread is mounted, its toString() contains\n+        \/\/ info about carrier thread, something like\n+        \/\/ VirtualThread[#27]\/runnable@ForkJoinPool-1-worker-1\n+        String s = t.toString();\n+        boolean mounted = t.isVirtual() && s.contains(\"\/runnable@\");\n+        System.out.println(\"Thread \" + t + \": \" + (mounted ? \"mounted\" : \"unmounted\"));\n+        if (mounted != expectedMounted) {\n+            throw new RuntimeException(\"Thread \" + t + \" has unexpected mount state\");\n+        }\n+    }\n+\n+    private static native void test(Class<?>... classes);\n+    private static native int getRefCount(int index);\n+    private static native long getRefThreadID(int index);\n+\n+    \/\/ Creates object of the the specified class (local JNI)\n+    \/\/ and calls the provided callback.\n+    private static native void createObjAndCallback(Class cls, Runnable callback);\n+    \/\/ Creates object of the the specified class (local JNI),\n+    \/\/ sets mountedVthreadReady static field,\n+    \/\/ and then waits until endWait() method is called.\n+    private static native void createObjAndWait(Class cls);\n+    \/\/ Signals createObjAndWait() to exit.\n+    private static native void endWait();\n+\n+    private record TestCase(Class cls, int expectedCount, long expectedThreadId) {\n+    }\n+\n+    public static class VThreadUnmountedReferenced {\n+    }\n+    public static class VThreadUnmountedJNIReferenced {\n+    }\n+    public static class VThreadUnmountedEnded {\n+    }\n+    public static class VThreadMountedReferenced {\n+    }\n+    public static class VThreadMountedJNIReferenced {\n+    }\n+    public static class PThreadReferenced {\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/FollowReferences\/VThreadStackRefTest.java","additions":249,"deletions":0,"binary":false,"changes":249,"status":"added"},{"patch":"@@ -0,0 +1,203 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+#include <jvmti.h>\n+#include <jvmti_common.h>\n+#include <atomic>\n+#include <string.h>\n+\n+namespace {\n+\n+jvmtiEnv *jvmti = nullptr;\n+\n+const int TAG_START = 100;\n+\n+struct RefCounters {\n+  jint testClassCount;\n+  jint *count;\n+  jlong *threadId;\n+\n+  RefCounters(): testClassCount(0), count(nullptr) {}\n+\n+  void* alloc(JNIEnv* env, jlong size) {\n+    unsigned char* ptr;\n+    jvmtiError err = jvmti->Allocate(size, &ptr);\n+    if (err != JVMTI_ERROR_NONE) {\n+      env->FatalError(\"jvmti->Allocate failed\");\n+    }\n+    memset(ptr, 0, size);\n+    return ptr;\n+  }\n+\n+  void init(JNIEnv* env, jint testClassCount) {\n+    this->testClassCount = testClassCount;\n+    count = (jint*)alloc(env, sizeof(count[0]) *  testClassCount);\n+    threadId = (jlong*)alloc(env, sizeof(threadId[0]) *  testClassCount);\n+  }\n+} refCounters;\n+\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ Agent functions\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+jint JNICALL\n+HeapReferenceCallback(jvmtiHeapReferenceKind reference_kind,\n+                      const jvmtiHeapReferenceInfo* reference_info,\n+                      jlong class_tag, jlong referrer_class_tag, jlong size,\n+                      jlong* tag_ptr, jlong* referrer_tag_ptr, jint length, void* user_data) {\n+  if (class_tag >= TAG_START) {\n+    jlong index = class_tag - TAG_START;\n+    switch (reference_kind) {\n+    case JVMTI_HEAP_REFERENCE_STACK_LOCAL: {\n+      jvmtiHeapReferenceInfoStackLocal *stackInfo = (jvmtiHeapReferenceInfoStackLocal *)reference_info;\n+      refCounters.count[index]++;\n+      refCounters.threadId[index] = stackInfo->thread_id;\n+      LOG(\"Stack local: index = %d, threadId = %d\\n\",\n+          (int)index, (int)stackInfo->thread_id);\n+      if (refCounters.count[index] > 1) {\n+        LOG(\"ERROR: count > 1: %d\\n\", (int)refCounters.count[index]);\n+      }\n+    }\n+    break;\n+    case JVMTI_HEAP_REFERENCE_JNI_LOCAL: {\n+      jvmtiHeapReferenceInfoJniLocal *jniInfo = (jvmtiHeapReferenceInfoJniLocal *)reference_info;\n+      refCounters.count[index]++;\n+      refCounters.threadId[index] = jniInfo->thread_id;\n+      LOG(\"JNI local: index = %d, threadId = %d\\n\",\n+          (int)index, (int)jniInfo->thread_id);\n+      if (refCounters.count[index] > 1) {\n+        LOG(\"ERROR: count > 1: %d\\n\", (int)refCounters.count[index]);\n+      }\n+    }\n+    break;\n+    default:\n+      \/\/ unexpected ref.kind\n+      LOG(\"ERROR: unexpected ref_kind for class %d: %d\\n\",\n+          (int)index, (int)reference_kind);\n+    }\n+  }\n+  return JVMTI_VISIT_OBJECTS;\n+}\n+\n+extern \"C\" JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *vm, char *options, void *reserved) {\n+  if (vm->GetEnv(reinterpret_cast<void **>(&jvmti), JVMTI_VERSION) != JNI_OK || jvmti == nullptr) {\n+    LOG(\"Could not initialize JVMTI\\n\");\n+    return JNI_ERR;\n+  }\n+  jvmtiCapabilities capabilities;\n+  memset(&capabilities, 0, sizeof(capabilities));\n+  capabilities.can_tag_objects = 1;\n+  \/\/capabilities.can_support_virtual_threads = 1;\n+  jvmtiError err = jvmti->AddCapabilities(&capabilities);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"JVMTI AddCapabilities error: %d\\n\", err);\n+    return JNI_ERR;\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ Test native methods\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+extern \"C\" JNIEXPORT void JNICALL\n+Java_VThreadStackRefTest_test(JNIEnv* env, jclass clazz, jobjectArray classes) {\n+  jsize classesCount = env->GetArrayLength(classes);\n+  for (int i=0; i<classesCount; i++) {\n+    jvmti->SetTag(env->GetObjectArrayElement(classes, i), TAG_START + i);\n+  }\n+  refCounters.init(env, classesCount);\n+  jvmtiHeapCallbacks heapCallBacks;\n+  memset(&heapCallBacks, 0, sizeof(jvmtiHeapCallbacks));\n+  heapCallBacks.heap_reference_callback = HeapReferenceCallback;\n+  jvmtiError err = jvmti->FollowReferences(0, nullptr, nullptr, &heapCallBacks, nullptr);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"JVMTI FollowReferences error: %d\\n\", err);\n+    env->FatalError(\"FollowReferences failed\");\n+  }\n+}\n+\n+extern \"C\" JNIEXPORT jint JNICALL\n+Java_VThreadStackRefTest_getRefCount(JNIEnv* env, jclass clazz, jint index) {\n+  return refCounters.count[index];\n+}\n+\n+extern \"C\" JNIEXPORT jlong JNICALL\n+Java_VThreadStackRefTest_getRefThreadID(JNIEnv* env, jclass clazz, jint index) {\n+  return refCounters.threadId[index];\n+}\n+\n+static void printtCreatedClass(JNIEnv* env, jclass cls) {\n+  jmethodID mid = env->GetMethodID(cls, \"toString\", \"()Ljava\/lang\/String;\");\n+  if (mid == nullptr) {\n+    env->FatalError(\"failed to get toString method\");\n+    return;\n+  }\n+  jstring jstr = (jstring)env->CallObjectMethod(cls, mid);\n+  const char* str = env->GetStringUTFChars(jstr, 0);\n+  LOG(\"created %s\\n\", str);\n+  env->ReleaseStringUTFChars(jstr, str);\n+}\n+\n+extern \"C\" JNIEXPORT void JNICALL\n+Java_VThreadStackRefTest_createObjAndCallback(JNIEnv* env, jclass clazz, jclass cls, jobject callback) {\n+  jobject jobj = env->AllocObject(cls);\n+  printtCreatedClass(env, cls);\n+\n+  jclass callbackClass = env->GetObjectClass(callback);\n+  jmethodID mid = env->GetMethodID(callbackClass, \"run\", \"()V\");\n+  if (mid == nullptr) {\n+    env->FatalError(\"cannot get run method\");\n+    return;\n+  }\n+  env->CallVoidMethod(callback, mid);\n+}\n+\n+static std::atomic<bool> timeToExit(false);\n+\n+extern \"C\" JNIEXPORT void JNICALL\n+Java_VThreadStackRefTest_createObjAndWait(JNIEnv* env, jclass clazz, jclass cls) {\n+  jobject jobj = env->AllocObject(cls);\n+  printtCreatedClass(env, cls);\n+\n+  \/\/ Notify main thread that we are ready\n+  jfieldID fid = env->GetStaticFieldID(clazz, \"mountedVthreadReady\", \"Z\");\n+  if (fid == nullptr) {\n+    env->FatalError(\"cannot get mountedVthreadReady field\");\n+    return;\n+  }\n+  env->SetStaticBooleanField(clazz, fid, JNI_TRUE);\n+\n+  while (!timeToExit) {\n+    sleep_ms(100);\n+  }\n+}\n+\n+extern \"C\" JNIEXPORT void JNICALL\n+Java_VThreadStackRefTest_endWait(JNIEnv* env, jclass clazz) {\n+  timeToExit = true;\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/FollowReferences\/libVThreadStackRefTest.cpp","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"}]}