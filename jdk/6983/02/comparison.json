{"files":[{"patch":"@@ -61,0 +61,1 @@\n+import java.util.stream.Stream;\n@@ -269,1 +270,4 @@\n-     * Typically called on a tester object in main()\n+     * The methods are invoked in the order found using getDeclaredMethods.\n+     * The arguments for the invocation are provided {@link #getTestArgs(Method)}.\n+     *\n+     * Typically called on a tester object in main().\n@@ -271,0 +275,1 @@\n+     * @throws IllegalArgumentException if any test method does not have a recognized signature\n@@ -274,1 +279,1 @@\n-        runTests(m -> new Object[0]);\n+        runTests(this::getTestArgs);\n@@ -279,0 +284,3 @@\n+     * The methods are invoked in the order found using getDeclaredMethods.\n+     * The arguments for the invocation are provided by a given function.\n+     *\n@@ -283,1 +291,1 @@\n-     * @throws Exception if any errors occurred\n+     * @throws Exception if any errors occurred while executing a test method\n@@ -286,1 +294,1 @@\n-        for (Method m: getClass().getDeclaredMethods()) {\n+        for (Method m : getClass().getDeclaredMethods()) {\n@@ -289,7 +297,1 @@\n-                try {\n-                    out.println(\"Running test \" + m.getName());\n-                    m.invoke(this, f.apply(m));\n-                } catch (InvocationTargetException e) {\n-                    Throwable cause = e.getCause();\n-                    throw (cause instanceof Exception) ? ((Exception) cause) : e;\n-                }\n+                runTest(m, f);\n@@ -302,0 +304,89 @@\n+    \/**\n+     * Run the specified methods annotated with @Test, or all methods annotated\n+     * with @Test if none are specified, followed by printSummary.\n+     * The methods are invoked in the order given in the methodNames argument,\n+     * or the order returned by getDeclaredMethods if no names are provided.\n+     * The arguments for the invocation are provided {@link #getTestArgs(Method)}.\n+     *\n+     * Typically called on a tester object in main(String[] args), perhaps using\n+     * args as the list of method names.\n+     *\n+     * @throws IllegalStateException if any methods annotated with @Test are overloaded\n+     * @throws IllegalArgumentException if any of the method names does not name a suitable method\n+     * @throws NullPointerException if {@code methodNames} is {@code null}, or if any of the names are {@code null}\n+     * @throws Exception if any errors occurred while executing a test method\n+     *\/\n+    public void runTests(String... methodNames) throws Exception {\n+        runTests(this::getTestArgs, methodNames);\n+    }\n+\n+    \/**\n+     * Run the specified methods annotated with @Test, or all methods annotated\n+     * with @Test if non are specified, followed by printSummary.\n+     * The methods are invoked in the order given in the methodNames argument,\n+     * or the order returned by getDeclaredMethods if no names are provided.\n+     * The arguments for the invocation are provided {@link #getTestArgs(Method)}.\n+     *\n+     * Typically called on a tester object in main(String[] args), perhaps using\n+     * args as the list of method names.\n+     *\n+     * @throws IllegalStateException if any methods annotated with @Test are overloaded\n+     * @throws IllegalArgumentException if any of the method names does not name a suitable method\n+     * @throws NullPointerException if {@code methodNames} is {@code null}, or if any of the names are {@code null}\n+     * @throws Exception if any errors occurred while executing a test method\n+     *\/\n+    public void runTests(Function<Method, Object[]> f, String... methodNames) throws Exception {\n+        if (methodNames.length == 0) {\n+            runTests(f);\n+        } else {\n+            Map<String, Method> testMethods = Stream.of(getClass().getDeclaredMethods())\n+                    .filter(this::isTestMethod)\n+                    .collect(Collectors.toMap(Method::getName, Function.identity(),\n+                            (o, n) -> {\n+                                throw new IllegalStateException(\"test method \" + o.getName() + \" is overloaded\");\n+                            }));\n+\n+            List<Method> list = new ArrayList<>();\n+            for (String mn : methodNames) {\n+                Method m = testMethods.get(mn);\n+                if (m == null) {\n+                    throw new IllegalArgumentException(\"test method \" + mn + \" not found\");\n+                }\n+                list.add(m);\n+            }\n+\n+            for (Method m : list) {\n+                runTest(m, f);\n+            }\n+        }\n+    }\n+\n+    protected boolean isTestMethod(Method m) {\n+        return m.getAnnotation(Test.class) != null;\n+    }\n+\n+    protected Object[] getTestArgs(Method m) throws IllegalArgumentException {\n+        Class<?>[] paramTypes = m.getParameterTypes();\n+        if (paramTypes.length == 0) {\n+            return new Object[] {};\n+        } else if (paramTypes.length == 1 && paramTypes[0] == Path.class) {\n+            return new Object[] { Path.of(m.getName())};\n+        } else {\n+            throw new IllegalArgumentException(\"unknown signature for method \"\n+                    + m + Stream.of(paramTypes)\n+                    .map(Class::toString)\n+                    .collect(Collectors.joining(\", \", \"(\", \")\")))  ;\n+        }\n+    }\n+\n+    protected void runTest(Method m, Function<Method, Object[]> f) throws Exception {\n+        try {\n+            out.println(\"Running test \" + m.getName());\n+            m.invoke(this, f.apply(m));\n+        } catch (InvocationTargetException e) {\n+            Throwable cause = e.getCause();\n+            throw (cause instanceof Exception) ? ((Exception) cause) : e;\n+        }\n+\n+    }\n+\n","filename":"test\/langtools\/jdk\/javadoc\/lib\/javadoc\/tester\/JavadocTester.java","additions":102,"deletions":11,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -0,0 +1,272 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @bug 8272853\n+ * @summary improve `JavadocTester.runTests`\n+ * @library \/tools\/lib\/ ..\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build toolbox.ToolBox javadoc.tester.*\n+ * @run main TestRunTests\n+ *\/\n+\n+import javadoc.tester.JavadocTester;\n+\n+import java.io.PrintStream;\n+import java.lang.annotation.Annotation;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+public class TestRunTests {\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface RunTest {\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        TestRunTests t = new TestRunTests();\n+        t.run();\n+    }\n+\n+    PrintStream out = System.out;\n+\n+    void run() throws Exception {\n+        for (Method m : getClass().getDeclaredMethods()) {\n+            Annotation a = m.getAnnotation(RunTest.class);\n+            if (a != null) {\n+                try {\n+                    out.println(\"Running \" + m);\n+                    m.invoke(this);\n+                    out.println();\n+                } catch (InvocationTargetException e) {\n+                    error(\"Invocation Target Exception while running \" + m + \": \" + e.getCause());\n+                } catch (Exception e) {\n+                    error(\"Exception while running \" + m + \": \" + e);\n+                }\n+            }\n+        }\n+        out.flush();\n+        if (errors > 0) {\n+            out.println(errors + \" errors occurred\");\n+            throw new Exception(errors + \" errors occurred\");\n+        }\n+    }\n+\n+    int errors;\n+\n+    @RunTest\n+    public void testNoArgs() throws Exception {\n+        MainGroup g = new MainGroup();\n+        g.runTests();\n+        checkEqualUnordered(g.log, Set.of(\"m1()\", \"m2(m2)\", \"m3()\", \"m4(m4)\"));\n+    }\n+\n+    @RunTest\n+    public void testMethodNames() throws Exception {\n+        MainGroup g = new MainGroup();\n+        g.runTests(\"m1\", \"m4\", \"m2\");\n+        checkEqualOrdered(g.log, List.of(\"m1()\", \"m4(m4)\", \"m2(m2)\"));\n+    }\n+\n+    @RunTest\n+    public void testFunction() throws Exception {\n+        Function<Method, Object[]> f = m ->\n+                switch (m.getName()) {\n+                    case \"m1\", \"m3\" -> new Object[]{};\n+                    case \"m2\", \"m4\" -> new Object[]{Path.of(m.getName().toUpperCase(Locale.ROOT))};\n+                    default -> throw new IllegalArgumentException(m.toString());\n+                };\n+        MainGroup g = new MainGroup();\n+        g.runTests(f);\n+        checkEqualUnordered(g.log, Set.of(\"m1()\", \"m2(M2)\", \"m3()\", \"m4(M4)\"));\n+    }\n+\n+    @RunTest\n+    public void testFunctionMethodNames() throws Exception {\n+        Function<Method, Object[]> f = m ->\n+                switch (m.getName()) {\n+                    case \"m1\", \"m3\" -> new Object[]{};\n+                    case \"m2\", \"m4\" -> new Object[]{Path.of(m.getName().toUpperCase(Locale.ROOT))};\n+                    default -> throw new IllegalArgumentException(m.toString());\n+                };\n+        MainGroup g = new MainGroup();\n+        g.runTests(f, \"m1\", \"m4\", \"m2\");\n+        checkEqualOrdered(g.log, List.of(\"m1()\", \"m4(M4)\", \"m2(M2)\"));\n+    }\n+\n+    @RunTest\n+    public void testMethodNotFound() throws Exception {\n+        MainGroup g = new MainGroup();\n+        try {\n+            g.runTests(\"m1\", \"m2\", \"mx\", \"m3\", \"m4\");\n+        } catch (IllegalArgumentException e) {\n+            g.log.add(e.toString());\n+        }\n+        \/\/ implicit in the following is that the error was detected before any test methods were executed\n+        checkEqualOrdered(g.log, List.of(\"java.lang.IllegalArgumentException: test method mx not found\"));\n+    }\n+\n+    @RunTest\n+    public void testInvalidSignature() throws Exception {\n+        InvalidSignatureGroup g = new InvalidSignatureGroup();\n+        try {\n+            g.runTests();\n+        } catch (IllegalArgumentException e) {\n+            g.log.add(e.toString());\n+        }\n+        \/\/ since the exception comes from the nested use of `getTestArgs`, it will be thrown\n+        \/\/ when the test method is being called, and so is not constrained to be thrown\n+        \/\/ before any test method is called\n+        checkContainsAll(g.log, List.of(\"java.lang.IllegalArgumentException: unknown signature for method \"\n+                + \"public void TestRunTests$InvalidSignatureGroup.invalidSignature(java.lang.Object)(class java.lang.Object)\"));\n+    }\n+\n+    @RunTest\n+    public void testOverloadedMethod() throws Exception {\n+        OverloadGroup g = new OverloadGroup();\n+        try {\n+            g.runTests(\"m1\");\n+        } catch (IllegalStateException e) {\n+            g.log.add(e.toString());\n+        }\n+        \/\/ implicit in the following is that the error was detected before any test methods were executed\n+        checkEqualOrdered(g.log, List.of(\"java.lang.IllegalStateException: test method m1 is overloaded\"));\n+    }\n+\n+    void checkContainsAll(List<String> found, List<String> expect) {\n+        if (!found.containsAll(expect)) {\n+            out.println(\"Found:  \" + found);\n+            out.println(\"Expect: \" + expect);\n+            error(\"Expected results not found\");\n+        }\n+    }\n+\n+    void checkEqualOrdered(List<String> found, List<String> expect) {\n+        if (!found.equals(expect)) {\n+            out.println(\"Found:  \" + found);\n+            out.println(\"Expect: \" + expect);\n+            error(\"Expected results not found\");\n+        }\n+    }\n+\n+    void checkEqualUnordered(List<String> found, Set<String> expect) {\n+        if (!(found.containsAll(expect) && expect.containsAll(found))) {\n+            out.println(\"Found:  \" + found);\n+            out.println(\"Expect: \" + expect);\n+            error(\"Expected results not found\");\n+        }\n+    }\n+\n+    void error(String message) {\n+        out.println(\"Error: \" + message);\n+        errors++;\n+    }\n+\n+    \/**\n+     * A group of tests to be executed by different overloads of {@code runTests}.\n+     *\/\n+    public static class MainGroup extends JavadocTester {\n+        List<String> log = new ArrayList<>();\n+\n+        @Test\n+        public void m1() {\n+            log.add(\"m1()\");\n+            checking(\"m1\");\n+            passed(\"OK\");\n+        }\n+\n+        @Test\n+        public void m2(Path p) {\n+            log.add(\"m2(\" + p.getFileName() + \")\");\n+            checking(\"m2\");\n+            passed(\"OK\");\n+        }\n+\n+        @Test\n+        public void m3() {\n+            log.add(\"m3()\");\n+            checking(\"m3\");\n+            passed(\"OK\");\n+        }\n+\n+        @Test\n+        public void m4(Path p) {\n+            log.add(\"m4(\" + p.getFileName() + \")\");\n+            checking(\"m4\");\n+            passed(\"OK\");\n+        }\n+    }\n+\n+    \/**\n+     * A group of tests containing one with an invalid (unrecognized) signature.\n+     * The invalid signature should cause an exception when trying to run that test.\n+     *\/\n+    public static class InvalidSignatureGroup extends JavadocTester {\n+        List<String> log = new ArrayList<>();\n+\n+        @Test\n+        public void m1() {\n+            log.add(\"m1()\");\n+            checking(\"m1\");\n+            passed(\"OK\");\n+        }\n+\n+        @Test\n+        public void invalidSignature(Object o) {\n+            log.add(\"invalidSignature(\" + o + \")\");\n+            checking(\"invalidSignature\");\n+            passed(\"OK\");\n+        }\n+    }\n+\n+    \/**\n+     * A group of tests including an overloaded test method.\n+     * The overload should cause an exception when trying to run that test by name.\n+     *\/\n+    public static class OverloadGroup extends JavadocTester {\n+        List<String> log = new ArrayList<>();\n+\n+        @Test\n+        public void m1() {\n+            log.add(\"m1()\");\n+            checking(\"m1\");\n+            passed(\"OK\");\n+        }\n+\n+        @Test\n+        public void m1(Path p) {\n+            log.add(\"m1(\" + p + \")\");\n+            checking(\"m1\");\n+            passed(\"OK\");\n+        }\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/testJavadocTester\/TestRunTests.java","additions":272,"deletions":0,"binary":false,"changes":272,"status":"added"}]}