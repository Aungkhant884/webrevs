{"files":[{"patch":"@@ -45,0 +45,1 @@\n+import java.lang.ref.ReferenceQueue;\n@@ -85,0 +86,1 @@\n+        Object canary;\n@@ -86,1 +88,1 @@\n-        public LoadLibraryFromClass(Class<?> fromClass) {\n+        public LoadLibraryFromClass(Class<?> fromClass, Object canary) {\n@@ -89,1 +91,2 @@\n-                this.method = fromClass.getDeclaredMethod(\"loadLibrary\");\n+                this.method = fromClass.getDeclaredMethod(\"loadLibrary\", Object.class);\n+                this.canary = canary;\n@@ -98,1 +101,1 @@\n-                method.invoke(object);\n+                method.invoke(object, canary);\n@@ -107,1 +110,1 @@\n-        Class<?> clazz = null;\n+        int LOADER_COUNT = 5;\n@@ -109,0 +112,3 @@\n+        Object[] canary = new Object[LOADER_COUNT];\n+        WeakReference<Object> wCanary[] = new WeakReference[LOADER_COUNT];\n+        ReferenceQueue<Object> refQueue = new ReferenceQueue<>();\n@@ -110,2 +116,2 @@\n-        for (int i = 0 ; i < 5 ; i++) {\n-            \/\/ 5 loaders and 10 threads in total.\n+        for (int i = 0 ; i < LOADER_COUNT ; i++) {\n+            \/\/ LOADER_COUNT loaders and 2X threads in total.\n@@ -113,3 +119,6 @@\n-            clazz = new TestLoader().loadClass(\"p.Class1\");\n-            threads.add(new Thread(new LoadLibraryFromClass(clazz)));\n-            threads.add(new Thread(new LoadLibraryFromClass(clazz)));\n+            canary[i] = new Object();\n+            wCanary[i] = new WeakReference<>(canary[i], refQueue);\n+\n+            Class<?> clazz = new TestLoader().loadClass(\"p.Class1\");\n+            threads.add(new Thread(new LoadLibraryFromClass(clazz, canary[i])));\n+            threads.add(new Thread(new LoadLibraryFromClass(clazz, canary[i])));\n@@ -143,2 +152,3 @@\n-        Asserts.assertTrue(exceptions.size() == 8,\n-                \"Expected to see 8 failing threads\");\n+        int expectedErrorCount = (LOADER_COUNT - 1) * 2;\n+        Asserts.assertTrue(exceptions.size() == expectedErrorCount,\n+                \"Expected to see \" + expectedErrorCount + \" failing threads\");\n@@ -149,2 +159,0 @@\n-        WeakReference<Class<?>> wClass = new WeakReference<>(clazz);\n-\n@@ -152,1 +160,0 @@\n-        clazz = null;\n@@ -154,0 +161,1 @@\n+        canary = null;\n@@ -155,2 +163,10 @@\n-        if (!ForceGC.wait(() -> wClass.refersTo(null))) {\n-            throw new RuntimeException(\"Class1 hasn't been GC'ed\");\n+\n+        \/\/ Wait for the canary for each of the libraries to be GC'd\n+        \/\/ before exiting the test.\n+        for (int i = 0; i < LOADER_COUNT; i++) {\n+            System.gc();\n+            var res = refQueue.remove();\n+            System.out.println(i + \" dequeued: \" + res);\n+            if (res == null) {\n+                Asserts.fail(\"Too few cleared Weak references\");\n+            }\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryUnload\/LoadLibraryUnload.java","additions":32,"deletions":16,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,0 +105,3 @@\n+\n+        Asserts.assertEquals(0, outputAnalyzer.getExitValue(),\n+                \"LoadLibraryUnload exit value not zero\");\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryUnload\/LoadLibraryUnloadTest.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+static volatile jobject ref = NULL;\n+\n@@ -43,0 +45,8 @@\n+JNIEXPORT void JNICALL Java_p_Class1_setRef(JNIEnv *env, jobject this, jobject obj) {\n+    if (ref == NULL) {\n+        \/\/ Only create a single GlobalRef\n+        ref = (*env)->NewGlobalRef(env, obj);\n+        printf(\"GlobalRef created\\n\");\n+    }\n+}\n+\n@@ -46,0 +56,8 @@\n+    if (ref != NULL) {\n+        JNIEnv *env = NULL;\n+        if ((*vm)->GetEnv(vm, (void**) &env, JNI_VERSION_1_2) != JNI_OK) {\n+            return; \/* JNI version not supported *\/\n+        }\n+        (*env)->DeleteGlobalRef(env, ref);\n+        printf(\"GlobalRef deleted\\n\");\n+    }\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryUnload\/libloadLibraryUnload.c","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-    public void loadLibrary() throws Exception {\n+    public void loadLibrary(Object obj) throws Exception {\n@@ -39,0 +39,1 @@\n+        setRef(obj);\n@@ -40,0 +41,7 @@\n+\n+    \/**\n+     * Native method to store an object ref in a native Global reference\n+     * to be cleared when the library is unloaded.\n+     * @param obj an object\n+     *\/\n+    private static native void setRef(Object obj);\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryUnload\/p\/Class1.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"}]}