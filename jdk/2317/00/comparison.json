{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -3896,6 +3896,1 @@\n-  } else if (opc == Op_ConvI2L) {\n-    if (n->in(1)->Opcode() == Op_CastII &&\n-        n->in(1)->as_CastII()->has_range_check()) {\n-      \/\/ Skip range check dependent CastII nodes\n-      n = n->in(1);\n-    }\n+  } else if (opc == Op_ConvI2L || opc == Op_CastII) {\n@@ -3998,1 +3993,1 @@\n-    \/\/ 'n' is loop invariant. Skip range check dependent CastII nodes before checking if 'n' is dominating the pre loop.\n+    \/\/ 'n' is loop invariant. Skip ConvI2L and CastII nodes before checking if 'n' is dominating the pre loop.\n@@ -4001,6 +3996,5 @@\n-      if (n->Opcode() == Op_CastII &&\n-          n->as_CastII()->has_range_check()) {\n-        \/\/ Skip range check dependent CastII nodes\n-        assert(!is_main_loop_member(n), \"sanity\");\n-        n = n->in(1);\n-      }\n+    }\n+    if (n->Opcode() == Op_CastII) {\n+      \/\/ Skip CastII nodes\n+      assert(!is_main_loop_member(n), \"sanity\");\n+      n = n->in(1);\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":8,"deletions":14,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+ * @run main compiler.vectorization.TestBufferVectorization arrayView\n@@ -40,0 +41,3 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+\n@@ -54,0 +58,1 @@\n+    final static VarHandle VH_arr_view = MethodHandles.byteArrayViewVarHandle(int[].class, ByteOrder.nativeOrder()).withInvokeExactBehavior();\n@@ -156,0 +161,33 @@\n+    static class TestArrayView implements Test {\n+        final byte[] b_arr = new byte[N * Integer.BYTES];\n+\n+        public void init() {\n+            for (int k = 0; k < N; k++) {\n+                VH_arr_view.set(b_arr, k, k);\n+            }\n+        }\n+\n+        public void run() {\n+            for (int k = 0; k < b_arr.length; k += 4) {\n+                int v = (int) VH_arr_view.get(b_arr, k);\n+                VH_arr_view.set(b_arr, k, v + 1);\n+            }\n+        }\n+\n+        public void verify() {\n+            init(); \/\/ reset\n+            \/\/ Save initial INT values\n+            final int[] i_arr = new int[N];\n+            for (int k = 0; k < i_arr.length; k++) {\n+                i_arr[k] = (int) VH_arr_view.get(b_arr, k * Integer.BYTES);\n+            }\n+            run();  \/\/ run compiled code\n+            for (int k = 0; k < i_arr.length; k++) {\n+                int v = (int) VH_arr_view.get(b_arr, k * Integer.BYTES);\n+                if (v != (i_arr[k] + 1)) {\n+                    throw new RuntimeException(\" Invalid result: VH_arr_view.get(b_arr, \" + (k * Integer.BYTES) + \"): \" + v + \" != \" + (i_arr[k] + 1));\n+                }\n+            }\n+        }\n+    }\n+\n@@ -158,1 +196,1 @@\n-            throw new RuntimeException(\" Missing test name: array, arrayOffset, buffer, bufferHeap, bufferDirect\");\n+            throw new RuntimeException(\" Missing test name: array, arrayOffset, buffer, bufferHeap, bufferDirect, arrayView\");\n@@ -178,0 +216,3 @@\n+            case \"arrayView\":\n+                te = new TestArrayView();\n+                break;\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestBufferVectorization.java","additions":43,"deletions":2,"binary":false,"changes":45,"status":"modified"}]}