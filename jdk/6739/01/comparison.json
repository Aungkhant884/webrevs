{"files":[{"patch":"@@ -376,0 +376,2 @@\n+doclet.snippet.markup.spurious=\\\n+  spurious markup\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -272,0 +272,6 @@\n+            Diags d = (text, pos) -> {\n+                var path = writer.configuration().utils.getCommentHelper(holder)\n+                        .getDocTreePath(snippetTag.getBody());\n+                writer.configuration().getReporter().print(Diagnostic.Kind.WARNING,\n+                        path, pos, pos, pos, text);\n+            };\n@@ -273,1 +279,1 @@\n-                inlineSnippet = parse(writer.configuration().getDocResources(), language, inlineContent);\n+                inlineSnippet = parse(writer.configuration().getDocResources(), d, language, inlineContent);\n@@ -287,0 +293,2 @@\n+            var finalFileObject = fileObject;\n+            Diags d = (text, pos) -> writer.configuration().getMessages().warning(finalFileObject, pos, pos, pos, text);\n@@ -288,1 +296,1 @@\n-                externalSnippet = parse(writer.configuration().getDocResources(), language, externalContent);\n+                externalSnippet = parse(writer.configuration().getDocResources(), d, language, externalContent);\n@@ -366,2 +374,2 @@\n-    private StyledText parse(Resources resources, Optional<Language> language, String content) throws ParseException {\n-        Parser.Result result = new Parser(resources).parse(language, content);\n+    private StyledText parse(Resources resources, Diags diags, Optional<Language> language, String content) throws ParseException {\n+        Parser.Result result = new Parser(resources).parse(diags, language, content);\n@@ -372,0 +380,4 @@\n+    public interface Diags {\n+        void warn(String text, int pos);\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SnippetTaglet.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -34,5 +34,2 @@\n-\/\/ markup-comment = { markup-tag } ;\n-\/\/     markup-tag = \"@\" , tag-name , {attribute} [\":\"] ;\n-\/\/\n-\/\/ If optional trailing \":\" is present, the tag refers to the next line\n-\/\/ rather than to this line.\n+\/\/ markup-comment = { markup-tag } [\":\"] ;\n+\/\/     markup-tag = \"@\" , tag-name , {attribute} ;\n@@ -79,0 +76,13 @@\n+        List<Parser.Tag> tags = readTags();\n+        if (ch == ':') {\n+            tags.forEach(t -> t.appliesToNextLine = true);\n+            nextChar();\n+        }\n+        skipWhitespace();\n+        if (ch != EOI) {\n+            return List.of();\n+        }\n+        return tags;\n+    }\n+\n+    protected List<Parser.Tag> readTags() throws ParseException {\n@@ -80,1 +90,1 @@\n-        \/\/ TODO: what to do with leading and trailing unrecognized markup?\n+        skipWhitespace();\n@@ -82,3 +92,4 @@\n-            switch (ch) {\n-                case '@' -> tags.add(readTag());\n-                default -> nextChar();\n+            if (ch == '@') {\n+                tags.add(readTag());\n+            } else {\n+                break;\n@@ -87,1 +98,0 @@\n-\n@@ -97,14 +107,2 @@\n-        boolean appliesToNextLine = false;\n-        List<Attribute> attributes = List.of();\n-\n-        if (ch == ':') {\n-            appliesToNextLine = true;\n-            nextChar();\n-        } else {\n-            attributes = attrs();\n-            skipWhitespace();\n-            if (ch == ':') {\n-                appliesToNextLine = true;\n-                nextChar();\n-            }\n-        }\n+        List<Attribute> attributes = attrs();\n+        skipWhitespace();\n@@ -116,1 +114,0 @@\n-        i.appliesToNextLine = appliesToNextLine;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/MarkupParser.java","additions":22,"deletions":25,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-    public Result parse(Optional<SnippetTaglet.Language> language, String source) throws ParseException {\n+    public Result parse(SnippetTaglet.Diags diags, Optional<SnippetTaglet.Language> language, String source) throws ParseException {\n@@ -103,1 +103,1 @@\n-        return parse(p, source);\n+        return parse(diags, p, source);\n@@ -109,1 +109,1 @@\n-    private Result parse(Pattern commentPattern, String source) throws ParseException {\n+    private Result parse(SnippetTaglet.Diags diags, Pattern commentPattern, String source) throws ParseException {\n@@ -153,1 +153,1 @@\n-                    throw new ParseException(e::getMessage, markedUpLine.start(\"markup\") + e.getPosition());\n+                    throw new ParseException(e::getMessage, next.offset() + markedUpLine.start(\"markup\") + e.getPosition());\n@@ -169,1 +169,1 @@\n-                    \/\/ TODO: log this with NOTICE;\n+                    diags.warn(resources.getText(\"doclet.snippet.markup.spurious\"), next.offset() + markedUpLine.start(\"markup\"));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Parser.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.nio.file.attribute.BasicFileAttributes;\n@@ -32,0 +33,1 @@\n+import java.util.function.BiPredicate;\n@@ -125,0 +127,42 @@\n+\n+    \/\/ There's JavadocTester.diff(), but its semantics is different; hence we\n+    \/\/ use this method.\n+    protected void match(Path path1, Path path2, BiPredicate<Path, BasicFileAttributes> filter) throws IOException {\n+        checking(\"diff \" + path1 + \", \" + path2);\n+        try (var paths1 = Files.find(path1, Integer.MAX_VALUE, filter).sorted();\n+             var paths2 = Files.find(path2, Integer.MAX_VALUE, filter).sorted()) {\n+            var it1 = paths1.iterator();\n+            var it2 = paths2.iterator();\n+            while (true) {\n+                if (it1.hasNext() != it2.hasNext()) {\n+                    failed(it1.hasNext() ? it1.next() : it2.next(), \"missing\");\n+                    return;\n+                }\n+                if (!it1.hasNext()) {\n+                    passed(\"match\");\n+                    return;\n+                }\n+                Path next1 = it1.next();\n+                Path next2 = it2.next();\n+                if (!path1.relativize(next1).equals(path2.relativize(next2))) {\n+                    \/\/ compare directory tree to see the difference\n+                    failed(\"mismatching names %s %s\".formatted(next1, next2));\n+                    return;\n+                }\n+                if (Files.isDirectory(next1) != Files.isDirectory(next2)) {\n+                    \/\/ it'd be surprising to ever see this\n+                    failed(\"mismatching types %s %s\".formatted(next1, next2));\n+                    return;\n+                }\n+                if (Files.isDirectory(next1)) {\n+                    continue;\n+                }\n+                if (Files.size(next1) != Files.size(next2)\n+                        || Files.mismatch(next1, next2) != -1L) {\n+                    failed(\"mismatching contents: diff %s %s\".formatted(next1.toAbsolutePath(),\n+                            next2.toAbsolutePath()));\n+                    return;\n+                }\n+            }\n+        }\n+    }\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSnippetTag\/SnippetTester.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -606,0 +606,109 @@\n+    @Test\n+    public void testPositiveInlineTagMarkup_FalseMarkup(Path base) throws Exception {\n+        var testCases = List.of(\n+                new TestCase(\n+                        \"\"\"\n+                        First line\n+                        \/\/ @formatter:off\n+                          Second Line\n+                            Third line\n+                            \/\/ @formatter:on\n+                              Fourth line\n+                        \"\"\",\n+                        \"\"\"\n+                        First line\n+                        \/\/ @formatter:off\n+                          Second Line\n+                            Third line\n+                            \/\/ @formatter:on\n+                              Fourth line\n+                        \"\"\"),\n+                new TestCase(\"showThis\",\n+                        \"\"\"\n+                        First line\n+                        \/\/ @formatter:off\n+                          \/\/ @start region=showThis\n+                          Second Line\n+                            Third line\n+                            \/\/ @end region\n+                            \/\/ @formatter:on\n+                              Fourth line\n+                        \"\"\",\n+                        \"\"\"\n+                        Second Line\n+                          Third line\n+                        \"\"\")\n+        );\n+        testPositive(base, testCases);\n+    }\n+\n+    @Test\n+    public void testPositiveInlineTagMarkup_NextLineTwoTags(Path base) throws Exception {\n+        var firstTag = new String[]{\n+                \"@highlight string=firstWord\",\n+                \"@replace string=secondWord replacement=replacedSecondWord\",\n+                \"@link substring=firstWord target=java.lang.Object\"};\n+        var secondTag = new String[]{\n+                \"@highlight string=secondWord\",\n+                \"@replace string=firstWord replacement=replacedFirstWord\",\n+                \"@link substring=secondWord target=java.lang.Thread\"};\n+        List<TestCase> testCases = new ArrayList<>();\n+        for (var f : firstTag) {\n+            for (var s : secondTag)\n+                for (var separator : List.of(\"\", \" \")) {\n+                    var t = new TestCase(\n+                            \"\"\"\n+                                first-line \/\/ %s %s%s:\n+                                firstWord secondWord thirdWord\n+                                \"\"\".formatted(f, s, separator),\n+                            \"\"\"\n+                                first-line\n+                                firstWord secondWord thirdWord \/\/ %s %s\n+                                \"\"\".formatted(f, s));\n+                    testCases.add(t);\n+            }\n+        }\n+        testEquivalence(base, testCases);\n+    }\n+\n+    record Snippet(String region, String snippet) { }\n+\n+    private void testEquivalence(Path base, List<TestCase> testCases) throws IOException {\n+        \/\/ group all the testcases in just two runs\n+        Path out1 = base.resolve(\"out1\");\n+        Path out2 = base.resolve(\"out2\");\n+        run(base.resolve(\"src1\"), out1, testCases.stream().map(t -> new Snippet(t.region(), t.input())).toList());\n+        run(base.resolve(\"src2\"), out2, testCases.stream().map(t -> new Snippet(t.region(), t.expectedOutput())).toList());\n+        match(out1, out2, (p, a) -> \/* p.toString().endsWith(\".html\") *\/ true);\n+    }\n+\n+    private void run(Path source, Path target, List<Snippet> snippets) throws IOException {\n+        StringBuilder methods = new StringBuilder();\n+        forEachNumbered(snippets, (i, n) -> {\n+            String r = i.region.isBlank() ? \"\" : \"region=\" + i.region;\n+            var methodDef = \"\"\"\n+\n+                    \/**\n+                    {@snippet %s:\n+                    %s}*\/\n+                    public void case%s() {}\n+                    \"\"\".formatted(r, i.snippet(), n);\n+            methods.append(methodDef);\n+        });\n+        var classDef = \"\"\"\n+                public class A {\n+                %s\n+                }\n+                \"\"\".formatted(methods.toString());\n+        Path src = Files.createDirectories(source);\n+        tb.writeJavaFiles(src, classDef);\n+        javadoc(\"-d\", target.toString(),\n+                \"--limit-modules\", \"java.base\",\n+                \"-quiet\", \"-nohelp\", \"-noindex\", \"-nonavbar\", \"-nosince\",\n+                \"-notimestamp\", \"-notree\", \"-Xdoclint:none\",\n+                \"-sourcepath\", src.toString(),\n+                src.resolve(\"A.java\").toString());\n+        checkExit(Exit.OK);\n+        checkNoCrashes();\n+    }\n+\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSnippetTag\/TestSnippetMarkup.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -2421,1 +2421,2 @@\n-    hello \/\/ @highlight substring=\"\n+    hello\n+    there \/\/ @highlight substring=\"\n@@ -2425,1 +2426,1 @@\n-    hello \/\/ @highlight substring=\"\n+    there \/\/ @highlight substring=\"\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSnippetTag\/TestSnippetTag.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}