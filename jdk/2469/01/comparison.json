{"files":[{"patch":"@@ -107,1 +107,1 @@\n-\/\/ bootstrapsearchpath support: links in a thread before load_instance_class\n+\/\/ bootstrap loader support:  links in a thread before load_instance_class\n@@ -115,0 +115,3 @@\n+  assert(action != PlaceholderTable::LOAD_INSTANCE || seen == NULL,\n+         \"Only one LOAD_INSTANCE allowed at a time\");\n+\n","filename":"src\/hotspot\/share\/classfile\/placeholders.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -123,2 +123,2 @@\n-                                    \/\/ can be multiple threads if classloader object lock broken by application\n-                                    \/\/ or if classloader supports parallel classloading\n+                                    \/\/ This can't be multiple threads since class loading waits for\n+                                    \/\/ this token to be removed.\n","filename":"src\/hotspot\/share\/classfile\/placeholders.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -573,3 +573,0 @@\n-\/\/ Note: must call resolve_super_or_fail even if null super -\n-\/\/ to force placeholder entry creation for this class for circularity detection\n-\/\/ Caller must check for pending exception\n@@ -577,2 +574,2 @@\n-\/\/ and we are done,\n-\/\/ If return null Klass* and no pending exception, the caller must load the class\n+\/\/ and we are done.  If this returns a null Klass* and no pending exception,\n+\/\/ the caller must load the class.\n@@ -587,8 +584,1 @@\n-  \/\/ superk is not used, resolve_super called for circularity check only\n-  \/\/ This code is reached in two situations. One if this thread\n-  \/\/ is loading the same class twice (e.g. ClassCircularity, or\n-  \/\/ java.lang.instrument).\n-  \/\/ The second is if another thread started the resolve_super first\n-  \/\/ and has not yet finished.\n-  \/\/ In both cases the original caller will clean up the placeholder\n-  \/\/ entry on error.\n+  \/\/ superk is not used; resolve_super_or_fail is called for circularity check only.\n@@ -606,1 +596,0 @@\n-    \/\/ Check if classloading completed while we were loading superclass or waiting\n@@ -762,4 +751,2 @@\n-    \/\/    These class loaders don't lock the object until load_instance_class is\n-    \/\/    called after this placeholder is added.\n-    \/\/    Allow parallel classloading of a class\/classloader pair where mutual\n-    \/\/    exclusion is provided by this lock in the class loader Java code.\n+    \/\/    These class loaders lock a per-class object lock when ClassLoader.loadClass()\n+    \/\/    is called. A LOAD_INSTANCE placeholder isn't used for mutual exclusion.\n@@ -774,1 +761,1 @@\n-    {\n+    if (class_loader.is_null() || !is_parallelCapable(class_loader)) {\n@@ -776,16 +763,15 @@\n-      if (class_loader.is_null() || !is_parallelCapable(class_loader)) {\n-        PlaceholderEntry* oldprobe = placeholders()->get_entry(name_hash, name, loader_data);\n-        if (oldprobe != NULL) {\n-          \/\/ only need check_seen_thread once, not on each loop\n-          \/\/ 6341374 java\/lang\/Instrument with -Xcomp\n-          if (oldprobe->check_seen_thread(THREAD, PlaceholderTable::LOAD_INSTANCE)) {\n-            throw_circularity_error = true;\n-          } else {\n-            \/\/ case 3: traditional: should never see load_in_progress.\n-            while (!class_has_been_loaded && oldprobe != NULL && oldprobe->instance_load_in_progress()) {\n-\n-              \/\/ case 1: bootstrap classloader: prevent futile classloading,\n-              \/\/ wait on first requestor\n-              if (class_loader.is_null()) {\n-                SystemDictionary_lock->wait();\n-              } else {\n+      PlaceholderEntry* oldprobe = placeholders()->get_entry(name_hash, name, loader_data);\n+      if (oldprobe != NULL) {\n+        \/\/ only need check_seen_thread once, not on each loop\n+        \/\/ 6341374 java\/lang\/Instrument with -Xcomp\n+        if (oldprobe->check_seen_thread(THREAD, PlaceholderTable::LOAD_INSTANCE)) {\n+          throw_circularity_error = true;\n+        } else {\n+          \/\/ case 3: traditional: should never see load_in_progress.\n+          while (!class_has_been_loaded && oldprobe != NULL && oldprobe->instance_load_in_progress()) {\n+\n+            \/\/ case 1: bootstrap classloader: prevent futile classloading,\n+            \/\/ wait on first requestor\n+            if (class_loader.is_null()) {\n+              SystemDictionary_lock->wait();\n+            } else {\n@@ -794,11 +780,8 @@\n-                double_lock_wait(THREAD, lockObject);\n-              }\n-              \/\/ Check if classloading completed while we were waiting\n-              InstanceKlass* check = dictionary->find_class(name_hash, name);\n-              if (check != NULL) {\n-                \/\/ Klass is already loaded, so just return it\n-                loaded_class = check;\n-                class_has_been_loaded = true;\n-              }\n-              \/\/ check if other thread failed to load and cleaned up\n-              oldprobe = placeholders()->get_entry(name_hash, name, loader_data);\n+              double_lock_wait(THREAD, lockObject);\n+            }\n+            \/\/ Check if classloading completed while we were waiting\n+            InstanceKlass* check = dictionary->find_class(name_hash, name);\n+            if (check != NULL) {\n+              \/\/ Klass is already loaded, so just return it\n+              loaded_class = check;\n+              class_has_been_loaded = true;\n@@ -806,0 +789,2 @@\n+            \/\/ check if other thread failed to load and cleaned up\n+            oldprobe = placeholders()->get_entry(name_hash, name, loader_data);\n@@ -810,1 +795,1 @@\n-      \/\/ All cases: add LOAD_INSTANCE while holding the SystemDictionary_lock\n+      \/\/ Add LOAD_INSTANCE while holding the SystemDictionary_lock\n@@ -812,9 +797,3 @@\n-        PlaceholderEntry* newprobe = placeholders()->find_and_add(name_hash, name, loader_data,\n-                                                                  PlaceholderTable::LOAD_INSTANCE, NULL, THREAD);\n-        load_instance_added = true;\n-        \/\/ For class loaders that do not acquire the classloader object lock,\n-        \/\/ if they did not catch another thread holding LOAD_INSTANCE,\n-        \/\/ need a check analogous to the acquire ObjectLocker\/find_class\n-        \/\/ i.e. now that we hold the LOAD_INSTANCE token on loading this class\/CL\n-        \/\/ one final check if the load has already completed\n-        \/\/ class loaders holding the ObjectLock shouldn't find the class here\n+        \/\/ For the bootclass loader, if the thread did not catch another thread holding\n+        \/\/ the LOAD_INSTANCE token, we need to check whether it completed loading\n+        \/\/ while holding the SD_lock.\n@@ -826,0 +805,7 @@\n+        } else {\n+          \/\/ Now we've got the LOAD_INSTANCE token. Threads will wait on loading to complete for this thread.\n+          PlaceholderEntry* newprobe = placeholders()->find_and_add(name_hash, name, loader_data,\n+                                                                    PlaceholderTable::LOAD_INSTANCE,\n+                                                                    NULL,\n+                                                                    THREAD);\n+          load_instance_added = true;\n@@ -832,1 +818,1 @@\n-      assert(!HAS_PENDING_EXCEPTION && load_instance_added == false,\"circularity error cleanup\");\n+      assert(!HAS_PENDING_EXCEPTION && !load_instance_added, \"circularity error cleanup\");\n@@ -1815,11 +1801,0 @@\n-#ifdef ASSERT\n-\/\/ Verify that this placeholder exists since this class is in the middle of loading.\n-void verify_placeholder(Symbol* class_name, ClassLoaderData* loader_data) {\n-  \/\/ Only parallel capable class loaders use placeholder table for define class.\n-  assert_locked_or_safepoint(SystemDictionary_lock);\n-  unsigned int name_hash = placeholders()->compute_hash(class_name);\n-  Symbol* ph_check =  placeholders()->find_entry(name_hash, class_name, loader_data);\n-  assert(ph_check != NULL, \"This placeholder should exist\");\n-}\n-#endif \/\/ ASSERT\n-\n@@ -1865,2 +1840,0 @@\n-    DEBUG_ONLY(if (is_parallelCapable(class_loader)) verify_placeholder(name, loader_data));\n-\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":43,"deletions":70,"binary":false,"changes":113,"status":"modified"}]}