{"files":[{"patch":"@@ -233,0 +233,2 @@\n+  case vmIntrinsics::_blackhole:\n+    break;\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3418,1 +3418,1 @@\n-      (CheckIntrinsics ? callee->intrinsic_candidate() : true)) {\n+      callee->check_intrinsic_candidate()) {\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3209,0 +3209,4 @@\n+  case vmIntrinsics::_blackhole:\n+    do_blackhole(x);\n+    break;\n+\n@@ -3628,0 +3632,8 @@\n+void LIRGenerator::do_blackhole(Intrinsic *x) {\n+  for (int c = 0; c < x->number_of_arguments(); c++) {\n+    \/\/ Load the argument\n+    LIRItem vitem(x->argument_at(c), this);\n+    vitem.load_item();\n+    \/\/ ...and leave it unused.\n+  }\n+}\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -268,0 +268,1 @@\n+  void do_blackhole(Intrinsic* x);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -158,0 +158,6 @@\n+\n+  if (CompilerOracle::should_blackhole(h_m) &&\n+      _signature->return_type()->basic_type() == T_VOID &&\n+      h_m->intrinsic_id() == vmIntrinsics::_none) {\n+    h_m->set_intrinsic_id(vmIntrinsics::_blackhole);\n+  }\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -204,0 +204,9 @@\n+  bool check_intrinsic_candidate() const {\n+    if (intrinsic_id() == vmIntrinsics::_blackhole) {\n+      \/\/ This is the intrinsic without an associated method, so no intrinsic_candidate\n+      \/\/ flag is set. The intrinsic is still correct.\n+      return true;\n+    }\n+    return (CheckIntrinsics ? intrinsic_candidate() : true);\n+  }\n+\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -5298,0 +5298,5 @@\n+        if (vmIntrinsics::_blackhole == id) {\n+          \/\/ The _blackhole intrinsic is a special marker. No explicit method\n+          \/\/ is defined for it.\n+          continue;\n+        }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -154,0 +154,1 @@\n+  case vmIntrinsics::_blackhole:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -536,0 +536,3 @@\n+  \/* special marker for blackholed methods: *\/                                                                          \\\n+  do_intrinsic(_blackhole,                java_lang_Object,       blackhole_name, star_name, F_RN)                      \\\n+                                                                                                                        \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -285,0 +285,1 @@\n+  template(blackhole_name,                            \"<blackhole>\")  \/*fake name*\/               \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -414,0 +414,4 @@\n+bool CompilerOracle::should_blackhole(const methodHandle& method) {\n+  return (check_predicate(CompileCommand::Blackhole, method));\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+  option(Blackhole,  \"blackhole\", Bool) \\\n@@ -143,0 +144,3 @@\n+  \/\/ Tells whether to blackhole when compiling method\n+  static bool should_blackhole(const methodHandle& method);\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -678,0 +678,2 @@\n+  case vmIntrinsics::_blackhole:\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+macro(Blackhole)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3467,0 +3467,2 @@\n+  case Op_Blackhole:\n+    break;\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-  if ((CheckIntrinsics ? callee->intrinsic_candidate() : true) &&\n+  if (callee->check_intrinsic_candidate() &&\n@@ -670,0 +670,3 @@\n+  case vmIntrinsics::_blackhole:\n+    return inline_blackhole();\n+\n@@ -6851,0 +6854,17 @@\n+\n+\/\/------------------------------- inline_blackhole --------------------------------------\n+\/\/\n+\/\/ Make sure all arguments to this node are alive.\n+\/\/ This matches methods that were requested to be blackholed through compile commands.\n+\/\/\n+bool LibraryCallKit::inline_blackhole() {\n+  Node* bh = insert_mem_bar(Op_Blackhole);\n+\n+  \/\/ Bind call arguments as blackhole arguments to keep them alive\n+  uint nargs = method()->arg_size();\n+  for (uint i = 0; i < nargs; i++) {\n+    bh->add_req(argument(i));\n+  }\n+\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -347,0 +347,2 @@\n+\n+  bool inline_blackhole();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3224,0 +3224,1 @@\n+  case Op_Blackhole:         return new BlackholeNode(C, atp, pn);\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1338,0 +1338,17 @@\n+\/\/------------------------------BlackholeNode----------------------------\n+\/\/ Blackhole all arguments. This node would survive through the compiler\n+\/\/ the effects on its arguments, and would be finally matched to nothing.\n+class BlackholeNode : public MemBarNode {\n+public:\n+  BlackholeNode(Compile* C, int alias_idx, Node* precedent)\n+    : MemBarNode(C, alias_idx, precedent) {}\n+  virtual int   Opcode() const;\n+  virtual uint ideal_reg() const { return 0; } \/\/ not matched in the AD file\n+  const RegMask &in_RegMask(uint idx) const {\n+    \/\/ Fake the incoming arguments mask for blackholes: accept all registers\n+    \/\/ and all stack slots. This would avoid moving the arguments for the\n+    \/\/ call that never happens.\n+    return RegMask::All;\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+class BlackholeNode;\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -54,0 +54,7 @@\n+const RegMask RegMask::All(\n+# define BODY(I) -1,\n+  FORALL_BODY\n+# undef BODY\n+  0\n+);\n+\n","filename":"src\/hotspot\/share\/opto\/regmask.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -359,0 +359,1 @@\n+  static const RegMask All;     \/\/ Common all mask\n","filename":"src\/hotspot\/share\/opto\/regmask.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1597,0 +1597,1 @@\n+  declare_c2_type(BlackholeNode, MemBarNode)                              \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test id=c1\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceOneArgTest\n+ *\/\n+\n+\/**\n+ * @test id=c2\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceOneArgTest\n+ *\/\n+\n+\/**\n+ * @test id=c1-no-coops\n+ * @requires vm.bits == \"64\"\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceOneArgTest\n+ *\/\n+\n+\/**\n+ * @test id=c2-no-coops\n+ * @requires vm.bits == \"64\"\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceOneArgTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+public class BlackholeInstanceOneArgTest {\n+\n+    public static void main(String[] args) {\n+        runTries(BlackholeInstanceOneArgTest::test_boolean);\n+        runTries(BlackholeInstanceOneArgTest::test_byte);\n+        runTries(BlackholeInstanceOneArgTest::test_char);\n+        runTries(BlackholeInstanceOneArgTest::test_short);\n+        runTries(BlackholeInstanceOneArgTest::test_int);\n+        runTries(BlackholeInstanceOneArgTest::test_float);\n+        runTries(BlackholeInstanceOneArgTest::test_long);\n+        runTries(BlackholeInstanceOneArgTest::test_double);\n+        runTries(BlackholeInstanceOneArgTest::test_Object);\n+    }\n+\n+    private static final int CYCLES = 1_000_000;\n+    private static final int TRIES = 10;\n+\n+    public static void runTries(Runnable r) {\n+        for (int t = 0; t < TRIES; t++) {\n+            BlackholeTarget.clear();\n+            r.run();\n+            if (t == TRIES - 1) {\n+               BlackholeTarget.shouldNotBeEntered();\n+            }\n+        }\n+    }\n+\n+    private static void test_boolean() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_boolean((c & 0x1) == 0);\n+        }\n+    }\n+\n+    private static void test_byte() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_byte((byte)c);\n+        }\n+    }\n+\n+    private static void test_char() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_char((char)c);\n+        }\n+    }\n+\n+    private static void test_short() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_short((short)c);\n+        }\n+    }\n+\n+    private static void test_int() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_int(c);\n+        }\n+    }\n+\n+    private static void test_float() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_float(c);\n+        }\n+    }\n+\n+    private static void test_long() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_long(c);\n+        }\n+    }\n+\n+    private static void test_double() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_double(c);\n+        }\n+    }\n+\n+    private static void test_Object() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            Object o = new Object();\n+            t.bh_i_Object(o);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeInstanceOneArgTest.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test id=c1\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceReturnTest\n+ *\/\n+\n+\/**\n+ * @test id=c2\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceReturnTest\n+ *\/\n+\n+\/**\n+ * @test id=c1-no-coops\n+ * @requires vm.bits == \"64\"\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceReturnTest\n+ *\/\n+\n+\/**\n+ * @test id=c2-no-coops\n+ * @requires vm.bits == \"64\"\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceReturnTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+public class BlackholeInstanceReturnTest {\n+\n+    public static void main(String[] args) {\n+        runTries(BlackholeInstanceReturnTest::test_boolean);\n+        runTries(BlackholeInstanceReturnTest::test_byte);\n+        runTries(BlackholeInstanceReturnTest::test_char);\n+        runTries(BlackholeInstanceReturnTest::test_short);\n+        runTries(BlackholeInstanceReturnTest::test_int);\n+        runTries(BlackholeInstanceReturnTest::test_float);\n+        runTries(BlackholeInstanceReturnTest::test_long);\n+        runTries(BlackholeInstanceReturnTest::test_double);\n+        runTries(BlackholeInstanceReturnTest::test_Object);\n+    }\n+\n+    private static final int CYCLES = 1_000_000;\n+    private static final int TRIES = 10;\n+\n+    public static void runTries(Runnable r) {\n+        for (int t = 0; t < TRIES; t++) {\n+            BlackholeTarget.clear();\n+            r.run();\n+            BlackholeTarget.shouldBeEntered();\n+        }\n+    }\n+\n+    private static void test_boolean() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (t.bh_ir_boolean((c & 0x1) == 0) != false) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_byte() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (t.bh_ir_byte((byte)c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_char() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (t.bh_ir_char((char)c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_short() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (t.bh_ir_short((short)c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_int() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (t.bh_ir_int(c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_float() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (t.bh_ir_float(c) != 0F) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_long() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (t.bh_ir_long(c) != 0L) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_double() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (t.bh_ir_double(c) != 0D) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_Object() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            Object o = new Object();\n+            if (t.bh_ir_Object(o) != null) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeInstanceReturnTest.java","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test id=c1\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceTwoArgTest\n+ *\/\n+\n+\/**\n+ * @test id=c2\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceTwoArgTest\n+ *\/\n+\n+\/**\n+ * @test id=c1-no-coops\n+ * @requires vm.bits == \"64\"\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceTwoArgTest\n+ *\/\n+\n+\/**\n+ * @test id=c2-no-coops\n+ * @requires vm.bits == \"64\"\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceTwoArgTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+public class BlackholeInstanceTwoArgTest {\n+\n+    public static void main(String[] args) {\n+        runTries(BlackholeInstanceTwoArgTest::test_boolean);\n+        runTries(BlackholeInstanceTwoArgTest::test_byte);\n+        runTries(BlackholeInstanceTwoArgTest::test_char);\n+        runTries(BlackholeInstanceTwoArgTest::test_short);\n+        runTries(BlackholeInstanceTwoArgTest::test_int);\n+        runTries(BlackholeInstanceTwoArgTest::test_float);\n+        runTries(BlackholeInstanceTwoArgTest::test_long);\n+        runTries(BlackholeInstanceTwoArgTest::test_double);\n+        runTries(BlackholeInstanceTwoArgTest::test_Object);\n+    }\n+\n+    private static final int CYCLES = 1_000_000;\n+    private static final int TRIES = 10;\n+\n+    public static void runTries(Runnable r) {\n+        for (int t = 0; t < TRIES; t++) {\n+            BlackholeTarget.clear();\n+            r.run();\n+            if (t == TRIES - 1) {\n+               BlackholeTarget.shouldNotBeEntered();\n+            }\n+        }\n+    }\n+\n+    private static void test_boolean() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_boolean_2((c & 0x1) == 0, (c & 0x2) == 0);\n+        }\n+    }\n+\n+    private static void test_byte() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_byte_2((byte)c, (byte)(c + 1));\n+        }\n+    }\n+\n+    private static void test_char() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_char_2((char)c, (char)(c + 1));\n+        }\n+    }\n+\n+    private static void test_short() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_short_2((short)c, (short)(c + 1));\n+        }\n+    }\n+\n+    private static void test_int() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_int_2(c, c + 1);\n+        }\n+    }\n+\n+    private static void test_float() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_float_2(c, c + 1);\n+        }\n+    }\n+\n+    private static void test_long() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_long_2(c, c + 1);\n+        }\n+    }\n+\n+    private static void test_double() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_double_2(c, c + 1);\n+        }\n+    }\n+\n+    private static void test_Object() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            Object o1 = new Object();\n+            Object o2 = new Object();\n+            t.bh_i_Object_2(o1, o2);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeInstanceTwoArgTest.java","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test id=c1\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeNullCheckTest\n+ *\/\n+\n+\/**\n+ * @test id=c2\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeNullCheckTest\n+ *\/\n+\n+\/**\n+ * @test id=c1-no-coops\n+ * @requires vm.bits == \"64\"\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeNullCheckTest\n+ *\/\n+\n+\/**\n+ * @test id=c2-no-coops\n+ * @requires vm.bits == \"64\"\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeNullCheckTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+public class BlackholeNullCheckTest {\n+\n+    public static void main(String[] args) {\n+        BlackholeNullCheckTest t = new BlackholeNullCheckTest();\n+        runTries(t::test_local_sf);\n+        runTries(t::test_local_s);\n+        runTries(t::test_local);\n+        runTries(t::test_field_sf);\n+        runTries(t::test_field_s);\n+        runTries(t::test_field);\n+    }\n+\n+    private static final int CYCLES = 1_000_000;\n+    private static final int TRIES = 10;\n+\n+    public static void runTries(Runnable r) {\n+        for (int t = 0; t < TRIES; t++) {\n+            r.run();\n+        }\n+    }\n+\n+    static final BlackholeTarget BH_SF_TARGET = null;\n+    static       BlackholeTarget BH_S_TARGET = null;\n+                 BlackholeTarget BH_TARGET = null;\n+\n+    private void test_local_sf() {\n+        test_with(BH_SF_TARGET);\n+    }\n+\n+    private void test_local_s() {\n+        test_with(BH_S_TARGET);\n+    }\n+\n+    private void test_local() {\n+        test_with(BH_TARGET);\n+    }\n+\n+    private void test_with(BlackholeTarget t) {\n+        try {\n+            t.bh_s_boolean(false);\n+        } catch (NullPointerException npe) {\n+            throw new IllegalStateException(\"Unexpected NPE\");\n+        }\n+\n+        try {\n+            t.call_for_null_check();\n+            throw new IllegalStateException(\"Expected NPE\");\n+        } catch (NullPointerException npe) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    private void test_field_sf() {\n+        try {\n+            BH_SF_TARGET.bh_s_boolean(false);\n+        } catch (NullPointerException npe) {\n+            throw new IllegalStateException(\"Unexpected NPE\");\n+        }\n+\n+        try {\n+            BH_SF_TARGET.call_for_null_check();\n+            throw new IllegalStateException(\"Expected NPE\");\n+        } catch (NullPointerException npe) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    private void test_field_s() {\n+        try {\n+            BH_S_TARGET.bh_s_boolean(false);\n+        } catch (NullPointerException npe) {\n+            throw new IllegalStateException(\"Unexpected NPE\");\n+        }\n+\n+        try {\n+            BH_S_TARGET.call_for_null_check();\n+            throw new IllegalStateException(\"Expected NPE\");\n+        } catch (NullPointerException npe) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    private void test_field() {\n+        try {\n+            BH_TARGET.bh_s_boolean(false);\n+        } catch (NullPointerException npe) {\n+            throw new IllegalStateException(\"Unexpected NPE\");\n+        }\n+\n+        try {\n+            BH_TARGET.call_for_null_check();\n+            throw new IllegalStateException(\"Expected NPE\");\n+        } catch (NullPointerException npe) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeNullCheckTest.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test id=c1\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticOneArgTest\n+ *\/\n+\n+\/**\n+ * @test id=c2\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticOneArgTest\n+ *\/\n+\n+\/**\n+ * @test id=c1-no-coops\n+ * @requires vm.bits == \"64\"\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticOneArgTest\n+ *\/\n+\n+\/**\n+ * @test id=c2-no-coops\n+ * @requires vm.bits == \"64\"\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticOneArgTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+public class BlackholeStaticOneArgTest {\n+\n+    public static void main(String[] args) {\n+        runTries(BlackholeStaticOneArgTest::test_boolean);\n+        runTries(BlackholeStaticOneArgTest::test_byte);\n+        runTries(BlackholeStaticOneArgTest::test_char);\n+        runTries(BlackholeStaticOneArgTest::test_short);\n+        runTries(BlackholeStaticOneArgTest::test_int);\n+        runTries(BlackholeStaticOneArgTest::test_float);\n+        runTries(BlackholeStaticOneArgTest::test_long);\n+        runTries(BlackholeStaticOneArgTest::test_double);\n+        runTries(BlackholeStaticOneArgTest::test_Object);\n+    }\n+\n+    private static final int CYCLES = 1_000_000;\n+    private static final int TRIES = 10;\n+\n+    public static void runTries(Runnable r) {\n+        for (int t = 0; t < TRIES; t++) {\n+            BlackholeTarget.clear();\n+            r.run();\n+            if (t == TRIES - 1) {\n+               BlackholeTarget.shouldNotBeEntered();\n+            }\n+        }\n+    }\n+\n+    private static void test_boolean() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_boolean((c & 0x1) == 0);\n+        }\n+    }\n+\n+    private static void test_byte() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_byte((byte)c);\n+        }\n+    }\n+\n+    private static void test_char() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_char((char)c);\n+        }\n+    }\n+\n+    private static void test_short() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_short((short)c);\n+        }\n+    }\n+\n+    private static void test_int() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_int(c);\n+        }\n+    }\n+\n+    private static void test_float() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_float(c);\n+        }\n+    }\n+\n+    private static void test_long() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_long(c);\n+        }\n+    }\n+\n+    private static void test_double() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_double(c);\n+        }\n+    }\n+\n+    private static void test_Object() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            Object o = new Object();\n+            BlackholeTarget.bh_s_Object(o);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeStaticOneArgTest.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test id=c1\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticReturnTest\n+ *\/\n+\n+\/**\n+ * @test id=c2\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticReturnTest\n+ *\/\n+\n+\/**\n+ * @test id=c1-no-coops\n+ * @requires vm.bits == \"64\"\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticReturnTest\n+ *\/\n+\n+\/**\n+ * @test id=c2-no-coops\n+ * @requires vm.bits == \"64\"\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticReturnTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+public class BlackholeStaticReturnTest {\n+\n+    public static void main(String[] args) {\n+        runTries(BlackholeStaticReturnTest::test_boolean);\n+        runTries(BlackholeStaticReturnTest::test_byte);\n+        runTries(BlackholeStaticReturnTest::test_char);\n+        runTries(BlackholeStaticReturnTest::test_short);\n+        runTries(BlackholeStaticReturnTest::test_int);\n+        runTries(BlackholeStaticReturnTest::test_float);\n+        runTries(BlackholeStaticReturnTest::test_long);\n+        runTries(BlackholeStaticReturnTest::test_double);\n+        runTries(BlackholeStaticReturnTest::test_Object);\n+    }\n+\n+    private static final int CYCLES = 1_000_000;\n+    private static final int TRIES = 10;\n+\n+    public static void runTries(Runnable r) {\n+        for (int t = 0; t < TRIES; t++) {\n+            BlackholeTarget.clear();\n+            r.run();\n+            BlackholeTarget.shouldBeEntered();\n+        }\n+    }\n+\n+    private static void test_boolean() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (BlackholeTarget.bh_sr_boolean((c & 0x1) == 0) != false) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_byte() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (BlackholeTarget.bh_sr_byte((byte)c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_char() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (BlackholeTarget.bh_sr_char((char)c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_short() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (BlackholeTarget.bh_sr_short((short)c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_int() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (BlackholeTarget.bh_sr_int(c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_float() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (BlackholeTarget.bh_sr_float(c) != 0F) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_long() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (BlackholeTarget.bh_sr_long(c) != 0L) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_double() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (BlackholeTarget.bh_sr_double(c) != 0D) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_Object() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            Object o = new Object();\n+            if (BlackholeTarget.bh_sr_Object(o) != null) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeStaticReturnTest.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test id=c1\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticTwoArgTest\n+ *\/\n+\n+\/**\n+ * @test id=c2\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticTwoArgTest\n+ *\/\n+\n+\/**\n+ * @test id=c1-no-coops\n+ * @requires vm.bits == \"64\"\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticTwoArgTest\n+ *\/\n+\n+\/**\n+ * @test id=c2-no-coops\n+ * @requires vm.bits == \"64\"\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticTwoArgTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+public class BlackholeStaticTwoArgTest {\n+\n+    public static void main(String[] args) {\n+        runTries(BlackholeStaticTwoArgTest::test_boolean);\n+        runTries(BlackholeStaticTwoArgTest::test_byte);\n+        runTries(BlackholeStaticTwoArgTest::test_char);\n+        runTries(BlackholeStaticTwoArgTest::test_short);\n+        runTries(BlackholeStaticTwoArgTest::test_int);\n+        runTries(BlackholeStaticTwoArgTest::test_float);\n+        runTries(BlackholeStaticTwoArgTest::test_long);\n+        runTries(BlackholeStaticTwoArgTest::test_double);\n+        runTries(BlackholeStaticTwoArgTest::test_Object);\n+    }\n+\n+    private static final int CYCLES = 1_000_000;\n+    private static final int TRIES = 10;\n+\n+    public static void runTries(Runnable r) {\n+        for (int t = 0; t < TRIES; t++) {\n+            BlackholeTarget.clear();\n+            r.run();\n+            if (t == TRIES - 1) {\n+               BlackholeTarget.shouldNotBeEntered();\n+            }\n+        }\n+    }\n+\n+    private static void test_boolean() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_boolean_2((c & 0x1) == 0, (c & 0x2) == 0);\n+        }\n+    }\n+\n+    private static void test_byte() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_byte_2((byte)c, (byte)(c + 1));\n+        }\n+    }\n+\n+    private static void test_char() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_char_2((char)c, (char)(c + 1));\n+        }\n+    }\n+\n+    private static void test_short() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_short_2((short)c, (short)(c + 1));\n+        }\n+    }\n+\n+    private static void test_int() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_int_2(c, c + 1);\n+        }\n+    }\n+\n+    private static void test_float() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_float_2(c, c + 1);\n+        }\n+    }\n+\n+    private static void test_long() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_long_2(c, c + 1);\n+        }\n+    }\n+\n+    private static void test_double() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_double_2(c, c + 1);\n+        }\n+    }\n+\n+    private static void test_Object() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            Object o1 = new Object();\n+            Object o2 = new Object();\n+            BlackholeTarget.bh_s_Object_2(o1, o2);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeStaticTwoArgTest.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.blackhole;\n+\n+import java.lang.reflect.*;\n+\n+public class BlackholeTarget {\n+    private static String entered;\n+\n+    private static void registerEntered(String label) {\n+        if (entered == null) {\n+           entered = label;\n+        } else if (!entered.equals(label)) {\n+           throw new IllegalStateException(\"Trying to register enter with overwrite: \" + entered + \" -> \" + label);\n+        }\n+    }\n+\n+    public static void clear() {\n+        entered = null;\n+    }\n+\n+    public static void shouldBeEntered() {\n+        if (entered == null) {\n+            throw new IllegalStateException(\"Should have been entered\");\n+        }\n+    }\n+\n+    public static void shouldNotBeEntered() {\n+        if (entered != null) {\n+            throw new IllegalStateException(\"Should not have been entered: \" + entered);\n+        }\n+    }\n+\n+    public void call_for_null_check() {}\n+\n+    public static void    bh_s_boolean(boolean v)  { registerEntered(\"bh_s_boolean\"); }\n+    public static void    bh_s_byte(byte v)        { registerEntered(\"bh_s_byte\");    }\n+    public static void    bh_s_short(short v)      { registerEntered(\"bh_s_short\");   }\n+    public static void    bh_s_char(char v)        { registerEntered(\"bh_s_char\");    }\n+    public static void    bh_s_int(int v)          { registerEntered(\"bh_s_int\");     }\n+    public static void    bh_s_float(float v)      { registerEntered(\"bh_s_float\");   }\n+    public static void    bh_s_long(long v)        { registerEntered(\"bh_s_long\");    }\n+    public static void    bh_s_double(double v)    { registerEntered(\"bh_s_double\");  }\n+    public static void    bh_s_Object(Object v)    { registerEntered(\"bh_s_Object\");  }\n+\n+    public        void    bh_i_boolean(boolean v)  { registerEntered(\"bh_i_boolean\"); }\n+    public        void    bh_i_byte(byte v)        { registerEntered(\"bh_i_byte\");    }\n+    public        void    bh_i_short(short v)      { registerEntered(\"bh_i_short\");   }\n+    public        void    bh_i_char(char v)        { registerEntered(\"bh_i_char\");    }\n+    public        void    bh_i_int(int v)          { registerEntered(\"bh_i_int\");     }\n+    public        void    bh_i_float(float v)      { registerEntered(\"bh_i_float\");   }\n+    public        void    bh_i_long(long v)        { registerEntered(\"bh_i_long\");    }\n+    public        void    bh_i_double(double v)    { registerEntered(\"bh_i_double\");  }\n+    public        void    bh_i_Object(Object v)    { registerEntered(\"bh_i_Object\");  }\n+\n+    public static void    bh_s_boolean_2(boolean v1, boolean v2) { registerEntered(\"bh_s_boolean_2\"); }\n+    public static void    bh_s_byte_2(byte v1, byte v2)          { registerEntered(\"bh_s_byte_2\");    }\n+    public static void    bh_s_short_2(short v1, short v2)       { registerEntered(\"bh_s_short_2\");   }\n+    public static void    bh_s_char_2(char v1, char v2)          { registerEntered(\"bh_s_char_2\");    }\n+    public static void    bh_s_int_2(int v1, int v2)             { registerEntered(\"bh_s_int_2\");     }\n+    public static void    bh_s_float_2(float v1, float v2)       { registerEntered(\"bh_s_float_2\");   }\n+    public static void    bh_s_long_2(long v1, long v2)          { registerEntered(\"bh_s_long_2\");    }\n+    public static void    bh_s_double_2(double v1, double v2)    { registerEntered(\"bh_s_double_2\");  }\n+    public static void    bh_s_Object_2(Object v1, Object v2)    { registerEntered(\"bh_s_Object_2\");  }\n+\n+    public        void    bh_i_boolean_2(boolean v1, boolean v2) { registerEntered(\"bh_i_boolean_2\"); }\n+    public        void    bh_i_byte_2(byte v1, byte v2)          { registerEntered(\"bh_i_byte_2\");    }\n+    public        void    bh_i_short_2(short v1, short v2)       { registerEntered(\"bh_i_short_2\");   }\n+    public        void    bh_i_char_2(char v1, char v2)          { registerEntered(\"bh_i_char_2\");    }\n+    public        void    bh_i_int_2(int v1, int v2)             { registerEntered(\"bh_i_int_2\");     }\n+    public        void    bh_i_float_2(float v1, float v2)       { registerEntered(\"bh_i_float_2\");   }\n+    public        void    bh_i_long_2(long v1, long v2)          { registerEntered(\"bh_i_long_2\");    }\n+    public        void    bh_i_double_2(double v1, double v2)    { registerEntered(\"bh_i_double_2\");  }\n+    public        void    bh_i_Object_2(Object v1, Object v2)    { registerEntered(\"bh_i_Object_2\");  }\n+\n+    public static boolean bh_sr_boolean(boolean v) { registerEntered(\"bh_sr_boolean\"); return false; }\n+    public static byte    bh_sr_byte(byte v)       { registerEntered(\"bh_sr_byte\");    return 0;     }\n+    public static short   bh_sr_short(short v)     { registerEntered(\"bh_sr_short\");   return 0;     }\n+    public static char    bh_sr_char(char v)       { registerEntered(\"bh_sr_char\");    return 0;     }\n+    public static int     bh_sr_int(int v)         { registerEntered(\"bh_sr_int\");     return 0;     }\n+    public static float   bh_sr_float(float v)     { registerEntered(\"bh_sr_float\");   return 0;     }\n+    public static long    bh_sr_long(long v)       { registerEntered(\"bh_sr_long\");    return 0;     }\n+    public static double  bh_sr_double(double v)   { registerEntered(\"bh_sr_double\");  return 0;     }\n+    public static Object  bh_sr_Object(Object v)   { registerEntered(\"bh_sr_Object\");  return null;  }\n+\n+    public        boolean bh_ir_boolean(boolean v) { registerEntered(\"bh_ir_boolean\"); return false; }\n+    public        byte    bh_ir_byte(byte v)       { registerEntered(\"bh_ir_byte\");    return 0;     }\n+    public        short   bh_ir_short(short v)     { registerEntered(\"bh_ir_short\");   return 0;     }\n+    public        char    bh_ir_char(char v)       { registerEntered(\"bh_ir_char\");    return 0;     }\n+    public        int     bh_ir_int(int v)         { registerEntered(\"bh_ir_int\");     return 0;     }\n+    public        float   bh_ir_float(float v)     { registerEntered(\"bh_ir_float\");   return 0;     }\n+    public        long    bh_ir_long(long v)       { registerEntered(\"bh_ir_long\");    return 0;     }\n+    public        double  bh_ir_double(double v)   { registerEntered(\"bh_ir_double\");  return 0;     }\n+    public        Object  bh_ir_Object(Object v)   { registerEntered(\"bh_ir_Object\");  return null;  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeTarget.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"}]}