{"files":[{"patch":"@@ -233,0 +233,2 @@\n+  case vmIntrinsics::_blackhole:\n+    break;\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3418,1 +3418,1 @@\n-      (CheckIntrinsics ? callee->intrinsic_candidate() : true)) {\n+      callee->check_intrinsic_candidate()) {\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3209,0 +3209,4 @@\n+  case vmIntrinsics::_blackhole:\n+    do_blackhole(x);\n+    break;\n+\n@@ -3628,0 +3632,17 @@\n+void LIRGenerator::do_blackhole(Intrinsic *x) {\n+  \/\/ If we have a receiver, then null-check and handle it separately\n+  bool handle_receiver = x->needs_null_check();\n+  if (handle_receiver) {\n+    CodeEmitInfo* info = state_for(x);\n+    LIRItem vitem(x->receiver(), this);\n+    vitem.load_item();\n+    __ null_check(vitem.result(), info);\n+  }\n+\n+  for (int c = (handle_receiver ? 1 : 0); c < x->number_of_arguments(); c++) {\n+    \/\/ Load the argument\n+    LIRItem vitem(x->argument_at(c), this);\n+    vitem.load_item();\n+    \/\/ ...and leave it unused.\n+  }\n+}\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -268,0 +268,1 @@\n+  void do_blackhole(Intrinsic* x);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -158,0 +158,4 @@\n+\n+  if (CompilerOracle::should_blackhole(h_m)) {\n+    h_m->set_intrinsic_id(vmIntrinsics::_blackhole);\n+  }\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -204,0 +204,9 @@\n+  bool check_intrinsic_candidate() const {\n+    if (intrinsic_id() == vmIntrinsics::_blackhole) {\n+      \/\/ This is the intrinsic without an associated method, so no intrinsic_candidate\n+      \/\/ flag is set. The intrinsic is still correct.\n+      return true;\n+    }\n+    return (CheckIntrinsics ? intrinsic_candidate() : true);\n+  }\n+\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -5298,0 +5298,5 @@\n+        if (vmIntrinsics::_blackhole == id) {\n+          \/\/ The _blackhole intrinsic is a special marker. No explicit method\n+          \/\/ is defined for it.\n+          continue;\n+        }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -154,0 +154,1 @@\n+  case vmIntrinsics::_blackhole:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -536,0 +536,3 @@\n+  \/* special marker for blackholed methods: *\/                                                                          \\\n+  do_intrinsic(_blackhole,                java_lang_Object,       blackhole_name, star_name, F_S)                       \\\n+                                                                                                                        \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -285,0 +285,1 @@\n+  template(blackhole_name,                            \"<blackhole>\")  \/*fake name*\/               \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -412,0 +412,12 @@\n+bool CompilerOracle::should_blackhole(const methodHandle& method) {\n+  if (check_predicate(CompileCommand::Blackhole, method)) {\n+    if (method->result_type() == T_VOID) {\n+      return true;\n+    } else {\n+      warning(\"blackhole compile command only works for methods with void type: %s\",\n+              method->name_and_sig_as_C_string());\n+    }\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+  option(Blackhole,  \"blackhole\", Bool) \\\n@@ -143,0 +144,3 @@\n+  \/\/ Tells whether to blackhole when compiling method\n+  static bool should_blackhole(const methodHandle& method);\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -678,0 +678,2 @@\n+  case vmIntrinsics::_blackhole:\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+macro(Blackhole)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3467,0 +3467,2 @@\n+  case Op_Blackhole:\n+    break;\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-  if ((CheckIntrinsics ? callee->intrinsic_candidate() : true) &&\n+  if (callee->check_intrinsic_candidate() &&\n@@ -670,0 +670,3 @@\n+  case vmIntrinsics::_blackhole:\n+    return inline_blackhole();\n+\n@@ -6851,0 +6854,30 @@\n+\n+\/\/------------------------------- inline_blackhole --------------------------------------\n+\/\/\n+\/\/ Make sure all arguments to this node are alive.\n+\/\/ This matches methods that were requested to be blackholed through compile commands.\n+\/\/\n+bool LibraryCallKit::inline_blackhole() {\n+  \/\/ To preserve the semantics of Java call, we need to null-check the receiver,\n+  \/\/ if present. Shortcut if receiver is unconditionally null.\n+  Node* receiver = NULL;\n+  bool has_receiver = !callee()->is_static();\n+  if (has_receiver) {\n+    receiver = null_check_receiver();\n+    if (stopped()) {\n+      return true;\n+    }\n+  }\n+\n+  \/\/ Bind call arguments as blackhole arguments to keep them alive\n+  Node* bh = insert_mem_bar(Op_Blackhole);\n+  if (has_receiver) {\n+    bh->add_req(receiver);\n+  }\n+  uint nargs = callee()->arg_size();\n+  for (uint i = has_receiver ? 1 : 0; i < nargs; i++) {\n+    bh->add_req(argument(i));\n+  }\n+\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -347,0 +347,2 @@\n+\n+  bool inline_blackhole();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"opto\/regalloc.hpp\"\n@@ -3224,0 +3225,1 @@\n+  case Op_Blackhole:         return new BlackholeNode(C, atp, pn);\n@@ -3458,0 +3460,21 @@\n+#ifndef PRODUCT\n+void BlackholeNode::format(PhaseRegAlloc* ra, outputStream* st) const {\n+  st->print(\"blackhole \");\n+  bool first = true;\n+  for (uint i = 0; i < req(); i++) {\n+    Node* n = in(i);\n+    if (n != NULL && OptoReg::is_valid(ra->get_reg_first(n))) {\n+      if (first) {\n+        first = false;\n+      } else {\n+        st->print(\", \");\n+      }\n+      char buf[128];\n+      ra->dump_register(n, buf);\n+      st->print(\"%s\", buf);\n+    }\n+  }\n+  st->cr();\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1338,0 +1338,20 @@\n+\/\/------------------------------BlackholeNode----------------------------\n+\/\/ Blackhole all arguments. This node would survive through the compiler\n+\/\/ the effects on its arguments, and would be finally matched to nothing.\n+class BlackholeNode : public MemBarNode {\n+public:\n+  BlackholeNode(Compile* C, int alias_idx, Node* precedent)\n+    : MemBarNode(C, alias_idx, precedent) {}\n+  virtual int   Opcode() const;\n+  virtual uint ideal_reg() const { return 0; } \/\/ not matched in the AD file\n+  const RegMask &in_RegMask(uint idx) const {\n+    \/\/ Fake the incoming arguments mask for blackholes: accept all registers\n+    \/\/ and all stack slots. This would avoid moving the arguments for the\n+    \/\/ call that never happens.\n+    return RegMask::All;\n+  }\n+#ifndef PRODUCT\n+  virtual void format(PhaseRegAlloc* ra, outputStream* st) const;\n+#endif\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+class BlackholeNode;\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -54,0 +54,7 @@\n+const RegMask RegMask::All(\n+# define BODY(I) -1,\n+  FORALL_BODY\n+# undef BODY\n+  0\n+);\n+\n","filename":"src\/hotspot\/share\/opto\/regmask.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -359,0 +359,1 @@\n+  static const RegMask All;     \/\/ Common all mask\n","filename":"src\/hotspot\/share\/opto\/regmask.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1597,0 +1597,1 @@\n+  declare_c2_type(BlackholeNode, MemBarNode)                              \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test id=c1\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceReturnTest\n+ *\/\n+\n+\/**\n+ * @test id=c2\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceReturnTest\n+ *\/\n+\n+\/**\n+ * @test id=c1-no-coops\n+ * @requires vm.bits == \"64\"\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceReturnTest\n+ *\/\n+\n+\/**\n+ * @test id=c2-no-coops\n+ * @requires vm.bits == \"64\"\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceReturnTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+public class BlackholeInstanceReturnTest {\n+\n+    public static void main(String[] args) {\n+        runTries(BlackholeInstanceReturnTest::test_boolean);\n+        runTries(BlackholeInstanceReturnTest::test_byte);\n+        runTries(BlackholeInstanceReturnTest::test_char);\n+        runTries(BlackholeInstanceReturnTest::test_short);\n+        runTries(BlackholeInstanceReturnTest::test_int);\n+        runTries(BlackholeInstanceReturnTest::test_float);\n+        runTries(BlackholeInstanceReturnTest::test_long);\n+        runTries(BlackholeInstanceReturnTest::test_double);\n+        runTries(BlackholeInstanceReturnTest::test_Object);\n+    }\n+\n+    private static final int CYCLES = 1_000_000;\n+    private static final int TRIES = 10;\n+\n+    public static void runTries(Runnable r) {\n+        for (int t = 0; t < TRIES; t++) {\n+            BlackholeTarget.clear();\n+            r.run();\n+            BlackholeTarget.shouldBeEntered();\n+        }\n+    }\n+\n+    private static void test_boolean() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (t.bh_ir_boolean((c & 0x1) == 0) != false) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_byte() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (t.bh_ir_byte((byte)c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_char() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (t.bh_ir_char((char)c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_short() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (t.bh_ir_short((short)c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_int() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (t.bh_ir_int(c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_float() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (t.bh_ir_float(c) != 0F) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_long() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (t.bh_ir_long(c) != 0L) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_double() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (t.bh_ir_double(c) != 0D) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_Object() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            Object o = new Object();\n+            if (t.bh_ir_Object(o) != null) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeInstanceReturnTest.java","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"},{"patch":"@@ -0,0 +1,314 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test id=c1\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceTest\n+ *\/\n+\n+\/**\n+ * @test id=c2\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceTest\n+ *\/\n+\n+\/**\n+ * @test id=c1-no-coops\n+ * @requires vm.bits == \"64\"\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceTest\n+ *\/\n+\n+\/**\n+ * @test id=c2-no-coops\n+ * @requires vm.bits == \"64\"\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+public class BlackholeInstanceTest {\n+\n+    public static void main(String[] args) {\n+        runTries(BlackholeInstanceTest::test_boolean_0);\n+        runTries(BlackholeInstanceTest::test_byte_0);\n+        runTries(BlackholeInstanceTest::test_char_0);\n+        runTries(BlackholeInstanceTest::test_short_0);\n+        runTries(BlackholeInstanceTest::test_int_0);\n+        runTries(BlackholeInstanceTest::test_float_0);\n+        runTries(BlackholeInstanceTest::test_long_0);\n+        runTries(BlackholeInstanceTest::test_double_0);\n+        runTries(BlackholeInstanceTest::test_Object_0);\n+\n+        runTries(BlackholeInstanceTest::test_boolean_1);\n+        runTries(BlackholeInstanceTest::test_byte_1);\n+        runTries(BlackholeInstanceTest::test_char_1);\n+        runTries(BlackholeInstanceTest::test_short_1);\n+        runTries(BlackholeInstanceTest::test_int_1);\n+        runTries(BlackholeInstanceTest::test_float_1);\n+        runTries(BlackholeInstanceTest::test_long_1);\n+        runTries(BlackholeInstanceTest::test_double_1);\n+        runTries(BlackholeInstanceTest::test_Object_1);\n+\n+        runTries(BlackholeInstanceTest::test_boolean_2);\n+        runTries(BlackholeInstanceTest::test_byte_2);\n+        runTries(BlackholeInstanceTest::test_char_2);\n+        runTries(BlackholeInstanceTest::test_short_2);\n+        runTries(BlackholeInstanceTest::test_int_2);\n+        runTries(BlackholeInstanceTest::test_float_2);\n+        runTries(BlackholeInstanceTest::test_long_2);\n+        runTries(BlackholeInstanceTest::test_double_2);\n+        runTries(BlackholeInstanceTest::test_Object_2);\n+    }\n+\n+    private static final int CYCLES = 1_000_000;\n+    private static final int TRIES = 10;\n+\n+    public static void runTries(Runnable r) {\n+        for (int t = 0; t < TRIES; t++) {\n+            BlackholeTarget.clear();\n+            r.run();\n+            if (t == TRIES - 1) {\n+               BlackholeTarget.shouldNotBeEntered();\n+            }\n+        }\n+    }\n+\n+    private static void test_boolean_0() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_boolean_0();\n+        }\n+    }\n+\n+    private static void test_byte_0() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_byte_0();\n+        }\n+    }\n+\n+    private static void test_char_0() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_char_0();\n+        }\n+    }\n+\n+    private static void test_short_0() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_short_0();\n+        }\n+    }\n+\n+    private static void test_int_0() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_int_0();\n+        }\n+    }\n+\n+    private static void test_float_0() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_float_0();\n+        }\n+    }\n+\n+    private static void test_long_0() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_long_0();\n+        }\n+    }\n+\n+    private static void test_double_0() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_double_0();\n+        }\n+    }\n+\n+    private static void test_Object_0() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_Object_0();\n+        }\n+    }\n+\n+    private static void test_boolean_1() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_boolean_1((c & 0x1) == 0);\n+        }\n+    }\n+\n+    private static void test_byte_1() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_byte_1((byte)c);\n+        }\n+    }\n+\n+    private static void test_char_1() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_char_1((char)c);\n+        }\n+    }\n+\n+    private static void test_short_1() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_short_1((short)c);\n+        }\n+    }\n+\n+    private static void test_int_1() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_int_1(c);\n+        }\n+    }\n+\n+    private static void test_float_1() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_float_1(c);\n+        }\n+    }\n+\n+    private static void test_long_1() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_long_1(c);\n+        }\n+    }\n+\n+    private static void test_double_1() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_double_1(c);\n+        }\n+    }\n+\n+    private static void test_Object_1() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            Object o = new Object();\n+            t.bh_i_Object_1(o);\n+        }\n+    }\n+\n+    private static void test_boolean_2() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_boolean_2((c & 0x1) == 0, (c & 0x2) == 0);\n+        }\n+    }\n+\n+    private static void test_byte_2() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_byte_2((byte)c, (byte)(c + 1));\n+        }\n+    }\n+\n+    private static void test_char_2() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_char_2((char)c, (char)(c + 1));\n+        }\n+    }\n+\n+    private static void test_short_2() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_short_2((short)c, (short)(c + 1));\n+        }\n+    }\n+\n+    private static void test_int_2() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_int_2(c, c + 1);\n+        }\n+    }\n+\n+    private static void test_float_2() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_float_2(c, c + 1);\n+        }\n+    }\n+\n+    private static void test_long_2() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_long_2(c, c + 1);\n+        }\n+    }\n+\n+    private static void test_double_2() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_double_2(c, c + 1);\n+        }\n+    }\n+\n+    private static void test_Object_2() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            Object o1 = new Object();\n+            Object o2 = new Object();\n+            t.bh_i_Object_2(o1, o2);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeInstanceTest.java","additions":314,"deletions":0,"binary":false,"changes":314,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build compiler.blackhole.BlackholeTarget\n+ * @run driver compiler.blackhole.BlackholeNonVoidWarning\n+ *\/\n+\n+package compiler.blackhole;\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class BlackholeNonVoidWarning {\n+\n+    private static final int CYCLES = 1_000_000;\n+    private static final int TRIES = 10;\n+\n+    public static void main(String[] args) throws IOException {\n+        if (args.length == 0) {\n+            driver();\n+        } else {\n+            runner();\n+        }\n+    }\n+\n+    public static void driver() throws IOException {\n+       final String msg = \"blackhole compile command only works for methods with void type: compiler.blackhole.BlackholeTarget.bh_sr_int(I)I\";\n+\n+       {\n+           ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+               \"-Xmx128m\",\n+               \"-XX:CompileCommand=quiet\",\n+               \"-XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\",\n+               \"compiler.blackhole.BlackholeNonVoidWarning\",\n+               \"run\"\n+           );\n+           OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+           output.shouldHaveExitValue(0);\n+           output.shouldContain(msg);\n+       }\n+\n+       {\n+           ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+               \"-Xmx128m\",\n+               \"-XX:-PrintWarnings\",\n+               \"-XX:CompileCommand=quiet\",\n+               \"-XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\",\n+               \"compiler.blackhole.BlackholeNonVoidWarning\",\n+               \"run\"\n+           );\n+           OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+           output.shouldHaveExitValue(0);\n+           output.shouldNotContain(msg);\n+       }\n+    }\n+\n+    public static void runner() {\n+        for (int t = 0; t < TRIES; t++) {\n+            run();\n+        }\n+    }\n+\n+    public static void run() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (BlackholeTarget.bh_sr_int(c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeNonVoidWarning.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test id=c1\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeNullCheckTest\n+ *\/\n+\n+\/**\n+ * @test id=c2\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeNullCheckTest\n+ *\/\n+\n+\/**\n+ * @test id=c1-no-coops\n+ * @requires vm.bits == \"64\"\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeNullCheckTest\n+ *\/\n+\n+\/**\n+ * @test id=c2-no-coops\n+ * @requires vm.bits == \"64\"\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeNullCheckTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+public class BlackholeNullCheckTest {\n+\n+    public static void main(String[] args) {\n+        BlackholeNullCheckTest t = new BlackholeNullCheckTest();\n+        runTries(t::test_local_sf);\n+        runTries(t::test_local_s);\n+        runTries(t::test_local);\n+        runTries(t::test_field_sf);\n+        runTries(t::test_field_s);\n+        runTries(t::test_field);\n+    }\n+\n+    private static final int CYCLES = 1_000_000;\n+    private static final int TRIES = 10;\n+\n+    public static void runTries(Runnable r) {\n+        for (int t = 0; t < TRIES; t++) {\n+            r.run();\n+        }\n+    }\n+\n+    static final BlackholeTarget BH_SF_TARGET = null;\n+    static       BlackholeTarget BH_S_TARGET = null;\n+                 BlackholeTarget BH_TARGET = null;\n+\n+    private void test_local_sf() {\n+        test_with(BH_SF_TARGET);\n+    }\n+\n+    private void test_local_s() {\n+        test_with(BH_S_TARGET);\n+    }\n+\n+    private void test_local() {\n+        test_with(BH_TARGET);\n+    }\n+\n+    private void test_with(BlackholeTarget t) {\n+        try {\n+            t.bh_i_boolean_1(false);\n+            throw new IllegalStateException(\"Expected NPE\");\n+        } catch (NullPointerException npe) {\n+        }\n+\n+        try {\n+            t.call_for_null_check();\n+            throw new IllegalStateException(\"Expected NPE\");\n+        } catch (NullPointerException npe) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    private void test_field_sf() {\n+        try {\n+            BH_SF_TARGET.bh_i_boolean_1(false);\n+            throw new IllegalStateException(\"Expected NPE\");\n+        } catch (NullPointerException npe) {\n+        }\n+\n+        try {\n+            BH_SF_TARGET.call_for_null_check();\n+            throw new IllegalStateException(\"Expected NPE\");\n+        } catch (NullPointerException npe) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    private void test_field_s() {\n+        try {\n+            BH_S_TARGET.bh_i_boolean_1(false);\n+            throw new IllegalStateException(\"Expected NPE\");\n+        } catch (NullPointerException npe) {\n+        }\n+\n+        try {\n+            BH_S_TARGET.call_for_null_check();\n+            throw new IllegalStateException(\"Expected NPE\");\n+        } catch (NullPointerException npe) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    private void test_field() {\n+        try {\n+            BH_TARGET.bh_i_boolean_1(false);\n+            throw new IllegalStateException(\"Expected NPE\");\n+        } catch (NullPointerException npe) {\n+        }\n+\n+        try {\n+            BH_TARGET.call_for_null_check();\n+            throw new IllegalStateException(\"Expected NPE\");\n+        } catch (NullPointerException npe) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeNullCheckTest.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test id=c1\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticReturnTest\n+ *\/\n+\n+\/**\n+ * @test id=c2\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticReturnTest\n+ *\/\n+\n+\/**\n+ * @test id=c1-no-coops\n+ * @requires vm.bits == \"64\"\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticReturnTest\n+ *\/\n+\n+\/**\n+ * @test id=c2-no-coops\n+ * @requires vm.bits == \"64\"\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticReturnTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+public class BlackholeStaticReturnTest {\n+\n+    public static void main(String[] args) {\n+        runTries(BlackholeStaticReturnTest::test_boolean);\n+        runTries(BlackholeStaticReturnTest::test_byte);\n+        runTries(BlackholeStaticReturnTest::test_char);\n+        runTries(BlackholeStaticReturnTest::test_short);\n+        runTries(BlackholeStaticReturnTest::test_int);\n+        runTries(BlackholeStaticReturnTest::test_float);\n+        runTries(BlackholeStaticReturnTest::test_long);\n+        runTries(BlackholeStaticReturnTest::test_double);\n+        runTries(BlackholeStaticReturnTest::test_Object);\n+    }\n+\n+    private static final int CYCLES = 1_000_000;\n+    private static final int TRIES = 10;\n+\n+    public static void runTries(Runnable r) {\n+        for (int t = 0; t < TRIES; t++) {\n+            BlackholeTarget.clear();\n+            r.run();\n+            BlackholeTarget.shouldBeEntered();\n+        }\n+    }\n+\n+    private static void test_boolean() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (BlackholeTarget.bh_sr_boolean((c & 0x1) == 0) != false) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_byte() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (BlackholeTarget.bh_sr_byte((byte)c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_char() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (BlackholeTarget.bh_sr_char((char)c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_short() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (BlackholeTarget.bh_sr_short((short)c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_int() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (BlackholeTarget.bh_sr_int(c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_float() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (BlackholeTarget.bh_sr_float(c) != 0F) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_long() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (BlackholeTarget.bh_sr_long(c) != 0L) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_double() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (BlackholeTarget.bh_sr_double(c) != 0D) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_Object() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            Object o = new Object();\n+            if (BlackholeTarget.bh_sr_Object(o) != null) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeStaticReturnTest.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -0,0 +1,287 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test id=c1\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticTest\n+ *\/\n+\n+\/**\n+ * @test id=c2\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticTest\n+ *\/\n+\n+\/**\n+ * @test id=c1-no-coops\n+ * @requires vm.bits == \"64\"\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticTest\n+ *\/\n+\n+\/**\n+ * @test id=c2-no-coops\n+ * @requires vm.bits == \"64\"\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+public class BlackholeStaticTest {\n+\n+    public static void main(String[] args) {\n+        runTries(BlackholeStaticTest::test_boolean_0);\n+        runTries(BlackholeStaticTest::test_byte_0);\n+        runTries(BlackholeStaticTest::test_char_0);\n+        runTries(BlackholeStaticTest::test_short_0);\n+        runTries(BlackholeStaticTest::test_int_0);\n+        runTries(BlackholeStaticTest::test_float_0);\n+        runTries(BlackholeStaticTest::test_long_0);\n+        runTries(BlackholeStaticTest::test_double_0);\n+        runTries(BlackholeStaticTest::test_Object_0);\n+\n+        runTries(BlackholeStaticTest::test_boolean_1);\n+        runTries(BlackholeStaticTest::test_byte_1);\n+        runTries(BlackholeStaticTest::test_char_1);\n+        runTries(BlackholeStaticTest::test_short_1);\n+        runTries(BlackholeStaticTest::test_int_1);\n+        runTries(BlackholeStaticTest::test_float_1);\n+        runTries(BlackholeStaticTest::test_long_1);\n+        runTries(BlackholeStaticTest::test_double_1);\n+        runTries(BlackholeStaticTest::test_Object_1);\n+\n+        runTries(BlackholeStaticTest::test_boolean_2);\n+        runTries(BlackholeStaticTest::test_byte_2);\n+        runTries(BlackholeStaticTest::test_char_2);\n+        runTries(BlackholeStaticTest::test_short_2);\n+        runTries(BlackholeStaticTest::test_int_2);\n+        runTries(BlackholeStaticTest::test_float_2);\n+        runTries(BlackholeStaticTest::test_long_2);\n+        runTries(BlackholeStaticTest::test_double_2);\n+        runTries(BlackholeStaticTest::test_Object_2);\n+    }\n+\n+    private static final int CYCLES = 1_000_000;\n+    private static final int TRIES = 10;\n+\n+    public static void runTries(Runnable r) {\n+        for (int t = 0; t < TRIES; t++) {\n+            BlackholeTarget.clear();\n+            r.run();\n+            if (t == TRIES - 1) {\n+               BlackholeTarget.shouldNotBeEntered();\n+            }\n+        }\n+    }\n+\n+    private static void test_boolean_0() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_boolean_0();\n+        }\n+    }\n+\n+    private static void test_byte_0() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_byte_0();\n+        }\n+    }\n+\n+    private static void test_char_0() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_char_0();\n+        }\n+    }\n+\n+    private static void test_short_0() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_short_0();\n+        }\n+    }\n+\n+    private static void test_int_0() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_int_0();\n+        }\n+    }\n+\n+    private static void test_float_0() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_float_0();\n+        }\n+    }\n+\n+    private static void test_long_0() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_long_0();\n+        }\n+    }\n+\n+    private static void test_double_0() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_double_0();\n+        }\n+    }\n+\n+    private static void test_Object_0() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_Object_0();\n+        }\n+    }\n+\n+    private static void test_boolean_1() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_boolean_1((c & 0x1) == 0);\n+        }\n+    }\n+\n+    private static void test_byte_1() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_byte_1((byte)c);\n+        }\n+    }\n+\n+    private static void test_char_1() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_char_1((char)c);\n+        }\n+    }\n+\n+    private static void test_short_1() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_short_1((short)c);\n+        }\n+    }\n+\n+    private static void test_int_1() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_int_1(c);\n+        }\n+    }\n+\n+    private static void test_float_1() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_float_1(c);\n+        }\n+    }\n+\n+    private static void test_long_1() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_long_1(c);\n+        }\n+    }\n+\n+    private static void test_double_1() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_double_1(c);\n+        }\n+    }\n+\n+    private static void test_Object_1() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            Object o = new Object();\n+            BlackholeTarget.bh_s_Object_1(o);\n+        }\n+    }\n+\n+    private static void test_boolean_2() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_boolean_2((c & 0x1) == 0, (c & 0x2) == 0);\n+        }\n+    }\n+\n+    private static void test_byte_2() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_byte_2((byte)c, (byte)(c + 1));\n+        }\n+    }\n+\n+    private static void test_char_2() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_char_2((char)c, (char)(c + 1));\n+        }\n+    }\n+\n+    private static void test_short_2() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_short_2((short)c, (short)(c + 1));\n+        }\n+    }\n+\n+    private static void test_int_2() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_int_2(c, c + 1);\n+        }\n+    }\n+\n+    private static void test_float_2() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_float_2(c, c + 1);\n+        }\n+    }\n+\n+    private static void test_long_2() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_long_2(c, c + 1);\n+        }\n+    }\n+\n+    private static void test_double_2() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_double_2(c, c + 1);\n+        }\n+    }\n+\n+    private static void test_Object_2() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            Object o1 = new Object();\n+            Object o2 = new Object();\n+            BlackholeTarget.bh_s_Object_2(o1, o2);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeStaticTest.java","additions":287,"deletions":0,"binary":false,"changes":287,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.blackhole;\n+\n+import java.lang.reflect.*;\n+\n+public class BlackholeTarget {\n+    private static String entered;\n+\n+    private static void registerEntered(String label) {\n+        if (entered == null) {\n+           entered = label;\n+        } else if (!entered.equals(label)) {\n+           throw new IllegalStateException(\"Trying to register enter with overwrite: \" + entered + \" -> \" + label);\n+        }\n+    }\n+\n+    public static void clear() {\n+        entered = null;\n+    }\n+\n+    public static void shouldBeEntered() {\n+        if (entered == null) {\n+            throw new IllegalStateException(\"Should have been entered\");\n+        }\n+    }\n+\n+    public static void shouldNotBeEntered() {\n+        if (entered != null) {\n+            throw new IllegalStateException(\"Should not have been entered: \" + entered);\n+        }\n+    }\n+\n+    public void call_for_null_check() {}\n+\n+    public static void    bh_s_boolean_0()           { registerEntered(\"bh_s_boolean_0\"); }\n+    public static void    bh_s_byte_0()              { registerEntered(\"bh_s_byte_0\");    }\n+    public static void    bh_s_short_0()             { registerEntered(\"bh_s_short_0\");   }\n+    public static void    bh_s_char_0()              { registerEntered(\"bh_s_char_0\");    }\n+    public static void    bh_s_int_0()               { registerEntered(\"bh_s_int_0\");     }\n+    public static void    bh_s_float_0()             { registerEntered(\"bh_s_float_0\");   }\n+    public static void    bh_s_long_0()              { registerEntered(\"bh_s_long_0\");    }\n+    public static void    bh_s_double_0()            { registerEntered(\"bh_s_double_0\");  }\n+    public static void    bh_s_Object_0()            { registerEntered(\"bh_s_Object_0\");  }\n+\n+    public        void    bh_i_boolean_0()           { registerEntered(\"bh_i_boolean_0\"); }\n+    public        void    bh_i_byte_0()              { registerEntered(\"bh_i_byte_0\");    }\n+    public        void    bh_i_short_0()             { registerEntered(\"bh_i_short_0\");   }\n+    public        void    bh_i_char_0()              { registerEntered(\"bh_i_char_0\");    }\n+    public        void    bh_i_int_0()               { registerEntered(\"bh_i_int_0\");     }\n+    public        void    bh_i_float_0()             { registerEntered(\"bh_i_float_0\");   }\n+    public        void    bh_i_long_0()              { registerEntered(\"bh_i_long_0\");    }\n+    public        void    bh_i_double_0()            { registerEntered(\"bh_i_double_0\");  }\n+    public        void    bh_i_Object_0()            { registerEntered(\"bh_i_Object_0\");  }\n+\n+    public static void    bh_s_boolean_1(boolean v)  { registerEntered(\"bh_s_boolean_1\"); }\n+    public static void    bh_s_byte_1(byte v)        { registerEntered(\"bh_s_byte_1\");    }\n+    public static void    bh_s_short_1(short v)      { registerEntered(\"bh_s_short_1\");   }\n+    public static void    bh_s_char_1(char v)        { registerEntered(\"bh_s_char_1\");    }\n+    public static void    bh_s_int_1(int v)          { registerEntered(\"bh_s_int_1\");     }\n+    public static void    bh_s_float_1(float v)      { registerEntered(\"bh_s_float_1\");   }\n+    public static void    bh_s_long_1(long v)        { registerEntered(\"bh_s_long_1\");    }\n+    public static void    bh_s_double_1(double v)    { registerEntered(\"bh_s_double_1\");  }\n+    public static void    bh_s_Object_1(Object v)    { registerEntered(\"bh_s_Object_1\");  }\n+\n+    public        void    bh_i_boolean_1(boolean v)  { registerEntered(\"bh_i_boolean_1\"); }\n+    public        void    bh_i_byte_1(byte v)        { registerEntered(\"bh_i_byte_1\");    }\n+    public        void    bh_i_short_1(short v)      { registerEntered(\"bh_i_short_1\");   }\n+    public        void    bh_i_char_1(char v)        { registerEntered(\"bh_i_char_1\");    }\n+    public        void    bh_i_int_1(int v)          { registerEntered(\"bh_i_int_1\");     }\n+    public        void    bh_i_float_1(float v)      { registerEntered(\"bh_i_float_1\");   }\n+    public        void    bh_i_long_1(long v)        { registerEntered(\"bh_i_long_1\");    }\n+    public        void    bh_i_double_1(double v)    { registerEntered(\"bh_i_double_1\");  }\n+    public        void    bh_i_Object_1(Object v)    { registerEntered(\"bh_i_Object_1\");  }\n+\n+    public static void    bh_s_boolean_2(boolean v1, boolean v2) { registerEntered(\"bh_s_boolean_2\"); }\n+    public static void    bh_s_byte_2(byte v1, byte v2)          { registerEntered(\"bh_s_byte_2\");    }\n+    public static void    bh_s_short_2(short v1, short v2)       { registerEntered(\"bh_s_short_2\");   }\n+    public static void    bh_s_char_2(char v1, char v2)          { registerEntered(\"bh_s_char_2\");    }\n+    public static void    bh_s_int_2(int v1, int v2)             { registerEntered(\"bh_s_int_2\");     }\n+    public static void    bh_s_float_2(float v1, float v2)       { registerEntered(\"bh_s_float_2\");   }\n+    public static void    bh_s_long_2(long v1, long v2)          { registerEntered(\"bh_s_long_2\");    }\n+    public static void    bh_s_double_2(double v1, double v2)    { registerEntered(\"bh_s_double_2\");  }\n+    public static void    bh_s_Object_2(Object v1, Object v2)    { registerEntered(\"bh_s_Object_2\");  }\n+\n+    public        void    bh_i_boolean_2(boolean v1, boolean v2) { registerEntered(\"bh_i_boolean_2\"); }\n+    public        void    bh_i_byte_2(byte v1, byte v2)          { registerEntered(\"bh_i_byte_2\");    }\n+    public        void    bh_i_short_2(short v1, short v2)       { registerEntered(\"bh_i_short_2\");   }\n+    public        void    bh_i_char_2(char v1, char v2)          { registerEntered(\"bh_i_char_2\");    }\n+    public        void    bh_i_int_2(int v1, int v2)             { registerEntered(\"bh_i_int_2\");     }\n+    public        void    bh_i_float_2(float v1, float v2)       { registerEntered(\"bh_i_float_2\");   }\n+    public        void    bh_i_long_2(long v1, long v2)          { registerEntered(\"bh_i_long_2\");    }\n+    public        void    bh_i_double_2(double v1, double v2)    { registerEntered(\"bh_i_double_2\");  }\n+    public        void    bh_i_Object_2(Object v1, Object v2)    { registerEntered(\"bh_i_Object_2\");  }\n+\n+    public static boolean bh_sr_boolean(boolean v) { registerEntered(\"bh_sr_boolean\"); return false; }\n+    public static byte    bh_sr_byte(byte v)       { registerEntered(\"bh_sr_byte\");    return 0;     }\n+    public static short   bh_sr_short(short v)     { registerEntered(\"bh_sr_short\");   return 0;     }\n+    public static char    bh_sr_char(char v)       { registerEntered(\"bh_sr_char\");    return 0;     }\n+    public static int     bh_sr_int(int v)         { registerEntered(\"bh_sr_int\");     return 0;     }\n+    public static float   bh_sr_float(float v)     { registerEntered(\"bh_sr_float\");   return 0;     }\n+    public static long    bh_sr_long(long v)       { registerEntered(\"bh_sr_long\");    return 0;     }\n+    public static double  bh_sr_double(double v)   { registerEntered(\"bh_sr_double\");  return 0;     }\n+    public static Object  bh_sr_Object(Object v)   { registerEntered(\"bh_sr_Object\");  return null;  }\n+\n+    public        boolean bh_ir_boolean(boolean v) { registerEntered(\"bh_ir_boolean\"); return false; }\n+    public        byte    bh_ir_byte(byte v)       { registerEntered(\"bh_ir_byte\");    return 0;     }\n+    public        short   bh_ir_short(short v)     { registerEntered(\"bh_ir_short\");   return 0;     }\n+    public        char    bh_ir_char(char v)       { registerEntered(\"bh_ir_char\");    return 0;     }\n+    public        int     bh_ir_int(int v)         { registerEntered(\"bh_ir_int\");     return 0;     }\n+    public        float   bh_ir_float(float v)     { registerEntered(\"bh_ir_float\");   return 0;     }\n+    public        long    bh_ir_long(long v)       { registerEntered(\"bh_ir_long\");    return 0;     }\n+    public        double  bh_ir_double(double v)   { registerEntered(\"bh_ir_double\");  return 0;     }\n+    public        Object  bh_ir_Object(Object v)   { registerEntered(\"bh_ir_Object\");  return null;  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeTarget.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"}]}