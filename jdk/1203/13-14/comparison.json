{"files":[{"patch":"@@ -15991,17 +15991,0 @@\n-\/\/ Call Blackhole Instruction\n-\n-instruct CallBlackholeDirect(method meth)\n-%{\n-  match(CallBlackhole);\n-\n-  effect(USE meth);\n-\n-  ins_cost(1);\n-\n-  format %{ \"CALL,blackhole \" %}\n-\n-  ins_encode(); \/\/ Encode to nothing\n-\n-  ins_pipe(pipe_class_empty);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -8850,11 +8850,0 @@\n-\/\/ Call Blackhole Instruction\n-instruct CallBlackholeDirect( method meth ) %{\n-  match(CallBlackhole);\n-  effect(USE meth);\n-\n-  ins_cost(1);\n-  format %{ \"CALL,blackhole\" %}\n-  ins_encode(); \/\/ encode to nothing\n-  ins_pipe(empty);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -14390,12 +14390,0 @@\n-\/\/ Call Blackhole Instruction\n-\n-instruct CallBlackholeDirect(method meth) %{\n-  match(CallBlackhole);\n-  effect(USE meth);\n-  ins_cost(1);\n-\n-  format %{ \"CALL,blackhole\" %}\n-  ins_encode(); \/\/ Encode to nothing\n-  ins_pipe(pipe_class_empty);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -9713,10 +9713,0 @@\n-\/\/ Call Blackhole Instruction\n-instruct CallBlackholeDirect(method meth) %{\n-  match(CallBlackhole);\n-  effect(USE meth);\n-  ins_cost(1);\n-  format %{ \"CALL,blackhole \" %}\n-  ins_encode(); \/\/ Encode to nothing\n-  ins_pipe(pipe_class_dummy);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -13222,12 +13222,0 @@\n-\/\/ Call Blackhole Instruction\n-instruct CallBlackholeDirect(method meth)\n-%{\n-  match(CallBlackhole);\n-  effect(USE meth);\n-\n-  ins_cost(1);\n-  format %{ \"CALL,blackhole \" %}\n-  ins_encode(); \/\/ Encode to nothing\n-  ins_pipe(empty);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -12384,12 +12384,0 @@\n-\/\/ Call Blackhole Instruction\n-instruct CallBlackholeDirect(method meth)\n-%{\n-  match(CallBlackhole);\n-  effect(USE meth);\n-\n-  ins_cost(1);\n-  format %{ \"call,blackhole \" %}\n-  ins_encode(); \/\/ Encode to nothing\n-  ins_pipe(empty);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -202,2 +202,1 @@\n-    JAVA_LEAF     =  7,  \/\/ calling leaf,\n-    JAVA_BLACKHOLE=  8   \/\/ blackholed method\n+    JAVA_LEAF     =  7   \/\/ calling leaf\n","filename":"src\/hotspot\/share\/adlc\/forms.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -416,2 +416,0 @@\n-  if(_matrule->find_type(\"CallBlackhole\",idx))    return Form::JAVA_BLACKHOLE;\n-  idx = 0;\n@@ -1133,3 +1131,0 @@\n-  else if( is_ideal_call() == Form::JAVA_BLACKHOLE ) {\n-    return \"MachCallBlackholeNode\";\n-  }\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3656,1 +3656,0 @@\n-  fprintf(fp_hpp, \"extern const char  no_reg_save_policy[];\\n\");\n@@ -3683,11 +3682,0 @@\n-\n-  \/\/ Construct No-Save-Policy array\n-  fprintf(fp_cpp, \"\/\/ Map from machine-independent register number to no_reg_save_policy\\n\");\n-  fprintf(fp_cpp, \"const        char no_reg_save_policy[] = {\\n\");\n-  _register->reset_RegDefs();\n-  for( rdef = _register->iter_RegDefs(); rdef != NULL; rdef = next ) {\n-    next        = _register->iter_RegDefs();\n-    const char *comma = (next != NULL) ? \",\" : \" \/\/ no trailing comma\";\n-    fprintf(fp_cpp, \"  '%c'%s \/\/ %s\\n\", 'N', comma, rdef->_regname);\n-  }\n-  fprintf(fp_cpp, \"};\\n\\n\");\n","filename":"src\/hotspot\/share\/adlc\/output_c.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -696,3 +696,0 @@\n-    case Form::JAVA_BLACKHOLE:\n-      \/\/ Nothing additional to print\n-      break;\n","filename":"src\/hotspot\/share\/adlc\/output_h.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1056,1 +1056,0 @@\n-void Canonicalizer::do_Blackhole(Blackhole* x) {}\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -114,1 +114,0 @@\n-  virtual void do_Blackhole      (Blackhole* x);\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -233,0 +233,2 @@\n+  case vmIntrinsics::_blackhole:\n+    break;\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2029,7 +2029,0 @@\n-  \/\/ check if we need to blackhole the method\n-  if (target->should_be_blackholed()) {\n-    blackhole(target);\n-    print_inlining(target, \"blackhole\", \/*success*\/ true);\n-    return;\n-  }\n-\n@@ -3425,1 +3418,1 @@\n-      (CheckIntrinsics ? callee->intrinsic_candidate() : true)) {\n+      callee->check_intrinsic_candidate()) {\n@@ -3462,9 +3455,0 @@\n-void GraphBuilder::blackhole(ciMethod* callee) {\n-  Values* args = state()->pop_arguments(callee->arg_size());\n-\n-  \/\/ Blackhole everything except the receiver itself\n-  int start = callee->flags().is_static() ? 0 : 1;\n-  for (int c = start; c < args->length(); c++) {\n-    append(new Blackhole(args->at(c)));\n-  }\n-}\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -357,2 +357,0 @@\n-  void blackhole(ciMethod* callee);\n-\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1045,4 +1045,0 @@\n-\n-Blackhole::Blackhole(Value v) : Instruction(illegalType), _v(v) {\n-  pin();\n-}\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -112,1 +112,0 @@\n-class   Blackhole;\n@@ -212,1 +211,0 @@\n-  virtual void do_Blackhole      (Blackhole*       x) = 0;\n@@ -2614,15 +2612,0 @@\n-LEAF(Blackhole, Instruction)\n-private:\n-  Value       _v;\n-\n-public:\n-  \/\/ creation\n-  Blackhole(Value v);\n-\n-  \/\/ accessors\n-  Value v() { return _v; }\n-\n-  \/\/ generic\n-  virtual void input_values_do(ValueVisitor* f)  { f->visit(&_v); }\n-};\n-\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -864,5 +864,0 @@\n-void InstructionPrinter::do_Blackhole(Blackhole* x) {\n-  output()->print(\"blackhole \");\n-  print_value(x->v());\n-}\n-\n","filename":"src\/hotspot\/share\/c1\/c1_InstructionPrinter.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -138,1 +138,0 @@\n-  virtual void do_Blackhole      (Blackhole* x);\n","filename":"src\/hotspot\/share\/c1\/c1_InstructionPrinter.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3209,0 +3209,4 @@\n+  case vmIntrinsics::_blackhole:\n+    do_blackhole(x);\n+    break;\n+\n@@ -3628,5 +3632,7 @@\n-void LIRGenerator::do_Blackhole(Blackhole *x) {\n-  \/\/ Load the argument\n-  LIRItem vitem(x->v(), this);\n-  vitem.load_item();\n-  \/\/ ...and leave it unused.\n+void LIRGenerator::do_blackhole(Intrinsic *x) {\n+  for (int c = 0; c < x->number_of_arguments(); c++) {\n+    \/\/ Load the argument\n+    LIRItem vitem(x->argument_at(c), this);\n+    vitem.load_item();\n+    \/\/ ...and leave it unused.\n+  }\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -268,0 +268,1 @@\n+  void do_blackhole(Intrinsic* x);\n@@ -599,1 +600,0 @@\n-  virtual void do_Blackhole      (Blackhole* x);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -544,1 +544,0 @@\n-  void do_Blackhole      (Blackhole* x);\n@@ -732,1 +731,0 @@\n-void NullCheckVisitor::do_Blackhole      (Blackhole* x) {}\n","filename":"src\/hotspot\/share\/c1\/c1_Optimizer.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -176,1 +176,0 @@\n-    void do_Blackhole      (Blackhole* x)       { \/* nothing to do *\/ };\n","filename":"src\/hotspot\/share\/c1\/c1_RangeCheckElimination.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -212,3 +212,0 @@\n-  void do_Blackhole      (Blackhole* x) {\n-    kill_memory();\n-  };\n","filename":"src\/hotspot\/share\/c1\/c1_ValueMap.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -159,2 +159,5 @@\n-  _should_be_blackholed = CompilerOracle::should_blackhole(h_m) &&\n-                          _signature->return_type()->basic_type() == T_VOID;\n+  if (CompilerOracle::should_blackhole(h_m) &&\n+      _signature->return_type()->basic_type() == T_VOID &&\n+      h_m->intrinsic_id() == vmIntrinsics::_none) {\n+    h_m->set_intrinsic_id(vmIntrinsics::_blackhole);\n+  }\n@@ -191,2 +194,0 @@\n-\n-  _should_be_blackholed = false;\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -94,1 +94,0 @@\n-  bool _should_be_blackholed;\n@@ -205,0 +204,9 @@\n+  bool check_intrinsic_candidate() const {\n+    if (intrinsic_id() == vmIntrinsics::_blackhole) {\n+      \/\/ This is the intrinsic without an associated method, so no intrinsic_candidate\n+      \/\/ flag is set. The intrinsic is still correct.\n+      return true;\n+    }\n+    return (CheckIntrinsics ? intrinsic_candidate() : true);\n+  }\n+\n@@ -356,2 +364,0 @@\n-  bool should_be_blackholed() const              { return _should_be_blackholed; }\n-\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -5298,0 +5298,5 @@\n+        if (vmIntrinsics::_blackhole == id) {\n+          \/\/ The _blackhole intrinsic is a special marker. No explicit method\n+          \/\/ is defined for it.\n+          continue;\n+        }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -154,0 +154,1 @@\n+  case vmIntrinsics::_blackhole:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -536,0 +536,3 @@\n+  \/* special marker for blackholed methods: *\/                                                                          \\\n+  do_intrinsic(_blackhole,                java_lang_Object,       blackhole_name, star_name, F_RN)                      \\\n+                                                                                                                        \\\n@@ -1015,0 +1018,1 @@\n+                                                                                                                        \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -285,0 +285,1 @@\n+  template(blackhole_name,                            \"<blackhole>\")  \/*fake name*\/               \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -678,0 +678,2 @@\n+  case vmIntrinsics::_blackhole:\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -115,54 +115,0 @@\n-\/\/---------------------------BlackholeCallGenerator------------------------------\n-\/\/ Internal class which handles blackhole calls.\n-class BlackholeCallGenerator : public CallGenerator {\n-private:\n-\n-public:\n-  BlackholeCallGenerator(ciMethod* method) : CallGenerator(method) {}\n-  virtual JVMState* generate(JVMState* jvms);\n-};\n-\n-JVMState* BlackholeCallGenerator::generate(JVMState* jvms) {\n-  GraphKit kit(jvms);\n-  kit.C->print_inlining_update(this);\n-  if (kit.C->log() != NULL) {\n-    kit.C->log()->elem(\"blackhole bci='%d'\", jvms->bci());\n-  }\n-\n-  CallBlackholeNode* call = new CallBlackholeNode(tf());\n-\n-  \/\/ Bind arguments\n-  uint nargs = method()->arg_size();\n-  for (uint i = 0; i < nargs; i++) {\n-    Node* arg = kit.argument(i);\n-    call->init_req(i + TypeFunc::Parms, arg);\n-  }\n-\n-  \/\/ Add the predefined inputs:\n-  call->init_req( TypeFunc::Control, kit.control() );\n-  call->init_req( TypeFunc::I_O    , kit.i_o() );\n-  call->init_req( TypeFunc::Memory , kit.reset_memory() );\n-  call->init_req( TypeFunc::FramePtr, kit.frameptr() );\n-  call->init_req( TypeFunc::ReturnAdr, kit.top() );\n-\n-  Node* xcall = kit.gvn().transform(call);\n-\n-  if (xcall != kit.top()) {\n-    assert(xcall == call, \"call identity is stable\");\n-    kit.set_control(kit.gvn().transform(new ProjNode(call, TypeFunc::Control)));\n-    kit.set_i_o(kit.gvn().transform(new ProjNode(call, TypeFunc::I_O, false)));\n-    kit.set_all_memory_call(xcall, false);\n-  } else {\n-    kit.set_control(kit.top());\n-  }\n-\n-  BasicType ret_type = method()->return_type()->basic_type();\n-  assert(ret_type == T_VOID, \"Must be void\");\n-  kit.push_node(ret_type, kit.top());\n-  return kit.transfer_exceptions_into_jvms();\n-}\n-\n-CallGenerator* CallGenerator::for_blackhole(ciMethod* m) {\n-  return new BlackholeCallGenerator(m);\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":0,"deletions":54,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -181,2 +181,0 @@\n-\n-  static CallGenerator* for_blackhole(ciMethod* m);\n","filename":"src\/hotspot\/share\/opto\/callGenerator.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1121,13 +1121,0 @@\n-\/\/=============================================================================\n-uint CallBlackholeNode::size_of() const { return sizeof(*this); }\n-bool CallBlackholeNode::cmp( const Node &n ) const {\n-  CallBlackholeNode &call = (CallBlackholeNode&)n;\n-  return CallNode::cmp(call);\n-}\n-#ifndef PRODUCT\n-void CallBlackholeNode::dump_spec(outputStream *st) const {\n-  st->print(\"# Blackhole \");\n-  CallNode::dump_spec(st);\n-}\n-#endif\n-\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-class     CallBlackholeNode;\n@@ -773,21 +772,0 @@\n-\/\/------------------------------CallBlackholeNode----------------------------\n-\/\/ Make a blackholed call. It would survive through the compiler and keep\n-\/\/ the effects on its argument, and would be finally emitted as nothing.\n-class CallBlackholeNode : public CallNode {\n-  virtual bool cmp( const Node &n ) const;\n-  virtual uint size_of() const; \/\/ Size is bigger\n-public:\n-  CallBlackholeNode( const TypeFunc *tf ) : CallNode(tf, NULL, TypePtr::BOTTOM) {\n-    init_class_id(Class_CallBlackhole);\n-  }\n-\n-  \/\/ If method is blackholed, there is no method body, and thus no\n-  \/\/ safepoint, and therefore safepoint is not guaranteed.\n-  virtual bool guaranteed_safepoint()      { return false; }\n-\n-  virtual int   Opcode() const;\n-#ifndef PRODUCT\n-  virtual void  dump_spec(outputStream *st) const;\n-#endif\n-};\n-\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+macro(Blackhole)\n@@ -58,1 +59,0 @@\n-macro(CallBlackhole)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2911,1 +2911,0 @@\n-  case Op_CallBlackhole:\n@@ -3468,0 +3467,2 @@\n+  case Op_Blackhole:\n+    break;\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -114,5 +114,0 @@\n-  \/\/ Try blackholing a method\n-  if (callee->should_be_blackholed()) {\n-    return CallGenerator::for_blackhole(callee);\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -872,4 +872,0 @@\n-    case Op_CallBlackhole:\n-      \/\/ Calling blackhole, so no registers are touched, no need to save\n-      save_policy = _matcher._no_reg_save_policy;\n-      break;\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-  if ((CheckIntrinsics ? callee->intrinsic_candidate() : true) &&\n+  if (callee->check_intrinsic_candidate() &&\n@@ -670,0 +670,3 @@\n+  case vmIntrinsics::_blackhole:\n+    return inline_blackhole();\n+\n@@ -6851,0 +6854,12 @@\n+\n+bool LibraryCallKit::inline_blackhole() {\n+  Node* bh = insert_mem_bar(Op_Blackhole);\n+\n+  \/\/ Bind call arguments as blackhole arguments to keep them alive\n+  uint nargs = method()->arg_size();\n+  for (uint i = 0; i < nargs; i++) {\n+    bh->add_req(argument(i));\n+  }\n+\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -347,0 +347,2 @@\n+\n+  bool inline_blackhole();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -809,16 +809,0 @@\n-const RegMask &MachCallBlackholeNode::in_RegMask(uint idx) const {\n-  \/\/ Fake the incoming arguments mask for blackholes: accept all registers and all stack slots.\n-  \/\/ This must avoid moving the arguments for the call that never happens.\n-  return RegMask::All;\n-}\n-int MachCallBlackholeNode::ret_addr_offset() {\n-  \/\/ No address, might as as well return the neutral value.\n-  return 0;\n-}\n-#ifndef PRODUCT\n-void MachCallBlackholeNode::dump_spec(outputStream *st) const {\n-  st->print(\"Blackhole \");\n-  MachCallNode::dump_spec(st);\n-}\n-#endif\n-\/\/=============================================================================\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-class MachCallBlackholeNode;\n@@ -991,14 +990,0 @@\n-\/\/------------------------------MachCallBlackholeNode------------------------\n-\/\/ Machine-specific versions of blackholed call\n-class MachCallBlackholeNode : public MachCallNode {\n-public:\n-  MachCallBlackholeNode() : MachCallNode() {\n-    init_class_id(Class_MachCallBlackhole);\n-  }\n-  virtual const RegMask &in_RegMask(uint) const;\n-  virtual int ret_addr_offset();\n-#ifndef PRODUCT\n-  virtual void dump_spec(outputStream *st) const;\n-#endif\n-};\n-\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -82,1 +82,0 @@\n-  _no_reg_save_policy(no_reg_save_policy),\n@@ -1315,2 +1314,0 @@\n-  if( call != NULL && call->is_CallBlackhole() )\n-    out_arg_limit_per_call = _new_SP; \/\/ Blackhole does not have outs, roll back.\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -219,1 +219,0 @@\n-  const char *_no_reg_save_policy;\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3224,0 +3224,1 @@\n+  case Op_Blackhole:         return new BlackholeNode(C, atp, pn);\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1338,0 +1338,17 @@\n+\/\/------------------------------BlackholeNode----------------------------\n+\/\/ Blackhole all arguments. This node would survive through the compiler\n+\/\/ the effects on its arguments, and would be finally matched to nothing.\n+class BlackholeNode : public MemBarNode {\n+public:\n+  BlackholeNode(Compile* C, int alias_idx, Node* precedent)\n+    : MemBarNode(C, alias_idx, precedent) {}\n+  virtual int   Opcode() const;\n+  virtual uint ideal_reg() const { return 0; } \/\/ not matched in the AD file\n+  const RegMask &in_RegMask(uint idx) const {\n+    \/\/ Fake the incoming arguments mask for blackholes: accept all registers\n+    \/\/ and all stack slots. This would avoid moving the arguments for the\n+    \/\/ call that never happens.\n+    return RegMask::All;\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+class BlackholeNode;\n@@ -59,1 +60,0 @@\n-class CallBlackholeNode;\n@@ -106,1 +106,0 @@\n-class MachCallBlackholeNode;\n@@ -645,1 +644,0 @@\n-          DEFINE_CLASS_ID(CallBlackhole,    Call, 6)\n@@ -672,1 +670,0 @@\n-            DEFINE_CLASS_ID(MachCallBlackhole,    MachCall, 3)\n@@ -843,1 +840,0 @@\n-  DEFINE_CLASS_QUERY(CallBlackhole)\n@@ -884,1 +880,0 @@\n-  DEFINE_CLASS_QUERY(MachCallBlackhole)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1523,1 +1523,0 @@\n-  declare_c2_type(CallBlackholeNode, CallNode)                            \\\n@@ -1598,0 +1597,1 @@\n+  declare_c2_type(BlackholeNode, MemBarNode)                              \\\n@@ -1642,1 +1642,0 @@\n-  declare_c2_type(MachCallBlackholeNode, MachCallNode)                    \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test id=c1\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceOneArgTest\n+ *\/\n+\n+\/**\n+ * @test id=c2\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceOneArgTest\n+ *\/\n+\n+\/**\n+ * @test id=c1-no-coops\n+ * @requires vm.bits == \"64\"\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceOneArgTest\n+ *\/\n+\n+\/**\n+ * @test id=c2-no-coops\n+ * @requires vm.bits == \"64\"\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceOneArgTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+public class BlackholeInstanceOneArgTest {\n+\n+    public static void main(String[] args) {\n+        runTries(BlackholeInstanceOneArgTest::test_boolean);\n+        runTries(BlackholeInstanceOneArgTest::test_byte);\n+        runTries(BlackholeInstanceOneArgTest::test_char);\n+        runTries(BlackholeInstanceOneArgTest::test_short);\n+        runTries(BlackholeInstanceOneArgTest::test_int);\n+        runTries(BlackholeInstanceOneArgTest::test_float);\n+        runTries(BlackholeInstanceOneArgTest::test_long);\n+        runTries(BlackholeInstanceOneArgTest::test_double);\n+        runTries(BlackholeInstanceOneArgTest::test_Object);\n+    }\n+\n+    private static final int CYCLES = 1_000_000;\n+    private static final int TRIES = 10;\n+\n+    public static void runTries(Runnable r) {\n+        for (int t = 0; t < TRIES; t++) {\n+            BlackholeTarget.clear();\n+            r.run();\n+            if (t == TRIES - 1) {\n+               BlackholeTarget.shouldNotBeEntered();\n+            }\n+        }\n+    }\n+\n+    private static void test_boolean() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_boolean((c & 0x1) == 0);\n+        }\n+    }\n+\n+    private static void test_byte() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_byte((byte)c);\n+        }\n+    }\n+\n+    private static void test_char() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_char((char)c);\n+        }\n+    }\n+\n+    private static void test_short() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_short((short)c);\n+        }\n+    }\n+\n+    private static void test_int() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_int(c);\n+        }\n+    }\n+\n+    private static void test_float() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_float(c);\n+        }\n+    }\n+\n+    private static void test_long() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_long(c);\n+        }\n+    }\n+\n+    private static void test_double() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_double(c);\n+        }\n+    }\n+\n+    private static void test_Object() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            Object o = new Object();\n+            t.bh_i_Object(o);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeInstanceOneArgTest.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -25,2 +25,1 @@\n- * @test\n- *\n+ * @test id=c1\n@@ -35,0 +34,5 @@\n+ *\/\n+\n+\/**\n+ * @test id=c2\n+ * @build compiler.blackhole.BlackholeTarget\n@@ -44,2 +48,2 @@\n-\/*\n- * @test\n+\/**\n+ * @test id=c1-no-coops\n@@ -47,1 +51,0 @@\n- *\n@@ -56,0 +59,6 @@\n+ *\/\n+\n+\/**\n+ * @test id=c2-no-coops\n+ * @requires vm.bits == \"64\"\n+ * @build compiler.blackhole.BlackholeTarget\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeInstanceReturnTest.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1,157 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- *\n- * @build compiler.blackhole.BlackholeTarget\n- *\n- * @run main\/othervm\n- *      -Xmx1g\n- *      -XX:TieredStopAtLevel=1\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n- *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n- *      compiler.blackhole.BlackholeInstanceSingleArgTest\n- *\n- * @run main\/othervm\n- *      -Xmx1g\n- *      -XX:-TieredCompilation\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n- *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n- *      compiler.blackhole.BlackholeInstanceSingleArgTest\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.bits == \"64\"\n- *\n- * @build compiler.blackhole.BlackholeTarget\n- *\n- * @run main\/othervm\n- *      -Xmx1g -XX:-UseCompressedOops\n- *      -XX:TieredStopAtLevel=1\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n- *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n- *      compiler.blackhole.BlackholeInstanceSingleArgTest\n- *\n- * @run main\/othervm\n- *      -Xmx1g -XX:-UseCompressedOops\n- *      -XX:-TieredCompilation\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n- *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n- *      compiler.blackhole.BlackholeInstanceSingleArgTest\n- *\/\n-\n-package compiler.blackhole;\n-\n-public class BlackholeInstanceSingleArgTest {\n-\n-    public static void main(String[] args) {\n-        runTries(BlackholeInstanceSingleArgTest::test_boolean);\n-        runTries(BlackholeInstanceSingleArgTest::test_byte);\n-        runTries(BlackholeInstanceSingleArgTest::test_char);\n-        runTries(BlackholeInstanceSingleArgTest::test_short);\n-        runTries(BlackholeInstanceSingleArgTest::test_int);\n-        runTries(BlackholeInstanceSingleArgTest::test_float);\n-        runTries(BlackholeInstanceSingleArgTest::test_long);\n-        runTries(BlackholeInstanceSingleArgTest::test_double);\n-        runTries(BlackholeInstanceSingleArgTest::test_Object);\n-    }\n-\n-    private static final int CYCLES = 1_000_000;\n-    private static final int TRIES = 10;\n-\n-    public static void runTries(Runnable r) {\n-        for (int t = 0; t < TRIES; t++) {\n-            BlackholeTarget.clear();\n-            r.run();\n-            if (t == TRIES - 1) {\n-               BlackholeTarget.shouldNotBeEntered();\n-            }\n-        }\n-    }\n-\n-    private static void test_boolean() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            t.bh_i_boolean((c & 0x1) == 0);\n-        }\n-    }\n-\n-    private static void test_byte() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            t.bh_i_byte((byte)c);\n-        }\n-    }\n-\n-    private static void test_char() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            t.bh_i_char((char)c);\n-        }\n-    }\n-\n-    private static void test_short() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            t.bh_i_short((short)c);\n-        }\n-    }\n-\n-    private static void test_int() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            t.bh_i_int(c);\n-        }\n-    }\n-\n-    private static void test_float() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            t.bh_i_float(c);\n-        }\n-    }\n-\n-    private static void test_long() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            t.bh_i_long(c);\n-        }\n-    }\n-\n-    private static void test_double() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            t.bh_i_double(c);\n-        }\n-    }\n-\n-    private static void test_Object() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            Object o = new Object();\n-            t.bh_i_Object(o);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeInstanceSingleArgTest.java","additions":0,"deletions":157,"binary":false,"changes":157,"status":"deleted"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test id=c1\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceTwoArgTest\n+ *\/\n+\n+\/**\n+ * @test id=c2\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceTwoArgTest\n+ *\/\n+\n+\/**\n+ * @test id=c1-no-coops\n+ * @requires vm.bits == \"64\"\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceTwoArgTest\n+ *\/\n+\n+\/**\n+ * @test id=c2-no-coops\n+ * @requires vm.bits == \"64\"\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceTwoArgTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+public class BlackholeInstanceTwoArgTest {\n+\n+    public static void main(String[] args) {\n+        runTries(BlackholeInstanceTwoArgTest::test_boolean);\n+        runTries(BlackholeInstanceTwoArgTest::test_byte);\n+        runTries(BlackholeInstanceTwoArgTest::test_char);\n+        runTries(BlackholeInstanceTwoArgTest::test_short);\n+        runTries(BlackholeInstanceTwoArgTest::test_int);\n+        runTries(BlackholeInstanceTwoArgTest::test_float);\n+        runTries(BlackholeInstanceTwoArgTest::test_long);\n+        runTries(BlackholeInstanceTwoArgTest::test_double);\n+        runTries(BlackholeInstanceTwoArgTest::test_Object);\n+    }\n+\n+    private static final int CYCLES = 1_000_000;\n+    private static final int TRIES = 10;\n+\n+    public static void runTries(Runnable r) {\n+        for (int t = 0; t < TRIES; t++) {\n+            BlackholeTarget.clear();\n+            r.run();\n+            if (t == TRIES - 1) {\n+               BlackholeTarget.shouldNotBeEntered();\n+            }\n+        }\n+    }\n+\n+    private static void test_boolean() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_boolean_2((c & 0x1) == 0, (c & 0x2) == 0);\n+        }\n+    }\n+\n+    private static void test_byte() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_byte_2((byte)c, (byte)(c + 1));\n+        }\n+    }\n+\n+    private static void test_char() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_char_2((char)c, (char)(c + 1));\n+        }\n+    }\n+\n+    private static void test_short() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_short_2((short)c, (short)(c + 1));\n+        }\n+    }\n+\n+    private static void test_int() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_int_2(c, c + 1);\n+        }\n+    }\n+\n+    private static void test_float() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_float_2(c, c + 1);\n+        }\n+    }\n+\n+    private static void test_long() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_long_2(c, c + 1);\n+        }\n+    }\n+\n+    private static void test_double() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_double_2(c, c + 1);\n+        }\n+    }\n+\n+    private static void test_Object() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            Object o1 = new Object();\n+            Object o2 = new Object();\n+            t.bh_i_Object_2(o1, o2);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeInstanceTwoArgTest.java","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test id=c1\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeNullCheckTest\n+ *\/\n+\n+\/**\n+ * @test id=c2\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeNullCheckTest\n+ *\/\n+\n+\/**\n+ * @test id=c1-no-coops\n+ * @requires vm.bits == \"64\"\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeNullCheckTest\n+ *\/\n+\n+\/**\n+ * @test id=c2-no-coops\n+ * @requires vm.bits == \"64\"\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeNullCheckTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+public class BlackholeNullCheckTest {\n+\n+    public static void main(String[] args) {\n+        BlackholeNullCheckTest t = new BlackholeNullCheckTest();\n+        runTries(t::test_local_sf);\n+        runTries(t::test_local_s);\n+        runTries(t::test_local);\n+        runTries(t::test_field_sf);\n+        runTries(t::test_field_s);\n+        runTries(t::test_field);\n+    }\n+\n+    private static final int CYCLES = 1_000_000;\n+    private static final int TRIES = 10;\n+\n+    public static void runTries(Runnable r) {\n+        for (int t = 0; t < TRIES; t++) {\n+            r.run();\n+        }\n+    }\n+\n+    static final BlackholeTarget BH_SF_TARGET = null;\n+    static       BlackholeTarget BH_S_TARGET = null;\n+                 BlackholeTarget BH_TARGET = null;\n+\n+    private void test_local_sf() {\n+        test_with(BH_SF_TARGET);\n+    }\n+\n+    private void test_local_s() {\n+        test_with(BH_S_TARGET);\n+    }\n+\n+    private void test_local() {\n+        test_with(BH_TARGET);\n+    }\n+\n+    private void test_with(BlackholeTarget t) {\n+        try {\n+            t.bh_s_boolean(false);\n+        } catch (NullPointerException npe) {\n+            throw new IllegalStateException(\"Unexpected NPE\");\n+        }\n+\n+        try {\n+            t.call_for_null_check();\n+            throw new IllegalStateException(\"Expected NPE\");\n+        } catch (NullPointerException npe) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    private void test_field_sf() {\n+        try {\n+            BH_SF_TARGET.bh_s_boolean(false);\n+        } catch (NullPointerException npe) {\n+            throw new IllegalStateException(\"Unexpected NPE\");\n+        }\n+\n+        try {\n+            BH_SF_TARGET.call_for_null_check();\n+            throw new IllegalStateException(\"Expected NPE\");\n+        } catch (NullPointerException npe) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    private void test_field_s() {\n+        try {\n+            BH_S_TARGET.bh_s_boolean(false);\n+        } catch (NullPointerException npe) {\n+            throw new IllegalStateException(\"Unexpected NPE\");\n+        }\n+\n+        try {\n+            BH_S_TARGET.call_for_null_check();\n+            throw new IllegalStateException(\"Expected NPE\");\n+        } catch (NullPointerException npe) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    private void test_field() {\n+        try {\n+            BH_TARGET.bh_s_boolean(false);\n+        } catch (NullPointerException npe) {\n+            throw new IllegalStateException(\"Unexpected NPE\");\n+        }\n+\n+        try {\n+            BH_TARGET.call_for_null_check();\n+            throw new IllegalStateException(\"Expected NPE\");\n+        } catch (NullPointerException npe) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeNullCheckTest.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test id=c1\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticOneArgTest\n+ *\/\n+\n+\/**\n+ * @test id=c2\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticOneArgTest\n+ *\/\n+\n+\/**\n+ * @test id=c1-no-coops\n+ * @requires vm.bits == \"64\"\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticOneArgTest\n+ *\/\n+\n+\/**\n+ * @test id=c2-no-coops\n+ * @requires vm.bits == \"64\"\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticOneArgTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+public class BlackholeStaticOneArgTest {\n+\n+    public static void main(String[] args) {\n+        runTries(BlackholeStaticOneArgTest::test_boolean);\n+        runTries(BlackholeStaticOneArgTest::test_byte);\n+        runTries(BlackholeStaticOneArgTest::test_char);\n+        runTries(BlackholeStaticOneArgTest::test_short);\n+        runTries(BlackholeStaticOneArgTest::test_int);\n+        runTries(BlackholeStaticOneArgTest::test_float);\n+        runTries(BlackholeStaticOneArgTest::test_long);\n+        runTries(BlackholeStaticOneArgTest::test_double);\n+        runTries(BlackholeStaticOneArgTest::test_Object);\n+    }\n+\n+    private static final int CYCLES = 1_000_000;\n+    private static final int TRIES = 10;\n+\n+    public static void runTries(Runnable r) {\n+        for (int t = 0; t < TRIES; t++) {\n+            BlackholeTarget.clear();\n+            r.run();\n+            if (t == TRIES - 1) {\n+               BlackholeTarget.shouldNotBeEntered();\n+            }\n+        }\n+    }\n+\n+    private static void test_boolean() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_boolean((c & 0x1) == 0);\n+        }\n+    }\n+\n+    private static void test_byte() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_byte((byte)c);\n+        }\n+    }\n+\n+    private static void test_char() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_char((char)c);\n+        }\n+    }\n+\n+    private static void test_short() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_short((short)c);\n+        }\n+    }\n+\n+    private static void test_int() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_int(c);\n+        }\n+    }\n+\n+    private static void test_float() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_float(c);\n+        }\n+    }\n+\n+    private static void test_long() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_long(c);\n+        }\n+    }\n+\n+    private static void test_double() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_double(c);\n+        }\n+    }\n+\n+    private static void test_Object() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            Object o = new Object();\n+            BlackholeTarget.bh_s_Object(o);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeStaticOneArgTest.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -25,2 +25,1 @@\n- * @test\n- *\n+ * @test id=c1\n@@ -35,0 +34,5 @@\n+ *\/\n+\n+\/**\n+ * @test id=c2\n+ * @build compiler.blackhole.BlackholeTarget\n@@ -44,2 +48,2 @@\n-\/*\n- * @test\n+\/**\n+ * @test id=c1-no-coops\n@@ -47,1 +51,0 @@\n- *\n@@ -56,0 +59,6 @@\n+ *\/\n+\n+\/**\n+ * @test id=c2-no-coops\n+ * @requires vm.bits == \"64\"\n+ * @build compiler.blackhole.BlackholeTarget\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeStaticReturnTest.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1,148 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- *\n- * @build compiler.blackhole.BlackholeTarget\n- *\n- * @run main\/othervm\n- *      -Xmx1g\n- *      -XX:TieredStopAtLevel=1\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n- *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n- *      compiler.blackhole.BlackholeStaticSingleArgTest\n- *\n- * @run main\/othervm\n- *      -Xmx1g\n- *      -XX:-TieredCompilation\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n- *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n- *      compiler.blackhole.BlackholeStaticSingleArgTest\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.bits == \"64\"\n- *\n- * @build compiler.blackhole.BlackholeTarget\n- *\n- * @run main\/othervm\n- *      -Xmx1g -XX:-UseCompressedOops\n- *      -XX:TieredStopAtLevel=1\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n- *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n- *      compiler.blackhole.BlackholeStaticSingleArgTest\n- *\n- * @run main\/othervm\n- *      -Xmx1g -XX:-UseCompressedOops\n- *      -XX:-TieredCompilation\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n- *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n- *      compiler.blackhole.BlackholeStaticSingleArgTest\n- *\/\n-\n-package compiler.blackhole;\n-\n-public class BlackholeStaticSingleArgTest {\n-\n-    public static void main(String[] args) {\n-        runTries(BlackholeStaticSingleArgTest::test_boolean);\n-        runTries(BlackholeStaticSingleArgTest::test_byte);\n-        runTries(BlackholeStaticSingleArgTest::test_char);\n-        runTries(BlackholeStaticSingleArgTest::test_short);\n-        runTries(BlackholeStaticSingleArgTest::test_int);\n-        runTries(BlackholeStaticSingleArgTest::test_float);\n-        runTries(BlackholeStaticSingleArgTest::test_long);\n-        runTries(BlackholeStaticSingleArgTest::test_double);\n-        runTries(BlackholeStaticSingleArgTest::test_Object);\n-    }\n-\n-    private static final int CYCLES = 1_000_000;\n-    private static final int TRIES = 10;\n-\n-    public static void runTries(Runnable r) {\n-        for (int t = 0; t < TRIES; t++) {\n-            BlackholeTarget.clear();\n-            r.run();\n-            if (t == TRIES - 1) {\n-               BlackholeTarget.shouldNotBeEntered();\n-            }\n-        }\n-    }\n-\n-    private static void test_boolean() {\n-        for (int c = 0; c < CYCLES; c++) {\n-            BlackholeTarget.bh_s_boolean((c & 0x1) == 0);\n-        }\n-    }\n-\n-    private static void test_byte() {\n-        for (int c = 0; c < CYCLES; c++) {\n-            BlackholeTarget.bh_s_byte((byte)c);\n-        }\n-    }\n-\n-    private static void test_char() {\n-        for (int c = 0; c < CYCLES; c++) {\n-            BlackholeTarget.bh_s_char((char)c);\n-        }\n-    }\n-\n-    private static void test_short() {\n-        for (int c = 0; c < CYCLES; c++) {\n-            BlackholeTarget.bh_s_short((short)c);\n-        }\n-    }\n-\n-    private static void test_int() {\n-        for (int c = 0; c < CYCLES; c++) {\n-            BlackholeTarget.bh_s_int(c);\n-        }\n-    }\n-\n-    private static void test_float() {\n-        for (int c = 0; c < CYCLES; c++) {\n-            BlackholeTarget.bh_s_float(c);\n-        }\n-    }\n-\n-    private static void test_long() {\n-        for (int c = 0; c < CYCLES; c++) {\n-            BlackholeTarget.bh_s_long(c);\n-        }\n-    }\n-\n-    private static void test_double() {\n-        for (int c = 0; c < CYCLES; c++) {\n-            BlackholeTarget.bh_s_double(c);\n-        }\n-    }\n-\n-    private static void test_Object() {\n-        for (int c = 0; c < CYCLES; c++) {\n-            Object o = new Object();\n-            BlackholeTarget.bh_s_Object(o);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeStaticSingleArgTest.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"deleted"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test id=c1\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticTwoArgTest\n+ *\/\n+\n+\/**\n+ * @test id=c2\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticTwoArgTest\n+ *\/\n+\n+\/**\n+ * @test id=c1-no-coops\n+ * @requires vm.bits == \"64\"\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticTwoArgTest\n+ *\/\n+\n+\/**\n+ * @test id=c2-no-coops\n+ * @requires vm.bits == \"64\"\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticTwoArgTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+public class BlackholeStaticTwoArgTest {\n+\n+    public static void main(String[] args) {\n+        runTries(BlackholeStaticTwoArgTest::test_boolean);\n+        runTries(BlackholeStaticTwoArgTest::test_byte);\n+        runTries(BlackholeStaticTwoArgTest::test_char);\n+        runTries(BlackholeStaticTwoArgTest::test_short);\n+        runTries(BlackholeStaticTwoArgTest::test_int);\n+        runTries(BlackholeStaticTwoArgTest::test_float);\n+        runTries(BlackholeStaticTwoArgTest::test_long);\n+        runTries(BlackholeStaticTwoArgTest::test_double);\n+        runTries(BlackholeStaticTwoArgTest::test_Object);\n+    }\n+\n+    private static final int CYCLES = 1_000_000;\n+    private static final int TRIES = 10;\n+\n+    public static void runTries(Runnable r) {\n+        for (int t = 0; t < TRIES; t++) {\n+            BlackholeTarget.clear();\n+            r.run();\n+            if (t == TRIES - 1) {\n+               BlackholeTarget.shouldNotBeEntered();\n+            }\n+        }\n+    }\n+\n+    private static void test_boolean() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_boolean_2((c & 0x1) == 0, (c & 0x2) == 0);\n+        }\n+    }\n+\n+    private static void test_byte() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_byte_2((byte)c, (byte)(c + 1));\n+        }\n+    }\n+\n+    private static void test_char() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_char_2((char)c, (char)(c + 1));\n+        }\n+    }\n+\n+    private static void test_short() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_short_2((short)c, (short)(c + 1));\n+        }\n+    }\n+\n+    private static void test_int() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_int_2(c, c + 1);\n+        }\n+    }\n+\n+    private static void test_float() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_float_2(c, c + 1);\n+        }\n+    }\n+\n+    private static void test_long() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_long_2(c, c + 1);\n+        }\n+    }\n+\n+    private static void test_double() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_double_2(c, c + 1);\n+        }\n+    }\n+\n+    private static void test_Object() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            Object o1 = new Object();\n+            Object o2 = new Object();\n+            BlackholeTarget.bh_s_Object_2(o1, o2);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeStaticTwoArgTest.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -55,0 +55,2 @@\n+    public void call_for_null_check() {}\n+\n@@ -75,0 +77,20 @@\n+    public static void    bh_s_boolean_2(boolean v1, boolean v2) { registerEntered(\"bh_s_boolean_2\"); }\n+    public static void    bh_s_byte_2(byte v1, byte v2)          { registerEntered(\"bh_s_byte_2\");    }\n+    public static void    bh_s_short_2(short v1, short v2)       { registerEntered(\"bh_s_short_2\");   }\n+    public static void    bh_s_char_2(char v1, char v2)          { registerEntered(\"bh_s_char_2\");    }\n+    public static void    bh_s_int_2(int v1, int v2)             { registerEntered(\"bh_s_int_2\");     }\n+    public static void    bh_s_float_2(float v1, float v2)       { registerEntered(\"bh_s_float_2\");   }\n+    public static void    bh_s_long_2(long v1, long v2)          { registerEntered(\"bh_s_long_2\");    }\n+    public static void    bh_s_double_2(double v1, double v2)    { registerEntered(\"bh_s_double_2\");  }\n+    public static void    bh_s_Object_2(Object v1, Object v2)    { registerEntered(\"bh_s_Object_2\");  }\n+\n+    public        void    bh_i_boolean_2(boolean v1, boolean v2) { registerEntered(\"bh_i_boolean_2\"); }\n+    public        void    bh_i_byte_2(byte v1, byte v2)          { registerEntered(\"bh_i_byte_2\");    }\n+    public        void    bh_i_short_2(short v1, short v2)       { registerEntered(\"bh_i_short_2\");   }\n+    public        void    bh_i_char_2(char v1, char v2)          { registerEntered(\"bh_i_char_2\");    }\n+    public        void    bh_i_int_2(int v1, int v2)             { registerEntered(\"bh_i_int_2\");     }\n+    public        void    bh_i_float_2(float v1, float v2)       { registerEntered(\"bh_i_float_2\");   }\n+    public        void    bh_i_long_2(long v1, long v2)          { registerEntered(\"bh_i_long_2\");    }\n+    public        void    bh_i_double_2(double v1, double v2)    { registerEntered(\"bh_i_double_2\");  }\n+    public        void    bh_i_Object_2(Object v1, Object v2)    { registerEntered(\"bh_i_Object_2\");  }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeTarget.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"}]}