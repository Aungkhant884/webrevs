{"files":[{"patch":"@@ -3656,0 +3656,1 @@\n+  fprintf(fp_hpp, \"extern const char  no_reg_save_policy[];\\n\");\n@@ -3682,0 +3683,11 @@\n+\n+  \/\/ Construct No-Save-Policy array\n+  fprintf(fp_cpp, \"\/\/ Map from machine-independent register number to no_reg_save_policy\\n\");\n+  fprintf(fp_cpp, \"const        char no_reg_save_policy[] = {\\n\");\n+  _register->reset_RegDefs();\n+  for( rdef = _register->iter_RegDefs(); rdef != NULL; rdef = next ) {\n+    next        = _register->iter_RegDefs();\n+    const char *comma = (next != NULL) ? \",\" : \" \/\/ no trailing comma\";\n+    fprintf(fp_cpp, \"  '%c'%s \/\/ %s\\n\", 'N', comma, rdef->_regname);\n+  }\n+  fprintf(fp_cpp, \"};\\n\\n\");\n","filename":"src\/hotspot\/share\/adlc\/output_c.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -391,3 +391,1 @@\n-  return check_predicate(CompileCommand::DontInline, method) ||\n-         check_predicate(CompileCommand::Exclude, method) ||\n-         check_predicate(CompileCommand::Blackhole, method);\n+  return check_predicate(CompileCommand::DontInline, method) || check_predicate(CompileCommand::Exclude, method);\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -212,1 +212,1 @@\n-  CallStaticJavaNode* call = new CallStaticJavaNode(kit.C, tf(), target, method(), kit.bci());\n+  CallStaticJavaNode *call = new CallStaticJavaNode(kit.C, tf(), target, method(), kit.bci());\n@@ -311,1 +311,1 @@\n-  CallDynamicJavaNode* call = new CallDynamicJavaNode(tf(), target, method(), _vtable_index, kit.bci());\n+  CallDynamicJavaNode *call = new CallDynamicJavaNode(tf(), target, method(), _vtable_index, kit.bci());\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -873,1 +873,2 @@\n-      \/\/ We do not actually care about calling convention for it.\n+      \/\/ Calling blackhole, so no registers are touched, no need to save\n+      save_policy = _matcher._no_reg_save_policy;\n@@ -907,3 +908,1 @@\n-  if (op != Op_CallBlackhole) {\n-    add_call_kills(proj, regs, save_policy, exclude_soe);\n-  }\n+  add_call_kills(proj, regs, save_policy, exclude_soe);\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+  _no_reg_save_policy(no_reg_save_policy),\n@@ -1314,0 +1315,2 @@\n+  if( call != NULL && call->is_CallBlackhole() )\n+    out_arg_limit_per_call = _new_SP; \/\/ Blackhole does not have outs, roll back.\n@@ -1383,1 +1386,1 @@\n-  if( _out_arg_limit < out_arg_limit_per_call && !mcall->is_MachCallBlackhole())\n+  if( _out_arg_limit < out_arg_limit_per_call)\n@@ -1386,1 +1389,1 @@\n-  if (mcall && !mcall->is_MachCallBlackhole()) {\n+  if (mcall) {\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -219,0 +219,1 @@\n+  const char *_no_reg_save_policy;\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}