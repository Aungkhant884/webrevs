{"files":[{"patch":"@@ -15991,0 +15991,15 @@\n+instruct CallBlackholeJavaDirect(method meth)\n+%{\n+  match(CallBlackholeJava);\n+\n+  effect(USE meth);\n+\n+  ins_cost(1);\n+\n+  format %{ \"call,blackhole \" %}\n+\n+  ins_encode(); \/\/ Encode to nothing\n+\n+  ins_pipe(empty);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -454,0 +454,6 @@\n+int MachCallBlackholeJavaNode::ret_addr_offset()\n+{\n+  \/\/ Fake it, no address.\n+  return 0;\n+}\n+\n@@ -12384,0 +12390,11 @@\n+instruct CallBlackholeJavaDirect(method meth)\n+%{\n+  match(CallBlackholeJava);\n+  effect(USE meth);\n+\n+  ins_cost(1);\n+  format %{ \"call,blackhole \" %}\n+  ins_encode(); \/\/ Encode to nothing\n+  ins_pipe(empty);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -202,1 +202,2 @@\n-    JAVA_LEAF     =  7   \/\/ calling leaf\n+    JAVA_LEAF     =  7,  \/\/ calling leaf,\n+    JAVA_BLACKHOLE=  8   \/\/ blackholed method\n","filename":"src\/hotspot\/share\/adlc\/forms.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -416,0 +416,2 @@\n+  if(_matrule->find_type(\"CallBlackholeJava\",idx)) return Form::JAVA_BLACKHOLE;\n+  idx = 0;\n@@ -1131,0 +1133,3 @@\n+  else if( is_ideal_call() == Form::JAVA_BLACKHOLE ) {\n+    return \"MachCallBlackholeJavaNode\";\n+  }\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -696,0 +696,3 @@\n+    case Form::JAVA_BLACKHOLE:\n+      \/\/ Nothing additional to print\n+      break;\n","filename":"src\/hotspot\/share\/adlc\/output_h.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1056,0 +1056,1 @@\n+void Canonicalizer::do_Blackhole(Blackhole* x) {}\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -114,0 +114,1 @@\n+  virtual void do_Blackhole      (Blackhole* x);\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2029,0 +2029,11 @@\n+  \/\/ check if we need to blackhole the method\n+  if (target->is_loaded() && target->return_type()->basic_type() == T_VOID &&\n+      compilation()->directive()->should_blackhole(target)) {\n+    if (try_blackhole(target)) {\n+      print_inlining(target, \"blackhole\", \/*success*\/ true);\n+      return;\n+    } else {\n+      assert(false, \"Blackholing should always work\");\n+    }\n+  }\n+\n@@ -3455,0 +3466,11 @@\n+bool GraphBuilder::try_blackhole(ciMethod* callee) {\n+  Values* args = state()->pop_arguments(callee->arg_size());\n+\n+  \/\/ Blackhole everything except the receiver itself\n+  int start = callee->flags().is_static() ? 0 : 1;\n+  for (int c = start; c < args->length(); c++) {\n+    append(new Blackhole(args->at(c)));\n+  }\n+\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -357,0 +357,2 @@\n+  bool try_blackhole(ciMethod* callee);\n+\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1045,0 +1045,4 @@\n+\n+Blackhole::Blackhole(Value v) : Instruction(illegalType), _v(v) {\n+  pin();\n+}\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -112,0 +112,1 @@\n+class   Blackhole;\n@@ -211,0 +212,1 @@\n+  virtual void do_Blackhole      (Blackhole*       x) = 0;\n@@ -2612,0 +2614,15 @@\n+LEAF(Blackhole, Instruction)\n+private:\n+  Value       _v;\n+\n+public:\n+  \/\/ creation\n+  Blackhole(Value v);\n+\n+  \/\/ accessors\n+  Value v() { return _v; }\n+\n+  \/\/ generic\n+  virtual void input_values_do(ValueVisitor* f)  { f->visit(&_v); }\n+};\n+\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -864,0 +864,9 @@\n+void InstructionPrinter::do_Blackhole(Blackhole* x) {\n+  if (x->v() != NULL) {\n+    output()->print(\"blackhole \");\n+    print_value(x->v());\n+  } else {\n+    output()->print(\"incorrect blackhole\");\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/c1\/c1_InstructionPrinter.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -138,0 +138,1 @@\n+  virtual void do_Blackhole      (Blackhole* x);\n","filename":"src\/hotspot\/share\/c1\/c1_InstructionPrinter.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3628,0 +3628,6 @@\n+void LIRGenerator::do_Blackhole(Blackhole *x) {\n+  \/\/ Load the argument\n+  LIRItem vitem(x->v(), this);\n+  vitem.load_item();\n+  \/\/ ...and leave it unused.\n+}\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -599,0 +599,1 @@\n+  virtual void do_Blackhole      (Blackhole* x);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -544,0 +544,1 @@\n+  void do_Blackhole      (Blackhole* x);\n@@ -731,0 +732,1 @@\n+void NullCheckVisitor::do_Blackhole      (Blackhole* x) {}\n","filename":"src\/hotspot\/share\/c1\/c1_Optimizer.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -176,0 +176,1 @@\n+    void do_Blackhole      (Blackhole* x)       { \/* nothing to do *\/ };\n","filename":"src\/hotspot\/share\/c1\/c1_RangeCheckElimination.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -212,0 +212,3 @@\n+  void do_Blackhole      (Blackhole* x) {\n+    kill_memory();\n+  };\n","filename":"src\/hotspot\/share\/c1\/c1_ValueMap.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -458,0 +458,11 @@\n+bool DirectiveSet::should_blackhole(ciMethod* m) {\n+  m->check_is_loaded();\n+  VM_ENTRY_MARK;\n+  methodHandle mh(THREAD, m->get_Method());\n+\n+  if (!CompilerDirectivesIgnoreCompileCommandsOption) {\n+    return CompilerOracle::should_blackhole(mh);\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -116,0 +116,1 @@\n+  bool should_blackhole(ciMethod* m);\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -391,1 +391,3 @@\n-  return check_predicate(CompileCommand::DontInline, method) || check_predicate(CompileCommand::Exclude, method);\n+  return check_predicate(CompileCommand::DontInline, method) ||\n+         check_predicate(CompileCommand::Exclude, method) ||\n+         check_predicate(CompileCommand::Blackhole, method);\n@@ -414,0 +416,4 @@\n+bool CompilerOracle::should_blackhole(const methodHandle& method) {\n+  return (check_predicate(CompileCommand::Blackhole, method));\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+  option(Blackhole,  \"blackhole\", Bool) \\\n@@ -143,0 +144,3 @@\n+  \/\/ Tells whether to blackhole when compiling method\n+  static bool should_blackhole(const methodHandle& method);\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-  CallStaticJavaNode* _call_node;\n+  CallJavaNode* _call_node;\n@@ -132,1 +132,1 @@\n-  CallStaticJavaNode* call_node() const { return _call_node; }\n+  CallJavaNode* call_node() const { return _call_node; }\n@@ -146,1 +146,7 @@\n-  CallStaticJavaNode *call = new CallStaticJavaNode(kit.C, tf(), target, method(), kit.bci());\n+  CallJavaNode* call = NULL;\n+  if (CallJavaNode::should_blackhole(method())) {\n+    \/\/ Should blackhole this method instead.\n+    call = new CallBlackholeJavaNode(tf(), target, method(), kit.bci());\n+  } else {\n+    call = new CallStaticJavaNode(kit.C, tf(), target, method(), kit.bci());\n+  }\n@@ -244,2 +250,8 @@\n-  \/\/ Normal inline cache used for call\n-  CallDynamicJavaNode *call = new CallDynamicJavaNode(tf(), target, method(), _vtable_index, kit.bci());\n+  CallJavaNode* call = NULL;\n+  if (CallJavaNode::should_blackhole(method())) {\n+    \/\/ Should blackhole this method instead.\n+    call = new CallBlackholeJavaNode(tf(), target, method(), kit.bci());\n+  } else {\n+    \/\/ Normal inline cache used for call\n+    call = new CallDynamicJavaNode(tf(), target, method(), _vtable_index, kit.bci());\n+  }\n@@ -348,1 +360,1 @@\n-  CallStaticJavaNode* call = call_node();\n+  CallJavaNode* call = call_node();\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":18,"deletions":6,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-  virtual CallStaticJavaNode* call_node() const { ShouldNotReachHere(); return NULL; }\n+  virtual CallJavaNode* call_node() const { ShouldNotReachHere(); return NULL; }\n","filename":"src\/hotspot\/share\/opto\/callGenerator.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1036,0 +1036,7 @@\n+bool CallJavaNode::should_blackhole(ciMethod* method) {\n+  return method != NULL && method->is_loaded() &&\n+         method->return_type()->basic_type() == T_VOID &&\n+         Compile::current()->directive()->should_blackhole(method) &&\n+         Matcher::match_rule_supported(Op_CallBlackholeJava);\n+}\n+\n@@ -1121,0 +1128,36 @@\n+\/\/=============================================================================\n+uint CallBlackholeJavaNode::size_of() const { return sizeof(*this); }\n+bool CallBlackholeJavaNode::cmp( const Node &n ) const {\n+  CallBlackholeJavaNode &call = (CallBlackholeJavaNode&)n;\n+  return CallJavaNode::cmp(call);\n+}\n+#ifndef PRODUCT\n+void CallBlackholeJavaNode::dump_spec(outputStream *st) const {\n+  st->print(\"# Blackhole \");\n+  CallJavaNode::dump_spec(st);\n+}\n+#endif\n+\n+Node* CallBlackholeJavaNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+  Node* node = CallJavaNode::Ideal(phase, can_reshape);\n+  if (node != NULL) {\n+    return node;\n+  }\n+\n+  if (can_reshape) {\n+    \/\/ Purge debug info for blackholed method\n+    bool progress = false;\n+    Node *top = Compile::current()->top();\n+    uint dbg_start = tf()->domain()->cnt();\n+    for (uint i = dbg_start; i < req(); i++) {\n+      if (in(i) != top) {\n+        set_req(i, top);\n+        progress = true;\n+      }\n+    }\n+    return progress ? this : NULL;\n+  }\n+\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+class       CallBlackholeJavaNode;\n@@ -701,0 +702,2 @@\n+  static bool should_blackhole(ciMethod* method);\n+\n@@ -772,0 +775,23 @@\n+\/\/------------------------------CallBlackholeJavaNode----------------------------\n+\/\/ Make a blackholed call. It would survive through the compiler and keep\n+\/\/ the effects on its argument, and would be finally emitted as nothing.\n+class CallBlackholeJavaNode : public CallJavaNode {\n+  virtual bool cmp( const Node &n ) const;\n+  virtual uint size_of() const; \/\/ Size is bigger\n+public:\n+  CallBlackholeJavaNode( const TypeFunc *tf , address addr, ciMethod* method, int bci ) : CallJavaNode(tf,addr,method,bci) {\n+    init_class_id(Class_CallBlackholeJava);\n+  }\n+\n+  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n+\n+  \/\/ If method is blackholed, there is no method body, and thus no\n+  \/\/ safepoint, and therefore safepoint is not guaranteed.\n+  virtual bool guaranteed_safepoint()      { return false; }\n+\n+  virtual int   Opcode() const;\n+#ifndef PRODUCT\n+  virtual void  dump_spec(outputStream *st) const;\n+#endif\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+macro(CallBlackholeJava)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2903,0 +2903,1 @@\n+  case Op_CallBlackholeJava:\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -863,0 +863,1 @@\n+    case Op_CallBlackholeJava:\n@@ -904,1 +905,3 @@\n-  add_call_kills(proj, regs, save_policy, exclude_soe);\n+  if (op != Op_CallBlackholeJava) {\n+    add_call_kills(proj, regs, save_policy, exclude_soe);\n+  }\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -809,0 +809,12 @@\n+const RegMask &MachCallBlackholeJavaNode::in_RegMask(uint idx) const {\n+  \/\/ Fake the incoming arguments mask for blackholes: accept all registers and all stack slots.\n+  \/\/ This must avoid moving the arguments for the call that never happens.\n+  return RegMask::All;\n+}\n+#ifndef PRODUCT\n+void MachCallBlackholeJavaNode::dump_spec(outputStream *st) const {\n+  st->print(\"Blackhole \");\n+  MachCallJavaNode::dump_spec(st);\n+}\n+#endif\n+\/\/=============================================================================\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+class MachCallBlackholeJavaNode;\n@@ -990,0 +991,14 @@\n+\/\/------------------------------MachCallBlackholeJavaNode------------------------\n+\/\/ Machine-specific versions of blackholed call\n+class MachCallBlackholeJavaNode : public MachCallJavaNode {\n+public:\n+  MachCallBlackholeJavaNode() : MachCallJavaNode() {\n+    init_class_id(Class_MachCallBlackholeJava);\n+  }\n+  virtual const RegMask &in_RegMask(uint) const;\n+  virtual int ret_addr_offset();\n+#ifndef PRODUCT\n+  virtual void dump_spec(outputStream *st) const;\n+#endif\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1384,1 +1384,1 @@\n-  if (mcall) {\n+  if (mcall && !mcall->is_MachCallBlackholeJava()) {\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+class CallBlackholeJavaNode;\n@@ -100,0 +101,1 @@\n+class MachCallBlackholeJavaNode;\n@@ -628,0 +630,1 @@\n+            DEFINE_CLASS_ID(CallBlackholeJava, CallJava, 2)\n@@ -658,0 +661,1 @@\n+              DEFINE_CLASS_ID(MachCallBlackholeJava, MachCallJava, 2)\n@@ -826,0 +830,1 @@\n+  DEFINE_CLASS_QUERY(CallBlackholeJava)\n@@ -864,0 +869,1 @@\n+  DEFINE_CLASS_QUERY(MachCallBlackholeJava)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -54,0 +54,7 @@\n+const RegMask RegMask::All(\n+# define BODY(I) -1,\n+  FORALL_BODY\n+# undef BODY\n+  0\n+);\n+\n","filename":"src\/hotspot\/share\/opto\/regmask.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -353,0 +353,1 @@\n+  static const RegMask All;     \/\/ Common all mask\n","filename":"src\/hotspot\/share\/opto\/regmask.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1523,0 +1523,1 @@\n+  declare_c2_type(CallBlackholeJavaNode, CallJavaNode)                    \\\n@@ -1641,0 +1642,1 @@\n+  declare_c2_type(MachCallBlackholeJavaNode, MachCallJavaNode)            \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,236 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ *\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceReturnTest\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceReturnTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires vm.bits == \"64\"\n+ *\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceReturnTest\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceReturnTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+import sun.hotspot.WhiteBox;\n+\n+public class BlackholeInstanceReturnTest {\n+\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    public static void main(String[] args) {\n+        \/\/ Warmup\/resolve methods\n+        BlackholeTarget.clear();\n+        test_boolean();\n+\n+        BlackholeTarget.clear();\n+        test_byte();\n+\n+        BlackholeTarget.clear();\n+        test_char();\n+\n+        BlackholeTarget.clear();\n+        test_short();\n+\n+        BlackholeTarget.clear();\n+        test_int();\n+\n+        BlackholeTarget.clear();\n+        test_float();\n+\n+        BlackholeTarget.clear();\n+        test_long();\n+\n+        BlackholeTarget.clear();\n+        test_double();\n+\n+        BlackholeTarget.clear();\n+        test_Object();\n+\n+        \/\/ Now that all tests are guaranteed to be linked, recompile.\n+        \/\/ Then seee if targets are still entered, despite the compiler commands.\n+\n+        WB.deoptimizeAll();\n+\n+        BlackholeTarget.clear();\n+        test_boolean();\n+        BlackholeTarget.shouldBeEntered();\n+\n+        BlackholeTarget.clear();\n+        test_byte();\n+        BlackholeTarget.shouldBeEntered();\n+\n+        BlackholeTarget.clear();\n+        test_char();\n+        BlackholeTarget.shouldBeEntered();\n+\n+        BlackholeTarget.clear();\n+        test_short();\n+        BlackholeTarget.shouldBeEntered();\n+\n+        BlackholeTarget.clear();\n+        test_int();\n+        BlackholeTarget.shouldBeEntered();\n+\n+        BlackholeTarget.clear();\n+        test_float();\n+        BlackholeTarget.shouldBeEntered();\n+\n+        BlackholeTarget.clear();\n+        test_long();\n+        BlackholeTarget.shouldBeEntered();\n+\n+        BlackholeTarget.clear();\n+        test_double();\n+        BlackholeTarget.shouldBeEntered();\n+\n+        BlackholeTarget.clear();\n+        test_Object();\n+        BlackholeTarget.shouldBeEntered();\n+    }\n+\n+    private static void test_boolean() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < 1_000_000; c++) {\n+            if (t.bh_ir_boolean((c & 0x1) == 0) != false) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_byte() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < 1_000_000; c++) {\n+            if (t.bh_ir_byte((byte)c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_char() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < 1_000_000; c++) {\n+            if (t.bh_ir_char((char)c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_short() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < 1_000_000; c++) {\n+            if (t.bh_ir_short((short)c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_int() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < 1_000_000; c++) {\n+            if (t.bh_ir_int(c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_float() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < 1_000_000; c++) {\n+            if (t.bh_ir_float(c) != 0F) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_long() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < 1_000_000; c++) {\n+            if (t.bh_ir_long(c) != 0L) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_double() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < 1_000_000; c++) {\n+            if (t.bh_ir_double(c) != 0D) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_Object() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < 1_000_000; c++) {\n+            if (t.bh_ir_Object(Integer.valueOf(c)) != null) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeInstanceReturnTest.java","additions":236,"deletions":0,"binary":false,"changes":236,"status":"added"},{"patch":"@@ -0,0 +1,207 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ *\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceSingleArgTest\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceSingleArgTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires vm.bits == \"64\"\n+ *\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceSingleArgTest\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceSingleArgTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+import sun.hotspot.WhiteBox;\n+\n+public class BlackholeInstanceSingleArgTest {\n+\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    public static void main(String[] args) {\n+        \/\/ Warmup\/resolve methods\n+        BlackholeTarget.clear();\n+        test_boolean();\n+\n+        BlackholeTarget.clear();\n+        test_byte();\n+\n+        BlackholeTarget.clear();\n+        test_char();\n+\n+        BlackholeTarget.clear();\n+        test_short();\n+\n+        BlackholeTarget.clear();\n+        test_int();\n+\n+        BlackholeTarget.clear();\n+        test_float();\n+\n+        BlackholeTarget.clear();\n+        test_long();\n+\n+        BlackholeTarget.clear();\n+        test_double();\n+\n+        BlackholeTarget.clear();\n+        test_Object();\n+\n+        \/\/ Now that all tests are guaranteed to be linked, recompile.\n+        \/\/ Then make sure targets can still be called.\n+\n+        WB.deoptimizeAll();\n+\n+        BlackholeTarget.clear();\n+        test_boolean();\n+\n+        BlackholeTarget.clear();\n+        test_byte();\n+\n+        BlackholeTarget.clear();\n+        test_char();\n+\n+        BlackholeTarget.clear();\n+        test_short();\n+\n+        BlackholeTarget.clear();\n+        test_int();\n+\n+        BlackholeTarget.clear();\n+        test_float();\n+\n+        BlackholeTarget.clear();\n+        test_long();\n+\n+        BlackholeTarget.clear();\n+        test_double();\n+\n+        BlackholeTarget.clear();\n+        test_Object();\n+    }\n+\n+    private static void test_boolean() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < 1_000_000; c++) {\n+            t.bh_i_boolean((c & 0x1) == 0);\n+        }\n+    }\n+\n+    private static void test_byte() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < 1_000_000; c++) {\n+            t.bh_i_byte((byte)c);\n+        }\n+    }\n+\n+    private static void test_char() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < 1_000_000; c++) {\n+            t.bh_i_char((char)c);\n+        }\n+    }\n+\n+    private static void test_short() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < 1_000_000; c++) {\n+            t.bh_i_short((short)c);\n+        }\n+    }\n+\n+    private static void test_int() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < 1_000_000; c++) {\n+            t.bh_i_int(c);\n+        }\n+    }\n+\n+    private static void test_float() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < 1_000_000; c++) {\n+            t.bh_i_float(c);\n+        }\n+    }\n+\n+    private static void test_long() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < 1_000_000; c++) {\n+            t.bh_i_long(c);\n+        }\n+    }\n+\n+    private static void test_double() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < 1_000_000; c++) {\n+            t.bh_i_double(c);\n+        }\n+    }\n+\n+    private static void test_Object() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < 1_000_000; c++) {\n+            t.bh_i_Object(Integer.valueOf(c));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeInstanceSingleArgTest.java","additions":207,"deletions":0,"binary":false,"changes":207,"status":"added"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:TieredStopAtLevel=1 -Xcomp -Xbatch -XX:-UseOnStackReplacement\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeRemovalTest\n+ *\/\n+\n+\/*\n+ * @ignore \/\/ C2 does not blackhole consistently yet\n+ * @test\n+ *\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:-TieredCompilation -Xcomp -Xbatch -XX:-UseOnStackReplacement\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeRemovalTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires vm.bits == \"64\"\n+ *\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:TieredStopAtLevel=1 -Xcomp -Xbatch -XX:-UseOnStackReplacement\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeRemovalTest\n+ *\n+\n+\/*\n+ * @ignore \/\/ C2 does not blackhole consistently yet\n+ * @test\n+ * @requires vm.bits == \"64\"\n+ *\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:-TieredCompilation -Xcomp -Xbatch -XX:-UseOnStackReplacement\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeRemovalTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+import sun.hotspot.WhiteBox;\n+\n+public class BlackholeRemovalTest {\n+\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    public static void main(String[] args) {\n+        \/\/ Warmup\/resolve methods\n+        BlackholeTarget.clear();\n+        test_boolean();\n+\n+        BlackholeTarget.clear();\n+        test_byte();\n+\n+        BlackholeTarget.clear();\n+        test_char();\n+\n+        BlackholeTarget.clear();\n+        test_short();\n+\n+        BlackholeTarget.clear();\n+        test_int();\n+\n+        BlackholeTarget.clear();\n+        test_float();\n+\n+        BlackholeTarget.clear();\n+        test_long();\n+\n+        BlackholeTarget.clear();\n+        test_double();\n+\n+        BlackholeTarget.clear();\n+        test_Object();\n+\n+        \/\/ Now that all tests are guaranteed to be linked,\n+        \/\/ recompile and see if targets crashing the VM are removed.\n+        BlackholeTarget.clear();\n+        WB.deoptimizeAll();\n+\n+        test_boolean();\n+        BlackholeTarget.shouldNotBeEntered();\n+\n+        test_byte();\n+        BlackholeTarget.shouldNotBeEntered();\n+\n+        test_char();\n+        BlackholeTarget.shouldNotBeEntered();\n+\n+        test_short();\n+        BlackholeTarget.shouldNotBeEntered();\n+\n+        test_int();\n+        BlackholeTarget.shouldNotBeEntered();\n+\n+        test_float();\n+        BlackholeTarget.shouldNotBeEntered();\n+\n+        test_long();\n+        BlackholeTarget.shouldNotBeEntered();\n+\n+        test_double();\n+        BlackholeTarget.shouldNotBeEntered();\n+\n+        test_Object();\n+        BlackholeTarget.shouldNotBeEntered();\n+    }\n+\n+    private static void test_boolean() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            BlackholeTarget.bh_s_boolean((c & 0x1) == 0);\n+        }\n+    }\n+\n+    private static void test_byte() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            BlackholeTarget.bh_s_byte((byte)c);\n+        }\n+    }\n+\n+    private static void test_char() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            BlackholeTarget.bh_s_char((char)c);\n+        }\n+    }\n+\n+    private static void test_short() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            BlackholeTarget.bh_s_short((short)c);\n+        }\n+    }\n+\n+    private static void test_int() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            BlackholeTarget.bh_s_int(c);\n+        }\n+    }\n+\n+    private static void test_float() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            BlackholeTarget.bh_s_float(c);\n+        }\n+    }\n+\n+    private static void test_long() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            BlackholeTarget.bh_s_long(c);\n+        }\n+    }\n+\n+    private static void test_double() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            BlackholeTarget.bh_s_double(c);\n+        }\n+    }\n+\n+    private static void test_Object() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            BlackholeTarget.bh_s_Object(Integer.valueOf(c));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeRemovalTest.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -0,0 +1,226 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ *\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticReturnTest\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticReturnTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires vm.bits == \"64\"\n+ *\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticReturnTest\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticReturnTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+import sun.hotspot.WhiteBox;\n+\n+public class BlackholeStaticReturnTest {\n+\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    public static void main(String[] args) {\n+        \/\/ Warmup\/resolve methods\n+        BlackholeTarget.clear();\n+        test_boolean();\n+\n+        BlackholeTarget.clear();\n+        test_byte();\n+\n+        BlackholeTarget.clear();\n+        test_char();\n+\n+        BlackholeTarget.clear();\n+        test_short();\n+\n+        BlackholeTarget.clear();\n+        test_int();\n+\n+        BlackholeTarget.clear();\n+        test_float();\n+\n+        BlackholeTarget.clear();\n+        test_long();\n+\n+        BlackholeTarget.clear();\n+        test_double();\n+\n+        BlackholeTarget.clear();\n+        test_Object();\n+\n+        \/\/ Now that all tests are guaranteed to be linked, recompile.\n+        \/\/ Then see if targets are still entered, despite the compiler commands.\n+\n+        WB.deoptimizeAll();\n+\n+        BlackholeTarget.clear();\n+        test_boolean();\n+        BlackholeTarget.shouldBeEntered();\n+\n+        BlackholeTarget.clear();\n+        test_byte();\n+        BlackholeTarget.shouldBeEntered();\n+\n+        BlackholeTarget.clear();\n+        test_char();\n+        BlackholeTarget.shouldBeEntered();\n+\n+        BlackholeTarget.clear();\n+        test_short();\n+        BlackholeTarget.shouldBeEntered();\n+\n+        BlackholeTarget.clear();\n+        test_int();\n+        BlackholeTarget.shouldBeEntered();\n+\n+        BlackholeTarget.clear();\n+        test_float();\n+        BlackholeTarget.shouldBeEntered();\n+\n+        BlackholeTarget.clear();\n+        test_long();\n+        BlackholeTarget.shouldBeEntered();\n+\n+        BlackholeTarget.clear();\n+        test_double();\n+        BlackholeTarget.shouldBeEntered();\n+\n+        BlackholeTarget.clear();\n+        test_Object();\n+        BlackholeTarget.shouldBeEntered();\n+    }\n+\n+    private static void test_boolean() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            if (BlackholeTarget.bh_sr_boolean((c & 0x1) == 0) != false) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_byte() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            if (BlackholeTarget.bh_sr_byte((byte)c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_char() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            if (BlackholeTarget.bh_sr_char((char)c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_short() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            if (BlackholeTarget.bh_sr_short((short)c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_int() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            if (BlackholeTarget.bh_sr_int(c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_float() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            if (BlackholeTarget.bh_sr_float(c) != 0F) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_long() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            if (BlackholeTarget.bh_sr_long(c) != 0L) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_double() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            if (BlackholeTarget.bh_sr_double(c) != 0D) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_Object() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            if (BlackholeTarget.bh_sr_Object(Integer.valueOf(c)) != null) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeStaticReturnTest.java","additions":226,"deletions":0,"binary":false,"changes":226,"status":"added"},{"patch":"@@ -0,0 +1,198 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ *\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticSingleArgTest\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticSingleArgTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires vm.bits == \"64\"\n+ *\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticSingleArgTest\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticSingleArgTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+import sun.hotspot.WhiteBox;\n+\n+public class BlackholeStaticSingleArgTest {\n+\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    public static void main(String[] args) {\n+        \/\/ Warmup\/resolve methods\n+        BlackholeTarget.clear();\n+        test_boolean();\n+\n+        BlackholeTarget.clear();\n+        test_byte();\n+\n+        BlackholeTarget.clear();\n+        test_char();\n+\n+        BlackholeTarget.clear();\n+        test_short();\n+\n+        BlackholeTarget.clear();\n+        test_int();\n+\n+        BlackholeTarget.clear();\n+        test_float();\n+\n+        BlackholeTarget.clear();\n+        test_long();\n+\n+        BlackholeTarget.clear();\n+        test_double();\n+\n+        BlackholeTarget.clear();\n+        test_Object();\n+\n+        \/\/ Now that all tests are guaranteed to be linked, recompile.\n+        \/\/ Then make sure targets can still be called.\n+\n+        WB.deoptimizeAll();\n+\n+        BlackholeTarget.clear();\n+        test_boolean();\n+\n+        BlackholeTarget.clear();\n+        test_byte();\n+\n+        BlackholeTarget.clear();\n+        test_char();\n+\n+        BlackholeTarget.clear();\n+        test_short();\n+\n+        BlackholeTarget.clear();\n+        test_int();\n+\n+        BlackholeTarget.clear();\n+        test_float();\n+\n+        BlackholeTarget.clear();\n+        test_long();\n+\n+        BlackholeTarget.clear();\n+        test_double();\n+\n+        BlackholeTarget.clear();\n+        test_Object();\n+    }\n+\n+    private static void test_boolean() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            BlackholeTarget.bh_s_boolean((c & 0x1) == 0);\n+        }\n+    }\n+\n+    private static void test_byte() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            BlackholeTarget.bh_s_byte((byte)c);\n+        }\n+    }\n+\n+    private static void test_char() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            BlackholeTarget.bh_s_char((char)c);\n+        }\n+    }\n+\n+    private static void test_short() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            BlackholeTarget.bh_s_short((short)c);\n+        }\n+    }\n+\n+    private static void test_int() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            BlackholeTarget.bh_s_int(c);\n+        }\n+    }\n+\n+    private static void test_float() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            BlackholeTarget.bh_s_float(c);\n+        }\n+    }\n+\n+    private static void test_long() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            BlackholeTarget.bh_s_long(c);\n+        }\n+    }\n+\n+    private static void test_double() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            BlackholeTarget.bh_s_double(c);\n+        }\n+    }\n+\n+    private static void test_Object() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            BlackholeTarget.bh_s_Object(Integer.valueOf(c));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeStaticSingleArgTest.java","additions":198,"deletions":0,"binary":false,"changes":198,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.blackhole;\n+\n+import java.lang.reflect.*;\n+\n+public class BlackholeTarget {\n+    private static String entered;\n+\n+    private static void registerEntered(String label) {\n+        if (entered == null) {\n+           entered = label;\n+        } else if (!entered.equals(label)) {\n+           throw new IllegalStateException(\"Trying to register enter with overwrite: \" + entered + \" -> \" + label);\n+        }\n+    }\n+\n+    public static void clear() {\n+        entered = null;\n+    }\n+\n+    public static void shouldBeEntered() {\n+        if (entered == null) {\n+            throw new IllegalStateException(\"Should have been entered\");\n+        }\n+    }\n+\n+    public static void shouldNotBeEntered() {\n+        if (entered != null) {\n+            throw new IllegalStateException(\"Should not have been entered: \" + entered);\n+        }\n+    }\n+\n+    public static void    bh_s_boolean(boolean v)  { registerEntered(\"bh_s_boolean\"); }\n+    public static void    bh_s_byte(byte v)        { registerEntered(\"bh_s_byte\");    }\n+    public static void    bh_s_short(short v)      { registerEntered(\"bh_s_short\");   }\n+    public static void    bh_s_char(char v)        { registerEntered(\"bh_s_char\");    }\n+    public static void    bh_s_int(int v)          { registerEntered(\"bh_s_int\");     }\n+    public static void    bh_s_float(float v)      { registerEntered(\"bh_s_float\");   }\n+    public static void    bh_s_long(long v)        { registerEntered(\"bh_s_long\");    }\n+    public static void    bh_s_double(double v)    { registerEntered(\"bh_s_double\");  }\n+    public static void    bh_s_Object(Object v)    { registerEntered(\"bh_s_Object\");  }\n+\n+    public        void    bh_i_boolean(boolean v)  { registerEntered(\"bh_i_boolean\"); }\n+    public        void    bh_i_byte(byte v)        { registerEntered(\"bh_i_byte\");    }\n+    public        void    bh_i_short(short v)      { registerEntered(\"bh_i_short\");   }\n+    public        void    bh_i_char(char v)        { registerEntered(\"bh_i_char\");    }\n+    public        void    bh_i_int(int v)          { registerEntered(\"bh_i_int\");     }\n+    public        void    bh_i_float(float v)      { registerEntered(\"bh_i_float\");   }\n+    public        void    bh_i_long(long v)        { registerEntered(\"bh_i_long\");    }\n+    public        void    bh_i_double(double v)    { registerEntered(\"bh_i_double\");  }\n+    public        void    bh_i_Object(Object v)    { registerEntered(\"bh_i_Object\");  }\n+\n+    public static boolean bh_sr_boolean(boolean v) { registerEntered(\"bh_sr_boolean\"); return false; }\n+    public static byte    bh_sr_byte(byte v)       { registerEntered(\"bh_sr_byte\");    return 0;     }\n+    public static short   bh_sr_short(short v)     { registerEntered(\"bh_sr_short\");   return 0;     }\n+    public static char    bh_sr_char(char v)       { registerEntered(\"bh_sr_char\");    return 0;     }\n+    public static int     bh_sr_int(int v)         { registerEntered(\"bh_sr_int\");     return 0;     }\n+    public static float   bh_sr_float(float v)     { registerEntered(\"bh_sr_float\");   return 0;     }\n+    public static long    bh_sr_long(long v)       { registerEntered(\"bh_sr_long\");    return 0;     }\n+    public static double  bh_sr_double(double v)   { registerEntered(\"bh_sr_double\");  return 0;     }\n+    public static Object  bh_sr_Object(Object v)   { registerEntered(\"bh_sr_Object\");  return null;  }\n+\n+    public        boolean bh_ir_boolean(boolean v) { registerEntered(\"bh_ir_boolean\"); return false; }\n+    public        byte    bh_ir_byte(byte v)       { registerEntered(\"bh_ir_byte\");    return 0;     }\n+    public        short   bh_ir_short(short v)     { registerEntered(\"bh_ir_short\");   return 0;     }\n+    public        char    bh_ir_char(char v)       { registerEntered(\"bh_ir_char\");    return 0;     }\n+    public        int     bh_ir_int(int v)         { registerEntered(\"bh_ir_int\");     return 0;     }\n+    public        float   bh_ir_float(float v)     { registerEntered(\"bh_ir_float\");   return 0;     }\n+    public        long    bh_ir_long(long v)       { registerEntered(\"bh_ir_long\");    return 0;     }\n+    public        double  bh_ir_double(double v)   { registerEntered(\"bh_ir_double\");  return 0;     }\n+    public        Object  bh_ir_Object(Object v)   { registerEntered(\"bh_ir_Object\");  return null;  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeTarget.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"}]}