{"files":[{"patch":"@@ -2524,4 +2524,0 @@\n-const bool Matcher::supports_blackholes() {\n-  return true;\n-}\n-\n@@ -15959,2 +15955,0 @@\n-  predicate(!n->as_CallJava()->should_blackhole());\n-\n@@ -15973,18 +15967,0 @@\n-instruct CallStaticJavaDirect_Blackhole(method meth)\n-%{\n-  match(CallStaticJava);\n-\n-  predicate(n->as_CallJava()->should_blackhole());\n-\n-  effect(USE meth);\n-\n-  ins_cost(CALL_COST);\n-\n-  format %{ \"call,static,blackhole $meth \\t\/\/ ==> \" %}\n-\n-  ins_encode(); \/\/ encode to nothing: blackhole\n-\n-  ins_pipe(pipe_class_call);\n-%}\n-\n-\n@@ -15998,2 +15974,0 @@\n-  predicate(!n->as_CallJava()->should_blackhole());\n-\n@@ -16012,1 +15986,1 @@\n-instruct CallDynamicJavaDirect_Blackhole(method meth)\n+instruct CallBlackholeJavaDirect(method meth)\n@@ -16014,3 +15988,1 @@\n-  match(CallDynamicJava);\n-\n-  predicate(n->as_CallJava()->should_blackhole());\n+  match(CallBlackholeJava);\n@@ -16020,1 +15992,1 @@\n-  ins_cost(CALL_COST);\n+  ins_cost(1);\n@@ -16022,1 +15994,1 @@\n-  format %{ \"CALL,dynamic,blackhole $meth \\t\/\/ ==> \" %}\n+  format %{ \"call,blackhole \" %}\n@@ -16024,1 +15996,1 @@\n-  ins_encode(); \/\/ encode to nothing: blackhole\n+  ins_encode(); \/\/ Encode to nothing\n@@ -16026,1 +15998,1 @@\n-  ins_pipe(pipe_class_call);\n+  ins_pipe(empty);\n@@ -16029,1 +16001,0 @@\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":6,"deletions":35,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -1044,5 +1044,0 @@\n-const bool Matcher::supports_blackholes() {\n-  \/\/ Not implemented yet.\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2203,5 +2203,0 @@\n-const bool Matcher::supports_blackholes() {\n-  \/\/ Not implemented yet.\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1591,5 +1591,0 @@\n-const bool Matcher::supports_blackholes() {\n-  \/\/ Not implemented yet.\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1902,3 +1902,0 @@\n-const bool Matcher::supports_blackholes() {\n-  return true;\n-}\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -454,0 +454,6 @@\n+int MachCallBlackholeJavaNode::ret_addr_offset()\n+{\n+  \/\/ Fake it, no address.\n+  return 0;\n+}\n+\n@@ -2131,0 +2137,4 @@\n+  enc_class Java_Blackhole_Call(method meth) %{\n+    \/\/ Do nothing\n+  %}\n+\n@@ -12353,1 +12363,0 @@\n-  predicate(!n->as_CallJava()->should_blackhole());\n@@ -12364,11 +12373,0 @@\n-instruct CallStaticJavaDirect_Blackhole(method meth) %{\n-  match(CallStaticJava);\n-  predicate(n->as_CallJava()->should_blackhole());\n-  effect(USE meth);\n-\n-  ins_cost(1);\n-  format %{ \"call,static,blackhole \" %}\n-  ins_encode(); \/\/ Encode to nothing: blackhole.\n-  ins_pipe(empty);\n-%}\n-\n@@ -12381,1 +12379,0 @@\n-  predicate(!n->as_CallJava()->should_blackhole());\n@@ -12392,1 +12389,1 @@\n-instruct CallDynamicJavaDirect_Blackhole(method meth)\n+instruct CallBlackholeJavaDirect(method meth)\n@@ -12394,2 +12391,1 @@\n-  match(CallDynamicJava);\n-  predicate(n->as_CallJava()->should_blackhole());\n+  match(CallBlackholeJava);\n@@ -12398,3 +12394,3 @@\n-  ins_cost(300);\n-  format %{ \"call,dynamic,blackhole \" %}\n-  ins_encode(); \/\/ Encode to nothing: blackhole.\n+  ins_cost(1);\n+  format %{ \"call,blackhole \" %}\n+  ins_encode(); \/\/ Encode to nothing\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":15,"deletions":19,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -202,1 +202,2 @@\n-    JAVA_LEAF     =  7   \/\/ calling leaf\n+    JAVA_LEAF     =  7,  \/\/ calling leaf,\n+    JAVA_BLACKHOLE=  8   \/\/ blackholed method\n","filename":"src\/hotspot\/share\/adlc\/forms.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -416,0 +416,2 @@\n+  if(_matrule->find_type(\"CallBlackholeJava\",idx)) return Form::JAVA_BLACKHOLE;\n+  idx = 0;\n@@ -1128,0 +1130,3 @@\n+  else if( is_ideal_call() == Form::JAVA_BLACKHOLE ) {\n+    return \"MachCallBlackholeJavaNode\";\n+  }\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -696,0 +696,3 @@\n+    case Form::JAVA_BLACKHOLE:\n+      \/\/ TODO: What to print here?\n+      break;\n","filename":"src\/hotspot\/share\/adlc\/output_h.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-  CallStaticJavaNode* _call_node;\n+  CallJavaNode* _call_node;\n@@ -130,1 +130,1 @@\n-  CallStaticJavaNode* call_node() const { return _call_node; }\n+  CallJavaNode* call_node() const { return _call_node; }\n@@ -144,1 +144,7 @@\n-  CallStaticJavaNode *call = new CallStaticJavaNode(kit.C, tf(), target, method(), kit.bci());\n+  CallJavaNode* call = NULL;\n+  if (CallJavaNode::should_blackhole(method())) {\n+    \/\/ Should blackhole this method instead.\n+    call = new CallBlackholeJavaNode(tf(), target, method(), kit.bci());\n+  } else {\n+    call = new CallStaticJavaNode(kit.C, tf(), target, method(), kit.bci());\n+  }\n@@ -242,2 +248,8 @@\n-  \/\/ Normal inline cache used for call\n-  CallDynamicJavaNode *call = new CallDynamicJavaNode(tf(), target, method(), _vtable_index, kit.bci());\n+  CallJavaNode* call = NULL;\n+  if (CallJavaNode::should_blackhole(method())) {\n+    \/\/ Should blackhole this method instead.\n+    call = new CallBlackholeJavaNode(tf(), target, method(), kit.bci());\n+  } else {\n+    \/\/ Normal inline cache used for call\n+    call = new CallDynamicJavaNode(tf(), target, method(), _vtable_index, kit.bci());\n+  }\n@@ -346,1 +358,1 @@\n-  CallStaticJavaNode* call = call_node();\n+  CallJavaNode* call = call_node();\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":18,"deletions":6,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-  virtual CallStaticJavaNode* call_node() const { ShouldNotReachHere(); return NULL; }\n+  virtual CallJavaNode* call_node() const { ShouldNotReachHere(); return NULL; }\n","filename":"src\/hotspot\/share\/opto\/callGenerator.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1031,15 +1031,0 @@\n-\n-  if (can_reshape && should_blackhole()) {\n-    \/\/ Purge debug info for blackholed method\n-    bool progress = false;\n-    Node* top = Compile::current()->top();\n-    uint dbg_start = tf()->domain()->cnt();\n-    for (uint i = dbg_start; i < req(); i++) {\n-      if (in(i) != top) {\n-        set_req(i, top);\n-        progress = true;\n-      }\n-    }\n-    return progress ? this : NULL;\n-  }\n-\n@@ -1049,5 +1034,5 @@\n-bool CallJavaNode::should_blackhole() const {\n-  return Matcher::supports_blackholes() &&\n-         method() != NULL && method()->is_loaded() &&\n-         method()->return_type()->basic_type() == T_VOID &&\n-         Compile::current()->directive()->should_blackhole(method());\n+bool CallJavaNode::should_blackhole(ciMethod* method) {\n+  return Matcher::match_rule_supported(Op_CallBlackholeJava) &&\n+         method != NULL && method->is_loaded() &&\n+         method->return_type()->basic_type() == T_VOID &&\n+         Compile::current()->directive()->should_blackhole(method);\n@@ -1141,0 +1126,36 @@\n+\/\/=============================================================================\n+uint CallBlackholeJavaNode::size_of() const { return sizeof(*this); }\n+bool CallBlackholeJavaNode::cmp( const Node &n ) const {\n+  CallBlackholeJavaNode &call = (CallBlackholeJavaNode&)n;\n+  return CallJavaNode::cmp(call);\n+}\n+#ifndef PRODUCT\n+void CallBlackholeJavaNode::dump_spec(outputStream *st) const {\n+  st->print(\"# Blackhole \");\n+  CallJavaNode::dump_spec(st);\n+}\n+#endif\n+\n+Node* CallBlackholeJavaNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+  Node* node = CallJavaNode::Ideal(phase, can_reshape);\n+  if (node != NULL) {\n+    return node;\n+  }\n+\n+  if (can_reshape) {\n+    \/\/ Purge debug info for blackholed method\n+    bool progress = false;\n+    Node *top = Compile::current()->top();\n+    uint dbg_start = tf()->domain()->cnt();\n+    for (uint i = dbg_start; i < req(); i++) {\n+      if (in(i) != top) {\n+        set_req(i, top);\n+        progress = true;\n+      }\n+    }\n+    return progress ? this : NULL;\n+  }\n+\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":41,"deletions":20,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+class       CallBlackholeJavaNode;\n@@ -700,5 +701,1 @@\n-  bool should_blackhole() const;\n-\n-  \/\/ Safepoint is guaranteed only if method is not blackholed. Otherwise,\n-  \/\/ there is no safepoint in the method body.\n-  virtual bool guaranteed_safepoint()      { return !should_blackhole(); }\n+  static bool should_blackhole(ciMethod* method);\n@@ -777,0 +774,23 @@\n+\/\/------------------------------CallBlackholeJavaNode----------------------------\n+\/\/ Make a blackholed call. It would survive through the compiler and keep\n+\/\/ the effects on its argument, and would be finally emitted as nothing.\n+class CallBlackholeJavaNode : public CallJavaNode {\n+  virtual bool cmp( const Node &n ) const;\n+  virtual uint size_of() const; \/\/ Size is bigger\n+public:\n+  CallBlackholeJavaNode( const TypeFunc *tf , address addr, ciMethod* method, int bci ) : CallJavaNode(tf,addr,method,bci) {\n+    init_class_id(Class_CallBlackholeJava);\n+  }\n+\n+  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n+\n+  \/\/ If method is blackholed, there is no method body, and thus no\n+  \/\/ safepoint, and therefore safepoint is not guaranteed.\n+  virtual bool guaranteed_safepoint()      { return false; }\n+\n+  virtual int   Opcode() const;\n+#ifndef PRODUCT\n+  virtual void  dump_spec(outputStream *st) const;\n+#endif\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":25,"deletions":5,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+macro(CallBlackholeJava)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2901,0 +2901,1 @@\n+  case Op_CallBlackholeJava:\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -862,0 +862,1 @@\n+    case Op_CallBlackholeJava:\n@@ -890,1 +891,1 @@\n-  if (mcall->isa_MachCallJava() == NULL || !mcall->as_MachCallJava()->is_blackhole()) {\n+  if (op != Op_CallBlackholeJava) {\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -735,2 +735,0 @@\n-  if (_blackhole)\n-    st->print(\"blackhole \");\n@@ -747,6 +745,0 @@\n-  \/\/ Fake the incoming arguments mask for blackholes: accept all registers and all stack slots.\n-  \/\/ This must avoid moving the arguments for the call that never happens.\n-  if (is_blackhole()) {\n-    return RegMask::All;\n-  }\n-\n@@ -817,0 +809,12 @@\n+const RegMask &MachCallBlackholeJavaNode::in_RegMask(uint idx) const {\n+  \/\/ Fake the incoming arguments mask for blackholes: accept all registers and all stack slots.\n+  \/\/ This must avoid moving the arguments for the call that never happens.\n+  return RegMask::All;\n+}\n+#ifndef PRODUCT\n+void MachCallBlackholeJavaNode::dump_spec(outputStream *st) const {\n+  st->print(\"Blackhole \");\n+  MachCallJavaNode::dump_spec(st);\n+}\n+#endif\n+\/\/=============================================================================\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+class MachCallBlackholeJavaNode;\n@@ -926,1 +927,0 @@\n-  bool      _blackhole;              \/\/ Tells if the call has to be blackholed\n@@ -932,3 +932,0 @@\n-  void set_blackhole(bool b)      { _blackhole = b; }\n-  bool is_blackhole() const       { return _blackhole; }\n-\n@@ -989,0 +986,14 @@\n+\/\/------------------------------MachCallBlackholeJavaNode------------------------\n+\/\/ Machine-specific versions of blackholed call\n+class MachCallBlackholeJavaNode : public MachCallJavaNode {\n+public:\n+  MachCallBlackholeJavaNode() : MachCallJavaNode() {\n+    init_class_id(Class_MachCallBlackholeJava);\n+  }\n+  virtual const RegMask &in_RegMask(uint) const;\n+  virtual int ret_addr_offset();\n+#ifndef PRODUCT\n+  virtual void dump_spec(outputStream *st) const;\n+#endif\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1264,2 +1264,0 @@\n-\n-      mcall_java->set_blackhole(call_java->should_blackhole());\n@@ -1376,1 +1374,1 @@\n-  if (mcall && !(mcall->is_MachCallJava() && mcall->as_MachCallJava()->is_blackhole())) {\n+  if (mcall && !mcall->is_MachCallBlackholeJava()) {\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -354,2 +354,0 @@\n-  static const bool supports_blackholes();\n-\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+class CallBlackholeJavaNode;\n@@ -97,0 +98,1 @@\n+class MachCallBlackholeJavaNode;\n@@ -623,0 +625,1 @@\n+            DEFINE_CLASS_ID(CallBlackholeJava, CallJava, 2)\n@@ -652,0 +655,1 @@\n+              DEFINE_CLASS_ID(MachCallBlackholeJava, MachCallJava, 2)\n@@ -816,0 +820,1 @@\n+  DEFINE_CLASS_QUERY(CallBlackholeJava)\n@@ -853,0 +858,1 @@\n+  DEFINE_CLASS_QUERY(MachCallBlackholeJava)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1524,0 +1524,1 @@\n+  declare_c2_type(CallBlackholeJavaNode, CallJavaNode)                    \\\n@@ -1641,0 +1642,1 @@\n+  declare_c2_type(MachCallBlackholeJavaNode, MachCallJavaNode)            \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}