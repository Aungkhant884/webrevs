{"files":[{"patch":"@@ -2524,0 +2524,4 @@\n+const bool Matcher::supports_blackholes() {\n+  return true;\n+}\n+\n@@ -15955,0 +15959,2 @@\n+  predicate(!n->as_CallJava()->should_blackhole());\n+\n@@ -15967,0 +15973,18 @@\n+instruct CallStaticJavaDirect_Blackhole(method meth)\n+%{\n+  match(CallStaticJava);\n+\n+  predicate(n->as_CallJava()->should_blackhole());\n+\n+  effect(USE meth);\n+\n+  ins_cost(CALL_COST);\n+\n+  format %{ \"call,static,blackhole $meth \\t\/\/ ==> \" %}\n+\n+  ins_encode(); \/\/ encode to nothing: blackhole\n+\n+  ins_pipe(pipe_class_call);\n+%}\n+\n+\n@@ -15974,0 +15998,2 @@\n+  predicate(!n->as_CallJava()->should_blackhole());\n+\n@@ -15986,0 +16012,18 @@\n+instruct CallDynamicJavaDirect_Blackhole(method meth)\n+%{\n+  match(CallDynamicJava);\n+\n+  predicate(n->as_CallJava()->should_blackhole());\n+\n+  effect(USE meth);\n+\n+  ins_cost(CALL_COST);\n+\n+  format %{ \"CALL,dynamic,blackhole $meth \\t\/\/ ==> \" %}\n+\n+  ins_encode(); \/\/ encode to nothing: blackhole\n+\n+  ins_pipe(pipe_class_call);\n+%}\n+\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -1044,0 +1044,5 @@\n+const bool Matcher::supports_blackholes() {\n+  \/\/ Not implemented yet.\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2203,0 +2203,5 @@\n+const bool Matcher::supports_blackholes() {\n+  \/\/ Not implemented yet.\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1591,0 +1591,5 @@\n+const bool Matcher::supports_blackholes() {\n+  \/\/ Not implemented yet.\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1902,0 +1902,3 @@\n+const bool Matcher::supports_blackholes() {\n+  return true;\n+}\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -12353,0 +12353,1 @@\n+  predicate(!n->as_CallJava()->should_blackhole());\n@@ -12363,0 +12364,11 @@\n+instruct CallStaticJavaDirect_Blackhole(method meth) %{\n+  match(CallStaticJava);\n+  predicate(n->as_CallJava()->should_blackhole());\n+  effect(USE meth);\n+\n+  ins_cost(1);\n+  format %{ \"call,static,blackhole \" %}\n+  ins_encode(); \/\/ Encode to nothing: blackhole.\n+  ins_pipe(empty);\n+%}\n+\n@@ -12369,0 +12381,1 @@\n+  predicate(!n->as_CallJava()->should_blackhole());\n@@ -12379,0 +12392,12 @@\n+instruct CallDynamicJavaDirect_Blackhole(method meth)\n+%{\n+  match(CallDynamicJava);\n+  predicate(n->as_CallJava()->should_blackhole());\n+  effect(USE meth);\n+\n+  ins_cost(300);\n+  format %{ \"call,dynamic,blackhole \" %}\n+  ins_encode(); \/\/ Encode to nothing: blackhole.\n+  ins_pipe(empty);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1056,0 +1056,1 @@\n+void Canonicalizer::do_Blackhole(Blackhole* x) {}\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -114,0 +114,1 @@\n+  virtual void do_Blackhole      (Blackhole* x);\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2029,0 +2029,11 @@\n+  \/\/ check if we need to blackhole the method\n+  if (target->is_loaded() && target->return_type()->basic_type() == T_VOID &&\n+      compilation()->directive()->should_blackhole(target)) {\n+    if (try_blackhole(target)) {\n+      print_inlining(target, \"blackhole\", \/*success*\/ true);\n+      return;\n+    } else {\n+      assert(false, \"Blackholing should always work\");\n+    }\n+  }\n+\n@@ -3455,0 +3466,11 @@\n+bool GraphBuilder::try_blackhole(ciMethod* callee) {\n+  Values* args = state()->pop_arguments(callee->arg_size());\n+\n+  \/\/ Blackhole everything except the receiver itself\n+  int start = callee->flags().is_static() ? 0 : 1;\n+  for (int c = start; c < args->length(); c++) {\n+    append(new Blackhole(args->at(c)));\n+  }\n+\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -357,0 +357,2 @@\n+  bool try_blackhole(ciMethod* callee);\n+\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1045,0 +1045,4 @@\n+\n+Blackhole::Blackhole(Value v) : Instruction(illegalType), _v(v) {\n+  pin();\n+}\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -112,0 +112,1 @@\n+class   Blackhole;\n@@ -211,0 +212,1 @@\n+  virtual void do_Blackhole      (Blackhole*       x) = 0;\n@@ -2612,0 +2614,15 @@\n+LEAF(Blackhole, Instruction)\n+private:\n+  Value       _v;\n+\n+public:\n+  \/\/ creation\n+  Blackhole(Value v);\n+\n+  \/\/ accessors\n+  Value v() { return _v; }\n+\n+  \/\/ generic\n+  virtual void input_values_do(ValueVisitor* f)  { f->visit(&_v); }\n+};\n+\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -864,0 +864,9 @@\n+void InstructionPrinter::do_Blackhole(Blackhole* x) {\n+  if (x->v() != NULL) {\n+    output()->print(\"blackhole \");\n+    print_value(x->v());\n+  } else {\n+    output()->print(\"incorrect blackhole\");\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/c1\/c1_InstructionPrinter.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -138,0 +138,1 @@\n+  virtual void do_Blackhole      (Blackhole* x);\n","filename":"src\/hotspot\/share\/c1\/c1_InstructionPrinter.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3628,0 +3628,6 @@\n+void LIRGenerator::do_Blackhole(Blackhole *x) {\n+  \/\/ Load the argument\n+  LIRItem vitem(x->v(), this);\n+  vitem.load_item();\n+  \/\/ ...and leave it unused.\n+}\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -599,0 +599,1 @@\n+  virtual void do_Blackhole      (Blackhole* x);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -544,0 +544,1 @@\n+  void do_Blackhole      (Blackhole* x);\n@@ -731,0 +732,1 @@\n+void NullCheckVisitor::do_Blackhole      (Blackhole* x) {}\n","filename":"src\/hotspot\/share\/c1\/c1_Optimizer.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -176,0 +176,1 @@\n+    void do_Blackhole      (Blackhole* x)       { \/* nothing to do *\/ };\n","filename":"src\/hotspot\/share\/c1\/c1_RangeCheckElimination.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -212,0 +212,3 @@\n+  void do_Blackhole      (Blackhole* x) {\n+    kill_memory();\n+  };\n","filename":"src\/hotspot\/share\/c1\/c1_ValueMap.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -459,0 +459,11 @@\n+bool DirectiveSet::should_blackhole(ciMethod* m) {\n+  m->check_is_loaded();\n+  VM_ENTRY_MARK;\n+  methodHandle mh(THREAD, m->get_Method());\n+\n+  if (!CompilerDirectivesIgnoreCompileCommandsOption) {\n+    return CompilerOracle::should_blackhole(mh);\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -116,0 +116,1 @@\n+  bool should_blackhole(ciMethod* m);\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+  BlackholeCommand,\n@@ -101,0 +102,1 @@\n+  \"blackhole\",\n@@ -357,1 +359,3 @@\n-  return check_predicate(DontInlineCommand, method) || check_predicate(ExcludeCommand, method);\n+  return check_predicate(DontInlineCommand, method)\n+    || check_predicate(ExcludeCommand, method)\n+    || check_predicate(BlackholeCommand, method);\n@@ -378,0 +382,4 @@\n+bool CompilerOracle::should_blackhole(const methodHandle& method) {\n+  return (check_predicate(BlackholeCommand, method));\n+}\n+\n@@ -407,0 +415,1 @@\n+  tty->print_cr(\"  blackhole,<pattern>   - eliminate the call and blackhole all arguments\");\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -69,0 +69,3 @@\n+  \/\/ Tells whether to blackhole when compiling method\n+  static bool should_blackhole(const methodHandle& method);\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1026,0 +1026,30 @@\n+Node* CallJavaNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+  Node* node = CallNode::Ideal(phase, can_reshape);\n+  if (node != NULL) {\n+    return node;\n+  }\n+\n+  if (can_reshape && should_blackhole()) {\n+    \/\/ Purge debug info for blackholed method\n+    bool progress = false;\n+    Node* top = Compile::current()->top();\n+    uint dbg_start = tf()->domain()->cnt();\n+    for (uint i = dbg_start; i < req(); i++) {\n+      if (in(i) != top) {\n+        set_req(i, top);\n+        progress = true;\n+      }\n+    }\n+    return progress ? this : NULL;\n+  }\n+\n+  return NULL;\n+}\n+\n+bool CallJavaNode::should_blackhole() const {\n+  return Matcher::supports_blackholes() &&\n+         method() != NULL && method()->is_loaded() &&\n+         method()->return_type()->basic_type() == T_VOID &&\n+         Compile::current()->directive()->should_blackhole(method());\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -696,0 +696,2 @@\n+  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n+\n@@ -698,0 +700,6 @@\n+  bool should_blackhole() const;\n+\n+  \/\/ Safepoint is guaranteed only if method is not blackholed. Otherwise,\n+  \/\/ there is no safepoint in the method body.\n+  virtual bool guaranteed_safepoint()      { return !should_blackhole(); }\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -890,1 +890,3 @@\n-  add_call_kills(proj, regs, save_policy, exclude_soe);\n+  if (mcall->isa_MachCallJava() == NULL || !mcall->as_MachCallJava()->is_blackhole()) {\n+    add_call_kills(proj, regs, save_policy, exclude_soe);\n+  }\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -735,0 +735,2 @@\n+  if (_blackhole)\n+    st->print(\"blackhole \");\n@@ -745,0 +747,6 @@\n+  \/\/ Fake the incoming arguments mask for blackholes: accept all registers and all stack slots.\n+  \/\/ This must avoid moving the arguments for the call that never happens.\n+  if (is_blackhole()) {\n+    return RegMask::All;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -926,0 +926,2 @@\n+  bool      _blackhole;              \/\/ Tells if the call has to be blackholed\n+\n@@ -930,0 +932,3 @@\n+  void set_blackhole(bool b)      { _blackhole = b; }\n+  bool is_blackhole() const       { return _blackhole; }\n+\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1264,0 +1264,2 @@\n+\n+      mcall_java->set_blackhole(call_java->should_blackhole());\n@@ -1374,1 +1376,1 @@\n-  if (mcall) {\n+  if (mcall && !(mcall->is_MachCallJava() && mcall->as_MachCallJava()->is_blackhole())) {\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -354,0 +354,2 @@\n+  static const bool supports_blackholes();\n+\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,0 +54,7 @@\n+const RegMask RegMask::All(\n+# define BODY(I) -1,\n+  FORALL_BODY\n+# undef BODY\n+  0\n+);\n+\n","filename":"src\/hotspot\/share\/opto\/regmask.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -351,0 +351,1 @@\n+  static const RegMask All;     \/\/ Common all mask\n","filename":"src\/hotspot\/share\/opto\/regmask.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,236 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ *\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceReturnTest\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceReturnTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires vm.bits == \"64\"\n+ *\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceReturnTest\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceReturnTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+import sun.hotspot.WhiteBox;\n+\n+public class BlackholeInstanceReturnTest {\n+\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    public static void main(String[] args) {\n+        \/\/ Warmup\/resolve methods\n+        BlackholeTarget.clear();\n+        test_boolean();\n+\n+        BlackholeTarget.clear();\n+        test_byte();\n+\n+        BlackholeTarget.clear();\n+        test_char();\n+\n+        BlackholeTarget.clear();\n+        test_short();\n+\n+        BlackholeTarget.clear();\n+        test_int();\n+\n+        BlackholeTarget.clear();\n+        test_float();\n+\n+        BlackholeTarget.clear();\n+        test_long();\n+\n+        BlackholeTarget.clear();\n+        test_double();\n+\n+        BlackholeTarget.clear();\n+        test_Object();\n+\n+        \/\/ Now that all tests are guaranteed to be linked, recompile.\n+        \/\/ Then seee if targets are still entered, despite the compiler commands.\n+\n+        WB.deoptimizeAll();\n+\n+        BlackholeTarget.clear();\n+        test_boolean();\n+        BlackholeTarget.shouldBeEntered();\n+\n+        BlackholeTarget.clear();\n+        test_byte();\n+        BlackholeTarget.shouldBeEntered();\n+\n+        BlackholeTarget.clear();\n+        test_char();\n+        BlackholeTarget.shouldBeEntered();\n+\n+        BlackholeTarget.clear();\n+        test_short();\n+        BlackholeTarget.shouldBeEntered();\n+\n+        BlackholeTarget.clear();\n+        test_int();\n+        BlackholeTarget.shouldBeEntered();\n+\n+        BlackholeTarget.clear();\n+        test_float();\n+        BlackholeTarget.shouldBeEntered();\n+\n+        BlackholeTarget.clear();\n+        test_long();\n+        BlackholeTarget.shouldBeEntered();\n+\n+        BlackholeTarget.clear();\n+        test_double();\n+        BlackholeTarget.shouldBeEntered();\n+\n+        BlackholeTarget.clear();\n+        test_Object();\n+        BlackholeTarget.shouldBeEntered();\n+    }\n+\n+    private static void test_boolean() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < 1_000_000; c++) {\n+            if (t.bh_ir_boolean((c & 0x1) == 0) != false) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_byte() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < 1_000_000; c++) {\n+            if (t.bh_ir_byte((byte)c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_char() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < 1_000_000; c++) {\n+            if (t.bh_ir_char((char)c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_short() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < 1_000_000; c++) {\n+            if (t.bh_ir_short((short)c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_int() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < 1_000_000; c++) {\n+            if (t.bh_ir_int(c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_float() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < 1_000_000; c++) {\n+            if (t.bh_ir_float(c) != 0F) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_long() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < 1_000_000; c++) {\n+            if (t.bh_ir_long(c) != 0L) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_double() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < 1_000_000; c++) {\n+            if (t.bh_ir_double(c) != 0D) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_Object() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < 1_000_000; c++) {\n+            if (t.bh_ir_Object(Integer.valueOf(c)) != null) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeInstanceReturnTest.java","additions":236,"deletions":0,"binary":false,"changes":236,"status":"added"},{"patch":"@@ -0,0 +1,207 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ *\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceSingleArgTest\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceSingleArgTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires vm.bits == \"64\"\n+ *\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceSingleArgTest\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceSingleArgTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+import sun.hotspot.WhiteBox;\n+\n+public class BlackholeInstanceSingleArgTest {\n+\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    public static void main(String[] args) {\n+        \/\/ Warmup\/resolve methods\n+        BlackholeTarget.clear();\n+        test_boolean();\n+\n+        BlackholeTarget.clear();\n+        test_byte();\n+\n+        BlackholeTarget.clear();\n+        test_char();\n+\n+        BlackholeTarget.clear();\n+        test_short();\n+\n+        BlackholeTarget.clear();\n+        test_int();\n+\n+        BlackholeTarget.clear();\n+        test_float();\n+\n+        BlackholeTarget.clear();\n+        test_long();\n+\n+        BlackholeTarget.clear();\n+        test_double();\n+\n+        BlackholeTarget.clear();\n+        test_Object();\n+\n+        \/\/ Now that all tests are guaranteed to be linked, recompile.\n+        \/\/ Then make sure targets can still be called.\n+\n+        WB.deoptimizeAll();\n+\n+        BlackholeTarget.clear();\n+        test_boolean();\n+\n+        BlackholeTarget.clear();\n+        test_byte();\n+\n+        BlackholeTarget.clear();\n+        test_char();\n+\n+        BlackholeTarget.clear();\n+        test_short();\n+\n+        BlackholeTarget.clear();\n+        test_int();\n+\n+        BlackholeTarget.clear();\n+        test_float();\n+\n+        BlackholeTarget.clear();\n+        test_long();\n+\n+        BlackholeTarget.clear();\n+        test_double();\n+\n+        BlackholeTarget.clear();\n+        test_Object();\n+    }\n+\n+    private static void test_boolean() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < 1_000_000; c++) {\n+            t.bh_i_boolean((c & 0x1) == 0);\n+        }\n+    }\n+\n+    private static void test_byte() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < 1_000_000; c++) {\n+            t.bh_i_byte((byte)c);\n+        }\n+    }\n+\n+    private static void test_char() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < 1_000_000; c++) {\n+            t.bh_i_char((char)c);\n+        }\n+    }\n+\n+    private static void test_short() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < 1_000_000; c++) {\n+            t.bh_i_short((short)c);\n+        }\n+    }\n+\n+    private static void test_int() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < 1_000_000; c++) {\n+            t.bh_i_int(c);\n+        }\n+    }\n+\n+    private static void test_float() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < 1_000_000; c++) {\n+            t.bh_i_float(c);\n+        }\n+    }\n+\n+    private static void test_long() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < 1_000_000; c++) {\n+            t.bh_i_long(c);\n+        }\n+    }\n+\n+    private static void test_double() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < 1_000_000; c++) {\n+            t.bh_i_double(c);\n+        }\n+    }\n+\n+    private static void test_Object() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < 1_000_000; c++) {\n+            t.bh_i_Object(Integer.valueOf(c));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeInstanceSingleArgTest.java","additions":207,"deletions":0,"binary":false,"changes":207,"status":"added"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:TieredStopAtLevel=1 -Xcomp -Xbatch -XX:-UseOnStackReplacement\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeRemovalTest\n+ *\/\n+\n+\/*\n+ * @ignore \/\/ C2 does not blackhole consistently yet\n+ * @test\n+ *\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:-TieredCompilation -Xcomp -Xbatch -XX:-UseOnStackReplacement\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeRemovalTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires vm.bits == \"64\"\n+ *\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:TieredStopAtLevel=1 -Xcomp -Xbatch -XX:-UseOnStackReplacement\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeRemovalTest\n+ *\n+\n+\/*\n+ * @ignore \/\/ C2 does not blackhole consistently yet\n+ * @test\n+ * @requires vm.bits == \"64\"\n+ *\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:-TieredCompilation -Xcomp -Xbatch -XX:-UseOnStackReplacement\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeRemovalTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+import sun.hotspot.WhiteBox;\n+\n+public class BlackholeRemovalTest {\n+\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    public static void main(String[] args) {\n+        \/\/ Warmup\/resolve methods\n+        BlackholeTarget.clear();\n+        test_boolean();\n+\n+        BlackholeTarget.clear();\n+        test_byte();\n+\n+        BlackholeTarget.clear();\n+        test_char();\n+\n+        BlackholeTarget.clear();\n+        test_short();\n+\n+        BlackholeTarget.clear();\n+        test_int();\n+\n+        BlackholeTarget.clear();\n+        test_float();\n+\n+        BlackholeTarget.clear();\n+        test_long();\n+\n+        BlackholeTarget.clear();\n+        test_double();\n+\n+        BlackholeTarget.clear();\n+        test_Object();\n+\n+        \/\/ Now that all tests are guaranteed to be linked,\n+        \/\/ recompile and see if targets crashing the VM are removed.\n+        BlackholeTarget.clear();\n+        WB.deoptimizeAll();\n+\n+        test_boolean();\n+        BlackholeTarget.shouldNotBeEntered();\n+\n+        test_byte();\n+        BlackholeTarget.shouldNotBeEntered();\n+\n+        test_char();\n+        BlackholeTarget.shouldNotBeEntered();\n+\n+        test_short();\n+        BlackholeTarget.shouldNotBeEntered();\n+\n+        test_int();\n+        BlackholeTarget.shouldNotBeEntered();\n+\n+        test_float();\n+        BlackholeTarget.shouldNotBeEntered();\n+\n+        test_long();\n+        BlackholeTarget.shouldNotBeEntered();\n+\n+        test_double();\n+        BlackholeTarget.shouldNotBeEntered();\n+\n+        test_Object();\n+        BlackholeTarget.shouldNotBeEntered();\n+    }\n+\n+    private static void test_boolean() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            BlackholeTarget.bh_s_boolean((c & 0x1) == 0);\n+        }\n+    }\n+\n+    private static void test_byte() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            BlackholeTarget.bh_s_byte((byte)c);\n+        }\n+    }\n+\n+    private static void test_char() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            BlackholeTarget.bh_s_char((char)c);\n+        }\n+    }\n+\n+    private static void test_short() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            BlackholeTarget.bh_s_short((short)c);\n+        }\n+    }\n+\n+    private static void test_int() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            BlackholeTarget.bh_s_int(c);\n+        }\n+    }\n+\n+    private static void test_float() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            BlackholeTarget.bh_s_float(c);\n+        }\n+    }\n+\n+    private static void test_long() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            BlackholeTarget.bh_s_long(c);\n+        }\n+    }\n+\n+    private static void test_double() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            BlackholeTarget.bh_s_double(c);\n+        }\n+    }\n+\n+    private static void test_Object() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            BlackholeTarget.bh_s_Object(Integer.valueOf(c));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeRemovalTest.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -0,0 +1,226 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ *\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticReturnTest\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticReturnTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires vm.bits == \"64\"\n+ *\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticReturnTest\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticReturnTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+import sun.hotspot.WhiteBox;\n+\n+public class BlackholeStaticReturnTest {\n+\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    public static void main(String[] args) {\n+        \/\/ Warmup\/resolve methods\n+        BlackholeTarget.clear();\n+        test_boolean();\n+\n+        BlackholeTarget.clear();\n+        test_byte();\n+\n+        BlackholeTarget.clear();\n+        test_char();\n+\n+        BlackholeTarget.clear();\n+        test_short();\n+\n+        BlackholeTarget.clear();\n+        test_int();\n+\n+        BlackholeTarget.clear();\n+        test_float();\n+\n+        BlackholeTarget.clear();\n+        test_long();\n+\n+        BlackholeTarget.clear();\n+        test_double();\n+\n+        BlackholeTarget.clear();\n+        test_Object();\n+\n+        \/\/ Now that all tests are guaranteed to be linked, recompile.\n+        \/\/ Then see if targets are still entered, despite the compiler commands.\n+\n+        WB.deoptimizeAll();\n+\n+        BlackholeTarget.clear();\n+        test_boolean();\n+        BlackholeTarget.shouldBeEntered();\n+\n+        BlackholeTarget.clear();\n+        test_byte();\n+        BlackholeTarget.shouldBeEntered();\n+\n+        BlackholeTarget.clear();\n+        test_char();\n+        BlackholeTarget.shouldBeEntered();\n+\n+        BlackholeTarget.clear();\n+        test_short();\n+        BlackholeTarget.shouldBeEntered();\n+\n+        BlackholeTarget.clear();\n+        test_int();\n+        BlackholeTarget.shouldBeEntered();\n+\n+        BlackholeTarget.clear();\n+        test_float();\n+        BlackholeTarget.shouldBeEntered();\n+\n+        BlackholeTarget.clear();\n+        test_long();\n+        BlackholeTarget.shouldBeEntered();\n+\n+        BlackholeTarget.clear();\n+        test_double();\n+        BlackholeTarget.shouldBeEntered();\n+\n+        BlackholeTarget.clear();\n+        test_Object();\n+        BlackholeTarget.shouldBeEntered();\n+    }\n+\n+    private static void test_boolean() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            if (BlackholeTarget.bh_sr_boolean((c & 0x1) == 0) != false) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_byte() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            if (BlackholeTarget.bh_sr_byte((byte)c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_char() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            if (BlackholeTarget.bh_sr_char((char)c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_short() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            if (BlackholeTarget.bh_sr_short((short)c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_int() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            if (BlackholeTarget.bh_sr_int(c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_float() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            if (BlackholeTarget.bh_sr_float(c) != 0F) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_long() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            if (BlackholeTarget.bh_sr_long(c) != 0L) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_double() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            if (BlackholeTarget.bh_sr_double(c) != 0D) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_Object() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            if (BlackholeTarget.bh_sr_Object(Integer.valueOf(c)) != null) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeStaticReturnTest.java","additions":226,"deletions":0,"binary":false,"changes":226,"status":"added"},{"patch":"@@ -0,0 +1,198 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ *\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticSingleArgTest\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticSingleArgTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires vm.bits == \"64\"\n+ *\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticSingleArgTest\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticSingleArgTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+import sun.hotspot.WhiteBox;\n+\n+public class BlackholeStaticSingleArgTest {\n+\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    public static void main(String[] args) {\n+        \/\/ Warmup\/resolve methods\n+        BlackholeTarget.clear();\n+        test_boolean();\n+\n+        BlackholeTarget.clear();\n+        test_byte();\n+\n+        BlackholeTarget.clear();\n+        test_char();\n+\n+        BlackholeTarget.clear();\n+        test_short();\n+\n+        BlackholeTarget.clear();\n+        test_int();\n+\n+        BlackholeTarget.clear();\n+        test_float();\n+\n+        BlackholeTarget.clear();\n+        test_long();\n+\n+        BlackholeTarget.clear();\n+        test_double();\n+\n+        BlackholeTarget.clear();\n+        test_Object();\n+\n+        \/\/ Now that all tests are guaranteed to be linked, recompile.\n+        \/\/ Then make sure targets can still be called.\n+\n+        WB.deoptimizeAll();\n+\n+        BlackholeTarget.clear();\n+        test_boolean();\n+\n+        BlackholeTarget.clear();\n+        test_byte();\n+\n+        BlackholeTarget.clear();\n+        test_char();\n+\n+        BlackholeTarget.clear();\n+        test_short();\n+\n+        BlackholeTarget.clear();\n+        test_int();\n+\n+        BlackholeTarget.clear();\n+        test_float();\n+\n+        BlackholeTarget.clear();\n+        test_long();\n+\n+        BlackholeTarget.clear();\n+        test_double();\n+\n+        BlackholeTarget.clear();\n+        test_Object();\n+    }\n+\n+    private static void test_boolean() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            BlackholeTarget.bh_s_boolean((c & 0x1) == 0);\n+        }\n+    }\n+\n+    private static void test_byte() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            BlackholeTarget.bh_s_byte((byte)c);\n+        }\n+    }\n+\n+    private static void test_char() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            BlackholeTarget.bh_s_char((char)c);\n+        }\n+    }\n+\n+    private static void test_short() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            BlackholeTarget.bh_s_short((short)c);\n+        }\n+    }\n+\n+    private static void test_int() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            BlackholeTarget.bh_s_int(c);\n+        }\n+    }\n+\n+    private static void test_float() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            BlackholeTarget.bh_s_float(c);\n+        }\n+    }\n+\n+    private static void test_long() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            BlackholeTarget.bh_s_long(c);\n+        }\n+    }\n+\n+    private static void test_double() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            BlackholeTarget.bh_s_double(c);\n+        }\n+    }\n+\n+    private static void test_Object() {\n+        for (int c = 0; c < 1_000_000; c++) {\n+            BlackholeTarget.bh_s_Object(Integer.valueOf(c));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeStaticSingleArgTest.java","additions":198,"deletions":0,"binary":false,"changes":198,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.blackhole;\n+\n+import java.lang.reflect.*;\n+\n+public class BlackholeTarget {\n+    private static String entered;\n+\n+    private static void registerEntered(String label) {\n+        if (entered == null) {\n+           entered = label;\n+        } else if (!entered.equals(label)) {\n+           throw new IllegalStateException(\"Trying to register enter with overwrite: \" + entered + \" -> \" + label);\n+        }\n+    }\n+\n+    public static void clear() {\n+        entered = null;\n+    }\n+\n+    public static void shouldBeEntered() {\n+        if (entered == null) {\n+            throw new IllegalStateException(\"Should have been entered\");\n+        }\n+    }\n+\n+    public static void shouldNotBeEntered() {\n+        if (entered != null) {\n+            throw new IllegalStateException(\"Should not have been entered: \" + entered);\n+        }\n+    }\n+\n+    public static void    bh_s_boolean(boolean v)  { registerEntered(\"bh_s_boolean\"); }\n+    public static void    bh_s_byte(byte v)        { registerEntered(\"bh_s_byte\");    }\n+    public static void    bh_s_short(short v)      { registerEntered(\"bh_s_short\");   }\n+    public static void    bh_s_char(char v)        { registerEntered(\"bh_s_char\");    }\n+    public static void    bh_s_int(int v)          { registerEntered(\"bh_s_int\");     }\n+    public static void    bh_s_float(float v)      { registerEntered(\"bh_s_float\");   }\n+    public static void    bh_s_long(long v)        { registerEntered(\"bh_s_long\");    }\n+    public static void    bh_s_double(double v)    { registerEntered(\"bh_s_double\");  }\n+    public static void    bh_s_Object(Object v)    { registerEntered(\"bh_s_Object\");  }\n+\n+    public        void    bh_i_boolean(boolean v)  { registerEntered(\"bh_i_boolean\"); }\n+    public        void    bh_i_byte(byte v)        { registerEntered(\"bh_i_byte\");    }\n+    public        void    bh_i_short(short v)      { registerEntered(\"bh_i_short\");   }\n+    public        void    bh_i_char(char v)        { registerEntered(\"bh_i_char\");    }\n+    public        void    bh_i_int(int v)          { registerEntered(\"bh_i_int\");     }\n+    public        void    bh_i_float(float v)      { registerEntered(\"bh_i_float\");   }\n+    public        void    bh_i_long(long v)        { registerEntered(\"bh_i_long\");    }\n+    public        void    bh_i_double(double v)    { registerEntered(\"bh_i_double\");  }\n+    public        void    bh_i_Object(Object v)    { registerEntered(\"bh_i_Object\");  }\n+\n+    public static boolean bh_sr_boolean(boolean v) { registerEntered(\"bh_sr_boolean\"); return false; }\n+    public static byte    bh_sr_byte(byte v)       { registerEntered(\"bh_sr_byte\");    return 0;     }\n+    public static short   bh_sr_short(short v)     { registerEntered(\"bh_sr_short\");   return 0;     }\n+    public static char    bh_sr_char(char v)       { registerEntered(\"bh_sr_char\");    return 0;     }\n+    public static int     bh_sr_int(int v)         { registerEntered(\"bh_sr_int\");     return 0;     }\n+    public static float   bh_sr_float(float v)     { registerEntered(\"bh_sr_float\");   return 0;     }\n+    public static long    bh_sr_long(long v)       { registerEntered(\"bh_sr_long\");    return 0;     }\n+    public static double  bh_sr_double(double v)   { registerEntered(\"bh_sr_double\");  return 0;     }\n+    public static Object  bh_sr_Object(Object v)   { registerEntered(\"bh_sr_Object\");  return null;  }\n+\n+    public        boolean bh_ir_boolean(boolean v) { registerEntered(\"bh_ir_boolean\"); return false; }\n+    public        byte    bh_ir_byte(byte v)       { registerEntered(\"bh_ir_byte\");    return 0;     }\n+    public        short   bh_ir_short(short v)     { registerEntered(\"bh_ir_short\");   return 0;     }\n+    public        char    bh_ir_char(char v)       { registerEntered(\"bh_ir_char\");    return 0;     }\n+    public        int     bh_ir_int(int v)         { registerEntered(\"bh_ir_int\");     return 0;     }\n+    public        float   bh_ir_float(float v)     { registerEntered(\"bh_ir_float\");   return 0;     }\n+    public        long    bh_ir_long(long v)       { registerEntered(\"bh_ir_long\");    return 0;     }\n+    public        double  bh_ir_double(double v)   { registerEntered(\"bh_ir_double\");  return 0;     }\n+    public        Object  bh_ir_Object(Object v)   { registerEntered(\"bh_ir_Object\");  return null;  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeTarget.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"}]}