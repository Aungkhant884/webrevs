{"files":[{"patch":"@@ -15991,0 +15991,15 @@\n+instruct CallBlackholeDirect(method meth)\n+%{\n+  match(CallBlackhole);\n+\n+  effect(USE meth);\n+\n+  ins_cost(1);\n+\n+  format %{ \"call,blackhole \" %}\n+\n+  ins_encode(); \/\/ Encode to nothing\n+\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -8850,0 +8850,11 @@\n+\/\/ Call Blackhole\n+instruct CallBlackholeDirect( method meth ) %{\n+  match(CallBlackhole);\n+  effect(USE meth);\n+\n+  ins_cost(1);\n+  format %{ \"CALL,blackhole \" %}\n+  ins_encode(); \/\/ encode to nothing\n+  ins_pipe(empty);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -14390,0 +14390,10 @@\n+instruct CallBlackholeDirect(method meth) %{\n+  match(CallBlackhole);\n+  effect(USE meth);\n+  ins_cost(1);\n+\n+  format %{ \"CALL,blackhole $meth \\t\/\/ ==> \" %}\n+  ins_encode(); \/\/ Encode to nothing\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -9713,0 +9713,10 @@\n+\/\/ Call Java Dynamic Instruction\n+instruct CallBlackholeDirect(method meth) %{\n+  match(CallBlackhole);\n+  effect(USE meth);\n+  ins_cost(1);\n+  format %{ \"CALL,blackhole \" %}\n+  ins_encode(); \/\/ Encode to nothing\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -13222,0 +13222,11 @@\n+instruct CallBlackholeDirect(method meth)\n+%{\n+  match(CallBlackhole);\n+  effect(USE meth);\n+\n+  ins_cost(1);\n+  format %{ \"CALL,blackhole \" %}\n+  ins_encode(); \/\/ Encode to nothing\n+  ins_pipe(empty);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -12384,0 +12384,11 @@\n+instruct CallBlackholeDirect(method meth)\n+%{\n+  match(CallBlackhole);\n+  effect(USE meth);\n+\n+  ins_cost(1);\n+  format %{ \"call,blackhole \" %}\n+  ins_encode(); \/\/ Encode to nothing\n+  ins_pipe(empty);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -202,1 +202,2 @@\n-    JAVA_LEAF     =  7   \/\/ calling leaf\n+    JAVA_LEAF     =  7,  \/\/ calling leaf,\n+    JAVA_BLACKHOLE=  8   \/\/ blackholed method\n","filename":"src\/hotspot\/share\/adlc\/forms.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -416,0 +416,2 @@\n+  if(_matrule->find_type(\"CallBlackhole\",idx))    return Form::JAVA_BLACKHOLE;\n+  idx = 0;\n@@ -1131,0 +1133,3 @@\n+  else if( is_ideal_call() == Form::JAVA_BLACKHOLE ) {\n+    return \"MachCallBlackholeNode\";\n+  }\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3656,0 +3656,1 @@\n+  fprintf(fp_hpp, \"extern const char  no_reg_save_policy[];\\n\");\n@@ -3682,0 +3683,11 @@\n+\n+  \/\/ Construct No-Save-Policy array\n+  fprintf(fp_cpp, \"\/\/ Map from machine-independent register number to no_reg_save_policy\\n\");\n+  fprintf(fp_cpp, \"const        char no_reg_save_policy[] = {\\n\");\n+  _register->reset_RegDefs();\n+  for( rdef = _register->iter_RegDefs(); rdef != NULL; rdef = next ) {\n+    next        = _register->iter_RegDefs();\n+    const char *comma = (next != NULL) ? \",\" : \" \/\/ no trailing comma\";\n+    fprintf(fp_cpp, \"  '%c'%s \/\/ %s\\n\", 'N', comma, rdef->_regname);\n+  }\n+  fprintf(fp_cpp, \"};\\n\\n\");\n","filename":"src\/hotspot\/share\/adlc\/output_c.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -696,0 +696,3 @@\n+    case Form::JAVA_BLACKHOLE:\n+      \/\/ Nothing additional to print\n+      break;\n","filename":"src\/hotspot\/share\/adlc\/output_h.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1056,0 +1056,1 @@\n+void Canonicalizer::do_Blackhole(Blackhole* x) {}\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -114,0 +114,1 @@\n+  virtual void do_Blackhole      (Blackhole* x);\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2029,0 +2029,8 @@\n+  \/\/ check if we need to blackhole the method\n+  if (target->can_be_blackholed() &&\n+      compilation()->directive()->should_blackhole(target)) {\n+    blackhole(target);\n+    print_inlining(target, \"blackhole\", \/*success*\/ true);\n+    return;\n+  }\n+\n@@ -3455,0 +3463,9 @@\n+void GraphBuilder::blackhole(ciMethod* callee) {\n+  Values* args = state()->pop_arguments(callee->arg_size());\n+\n+  \/\/ Blackhole everything except the receiver itself\n+  int start = callee->flags().is_static() ? 0 : 1;\n+  for (int c = start; c < args->length(); c++) {\n+    append(new Blackhole(args->at(c)));\n+  }\n+}\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -357,0 +357,2 @@\n+  void blackhole(ciMethod* callee);\n+\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1045,0 +1045,4 @@\n+\n+Blackhole::Blackhole(Value v) : Instruction(illegalType), _v(v) {\n+  pin();\n+}\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -112,0 +112,1 @@\n+class   Blackhole;\n@@ -211,0 +212,1 @@\n+  virtual void do_Blackhole      (Blackhole*       x) = 0;\n@@ -2612,0 +2614,15 @@\n+LEAF(Blackhole, Instruction)\n+private:\n+  Value       _v;\n+\n+public:\n+  \/\/ creation\n+  Blackhole(Value v);\n+\n+  \/\/ accessors\n+  Value v() { return _v; }\n+\n+  \/\/ generic\n+  virtual void input_values_do(ValueVisitor* f)  { f->visit(&_v); }\n+};\n+\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -864,0 +864,5 @@\n+void InstructionPrinter::do_Blackhole(Blackhole* x) {\n+  output()->print(\"blackhole \");\n+  print_value(x->v());\n+}\n+\n","filename":"src\/hotspot\/share\/c1\/c1_InstructionPrinter.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -138,0 +138,1 @@\n+  virtual void do_Blackhole      (Blackhole* x);\n","filename":"src\/hotspot\/share\/c1\/c1_InstructionPrinter.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3628,0 +3628,6 @@\n+void LIRGenerator::do_Blackhole(Blackhole *x) {\n+  \/\/ Load the argument\n+  LIRItem vitem(x->v(), this);\n+  vitem.load_item();\n+  \/\/ ...and leave it unused.\n+}\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -599,0 +599,1 @@\n+  virtual void do_Blackhole      (Blackhole* x);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -544,0 +544,1 @@\n+  void do_Blackhole      (Blackhole* x);\n@@ -731,0 +732,1 @@\n+void NullCheckVisitor::do_Blackhole      (Blackhole* x) {}\n","filename":"src\/hotspot\/share\/c1\/c1_Optimizer.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -176,0 +176,1 @@\n+    void do_Blackhole      (Blackhole* x)       { \/* nothing to do *\/ };\n","filename":"src\/hotspot\/share\/c1\/c1_RangeCheckElimination.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -212,0 +212,3 @@\n+  void do_Blackhole      (Blackhole* x) {\n+    kill_memory();\n+  };\n","filename":"src\/hotspot\/share\/c1\/c1_ValueMap.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -158,0 +158,2 @@\n+\n+  _can_be_blackholed = _signature->return_type()->basic_type() == T_VOID;\n@@ -188,0 +190,2 @@\n+\n+  _can_be_blackholed = false;\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -94,0 +94,1 @@\n+  bool _can_be_blackholed;\n@@ -355,0 +356,2 @@\n+  bool can_be_blackholed() const { return _can_be_blackholed; }\n+\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -458,0 +458,11 @@\n+bool DirectiveSet::should_blackhole(ciMethod* m) {\n+  m->check_is_loaded();\n+  VM_ENTRY_MARK;\n+  methodHandle mh(THREAD, m->get_Method());\n+\n+  if (!CompilerDirectivesIgnoreCompileCommandsOption) {\n+    return CompilerOracle::should_blackhole(mh);\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -116,0 +116,1 @@\n+  bool should_blackhole(ciMethod* m);\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -414,0 +414,4 @@\n+bool CompilerOracle::should_blackhole(const methodHandle& method) {\n+  return (check_predicate(CompileCommand::Blackhole, method));\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+  option(Blackhole,  \"blackhole\", Bool) \\\n@@ -143,0 +144,3 @@\n+  \/\/ Tells whether to blackhole when compiling method\n+  static bool should_blackhole(const methodHandle& method);\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -115,0 +115,54 @@\n+\/\/---------------------------BlackholeCallGenerator------------------------------\n+\/\/ Internal class which handles blackhole calls.\n+class BlackholeCallGenerator : public CallGenerator {\n+private:\n+\n+public:\n+  BlackholeCallGenerator(ciMethod* method) : CallGenerator(method) {}\n+  virtual JVMState* generate(JVMState* jvms);\n+};\n+\n+JVMState* BlackholeCallGenerator::generate(JVMState* jvms) {\n+  GraphKit kit(jvms);\n+  kit.C->print_inlining_update(this);\n+  if (kit.C->log() != NULL) {\n+    kit.C->log()->elem(\"blackhole bci='%d'\", jvms->bci());\n+  }\n+\n+  CallBlackholeNode* call = new CallBlackholeNode(tf());\n+\n+  \/\/ Bind arguments\n+  uint nargs = method()->arg_size();\n+  for (uint i = 0; i < nargs; i++) {\n+    Node* arg = kit.argument(i);\n+    call->init_req(i + TypeFunc::Parms, arg);\n+  }\n+\n+  \/\/ Add the predefined inputs:\n+  call->init_req( TypeFunc::Control, kit.control() );\n+  call->init_req( TypeFunc::I_O    , kit.i_o() );\n+  call->init_req( TypeFunc::Memory , kit.reset_memory() );\n+  call->init_req( TypeFunc::FramePtr, kit.frameptr() );\n+  call->init_req( TypeFunc::ReturnAdr, kit.top() );\n+\n+  Node* xcall = kit.gvn().transform(call);\n+\n+  if (xcall != kit.top()) {\n+    assert(xcall == call, \"call identity is stable\");\n+    kit.set_control(kit.gvn().transform(new ProjNode(call, TypeFunc::Control)));\n+    kit.set_i_o(kit.gvn().transform(new ProjNode(call, TypeFunc::I_O, false)));\n+    kit.set_all_memory_call(xcall, false);\n+  } else {\n+    kit.set_control(kit.top());\n+  }\n+\n+  BasicType ret_type = method()->return_type()->basic_type();\n+  assert(ret_type == T_VOID, \"Must be void\");\n+  kit.push_node(ret_type, kit.top());\n+  return kit.transfer_exceptions_into_jvms();\n+}\n+\n+CallGenerator* CallGenerator::for_blackhole(ciMethod* m) {\n+  return new BlackholeCallGenerator(m);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":54,"deletions":0,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -181,0 +181,2 @@\n+\n+  static CallGenerator* for_blackhole(ciMethod* m);\n","filename":"src\/hotspot\/share\/opto\/callGenerator.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1121,0 +1121,13 @@\n+\/\/=============================================================================\n+uint CallBlackholeNode::size_of() const { return sizeof(*this); }\n+bool CallBlackholeNode::cmp( const Node &n ) const {\n+  CallBlackholeNode &call = (CallBlackholeNode&)n;\n+  return CallNode::cmp(call);\n+}\n+#ifndef PRODUCT\n+void CallBlackholeNode::dump_spec(outputStream *st) const {\n+  st->print(\"# Blackhole \");\n+  CallNode::dump_spec(st);\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+class     CallBlackholeNode;\n@@ -772,0 +773,21 @@\n+\/\/------------------------------CallBlackholeNode----------------------------\n+\/\/ Make a blackholed call. It would survive through the compiler and keep\n+\/\/ the effects on its argument, and would be finally emitted as nothing.\n+class CallBlackholeNode : public CallNode {\n+  virtual bool cmp( const Node &n ) const;\n+  virtual uint size_of() const; \/\/ Size is bigger\n+public:\n+  CallBlackholeNode( const TypeFunc *tf ) : CallNode(tf, NULL, TypePtr::BOTTOM) {\n+    init_class_id(Class_CallBlackhole);\n+  }\n+\n+  \/\/ If method is blackholed, there is no method body, and thus no\n+  \/\/ safepoint, and therefore safepoint is not guaranteed.\n+  virtual bool guaranteed_safepoint()      { return false; }\n+\n+  virtual int   Opcode() const;\n+#ifndef PRODUCT\n+  virtual void  dump_spec(outputStream *st) const;\n+#endif\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+macro(CallBlackhole)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2911,0 +2911,1 @@\n+  case Op_CallBlackhole:\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -114,0 +114,7 @@\n+  \/\/ Try blackholing a method\n+  if (callee->can_be_blackholed() &&\n+      Compile::current()->directive()->should_blackhole(callee) &&\n+      Matcher::match_rule_supported(Op_CallBlackhole)) {\n+    return CallGenerator::for_blackhole(callee);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -872,0 +872,4 @@\n+    case Op_CallBlackhole:\n+      \/\/ Calling blackhole, so no registers are touched, no need to save\n+      save_policy = _matcher._no_reg_save_policy;\n+      break;\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -809,0 +809,16 @@\n+const RegMask &MachCallBlackholeNode::in_RegMask(uint idx) const {\n+  \/\/ Fake the incoming arguments mask for blackholes: accept all registers and all stack slots.\n+  \/\/ This must avoid moving the arguments for the call that never happens.\n+  return RegMask::All;\n+}\n+int MachCallBlackholeNode::ret_addr_offset() {\n+  \/\/ No address, might as as well return the neutral value.\n+  return 0;\n+}\n+#ifndef PRODUCT\n+void MachCallBlackholeNode::dump_spec(outputStream *st) const {\n+  st->print(\"Blackhole \");\n+  MachCallNode::dump_spec(st);\n+}\n+#endif\n+\/\/=============================================================================\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+class MachCallBlackholeNode;\n@@ -990,0 +991,14 @@\n+\/\/------------------------------MachCallBlackholeNode------------------------\n+\/\/ Machine-specific versions of blackholed call\n+class MachCallBlackholeNode : public MachCallNode {\n+public:\n+  MachCallBlackholeNode() : MachCallNode() {\n+    init_class_id(Class_MachCallBlackhole);\n+  }\n+  virtual const RegMask &in_RegMask(uint) const;\n+  virtual int ret_addr_offset();\n+#ifndef PRODUCT\n+  virtual void dump_spec(outputStream *st) const;\n+#endif\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+  _no_reg_save_policy(no_reg_save_policy),\n@@ -1314,0 +1315,2 @@\n+  if( call != NULL && call->is_CallBlackhole() )\n+    out_arg_limit_per_call = _new_SP; \/\/ Blackhole does not have outs, roll back.\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -219,0 +219,1 @@\n+  const char *_no_reg_save_policy;\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+class CallBlackholeNode;\n@@ -105,0 +106,1 @@\n+class MachCallBlackholeNode;\n@@ -643,0 +645,1 @@\n+          DEFINE_CLASS_ID(CallBlackhole,    Call, 6)\n@@ -669,0 +672,1 @@\n+            DEFINE_CLASS_ID(MachCallBlackhole,    MachCall, 3)\n@@ -839,0 +843,1 @@\n+  DEFINE_CLASS_QUERY(CallBlackhole)\n@@ -879,0 +884,1 @@\n+  DEFINE_CLASS_QUERY(MachCallBlackhole)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -54,0 +54,7 @@\n+const RegMask RegMask::All(\n+# define BODY(I) -1,\n+  FORALL_BODY\n+# undef BODY\n+  0\n+);\n+\n","filename":"src\/hotspot\/share\/opto\/regmask.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -359,0 +359,1 @@\n+  static const RegMask All;     \/\/ Common all mask\n","filename":"src\/hotspot\/share\/opto\/regmask.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1523,0 +1523,1 @@\n+  declare_c2_type(CallBlackholeNode, CallNode)                            \\\n@@ -1641,0 +1642,1 @@\n+  declare_c2_type(MachCallBlackholeNode, MachCallNode)                    \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ *\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceReturnTest\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceReturnTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires vm.bits == \"64\"\n+ *\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceReturnTest\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceReturnTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+public class BlackholeInstanceReturnTest {\n+\n+    public static void main(String[] args) {\n+        runTries(BlackholeInstanceReturnTest::test_boolean);\n+        runTries(BlackholeInstanceReturnTest::test_byte);\n+        runTries(BlackholeInstanceReturnTest::test_char);\n+        runTries(BlackholeInstanceReturnTest::test_short);\n+        runTries(BlackholeInstanceReturnTest::test_int);\n+        runTries(BlackholeInstanceReturnTest::test_float);\n+        runTries(BlackholeInstanceReturnTest::test_long);\n+        runTries(BlackholeInstanceReturnTest::test_double);\n+        runTries(BlackholeInstanceReturnTest::test_Object);\n+    }\n+\n+    private static final int CYCLES = 1_000_000;\n+    private static final int TRIES = 10;\n+\n+    public static void runTries(Runnable r) {\n+        for (int t = 0; t < TRIES; t++) {\n+            BlackholeTarget.clear();\n+            r.run();\n+            BlackholeTarget.shouldBeEntered();\n+        }\n+    }\n+\n+    private static void test_boolean() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (t.bh_ir_boolean((c & 0x1) == 0) != false) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_byte() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (t.bh_ir_byte((byte)c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_char() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (t.bh_ir_char((char)c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_short() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (t.bh_ir_short((short)c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_int() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (t.bh_ir_int(c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_float() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (t.bh_ir_float(c) != 0F) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_long() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (t.bh_ir_long(c) != 0L) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_double() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (t.bh_ir_double(c) != 0D) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_Object() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            Object o = new Object();\n+            if (t.bh_ir_Object(o) != null) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeInstanceReturnTest.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ *\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceSingleArgTest\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceSingleArgTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires vm.bits == \"64\"\n+ *\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceSingleArgTest\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeInstanceSingleArgTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+public class BlackholeInstanceSingleArgTest {\n+\n+    public static void main(String[] args) {\n+        runTries(BlackholeInstanceSingleArgTest::test_boolean);\n+        runTries(BlackholeInstanceSingleArgTest::test_byte);\n+        runTries(BlackholeInstanceSingleArgTest::test_char);\n+        runTries(BlackholeInstanceSingleArgTest::test_short);\n+        runTries(BlackholeInstanceSingleArgTest::test_int);\n+        runTries(BlackholeInstanceSingleArgTest::test_float);\n+        runTries(BlackholeInstanceSingleArgTest::test_long);\n+        runTries(BlackholeInstanceSingleArgTest::test_double);\n+        runTries(BlackholeInstanceSingleArgTest::test_Object);\n+    }\n+\n+    private static final int CYCLES = 1_000_000;\n+    private static final int TRIES = 10;\n+\n+    public static void runTries(Runnable r) {\n+        for (int t = 0; t < TRIES; t++) {\n+            BlackholeTarget.clear();\n+            r.run();\n+            if (t == TRIES - 1) {\n+               BlackholeTarget.shouldNotBeEntered();\n+            }\n+        }\n+    }\n+\n+    private static void test_boolean() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_boolean((c & 0x1) == 0);\n+        }\n+    }\n+\n+    private static void test_byte() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_byte((byte)c);\n+        }\n+    }\n+\n+    private static void test_char() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_char((char)c);\n+        }\n+    }\n+\n+    private static void test_short() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_short((short)c);\n+        }\n+    }\n+\n+    private static void test_int() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_int(c);\n+        }\n+    }\n+\n+    private static void test_float() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_float(c);\n+        }\n+    }\n+\n+    private static void test_long() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_long(c);\n+        }\n+    }\n+\n+    private static void test_double() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_double(c);\n+        }\n+    }\n+\n+    private static void test_Object() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            Object o = new Object();\n+            t.bh_i_Object(o);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeInstanceSingleArgTest.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -0,0 +1,165 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ *\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticReturnTest\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticReturnTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires vm.bits == \"64\"\n+ *\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticReturnTest\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticReturnTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+public class BlackholeStaticReturnTest {\n+\n+    public static void main(String[] args) {\n+        runTries(BlackholeStaticReturnTest::test_boolean);\n+        runTries(BlackholeStaticReturnTest::test_byte);\n+        runTries(BlackholeStaticReturnTest::test_char);\n+        runTries(BlackholeStaticReturnTest::test_short);\n+        runTries(BlackholeStaticReturnTest::test_int);\n+        runTries(BlackholeStaticReturnTest::test_float);\n+        runTries(BlackholeStaticReturnTest::test_long);\n+        runTries(BlackholeStaticReturnTest::test_double);\n+        runTries(BlackholeStaticReturnTest::test_Object);\n+    }\n+\n+    private static final int CYCLES = 1_000_000;\n+    private static final int TRIES = 10;\n+\n+    public static void runTries(Runnable r) {\n+        for (int t = 0; t < TRIES; t++) {\n+            BlackholeTarget.clear();\n+            r.run();\n+            BlackholeTarget.shouldBeEntered();\n+        }\n+    }\n+\n+    private static void test_boolean() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (BlackholeTarget.bh_sr_boolean((c & 0x1) == 0) != false) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_byte() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (BlackholeTarget.bh_sr_byte((byte)c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_char() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (BlackholeTarget.bh_sr_char((char)c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_short() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (BlackholeTarget.bh_sr_short((short)c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_int() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (BlackholeTarget.bh_sr_int(c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_float() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (BlackholeTarget.bh_sr_float(c) != 0F) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_long() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (BlackholeTarget.bh_sr_long(c) != 0L) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_double() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (BlackholeTarget.bh_sr_double(c) != 0D) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+    private static void test_Object() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            Object o = new Object();\n+            if (BlackholeTarget.bh_sr_Object(o) != null) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeStaticReturnTest.java","additions":165,"deletions":0,"binary":false,"changes":165,"status":"added"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ *\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticSingleArgTest\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticSingleArgTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires vm.bits == \"64\"\n+ *\n+ * @build compiler.blackhole.BlackholeTarget\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:TieredStopAtLevel=1\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticSingleArgTest\n+ *\n+ * @run main\/othervm\n+ *      -Xmx1g -XX:-UseCompressedOops\n+ *      -XX:-TieredCompilation\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n+ *      compiler.blackhole.BlackholeStaticSingleArgTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+public class BlackholeStaticSingleArgTest {\n+\n+    public static void main(String[] args) {\n+        runTries(BlackholeStaticSingleArgTest::test_boolean);\n+        runTries(BlackholeStaticSingleArgTest::test_byte);\n+        runTries(BlackholeStaticSingleArgTest::test_char);\n+        runTries(BlackholeStaticSingleArgTest::test_short);\n+        runTries(BlackholeStaticSingleArgTest::test_int);\n+        runTries(BlackholeStaticSingleArgTest::test_float);\n+        runTries(BlackholeStaticSingleArgTest::test_long);\n+        runTries(BlackholeStaticSingleArgTest::test_double);\n+        runTries(BlackholeStaticSingleArgTest::test_Object);\n+    }\n+\n+    private static final int CYCLES = 1_000_000;\n+    private static final int TRIES = 10;\n+\n+    public static void runTries(Runnable r) {\n+        for (int t = 0; t < TRIES; t++) {\n+            BlackholeTarget.clear();\n+            r.run();\n+            if (t == TRIES - 1) {\n+               BlackholeTarget.shouldNotBeEntered();\n+            }\n+        }\n+    }\n+\n+    private static void test_boolean() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_boolean((c & 0x1) == 0);\n+        }\n+    }\n+\n+    private static void test_byte() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_byte((byte)c);\n+        }\n+    }\n+\n+    private static void test_char() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_char((char)c);\n+        }\n+    }\n+\n+    private static void test_short() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_short((short)c);\n+        }\n+    }\n+\n+    private static void test_int() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_int(c);\n+        }\n+    }\n+\n+    private static void test_float() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_float(c);\n+        }\n+    }\n+\n+    private static void test_long() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_long(c);\n+        }\n+    }\n+\n+    private static void test_double() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_double(c);\n+        }\n+    }\n+\n+    private static void test_Object() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            Object o = new Object();\n+            BlackholeTarget.bh_s_Object(o);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeStaticSingleArgTest.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.blackhole;\n+\n+import java.lang.reflect.*;\n+\n+public class BlackholeTarget {\n+    private static String entered;\n+\n+    private static void registerEntered(String label) {\n+        if (entered == null) {\n+           entered = label;\n+        } else if (!entered.equals(label)) {\n+           throw new IllegalStateException(\"Trying to register enter with overwrite: \" + entered + \" -> \" + label);\n+        }\n+    }\n+\n+    public static void clear() {\n+        entered = null;\n+    }\n+\n+    public static void shouldBeEntered() {\n+        if (entered == null) {\n+            throw new IllegalStateException(\"Should have been entered\");\n+        }\n+    }\n+\n+    public static void shouldNotBeEntered() {\n+        if (entered != null) {\n+            throw new IllegalStateException(\"Should not have been entered: \" + entered);\n+        }\n+    }\n+\n+    public static void    bh_s_boolean(boolean v)  { registerEntered(\"bh_s_boolean\"); }\n+    public static void    bh_s_byte(byte v)        { registerEntered(\"bh_s_byte\");    }\n+    public static void    bh_s_short(short v)      { registerEntered(\"bh_s_short\");   }\n+    public static void    bh_s_char(char v)        { registerEntered(\"bh_s_char\");    }\n+    public static void    bh_s_int(int v)          { registerEntered(\"bh_s_int\");     }\n+    public static void    bh_s_float(float v)      { registerEntered(\"bh_s_float\");   }\n+    public static void    bh_s_long(long v)        { registerEntered(\"bh_s_long\");    }\n+    public static void    bh_s_double(double v)    { registerEntered(\"bh_s_double\");  }\n+    public static void    bh_s_Object(Object v)    { registerEntered(\"bh_s_Object\");  }\n+\n+    public        void    bh_i_boolean(boolean v)  { registerEntered(\"bh_i_boolean\"); }\n+    public        void    bh_i_byte(byte v)        { registerEntered(\"bh_i_byte\");    }\n+    public        void    bh_i_short(short v)      { registerEntered(\"bh_i_short\");   }\n+    public        void    bh_i_char(char v)        { registerEntered(\"bh_i_char\");    }\n+    public        void    bh_i_int(int v)          { registerEntered(\"bh_i_int\");     }\n+    public        void    bh_i_float(float v)      { registerEntered(\"bh_i_float\");   }\n+    public        void    bh_i_long(long v)        { registerEntered(\"bh_i_long\");    }\n+    public        void    bh_i_double(double v)    { registerEntered(\"bh_i_double\");  }\n+    public        void    bh_i_Object(Object v)    { registerEntered(\"bh_i_Object\");  }\n+\n+    public static boolean bh_sr_boolean(boolean v) { registerEntered(\"bh_sr_boolean\"); return false; }\n+    public static byte    bh_sr_byte(byte v)       { registerEntered(\"bh_sr_byte\");    return 0;     }\n+    public static short   bh_sr_short(short v)     { registerEntered(\"bh_sr_short\");   return 0;     }\n+    public static char    bh_sr_char(char v)       { registerEntered(\"bh_sr_char\");    return 0;     }\n+    public static int     bh_sr_int(int v)         { registerEntered(\"bh_sr_int\");     return 0;     }\n+    public static float   bh_sr_float(float v)     { registerEntered(\"bh_sr_float\");   return 0;     }\n+    public static long    bh_sr_long(long v)       { registerEntered(\"bh_sr_long\");    return 0;     }\n+    public static double  bh_sr_double(double v)   { registerEntered(\"bh_sr_double\");  return 0;     }\n+    public static Object  bh_sr_Object(Object v)   { registerEntered(\"bh_sr_Object\");  return null;  }\n+\n+    public        boolean bh_ir_boolean(boolean v) { registerEntered(\"bh_ir_boolean\"); return false; }\n+    public        byte    bh_ir_byte(byte v)       { registerEntered(\"bh_ir_byte\");    return 0;     }\n+    public        short   bh_ir_short(short v)     { registerEntered(\"bh_ir_short\");   return 0;     }\n+    public        char    bh_ir_char(char v)       { registerEntered(\"bh_ir_char\");    return 0;     }\n+    public        int     bh_ir_int(int v)         { registerEntered(\"bh_ir_int\");     return 0;     }\n+    public        float   bh_ir_float(float v)     { registerEntered(\"bh_ir_float\");   return 0;     }\n+    public        long    bh_ir_long(long v)       { registerEntered(\"bh_ir_long\");    return 0;     }\n+    public        double  bh_ir_double(double v)   { registerEntered(\"bh_ir_double\");  return 0;     }\n+    public        Object  bh_ir_Object(Object v)   { registerEntered(\"bh_ir_Object\");  return null;  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeTarget.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"}]}