{"files":[{"patch":"@@ -68,4 +68,2 @@\n-    @SuppressWarnings(\"serial\")\n-    private Mac prf;\n-    @SuppressWarnings(\"serial\")\n-    private Cleaner.Cleanable cleaner;\n+    private transient Mac prf;\n+    private transient Cleaner.Cleanable cleaner;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBKDF2KeyImpl.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -70,0 +70,45 @@\n+        \/*\n+         * Initialize a PBES2Params instance. May generate random salt and\n+         * IV if not passed and the operation is encryption. If initialization\n+         * fails, values are reset. Used by PBES2Params and P11PBECipher\n+         * (SunPKCS11).\n+         *\/\n+        public void initialize(int blkSize, int opmode, int iCount, byte[] salt,\n+                AlgorithmParameterSpec params, SecureRandom random)\n+                throws InvalidAlgorithmParameterException {\n+            try {\n+                boolean doEncrypt = ((opmode == Cipher.ENCRYPT_MODE) ||\n+                        (opmode == Cipher.WRAP_MODE));\n+                if (params instanceof PBEParameterSpec pbeParams) {\n+                    params = pbeParams.getParameterSpec();\n+                }\n+                if (params instanceof IvParameterSpec iv) {\n+                    this.ivSpec = iv;\n+                } else if (params == null && doEncrypt) {\n+                    byte[] ivBytes = new byte[blkSize];\n+                    random.nextBytes(ivBytes);\n+                    this.ivSpec = new IvParameterSpec(ivBytes);\n+                } else {\n+                    throw new InvalidAlgorithmParameterException(\"Wrong \" +\n+                            \"parameter type: IvParameterSpec \" +\n+                            (doEncrypt ? \"or null \" : \"\") + \"expected\");\n+                }\n+                this.iCount = iCount;\n+                if (salt == null) {\n+                    if (doEncrypt) {\n+                        salt = new byte[DEFAULT_SALT_LENGTH];\n+                        random.nextBytes(salt);\n+                    } else {\n+                        throw new InvalidAlgorithmParameterException(\"Salt \" +\n+                                \"needed for decryption\");\n+                    }\n+                }\n+                this.salt = salt;\n+            } catch (InvalidAlgorithmParameterException e) {\n+                this.ivSpec = null;\n+                this.iCount = 0;\n+                this.salt = null;\n+                throw e;\n+            }\n+        }\n+\n@@ -80,4 +125,5 @@\n-         * Obtain AlgorithmParameters for Cipher services. If the state is not\n-         * initialized, this method will generate new values randomly or assign\n-         * from defaults. If the state is initialized, existing values will be\n-         * returned. Used by PBES2Core (SunJCE) and P11PBECipher (SunPKCS11).\n+         * Obtain AlgorithmParameters for Cipher services. This method will\n+         * initialize PBES2Params if needed, generating new values randomly or\n+         * assigning from defaults. If PBES2Params is initialized, existing\n+         * values will be returned. Used by PBES2Core (SunJCE) and\n+         * P11PBECipher (SunPKCS11).\n@@ -87,15 +133,1 @@\n-            AlgorithmParameters params = null;\n-            if (salt == null) {\n-                \/\/ generate random salt and use default iteration count\n-                salt = new byte[DEFAULT_SALT_LENGTH];\n-                random.nextBytes(salt);\n-                iCount = DEFAULT_ITERATIONS;\n-            }\n-            if (ivSpec == null) {\n-                \/\/ generate random IV\n-                byte[] ivBytes = new byte[blkSize];\n-                random.nextBytes(ivBytes);\n-                ivSpec = new IvParameterSpec(ivBytes);\n-            }\n-            PBEParameterSpec pbeSpec = new PBEParameterSpec(\n-                    salt, iCount, ivSpec);\n+            AlgorithmParameters params;\n@@ -103,0 +135,4 @@\n+                if (iCount == 0 && salt == null && ivSpec == null) {\n+                    initialize(blkSize, Cipher.ENCRYPT_MODE, DEFAULT_ITERATIONS,\n+                            null, null, random);\n+                }\n@@ -105,1 +141,1 @@\n-                params.init(pbeSpec);\n+                params.init(new PBEParameterSpec(salt, iCount, ivSpec));\n@@ -113,0 +149,3 @@\n+            } catch (InvalidAlgorithmParameterException iape) {\n+                \/\/ should never happen\n+                throw new RuntimeException(\"Error initializing PBES2Params\");\n@@ -118,3 +157,4 @@\n-         * Obtain a PBEKeySpec for Cipher services, after key and parameters\n-         * validation, random generation or assignment from defaults. Used by\n-         * PBES2Core (SunJCE) and P11PBECipher (SunPKCS11).\n+         * Initialize PBES2Params and obtain a PBEKeySpec for Cipher services.\n+         * Data from the key, parameters, defaults or random may be used for\n+         * initialization. Used by PBES2Core (SunJCE) and P11PBECipher\n+         * (SunPKCS11).\n@@ -128,5 +168,0 @@\n-\n-            char[] passwdChars = null;\n-            salt = null;\n-            iCount = 0;\n-            ivSpec = null;\n@@ -135,0 +170,1 @@\n+            char[] passwdChars = null;\n@@ -140,3 +176,2 @@\n-                boolean doEncrypt = ((opmode == Cipher.ENCRYPT_MODE) ||\n-                            (opmode == Cipher.WRAP_MODE));\n-\n+                int iCountInit;\n+                byte[] saltInit;\n@@ -146,16 +181,3 @@\n-                    salt = check(pbeParams.getSalt());\n-                    iCount = check(pbeParams.getIterationCount());\n-                    AlgorithmParameterSpec ivParams =\n-                            pbeParams.getParameterSpec();\n-                    if (ivParams instanceof IvParameterSpec iv) {\n-                        ivSpec = iv;\n-                    } else if (ivParams == null && doEncrypt) {\n-                        \/\/ generate random IV\n-                        byte[] ivBytes = new byte[blkSize];\n-                        random.nextBytes(ivBytes);\n-                        ivSpec = new IvParameterSpec(ivBytes);\n-                    } else {\n-                        throw new InvalidAlgorithmParameterException(\n-                                \"Wrong parameter type: IV expected\");\n-                    }\n-                } else if (params == null && doEncrypt) {\n+                    iCountInit = check(pbeParams.getIterationCount());\n+                    saltInit = check(pbeParams.getSalt());\n+                } else if (params == null) {\n@@ -163,1 +185,1 @@\n-                    \/\/ PBEKey returns null and 0 respectively.\n+                    \/\/ PBEKey returns 0 and null respectively.\n@@ -165,11 +187,5 @@\n-                        salt = check(pbeKey.getSalt());\n-                        iCount = check(pbeKey.getIterationCount());\n-                    }\n-                    if (salt == null) {\n-                        \/\/ generate random salt\n-                        salt = new byte[DEFAULT_SALT_LENGTH];\n-                        random.nextBytes(salt);\n-                    }\n-                    if (iCount == 0) {\n-                        \/\/ use default iteration count\n-                        iCount = DEFAULT_ITERATIONS;\n+                        iCountInit = check(pbeKey.getIterationCount());\n+                        saltInit = check(pbeKey.getSalt());\n+                    } else {\n+                        iCountInit = DEFAULT_ITERATIONS;\n+                        saltInit = null;\n@@ -177,4 +193,0 @@\n-                    \/\/ generate random IV\n-                    byte[] ivBytes = new byte[blkSize];\n-                    random.nextBytes(ivBytes);\n-                    ivSpec = new IvParameterSpec(ivBytes);\n@@ -185,0 +197,2 @@\n+                initialize(blkSize, opmode, iCountInit, saltInit, params,\n+                        random);\n@@ -189,1 +203,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/PBEUtil.java","additions":77,"deletions":64,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -503,1 +503,1 @@\n-        private final char[] password;\n+        private char[] password;\n@@ -517,0 +517,3 @@\n+            if (password == null) {\n+                throw new IllegalStateException(\"password has been cleared\");\n+            }\n@@ -532,0 +535,1 @@\n+            password = null;\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Key.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import javax.crypto.spec.PBEParameterSpec;\n@@ -110,3 +109,2 @@\n-        return pbes2Params.getAlgorithmParameters(\n-                blkSize, pbeAlg, P11Util.getSunJceProvider(),\n-                JCAUtil.getSecureRandom());\n+        return pbes2Params.getAlgorithmParameters(blkSize, pbeAlg,\n+                P11Util.getSunJceProvider(), JCAUtil.getSecureRandom());\n@@ -137,3 +135,8 @@\n-            if (params instanceof PBEParameterSpec pbeParams) {\n-                \/\/ Reassign params to the underlying service params.\n-                params = pbeParams.getParameterSpec();\n+            \/\/ At this point, we know that the key is a P11PBEKey.\n+            P11Key.P11PBEKey p11PBEKey = (P11Key.P11PBEKey) key;\n+            \/\/ PBE services require a PBE key of the same algorithm and the\n+            \/\/ underlying service (non-PBE) won't check it.\n+            if (!pbeAlg.equals(p11PBEKey.getAlgorithm())) {\n+                throw new InvalidKeyException(\"Cannot use a \" +\n+                        p11PBEKey.getAlgorithm() + \" key for a \" + pbeAlg +\n+                        \" service\");\n@@ -141,0 +144,3 @@\n+            pbes2Params.initialize(blkSize, opmode,\n+                    p11PBEKey.getIterationCount(), p11PBEKey.getSalt(), params,\n+                    random);\n@@ -161,1 +167,0 @@\n-            params = pbes2Params.getIvSpec();\n@@ -163,1 +168,1 @@\n-        cipher.engineInit(opmode, key, params, random);\n+        cipher.engineInit(opmode, key, pbes2Params.getIvSpec(), random);\n@@ -212,3 +217,5 @@\n-    protected int engineGetKeySize(Key key)\n-            throws InvalidKeyException {\n-        return cipher.engineGetKeySize(key);\n+    protected int engineGetKeySize(Key key) {\n+        \/\/ It's guaranteed that when engineInit succeeds, the key length\n+        \/\/ for the underlying cipher is equal to the PBE service key length.\n+        \/\/ Otherwise, initialization fails.\n+        return svcPbeKi.keyLen;\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11PBECipher.java","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -582,1 +582,1 @@\n-            return (SecretKey) derivePBEKey(token, pbeKeySpec, svcPbeKi);\n+            return derivePBEKey(token, pbeKeySpec, svcPbeKi);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11SecretKeyFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.util.Arrays;\n@@ -36,1 +35,0 @@\n-import jdk.internal.access.SharedSecrets;\n@@ -93,0 +91,1 @@\n+            \/\/ Erase password bytes as we read during encoding.\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Util.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/PKCS11.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}