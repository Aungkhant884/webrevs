{"files":[{"patch":"@@ -1525,4 +1525,0 @@\n-Thread* os::ThreadCrashProtection::_protected_thread = NULL;\n-os::ThreadCrashProtection* os::ThreadCrashProtection::_crash_protection = NULL;\n-volatile intptr_t os::ThreadCrashProtection::_crash_mux = 0;\n-\n@@ -1530,1 +1526,2 @@\n-}\n+  _protected_thread = Thread::current();\n+};\n@@ -1539,5 +1536,0 @@\n-  sigset_t saved_sig_mask;\n-\n-  Thread::muxAcquire(&_crash_mux, \"CrashProtection\");\n-\n-  _protected_thread = Thread::current_or_null();\n@@ -1545,0 +1537,1 @@\n+  sigset_t saved_sig_mask;\n@@ -1553,1 +1546,1 @@\n-    _crash_protection = this;\n+    _protected_thread->set_crash_protection(this);\n@@ -1556,3 +1549,1 @@\n-    _crash_protection = NULL;\n-    _protected_thread = NULL;\n-    Thread::muxRelease(&_crash_mux);\n+    _protected_thread->set_crash_protection(NULL);\n@@ -1562,0 +1553,1 @@\n+  assert(_protected_thread == Thread::current(), \"protected thread must be current thread\");\n@@ -1563,3 +1555,1 @@\n-  _crash_protection = NULL;\n-  _protected_thread = NULL;\n-  Thread::muxRelease(&_crash_mux);\n+  _protected_thread->set_crash_protection(NULL);\n@@ -1569,15 +1559,3 @@\n-void os::ThreadCrashProtection::restore() {\n-  assert(_crash_protection != NULL, \"must have crash protection\");\n-  siglongjmp(_jmpbuf, 1);\n-}\n-\n-void os::ThreadCrashProtection::check_crash_protection(int sig,\n-    Thread* thread) {\n-\n-  if (thread != NULL &&\n-      thread == _protected_thread &&\n-      _crash_protection != NULL) {\n-\n-    if (sig == SIGSEGV || sig == SIGBUS) {\n-      _crash_protection->restore();\n-    }\n+void os::ThreadCrashProtection::check_crash_protection(int sig) {\n+  if (sig == SIGSEGV || sig == SIGBUS) {\n+    siglongjmp(_jmpbuf, 1);\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":10,"deletions":32,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -149,3 +149,2 @@\n- * Crash protection for the watcher thread. Wrap the callback\n- * with a sigsetjmp and in case of a SIGSEGV\/SIGBUS we siglongjmp\n- * back.\n+ * Wrap the callback with a sigsetjmp and in case of a SIGSEGV\/SIGBUS we\n+ * siglongjmp back.\n@@ -158,0 +157,2 @@\n+  Thread* _protected_thread;\n+  sigjmp_buf _jmpbuf;\n@@ -159,4 +160,0 @@\n-  static bool is_crash_protected(Thread* thr) {\n-    return _crash_protection != NULL && _protected_thread == thr;\n-  }\n-\n@@ -165,8 +162,1 @@\n-\n-  static void check_crash_protection(int signal, Thread* thread);\n-private:\n-  static Thread* _protected_thread;\n-  static ThreadCrashProtection* _crash_protection;\n-  static volatile intptr_t _crash_mux;\n-  void restore();\n-  sigjmp_buf _jmpbuf;\n+  void check_crash_protection(int sig);\n","filename":"src\/hotspot\/os\/posix\/os_posix.hpp","additions":5,"deletions":15,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -5000,4 +5000,0 @@\n-Thread* os::ThreadCrashProtection::_protected_thread = NULL;\n-os::ThreadCrashProtection* os::ThreadCrashProtection::_crash_protection = NULL;\n-volatile intptr_t os::ThreadCrashProtection::_crash_mux = 0;\n-\n@@ -5005,1 +5001,2 @@\n-}\n+  _protected_thread = Thread::current();\n+};\n@@ -5014,4 +5011,0 @@\n-\n-  Thread::muxAcquire(&_crash_mux, \"CrashProtection\");\n-\n-  _protected_thread = Thread::current_or_null();\n@@ -5019,1 +5012,0 @@\n-\n@@ -5022,1 +5014,1 @@\n-    _crash_protection = this;\n+    _protected_thread->set_crash_protection(this);\n@@ -5026,0 +5018,1 @@\n+    assert(_protected_thread == Thread::current(), \"protected thread must be current thread\");\n@@ -5028,3 +5021,1 @@\n-  _crash_protection = NULL;\n-  _protected_thread = NULL;\n-  Thread::muxRelease(&_crash_mux);\n+  _protected_thread->set_crash_protection(NULL);\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":5,"deletions":14,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -131,2 +131,1 @@\n- * Crash protection for the watcher thread. Wrap the callback\n- * with a __try { call() }\n+ * Wrap the callback with a __try { call() }\n@@ -139,0 +138,1 @@\n+  Thread* _protected_thread;\n@@ -140,4 +140,0 @@\n-  static bool is_crash_protected(Thread* thr) {\n-    return _crash_protection != NULL && _protected_thread == thr;\n-  }\n-\n@@ -146,4 +142,0 @@\n-private:\n-  static Thread* _protected_thread;\n-  static ThreadCrashProtection* _crash_protection;\n-  static volatile intptr_t _crash_mux;\n","filename":"src\/hotspot\/os\/windows\/os_windows.hpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -434,1 +434,3 @@\n-  os::ThreadCrashProtection::check_crash_protection(sig, t);\n+  if (t != NULL) {\n+    t->check_crash_protection(sig);\n+  }\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/os_bsd_x86.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -206,1 +206,3 @@\n-  os::ThreadCrashProtection::check_crash_protection(sig, t);\n+  if (t != NULL) {\n+    t->check_crash_protection(sig);\n+  }\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/os_linux_aarch64.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -253,1 +253,3 @@\n-  os::ThreadCrashProtection::check_crash_protection(sig, t);\n+  if (t != NULL) {\n+    t->check_crash_protection(sig);\n+  }\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/os_linux_arm.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -248,1 +248,3 @@\n-  os::ThreadCrashProtection::check_crash_protection(sig, t);\n+  if (t != NULL) {\n+    t->check_crash_protection(sig);\n+  }\n","filename":"src\/hotspot\/os_cpu\/linux_s390\/os_linux_s390.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -245,1 +245,3 @@\n-  os::ThreadCrashProtection::check_crash_protection(sig, t);\n+  if (t != NULL) {\n+    t->check_crash_protection(sig);\n+  }\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,2 +43,1 @@\n-  assert(!os::ThreadCrashProtection::is_crash_protected(thread),\n-         \"locking not allowed when crash protection is set\");\n+  assert(!thread->has_crash_protection(), \"locking not allowed when crash protection is set\");\n","filename":"src\/hotspot\/share\/runtime\/mutex.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -685,1 +685,1 @@\n-  assert(!os::ThreadCrashProtection::is_crash_protected(Thread::current_or_null()),\n+  assert(Thread::current_or_null() == NULL || !Thread::current()->has_crash_protection(),\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -264,0 +264,1 @@\n+  _crash_protection = NULL;\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -740,0 +740,17 @@\n+private:\n+  os::ThreadCrashProtection *_crash_protection;\n+\n+public:\n+  bool has_crash_protection() const { return _crash_protection != NULL; }\n+  void set_crash_protection(os::ThreadCrashProtection *crash_protection) {\n+    _crash_protection = crash_protection;\n+  }\n+#ifndef _WINDOWS\n+  void check_crash_protection(int sig) const {\n+    assert(this == Thread::current(), \"should only call check_crash_protection() on self\");\n+    if (_crash_protection != NULL) {\n+      _crash_protection->check_crash_protection(sig);\n+    }\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"}]}