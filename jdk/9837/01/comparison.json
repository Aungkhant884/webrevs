{"files":[{"patch":"@@ -1014,5 +1014,1 @@\n-  GrowableArray<PackageEntry*>* loaded_class_pkgs = new GrowableArray<PackageEntry*>(50);\n-  {\n-    MutexLocker ml(THREAD, Module_lock);\n-\n-    PackageEntryTable* pe_table =\n+  PackageEntryTable* pe_table =\n@@ -1020,13 +1016,1 @@\n-\n-    \/\/ Collect the packages that have at least one loaded class.\n-    for (int x = 0; x < pe_table->table_size(); x++) {\n-      for (PackageEntry* package_entry = pe_table->bucket(x);\n-           package_entry != NULL;\n-           package_entry = package_entry->next()) {\n-        if (package_entry->has_loaded_class()) {\n-          loaded_class_pkgs->append(package_entry);\n-        }\n-      }\n-    }\n-  }\n-\n+  GrowableArray<PackageEntry*>* loaded_class_pkgs = pe_table->get_system_packages();\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":2,"deletions":18,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-    _packages = new PackageEntryTable(PackageEntryTable::_packagetable_entry_size);\n+    _packages = new PackageEntryTable();\n@@ -410,7 +410,1 @@\n-    for (int i = 0; i < _packages->table_size(); i++) {\n-      for (PackageEntry* entry = _packages->bucket(i);\n-           entry != NULL;\n-           entry = entry->next()) {\n-        f(entry);\n-      }\n-    }\n+    _packages->packages_do(f);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -356,8 +356,12 @@\n-class ModuleEntryTableDeleter : public StackObj {\n- public:\n-  bool do_entry(const Symbol*& name, ModuleEntry*& entry) {\n-    if (log_is_enabled(Info, module, unload) || log_is_enabled(Debug, module)) {\n-      ResourceMark rm;\n-      const char* str = name->as_C_string();\n-      log_info(module, unload)(\"unloading module %s\", str);\n-      log_debug(module)(\"ModuleEntryTable: deleting module: %s\", str);\n+ModuleEntryTable::~ModuleEntryTable() {\n+  class ModuleEntryTableDeleter : public StackObj {\n+   public:\n+    bool do_entry(const Symbol*& name, ModuleEntry*& entry) {\n+      if (log_is_enabled(Info, module, unload) || log_is_enabled(Debug, module)) {\n+        ResourceMark rm;\n+        const char* str = name->as_C_string();\n+        log_info(module, unload)(\"unloading module %s\", str);\n+        log_debug(module)(\"ModuleEntryTable: deleting module: %s\", str);\n+      }\n+      delete entry;\n+      return true;\n@@ -365,4 +369,1 @@\n-    delete entry;\n-    return true;\n-  }\n-};\n+  };\n@@ -370,1 +371,0 @@\n-ModuleEntryTable::~ModuleEntryTable() {\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -217,2 +217,2 @@\n-        package_table->locked_create_entry_if_not_exist(pkg_list->at(x),\n-                                                        ModuleEntryTable::javabase_moduleEntry());\n+        package_table->locked_create_entry_if_absent(pkg_list->at(x),\n+                                                     ModuleEntryTable::javabase_moduleEntry());\n","filename":"src\/hotspot\/share\/classfile\/modules.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n-#include \"utilities\/hashtable.inline.hpp\"\n@@ -45,0 +44,20 @@\n+PackageEntry::PackageEntry(Symbol* name, ModuleEntry* module) :\n+  _name(name),\n+  _module(module),\n+  _export_flags(0),\n+  _classpath_index(-1),\n+  _must_walk_exports(false),\n+  _qualified_exports(NULL),\n+  _defined_by_cds_in_class_path(0)\n+{\n+  \/\/ name can't be null\n+  _name->increment_refcount();\n+\n+  JFR_ONLY(INIT_ID(this);)\n+}\n+\n+PackageEntry::~PackageEntry() {\n+  delete_qualified_exports();\n+  _name->decrement_refcount();\n+}\n+\n@@ -172,4 +191,1 @@\n-PackageEntryTable::PackageEntryTable(int table_size)\n-  : Hashtable<Symbol*, mtModule>(table_size, sizeof(PackageEntry))\n-{\n-}\n+PackageEntryTable::PackageEntryTable() { }\n@@ -178,13 +194,11 @@\n-  \/\/ Walk through all buckets and all entries in each bucket,\n-  \/\/ freeing each entry.\n-  for (int i = 0; i < table_size(); ++i) {\n-    for (PackageEntry* p = bucket(i); p != NULL;) {\n-      PackageEntry* to_remove = p;\n-      \/\/ read next before freeing.\n-      p = p->next();\n-\n-      \/\/ Clean out the C heap allocated qualified exports list first before freeing the entry\n-      to_remove->delete_qualified_exports();\n-      to_remove->name()->decrement_refcount();\n-\n-      BasicHashtable<mtModule>::free_entry(to_remove);\n+  class PackageEntryTableDeleter : public StackObj {\n+   public:\n+    bool do_entry(const Symbol*& name, PackageEntry*& entry) {\n+      if (log_is_enabled(Info, module, unload) || log_is_enabled(Debug, module)) {\n+        ResourceMark rm;\n+        const char* str = name->as_C_string();\n+        log_info(module, unload)(\"unloading package %s\", str);\n+        log_debug(module)(\"PackageEntry: deleting package: %s\", str);\n+      }\n+      delete entry;\n+      return true;\n@@ -192,2 +206,5 @@\n-  }\n-  assert(number_of_entries() == 0, \"should have removed all entries\");\n+  };\n+\n+  PackageEntryTableDeleter deleter;\n+  _table.unlink(&deleter);\n+  assert(_table.number_of_entries() == 0, \"should have removed all entries\");\n@@ -228,1 +245,1 @@\n-  closure->push(literal_addr()); \/\/ name\n+  closure->push(&_name);\n@@ -234,3 +251,1 @@\n-  set_next(NULL);\n-  set_literal(ArchiveBuilder::get_relocated_symbol(literal()));\n-  set_hash(0x0);  \/\/ re-init at runtime\n+  _name = ArchiveBuilder::get_relocated_symbol(_name);\n@@ -242,1 +257,1 @@\n-  ArchivePtrMarker::mark_pointer((address*)literal_addr());\n+  ArchivePtrMarker::mark_pointer((address*)&_name);\n@@ -258,2 +273,1 @@\n-  for (int i = 0; i < table_size(); ++i) {\n-    for (PackageEntry* p = bucket(i); p != NULL; p = p->next()) {\n+  auto syms = [&] (const Symbol*& key, PackageEntry*& p) {\n@@ -261,2 +275,2 @@\n-    }\n-  }\n+  };\n+  _table.iterate_all(syms);\n@@ -267,6 +281,4 @@\n-  int n, i;\n-  for (n = 0, i = 0; i < table_size(); ++i) {\n-    for (PackageEntry* p = bucket(i); p != NULL; p = p->next()) {\n-      if (p->module()->name() != NULL) {\n-        n++;\n-      }\n+  int n = 0;\n+  auto count = [&] (const Symbol*& key, PackageEntry*& p) {\n+    if (p->module()->is_named()) {\n+      n++;\n@@ -274,1 +286,2 @@\n-  }\n+  };\n+  _table.iterate_all(count);\n@@ -277,7 +290,7 @@\n-  for (n = 0, i = 0; i < table_size(); ++i) {\n-    for (PackageEntry* p = bucket(i); p != NULL; p = p->next()) {\n-      if (p->module()->name() != NULL) {\n-        \/\/ We don't archive unnamed modules, or packages in unnamed modules. They will be\n-        \/\/ created on-demand at runtime as classes in such packages are loaded.\n-        archived_packages->at_put(n++, p);\n-      }\n+  \/\/ reset n\n+  n = 0;\n+  auto grab = [&] (const Symbol*& key, PackageEntry*& p) {\n+    if (p->module()->is_named()) {\n+      \/\/ We don't archive unnamed modules, or packages in unnamed modules. They will be\n+      \/\/ created on-demand at runtime as classes in such packages are loaded.\n+      archived_packages->at_put(n++, p);\n@@ -285,1 +298,3 @@\n-  }\n+  };\n+  _table.iterate_all(grab);\n+\n@@ -289,1 +304,1 @@\n-  for (i = 0; i < n; i++) {\n+  for (int i = 0; i < n; i++) {\n@@ -309,4 +324,1 @@\n-\n-    unsigned int hash = compute_hash(archived_entry->name());\n-    archived_entry->set_hash(hash);\n-    add_entry(hash_to_index(hash), archived_entry);\n+    _table.put(archived_entry->name(), archived_entry);\n@@ -318,18 +330,0 @@\n-PackageEntry* PackageEntryTable::new_entry(unsigned int hash, Symbol* name, ModuleEntry* module) {\n-  assert(Module_lock->owned_by_self(), \"should have the Module_lock\");\n-  PackageEntry* entry = (PackageEntry*)Hashtable<Symbol*, mtModule>::new_entry(hash, name);\n-\n-  JFR_ONLY(INIT_ID(entry);)\n-\n-  \/\/ Initialize fields specific to a PackageEntry\n-  entry->init();\n-  entry->name()->increment_refcount();\n-  entry->set_module(module);\n-  return entry;\n-}\n-\n-void PackageEntryTable::add_entry(int index, PackageEntry* new_entry) {\n-  assert(Module_lock->owned_by_self(), \"should have the Module_lock\");\n-  Hashtable<Symbol*, mtModule>::add_entry(index, (HashtableEntry<Symbol*, mtModule>*)new_entry);\n-}\n-\n@@ -341,2 +335,3 @@\n-  PackageEntry* entry = new_entry(compute_hash(name), name, module);\n-  add_entry(index_for(name), entry);\n+  PackageEntry* entry = new PackageEntry(name, module);\n+  bool created = _table.put(name, entry);\n+  assert(created, \"must be\");\n@@ -347,1 +342,1 @@\n-void PackageEntryTable::locked_create_entry_if_not_exist(Symbol* name, ModuleEntry* module) {\n+PackageEntry* PackageEntryTable::locked_create_entry_if_absent(Symbol* name, ModuleEntry* module) {\n@@ -350,2 +345,8 @@\n-  if (locked_lookup_only(name) == NULL) {\n-    locked_create_entry(name, module);\n+  bool created;\n+  PackageEntry* entry = new PackageEntry(name, module);\n+  PackageEntry** old_entry = _table.put_if_absent(name, entry, &created);\n+  if (created) {\n+    return entry;\n+  } else {\n+    delete entry;\n+    return *old_entry;\n@@ -355,1 +356,1 @@\n-PackageEntry* PackageEntryTable::lookup(Symbol* name, ModuleEntry* module) {\n+PackageEntry* PackageEntryTable::create_entry_if_absent(Symbol* name, ModuleEntry* module) {\n@@ -357,9 +358,1 @@\n-  PackageEntry* p = locked_lookup_only(name);\n-  if (p != NULL) {\n-    return p;\n-  } else {\n-    assert(module != NULL, \"module should never be null\");\n-    PackageEntry* entry = new_entry(compute_hash(name), name, module);\n-    add_entry(index_for(name), entry);\n-    return entry;\n-  }\n+  return locked_create_entry_if_absent(name, module);\n@@ -376,7 +369,2 @@\n-  int index = index_for(name);\n-  for (PackageEntry* p = bucket(index); p != NULL; p = p->next()) {\n-    if (p->name()->fast_compare(name) == 0) {\n-      return p;\n-    }\n-  }\n-  return NULL;\n+  PackageEntry** entry = _table.get(name);\n+  return entry == nullptr ? nullptr : *entry;\n@@ -389,12 +377,9 @@\n-  for (int i = 0; i < table_size(); i++) {\n-    for (PackageEntry* entry = bucket(i);\n-                       entry != NULL;\n-                       entry = entry->next()) {\n-      ModuleEntry* m = entry->module();\n-      Symbol* module_name = (m == NULL ? NULL : m->name());\n-      if (module_name != NULL &&\n-          (module_name->fast_compare(vmSymbols::java_base()) == 0) &&\n-          !pkg_list->contains(entry->name())) {\n-        ResourceMark rm;\n-        vm_exit_during_initialization(\"A non-\" JAVA_BASE_NAME \" package was loaded prior to module system initialization\", entry->name()->as_C_string());\n-      }\n+  auto verifier = [&] (const Symbol*& name, PackageEntry*& entry) {\n+    ModuleEntry* m = entry->module();\n+    Symbol* module_name = (m == NULL ? NULL : m->name());\n+    if (module_name != NULL &&\n+      (module_name->fast_compare(vmSymbols::java_base()) == 0) &&\n+        !pkg_list->contains(entry->name())) {\n+      ResourceMark rm;\n+      vm_exit_during_initialization(\"A non-\" JAVA_BASE_NAME \" package was loaded prior to module system initialization\",\n+                                    entry->name()->as_C_string());\n@@ -402,1 +387,2 @@\n-  }\n+  };\n+  _table.iterate_all(verifier);\n@@ -427,11 +413,7 @@\n-  for (int i = 0; i < table_size(); i++) {\n-    for (PackageEntry* entry = bucket(i);\n-                       entry != NULL;\n-                       entry = entry->next()) {\n-      if (entry->exported_pending_delete()) {\n-        \/\/ exported list is pending deletion due to a transition\n-        \/\/ from qualified to unqualified\n-        entry->delete_qualified_exports();\n-      } else if (entry->is_qual_exported()) {\n-        entry->purge_qualified_exports();\n-      }\n+  auto purge = [&] (const Symbol*& name, PackageEntry*& entry) {\n+    if (entry->exported_pending_delete()) {\n+      \/\/ exported list is pending deletion due to a transition\n+      \/\/ from qualified to unqualified\n+      entry->delete_qualified_exports();\n+    } else if (entry->is_qual_exported()) {\n+      entry->purge_qualified_exports();\n@@ -439,1 +421,25 @@\n-  }\n+  };\n+  _table.iterate_all(purge);\n+}\n+\n+void PackageEntryTable::packages_do(void f(PackageEntry*)) {\n+  auto doit = [&] (const Symbol*&name, PackageEntry*& entry) {\n+    f(entry);\n+  };\n+  assert_locked_or_safepoint(Module_lock);\n+  _table.iterate_all(doit);\n+}\n+\n+\n+GrowableArray<PackageEntry*>*  PackageEntryTable::get_system_packages() {\n+  GrowableArray<PackageEntry*>* loaded_class_pkgs = new GrowableArray<PackageEntry*>(50);\n+  auto grab = [&] (const Symbol*&name, PackageEntry*& entry) {\n+    if (entry->has_loaded_class()) {\n+      loaded_class_pkgs->append(entry);\n+    }\n+  };\n+\n+  MutexLocker ml(Module_lock);\n+  _table.iterate_all(grab);\n+  \/\/ Returns a resource allocated object so caller must have ResourceMark\n+  return loaded_class_pkgs;\n@@ -443,0 +449,3 @@\n+  auto printer = [&] (const Symbol*& name, PackageEntry*& entry) {\n+    entry->print(st);\n+  };\n@@ -444,8 +453,2 @@\n-               table_size(), number_of_entries());\n-  for (int i = 0; i < table_size(); i++) {\n-    for (PackageEntry* probe = bucket(i);\n-                       probe != NULL;\n-                       probe = probe->next()) {\n-      probe->print(st);\n-    }\n-  }\n+               _table.table_size(), _table.number_of_entries());\n+  _table.iterate_all(printer);\n@@ -460,1 +463,1 @@\n-               INT32_FORMAT \" is_exported_unqualified %d is_exported_allUnnamed %d \" \"next \" PTR_FORMAT,\n+               INT32_FORMAT \" is_exported_unqualified %d is_exported_allUnnamed %d \",\n@@ -464,9 +467,1 @@\n-               _export_flags == PKG_EXP_ALLUNNAMED, p2i(next()));\n-}\n-\n-void PackageEntryTable::verify() {\n-  verify_table<PackageEntry>(\"Package Entry Table\");\n-}\n-\n-void PackageEntry::verify() {\n-  guarantee(name() != NULL, \"A package entry must have a corresponding symbol name.\");\n+               _export_flags == PKG_EXP_ALLUNNAMED);\n","filename":"src\/hotspot\/share\/classfile\/packageEntry.cpp","additions":128,"deletions":133,"binary":false,"changes":261,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-#include \"utilities\/hashtable.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n@@ -41,0 +41,1 @@\n+class ModuleEntry;\n@@ -100,1 +101,1 @@\n-class PackageEntry : public HashtableEntry<Symbol*, mtModule> {\n+class PackageEntry : public CHeapObj<mtModule> {\n@@ -102,0 +103,1 @@\n+  Symbol*      _name;\n@@ -123,8 +125,2 @@\n-  void init() {\n-    _module = NULL;\n-    _export_flags = 0;\n-    _classpath_index = -1;\n-    _must_walk_exports = false;\n-    _qualified_exports = NULL;\n-    _defined_by_cds_in_class_path = 0;\n-  }\n+  PackageEntry(Symbol* name, ModuleEntry* module);\n+  ~PackageEntry();\n@@ -133,1 +129,1 @@\n-  Symbol*            name() const               { return literal(); }\n+  Symbol*            name() const               { return _name; }\n@@ -202,8 +198,0 @@\n-  PackageEntry* next() const {\n-    return (PackageEntry*)HashtableEntry<Symbol*, mtModule>::next();\n-  }\n-\n-  PackageEntry** next_addr() {\n-    return (PackageEntry**)HashtableEntry<Symbol*, mtModule>::next_addr();\n-  }\n-\n@@ -220,1 +208,0 @@\n-  void verify();\n@@ -251,22 +238,3 @@\n-\/\/ The PackageEntryTable's lookup is lock free.\n-\/\/\n-class PackageEntryTable : public Hashtable<Symbol*, mtModule> {\n-  friend class VMStructs;\n-public:\n-  enum Constants {\n-    _packagetable_entry_size = 109  \/\/ number of entries in package entry table\n-  };\n-\n-private:\n-  PackageEntry* new_entry(unsigned int hash, Symbol* name, ModuleEntry* module);\n-  void add_entry(int index, PackageEntry* new_entry);\n-\n-  int entry_size() const { return BasicHashtable<mtModule>::entry_size(); }\n-\n-  PackageEntry** bucket_addr(int i) {\n-    return (PackageEntry**)Hashtable<Symbol*, mtModule>::bucket_addr(i);\n-  }\n-\n-  static unsigned int compute_hash(Symbol* name) { return (unsigned int)(name->identity_hash()); }\n-  int index_for(Symbol* name) const { return hash_to_index(compute_hash(name)); }\n-\n+class PackageEntryTable : public CHeapObj<mtModule> {\n+  ResourceHashtable<const Symbol*, PackageEntry*, 109, ResourceObj::C_HEAP, mtModule,\n+                    Symbol::compute_hash> _table;\n@@ -274,1 +242,1 @@\n-  PackageEntryTable(int table_size);\n+  PackageEntryTable();\n@@ -277,4 +245,0 @@\n-  PackageEntry* bucket(int i) {\n-    return (PackageEntry*)Hashtable<Symbol*, mtModule>::bucket(i);\n-  }\n-\n@@ -287,1 +251,1 @@\n-  void locked_create_entry_if_not_exist(Symbol* name, ModuleEntry* module);\n+  PackageEntry* locked_create_entry_if_absent(Symbol* name, ModuleEntry* module);\n@@ -291,1 +255,1 @@\n-  PackageEntry* lookup(Symbol* name, ModuleEntry* module);\n+  PackageEntry* create_entry_if_absent(Symbol* name, ModuleEntry* module);\n@@ -306,0 +270,4 @@\n+  GrowableArray<PackageEntry*>* get_system_packages();\n+\n+  void packages_do(void f(PackageEntry*));\n+\n@@ -307,1 +275,0 @@\n-  void verify();\n","filename":"src\/hotspot\/share\/classfile\/packageEntry.hpp","additions":18,"deletions":51,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2883,1 +2883,1 @@\n-        _package_entry = loader_data->packages()->lookup(pkg_name, ModuleEntryTable::javabase_moduleEntry());\n+        _package_entry = loader_data->packages()->create_entry_if_absent(pkg_name, ModuleEntryTable::javabase_moduleEntry());\n@@ -2886,2 +2886,1 @@\n-        _package_entry = loader_data->packages()->lookup(pkg_name,\n-                                                         loader_data->unnamed_module());\n+        _package_entry = loader_data->packages()->create_entry_if_absent(pkg_name, loader_data->unnamed_module());\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -286,1 +286,0 @@\n-template void BasicHashtable<mtModule>::verify_table<PackageEntry>(char const*);\n","filename":"src\/hotspot\/share\/utilities\/hashtable.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}