{"files":[{"patch":"@@ -1327,0 +1327,13 @@\n+\n+    bool claim(size_t* start, size_t* stop, InternalTable** table) {\n+      if (Atomic::load(&_next) < _limit) {\n+        size_t claimed = Atomic::fetch_and_add(&_next, _size);\n+        if (claimed < _limit) {\n+          *start = claimed;\n+          *stop  = MIN2(claimed + _size, _limit);\n+          *table = _table;\n+          return true;\n+        }\n+      }\n+      return false;\n+    }\n@@ -1329,2 +1342,3 @@\n-  InternalTableClaimer _claimer;\n-  \/\/ If there is a paused resize, we also need to operate on the already resized items.\n+  InternalTableClaimer _table_claimer;\n+  \/\/ If there is a paused resize, we need to claim items already\n+  \/\/ moved to the new resized table.\n@@ -1335,1 +1349,1 @@\n-    _claimer(claim_size, _cht->_table),\n+    _table_claimer(claim_size, _cht->_table),\n@@ -1347,13 +1361,0 @@\n-  bool claim(InternalTableClaimer* claimer, size_t* start, size_t* stop, InternalTable** table) {\n-    if (Atomic::load(&claimer->_next) < claimer->_limit) {\n-      size_t claimed = Atomic::fetch_and_add(&claimer->_next, claimer->_size);\n-      if (claimed < claimer->_limit) {\n-        *start = claimed;\n-        *stop  = MIN2(claimed + claimer->_size, claimer->_limit);\n-        *table = claimer->_table;\n-        return true;\n-      }\n-    }\n-    return false;\n-  }\n-\n@@ -1362,1 +1363,1 @@\n-    if (claim(&_claimer, start, stop, table)) {\n+    if (_table_claimer.claim(start, stop, table)) {\n@@ -1371,2 +1372,1 @@\n-\n-    return claim(&_new_table_claimer, start, stop, table);\n+    return _new_table_claimer.claim(start, stop, table);\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.inline.hpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"}]}