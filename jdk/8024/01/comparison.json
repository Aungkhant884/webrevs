{"files":[{"patch":"@@ -3819,5 +3819,12 @@\n-      \/\/ Emit stub for static call\n-      address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);\n-      if (stub == NULL) {\n-        ciEnv::current()->record_failure(\"CodeCache is full\");\n-        return;\n+      if (UseSharedStubs && _method->is_loaded() &&\n+          (!_optimized_virtual || _method->is_final_method())) {\n+        \/\/ Postpone creating a stub to the interpreter because\n+        \/\/ it might be shared among calls of the same Java method.\n+        cbuf.shared_stub_to_interp_for(_method->get_Method(), cbuf.insts_mark());\n+      } else {\n+        \/\/ Emit stub for static call\n+        address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);\n+        if (stub == NULL) {\n+          ciEnv::current()->record_failure(\"CodeCache is full\");\n+          return;\n+        }\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/codeBuffer.inline.hpp\"\n+#include \"asm\/macroAssembler.hpp\"\n+\n+bool CodeBuffer::pd_finalize_stubs() {\n+  return emit_shared_stubs_to_interp<MacroAssembler>(this, _shared_stub_to_interp_requests);\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/codeBuffer_aarch64.cpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+  bool pd_finalize_stubs();\n","filename":"src\/hotspot\/cpu\/aarch64\/codeBuffer_aarch64.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -132,0 +132,4 @@\n+  if (FLAG_IS_DEFAULT(UseSharedStubs)) {\n+    FLAG_SET_DEFAULT(UseSharedStubs, true);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,6 @@\n+  bool pd_finalize_stubs() {\n+    if (_finalize_stubs) {\n+      Unimplemented();\n+    }\n+    return true;\n+  }\n","filename":"src\/hotspot\/cpu\/arm\/codeBuffer_arm.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,6 @@\n+  bool pd_finalize_stubs() {\n+    if (_finalize_stubs) {\n+      Unimplemented();\n+    }\n+    return true;\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/codeBuffer_ppc.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,6 @@\n+  bool pd_finalize_stubs() {\n+    if (_finalize_stubs) {\n+      Unimplemented();\n+    }\n+    return true;\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/codeBuffer_riscv.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,6 @@\n+  bool pd_finalize_stubs() {\n+    if (_finalize_stubs) {\n+      Unimplemented();\n+    }\n+    return true;\n+  }\n","filename":"src\/hotspot\/cpu\/s390\/codeBuffer_s390.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/codeBuffer.inline.hpp\"\n+#include \"asm\/macroAssembler.hpp\"\n+\n+bool CodeBuffer::pd_finalize_stubs() {\n+  return emit_shared_stubs_to_interp<MacroAssembler, Assembler::imm_operand>(this, _shared_stub_to_interp_requests);\n+}\n","filename":"src\/hotspot\/cpu\/x86\/codeBuffer_x86.cpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+  bool pd_finalize_stubs();\n","filename":"src\/hotspot\/cpu\/x86\/codeBuffer_x86.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,4 +58,1 @@\n-  \/\/ Static stub relocation also tags the Method* in the code-stream.\n-  __ mov_metadata(rbx, (Metadata*) NULL);  \/\/ Method is zapped till fixup time.\n-  \/\/ This is recognized as unresolved by relocs\/nativeinst\/ic code.\n-  __ jump(RuntimeAddress(__ pc()));\n+  __ emit_static_call_stub();\n","filename":"src\/hotspot\/cpu\/x86\/compiledIC_x86.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1311,0 +1311,7 @@\n+}\n+\n+void MacroAssembler::emit_static_call_stub() {\n+  \/\/ Static stub relocation also tags the Method* in the code-stream.\n+  mov_metadata(rbx, (Metadata*) NULL);  \/\/ Method is zapped till fixup time.\n+  \/\/ This is recognized as unresolved by relocs\/nativeinst\/ic code.\n+  jump(RuntimeAddress(pc()));\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -856,0 +856,2 @@\n+  void emit_static_call_stub();\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2059,0 +2059,4 @@\n+  if (FLAG_IS_DEFAULT(UseSharedStubs)) {\n+    FLAG_SET_DEFAULT(UseSharedStubs, true);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1816,5 +1816,13 @@\n-      \/\/ Emit stubs for static call.\n-      address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);\n-      if (stub == NULL) {\n-        ciEnv::current()->record_failure(\"CodeCache is full\");\n-        return;\n+      address mark = cbuf.insts_mark();\n+      if (UseSharedStubs && _method->is_loaded() &&\n+          (!_optimized_virtual || _method->is_final_method())) {\n+        \/\/ Postpone creating a stub to the interpreter because\n+        \/\/ it might be shared among calls of the same Java method.\n+        cbuf.shared_stub_to_interp_for(_method->get_Method(), mark);\n+      } else {\n+        \/\/ Emit stubs for static call.\n+        address stub = CompiledStaticCall::emit_to_interp_stub(cbuf, mark);\n+        if (stub == NULL) {\n+          ciEnv::current()->record_failure(\"CodeCache is full\");\n+          return;\n+        }\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2188,1 +2188,0 @@\n-      \/\/ Emit stubs for static call.\n@@ -2190,4 +2189,12 @@\n-      address stub = CompiledStaticCall::emit_to_interp_stub(cbuf, mark);\n-      if (stub == NULL) {\n-        ciEnv::current()->record_failure(\"CodeCache is full\");\n-        return;\n+      if (UseSharedStubs && _method->is_loaded() &&\n+          (!_optimized_virtual || _method->is_final_method())) {\n+        \/\/ Postpone creating a stub to the interpreter because\n+        \/\/ it might be shared among calls of the same Java method.\n+        cbuf.shared_stub_to_interp_for(_method->get_Method(), mark);\n+      } else {\n+        \/\/ Emit stubs for static call.\n+        address stub = CompiledStaticCall::emit_to_interp_stub(cbuf, mark);\n+        if (stub == NULL) {\n+          ciEnv::current()->record_failure(\"CodeCache is full\");\n+          return;\n+        }\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,6 @@\n+  bool pd_finalize_stubs() {\n+    if (_finalize_stubs) {\n+      Unimplemented();\n+    }\n+    return true;\n+  }\n","filename":"src\/hotspot\/cpu\/zero\/codeBuffer_zero.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -444,0 +444,1 @@\n+  assert(!_finalize_stubs, \"non-finalized stubs\");\n@@ -982,0 +983,16 @@\n+void CodeBuffer::finalize_stubs() {\n+  if (!pd_finalize_stubs()) {\n+    return;\n+  }\n+  _finalize_stubs = false;\n+}\n+\n+void CodeBuffer::shared_stub_to_interp_for(Method* method, address caller_pc) {\n+  if (_shared_stub_to_interp_requests == NULL) {\n+    _shared_stub_to_interp_requests = new SharedStubToInterpRequests();\n+  }\n+  SharedStubToInterpRequest request(method, caller_pc);\n+  _shared_stub_to_interp_requests->push(request);\n+  _finalize_stubs = true;\n+}\n+\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -345,0 +346,18 @@\n+\/\/ A Java method can have calls of Java methods which can be statically bound.\n+\/\/ Calls of Java mehtods need stubs to the interpreter. Calls sharing the same Java method\n+\/\/ can share a stub to interpreter.\n+\/\/ A SharedStubToInterpRequest describes a request for a shared stub to the interpreter.\n+class SharedStubToInterpRequest {\n+ private:\n+  Method* _shared_method;\n+  address _caller_pc;\n+\n+ public:\n+  SharedStubToInterpRequest(Method* method = NULL, address caller_pc = NULL) : _shared_method(method),\n+      _caller_pc(caller_pc) {}\n+\n+  Method* shared_method() const { return _shared_method; }\n+  address caller_pc() const { return _caller_pc; }\n+};\n+typedef GrowableArray<SharedStubToInterpRequest> SharedStubToInterpRequests;\n+\n@@ -417,0 +436,3 @@\n+  SharedStubToInterpRequests* _shared_stub_to_interp_requests; \/\/ used to collect requests for shared iterpreter stubs\n+  bool         _finalize_stubs; \/\/ Indicate if we need to finalize stubs to make CodeBuffer final.\n+\n@@ -434,0 +456,2 @@\n+    _finalize_stubs  = false;\n+    _shared_stub_to_interp_requests = NULL;\n@@ -685,0 +709,6 @@\n+  \/\/ Make a set of stubs final. It can create\/optimize stubs.\n+  void finalize_stubs();\n+\n+  \/\/ Request for a shared stub to the interpreter\n+  void shared_stub_to_interp_for(Method* call, address caller_pc);\n+\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_ASM_CODEBUFFER_INLINE_HPP\n+#define SHARE_ASM_CODEBUFFER_INLINE_HPP\n+\n+#include \"asm\/codeBuffer.hpp\"\n+#include \"ci\/ciEnv.hpp\"\n+#include \"code\/compiledIC.hpp\"\n+\n+template <typename MacroAssembler, int relocate_format = 0>\n+bool emit_shared_stubs_to_interp(CodeBuffer* cb, SharedStubToInterpRequests* shared_stub_to_interp_requests) {\n+  if (shared_stub_to_interp_requests == NULL) {\n+    return true;\n+  }\n+  auto by_shared_method = [](SharedStubToInterpRequest* r1, SharedStubToInterpRequest* r2) {\n+    if (r1->shared_method() < r2->shared_method()) {\n+      return -1;\n+    } else if (r1->shared_method() > r2->shared_method()) {\n+      return 1;\n+    } else {\n+      return 0;\n+    }\n+  };\n+  shared_stub_to_interp_requests->sort(by_shared_method);\n+  MacroAssembler masm(cb);\n+  for (int i = 0; i < shared_stub_to_interp_requests->length();) {\n+    address stub = masm.start_a_stub(CompiledStaticCall::to_interp_stub_size());\n+    if (stub == NULL) {\n+      ciEnv::current()->record_failure(\"CodeCache is full\");\n+      return false;\n+    }\n+\n+    Method* method = shared_stub_to_interp_requests->at(i).shared_method();\n+    do {\n+      masm.relocate(static_stub_Relocation::spec(shared_stub_to_interp_requests->at(i).caller_pc()), relocate_format);\n+      ++i;\n+    } while (i < shared_stub_to_interp_requests->length() && shared_stub_to_interp_requests->at(i).shared_method() == method);\n+    masm.emit_static_call_stub();\n+    masm.end_a_stub();\n+  }\n+  return true;\n+}\n+\n+#endif \/\/ SHARE_ASM_CODEBUFFER_INLINE_HPP\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.inline.hpp","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -450,0 +450,5 @@\n+static bool can_use_shared_stub_for(LIR_OpJavaCall* op) {\n+  return UseSharedStubs &&\n+         op->method()->is_loaded() &&\n+         (op->code() == lir_static_call || op->method()->is_final_method());\n+}\n@@ -457,2 +462,7 @@\n-  \/\/ emit the static call stub stuff out of line\n-  emit_static_call_stub();\n+  if (can_use_shared_stub_for(op)) {\n+    \/\/ Postpone creating a stub to the interpreter.\n+    \/\/ It might be shared among calls of the same Java method.\n+    _masm->code()->shared_stub_to_interp_for(op->method()->get_Method(), pc());\n+  } else {\n+    emit_static_call_stub();\n+  }\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1119,0 +1119,4 @@\n+    if (!failing()) {\n+      code_buffer->finalize_stubs();\n+    }\n+\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2029,2 +2029,5 @@\n-  develop(bool, TraceOptimizedUpcallStubs, false,                              \\\n-                \"Trace optimized upcall stub generation\")                      \\\n+  develop(bool, TraceOptimizedUpcallStubs, false,                           \\\n+                \"Trace optimized upcall stub generation\")                   \\\n+  product(bool, UseSharedStubs, false, DIAGNOSTIC,                          \\\n+                \"Allow sharing stubs whether it is possible\")               \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,202 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * @test SharedStubToInterpTest\n+ * @summary Checks that stubs to the interpreter can be shared for static or final method.\n+ * @bug 8280481\n+ * @library \/test\/lib\n+ *\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"i386\" | os.arch==\"x86\" | os.arch==\"aarch64\"\n+ *\n+ * @run driver compiler.sharedstubs.SharedStubToInterpTest c2 StaticMethodTest\n+ * @run driver compiler.sharedstubs.SharedStubToInterpTest c1 StaticMethodTest\n+ * @run driver compiler.sharedstubs.SharedStubToInterpTest c2 FinalClassTest\n+ * @run driver compiler.sharedstubs.SharedStubToInterpTest c1 FinalClassTest\n+ * @run driver compiler.sharedstubs.SharedStubToInterpTest c2 FinalMethodTest\n+ * @run driver compiler.sharedstubs.SharedStubToInterpTest c1 FinalMethodTest\n+ *\/\n+\n+package compiler.sharedstubs;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.ListIterator;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class SharedStubToInterpTest {\n+    public static void main(String[] args) throws Exception {\n+        String compiler = args[0];\n+        String testClassName = SharedStubToInterpTest.class.getName() + \"$\" + args[1];\n+        ArrayList<String> command = new ArrayList<String>();\n+        command.add(\"-XX:+IgnoreUnrecognizedVMOptions\");\n+        command.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+        if (compiler.equals(\"c2\")) {\n+            command.add(\"-XX:-TieredCompilation\");\n+        } else if (compiler.equals(\"c1\")) {\n+            command.add(\"-XX:TieredStopAtLevel=1\");\n+        } else {\n+            throw new RuntimeException(\"Unknown compiler: \" + compiler);\n+        }\n+        command.add(\"-Xbatch\");\n+        command.add(\"-XX:CompileCommand=compileonly,\" + testClassName + \"::\" + \"test\");\n+        command.add(\"-XX:CompileCommand=dontinline,\" + testClassName + \"::\" + \"test\");\n+        command.add(\"-XX:CompileCommand=print,\" + testClassName + \"::\" + \"test\");\n+        command.add(\"-XX:CompileCommand=exclude,\" + testClassName + \"::\" + \"log01\");\n+        command.add(\"-XX:CompileCommand=dontinline,\" + testClassName + \"::\" + \"log01\");\n+        command.add(\"-XX:CompileCommand=exclude,\" + testClassName + \"::\" + \"log02\");\n+        command.add(\"-XX:CompileCommand=dontinline,\" + testClassName + \"::\" + \"log02\");\n+        command.add(testClassName);\n+        command.add(\"a\");\n+        command.add(\"b\");\n+        command.add(\"c\");\n+\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(command);\n+\n+        OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n+\n+        analyzer.shouldHaveExitValue(0);\n+\n+        System.out.println(analyzer.getOutput());\n+\n+        checkOutput(analyzer);\n+    }\n+\n+    private static String skipTo(Iterator<String> iter, String substring) {\n+        while (iter.hasNext()) {\n+            String nextLine = iter.next();\n+            if (nextLine.contains(substring)) {\n+                return nextLine;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static void checkOutput(OutputAnalyzer output) {\n+        Iterator<String> iter = output.asLines().listIterator();\n+\n+        String match = skipTo(iter, \"Compiled method\");\n+        while (match != null && !match.contains(\"Test::test\")) {\n+            match = skipTo(iter, \"Compiled method\");\n+        }\n+        if (match == null) {\n+            throw new RuntimeException(\"Missing compiler output for the method 'test'\");\n+        }\n+\n+        while (iter.hasNext()) {\n+            String nextLine = iter.next();\n+            if (nextLine.contains(\"{static_stub}\")) {\n+                \/\/ Static stubs must be created at the end of the Stub section.\n+                throw new RuntimeException(\"Found {static_stub} before Deopt Handler Code\");\n+            } else if (nextLine.contains(\"{runtime_call DeoptimizationBlob}\")) {\n+                \/\/ Shared static stubs are put after Deopt Handler Code.\n+                break;\n+            }\n+        }\n+\n+        int foundStaticStubs = 0;\n+        while (iter.hasNext()) {\n+            if (iter.next().contains(\"{static_stub}\")) {\n+                foundStaticStubs += 1;\n+            }\n+        }\n+\n+        final int expectedStaticStubs = 2;\n+        if (foundStaticStubs != expectedStaticStubs) {\n+            throw new RuntimeException(\"Found static stubs: \" + foundStaticStubs + \"; Expected static stubs: \" + expectedStaticStubs);\n+        }\n+    }\n+\n+    public static class StaticMethodTest {\n+        static void log01(int i) {\n+        }\n+        static void log02(int i) {\n+        }\n+\n+        static void test(int i, String[] args) {\n+            if (i % args.length == 0) {\n+                log01(i);\n+                log02(i);\n+            } else {\n+                log01(i);\n+                log02(i);\n+            }\n+        }\n+\n+        public static void main(String[] args) {\n+            for (int i = 1; i < 50_000; ++i) {\n+                test(i, args);\n+            }\n+        }\n+    }\n+\n+    public static final class FinalClassTest {\n+        void log01(int i) {\n+        }\n+        void log02(int i) {\n+        }\n+\n+        void test(int i, String[] args) {\n+            if (i % args.length == 0) {\n+                log01(i);\n+                log02(i);\n+            } else {\n+                log01(i);\n+                log02(i);\n+            }\n+        }\n+\n+        public static void main(String[] args) {\n+            FinalClassTest tFC = new FinalClassTest();\n+            for (int i = 1; i < 50_000; ++i) {\n+                tFC.test(i,args);\n+            }\n+        }\n+    }\n+\n+    public static class FinalMethodTest {\n+        final void log01(int i) {\n+        }\n+        final void log02(int i) {\n+        }\n+\n+        void test(int i, String[] args) {\n+            if (i % args.length == 0) {\n+                log01(i);\n+                log02(i);\n+            } else {\n+                log01(i);\n+                log02(i);\n+            }\n+        }\n+\n+        public static void main(String[] args) {\n+            FinalMethodTest tFM = new FinalMethodTest();\n+            for (int i = 1; i < 50_000; ++i) {\n+                tFM.test(i,args);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/sharedstubs\/SharedStubToInterpTest.java","additions":202,"deletions":0,"binary":false,"changes":202,"status":"added"}]}