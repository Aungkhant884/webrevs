{"files":[{"patch":"@@ -3819,5 +3819,4 @@\n-      if (UseSharedStubs && _method->is_loaded() &&\n-          (!_optimized_virtual || _method->is_final_method())) {\n-        \/\/ Postpone creating a stub to the interpreter because\n-        \/\/ it might be shared among calls of the same Java method.\n-        cbuf.shared_stub_to_interp_for(_method->get_Method(), cbuf.insts_mark());\n+      if (CodeBuffer::supports_shared_stubs() && _method->can_be_statically_bound()) {\n+        \/\/ Calls of the same statically bound method can share\n+        \/\/ a stub to the interpreter.\n+        cbuf.shared_stub_to_interp_for(_method, cbuf.insts_mark());\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+  static constexpr bool supports_shared_stubs() { return true; }\n","filename":"src\/hotspot\/cpu\/aarch64\/codeBuffer_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -132,4 +132,0 @@\n-  if (FLAG_IS_DEFAULT(UseSharedStubs)) {\n-    FLAG_SET_DEFAULT(UseSharedStubs, true);\n-  }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+  static constexpr bool supports_shared_stubs() { return false; }\n","filename":"src\/hotspot\/cpu\/arm\/codeBuffer_arm.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+  static constexpr bool supports_shared_stubs() { return false; }\n","filename":"src\/hotspot\/cpu\/ppc\/codeBuffer_ppc.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+  static constexpr bool supports_shared_stubs() { return false; }\n","filename":"src\/hotspot\/cpu\/riscv\/codeBuffer_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+  static constexpr bool supports_shared_stubs() { return false; }\n","filename":"src\/hotspot\/cpu\/s390\/codeBuffer_s390.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+  static constexpr bool supports_shared_stubs() { return true; }\n","filename":"src\/hotspot\/cpu\/x86\/codeBuffer_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2059,4 +2059,0 @@\n-  if (FLAG_IS_DEFAULT(UseSharedStubs)) {\n-    FLAG_SET_DEFAULT(UseSharedStubs, true);\n-  }\n-\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1817,4 +1817,3 @@\n-      if (UseSharedStubs && _method->is_loaded() &&\n-          (!_optimized_virtual || _method->is_final_method())) {\n-        \/\/ Postpone creating a stub to the interpreter because\n-        \/\/ it might be shared among calls of the same Java method.\n+      if (CodeBuffer::supports_shared_stubs() && _method->can_be_statically_bound()) {\n+        \/\/ Calls of the same statically bound method can share\n+        \/\/ a stub to the interpreter.\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2189,4 +2189,3 @@\n-      if (UseSharedStubs && _method->is_loaded() &&\n-          (!_optimized_virtual || _method->is_final_method())) {\n-        \/\/ Postpone creating a stub to the interpreter because\n-        \/\/ it might be shared among calls of the same Java method.\n+      if (CodeBuffer::supports_shared_stubs() && _method->can_be_statically_bound()) {\n+        \/\/ Calls of the same statically bound method can share\n+        \/\/ a stub to the interpreter.\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+ public:\n+  static constexpr bool supports_shared_stubs() { return false; }\n","filename":"src\/hotspot\/cpu\/zero\/codeBuffer_zero.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -990,1 +990,1 @@\n-void CodeBuffer::shared_stub_to_interp_for(Method* method, address caller_pc) {\n+void CodeBuffer::shared_stub_to_interp_for(ciMethod* callee, address caller_pc) {\n@@ -994,1 +994,1 @@\n-  SharedStubToInterpRequest request(method, caller_pc);\n+  SharedStubToInterpRequest request(callee, caller_pc);\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+class ciMethod;\n@@ -350,1 +351,1 @@\n-class SharedStubToInterpRequest: public ResourceObj {\n+class SharedStubToInterpRequest : public ResourceObj {\n@@ -352,1 +353,1 @@\n-  Method* _shared_method;\n+  ciMethod* _shared_method;\n@@ -356,1 +357,1 @@\n-  SharedStubToInterpRequest(Method* method = NULL, address caller_pc = NULL) : _shared_method(method),\n+  SharedStubToInterpRequest(ciMethod* method = NULL, address caller_pc = NULL) : _shared_method(method),\n@@ -359,1 +360,1 @@\n-  Method* shared_method() const { return _shared_method; }\n+  ciMethod* shared_method() const { return _shared_method; }\n@@ -713,1 +714,1 @@\n-  void shared_stub_to_interp_for(Method* call, address caller_pc);\n+  void shared_stub_to_interp_for(ciMethod* callee, address caller_pc);\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    Method* method = shared_stub_to_interp_requests->at(i).shared_method();\n+    ciMethod* method = shared_stub_to_interp_requests->at(i).shared_method();\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -450,6 +450,0 @@\n-static bool can_use_shared_stub_for(LIR_OpJavaCall* op) {\n-  return UseSharedStubs &&\n-         op->method()->is_loaded() &&\n-         (op->code() == lir_static_call || op->method()->is_final_method());\n-}\n-\n@@ -462,4 +456,4 @@\n-  if (can_use_shared_stub_for(op)) {\n-    \/\/ Postpone creating a stub to the interpreter.\n-    \/\/ It might be shared among calls of the same Java method.\n-    _masm->code()->shared_stub_to_interp_for(op->method()->get_Method(), pc());\n+  if (CodeBuffer::supports_shared_stubs() && op->method()->can_be_statically_bound()) {\n+    \/\/ Calls of the same statically bound method can share\n+    \/\/ a stub to the interpreter.\n+    _masm->code()->shared_stub_to_interp_for(op->method(), pc());\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2031,3 +2031,0 @@\n-  product(bool, UseSharedStubs, false, DIAGNOSTIC,                          \\\n-                \"Allow sharing stubs whether it is possible\")               \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}