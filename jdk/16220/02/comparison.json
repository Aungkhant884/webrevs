{"files":[{"patch":"@@ -400,0 +400,1 @@\n+  CHECK_BAILOUT_(no_frame_size);\n@@ -449,2 +450,0 @@\n-  CompilationMemoryStatisticMark cmsm(env()->task()->directive());\n-\n@@ -456,0 +455,2 @@\n+    CHECK_BAILOUT();\n+\n@@ -608,0 +609,3 @@\n+\n+  CompilationMemoryStatisticMark cmsm(directive);\n+\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -88,0 +88,1 @@\n+  bool               _oom;\n@@ -206,0 +207,4 @@\n+  \/\/ MemLimit handling\n+  bool oom() const { return _oom; }\n+  void set_oom() { _oom = true; }\n+\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -322,1 +322,1 @@\n-  bool failing() { return _failure_reason != nullptr; }\n+  bool failing() const { return _failure_reason != nullptr; }\n@@ -325,1 +325,1 @@\n-  const char* failure_reason() { return _failure_reason; }\n+  const char* failure_reason() const { return _failure_reason; }\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+#ifdef COMPILER1\n+#include \"c1\/c1_Compilation.hpp\"\n+#endif\n@@ -45,0 +48,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -50,1 +54,0 @@\n-\n@@ -54,0 +57,1 @@\n+  _limit(0), _hit_limit(false),\n@@ -61,1 +65,1 @@\n-void ArenaStatCounter::start() {\n+void ArenaStatCounter::start(size_t limit) {\n@@ -63,0 +67,7 @@\n+  _limit = limit;\n+  _hit_limit = false;\n+}\n+\n+void ArenaStatCounter::end(){\n+  _limit = 0;\n+  _hit_limit = false;\n@@ -107,0 +118,4 @@\n+    \/\/ Did we hit the memory limit?\n+    if (!_hit_limit && _limit > 0 && peak_since_start() > _limit) {\n+      _hit_limit = true;\n+    }\n@@ -128,1 +143,2 @@\n-  FullMethodName(Symbol* k, Symbol* m, Symbol* s) : _k(k), _m(m), _s(s) {}\n+  FullMethodName(const Method* m) :\n+    _k(m->klass_name()), _m(m->name()), _s(m->signature()) {};\n@@ -176,0 +192,1 @@\n+  const char* _result;\n@@ -182,1 +199,2 @@\n-      _total(0), _na_at_peak(0), _ra_at_peak(0), _live_nodes_at_peak(0) {\n+      _total(0), _na_at_peak(0), _ra_at_peak(0), _live_nodes_at_peak(0),\n+      _result(nullptr) {\n@@ -195,0 +213,2 @@\n+  void set_result(const char* s) { _result = s; }\n+\n@@ -202,1 +222,2 @@\n-    st->print_cr(\"  #nodes : ...how many nodes (if c2)\");\n+    st->print_cr(\"  result : Result: 'ok' finished successfully, 'oom' hit memory limit, 'err' compilation failed\");\n+    st->print_cr(\"  #nodes : ...how many nodes (c2 only)\");\n@@ -210,1 +231,1 @@\n-    st->print_cr(\"total     NA        RA        #nodes  time    type  #rc thread              method\");\n+    st->print_cr(\"total     NA        RA        result  #nodes  time    type  #rc thread              method\");\n@@ -240,0 +261,4 @@\n+    \/\/ result?\n+    st->print(\"%s \", _result ? _result : \"\");\n+    col += 8; st->fill_to(col);\n+\n@@ -284,1 +309,1 @@\n-           unsigned live_nodes_at_peak) {\n+           unsigned live_nodes_at_peak, const char* result) {\n@@ -305,0 +330,1 @@\n+    e->set_result(result);\n@@ -344,1 +370,1 @@\n-void CompilationMemoryStatistic::on_start_compilation() {\n+void CompilationMemoryStatistic::on_start_compilation(const DirectiveSet* directive) {\n@@ -346,1 +372,2 @@\n-  Thread::current()->as_Compiler_thread()->arena_stat()->start();\n+  const size_t limit = directive->mem_limit();\n+  Thread::current()->as_Compiler_thread()->arena_stat()->start(limit);\n@@ -353,1 +380,1 @@\n-  const ArenaStatCounter* const arena_stat = th->arena_stat();\n+  ArenaStatCounter* const arena_stat = th->arena_stat();\n@@ -357,1 +384,1 @@\n-  FullMethodName fmn(m->klass_name(), m->name(), m->signature());\n+  FullMethodName fmn(m);\n@@ -371,0 +398,14 @@\n+\n+  \/\/ Store result\n+  \/\/ For this to work, we must call on_end_compilation() at a point where\n+  \/\/ Compile|Compilation already handed over the failure string to ciEnv,\n+  \/\/ but ciEnv must still be alive.\n+  const char* result = \"ok\"; \/\/ ok\n+  const ciEnv* const env = th->env();\n+  if (env) {\n+    const char* const failure_reason = env->failure_reason();\n+    if (failure_reason != nullptr) {\n+      result = (failure_reason == failure_reason_memlimit()) ? \"oom\" : \"err\";\n+    }\n+  }\n+\n@@ -379,1 +420,39 @@\n-                    arena_stat->live_nodes_at_peak());\n+                    arena_stat->live_nodes_at_peak(),\n+                    result);\n+  }\n+\n+  arena_stat->end(); \/\/ reset things\n+}\n+\n+static void inform_compilation_about_oom(CompilerType ct) {\n+  \/\/ Inform C1 or C2 that an OOM happened. They will take delayed action\n+  \/\/ and abort the compilation in progress. Note that this is not instantaneous,\n+  \/\/ since the compiler has to actively bailout, which may take a while, during\n+  \/\/ which memory usage may rise further.\n+  \/\/\n+  \/\/ The mechanism differs slightly between C1 and C2:\n+  \/\/ - With C1, we directly set the bailout string, which will cause C1 to\n+  \/\/   bailout at the typical BAILOUT places.\n+  \/\/ - With C2, the corresponding mechanism would be the failure string; but\n+  \/\/   bailout paths in C2 are not complete and therefore it is dangerous to\n+  \/\/   set the failure string at - for C2 - seemingly random places. Instead,\n+  \/\/   upon OOM C2 sets the failure string next time it checks the node limit.\n+  if (ciEnv::current() != nullptr) {\n+    void* compiler_data = ciEnv::current()->compiler_data();\n+#ifdef COMPILER1\n+    if (ct == compiler_c1) {\n+      Compilation* C = static_cast<Compilation*>(compiler_data);\n+      if (C != nullptr) {\n+        C->bailout(CompilationMemoryStatistic::failure_reason_memlimit());\n+        C->set_oom();\n+      }\n+    }\n+#endif\n+#ifdef COMPILER2\n+    if (ct == compiler_c2) {\n+      Compile* C = static_cast<Compile*>(compiler_data);\n+      if (C != nullptr) {\n+        C->set_oom();\n+      }\n+    }\n+#endif \/\/ COMPILER2\n@@ -386,1 +465,54 @@\n-  th->arena_stat()->account(diff, (int)arena->get_tag());\n+\n+  ArenaStatCounter* const arena_stat = th->arena_stat();\n+  bool hit_limit_before = arena_stat->hit_limit();\n+\n+  if (arena_stat->account(diff, (int)arena->get_tag())) { \/\/ new peak?\n+\n+    \/\/ Limit handling\n+    if (arena_stat->hit_limit()) {\n+\n+      char name[1024] = \"\";\n+      bool print = false;\n+      bool crash = false;\n+      CompilerType ct = compiler_none;\n+\n+      \/\/ get some more info\n+      const CompileTask* task = th->task();\n+      if (task != nullptr) {\n+        ct = task->compiler()->type();\n+        const DirectiveSet* directive = task->directive();\n+        print = directive->should_print_memstat();\n+        crash = directive->should_crash_at_mem_limit();\n+        const Method* m = th->task()->method();\n+        if (m != nullptr) {\n+          FullMethodName(m).as_C_string(name, sizeof(name));\n+        }\n+      }\n+\n+      char message[1024] = \"\";\n+\n+      \/\/ build up message if we need it later\n+      if (print || crash) {\n+        stringStream ss(message, sizeof(message));\n+        if (ct != compiler_none && name[0] != '\\0') {\n+          ss.print(\"%s %s: \", compilertype2name(ct), name);\n+        }\n+        ss.print(\"Hit MemLimit %s (limit: %zu now: %zu)\",\n+                 (hit_limit_before ? \"again\" : \"\"),\n+                 arena_stat->limit(), arena_stat->peak_since_start());\n+      }\n+\n+      \/\/ log if needed\n+      if (print) {\n+        tty->print_raw(message);\n+        tty->cr();\n+      }\n+\n+      \/\/ Crash out if needed\n+      if (crash) {\n+        report_fatal(OOM_HOTSPOT_ARENA, __FILE__, __LINE__, \"%s\", message);\n+      } else {\n+        inform_compilation_about_oom(ct);\n+      }\n+    }\n+  }\n@@ -441,0 +573,5 @@\n+const char* CompilationMemoryStatistic::failure_reason_memlimit() {\n+  static const char* const s = \"hit memory limit while compiling\";\n+  return s;\n+}\n+\n@@ -444,1 +581,1 @@\n-    CompilationMemoryStatistic::on_start_compilation();\n+    CompilationMemoryStatistic::on_start_compilation(directive);\n","filename":"src\/hotspot\/share\/compiler\/compilationMemoryStatistic.cpp","additions":151,"deletions":14,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -50,0 +50,3 @@\n+  \/\/ MemLimit handling\n+  size_t _limit;\n+  bool _hit_limit;\n@@ -72,2 +75,3 @@\n-  \/\/ Mark the start of a compilation.\n-  void start();\n+  \/\/ Mark the start and end of a compilation.\n+  void start(size_t limit);\n+  void end();\n@@ -80,0 +84,1 @@\n+\n@@ -81,0 +86,3 @@\n+\n+  size_t limit() const              { return _limit; }\n+  bool   hit_limit() const          { return _hit_limit; }\n@@ -89,1 +97,5 @@\n-  static void on_start_compilation();\n+  static void on_start_compilation(const DirectiveSet* directive);\n+\n+  \/\/ Called at end of compilation. Records the arena usage peak. Also takes over\n+  \/\/ status information from ciEnv (compilation failed, oom'ed or went okay). ciEnv::_failure_reason\n+  \/\/ must be set at this point (so place CompilationMemoryStatisticMark correctly).\n@@ -93,0 +105,2 @@\n+  \/\/ For compilers\n+  static const char* failure_reason_memlimit();\n","filename":"src\/hotspot\/share\/compiler\/compilationMemoryStatistic.hpp","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-AbstractCompiler* CompileTask::compiler() {\n+AbstractCompiler* CompileTask::compiler() const {\n","filename":"src\/hotspot\/share\/compiler\/compileTask.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -183,1 +183,1 @@\n-  AbstractCompiler* compiler();\n+  AbstractCompiler* compiler() const;\n","filename":"src\/hotspot\/share\/compiler\/compileTask.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -206,1 +206,2 @@\n-  return MemStatOption > 0;\n+  \/\/ MemLimit requires the memory statistic to be active\n+  return MemStatOption > 0 || MemLimitOption != 0;\n@@ -213,0 +214,10 @@\n+size_t DirectiveSet::mem_limit() const {\n+  return MemLimitOption < 0 ? -MemLimitOption : MemLimitOption;\n+}\n+\n+bool DirectiveSet::should_crash_at_mem_limit() const {\n+  \/\/ The sign encodes the action to be taken when reaching\n+  \/\/ the memory limit (+ stop - crash)\n+  return MemLimitOption < 0;\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+    cflags(MemLimit,                intx, 0, MemLimit) \\\n@@ -153,0 +154,2 @@\n+  size_t mem_limit() const;\n+  bool should_crash_at_mem_limit() const; \/\/ true: crash false: stop compilation\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"utilities\/parseInteger.hpp\"\n@@ -462,1 +463,1 @@\n-  return has_command(CompileCommand::MemStat);\n+  return has_command(CompileCommand::MemStat) || has_command(CompileCommand::MemLimit);\n@@ -637,0 +638,38 @@\n+static bool parseMemLimit(const char* line, intx& value, int& bytes_read, char* errorbuf, const int buf_size) {\n+  \/\/ Format:\n+  \/\/ \"<memory size>['~' <suboption>]\"\n+  \/\/ <memory size> can have units, e.g. M\n+  \/\/ <suboption> one of \"crash\" \"stop\", if omitted, \"stop\" is implied.\n+  \/\/\n+  \/\/ Examples:\n+  \/\/ -XX:CompileCommand='memlimit,*.*,20m'\n+  \/\/ -XX:CompileCommand='memlimit,*.*,20m~stop'\n+  \/\/ -XX:CompileCommand='memlimit,Option::toString,1m~crash'\n+  \/\/\n+  \/\/ The resulting intx carries the size and whether we are to stop or crash:\n+  \/\/ - neg. value means crash\n+  \/\/ - pos. value (default) means stop\n+  size_t s = 0;\n+  char* end;\n+  if (!parse_integer<size_t>(line, &end, &s)) {\n+    jio_snprintf(errorbuf, buf_size, \"MemLimit: invalid value\");\n+  }\n+  bytes_read = (int)(end - line);\n+\n+  intx v = (intx)s;\n+  if ((*end) != '\\0') {\n+    if (strncasecmp(end, \"~crash\", 6) == 0) {\n+      v = -v;\n+      bytes_read += 6;\n+    } else if (strncasecmp(end, \"~stop\", 5) == 0) {\n+      \/\/ ok, this is the default\n+      bytes_read += 5;\n+    } else {\n+      jio_snprintf(errorbuf, buf_size, \"MemLimit: invalid option\");\n+      return true;\n+    }\n+  }\n+  value = v;\n+  return true;\n+}\n+\n@@ -662,1 +701,7 @@\n-    if (sscanf(line, \"\" INTX_FORMAT \"%n\", &value, &bytes_read) == 1) {\n+    \/\/ Special handling for memlimit\n+    bool success = (option == CompileCommand::MemLimit) && parseMemLimit(line, value, bytes_read, errorbuf, buf_size);\n+    if (!success) {\n+      \/\/ Is it a raw number?\n+      success = sscanf(line, \"\" INTX_FORMAT \"%n\", &value, &bytes_read) == 1;\n+    }\n+    if (success) {\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":47,"deletions":2,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+  option(MemLimit, \"MemLimit\", Intx) \\\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n@@ -664,0 +665,1 @@\n+                  _oom(false),\n@@ -941,0 +943,1 @@\n+    _oom(false),\n@@ -5264,0 +5267,3 @@\n+void Compile::record_method_not_compilable_oom() {\n+  record_method_not_compilable(CompilationMemoryStatistic::failure_reason_memlimit());\n+}\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -463,0 +463,3 @@\n+  \/\/ \"MemLimit\" directive was specified and the memory limit was hit during compilation\n+  bool                          _oom;\n+\n@@ -506,0 +509,2 @@\n+  void record_method_not_compilable_oom();\n+\n@@ -817,0 +822,4 @@\n+    if (oom()) {\n+      record_method_not_compilable_oom();\n+      return true;\n+    }\n@@ -824,0 +833,2 @@\n+  bool oom() const { return _oom; }\n+  void set_oom()   { _oom = true; }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -253,1 +253,2 @@\n-  OOM_JAVA_HEAP_FATAL = 0xe0000004\n+  OOM_JAVA_HEAP_FATAL = 0xe0000004,\n+  OOM_HOTSPOT_ARENA = 0xe0000005\n","filename":"src\/hotspot\/share\/utilities\/debug.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=c1_crash\n+ * @requires vm.compiler1.enabled\n+ * @summary Checks that -XX:CompileCommand=MemLimit,...,crash causes compilation to crash\n+ * @library \/test\/lib\n+ * @run driver compiler.print.CompileCommandMemLimit crash false\n+ *\/\n+\n+\/*\n+ * @test id=c2_crash\n+ * @requires vm.compiler2.enabled\n+ * @summary Checks that -XX:CompileCommand=MemLimit,...,crash causes compilation to crash\n+ * @library \/test\/lib\n+ * @run driver compiler.print.CompileCommandMemLimit crash true\n+ *\/\n+\n+\/*\n+ * @test id=c1_stop\n+ * @requires vm.compiler1.enabled\n+ * @summary Checks that -XX:CompileCommand=MemLimit,...,crash causes compilation to stop\n+ * @library \/test\/lib\n+ * @run driver compiler.print.CompileCommandMemLimit stop false\n+ *\/\n+\n+\/*\n+ * @test id=c2_stop\n+ * @requires vm.compiler2.enabled\n+ * @summary Checks that -XX:CompileCommand=MemLimit,...,crash causes compilation to stop\n+ * @library \/test\/lib\n+ * @run driver compiler.print.CompileCommandMemLimit stop true\n+ *\/\n+\n+package compiler.print;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class CompileCommandMemLimit {\n+\n+    final static String METHOD1 = \"method1\";\n+    final static String METHOD2 = \"method2\";\n+\n+    static boolean c2;\n+    static boolean test_crash;\n+\n+    public static void main(String[] args) throws Exception {\n+        switch (args[0]) {\n+            case \"crash\" : test_crash = true; break;\n+            case \"stop\" : test_crash = false; break;\n+            default: throw new RuntimeException(\"invalid argument\");\n+        }\n+        c2 = Boolean.parseBoolean(args[1]);\n+        test(METHOD1, METHOD2);\n+        test(METHOD2, METHOD1);\n+    }\n+\n+    private static void test(String include, String exclude) throws Exception {\n+\n+        \/\/ A method that is known to cost compilers a bit of memory to compile\n+\n+        List<String> options = new ArrayList<String>();\n+        options.add(\"-Xcomp\");\n+        options.add(\"-XX:-Inline\");\n+        options.add(\"-XX:CompileCommand=compileonly,\" + getTestClass() + \"::*\");\n+        \/\/ We pass a very small size to guarantee the crash\n+        options.add(\"-XX:CompileCommand=MemStat,\" + getTestMethod(include) + \",print\");\n+        options.add(\"-XX:CompileCommand=MemLimit,\" + getTestMethod(include) + \",4k\" + (test_crash ? \"~crash\" : \"\"));\n+        if (c2) {\n+            options.add(\"-XX:-TieredCompilation\");\n+        } else {\n+            options.add(\"-XX:TieredStopAtLevel=1\");\n+        }\n+        options.add(getTestClass());\n+\n+        OutputAnalyzer oa = ProcessTools.executeTestJvm(options);\n+\n+        oa.reportDiagnosticSummary();\n+\n+        String expectedNameIncl = getTestMethod(include)\n+                .replace('.', '\/')\n+                .replace(\"$\", \"\\\\$\");\n+        String expectedNameExcl = getTestMethod(exclude)\n+                .replace('.', '\/')\n+                .replace(\"$\", \"\\\\$\");\n+\n+        String ct = c2 ? \"c2\" : \"c1\";\n+\n+        if (test_crash) {\n+            oa.shouldNotHaveExitValue(0);\n+            oa.shouldMatch(\"# *Internal Error.*\");\n+            oa.shouldMatch(\"# *fatal error: \" + ct + \" *\" + expectedNameIncl + \".*: Hit MemLimit .*limit: 4096.*\");\n+            oa.shouldNotMatch(\".*\" + expectedNameExcl + \".*\");\n+        } else {\n+            \/\/ Should see trace output when methods are compiled\n+            oa.shouldHaveExitValue(0)\n+                    .shouldMatch(\".*\" + expectedNameIncl + \".*\")\n+                    .shouldNotMatch(\".*\" + expectedNameExcl + \".*\");\n+\n+            \/\/ Expect this log line\n+            oa.shouldMatch(\".*\" + expectedNameIncl + \".*Hit MemLimit.*\");\n+\n+            \/\/ Expect final output to contain \"oom\"\n+            oa.shouldMatch(\".*oom.*\" + expectedNameIncl + \".*\");\n+        }\n+    }\n+\n+    \/\/ Test class that is invoked by the sub process\n+    public static String getTestClass() {\n+        return TestMain.class.getName();\n+    }\n+\n+    public static String getTestMethod(String method) {\n+        return getTestClass() + \"::\" + method;\n+    }\n+\n+    public static class TestMain {\n+        public static void main(String[] args) {\n+            method1();\n+            method2();\n+        }\n+\n+        static long method1() {\n+            return System.currentTimeMillis();\n+        }\n+        static void method2() {}\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/print\/CompileCommandMemLimit.java","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -76,2 +76,2 @@\n-        \/\/ total     NA        RA        #nodes  time    type  #rc thread              method\n-        \/\/ 621832    0         589104    0       0,025   c1    1   0x00007f5ccc1951a0  java\/util\/zip\/ZipFile$Source::checkAndAddEntry((II)I)\n+        \/\/ total     NA        RA        result  #nodes  time    type  #rc thread              method\n+        \/\/ 211488    66440     77624     ok      13      0.057   c2    2   0x00007fb49428db70  compiler\/print\/CompileCommandPrintMemStat$TestMain::method1(()V)\n@@ -79,2 +79,2 @@\n-        oa.shouldMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +\\\\d+.*\" + expectedNameIncl + \".*\");\n-        oa.shouldNotMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +\\\\d+.*\" + expectedNameExcl + \".*\");\n+        oa.shouldMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +\\\\S+ +\\\\d+.*\" + expectedNameIncl + \".*\");\n+        oa.shouldNotMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +\\\\S+ +\\\\d+.*\" + expectedNameExcl + \".*\");\n","filename":"test\/hotspot\/jtreg\/compiler\/print\/CompileCommandPrintMemStat.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -62,2 +62,2 @@\n-        \/\/ total     NA        RA        #nodes  time    type  #rc thread              method\n-        \/\/ 621832    0         589104    0       0,025   c1    1   0x00007f5ccc1951a0  java\/util\/zip\/ZipFile$Source.checkAndAddEntry((II)I)\n+        \/\/ total     NA        RA        result  #nodes  time    type  #rc thread              method\n+        \/\/ 211488    66440     77624     ok      13      0.057   c2    2   0x00007fb49428db70  compiler\/print\/CompileCommandPrintMemStat$TestMain::method1(()V)\n@@ -65,1 +65,1 @@\n-        out.shouldMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +\\\\d+.*java.*\\\\(.*\\\\)\");\n+        out.shouldMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +\\\\S+ +\\\\d+.*java.*\\\\(.*\\\\)\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/compiler\/CompilerMemoryStatisticTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}