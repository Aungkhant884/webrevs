{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -187,1 +187,6 @@\n-        TAGLET_PATH;\n+        TAGLET_PATH,\n+\n+        \/**\n+         * Location to search for snippets.\n+         *\/\n+        SNIPPET_PATH;\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/DocumentationTool.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * A tree node for an attribute in an HTML element.\n+ * A tree node for an attribute in an HTML element or tag.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/doctree\/AttributeTree.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-         * representing an HTML attribute.\n+         * representing an attribute in an HTML element or tag.\n@@ -207,0 +207,6 @@\n+        \/**\n+         * Used for instances of {@link SnippetTree}\n+         * representing an {@code @snippet} tag.\n+         *\/\n+        SNIPPET(\"snippet\"),\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/doctree\/DocTree.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -290,0 +290,15 @@\n+    \/**\n+     * Visits a SnippetTree node.\n+     *\n+     * @param node the node being visited\n+     * @param p    a parameter value\n+     *\n+     * @return a result value\n+     * @implSpec Visits the provided {@code SnippetTree} node\n+     *           by calling {@code visitOther(node, p)}.\n+     * @since 18\n+     *\/\n+    default R visitSnippet(SnippetTree node, P p) {\n+        return visitOther(node, p);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/doctree\/DocTreeVisitor.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.source.doctree;\n+\n+import java.util.List;\n+\n+\/**\n+ * A tree node for an {@code @snippet} inline tag, as specified by\n+ * <a href=\"http:\/\/openjdk.java.net\/jeps\/413\">JEP 413<\/a>.\n+ *\n+ * <pre>\n+ *    {&#064;snippet :\n+ *     body\n+ *    }\n+ *\n+ *    {&#064;snippet attributes}\n+ *\n+ *    {&#064;snippet attributes :\n+ *     body\n+ *    }\n+ * <\/pre>\n+ *\n+ * @since 18\n+ *\/\n+public interface SnippetTree extends InlineTagTree {\n+\n+    \/**\n+     * Returns the list of the attributes of the {@code @snippet} tag.\n+     *\n+     * @return the list of the attributes\n+     *\/\n+    List<? extends DocTree> getAttributes();\n+\n+    \/**\n+     * Returns the body of the {@code @snippet} tag, or {@code null} if there is no body.\n+     *\n+     * @apiNote\n+     * An instance of {@code SnippetTree} with an empty body differs from an\n+     * instance of {@code SnippetTree} with no body.\n+     * If a tag has no body, then calling this method returns {@code null}.\n+     * If a tag has an empty body, then this method returns a {@code TextTree}\n+     * whose {@link TextTree#getBody()} returns an empty string.\n+     *\n+     * @return the body of the tag, or {@code null} if there is no body\n+     *\/\n+    TextTree getBody();\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/doctree\/SnippetTree.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,0 +61,1 @@\n+import com.sun.source.doctree.SnippetTree;\n@@ -82,1 +83,1 @@\n-     * Creates a new {@code AttributeTree} object, to represent an HTML attribute in an HTML tag.\n+     * Creates a new {@code AttributeTree} object, to represent an attribute in an HTML element or tag.\n@@ -329,0 +330,9 @@\n+    \/**\n+     * Creates a new {@code SnippetTree} object, to represent a {@code {@snippet }} tag.\n+     * @param attributes the attributes of the tag\n+     * @param text the body of the tag, or {@code null} if the tag has no body (not to be confused with an empty body)\n+     * @return a {@code SnippetTree} object\n+     * @since 18\n+     *\/\n+    SnippetTree newSnippetTree(List<? extends DocTree> attributes, TextTree text);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/DocTreeFactory.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -503,0 +503,15 @@\n+     * @since 18\n+     *\/\n+    @Override\n+    public R visitSnippet(SnippetTree node, P p) {\n+        R r = scan(node.getAttributes(), p);\n+        r = scanAndReduce(node.getBody(), p, r);\n+        return r;\n+    }\n+\n+    \/**\n+     * {@inheritDoc} This implementation scans the children in left to right order.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/DocTreeScanner.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -459,0 +459,13 @@\n+     * @since 18\n+     *\/\n+    @Override\n+    public R visitSnippet(SnippetTree node, P p) {\n+        return defaultAction(node, p);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/SimpleDocTreeVisitor.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -888,0 +888,97 @@\n+    \/**\n+     * Read a series of inline tag attributes, terminated by {@code \":\"}\n+     * or the first unmatched <code>\"}\"<\/code>, whichever comes first.\n+     *\n+     * Each attribute is of the form {@literal identifier[=value]}.\n+     * \"value\" may be unquoted, single-quoted, or double-quoted.\n+     * @return the list of attributes\n+     *\/\n+    protected List<DCTree> tagAttrs() throws ParseException {\n+\n+        \/*\n+         * Unquoted values are a risky business: omitting quotes may result in\n+         * unexpected parsings. Users should prefer quoted values.\n+         *\n+         * If you decide to modify this code and the related spec(s), consider\n+         * the following.\n+         *\n+         * 1. It is unclear which characters should be included in an unquoted\n+         * value. On the one hand, the only precedent we have is the rules of\n+         * HTML (linked content as seen on 2021-MAY-12):\n+         *\n+         *     i. https:\/\/html.spec.whatwg.org\/multipage\/syntax.html#unquoted\n+         *    ii. https:\/\/www.w3.org\/TR\/html52\/syntax.html#attribute-value-unquoted-state\n+         *\n+         * On the other hand, those rules are tailored to HTML. For example,\n+         * while it makes sense to terminate an unquoted HTML attribute value\n+         * with characters such as < or fail attribute parsing when encounter >,\n+         * it makes less sense to do any of those for an unquoted attribute\n+         * value of a standard doclet tag.\n+         *\n+         * 2. An HTML attribute value is parsed recursively because it can use\n+         * character references (e.g. &commat;, &#064;, etc.) and, in our case,\n+         * standard doclet tags (see attrValueChar()). While this should\n+         * probably be considered on a case-by-case basis, for an attribute\n+         * value of the {@snippet} tag we do not recurse.\n+         *\/\n+        ListBuffer<DCTree> attrs = new ListBuffer<>();\n+        skipWhitespace();\n+\n+        loop:\n+        while (bp < buflen && isIdentifierStart(ch)) {\n+            int namePos = bp;\n+            Name name = readAttributeName();\n+            skipWhitespace();\n+            List<DCTree> value = null;\n+            ValueKind vkind = ValueKind.EMPTY;\n+            if (ch == '=') {\n+                ListBuffer<DCTree> v = new ListBuffer<>();\n+                nextChar();\n+                \/*\n+                 * The below skipWhitespace() handles optional whitespace.\n+                 * It was copied from HTML attribute value parsing, where it was\n+                 * introduced according to the HTML spec, perhaps for formatting\n+                 * purposes:\n+                 *\n+                 *   name=value vs name = value\n+                 *\n+                 * However, it might yield a problematic parsing. Consider two\n+                 * attributes, one unquoted and the other is boolean:\n+                 *\n+                 *   name1= name2\n+                 *\n+                 * The above is parsed effectively as if it were:\n+                 *\n+                 *   name1=\"name2\"\n+                 *\/\n+                skipWhitespace();\n+                if (ch == '\\'' || ch == '\"') {\n+                    newline = false;\n+                    vkind = (ch == '\\'') ? ValueKind.SINGLE : ValueKind.DOUBLE;\n+                    char quote = ch;\n+                    nextChar();\n+                    textStart = bp;\n+                    while (bp < buflen && ch != quote) {\n+                        nextChar();\n+                    }\n+                    addPendingText(v, bp - 1);\n+                    nextChar();\n+                } else {\n+                    vkind = ValueKind.UNQUOTED;\n+                    textStart = bp;\n+                    \/\/ Note: we stop on '}' for it to be re-consumed by the tag\n+                    while (bp < buflen && (ch != '}' && !isUnquotedAttrValueTerminator(ch))) {\n+                        nextChar();\n+                    }\n+                    addPendingText(v, bp - 1);\n+                }\n+                skipWhitespace();\n+                value = v.toList();\n+            }\n+            DCAttribute attr = m.at(namePos).newAttributeTree(name, vkind, value);\n+            attrs.add(attr);\n+        }\n+\n+        return attrs.toList();\n+    }\n+\n@@ -1001,0 +1098,8 @@\n+        return readGeneralAttributeName();\n+    }\n+\n+    protected Name readTagAttributeName() {\n+        return readGeneralAttributeName();\n+    }\n+\n+    protected Name readGeneralAttributeName() {\n@@ -1065,0 +1170,13 @@\n+    protected boolean isHorizontalWhitespace(char ch) {\n+        \/\/ Should `\\f` (FORM FEED) break a line? Relevant specifications have\n+        \/\/ different opinions on this:\n+        \/\/\n+        \/\/      No: https:\/\/docs.oracle.com\/javase\/specs\/jls\/se14\/html\/jls-3.html#jls-3.4\n+        \/\/     Yes: https:\/\/www.unicode.org\/versions\/Unicode13.0.0\/ch05.pdf, \"5.8 Newline Guidelines\"\n+        \/\/      No: https:\/\/html.spec.whatwg.org\/multipage\/syntax.html#newlines\n+        \/\/\n+        \/\/ This parser treats `\\f` as a line break (see `nextChar`). To be\n+        \/\/ consistent with that behaviour, this method does the same.\n+        return ch == ' ' || ch == '\\t' \/* || ch == '\\f'*\/;\n+    }\n+\n@@ -1400,0 +1518,35 @@\n+            \/\/ {@snippet attributes :\n+            \/\/  body}\n+            new TagParser(TagParser.Kind.INLINE, DCTree.Kind.SNIPPET) {\n+                @Override\n+                DCTree parse(int pos) throws ParseException {\n+                    skipWhitespace();\n+                    List<DCTree> attributes = tagAttrs();\n+                    \/\/ expect \"}\" or \":\"\n+                    if (ch == '}') {\n+                        nextChar();\n+                        return m.at(pos).newSnippetTree(attributes, null);\n+                    } else if (ch == ':') {\n+                        newline = false;\n+                        \/\/ consume ':'\n+                        nextChar();\n+                        \/\/ better still reuse JavaTokenizer here\n+                        \/\/ expect optional whitespace followed by a mandatory newline\n+                        while (bp < buflen && isHorizontalWhitespace(ch)) {\n+                            nextChar();\n+                        }\n+                        \/\/ check that we are looking at a line break\n+                        if (!newline) {\n+                            throw new ParseException(\"dc.unexpected.content\");\n+                        }\n+                        \/\/ consume that line break\n+                        nextChar();\n+                        DCText text = inlineText(WhitespaceRetentionPolicy.RETAIN_ALL);\n+                        nextChar();\n+                        return m.at(pos).newSnippetTree(attributes, text);\n+                    } else {\n+                        throw new ParseException(\"dc.unexpected.content\");\n+                    }\n+                }\n+            },\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/DocCommentParser.java","additions":154,"deletions":1,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -860,0 +860,30 @@\n+    public static class DCSnippet extends DCInlineTag implements SnippetTree {\n+        public final List<? extends DocTree> attributes;\n+        public final DCText body;\n+\n+        public DCSnippet(List<DCTree> attributes, DCText body) {\n+            this.body = body;\n+            this.attributes = attributes;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public Kind getKind() {\n+            return Kind.SNIPPET;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public <R, D> R accept(DocTreeVisitor<R, D> v, D d) {\n+            return v.visitSnippet(this, d);\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public List<? extends DocTree> getAttributes() {\n+            return attributes;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public TextTree getBody() {\n+            return body;\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/DCTree.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -493,0 +493,21 @@\n+    @Override @DefinedBy(Api.COMPILER_TREE)\n+    public Void visitSnippet(SnippetTree node, Void p) {\n+        try {\n+            print(\"{\");\n+            printTagName(node);\n+            List<? extends DocTree> attrs = node.getAttributes();\n+            if (!attrs.isEmpty()) {\n+                print(\" \");\n+                print(attrs, \" \");\n+            }\n+            if (node.getBody() != null) {\n+                print(\" :\\n\");\n+                print(node.getBody());\n+            }\n+            print(\"}\");\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+        return null;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/DocPretty.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import java.util.EnumSet;\n@@ -79,0 +78,1 @@\n+import com.sun.tools.javac.tree.DCTree.DCSnippet;\n@@ -434,0 +434,7 @@\n+    @Override @DefinedBy(Api.COMPILER_TREE)\n+    public DCSnippet newSnippetTree(List<? extends DocTree> attributes, TextTree text) {\n+        DCSnippet tree = new DCSnippet(cast(attributes), (DCText) text);\n+        tree.pos = pos;\n+        return tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/DocTreeMaker.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1147,0 +1147,127 @@\n+    \/\/ TODO: this method and seeTagToContent share much of the code; consider factoring common pieces out\n+    public Content linkToContent(Element referrer, Element target, String targetSignature, String text) {\n+        CommentHelper ch = utils.getCommentHelper(referrer);\n+\n+        boolean isLinkPlain = false; \/\/ FIXME: for now\n+        Content labelContent = plainOrCode(isLinkPlain, Text.of(text));\n+\n+        TypeElement refClass = ch.getReferencedClass(target);\n+        Element refMem =       ch.getReferencedMember(target);\n+        String refMemName =    ch.getReferencedMemberName(targetSignature);\n+\n+        if (refMemName == null && refMem != null) {\n+            refMemName = refMem.toString();\n+        }\n+        if (refClass == null) {\n+            ModuleElement refModule = ch.getReferencedModule(target);\n+            if (refModule != null && utils.isIncluded(refModule)) {\n+                return getModuleLink(refModule, labelContent);\n+            }\n+            \/\/@see is not referencing an included class\n+            PackageElement refPackage = ch.getReferencedPackage(target);\n+            if (refPackage != null && utils.isIncluded(refPackage)) {\n+                \/\/@see is referencing an included package\n+                if (labelContent.isEmpty())\n+                    labelContent = plainOrCode(isLinkPlain,\n+                                               Text.of(refPackage.getQualifiedName()));\n+                return getPackageLink(refPackage, labelContent);\n+            } else {\n+                \/\/ @see is not referencing an included class, module or package. Check for cross links.\n+                String refModuleName =  ch.getReferencedModuleName(targetSignature);\n+                DocLink elementCrossLink = (refPackage != null) ? getCrossPackageLink(refPackage) :\n+                        (configuration.extern.isModule(refModuleName))\n+                                ? getCrossModuleLink(utils.elementUtils.getModuleElement(refModuleName))\n+                                : null;\n+                if (elementCrossLink != null) {\n+                    \/\/ Element cross link found\n+                    return links.createExternalLink(elementCrossLink, labelContent);\n+                } else {\n+                    \/\/ No cross link found so print warning\n+\/\/ FIXME:\n+\/\/                    messages.warning(ch.getDocTreePath(see),\n+\/\/                                     \"doclet.see.class_or_package_not_found\",\n+\/\/                                     \"@\" + tagName,\n+\/\/                                     seeText);\n+                    return labelContent;\n+                }\n+            }\n+        } else if (refMemName == null) {\n+            \/\/ Must be a class reference since refClass is not null and refMemName is null.\n+            if (labelContent.isEmpty()) {\n+                if (!refClass.getTypeParameters().isEmpty() && targetSignature.contains(\"<\")) {\n+                    \/\/ If this is a generic type link try to use the TypeMirror representation.\n+\n+\/\/ FIXME\n+\/\/                  TypeMirror refType = ch.getReferencedType(target);\n+                    TypeMirror refType = target.asType();\n+\n+                    if (refType != null) {\n+                        return plainOrCode(isLinkPlain, getLink(\n+                                new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.DEFAULT, refType)));\n+                    }\n+                }\n+                labelContent = plainOrCode(isLinkPlain, Text.of(utils.getSimpleName(refClass)));\n+            }\n+            return getLink(new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.DEFAULT, refClass)\n+                                   .label(labelContent));\n+        } else if (refMem == null) {\n+            \/\/ Must be a member reference since refClass is not null and refMemName is not null.\n+            \/\/ However, refMem is null, so this referenced member does not exist.\n+            return labelContent;\n+        } else {\n+            \/\/ Must be a member reference since refClass is not null and refMemName is not null.\n+            \/\/ refMem is not null, so this @see tag must be referencing a valid member.\n+            TypeElement containing = utils.getEnclosingTypeElement(refMem);\n+\n+            \/\/ Find the enclosing type where the method is actually visible\n+            \/\/ in the inheritance hierarchy.\n+            ExecutableElement overriddenMethod = null;\n+            if (refMem.getKind() == ElementKind.METHOD) {\n+                VisibleMemberTable vmt = configuration.getVisibleMemberTable(containing);\n+                overriddenMethod = vmt.getOverriddenMethod((ExecutableElement)refMem);\n+\n+                if (overriddenMethod != null)\n+                    containing = utils.getEnclosingTypeElement(overriddenMethod);\n+            }\n+            if (targetSignature.trim().startsWith(\"#\") &&\n+                    ! (utils.isPublic(containing) || utils.isLinkable(containing))) {\n+                \/\/ Since the link is relative and the holder is not even being\n+                \/\/ documented, this must be an inherited link.  Redirect it.\n+                \/\/ The current class either overrides the referenced member or\n+                \/\/ inherits it automatically.\n+                if (this instanceof ClassWriterImpl writer) {\n+                    containing = writer.getTypeElement();\n+                } else if (!utils.isPublic(containing)) {\n+\/\/ FIXME\n+\/\/                    messages.warning(\n+\/\/                            ch.getDocTreePath(see), \"doclet.see.class_or_package_not_accessible\",\n+\/\/                            tagName, utils.getFullyQualifiedName(containing));\n+                } else {\n+\/\/ FIXME\n+\/\/                    messages.warning(\n+\/\/                            ch.getDocTreePath(see), \"doclet.see.class_or_package_not_found\",\n+\/\/                            tagName, seeText);\n+                }\n+            }\n+            if (configuration.currentTypeElement != containing) {\n+                refMemName = (utils.isConstructor(refMem))\n+                        ? refMemName\n+                        : utils.getSimpleName(containing) + \".\" + refMemName;\n+            }\n+            if (utils.isExecutableElement(refMem)) {\n+                if (refMemName.indexOf('(') < 0) {\n+                    refMemName += utils.makeSignature((ExecutableElement) refMem, null, true);\n+                }\n+                if (overriddenMethod != null) {\n+                    \/\/ The method to actually link.\n+                    refMem = overriddenMethod;\n+                }\n+            }\n+\n+            return getDocLink(HtmlLinkInfo.Kind.SEE_TAG, containing,\n+                              refMem, (labelContent.isEmpty()\n+                            ? plainOrCode(isLinkPlain, Text.of(text))\n+                            : labelContent), null, false);\n+        }\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.HashSet;\n@@ -50,0 +51,1 @@\n+import com.sun.source.doctree.SnippetTree;\n@@ -52,0 +54,1 @@\n+import com.sun.source.util.DocTreePath;\n@@ -66,0 +69,2 @@\n+import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.parser.Style;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.text.AnnotatedText;\n@@ -377,0 +382,72 @@\n+    @Override\n+    protected Content snippetTagOutput(Element element, SnippetTree tag, AnnotatedText<Style> content) {\n+        HtmlTree result = new HtmlTree(TagName.PRE).setStyle(HtmlStyle.snippet);\n+        result.add(Text.of(utils.normalizeNewlines(\"\\n\")));\n+        content.consumeBy((styles, sequence) -> {\n+            CharSequence text = utils.normalizeNewlines(sequence);\n+            if (styles.isEmpty()) {\n+                result.add(text);\n+            } else {\n+                Element e = null;\n+                String t = null;\n+                boolean linkEncountered = false;\n+                Set<String> classes = new HashSet<>();\n+                for (Style s : styles) {\n+                    if (s instanceof Style.Name n) {\n+                        classes.add(n.name());\n+                    } else if (s instanceof Style.Link l) {\n+                        assert !linkEncountered; \/\/ FIXME: do not assert; pick the first link\n+                        linkEncountered = true;\n+                        t = l.target();\n+                        e = getLinkedElement(element, t);\n+                        if (e == null) {\n+                            \/\/ diagnostic output\n+                        }\n+                    } else if (s instanceof Style.Markup) {\n+                    } else {\n+                        \/\/ TODO wait for sealed types for exhaustiveness\n+                        throw new AssertionError(styles);\n+                    }\n+                }\n+                Content c;\n+                if (linkEncountered) {\n+                    assert e != null;\n+                    String line = sequence.toString();\n+                    String strippedLine = line.strip();\n+                    int idx = line.indexOf(strippedLine);\n+                    assert idx >= 0; \/\/ because the stripped line is a substring of the line being stripped\n+                    Text whitespace = Text.of(line.substring(0, idx));\n+                    \/\/ If the leading whitespace is not excluded from the link,\n+                    \/\/ browsers might exhibit unwanted behavior. For example, a\n+                    \/\/ browser might display hand-click cursor while user hovers\n+                    \/\/ over that whitespace portion of the line; or use\n+                    \/\/ underline decoration.\n+                    c = new ContentBuilder(whitespace, htmlWriter.linkToContent(element, e, t, strippedLine));\n+                    \/\/ We don't care about trailing whitespace.\n+                } else {\n+                    c = HtmlTree.SPAN(Text.of(sequence));\n+                    classes.forEach(((HtmlTree) c)::addStyle);\n+                }\n+                result.add(c);\n+            }\n+        });\n+        return result;\n+    }\n+\n+    \/*\n+     * Returns the element that is linked from the context of the referrer using\n+     * the provided signature; returns null if such element could not be found.\n+     *\n+     * This method is to be used when it's the target of the link that is\n+     * important, not the container of the link (e.g. was it an @see,\n+     * @link\/@linkplain or @snippet tags, etc.)\n+     *\/\n+    public Element getLinkedElement(Element referer, String signature) {\n+        var factory = utils.docTrees.getDocTreeFactory();\n+        var docCommentTree = utils.getDocCommentTree(referer);\n+        var rootPath = new DocTreePath(utils.getTreePath(referer), docCommentTree);\n+        var reference = factory.newReferenceTree(signature);\n+        var fabricatedPath = new DocTreePath(rootPath, reference);\n+        return utils.docTrees.getElement(fabricatedPath);\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TagletWriterImpl.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -78,0 +78,10 @@\n+    \/\/<editor-fold desc=\"not-yet-categorized\">\n+    \/\/\n+    \/\/ The following constants are to be categorized.\n+\n+    \/**\n+     * The class of the {@code pre} element presenting a snippet.\n+     *\/\n+    snippet,\n+    \/\/<\/editor-fold>\n+\n@@ -806,0 +816,1 @@\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/HtmlStyle.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -538,0 +538,3 @@\n+doclet.usage.tagletpath.parameters=\\\n+    <path>\n+\n@@ -539,1 +542,7 @@\n-    The path to Taglets\n+    The path for custom taglets\n+\n+doclet.usage.snippet-path.parameters=\\\n+    <path>\n+\n+doclet.usage.snippet-path.description=\\\n+    The path for external snippets\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard.properties","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.io.File;\n@@ -31,0 +32,2 @@\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Path;\n@@ -32,0 +35,1 @@\n+import java.util.Arrays;\n@@ -53,0 +57,1 @@\n+import javax.tools.DocumentationTool;\n@@ -55,0 +60,1 @@\n+import javax.tools.StandardJavaFileManager;\n@@ -377,0 +383,22 @@\n+\n+        String snippetPath = options.snippetPath();\n+        if (snippetPath != null) {\n+            Messages messages = getMessages();\n+            JavaFileManager fm = getFileManager();\n+            if (fm instanceof StandardJavaFileManager) {\n+                try {\n+                    List<Path> sp = Arrays.stream(snippetPath.split(File.pathSeparator))\n+                            .map(Path::of)\n+                            .toList();\n+                    StandardJavaFileManager sfm = (StandardJavaFileManager) fm;\n+                    sfm.setLocationFromPaths(DocumentationTool.Location.SNIPPET_PATH, sp);\n+                } catch (IOException | InvalidPathException e) {\n+                    throw new SimpleDocletException(messages.getResources().getText(\n+                            \"doclet.error_setting_snippet_path\", snippetPath, e), e);\n+                }\n+            } else {\n+                throw new SimpleDocletException(messages.getResources().getText(\n+                        \"doclet.cannot_use_snippet_path\", snippetPath));\n+            }\n+        }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/BaseConfiguration.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -285,0 +285,6 @@\n+    \/**\n+     * Argument for command-line option {@code --snippet-path}.\n+     * The path for external snippets.\n+     *\/\n+    private String snippetPath = null;\n+\n@@ -557,0 +563,8 @@\n+                new Option(resources, \"--snippet-path\", 1) {\n+                    @Override\n+                    public boolean process(String opt, List<String> args) {\n+                        snippetPath = args.get(0);\n+                        return true;\n+                    }\n+                },\n+\n@@ -965,0 +979,8 @@\n+    \/**\n+     * Argument for command-line option {@code --snippet-path}.\n+     * The path to for external snippets.\n+     *\/\n+    public String snippetPath() {\n+        return snippetPath;\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/BaseOptions.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+import com.sun.source.doctree.LinkTree;\n@@ -126,0 +127,10 @@\n+    public LinkTree makeLinkTree(String sig, String label) {\n+        ReferenceTree ref = treeFactory.newReferenceTree(sig);\n+        return treeFactory.newLinkTree(ref, List.of(makeTextTree(label)));\n+    }\n+\n+    public LinkTree makeLinkPlainTree(String sig, String label) {\n+        ReferenceTree ref = treeFactory.newReferenceTree(sig);\n+        return treeFactory.newLinkPlainTree(ref, List.of(makeTextTree(label)));\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/CommentUtils.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -345,1 +345,30 @@\n-doclet.search.search_tags=Search Tags\n\\ No newline at end of file\n+doclet.search.search_tags=Search Tags\n+\n+doclet.snippet.contents.none=\\\n+ @snippet does not specify contents\n+\n+doclet.snippet.contents.ambiguity.external=\\\n+ @snippet specifies multiple external contents, which is ambiguous\n+\n+doclet.snippet.region.not_found=\\\n+ region not found: \"{0}\"\n+\n+doclet.tag.attribute.value.illegal=\\\n+ illegal value for attribute \"{0}\": \"{1}\"\n+\n+doclet.tag.attribute.repeated=\\\n+ repeated attribute: \"{0}\"\n+\n+doclet.snippet.contents.mismatch=\\\n+ contents mismatch:\\n{0}\n+\n+doclet.snippet.markup=\\\n+ snippet markup error: \"{0}\"\n+\n+# 0: path\n+doclet.cannot_use_snippet_path=\\\n+  Cannot use ''--snippet-path'' option with the given file manager: {0}\n+\n+# 0: path; 1: exception\n+doclet.error_setting_snippet_path=\\\n+  Error setting snippet path {0}: {1}\n\\ No newline at end of file\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets.properties","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -866,0 +866,21 @@\n+\n+pre.snippet {\n+    background-color: #e8e8e8;\n+    padding: 10px;\n+    margin: 12px 0;\n+    overflow: auto;\n+    white-space: pre;\n+}\n+\n+.italic {\n+    font-style: italic;\n+}\n+\n+.bold {\n+    font-weight: bold;\n+}\n+\n+.highlighted {\n+    background-color: sandybrown;\n+    border-radius: 10%;\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/stylesheet.css","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,347 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.toolkit.taglets;\n+\n+import com.sun.source.doctree.AttributeTree;\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.SnippetTree;\n+import com.sun.source.doctree.TextTree;\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.DocletElement;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.action.Action;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.parser.ParseException;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.parser.Parser;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.parser.Style;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.text.AnnotatedText;\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.PackageElement;\n+import javax.tools.Diagnostic;\n+import javax.tools.DocumentationTool.Location;\n+import javax.tools.FileObject;\n+import javax.tools.JavaFileManager;\n+import java.io.IOException;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class SnippetTaglet extends BaseTaglet {\n+\n+    public SnippetTaglet() {\n+        super(DocTree.Kind.SNIPPET, true, EnumSet.allOf(Taglet.Location.class));\n+    }\n+\n+    \/*\n+     * A snippet can specify content by value or by reference.\n+     *\n+     * To specify content by value, a snippet uses its body; the body of a snippet is the content.\n+     * To specify content by reference, a snippet uses either the \"class\" or \"file\" attribute;\n+     * the value of that attribute refers to the content.\n+     *\n+     * A snippet can specify the \"region\" attribute. That attribute refines the location of the content.\n+     * The value of that attribute must match one of the named regions in the snippets content.\n+     *\/\n+    @Override\n+    public Content getInlineTagOutput(Element holder, DocTree tag, TagletWriter writer) {\n+        SnippetTree snippetTag = (SnippetTree) tag;\n+\n+        Map<String, AttributeTree> attributes = new HashMap<>();\n+\n+        \/\/ organize attributes in a map, performing basic checks along the way\n+        for (DocTree d : snippetTag.getAttributes()) {\n+            if (!(d instanceof AttributeTree a)) {\n+                continue; \/\/ this might be an ErroneousTree\n+            }\n+            if (attributes.putIfAbsent(a.getName().toString(), a) == null) {\n+                continue;\n+            }\n+            \/\/ two like-named attributes found; although we report on the most\n+            \/\/ recently encountered of two, the iteration order might differ\n+            \/\/ from the source order\n+            error(writer, holder, a, \"doclet.tag.attribute.repeated\", a.getName().toString());\n+            return badSnippet(writer);\n+        }\n+\n+        final String CLASS = \"class\";\n+        final String FILE = \"file\";\n+\n+        final boolean containsClass = attributes.containsKey(CLASS);\n+        final boolean containsFile = attributes.containsKey(FILE);\n+        final boolean containsBody = snippetTag.getBody() != null;\n+\n+        if (containsClass && containsFile) {\n+            error(writer, holder, attributes.get(CLASS), \"doclet.snippet.contents.ambiguity.external\");\n+            return badSnippet(writer);\n+        } else if (!containsClass && !containsFile && !containsBody) {\n+            error(writer, holder, tag, \"doclet.snippet.contents.none\");\n+            return badSnippet(writer);\n+        }\n+\n+        String r = null;\n+        AttributeTree region = attributes.get(\"region\");\n+        if (region != null) {\n+            r = stringOf(region.getValue());\n+            if (r.isBlank()) {\n+                error(writer, holder, region, \"doclet.tag.attribute.value.illegal\", \"region\", region.getValue());\n+                return badSnippet(writer);\n+            }\n+        }\n+\n+        String inlineContent = null, externalContent = null;\n+\n+        if (containsBody) {\n+            inlineContent = snippetTag.getBody().getBody();\n+        }\n+\n+        FileObject fileObject = null;\n+\n+        if (containsFile || containsClass) {\n+            AttributeTree a;\n+            String v = containsFile\n+                    ? stringOf((a = attributes.get(FILE)).getValue())\n+                    : stringOf((a = attributes.get(CLASS)).getValue()).replace(\".\", \"\/\") + \".java\";\n+\n+            if (v.isBlank()) {\n+                error(writer, holder, a, \"doclet.tag.attribute.value.illegal\", containsFile ? FILE : CLASS, v);\n+            }\n+\n+            \/\/ we didn't create JavaFileManager, so we won't close it; even if an error occurs\n+            var fileManager = writer.configuration().getFileManager();\n+\n+            \/\/ first, look in local snippet-files subdirectory\n+            Utils utils = writer.configuration().utils;\n+            PackageElement pkg = getPackageElement(holder, utils);\n+            JavaFileManager.Location l = utils.getLocationForPackage(pkg);\n+            String relativeName = \"snippet-files\/\" + v;\n+            String packageName = packageName(pkg, utils);\n+            try {\n+                fileObject = fileManager.getFileForInput(l, packageName, relativeName);\n+\n+                \/\/ if not found in local snippet-files directory, look on snippet path\n+                if (fileObject == null && fileManager.hasLocation(Location.SNIPPET_PATH)) {\n+                    fileObject = fileManager.getFileForInput(Location.SNIPPET_PATH, \"\", v);\n+                }\n+            } catch (IOException | IllegalArgumentException e) {\n+                \/\/ JavaFileManager.getFileForInput can throw IllegalArgumentException in certain cases\n+                error(writer, holder, a, \"doclet.exception.read.file\", v, e.getCause());\n+                return badSnippet(writer);\n+            }\n+\n+            if (fileObject == null) { \/* i.e. the file does not exist *\/\n+                error(writer, holder, a, \"doclet.File_not_found\", v);\n+                return badSnippet(writer);\n+            }\n+\n+            try {\n+                externalContent = fileObject.getCharContent(true).toString();\n+            } catch (IOException e) {\n+                error(writer, holder, a, \"doclet.exception.read.file\", fileObject.getName(), e.getCause());\n+                return badSnippet(writer);\n+            }\n+        }\n+\n+        \/\/ FIXME cache parsed external snippet (WeakHashMap)\n+\n+        AnnotatedText<Style> inlineSnippet = null;\n+        AnnotatedText<Style> externalSnippet = null;\n+\n+        try {\n+            if (inlineContent != null) {\n+                inlineSnippet = parse(inlineContent);\n+            }\n+        } catch (ParseException e) {\n+            var path = writer.configuration().utils.getCommentHelper(holder).getDocTreePath(snippetTag.getBody());\n+            \/\/ FIXME: there should be a method in Messages; that method should mirror Reporter's; use that method instead accessing Reporter.\n+            String msg = writer.configuration().getDocResources().getText(\"doclet.snippet.markup\", e.getMessage());\n+            writer.configuration().getReporter().print(Diagnostic.Kind.ERROR, path, e.getPosition(), e.getPosition(), e.getPosition(), msg);\n+            return badSnippet(writer);\n+        }\n+\n+        try {\n+            if (externalContent != null) {\n+                externalSnippet = parse(externalContent);\n+            }\n+        } catch (ParseException e) {\n+            assert fileObject != null;\n+            writer.configuration().getMessages().error(\n+                    fileObject, e.getPosition(), e.getPosition(), e.getPosition(), \"doclet.snippet.markup\", e.getMessage());\n+            return badSnippet(writer);\n+        }\n+\n+        \/\/ the region must be matched at least in one content: it can be matched\n+        \/\/ in both, but never in none\n+        if (r != null) {\n+            AnnotatedText<Style> r1 = null;\n+            AnnotatedText<Style> r2 = null;\n+            if (inlineSnippet != null) {\n+                r1 = inlineSnippet.getBookmarkedText(r);\n+                if (r1 != null) {\n+                    inlineSnippet = r1;\n+                }\n+            }\n+            if (externalSnippet != null) {\n+                r2 = externalSnippet.getBookmarkedText(r);\n+                if (r2 != null) {\n+                    externalSnippet = r2;\n+                }\n+            }\n+            if (r1 == null && r2 == null) {\n+                error(writer, holder, tag, \"doclet.snippet.region.not_found\", r);\n+                return badSnippet(writer);\n+            }\n+        }\n+\n+        if (inlineSnippet != null) {\n+            inlineSnippet = toDisplayForm(inlineSnippet);\n+        }\n+\n+        if (externalSnippet != null) {\n+            externalSnippet = toDisplayForm(externalSnippet);\n+        }\n+\n+        if (inlineSnippet != null && externalSnippet != null) {\n+            String inlineStr = inlineSnippet.asCharSequence().toString();\n+            String externalStr = externalSnippet.asCharSequence().toString();\n+            if (!Objects.equals(inlineStr, externalStr)) {\n+                error(writer, holder, tag, \"doclet.snippet.contents.mismatch\", diff(inlineStr, externalStr));\n+                \/\/ output one above the other\n+                return badSnippet(writer);\n+            }\n+        }\n+\n+        assert inlineSnippet != null || externalSnippet != null;\n+        AnnotatedText<Style> text = inlineSnippet != null ? inlineSnippet : externalSnippet;\n+\n+        return writer.snippetTagOutput(holder, snippetTag, text);\n+    }\n+\n+    \/*\n+     * Maybe there's a case for implementing a proper (or at least more helpful)\n+     * diff view, but for now simply outputting both sides of a hybrid snippet\n+     * would do. Users could then use diff tools to compare those sides.\n+     *\n+     * There's a separate issue of mapping discrepancies back to their\n+     * originating source in the doc comment and the external file. Maybe there\n+     * is a value in it, or may be there isn't. In any case, accurate mapping\n+     * would be not trivial to code.\n+     *\/\n+    private static String diff(String inline, String external) {\n+        return \"\"\"\n+               ----------------- inline -------------------\n+               %s\n+               ----------------- external -----------------\n+               %s\n+               \"\"\".formatted(inline, external);\n+    }\n+\n+    private AnnotatedText<Style> parse(String content) throws ParseException {\n+        \/\/ FIXME: need to be able to process more fine-grained, i.e. around a particular region...\n+        \/\/ or, which is even better, cache the styled text\n+        Parser.Result result = new Parser().parse(content);\n+        result.actions().forEach(Action::perform);\n+        return result.text();\n+    }\n+\n+    private static String stringOf(List<? extends DocTree> value) {\n+        return value.stream()\n+                .map(t -> ((TextTree) t).getBody()) \/\/ value consists of TextTree nodes\n+                .collect(Collectors.joining());\n+    }\n+\n+    \/\/ FIXME: figure out how to do that correctly\n+    \/\/ FIXME: consider returning null from this method so it can be used as oneliner\n+    private void error(TagletWriter writer, Element holder, DocTree tag, String key, Object... args) {\n+        writer.configuration().getMessages().error(\n+                writer.configuration().utils.getCommentHelper(holder).getDocTreePath(tag), key, args);\n+    }\n+\n+    private Content badSnippet(TagletWriter writer) {\n+        return writer.getOutputInstance().add(\"bad snippet\");\n+    }\n+\n+    private String packageName(PackageElement pkg, Utils utils) {\n+        return utils.getPackageName(pkg);\n+    }\n+\n+    private static PackageElement getPackageElement(Element e, Utils utils) {\n+        if (e instanceof DocletElement de) {\n+            return de.getPackageElement();\n+        } else {\n+            return utils.elementUtils.getPackageOf(e);\n+        }\n+    }\n+\n+    \/*\n+     * Returns a version of annotated text that can be rendered into HTML or\n+     * compared to another such version. The latter is used to decide if inline\n+     * and external parts of a hybrid snippet match.\n+     *\n+     * Use this method to obtain a final version of text. After all\n+     * transformations on text have been performed, call this method with that\n+     * text and then use the returned result as described above.\n+     *\/\n+    private static <T> AnnotatedText<T> toDisplayForm(AnnotatedText<T> source) {\n+        var sourceString = source.asCharSequence().toString();\n+        var result = new AnnotatedText<T>();\n+        var originalLines = sourceString.lines().iterator();\n+        var unindentedLines = sourceString.stripIndent().lines().iterator();\n+        \/\/ done; the rest of the method translates the stripIndent\n+        \/\/ transformation performed on a character sequence to the annotated\n+        \/\/ text that this sequence originates from, line by line\n+        int pos = 0;\n+        \/\/ overcome a \"quirk\" of String.lines\n+        boolean endsWithLineFeed = !sourceString.isEmpty() && sourceString.charAt(source.length() - 1) == '\\n';\n+        while (originalLines.hasNext() && unindentedLines.hasNext()) { \/\/ [^1]\n+            String originalLine = originalLines.next();\n+            String unindentedLine = unindentedLines.next();\n+            \/\/ the search MUST succeed\n+            int idx = originalLine.indexOf(unindentedLine);\n+            \/\/ assume newlines are always of the \\n form\n+            \/\/ append the found fragment\n+            result.append(source.subText(pos + idx, pos + idx + unindentedLine.length()));\n+            \/\/ append the possibly annotated newline, but not if it's the last line\n+            int eol = pos + originalLine.length();\n+            if (originalLines.hasNext() || endsWithLineFeed) {\n+                result.append(source.subText(eol, eol + 1));\n+            }\n+            pos = eol + 1;\n+        }\n+        return result;\n+        \/\/ [^1]: Checking hasNext() on both iterators might look unnecessary.\n+        \/\/ However, there are strings for which those iterators return different\n+        \/\/ number of lines. That is, there exists a string s, such that\n+        \/\/\n+        \/\/     s.lines().count() != s.stripIndent().lines().count()\n+        \/\/\n+        \/\/ The most trivial example of such a string is \" \". In fact, any string\n+        \/\/ with a trailing non-empty blank line would do.\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SnippetTaglet.java","additions":347,"deletions":0,"binary":false,"changes":347,"status":"added"},{"patch":"@@ -658,0 +658,1 @@\n+        addStandardTaglet(new SnippetTaglet());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/TagletManager.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import com.sun.source.doctree.SnippetTree;\n@@ -47,0 +48,2 @@\n+import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.parser.Style;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.text.AnnotatedText;\n@@ -177,0 +180,10 @@\n+    \/**\n+     * Returns the output for a {@code {@snippet ...}} tag.\n+     *\n+     * @param element    The element that owns the doc comment\n+     * @param snippetTag the snippet tag\n+     *\n+     * @return the output\n+     *\/\n+    protected abstract Content snippetTagOutput(Element element, SnippetTree snippetTag, AnnotatedText<Style> text);\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/TagletWriter.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.toolkit.taglets.snippet.action;\n+\n+\/\/ FIXME: uncomment \/* sealed *\/ when minimum boot version >= 17\n+public \/* sealed *\/ interface Action \/* permits Annotate, Bookmark, Replace *\/ {\n+\n+    void perform();\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/action\/Action.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.toolkit.taglets.snippet.action;\n+\n+import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.text.AnnotatedText;\n+\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public final class Annotate implements Action {\n+\n+    private final Runnable action;\n+\n+    public <S> Annotate(S obj, Pattern pattern, AnnotatedText<S> text) {\n+        \/\/ This *constructor* is generified and the generic parameter is\n+        \/\/ captured by the Runnable to type-safely call text.annotate(obj)\n+        \/\/ later. An alternative would be to generify this *class* so as to\n+        \/\/ capture the generic parameter in this class' instance fields.\n+        \/\/ However, generifying the class would unduly force its clients to deal\n+        \/\/ with the generic parameter, whose *sole* purpose is to ensure that\n+        \/\/ the passed obj is of the type of objects that the passed text can be\n+        \/\/ annotated with.\n+        action = new Runnable() {\n+            @Override\n+            public void run() {\n+                Set<S> s = Set.of(obj);\n+                Matcher matcher = pattern.matcher(text.asCharSequence());\n+                while (matcher.find()) {\n+                    int start = matcher.start();\n+                    int end = matcher.end();\n+                    text.subText(start, end).annotate(s);\n+                }\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public void perform() {\n+        action.run();\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/action\/Annotate.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.toolkit.taglets.snippet.action;\n+\n+import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.text.AnnotatedText;\n+\n+public final class Bookmark implements Action {\n+\n+    private final String name;\n+    private final AnnotatedText<?> text;\n+\n+    public Bookmark(String name, AnnotatedText<?> text) {\n+        this.name = name;\n+        this.text = text;\n+    }\n+\n+    @Override\n+    public void perform() {\n+        text.subText(0, text.length()).bookmark(name);\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/action\/Bookmark.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.toolkit.taglets.snippet.action;\n+\n+import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.text.AnnotatedText;\n+\n+import java.util.ArrayList;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public final class Replace implements Action {\n+\n+    private final Pattern pattern;\n+    private final String replacement;\n+    private final AnnotatedText<?> text;\n+\n+    public Replace(String replacement, Pattern pattern, AnnotatedText<?> text) {\n+        this.replacement = replacement;\n+        this.pattern = pattern;\n+        this.text = text;\n+    }\n+\n+    @Override\n+    public void perform() {\n+        record Replacement(int start, int end, String value) { }\n+        \/\/ until JDK-8261619 is resolved, translating replacements requires some\n+        \/\/ amount of waste and careful index manipulation\n+        String textString = text.asCharSequence().toString();\n+        Matcher matcher = pattern.matcher(textString);\n+        var replacements = new ArrayList<Replacement>();\n+        StringBuilder b = new StringBuilder();\n+        int off = 0; \/\/ offset because of the replacements (can be negative)\n+        while (matcher.find()) {\n+            int start = matcher.start();\n+            int end = matcher.end();\n+            \/\/ replacements are computed as they may have special symbols\n+            matcher.appendReplacement(b, replacement);\n+            String s = b.substring(start + off);\n+            off = b.length() - end;\n+            replacements.add(new Replacement(start, end, s));\n+        }\n+        \/\/ there's no need to call matcher.appendTail(b)\n+        for (int i = replacements.size() - 1; i >= 0; i--) {\n+            Replacement r = replacements.get(i);\n+            text.subText(r.start, r.end).replace(Set.of(), r.value);\n+        }\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/action\/Replace.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.toolkit.taglets.snippet.parser;\n+\n+import java.util.Objects;\n+\n+\/*\n+ * 1. The hierarchy of attributes is modelled as\n+ *\n+ *     Attribute\n+ *     |\n+ *     +- Valueless\n+ *     |\n+ *     +- Valued\n+ *\n+ * not as\n+ *\n+ *     Attribute (Valueless)\n+ *     |\n+ *     +- Valued\n+ *\n+ * because in conjunction with query operations of `Attributes`, `Valued` and\n+ * `Valueless` should be more useful if neither is a subtype of the other.\n+ *\n+ * 2. `Attribute` is abstract because its sole purpose is to be a category.\n+ *\n+ * 3. This attribute abstraction is simpler than that of com.sun.source.doctree.AttributeTree.\n+ * There's no need to have recursive structure similar to that of allowed by AttributeTree.\n+ *\/\n+\/\/ FIXME: uncomment \/* sealed *\/ when minimum boot version >= 17\n+public \/* sealed *\/ abstract class Attribute {\n+\n+    private final String name;\n+\n+    private final int nameStartPosition;\n+\n+    private Attribute(String name, int nameStartPosition) {\n+        this.name = Objects.requireNonNull(name);\n+        this.nameStartPosition = nameStartPosition;\n+    }\n+\n+    String name() {\n+        return name;\n+    }\n+\n+    int nameStartPosition() {\n+        return nameStartPosition;\n+    }\n+\n+    \/*\n+     * `Valued` can be later extended by classes such as DoublyQuoted,\n+     * SinglyQuoted or Unquoted to form a (sealed) hierarchy. In that case,\n+     * `Valued` should become abstract similarly to `Attribute`.\n+     *\/\n+    final static class Valued extends Attribute {\n+\n+        private final String value;\n+\n+        private final int valueStartPosition;\n+\n+        Valued(String name, String value, int namePosition, int valueStartPosition) {\n+            super(name, namePosition);\n+            this.value = Objects.requireNonNull(value);\n+            this.valueStartPosition = valueStartPosition;\n+        }\n+\n+        String value() {\n+            return value;\n+        }\n+\n+        public int valueStartPosition() {\n+            return valueStartPosition;\n+        }\n+    }\n+\n+    final static class Valueless extends Attribute {\n+\n+        Valueless(String name, int nameStartPosition) {\n+            super(name, nameStartPosition);\n+        }\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/parser\/Attribute.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.toolkit.taglets.snippet.parser;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+\/*\n+ * Provides convenient access to attributes.\n+ *\/\n+public final class Attributes {\n+\n+    private final Map<String, List<Attribute>> attributes;\n+\n+    public Attributes(Collection<? extends Attribute> attributes) {\n+        this.attributes = attributes\n+                .stream()\n+                .collect(Collectors.groupingBy(Attribute::name,\n+                                               Collectors.toList()));\n+    }\n+\n+    \/*\n+     * 1. If there are multiple attributes with the same name and type, it is\n+     * unknown which one of these attributes will be returned.\n+     *\n+     * 2. If there are no attributes with this name and type, an empty optional\n+     * will be returned.\n+     *\n+     * 3. If a non-specific (any\/or\/union\/etc.) result is required, query for\n+     * the Attribute.class type.\n+     *\/\n+    public <T extends Attribute> Optional<T> get(String name, Class<T> type) {\n+        return attributes.getOrDefault(name, List.of())\n+                .stream()\n+                .filter(type::isInstance)\n+                .map(type::cast)\n+                .findAny();\n+    }\n+\n+    public int size() {\n+        return attributes.values().stream().mapToInt(List::size).sum();\n+    }\n+\n+    public boolean isEmpty() {\n+        return attributes.isEmpty();\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/parser\/Attributes.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.toolkit.taglets.snippet.parser;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/\/\n+\/\/ markup-comment = { markup-tag } ;\n+\/\/     markup-tag = \"@\" , tag-name , {attribute} [\":\"] ;\n+\/\/\n+\/\/ If optional trailing \":\" is present, the tag refers to the next line\n+\/\/ rather than to this line.\n+\/\/\n+public final class MarkupParser {\n+\n+    private final static int EOI = 0x1A;\n+    private char[] buf;\n+    private int bp;\n+    private int buflen;\n+    private char ch;\n+\n+    public List<Parser.Tag> parse(String input) throws ParseException {\n+\n+        \/\/ No vertical whitespace\n+        assert input.codePoints().noneMatch(c -> c == '\\n' || c == '\\r');\n+\n+        buf = new char[input.length() + 1];\n+        input.getChars(0, input.length(), buf, 0);\n+        buf[buf.length - 1] = EOI;\n+        buflen = buf.length - 1;\n+        bp = -1;\n+\n+        nextChar();\n+        return parse();\n+    }\n+\n+    protected List<Parser.Tag> parse() throws ParseException {\n+        List<Parser.Tag> tags = new ArrayList<>();\n+        \/\/ TODO: what to do with leading and trailing unrecognized markup?\n+        while (bp < buflen) {\n+            switch (ch) {\n+                case '@' -> tags.add(readTag());\n+                default -> nextChar();\n+            }\n+        }\n+\n+        return tags;\n+    }\n+\n+    protected Parser.Tag readTag() throws ParseException {\n+        nextChar();\n+        if (!Character.isUnicodeIdentifierStart(ch)) {\n+            \/\/ FIXME: internationalize!\n+            throw new ParseException(\"Bad character: '%s' (0x%s)\".formatted(ch, Integer.toString(ch, 16)), bp);\n+        }\n+        final int nameBp = bp;\n+        String name = readIdentifier();\n+        skipWhitespace();\n+\n+        boolean appliesToNextLine = false;\n+        List<Attribute> attributes = List.of();\n+\n+        if (ch == ':') {\n+            appliesToNextLine = true;\n+            nextChar();\n+        } else {\n+            attributes = attrs();\n+            skipWhitespace();\n+            if (ch == ':') {\n+                appliesToNextLine = true;\n+                nextChar();\n+            }\n+        }\n+\n+        Parser.Tag i = new Parser.Tag();\n+        i.nameLineOffset = nameBp;\n+        i.name = name;\n+        i.attributes = attributes;\n+        i.appliesToNextLine = appliesToNextLine;\n+\n+        return i;\n+    }\n+\n+    protected String readIdentifier() {\n+        int start = bp;\n+        nextChar();\n+        while (bp < buflen && (Character.isUnicodeIdentifierPart(ch) || ch == '-')) {\n+            nextChar();\n+        }\n+        return new String(buf, start, bp - start);\n+    }\n+\n+    protected void skipWhitespace() {\n+        while (bp < buflen && Character.isWhitespace(ch)) {\n+            nextChar();\n+        }\n+    }\n+\n+    void nextChar() {\n+        ch = buf[bp < buflen ? ++bp : buflen];\n+    }\n+\n+    \/\/ Parsing machinery is adapted from com.sun.tools.javac.parser.DocCommentParser:\n+\n+    private enum ValueKind {\n+        EMPTY,\n+        UNQUOTED,\n+        SINGLE_QUOTED,\n+        DOUBLE_QUOTED;\n+    }\n+\n+    protected List<Attribute> attrs() throws ParseException {\n+        List<Attribute> attrs = new ArrayList<>();\n+        skipWhitespace();\n+\n+        while (bp < buflen && isIdentifierStart(ch)) {\n+            int nameStartPos = bp;\n+            String name = readAttributeName();\n+            skipWhitespace();\n+            StringBuilder value = new StringBuilder();\n+            var vkind = ValueKind.EMPTY;\n+            int valueStartPos = -1;\n+            if (ch == '=') {\n+                nextChar();\n+                skipWhitespace();\n+                if (ch == '\\'' || ch == '\"') {\n+                    vkind = (ch == '\\'') ? ValueKind.SINGLE_QUOTED : ValueKind.DOUBLE_QUOTED;\n+                    char quote = ch;\n+                    nextChar();\n+                    valueStartPos = bp;\n+                    while (bp < buflen && ch != quote) {\n+                        nextChar();\n+                    }\n+                    if (bp >= buflen) { \/\/ TODO: unexpected EOL; check for a similar issue in parsing the @snippet tag\n+                        throw new ParseException(\"dc.unterminated.string\", bp - 1);\n+                    }\n+                    addPendingText(value, valueStartPos, bp - 1);\n+                    nextChar();\n+                } else {\n+                    vkind = ValueKind.UNQUOTED;\n+                    valueStartPos = bp;\n+                    while (bp < buflen && !isUnquotedAttrValueTerminator(ch)) {\n+                        nextChar();\n+                    }\n+                    \/\/ Unlike the case with a quoted value, there's no need to\n+                    \/\/ check for unexpected EOL here; an EOL would simply mean\n+                    \/\/ \"end of unquoted value\".\n+                    addPendingText(value, valueStartPos, bp - 1);\n+                }\n+                skipWhitespace();\n+            }\n+\n+            \/\/ material implication:\n+            \/\/     if vkind != EMPTY then it must be the case that valueStartPos >=0\n+            assert !(vkind != ValueKind.EMPTY && valueStartPos < 0);\n+\n+            var attribute = vkind == ValueKind.EMPTY ?\n+                    new Attribute.Valueless(name, nameStartPos) :\n+                    new Attribute.Valued(name, value.toString(), nameStartPos, valueStartPos);\n+\n+            attrs.add(attribute);\n+        }\n+        return attrs;\n+    }\n+\n+    protected boolean isIdentifierStart(char ch) {\n+        return Character.isUnicodeIdentifierStart(ch);\n+    }\n+\n+    protected String readAttributeName() {\n+        int start = bp;\n+        nextChar();\n+        while (bp < buflen && (Character.isUnicodeIdentifierPart(ch) || ch == '-'))\n+            nextChar();\n+        return new String(buf, start, bp - start);\n+    }\n+\n+    \/\/ Similar to https:\/\/html.spec.whatwg.org\/multipage\/syntax.html#unquoted\n+    protected boolean isUnquotedAttrValueTerminator(char ch) {\n+        switch (ch) {\n+            case ':': \/\/ indicates that the instruction relates to the next line\n+            case ' ': case '\\t':\n+            case '\"': case '\\'': case '`':\n+            case '=': case '<': case '>':\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    protected void addPendingText(StringBuilder b, int textStart, int textEnd) {\n+        if (textStart != -1) {\n+            if (textStart <= textEnd) {\n+                b.append(buf, textStart, (textEnd - textStart) + 1);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/parser\/MarkupParser.java","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.toolkit.taglets.snippet.parser;\n+\n+public class ParseException extends Exception {\n+\n+    @java.io.Serial\n+    private static final long serialVersionUID = 1;\n+\n+    private final int index;\n+\n+    public ParseException(String message, int position) {\n+        super(message);\n+        if (position < 0) {\n+            throw new IllegalArgumentException(String.valueOf(position));\n+        }\n+        this.index = position;\n+    }\n+\n+    public int getPosition() {\n+        return index;\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/parser\/ParseException.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,501 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.toolkit.taglets.snippet.parser;\n+\n+import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.action.Action;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.action.Annotate;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.action.Bookmark;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.action.Replace;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.text.AnnotatedText;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+\/*\n+ * Semantics of a EOL comment; plus\n+ * 1. This parser treats input as plain text. This may result in markup being\n+ * produced from unexpected places; for example, when parsing Java text blocks:\n+ *\n+ *     String text =\n+ *         \"\"\"\n+ *             \/\/ @start x\n+ *         \"\"\";\n+ *\n+ * false positives are possible, but false negatives are not.\n+ * To remediate that, perhaps a no-op trailing \/\/ @start x @end x might be added.\n+ *\n+ * 2. To allow some preexisting constructs, unknown actions in a leading position are skipped;\n+ * for example, \"\/\/ @formatter:on\" marker in IntelliJ IDEA is ignored.\n+ *\n+ * 3. This match's value can be confused for a trailing markup.\n+ *\n+ *     String x; \/\/ comment \/\/ another comment \/\/ @formatter:on \/\/ @highlight match=\"\/\/ @\"\n+ *\n+ * Do we need escapes?\n+ *\n+ * 4. Rules for EOL are very different among formats: compare Java's \/\/ with properties' #\/!\n+ *\n+ * 5. A convenience `end` ends all the things started so far.\n+ *\/\n+\/\/ FIXME: How to treat Form Feed? (i.e. is it vertical or horizontal whitespace?)\n+\/\/ FIXME: what to do with lines not covered by any markup? (i.e. in between markup)\n+\/\/ FIXME: all parsing errors must be localized.\n+public final class Parser {\n+\n+    \/\/                  v next line\n+    \/\/         : action :\n+    \/\/         ^\n+    \/\/ this line\n+    \/\/\n+    \/\/ next-line tag behaves as if it were specified on the next line\n+\n+    \/\/ Regions\n+    \/\/  * a line\n+    \/\/  * a set of lines\n+    \/\/  * a range of lines (a set of adjacent lines that unlocks multi-line regex)\n+\n+    \/\/ label \"name\"\n+    \/\/     Puts a label on the line. That label can be used to refer to that\n+    \/\/     line in the body (a.k.a. payload) of the marked up snippet.\n+\n+    \/\/ Examples of constructs sharing the same line:\n+    \/\/\n+    \/\/   * highlight\/replace and show\n+    \/\/   * highlight bold and (partially) highlight italic\n+    \/\/\n+    \/\/ What if they start on the same line but end on different lines?\n+    \/\/ Syntax should be compact\n+\n+    private String eolMarker;\n+    private Matcher markedUpLine;\n+    private final MarkupParser markupParser = new MarkupParser();\n+\n+    \/\/ Incomplete actions waiting for their complementary @end\n+    private final Regions regions = new Regions();\n+    \/\/ List of tags; consumed from top to bottom\n+    private final Queue<Tag> tags = new LinkedList<>();\n+\n+    public Result parse(String source) throws ParseException {\n+        return parse(\"\/\/\", source);\n+    }\n+\n+    \/*\n+     * Newline characters in the returned text are of the \\n form.\n+     *\/\n+    public Result parse(String eolMarker, String source) throws ParseException {\n+        Objects.requireNonNull(eolMarker);\n+        Objects.requireNonNull(source);\n+        if (!Objects.equals(eolMarker, this.eolMarker)) {\n+            if (eolMarker.length() < 1) {\n+                throw new IllegalArgumentException();\n+            }\n+            for (int i = 0; i < eolMarker.length(); i++) {\n+                switch (eolMarker.charAt(i)) {\n+                    case '\\f', '\\n', '\\r' -> throw new IllegalArgumentException();\n+                }\n+            }\n+            this.eolMarker = eolMarker;\n+            \/\/ capture the rightmost eolMarker (e.g. \"\/\/\")\n+            \/\/ The bellow Pattern.compile should never throw PatternSyntaxException\n+            Pattern pattern = Pattern.compile(\"^(.*)(\" + Pattern.quote(eolMarker) + \"(\\\\s*@\\\\s*\\\\w+.+?))$\");\n+            this.markedUpLine = pattern.matcher(\"\"); \/\/ reusable matcher\n+        }\n+\n+        tags.clear();\n+        regions.clear();\n+\n+        Queue<Action> actions = new LinkedList<>();\n+\n+        AnnotatedText<Style> text = new AnnotatedText<>();\n+        boolean trailingNewline = source.endsWith(\"\\r\") || source.endsWith(\"\\n\");\n+        int lineStart = 0;\n+        List<Tag> previousLineTags = new ArrayList<>();\n+        List<Tag> thisLineTags = new ArrayList<>();\n+        List<Tag> tempList = new ArrayList<>();\n+\n+        \/\/ while lines could be computed lazily, it would yield more complex code\n+        record OffsetAndLine(int offset, String line) { }\n+        var offsetAndLines = new LinkedList<OffsetAndLine>();\n+        forEachLine(source, (off, line) -> offsetAndLines.add(new OffsetAndLine(off, line)));\n+        Iterator<OffsetAndLine> iterator = offsetAndLines.iterator();\n+\n+        while (iterator.hasNext()) {\n+            \/\/ There are 3 cases:\n+            \/\/   1. The pattern that describes a marked-up line is not matched\n+            \/\/   2. While the pattern is matched, the markup is not recognized\n+            \/\/   3. Both the pattern is matched and the markup is recognized\n+            OffsetAndLine next = iterator.next();\n+            String rawLine = next.line();\n+            boolean addLineTerminator = iterator.hasNext() || trailingNewline;\n+            String line;\n+            markedUpLine.reset(rawLine);\n+            if (!markedUpLine.matches()) { \/\/ (1)\n+                line = rawLine + (addLineTerminator ? \"\\n\" : \"\");\n+            } else {\n+                String maybeMarkup = markedUpLine.group(3);\n+                List<Tag> parsedTags = markupParser.parse(maybeMarkup);\n+                for (Tag t : parsedTags) {\n+                    t.lineSourceOffset = next.offset;\n+                    t.markupLineOffset = markedUpLine.start(3);\n+                }\n+                thisLineTags.addAll(parsedTags);\n+                for (var tagIterator = thisLineTags.iterator(); tagIterator.hasNext(); ) {\n+                    Tag t = tagIterator.next();\n+                    if (t.appliesToNextLine) {\n+                        tagIterator.remove();\n+                        t.appliesToNextLine = false; \/\/ clear the flag\n+                        tempList.add(t);\n+                    }\n+                }\n+                if (parsedTags.isEmpty()) { \/\/ (2)\n+                    \/\/ TODO: log this with NOTICE;\n+                    line = rawLine + (addLineTerminator ? \"\\n\" : \"\");\n+                } else { \/\/ (3)\n+                    String payload = markedUpLine.group(1);\n+                    line = payload + (addLineTerminator ? \"\\n\" : \"\");\n+                }\n+            }\n+\n+            thisLineTags.addAll(0, previousLineTags); \/\/ prepend!\n+            previousLineTags.clear();\n+            for (Tag t : thisLineTags) {\n+                t.start = lineStart;\n+                t.end = lineStart + line.length(); \/\/ this includes line terminator, if any\n+                processTag(t);\n+            }\n+            previousLineTags.addAll(tempList);\n+            tempList.clear();\n+\n+            thisLineTags.clear();\n+\n+            append(text, Set.of(), line);\n+            \/\/ FIXME: mark up trailing whitespace!\n+            lineStart += line.length();\n+        }\n+\n+        if (!previousLineTags.isEmpty()) {\n+            Tag t = previousLineTags.iterator().next();\n+            throw new ParseException(\"Tags refer to non-existent lines\", t.markupLineOffset);\n+        }\n+\n+        \/\/ also report on unpaired with corresponding `end` or unknown tags\n+        if (!regions.isEmpty()) {\n+            Optional<Tag> tag = regions.removeLast(); \/\/ any of these tags would do\n+            Tag t = tag.get();\n+            throw new ParseException(\"Unpaired region(s)\", t.lineSourceOffset + t.markupLineOffset + t.nameLineOffset);\n+        }\n+\n+        for (var t : tags) {\n+\n+            \/\/ Translate a list of attributes into a more convenient form\n+            Attributes attributes = new Attributes(t.attributes());\n+\n+            final var substring = attributes.get(\"substring\", Attribute.Valued.class);\n+            final var regex = attributes.get(\"regex\", Attribute.Valued.class);\n+\n+            if (!t.name().equals(\"start\") && substring.isPresent() && regex.isPresent()) {\n+                throw new ParseException(\"'substring' and 'regex' cannot be used simultaneously\", t.lineSourceOffset + t.markupLineOffset + substring.get().nameStartPosition());\n+            }\n+\n+            switch (t.name()) {\n+                case \"link\" -> {\n+                    var target = attributes.get(\"target\", Attribute.Valued.class)\n+                            .orElseThrow(() -> new ParseException(\"target is absent\", t.lineSourceOffset + t.markupLineOffset + t.nameLineOffset));\n+                    var type = attributes.get(\"type\", Attribute.Valued.class);\n+                    String typeValue = type.isPresent() ? type.get().value() : \"link\";\n+                    if (!typeValue.equals(\"link\") && !typeValue.equals(\"linkplain\")) {\n+                        throw new ParseException(\"Unknown link type: '%s'\".formatted(typeValue), t.lineSourceOffset + t.markupLineOffset + type.get().valueStartPosition());\n+                    }\n+                    Annotate a = new Annotate(new Style.Link(target.value()),\n+                                              createRegexPattern(substring, regex, \".+\", t.lineSourceOffset + t.markupLineOffset), \/\/ different regex not to include newline\n+                                              text.subText(t.start(), t.end()));\n+                    actions.add(a);\n+                }\n+                case \"replace\" -> {\n+                    var replacement = attributes.get(\"replacement\", Attribute.Valued.class)\n+                            .orElseThrow(() -> new ParseException(\"replacement is absent\", t.lineSourceOffset + t.markupLineOffset + t.nameLineOffset));\n+                    Replace a = new Replace(replacement.value(),\n+                                            createRegexPattern(substring, regex, t.lineSourceOffset + t.markupLineOffset),\n+                                            text.subText(t.start(), t.end()));\n+                    actions.add(a);\n+                }\n+                case \"highlight\" -> {\n+                    var type = attributes.get(\"type\", Attribute.Valued.class);\n+\n+                    String typeValue = type.isPresent() ? type.get().value() : \"bold\";\n+\n+                    Annotate a = new Annotate(new Style.Name(typeValue),\n+                                              createRegexPattern(substring, regex, t.lineSourceOffset + t.markupLineOffset),\n+                                              text.subText(t.start(), t.end()));\n+                    actions.add(a);\n+                }\n+                case \"start\" -> {\n+                    var region = attributes.get(\"region\", Attribute.Valued.class)\n+                            .orElseThrow(() -> new ParseException(\"Unnamed start\", t.lineSourceOffset + t.markupLineOffset + t.nameLineOffset));\n+                    String regionValue = region.value();\n+                    if (regionValue.isBlank()) {\n+                        throw new ParseException(\"Blank region name\", t.lineSourceOffset + t.markupLineOffset + region.valueStartPosition());\n+                    }\n+                    if (t.attributes().size() != 1) {\n+                        throw new ParseException(\"Unexpected attributes\", t.lineSourceOffset + t.markupLineOffset + t.nameLineOffset);\n+                    }\n+                    actions.add(new Bookmark(region.value(), text.subText(t.start(), t.end() - 1)));\n+                }\n+            }\n+        }\n+\n+        return new Result(text, actions);\n+    }\n+\n+    private Pattern createRegexPattern(Optional<Attribute.Valued> substring,\n+                                       Optional<Attribute.Valued> regex,\n+                                       int offset) throws ParseException {\n+        return createRegexPattern(substring, regex, \"(?s).+\", offset);\n+    }\n+\n+    private Pattern createRegexPattern(Optional<Attribute.Valued> substring,\n+                                       Optional<Attribute.Valued> regex,\n+                                       String defaultRegex,\n+                                       int offset) throws ParseException {\n+        Pattern pattern;\n+        if (substring.isPresent()) {\n+            \/\/ this Pattern.compile *cannot* throw an exception\n+            pattern = Pattern.compile(Pattern.quote(substring.get().value()));\n+        } else if (regex.isEmpty()) {\n+            \/\/ this Pattern.compile *should not* throw an exception\n+            pattern = Pattern.compile(defaultRegex);\n+        } else {\n+            \/\/ Unlike string literals in Java source, attribute values in\n+            \/\/ snippet markup do not use escapes. This is why indices of\n+            \/\/ characters in the regex pattern directly map to their\n+            \/\/ corresponding positions in snippet source.\n+            assert regex.get().value().equals( Pattern.compile(regex.get().value()).pattern() ) : regex.get().value();\n+            try {\n+                pattern = Pattern.compile(regex.get().value());\n+            } catch (PatternSyntaxException e) {\n+                int pos = offset + regex.get().valueStartPosition();\n+                \/\/ Refine position using e.getIndex() only if that index is\n+                \/\/ relevant to the regex in the attribute value. Index might be\n+                \/\/ irrelevant because it refers to an internal representation of\n+                \/\/ regex, e.getPattern(), which might be a normalized or partial\n+                \/\/ view of the original pattern.\n+                if (e.getIndex() > -1 && regex.get().value().equals(e.getPattern())) {\n+                    pos += e.getIndex();\n+                }\n+                throw new ParseException(e.getDescription(), pos);\n+            }\n+        }\n+        return pattern;\n+    }\n+\n+    private void processTag(Tag t) throws ParseException {\n+\n+        Attributes attributes = new Attributes(t.attributes()); \/\/ FIXME: we create them twice\n+        Optional<Attribute> region = attributes.get(\"region\", Attribute.class);\n+\n+        if (!t.name().equals(\"end\")) {\n+            tags.add(t);\n+            if (region.isPresent()) {\n+                if (region.get() instanceof Attribute.Valued v) {\n+                    String name = v.value();\n+                    if (!regions.addNamed(name, t)) {\n+                        throw new ParseException(\"Duplicated region: \" + name, t.lineSourceOffset + t.markupLineOffset + v.valueStartPosition());\n+                    }\n+                } else {\n+                    \/\/ TODO: change to exhaustive switch after \"Pattern Matching for switch\" is implemented\n+                    assert region.get() instanceof Attribute.Valueless;\n+                    regions.addAnonymous(t);\n+                }\n+            }\n+        } else {\n+            if (region.isEmpty() || region.get() instanceof Attribute.Valueless) {\n+                Optional<Tag> tag = regions.removeLast();\n+                if (tag.isEmpty()) {\n+                    throw new ParseException(\"No started regions to end\", t.lineSourceOffset + t.markupLineOffset + t.nameLineOffset);\n+                }\n+                completeTag(tag.get(), t);\n+            } else {\n+                assert region.get() instanceof Attribute.Valued;\n+                String name = ((Attribute.Valued) region.get()).value();\n+                Optional<Tag> tag = regions.removeNamed(name);\n+                if (tag.isEmpty()) {\n+                    throw new ParseException(\"Ending a non-started region %s\".formatted(name), t.lineSourceOffset + t.markupLineOffset + region.get().nameStartPosition());\n+                }\n+                completeTag(tag.get(), t);\n+            }\n+        }\n+    }\n+\n+    static final class Tag {\n+\n+        String name;\n+        int lineSourceOffset;\n+        int markupLineOffset;\n+        int nameLineOffset;\n+        int start;\n+        int end;\n+        List<Attribute> attributes;\n+        boolean appliesToNextLine;\n+\n+        String name() {\n+            return name;\n+        }\n+\n+        List<Attribute> attributes() {\n+            return attributes;\n+        }\n+\n+        int start() {\n+            return start;\n+        }\n+\n+        int end() {\n+            return end;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Tag{\" +\n+                    \"name='\" + name + '\\'' +\n+                    \", start=\" + start +\n+                    \", end=\" + end +\n+                    \", attributes=\" + attributes +\n+                    '}';\n+        }\n+    }\n+\n+    private void completeTag(Tag start, Tag end) {\n+        assert !start.name().equals(\"end\") : start;\n+        assert end.name().equals(\"end\") : end;\n+        start.end = end.end();\n+    }\n+\n+    private void append(AnnotatedText<Style> text, Set<Style> style, CharSequence s) {\n+        text.subText(text.length(), text.length()).replace(style, s.toString());\n+    }\n+\n+    public record Result(AnnotatedText<Style> text, Queue<Action> actions) { }\n+\n+    \/*\n+     * Encapsulates the data structure used to manage regions.\n+     *\n+     * boolean-returning commands return true if succeed and false if fail.\n+     *\/\n+    public static final class Regions {\n+\n+        \/*\n+         * LinkedHashMap does not fit here because of both the need for unique\n+         * keys for anonymous regions and inability to easily access the most\n+         * recently put entry.\n+         *\n+         * Since we expect only a few regions, a list will do.\n+         *\/\n+        private final ArrayList<Map.Entry<Optional<String>, Tag>> tags = new ArrayList<>();\n+\n+        void addAnonymous(Tag i) {\n+            tags.add(Map.entry(Optional.empty(), i));\n+        }\n+\n+        boolean addNamed(String name, Tag i) {\n+            boolean matches = tags.stream()\n+                    .anyMatch(entry -> entry.getKey().isPresent() && entry.getKey().get().equals(name));\n+            if (matches) {\n+                return false; \/\/ won't add a duplicate\n+            }\n+            tags.add(Map.entry(Optional.of(name), i));\n+            return true;\n+        }\n+\n+        Optional<Tag> removeNamed(String name) {\n+            for (var iterator = tags.iterator(); iterator.hasNext(); ) {\n+                var entry = iterator.next();\n+                if (entry.getKey().isPresent() && entry.getKey().get().equals(name)) {\n+                    iterator.remove();\n+                    return Optional.of(entry.getValue());\n+                }\n+            }\n+            return Optional.empty();\n+        }\n+\n+        Optional<Tag> removeLast() {\n+            if (tags.isEmpty()) {\n+                return Optional.empty();\n+            }\n+            Map.Entry<Optional<String>, Tag> e = tags.remove(tags.size() - 1);\n+            return Optional.of(e.getValue());\n+        }\n+\n+        void clear() {\n+            tags.clear();\n+        }\n+\n+        boolean isEmpty() {\n+            return tags.isEmpty();\n+        }\n+    }\n+\n+    \/*\n+     * The reason that the lines are split using a custom method as opposed to\n+     * String.split(String) or String.lines() is that along with the lines\n+     * themselves we also need their offsets in the originating input to supply\n+     * to diagnostic exceptions should they arise.\n+     *\n+     * The reason that \"\\n|(\\r\\n)|\\r\" is used instead of \"\\\\R\" is that the\n+     * latter is UNICODE-aware, which we must be not.\n+     *\/\n+    static void forEachLine(String s, LineConsumer consumer) {\n+        \/\/ the fact that the regex alternation is *ordered* is used here to try\n+        \/\/ to match \\r\\n before \\r\n+        final Pattern NEWLINE = Pattern.compile(\"\\n|(\\r\\n)|\\r\");\n+        Matcher matcher = NEWLINE.matcher(s);\n+        int pos = 0;\n+        while (matcher.find()) {\n+            consumer.accept(pos, s.substring(pos, matcher.start()));\n+            pos = matcher.end();\n+        }\n+        if (pos < s.length())\n+            consumer.accept(pos, s.substring(pos));\n+    }\n+\n+    \/*\n+     * This interface is introduced to encapsulate the matching mechanics so\n+     * that it wouldn't be obtrusive to the client code.\n+     *\/\n+    @FunctionalInterface\n+    interface LineConsumer {\n+        void accept(int offset, String line);\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/parser\/Parser.java","additions":501,"deletions":0,"binary":false,"changes":501,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.toolkit.taglets.snippet.parser;\n+\n+\/\/ FIXME: uncomment \/* sealed *\/ when minimum boot version >= 17\n+public \/* sealed *\/ interface Style {\n+\n+    record Link(String target) implements Style { }\n+\n+    record Name(String name) implements Style { }\n+\n+    record Markup() implements Style { }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/parser\/Style.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,340 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.toolkit.taglets.snippet.text;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+\n+\/*\n+ * Mutable sequence of characters, each of which can be associated with a set of\n+ * objects. These objects can be used by clients as character metadata, such as\n+ * rich text style.\n+ *\/\n+public class AnnotatedText<S> {\n+\n+    private Map<String, AnnotatedText<S>> bookmarks;\n+    private StringBuilder chars;\n+    private Metadata<S> metadata;\n+    private List<WeakReference<SubText>> subtexts;\n+\n+    public AnnotatedText() {\n+        init();\n+    }\n+\n+    \/*\n+     * This method should be overridden to be no-op by a subclass that wants to\n+     * inherit the interface but not the implementation, which includes\n+     * unnecessary internal objects. If this is done, then all public methods\n+     * should be overridden too, otherwise they will not work.\n+     *\n+     * An alternative design would be to provide an interface for annotated text;\n+     * but I ruled that out as unnecessarily heavyweight.\n+     *\/\n+    protected void init() {\n+        this.bookmarks = new HashMap<>();\n+        this.chars = new StringBuilder();\n+        this.metadata = new Metadata<>();\n+        this.subtexts = new ArrayList<>();\n+    }\n+\n+    \/*\n+     * For each character of this text adds the provided objects to a set of\n+     * objects associated with that character.\n+     *\/\n+    public void annotate(Set<S> additional) {\n+        metadata.add(0, length(), additional);\n+    }\n+\n+    public int length() {\n+        return chars.length();\n+    }\n+\n+    \/*\n+     * Replaces all characters of this text with the provided sequence of\n+     * characters, each of which is associated with all the provided objects.\n+     *\/\n+    public void replace(Set<? extends S> s, CharSequence plaintext) {\n+        replace(0, length(), s, plaintext);\n+    }\n+\n+    \/*\n+     * A multi-purpose operation that can be used to replace, insert or delete\n+     * text. The effect on a text is as if [start, end) were deleted and\n+     * then plaintext inserted at start.\n+     *\/\n+    private void replace(int start, int end, Set<? extends S> s, CharSequence plaintext) {\n+        chars.replace(start, end, plaintext.toString());\n+        metadata.delete(start, end);\n+        metadata.insert(start, plaintext.length(), s);\n+        \/\/ The number of subtexts is not expected to be big; hence no\n+        \/\/ optimizations are applied\n+        var iterator = subtexts.iterator();\n+        while (iterator.hasNext()) {\n+            WeakReference<SubText> ref = iterator.next();\n+            SubText txt = ref.get();\n+            if (txt == null) {\n+                iterator.remove(); \/\/ a stale ref\n+            } else {\n+                update(start, end, plaintext.length(), txt);\n+            }\n+        }\n+    }\n+\n+    \/*\n+     * Updates the text given the scope of the change to reflect text continuity.\n+     *\/\n+    private void update(int start, int end, int newLength, SubText text) {\n+        assert start <= end;\n+        assert text.start <= text.end;\n+        assert newLength >= 0;\n+        if (text.start == text.end && start == text.start) {\n+            \/\/ insertion into empty text; special-cased for simplicity\n+            text.end += newLength;\n+            return;\n+        }\n+        if (end <= text.start) { \/\/ the change is on the left-hand side of the text\n+            int diff = newLength - (end - start);\n+            text.start += diff;\n+            text.end += diff;\n+        } else if (text.end <= start) { \/\/ the change is on the right-hand side of the text\n+            \/\/ no-op; explicit \"if\" for clarity\n+        } else { \/\/ the change intersects with the text\n+            if (text.start <= start && end <= text.end) { \/\/ the change is within the text\n+                text.end += newLength - (end - start);\n+            } else {\n+                int intersectionLen = min(end, text.end) - max(start, text.start);\n+                int oldLen = text.end - text.start;\n+                if (start <= text.start) {\n+                    text.start = start + newLength;\n+                }\n+                text.end = text.start + oldLen - intersectionLen;\n+            }\n+        }\n+    }\n+\n+    private void annotate(int start, int end, Set<S> additional) {\n+        metadata.add(start, end, additional);\n+    }\n+\n+    public AnnotatedText<S> getBookmarkedText(String bookmark) {\n+        return bookmarks.get(Objects.requireNonNull(bookmark));\n+    }\n+\n+    \/*\n+     * Maps the provided name to this text, using a flat namespace. A flat\n+     * namespace means that this text (t), as well as any subtext derived from\n+     * either t or t's subtext, share the naming map.\n+     *\/\n+    public void bookmark(String name) {\n+        bookmark(name, 0, length());\n+    }\n+\n+    private void bookmark(String name, int start, int end) {\n+        bookmarks.put(Objects.requireNonNull(name), subText(start, end));\n+    }\n+\n+    \/*\n+     * Selects a view of the portion of this text starting from start\n+     * (inclusive) to end (exclusive).\n+     *\n+     * In contrast with java.util.List.subList, returned views provide extra\n+     * consistency: they reflect structural changes happening to the underlying\n+     * text and other views thereof.\n+     *\/\n+    public AnnotatedText<S> subText(int start, int end) {\n+        Objects.checkFromToIndex(start, end, length());\n+        var s = new SubText(start, end);\n+        subtexts.add(new WeakReference<>(s));\n+        return s;\n+    }\n+\n+    \/*\n+     * Returns plaintext version of this text. This method is to be used for\n+     * algorithms that accept String or CharSequence to map the result back to\n+     * this text.\n+     *\n+     * There are no extensible \"mutable string\" interface. java.lang.Appendable\n+     * does not support replacements and insertions. StringBuilder\/StringBuffer\n+     * is not extensible. Even if it were extensible, not many general-purpose\n+     * string algorithms accept it.\n+     *\/\n+    public CharSequence asCharSequence() {\n+        return chars;\n+    }\n+\n+    \/*\n+     * Provides text to the consumer efficiently. The text always calls the\n+     * consumer at least once; even if the text is empty.\n+     *\/\n+    public void consumeBy(AnnotatedText.Consumer<? super S> consumer) {\n+        consumeBy(consumer, 0, length());\n+    }\n+\n+    private void consumeBy(AnnotatedText.Consumer<? super S> consumer, int start, int end) {\n+        Objects.checkFromToIndex(start, end, length());\n+        metadata.consumeBy(consumer, chars, start, end);\n+    }\n+\n+    public AnnotatedText<S> append(Set<? extends S> style, CharSequence sequence) {\n+        subText(length(), length()).replace(style, sequence);\n+        return this;\n+    }\n+\n+    public AnnotatedText<S> append(AnnotatedText<? extends S> fragment) {\n+        fragment.consumeBy((style, sequence) -> subText(length(), length()).replace(style, sequence));\n+        return this;\n+    }\n+\n+    @FunctionalInterface\n+    public interface Consumer<S> {\n+\n+        void consume(Set<? extends S> style, CharSequence sequence);\n+    }\n+\n+    \/*\n+     * A structure that stores character metadata.\n+     *\/\n+    private static final class Metadata<S> {\n+\n+        \/\/ Although this structure optimizes neither memory use nor object\n+        \/\/ allocation, it is simple both to implement and reason about.\n+\n+        \/\/ list is a reference to ArrayList because this class accesses list by\n+        \/\/ index, so this is important that the list is RandomAccess, which\n+        \/\/ ArrayList is\n+        private final ArrayList<Set<S>> list = new ArrayList<>();\n+\n+        private void delete(int fromIndex, int toIndex) {\n+            list.subList(fromIndex, toIndex).clear();\n+        }\n+\n+        private void insert(int fromIndex, int length, Set<? extends S> s) {\n+            list.addAll(fromIndex, Collections.nCopies(length, Set.copyOf(s)));\n+        }\n+\n+        private void add(int fromIndex, int toIndex, Set<S> additional) {\n+            var copyOfAdditional = Set.copyOf(additional);\n+            list.subList(fromIndex, toIndex).replaceAll(current -> sum(current, copyOfAdditional));\n+        }\n+\n+        private Set<S> sum(Set<S> a, Set<S> b) {\n+            \/\/ assumption: until there are complex texts, the most common\n+            \/\/ scenario is the one where `a` is empty while `b` is not\n+            if (a.isEmpty()) {\n+                return b;\n+            } else {\n+                var c = new HashSet<>(a);\n+                c.addAll(b);\n+                return Set.copyOf(c);\n+            }\n+        }\n+\n+        private void consumeBy(Consumer<? super S> consumer, CharSequence seq, int start, int end) {\n+            if (start == end) {\n+                \/\/ an empty region doesn't have an associated set; special-cased\n+                \/\/ for simplicity to avoid more complicated implementation of\n+                \/\/ this method using a do-while loop\n+                consumer.consume(Set.of(), \"\");\n+            } else {\n+                for (int i = start, j = i + 1; i < end; i = j) {\n+                    var ith = list.get(i);\n+                    while (j < end && ith.equals(list.get(j))) {\n+                        j++;\n+                    }\n+                    consumer.consume(ith, seq.subSequence(i, j));\n+                }\n+            }\n+        }\n+    }\n+\n+    final class SubText extends AnnotatedText<S> {\n+\n+        int start, end;\n+\n+        private SubText(int start, int end) {\n+            this.start = start;\n+            this.end = end;\n+        }\n+\n+        @Override\n+        protected void init() {\n+            \/\/ no-op\n+        }\n+\n+        @Override\n+        public void annotate(Set<S> style) {\n+            AnnotatedText.this.annotate(start, end, style);\n+        }\n+\n+        @Override\n+        public int length() {\n+            return end - start;\n+        }\n+\n+        @Override\n+        public void replace(Set<? extends S> s, CharSequence plaintext) {\n+            \/\/ If the \"replace\" operation affects this text's size, which it\n+            \/\/ can, then that size will be updated along with all other sizes\n+            \/\/ during the bulk \"update\" operation in tracking text instance.\n+            AnnotatedText.this.replace(start, end, s, plaintext);\n+        }\n+\n+        @Override\n+        public AnnotatedText<S> getBookmarkedText(String bookmark) {\n+            return AnnotatedText.this.getBookmarkedText(bookmark);\n+        }\n+\n+        @Override\n+        public void bookmark(String name) {\n+            AnnotatedText.this.bookmark(name, start, end);\n+        }\n+\n+        @Override\n+        public AnnotatedText<S> subText(int start, int end) {\n+            return AnnotatedText.this.subText(this.start + start, this.start + end);\n+        }\n+\n+        @Override\n+        public CharSequence asCharSequence() {\n+            return AnnotatedText.this.asCharSequence().subSequence(start, end);\n+        }\n+\n+        @Override\n+        public void consumeBy(AnnotatedText.Consumer<? super S> consumer) {\n+            AnnotatedText.this.consumeBy(consumer, start, end);\n+        }\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/text\/AnnotatedText.java","additions":340,"deletions":0,"binary":false,"changes":340,"status":"added"},{"patch":"@@ -371,1 +371,0 @@\n-        Utils utils = configuration.utils;\n@@ -373,0 +372,5 @@\n+        return getReferencedClass(e);\n+    }\n+\n+    public TypeElement getReferencedClass(Element e) {\n+        Utils utils = configuration.utils;\n@@ -385,1 +389,5 @@\n-        if (s == null || s.contains(\"#\") || s.contains(\"(\")) {\n+        return getReferencedModuleName(s);\n+    }\n+\n+    public String getReferencedModuleName(String signature) {\n+        if (signature == null || signature.contains(\"#\") || signature.contains(\"(\")) {\n@@ -388,2 +396,2 @@\n-        int n = s.indexOf(\"\/\");\n-        return (n == -1) ? s : s.substring(0, n);\n+        int n = signature.indexOf(\"\/\");\n+        return (n == -1) ? signature : signature.substring(0, n);\n@@ -393,1 +401,0 @@\n-        Utils utils = configuration.utils;\n@@ -395,0 +402,5 @@\n+        return getReferencedMember(e);\n+    }\n+\n+    public Element getReferencedMember(Element e) {\n+        Utils utils = configuration.utils;\n@@ -403,1 +415,5 @@\n-        if (s == null) {\n+        return getReferencedMemberName(s);\n+    }\n+\n+    public String getReferencedMemberName(String signature) {\n+        if (signature == null) {\n@@ -406,2 +422,2 @@\n-        int n = s.indexOf(\"#\");\n-        return (n == -1) ? null : s.substring(n + 1);\n+        int n = signature.indexOf(\"#\");\n+        return (n == -1) ? null : signature.substring(n + 1);\n@@ -412,0 +428,4 @@\n+        return getReferencedPackage(e);\n+    }\n+\n+    public PackageElement getReferencedPackage(Element e) {\n@@ -421,0 +441,4 @@\n+        return getReferencedModule(e);\n+    }\n+\n+    public ModuleElement getReferencedModule(Element e) {\n@@ -427,1 +451,0 @@\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/CommentHelper.java","additions":32,"deletions":9,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -613,0 +613,6 @@\n+        \/\/ for now, ensure we're in an HTML StartElementTree;\n+        \/\/ in time, we might check uses of attributes in other tree nodes\n+        if (getParentKind() != DocTree.Kind.START_ELEMENT) {\n+            return null;\n+        }\n+\n@@ -1140,0 +1146,4 @@\n+    private DocTree.Kind getParentKind() {\n+        return getCurrentPath().getParentPath().getLeaf().getKind();\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/Checker.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -143,0 +143,3 @@\n+        \/\/ snippet-related\n+        removeAll(styleSheetNames, \"bold\", \"highlighted\", \"italic\");\n+\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/checkStylesheetClasses\/CheckStylesheetClasses.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,1878 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8201533\n+ * @library \/tools\/lib ..\/..\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build javadoc.tester.* toolbox.ToolBox toolbox.ModuleBuilder builder.ClassBuilder\n+ * @run main TestSnippetTag\n+ *\/\n+\n+import builder.ClassBuilder;\n+import builder.ClassBuilder.MethodBuilder;\n+import javadoc.tester.JavadocTester;\n+import toolbox.ModuleBuilder;\n+import toolbox.ToolBox;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.function.ObjIntConsumer;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+\/\/ FIXME\n+\/\/   0. Add tests for snippets in all types of elements: e.g., fields\n+\/\/      and constructors (i.e. not only methods.)\n+\/\/   1. Add tests for nested structure under \"snippet-files\/\"\n+\/\/   2. Add negative tests for region\n+\/\/   3. Add tests for hybrid snippets\n+\n+\/*\n+ * General notes.\n+ *\n+ * 1. Some of the below tests could benefit from using a combinatorics library\n+ * as they are otherwise very wordy.\n+ *\n+ * 2. One has to be careful when using JavadocTester.checkOutput with duplicating\n+ * strings. If JavadocTester.checkOutput(x) is true, then it will also be true\n+ * if x is passed to that method additionally N times: JavadocTester.checkOutput(x, x, ..., x).\n+ * This is because a single occurrence of x in the output will be matched N times.\n+ *\/\n+public class TestSnippetTag extends JavadocTester {\n+\n+    private final ToolBox tb = new ToolBox();\n+\n+    private TestSnippetTag() { }\n+\n+    public static void main(String... args) throws Exception {\n+        new TestSnippetTag().runTests(m -> new Object[]{Paths.get(m.getName())});\n+    }\n+\n+    \/*\n+     * While the \"id\" and \"lang\" attributes are advertised in JEP 413, they are\n+     * currently unused by the implementation. The goal of this test is to make\n+     * sure that specifying these attributes causes no errors and exhibits no\n+     * unexpected behavior.\n+     *\/\n+    @Test\n+    public void testIdAndLangAttributes(Path base) throws IOException {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        final var snippets = List.of(\n+                \"\"\"\n+                {@snippet id=\"foo\" :\n+                    Hello, Snippet!\n+                }\n+                \"\"\",\n+                \"\"\"\n+                {@snippet id=\"foo\":\n+                    Hello, Snippet!\n+                }\n+                \"\"\",\n+                \"\"\"\n+                {@snippet id='foo' :\n+                    Hello, Snippet!\n+                }\n+                \"\"\",\n+                \"\"\"\n+                {@snippet id='foo':\n+                    Hello, Snippet!\n+                }\n+                \"\"\",\n+                \"\"\"\n+                {@snippet id=foo :\n+                    Hello, Snippet!\n+                }\n+                \"\"\",\n+\/\/ (1) Haven't yet decided on this one. It's a consistency issue. On the one\n+\/\/ hand, `:` is considered a part of a javadoc tag's name; on the other hand,\n+\/\/ snippet markup treats `:` (next-line modifier) as a value terminator.\n+\/\/                \"\"\"\n+\/\/                {@snippet id=foo:\n+\/\/                    Hello, Snippet!\n+\/\/                }\n+\/\/                \"\"\",\n+                \"\"\"\n+                {@snippet id=\"\" :\n+                    Hello, Snippet!\n+                }\n+                \"\"\",\n+                \"\"\"\n+                {@snippet id=\"\":\n+                    Hello, Snippet!\n+                }\n+                \"\"\",\n+                \"\"\"\n+                {@snippet id='':\n+                    Hello, Snippet!\n+                }\n+                \"\"\",\n+\/\/ Similarly to (1), haven't yet decided on this one.\n+\/\/                \"\"\"\n+\/\/                {@snippet id=:\n+\/\/                    Hello, Snippet!\n+\/\/                }\n+\/\/                \"\"\",\n+                \"\"\"\n+                {@snippet lang=\"java\" :\n+                    Hello, Snippet!\n+                }\n+                \"\"\",\n+                \"\"\"\n+                {@snippet lang=\"java\":\n+                    Hello, Snippet!\n+                }\n+                \"\"\",\n+                \"\"\"\n+                {@snippet lang='java' :\n+                    Hello, Snippet!\n+                }\n+                \"\"\",\n+                \"\"\"\n+                {@snippet lang='java':\n+                    Hello, Snippet!\n+                }\n+                \"\"\",\n+                \"\"\"\n+                {@snippet lang=java :\n+                    Hello, Snippet!\n+                }\n+                \"\"\",\n+                \"\"\"\n+                {@snippet lang=\"properties\" :\n+                    Hello, Snippet!\n+                }\n+                \"\"\",\n+                \"\"\"\n+                {@snippet lang=\"text\" :\n+                    Hello, Snippet!\n+                }\n+                \"\"\",\n+                \"\"\"\n+                {@snippet lang=\"\" :\n+                    Hello, Snippet!\n+                }\n+                \"\"\",\n+                \"\"\"\n+                {@snippet lang=\"foo\" id=\"bar\" :\n+                    Hello, Snippet!\n+                }\n+                \"\"\"\n+        );\n+        ClassBuilder classBuilder = new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\");\n+        forEachNumbered(snippets, (s, i) -> {\n+            classBuilder.addMembers(\n+                    MethodBuilder.parse(\"public void case%s() { }\".formatted(i))\n+                            .setComments(s));\n+        });\n+        classBuilder.write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        for (int j = 0; j < snippets.size(); j++) {\n+            checkOutput(\"pkg\/A.html\", true,\n+                        \"\"\"\n+                        <span class=\"element-name\">case%s<\/span>()<\/div>\n+                        <div class=\"block\">\n+                        <pre class=\"snippet\">\n+                            Hello, Snippet!\n+                        <\/pre>\n+                        <\/div>\n+                        \"\"\".formatted(j));\n+        }\n+    }\n+\n+    \/*\n+     * This is a convenience method to iterate through a list.\n+     * Unlike List.forEach, this method provides the consumer not only with an\n+     * element but also that element's index.\n+     *\n+     * See JDK-8184707.\n+     *\/\n+    private static <T> void forEachNumbered(List<T> list, ObjIntConsumer<? super T> action) {\n+        for (var iterator = list.listIterator(); iterator.hasNext(); ) {\n+            action.accept(iterator.next(), iterator.previousIndex());\n+        }\n+    }\n+\n+    @Test\n+    public void testBadTagSyntax(Path base) throws IOException {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        final var badSnippets = List.of(\n+                \/\/ No newline after `:`\n+                \"\"\"\n+                {@snippet :}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet : }\n+                \"\"\",\n+                \"\"\"\n+                {@snippet\n+                : }\n+                \"\"\",\n+                \"\"\"\n+                {@snippet\n+                 : }\n+                \"\"\",\n+                \/\/ Attribute issues\n+                \"\"\"\n+                {@snippet file=\"}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file=\"\n+                }\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file='}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file='\n+                }\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file='\n+                    }\n+                \"\"\",\n+                \"\"\"\n+                {@snippet\n+                file='\n+                    }\n+                \"\"\",\n+                \"\"\"\n+                {@snippet\n+                file='}\n+                \"\"\",\n+\/\/ This is an interesting case: closing curly terminates the tag, leaving the\n+\/\/ attribute value empty.\n+                \"\"\"\n+                {@snippet\n+                file=}\n+                \"\"\"\n+\/\/ The below commented out cases are worth testing if only to fixate the result.\n+\/\/ It's not that we can do a lot about them anyway.\n+\/\/                ,\n+\/\/ A missing `:`\n+\/\/                \"\"\"\n+\/\/                {@snippet\n+\/\/                  Hello  there\n+\/\/                }\n+\/\/                \"\"\"\n+\/\/ A missing `:`\n+\/\/                \"\"\"\n+\/\/                {@snippet\n+\/\/                    List<String> strings = List.of();\n+\/\/                }\n+\/\/                \"\"\"\n+        );\n+        ClassBuilder classBuilder = new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\");\n+        forEachNumbered(badSnippets, (s, i) -> {\n+            classBuilder.addMembers(\n+                    MethodBuilder.parse(\"public void case%s() { }\".formatted(i)).setComments(s));\n+        });\n+        classBuilder.write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        \/\/ Not very specific, but good enough\n+        long actual = Pattern.compile(\"error: \").matcher(getOutput(Output.OUT)).results().count();\n+        checking(\"Number of errors\");\n+        int expected = badSnippets.size();\n+        if (actual == expected) {\n+            passed(\"\");\n+        } else {\n+            failed(actual + \" vs \" + expected);\n+        }\n+        checkNoCrashes();\n+    }\n+\n+    \/*\n+     * When checking for errors, it is important not to confuse one error with\n+     * another. This method checks that there are no crashes (which are also\n+     * errors) by checking for stack traces. We never expect crashes.\n+     *\/\n+    private void checkNoCrashes() {\n+        checking(\"check crashes\");\n+        Matcher matcher = Pattern.compile(\"\\s*at.*\\\\(.*\\\\.java:\\\\d+\\\\)\")\n+                .matcher(getOutput(Output.STDERR));\n+        if (!matcher.find()) {\n+            passed(\"\");\n+        } else {\n+            failed(\"Looks like a stacktrace: \" + matcher.group());\n+        }\n+    }\n+\n+    \/*\n+     * A colon that is not separated from a tag name by whitespace is considered\n+     * a part of that name. This behavior is historical. For more context see,\n+     * for example, JDK-4750173.\n+     *\/\n+    @Test\n+    public void testUnknownTag(Path base) throws IOException {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        final var unknownTags = List.of(\n+                \"\"\"\n+                {@snippet:}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet:\n+                }\n+                \"\"\"\n+        );\n+        ClassBuilder classBuilder = new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\");\n+        forEachNumbered(unknownTags, (s, i) -> {\n+            classBuilder.addMembers(\n+                    MethodBuilder.parse(\"public void case%s() { }\".formatted(i))\n+                            .setComments(s));\n+        });\n+        classBuilder.write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        long actual = Pattern.compile(\"error: unknown tag: snippet:\")\n+                .matcher(getOutput(Output.OUT)).results().count();\n+        checking(\"Number of errors\");\n+        int expected = unknownTags.size();\n+        if (actual == expected) {\n+            passed(\"\");\n+        } else {\n+            failed(actual + \" vs \" + expected);\n+        }\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testInline(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+\n+        record TestCase(String input, String expectedOutput) { }\n+\n+        final var testCases = List.of(\n+                \/\/ minimal empty\n+                new TestCase(\"\"\"\n+                             {@snippet :\n+                             }\n+                             \"\"\",\n+                             \"\"\"\n+                             \"\"\"),\n+                \/\/ empty with a newline before `:` as a separator\n+                new TestCase(\"\"\"\n+                             {@snippet\n+                             :\n+                             }\n+                             \"\"\",\n+                             \"\"\"\n+                             \"\"\"),\n+                \/\/ empty with a newline followed by whitespace before `:`\n+                new TestCase(\"\"\"\n+                             {@snippet\n+                                       :\n+                             }\n+                             \"\"\",\n+                             \"\"\"\n+                             \"\"\"),\n+                \/\/ empty with whitespace followed by a newline before `:`\n+                new TestCase(\"\"\"\n+                             {@snippet    \\s\n+                             :\n+                             }\n+                             \"\"\",\n+                             \"\"\"\n+                             \"\"\"),\n+                \/\/ basic\n+                new TestCase(\"\"\"\n+                             {@snippet :\n+                                 Hello, Snippet!\n+                             }\n+                             \"\"\",\n+                             \"\"\"\n+                                 Hello, Snippet!\n+                             \"\"\"),\n+                \/\/ leading whitespace before `:`\n+                new TestCase(\"\"\"\n+                             {@snippet       :\n+                                 Hello, Snippet!\n+                             }\n+                             \"\"\",\n+                             \"\"\"\n+                                 Hello, Snippet!\n+                             \"\"\"),\n+                \/\/ trailing whitespace after `:`\n+                new TestCase(\"\"\"\n+                             {@snippet :      \\s\n+                                 Hello, Snippet!\n+                             }\n+                             \"\"\",\n+                             \"\"\"\n+                                 Hello, Snippet!\n+                             \"\"\"),\n+                \/\/ attributes do not interfere with body\n+                new TestCase(\"\"\"\n+                             {@snippet  attr1=\"val1\"    :\n+                                 Hello, Snippet!\n+                             }\n+                             \"\"\",\n+                             \"\"\"\n+                                 Hello, Snippet!\n+                             \"\"\"),\n+                \/\/ multi-line\n+                new TestCase(\"\"\"\n+                             {@snippet :\n+                                 Hello\n+                                 ,\n+                                  Snippet!\n+                             }\n+                             \"\"\",\n+                             \"\"\"\n+                                 Hello\n+                                 ,\n+                                  Snippet!\n+                             \"\"\"),\n+                \/\/ leading empty line\n+                new TestCase(\"\"\"\n+                             {@snippet :\n+\n+                                 Hello\n+                                 ,\n+                                  Snippet!\n+                             }\n+                             \"\"\",\n+                             \"\"\"\n+\n+                                 Hello\n+                                 ,\n+                                  Snippet!\n+                             \"\"\"),\n+                \/\/ trailing empty line\n+                new TestCase(\"\"\"\n+                             {@snippet :\n+                                 Hello\n+                                 ,\n+                                  Snippet!\n+\n+                             }\n+                             \"\"\",\n+                             \"\"\"\n+                                 Hello\n+                                 ,\n+                                  Snippet!\n+\n+                             \"\"\"),\n+                \/\/ controlling indent with `}`\n+                new TestCase(\"\"\"\n+                             {@snippet :\n+                                 Hello\n+                                 ,\n+                                  Snippet!\n+                                 }\n+                             \"\"\",\n+                             \"\"\"\n+                             Hello\n+                             ,\n+                              Snippet!\n+                             \"\"\"\n+                ),\n+                \/\/ no trailing newline before `}\n+                new TestCase(\"\"\"\n+                             {@snippet :\n+                                 Hello\n+                                 ,\n+                                  Snippet!}\n+                             \"\"\",\n+                             \"\"\"\n+                             Hello\n+                             ,\n+                              Snippet!\"\"\"),\n+                \/\/ trailing space is stripped\n+                new TestCase(\"\"\"\n+                             {@snippet :\n+                                 Hello\n+                                 ,    \\s\n+                                  Snippet!\n+                             }\n+                             \"\"\",\n+                             \"\"\"\n+                                 Hello\n+                                 ,\n+                                  Snippet!\n+                             \"\"\"),\n+                \/\/ escapes of Text Blocks and string literals are not interpreted\n+                new TestCase(\"\"\"\n+                             {@snippet :\n+                                 \\\\b\\\\t\\\\n\\\\f\\\\r\\\\\"\\\\'\\\\\\\n+                                 Hello\\\\\n+                                 ,\\\\s\n+                                  Snippet!\n+                             }\n+                             \"\"\",\n+                             \"\"\"\n+                                 \\\\b\\\\t\\\\n\\\\f\\\\r\\\\\"\\\\'\\\\    Hello\\\\\n+                                 ,\\\\s\n+                                  Snippet!\n+                             \"\"\"),\n+                \/\/ HTML is not interpreted\n+                new TestCase(\"\"\"\n+                             {@snippet :\n+                                 <\/pre>\n+                                     <!-- comment -->\n+                                 <b>&trade;<\/b> &#8230; \" '\n+                             }\n+                             \"\"\",\n+                             \"\"\"\n+                                 &lt;\/pre&gt;\n+                                     &lt;!-- comment --&gt;\n+                                 &lt;b&gt;&amp;trade;&lt;\/b&gt; &amp;#8230; \" '\n+                             \"\"\")\n+        );\n+        ClassBuilder classBuilder = new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\");\n+        forEachNumbered(testCases, (t, id) -> {\n+            classBuilder\n+                    .addMembers(\n+                            MethodBuilder\n+                                    .parse(\"public void case%s() { }\".formatted(id))\n+                                    .setComments(t.input()));\n+        });\n+        classBuilder.write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        forEachNumbered(testCases, (t, id) -> {\n+            checkOutput(\"pkg\/A.html\", true,\n+                        \"\"\"\n+                        <span class=\"element-name\">case%s<\/span>()<\/div>\n+                        <div class=\"block\">\n+                        <pre class=\"snippet\">\n+                        %s<\/pre>\n+                        <\/div>\"\"\".formatted(id, t.expectedOutput()));\n+        });\n+    }\n+\n+    @Test\n+    public void testExternalFile(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+\n+        record TestCase(String input, Function<String, String> expectedTransformation) {\n+\n+            TestCase(String input) {\n+                this(input, Function.identity());\n+            }\n+        }\n+\n+        final var testCases = List.of(\n+                new TestCase(\"\"\"\n+                             Hello, Snippet!\n+                             \"\"\"),\n+                new TestCase(\"\"\"\n+                                 Hello, Snippet!\n+                             \"\"\"),\n+                new TestCase(\"\"\"\n+                                 Hello\n+                                 ,\n+                                  Snippet!\n+                             \"\"\"),\n+                new TestCase(\"\"\"\n+\n+                                 Hello\n+                                 ,\n+                                  Snippet!\n+                             \"\"\"),\n+                new TestCase(\"\"\"\n+                                 Hello\n+                                 ,\n+                                  Snippet!\n+\n+                             \"\"\"),\n+                new TestCase(\"\"\"\n+                                 Hello\n+                                 ,        \\s\n+                                  Snippet!\n+                             \"\"\",\n+                             String::stripIndent),\n+                new TestCase(\"\"\"\n+                             Hello\n+                             ,\n+                              Snippet!\"\"\"),\n+                new TestCase(\"\"\"\n+                                 \\\\b\\\\t\\\\n\\\\f\\\\r\\\\\"\\\\'\\\\\\\n+                                 Hello\\\\\n+                                 ,\\\\s\n+                                  Snippet!\n+                             \"\"\"),\n+                new TestCase(\"\"\"\n+                                 <\/pre>\n+                                     <!-- comment -->\n+                                 <b>&trade;<\/b> &#8230; \" '\n+                             \"\"\",\n+                             s -> s.replace(\"&\", \"&amp;\").replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\")),\n+                new TestCase(\"\"\"\n+                                 &lt;\/pre&gt;\n+                                     &lt;!-- comment --&gt;\n+                                 &lt;b&gt;&amp;trade;&lt;\/b&gt; &amp;#8230; \" '\n+                             \"\"\",\n+                             s -> s.replaceAll(\"&\", \"&amp;\"))\n+        );\n+        ClassBuilder classBuilder = new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\");\n+        forEachNumbered(testCases, (t, id) -> {\n+            classBuilder\n+                    .addMembers(\n+                            MethodBuilder\n+                                    .parse(\"public void case%s() { }\".formatted(id))\n+                                    .setComments(\"\"\"\n+                                                 {@snippet file=\"%s.txt\"}\n+                                                 \"\"\".formatted(id)));\n+            addSnippetFile(srcDir, \"pkg\", \"%s.txt\".formatted(id), t.input());\n+        });\n+        classBuilder.write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        forEachNumbered(testCases, (testCase, index) -> {\n+            String expectedOutput = testCase.expectedTransformation().apply(testCase.input());\n+            checkOutput(\"pkg\/A.html\", true,\n+                        \"\"\"\n+                        <span class=\"element-name\">case%s<\/span>()<\/div>\n+                        <div class=\"block\">\n+                        <pre class=\"snippet\">\n+                        %s<\/pre>\n+                        <\/div>\"\"\".formatted(index, expectedOutput));\n+        });\n+    }\n+\n+    \/\/ TODO:\n+    \/\/   Explore the toolbox.ToolBox.writeFile and toolbox.ToolBox.writeJavaFiles methods:\n+    \/\/   see if any of them could be used instead of this one\n+    private void addSnippetFile(Path srcDir, String packageName, String fileName, String content) throws UncheckedIOException {\n+        String[] components = packageName.split(\"\\\\.\");\n+        Path snippetFiles = Path.of(components[0], Arrays.copyOfRange(components, 1, components.length)).resolve(\"snippet-files\");\n+        try {\n+            Path p = Files.createDirectories(srcDir.resolve(snippetFiles));\n+            Files.writeString(p.resolve(fileName), content, StandardOpenOption.CREATE_NEW);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    @Test\n+    public void testInlineSnippetInDocFiles(Path base) throws IOException {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        \/\/ If there is no *.java files, javadoc will not create an output\n+        \/\/ directory; so this class is created solely to trigger output.\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\")\n+                .addMembers(\n+                        MethodBuilder\n+                                .parse(\"public void m() { }\")\n+                                \/\/ a (convenience) user entry point to the html file (not used by test)\n+                                .setComments(\"<a href=\\\"doc-files\/file.html\\\">A document<\/a>\"))\n+                .write(srcDir);\n+        var content = \"\"\"\n+                              Unlike Java files, HTML files don't mind hosting\n+                              the *\/ sequence in a @snippet tag\n+                      \"\"\";\n+        String html = \"\"\"\n+                      <!DOCTYPE html>\n+                      <html lang=\"en\">\n+                        <head>\n+                          <meta charset=\"utf-8\">\n+                          <title>title<\/title>\n+                        <\/head>\n+                        <body>\n+                          <!-- yet another user entry point to the html file (not used by test): through an index page -->\n+                          {@index this A document}\n+                          {@snippet :\n+                              %s}\n+                        <\/body>\n+                      <\/html>\n+                      \"\"\".formatted(content);\n+        Path p = Files.createDirectories(srcDir.resolve(\"pkg\").resolve(\"doc-files\"));\n+        Files.writeString(p.resolve(\"file.html\"), html, StandardOpenOption.CREATE_NEW);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"pkg\/doc-files\/file.html\", true, content);\n+    }\n+\n+    @Test\n+    public void testExternalSnippetInDocFiles(Path base) throws IOException {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        \/\/ If there is no *.java files, javadoc will not create an output\n+        \/\/ directory; so this class is created solely to trigger output.\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\")\n+                .addMembers(\n+                        MethodBuilder\n+                                .parse(\"public void m() { }\")\n+                                \/\/ a (convenience) user entry point to the html file (not used by test)\n+                                .setComments(\"<a href=\\\"doc-files\/file.html\\\">A document<\/a>\"))\n+                .write(srcDir);\n+        String html = \"\"\"\n+                      <!DOCTYPE html>\n+                      <html lang=\"en\">\n+                        <head>\n+                          <meta charset=\"utf-8\">\n+                          <title>title<\/title>\n+                        <\/head>\n+                        <body>\n+                          <!-- yet another user entry point to the html file (not used by test): through an index page -->\n+                          {@index this A document}\n+                          {@snippet file=\"file.txt\"}\n+                        <\/body>\n+                      <\/html>\n+                      \"\"\";\n+        Path p = Files.createDirectories(srcDir.resolve(\"pkg\").resolve(\"doc-files\"));\n+        Files.writeString(p.resolve(\"file.html\"), html, StandardOpenOption.CREATE_NEW);\n+        String content = \"\"\"\n+                            Unlike Java files, text files don't mind hosting\n+                            the *\/ sequence in a @snippet tag\n+                         \"\"\";\n+        addSnippetFile(srcDir, \"pkg\", \"file.txt\", content);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"pkg\/doc-files\/file.html\", true, content);\n+    }\n+\n+    @Test\n+    public void testExternalFileNotFound(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        var fileName = \"text.txt\";\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\")\n+                .addMembers(\n+                        MethodBuilder\n+                                .parse(\"public void test() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet file=\"%s\"}\n+                                             \"\"\".formatted(fileName)))\n+                .write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true,\n+                    \"\"\"\n+                    A.java:4: error: File not found: %s\"\"\".formatted(fileName));\n+        checkNoCrashes();\n+    }\n+\n+    @Test \/\/ TODO perhaps this could be unified with testExternalFile\n+    public void testExternalFileModuleSourcePath(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        var fileName = \"snippet.txt\";\n+        String MODULE_NAME = \"mdl1\";\n+        String PACKAGE_NAME = \"pkg1.pkg2\";\n+        Path moduleDir = new ModuleBuilder(tb, MODULE_NAME)\n+                .exports(PACKAGE_NAME)\n+                .write(srcDir);\n+        new ClassBuilder(tb, String.join(\".\", PACKAGE_NAME, \"A\"))\n+                .setModifiers(\"public\", \"class\")\n+                .addMembers(\n+                        MethodBuilder\n+                                .parse(\"public void test() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet file=\"%s\"}\n+                                             \"\"\".formatted(fileName)))\n+                .write(moduleDir);\n+        addSnippetFile(moduleDir, PACKAGE_NAME, fileName, \"content\");\n+        javadoc(\"-d\", outDir.toString(),\n+                \"--module-source-path\", srcDir.toString(),\n+                \"--module\", MODULE_NAME);\n+        checkExit(Exit.OK);\n+    }\n+\n+    @Test \/\/ TODO perhaps this could be unified with testExternalFileNotFound\n+    public void testExternalFileNotFoundModuleSourcePath(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        var fileName = \"text.txt\";\n+        var MODULE_NAME = \"mdl1\";\n+        var PACKAGE_NAME = \"pkg1.pkg2\";\n+        Path moduleDir = new ModuleBuilder(tb, MODULE_NAME)\n+                .exports(PACKAGE_NAME)\n+                .write(srcDir);\n+        new ClassBuilder(tb, String.join(\".\", PACKAGE_NAME, \"A\"))\n+                .setModifiers(\"public\", \"class\")\n+                .addMembers(\n+                        MethodBuilder\n+                                .parse(\"public void test() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet file=\"%s\"}\n+                                             \"\"\".formatted(fileName)))\n+                .write(moduleDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"--module-source-path\", srcDir.toString(),\n+                \"--module\", MODULE_NAME);\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true,\n+                    \"\"\"\n+                    A.java:4: error: File not found: %s\"\"\".formatted(fileName));\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testNoContents(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setComments(\"\"\"\n+                             {@snippet}\n+                             \"\"\")\n+                .setModifiers(\"public\", \"class\")\n+                .write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true,\n+                    \"\"\"\n+                    A.java:3: error: @snippet does not specify contents\"\"\");\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testConflict20(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setComments(\"\"\"\n+                             {@snippet file=\"\" class=\"\" :\n+                                 Hello, Snippet!\n+                             }\n+                             \"\"\")\n+                .setModifiers(\"public\", \"class\")\n+                .write(srcDir);\n+\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        \/\/ TODO\n+        \/\/   In this and all similar tests check that there are no other errors, let alone errors related to {@snippet}\n+        \/\/   To achieve that, we might need to change JavadocTester (i.e. add \"consume output\", \"check that the output is empty\", etc.)\n+        checkOutput(Output.OUT, true,\n+                    \"\"\"\n+                    A.java:3: error: @snippet specifies multiple external contents, which is ambiguous\"\"\");\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testConflict30(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setComments(\"\"\"\n+                             {@snippet class=\"\" file=\"\" :\n+                                 Hello, Snippet!\n+                             }\n+                             \"\"\")\n+                .setModifiers(\"public\", \"class\")\n+                .write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        checkOutputEither(Output.OUT,\n+                          \"\"\"\n+                          A.java:3: error: @snippet specifies multiple external contents, which is ambiguous\"\"\");\n+        checkNoCrashes();\n+    }\n+\n+    \/\/ TODO: perhaps this method could be added to JavadocTester\n+    private void checkOutputEither(Output out, String first, String... other) {\n+        checking(\"checkOutputEither\");\n+        String output = getOutput(out);\n+        Stream<String> strings = Stream.concat(Stream.of(first), Stream.of(other));\n+        Optional<String> any = strings.filter(output::contains).findAny();\n+        if (any.isPresent()) {\n+            passed(\": following text is found:\\n\" + any.get());\n+        } else {\n+            failed(\": nothing found\");\n+        }\n+    }\n+\n+    @Test\n+    public void testConflict60(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setComments(\"\"\"\n+                             {@snippet file=\"\" file=\"\"}\n+                             \"\"\")\n+                .setModifiers(\"public\", \"class\")\n+                .write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true,\n+                    \"\"\"\n+                    A.java:3: error: repeated attribute: \"file\\\"\"\"\");\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testConflict70(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setComments(\"\"\"\n+                             {@snippet class=\"\" class=\"\" }\n+                             \"\"\")\n+                .setModifiers(\"public\", \"class\")\n+                .write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true,\n+                    \"\"\"\n+                    A.java:3: error: repeated attribute: \"class\\\"\"\"\");\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testConflict80(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setComments(\"\"\"\n+                             {@snippet class=\"\" class=\"\" :\n+                                 Hello, Snippet!\n+                             }\n+                             \"\"\")\n+                .setModifiers(\"public\", \"class\")\n+                .write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        checkOutputEither(Output.OUT,\n+                          \"\"\"\n+                          A.java:3: error: repeated attribute: \"class\\\"\"\"\",\n+                          \"\"\"\n+                          A.java:3: error: @snippet specifies external and inline contents, which is ambiguous\"\"\");\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testConflict90(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setComments(\"\"\"\n+                             {@snippet file=\"\" file=\"\" :\n+                                 Hello, Snippet!\n+                             }\n+                             \"\"\")\n+                .setModifiers(\"public\", \"class\")\n+                .write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        checkOutputEither(Output.OUT,\n+                          \"\"\"\n+                          A.java:3: error: repeated attribute: \"file\\\"\"\"\",\n+                          \"\"\"\n+                          A.java:3: error: @snippet specifies external and inline contents, which is ambiguous\"\"\");\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testErrorPositionResolution(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setComments(\"\"\"\n+                             {@snippet} {@snippet}\n+                             \"\"\")\n+                .setModifiers(\"public\", \"class\")\n+                .write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true,\n+                    \"\"\"\n+                    A.java:3: error: @snippet does not specify contents\n+                     * {@snippet} {@snippet}\n+                       ^\n+                    \"\"\",\n+                    \"\"\"\n+                    A.java:3: error: @snippet does not specify contents\n+                     * {@snippet} {@snippet}\n+                                  ^\n+                    \"\"\");\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testRegion(Path base) throws Exception {\n+        record TestCase(Snippet snippet, String expectedOutput) { }\n+        final var testCases = List.of(\n+                new TestCase(newSnippetBuilder()\n+                                     .body(\"\"\"\n+                                           \/\/ @start region=here :\n+                                           Hello\n+                                           ,\n+                                            Snippet!\n+                                           \/\/ @end\n+                                           \"\"\")\n+                                     .region(\"here\")\n+                                     .build(),\n+                             \"\"\"\n+                             Hello\n+                             ,\n+                              Snippet!\n+                             \"\"\"\n+                )\n+                ,\n+                new TestCase(newSnippetBuilder()\n+                                     .body(\"\"\"\n+                                               \/\/ @start region=here :\n+                                               Hello\n+                                               ,\n+                                                Snippet!\n+                                           \/\/ @end\n+                                               \"\"\")\n+                                     .region(\"here\")\n+                                     .build(),\n+                             \"\"\"\n+                                 Hello\n+                                 ,\n+                                  Snippet!\n+                             \"\"\")\n+                ,\n+                new TestCase(newSnippetBuilder()\n+                                     .body(\"\"\"\n+                                               \/\/ @start region=here :\n+                                               Hello\n+                                               ,\n+                                                Snippet!\/\/ @end\n+                                           \"\"\")\n+                                     .region(\"here\")\n+                                     .build(),\n+                             \"\"\"\n+                             Hello\n+                             ,\n+                              Snippet!\\\n+                             \"\"\"\n+                )\n+                ,\n+                new TestCase(newSnippetBuilder()\n+                                     .body(\"\"\"\n+                                           \/\/ @start region=there :\n+                                           \/\/ @end\n+\n+                                               \/\/ @start region=here :\n+                                               Hello\n+                                               ,\n+                                                Snippet!\n+                                               \/\/ @end\n+                                                  \"\"\")\n+                                     .region(\"here\")\n+                                     .build(),\n+                             \"\"\"\n+                             Hello\n+                             ,\n+                              Snippet!\n+                             \"\"\"\n+                )\n+                ,\n+\/\/                entry(newSnippetBuilder()\n+\/\/                              .body(\"\"\"\n+\/\/                                    \/\/ @start region=here :\n+\/\/                                        Hello\n+\/\/                                    \/\/ @end\n+\/\/\n+\/\/                                         , Snippet!\n+\/\/                                    \/\/ @end\n+\/\/                                        \"\"\")\n+\/\/                              .region(\"here\")\n+\/\/                              .build()\n+\/\/                        ,\n+\/\/                      \"\"\"\n+\/\/                          Hello\n+\/\/                      \"\"\"\n+\/\/                )\n+\/\/                ,\n+                new TestCase(newSnippetBuilder()\n+                                     .body(\"\"\"\n+                                           \/\/ @start region=here :\n+                                               This is the only line you should see.\n+                                           \/\/ @end\n+                                           \/\/ @start region=hereafter :\n+                                               You should NOT see this.\n+                                           \/\/ @end\n+                                               \"\"\")\n+                                     .region(\"here\")\n+                                     .build(),\n+                             \"\"\"\n+                                 This is the only line you should see.\n+                             \"\"\"\n+                )\n+                ,\n+                new TestCase(newSnippetBuilder()\n+                                     .body(\"\"\"\n+                                           \/\/ @start region=here :\n+                                               You should NOT see this.\n+                                           \/\/ @end\n+                                           \/\/ @start region=hereafter :\n+                                               This is the only line you should see.\n+                                           \/\/ @end\n+                                               \"\"\")\n+                                     .region(\"hereafter\")\n+                                     .build(),\n+                             \"\"\"\n+                                 This is the only line you should see.\n+                             \"\"\"\n+                )\n+                ,\n+                new TestCase(newSnippetBuilder()\n+                                     .body(\"\"\"\n+                                           \/\/ @start region=beforehand :\n+                                               You should NOT see this.\n+                                           \/\/ @end\n+                                           \/\/ @start region=before :\n+                                               This is the only line you should see.\n+                                           \/\/ @end\n+                                               \"\"\")\n+                                     .region(\"before\")\n+                                     .build(),\n+                             \"\"\"\n+                                 This is the only line you should see.\n+                             \"\"\"\n+                )\n+                ,\n+                new TestCase(newSnippetBuilder()\n+                                     .body(\"\"\"\n+                                           \/\/ @start region=beforehand :\n+                                               This is the only line you should see.\n+                                           \/\/ @end\n+                                           \/\/ @start region=before :\n+                                               You should NOT see this.\n+                                           \/\/ @end\n+                                               \"\"\")\n+                                     .region(\"beforehand\")\n+                                     .build(),\n+                             \"\"\"\n+                                 This is the only line you should see.\n+                             \"\"\"\n+                )\n+        );\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        ClassBuilder classBuilder = new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\");\n+        forEachNumbered(testCases, (t, id) -> {\n+            var snippet = t.snippet();\n+            classBuilder\n+                    .addMembers(\n+                            MethodBuilder\n+                                    .parse(\"public void case%s() { }\".formatted(id))\n+                                    .setComments(\"\"\"\n+                                                 {@snippet region=\"%s\" :\n+                                                 %s}\n+                                                 \"\"\".formatted(snippet.regionName(), snippet.body())));\n+        });\n+        classBuilder.write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        forEachNumbered(testCases, (t, index) -> {\n+            checkOutput(\"pkg\/A.html\", true,\n+                        \"\"\"\n+                        <span class=\"element-name\">case%s<\/span>()<\/div>\n+                        <div class=\"block\">\n+                        <pre class=\"snippet\">\n+                        %s<\/pre>\n+                        <\/div>\"\"\".formatted(index, t.expectedOutput()));\n+        });\n+    }\n+\n+    private static Snippet.Builder newSnippetBuilder() {\n+        return new Snippet.Builder();\n+    }\n+\n+    private record Snippet(String regionName, String body, String fileContent) {\n+\n+        static class Builder {\n+\n+            private String regionName;\n+            private String body;\n+            private String fileContent;\n+\n+            Builder region(String name) {\n+                this.regionName = name;\n+                return this;\n+            }\n+\n+            Builder body(String content) {\n+                this.body = content;\n+                return this;\n+            }\n+\n+            Builder fileContent(String fileContent) {\n+                this.fileContent = fileContent;\n+                return this;\n+            }\n+\n+            Snippet build() {\n+                return new Snippet(regionName, body, fileContent);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testAttributeValueSyntaxUnquotedCurly(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        \/*\n+         * The snippet region attribute's value is empty because the tag is\n+         * terminated by the first }\n+         *\n+         *    v                v\n+         *    {@snippet region=} :\n+         *        \/\/ @start region=\"}\" @end\n+         *    }\n+         *\/\n+        ClassBuilder classBuilder = new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\")\n+                .addMembers(\n+                        MethodBuilder\n+                                .parse(\"public void case0() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet region=} :\n+                                                 \/\/ @start region=\"}\" @end\n+                                             }\n+                                             \"\"\"));\n+        classBuilder.write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true,\n+                    \"\"\"\n+                    A.java:4: error: @snippet does not specify contents\"\"\");\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testAttributeValueSyntaxCurly(Path base) throws Exception {\n+        \/*\n+         * The snippet has to be external, otherwise its content would\n+         * interfere with the test: that internal closing curly would\n+         * terminate the @snippet tag:\n+         *\n+         *     v\n+         *     {@snippet region=\"}\" :\n+         *         \/\/ @start region=\"}\" @end\n+         *                           ^\n+         *     }\n+         *\/\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        addSnippetFile(srcDir, \"pkg\", \"file.txt\", \"\"\"\n+                                                  \/\/ @start region=\"}\" @end\n+                                                  \"\"\"\n+        );\n+        ClassBuilder classBuilder = new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\")\n+                .addMembers(\n+                        MethodBuilder\n+                                .parse(\"public void case0() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet region=\"}\" file=\"file.txt\"}\n+                                             \"\"\"))\n+                .addMembers(\n+                        MethodBuilder\n+                                .parse(\"public void case1() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet region='}' file=\"file.txt\"}\n+                                             \"\"\"));\n+        classBuilder.write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"pkg\/A.html\", true,\n+                    \"\"\"\n+                    <span class=\"element-name\">case0<\/span>()<\/div>\n+                    <div class=\"block\">\n+                    <pre class=\"snippet\">\n+                    <\/pre>\n+                    <\/div>\"\"\");\n+        checkOutput(\"pkg\/A.html\", true,\n+                    \"\"\"\n+                    <span class=\"element-name\">case1<\/span>()<\/div>\n+                    <div class=\"block\">\n+                    <pre class=\"snippet\">\n+                    <\/pre>\n+                    <\/div>\"\"\");\n+    }\n+\n+    @Test\n+    public void testAttributeValueSyntax(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        \/\/ Test most expected use cases for external snippet\n+        final var snippets = List.of(\n+                \"\"\"\n+                {@snippet file=file region=region}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file=file region= region}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file=file region=\"region\"}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file=file region='region'}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file= file region=region}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file= file region= region}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file= file region=\"region\"}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file= file region='region'}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file=\"file\" region=region}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file=\"file\" region= region}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file=\"file\" region=\"region\"}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file=\"file\" region='region'}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file='file' region=region}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file='file' region= region}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file='file' region=\"region\"}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file='file' region='region'}\n+                \"\"\",\n+                \/\/ ---------------------------------------------------------------\n+                \"\"\"\n+                {@snippet region=region file=file}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet region=region file=\"file\"}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet region=\"region\" file=\"file\"}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file=\"file\"\n+                          region=\"region\"}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file=\"file\"\n+                          region=region}\n+                \"\"\"\n+        );\n+        addSnippetFile(srcDir, \"pkg\", \"file\", \"\"\"\n+                                              1 \/\/ @start region=bar @end\n+                                              2 \/\/ @start region=region @end\n+                                              3 \/\/ @start region=foo @end\n+                                              \"\"\");\n+        ClassBuilder classBuilder = new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\");\n+        forEachNumbered(snippets, (s, i) -> {\n+            classBuilder.addMembers(\n+                    MethodBuilder.parse(\"public void case%s() { }\".formatted(i)).setComments(s));\n+        });\n+        classBuilder.write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        for (int j = 0; j < snippets.size(); j++) {\n+            checkOutput(\"pkg\/A.html\", true,\n+                        \"\"\"\n+                        <span class=\"element-name\">case%s<\/span>()<\/div>\n+                        <div class=\"block\">\n+                        <pre class=\"snippet\">\n+                        2<\/pre>\n+                        <\/div>\n+                        \"\"\".formatted(j));\n+        }\n+    }\n+\n+    @Test\n+    public void testComment(Path base) throws Exception {\n+        record TestCase(Snippet snippet, String expectedOutput) { }\n+        final var testCases = List.of(\n+                new TestCase(newSnippetBuilder()\n+                                     .body(\"\"\"\n+                                           \/\/ \/\/ @replace substring=\"\/\/\" replacement=\"Hello\"\n+                                           ,\n+                                            Snippet!\"\"\")\n+                                     .build(),\n+                             \"\"\"\n+                             Hello\n+                             ,\n+                              Snippet!\"\"\"\n+                )\n+                ,\n+                new TestCase(newSnippetBuilder()\n+                                     .body(\"\"\"\n+                                           \/\/             \/\/ @replace substring=\"\/\/\" replacement=\"Hello\"\n+                                           ,\n+                                            Snippet!\"\"\")\n+                                     .build(),\n+                             \"\"\"\n+                             Hello\n+                             ,\n+                              Snippet!\"\"\"\n+                )\n+                ,\n+                new TestCase(newSnippetBuilder()\n+                                     .body(\"\"\"\n+                                           \/\/ \/\/ @replace substring=\"\/\/\" replacement=\" Hello\"\n+                                           ,\n+                                            Snippet!\"\"\")\n+                                     .build(),\n+                             \"\"\"\n+                              Hello\n+                             ,\n+                              Snippet!\"\"\"\n+                )\n+\/\/ Uncomment when parser has improved (this would allow to write meta snippets,\n+\/\/ i.e. snippets showing how to write snippets.\n+\/\/\n+\/\/                ,\n+\/\/                entry(newSnippetBuilder()\n+\/\/                              .body(\"\"\"\n+\/\/                                    \/\/ snippet-comment : \/\/ snippet-comment : my comment\"\"\")\n+\/\/                              .build(),\n+\/\/                      \"\"\"\n+\/\/                      \/\/ snippet-comment : my comment\"\"\"\n+\/\/                )\n+        );\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        ClassBuilder classBuilder = new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\");\n+        forEachNumbered(testCases, (t, id) -> {\n+            classBuilder\n+                    .addMembers(\n+                            MethodBuilder\n+                                    .parse(\"public void case%s() { }\".formatted(id))\n+                                    .setComments(\"\"\"\n+                                                 {@snippet :\n+                                                 %s}\n+                                                 \"\"\".formatted(t.snippet().body())));\n+        });\n+        classBuilder.write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        forEachNumbered(testCases, (t, index) -> {\n+            checkOutput(\"pkg\/A.html\", true,\n+                        \"\"\"\n+                        <span class=\"element-name\">case%s<\/span>()<\/div>\n+                        <div class=\"block\">\n+                        <pre class=\"snippet\">\n+                        %s<\/pre>\n+                        <\/div>\"\"\".formatted(index, t.expectedOutput()));\n+        });\n+    }\n+\n+    @Test\n+    public void testRedundantFileNotFound(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        var fileName = \"text.txt\";\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\")\n+                .addMembers(\n+                        MethodBuilder\n+                                .parse(\"public void test() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet file=\"%s\":\n+                                                 Hello, Snippet!}\n+                                             \"\"\".formatted(fileName)))\n+                .write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true,\n+                    \"\"\"\n+                    A.java:4: error: File not found: %s\"\"\".formatted(fileName));\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testRedundantRegionNotFound(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        var fileName = \"text.txt\";\n+        var region = \"here\";\n+        var content =\n+                \"\"\"\n+                Hello, Snippet!\"\"\";\n+\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\")\n+                .addMembers(\n+                        MethodBuilder\n+                                .parse(\"public void test() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet region=\"%s\" file=\"%s\":\n+                                             %s}\n+                                             \"\"\".formatted(region, fileName, content)))\n+                .write(srcDir);\n+        addSnippetFile(srcDir, \"pkg\", fileName, content);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true,\n+                    \"\"\"\n+                    A.java:4: error: region not found: \"%s\\\"\"\"\".formatted(region));\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testRedundantMismatch(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        var fileName = \"text.txt\";\n+        var content =\n+                \"\"\"\n+                Hello, Snippet!\"\"\";\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\")\n+                .addMembers(\n+                        MethodBuilder\n+                                .parse(\"public void test() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet file=\"%s\":\n+                                             %s}\n+                                             \"\"\".formatted(fileName, content)))\n+                .write(srcDir);\n+        addSnippetFile(srcDir, \"pkg\", fileName, content + \"...more\");\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true,\n+                    \"\"\"\n+                    A.java:4: error: contents mismatch\"\"\");\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testRedundantRegionRegionMismatch(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        var fileName = \"text.txt\";\n+        var region = \"here\";\n+        var content =\n+                \"\"\"\n+                Hello, Snippet!\"\"\";\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\")\n+                .addMembers(\n+                        MethodBuilder\n+                                .parse(\"public void test() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet region=\"%s\" file=\"%s\":\n+                                             Above the region.\n+                                             \/\/ @start region=\"%s\" :\n+                                             %s ...more\n+                                             \/\/ @end\n+                                             Below the region}\n+                                             \"\"\".formatted(region, fileName, region, content)))\n+                .write(srcDir);\n+        addSnippetFile(srcDir, \"pkg\", fileName,\n+                       \"\"\"\n+                       This line is above the region.\n+                       \/\/ @start region=\"%s\" :\n+                       %s\n+                       \/\/ @end\n+                       This line is below the region.\"\"\".formatted(region, content));\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true,\n+                    \"\"\"\n+                    A.java:4: error: contents mismatch\"\"\");\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testRedundantRegion1Mismatch(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        var fileName = \"text.txt\";\n+        var region = \"here\";\n+        var content =\n+                \"\"\"\n+                Hello, Snippet!\"\"\";\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\")\n+                .addMembers(\n+                        MethodBuilder\n+                                .parse(\"public void test() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet region=\"%s\" file=\"%s\":\n+                                             Above the region.\n+                                             \/\/ @start region=\"%s\" :\n+                                             %s ...more\n+                                             \/\/ @end\n+                                             Below the region}\n+                                             \"\"\".formatted(region, fileName, region, content)))\n+                .write(srcDir);\n+        addSnippetFile(srcDir, \"pkg\", fileName, content);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true,\n+                    \"\"\"\n+                    A.java:4: error: contents mismatch\"\"\");\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testRedundantRegion2Mismatch(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        var fileName = \"text.txt\";\n+        var region = \"here\";\n+        var content =\n+                \"\"\"\n+                Hello, Snippet!\"\"\";\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\")\n+                .addMembers(\n+                        MethodBuilder\n+                                .parse(\"public void test() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet region=\"%s\" file=\"%s\":\n+                                             %s}\n+                                             \"\"\".formatted(region, fileName, content)))\n+                .write(srcDir);\n+        addSnippetFile(srcDir, \"pkg\", fileName,\n+                       \"\"\"\n+                       Above the region.\n+                       \/\/ @start region=\"%s\" :\n+                       %s ...more\n+                       \/\/ @end\n+                       Below the region\n+                       \"\"\".formatted(region, content));\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true,\n+                    \"\"\"\n+                    A.java:4: error: contents mismatch\"\"\");\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testRedundant(Path base) throws Exception {\n+        record TestCase(Snippet snippet, String expectedOutput) { }\n+        final var testCases = List.of(\n+                new TestCase(newSnippetBuilder()\n+                                     .body(\"\"\"\n+                                           Hello\n+                                           ,\n+                                            Snippet!\"\"\")\n+                                     .fileContent(\n+                                             \"\"\"\n+                                             Hello\n+                                             ,\n+                                              Snippet!\"\"\")\n+                                     .build(),\n+                             \"\"\"\n+                             Hello\n+                             ,\n+                              Snippet!\"\"\"\n+                )\n+                ,\n+                new TestCase(newSnippetBuilder()\n+                                     .body(\"\"\"\n+                                             Hello\n+                                             ,\n+                                              Snippet!\n+                                           \"\"\")\n+                                     .region(\"here\")\n+                                     .fileContent(\n+                                             \"\"\"\n+                                             Above the region.\n+                                             \/\/ @start region=here :\n+                                               Hello\n+                                               ,\n+                                                Snippet!\n+                                             \/\/ @end\n+                                             Below the region.\n+                                             \"\"\")\n+                                     .build(),\n+                             \"\"\"\n+                               Hello\n+                               ,\n+                                Snippet!\n+                             \"\"\"\n+                )\n+                ,\n+                new TestCase(newSnippetBuilder()\n+                                     .body(\"\"\"\n+                                           Above the region.\n+                                           \/\/ @start region=here :\n+                                             Hello\n+                                             ,\n+                                              Snippet!\n+                                           \/\/ @end\n+                                           Below the region.\n+                                           \"\"\")\n+                                     .region(\"here\")\n+                                     .fileContent(\n+                                             \"\"\"\n+                                               Hello\n+                                               ,\n+                                                Snippet!\n+                                             \"\"\")\n+                                     .build(),\n+                             \"\"\"\n+                               Hello\n+                               ,\n+                                Snippet!\n+                             \"\"\"\n+                )\n+                ,\n+                new TestCase(newSnippetBuilder()\n+                                     .body(\"\"\"\n+                                           Above the region.\n+                                           \/\/ @start region=here :\n+                                             Hello\n+                                             ,\n+                                              Snippet!\n+                                           \/\/ @end\n+                                           Below the region.\n+                                           \"\"\")\n+                                     .region(\"here\")\n+                                     .fileContent(\n+                                             \"\"\"\n+                                             Above the region.\n+                                             \/\/ @start region=here :\n+                                               Hello\n+                                               ,\n+                                                Snippet!\n+                                             \/\/ @end\n+                                             Below the region.\n+                                             \"\"\")\n+                                     .build(),\n+                             \"\"\"\n+                               Hello\n+                               ,\n+                                Snippet!\n+                             \"\"\"\n+                )\n+        );\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        ClassBuilder classBuilder = new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\");\n+        forEachNumbered(testCases, (t, id) -> {\n+            var snippet = t.snippet();\n+            final String r = snippet.regionName() == null ? \"\" : \"region=\\\"\" + snippet.regionName() + \"\\\"\";\n+            final String f = snippet.fileContent() == null ? \"\" : \"file=\\\"%s.txt\\\"\".formatted(id);\n+            classBuilder\n+                    .addMembers(\n+                            MethodBuilder\n+                                    .parse(\"public void case%s() { }\".formatted(id))\n+                                    .setComments(\"\"\"\n+                                                 {@snippet %s %s:\n+                                                 %s}\n+                                                 \"\"\".formatted(r, f, snippet.body())));\n+            addSnippetFile(srcDir, \"pkg\", \"%s.txt\".formatted(id), snippet.fileContent());\n+        });\n+        classBuilder.write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        forEachNumbered(testCases, (t, index) -> {\n+            checkOutput(\"pkg\/A.html\", true,\n+                        \"\"\"\n+                        <span class=\"element-name\">case%s<\/span>()<\/div>\n+                        <div class=\"block\">\n+                        <pre class=\"snippet\">\n+                        %s<\/pre>\n+                        <\/div>\"\"\".formatted(index, t.expectedOutput()));\n+        });\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSnippetTag\/TestSnippetTag.java","additions":1878,"deletions":0,"binary":false,"changes":1878,"status":"added"},{"patch":"@@ -23,0 +23,1 @@\n+          {@snippet}: ..... overview module package type constructor method field inline ........\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTaglets\/TestTaglets.out","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-        if (values.length != 3)\n+        if (values.length != 4)\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/api\/basic\/DocumentationToolLocationTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,0 +108,7 @@\n+            case \"SnippetTree\" ->\n+                    test(d, type, \"\"\"\n+                            {@snippet :\n+                                abc\n+                            }\n+                            \"\"\");\n+\n","filename":"test\/langtools\/tools\/doclint\/EmptyHtmlTest.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -590,0 +590,12 @@\n+            @Override\n+            public Void visitSnippet(SnippetTree node, Void p) {\n+                header(node);\n+                indent(+1);\n+                print(\"attributes\", node.getAttributes());\n+                print(\"body\", node.getBody());\n+                indent(-1);\n+                indent();\n+                out.println(\"]\");\n+                return null;\n+            }\n+\n","filename":"test\/langtools\/tools\/javac\/doctree\/DocCommentTester.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8201533\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.file\n+ *          jdk.compiler\/com.sun.tools.javac.tree\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build DocCommentTester\n+ * @run main DocCommentTester SnippetTest.java\n+ *\/\n+\n+class SnippetTest {\n+    \/**\n+     * {@snippet attr1=\"val1\" :\n+     *     Hello, Snippet!\n+     * }\n+     *\/\n+    void inline() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:1\n+  firstSentence: 1\n+    Snippet[SNIPPET, pos:1\n+      attributes: 1\n+        Attribute[ATTRIBUTE, pos:11\n+          name: attr1\n+          vkind: DOUBLE\n+          value: 1\n+            Text[TEXT, pos:18, val1]\n+        ]\n+      body:\n+        Text[TEXT, pos:26, _____Hello,_Snippet!|_]\n+    ]\n+  body: empty\n+  block tags: empty\n+]\n+*\/\n+}\n","filename":"test\/langtools\/tools\/javac\/doctree\/SnippetTest.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"}]}