{"files":[{"patch":"@@ -69,2 +69,2 @@\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.parser.Style;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.text.AnnotatedText;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.Style;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.StyledText;\n@@ -383,1 +383,1 @@\n-    protected Content snippetTagOutput(Element element, SnippetTree tag, AnnotatedText<Style> content) {\n+    protected Content snippetTagOutput(Element element, SnippetTree tag, StyledText content) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TagletWriterImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,5 +35,4 @@\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.action.Action;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.parser.ParseException;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.parser.Parser;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.parser.Style;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.text.AnnotatedText;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.Action;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.ParseException;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.Parser;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.StyledText;\n@@ -181,2 +180,2 @@\n-        AnnotatedText<Style> inlineSnippet = null;\n-        AnnotatedText<Style> externalSnippet = null;\n+        StyledText inlineSnippet = null;\n+        StyledText externalSnippet = null;\n@@ -210,2 +209,2 @@\n-            AnnotatedText<Style> r1 = null;\n-            AnnotatedText<Style> r2 = null;\n+            StyledText r1 = null;\n+            StyledText r2 = null;\n@@ -249,1 +248,1 @@\n-        AnnotatedText<Style> text = inlineSnippet != null ? inlineSnippet : externalSnippet;\n+        StyledText text = inlineSnippet != null ? inlineSnippet : externalSnippet;\n@@ -273,1 +272,1 @@\n-    private AnnotatedText<Style> parse(String content) throws ParseException {\n+    private StyledText parse(String content) throws ParseException {\n@@ -311,1 +310,1 @@\n-     * Returns a version of annotated text that can be rendered into HTML or\n+     * Returns a version of styled text that can be rendered into HTML or\n@@ -319,1 +318,1 @@\n-    private static <T> AnnotatedText<T> toDisplayForm(AnnotatedText<T> source) {\n+    private static StyledText toDisplayForm(StyledText source) {\n@@ -321,1 +320,1 @@\n-        var result = new AnnotatedText<T>();\n+        var result = new StyledText();\n@@ -325,1 +324,1 @@\n-        \/\/ transformation performed on a character sequence to the annotated\n+        \/\/ transformation performed on a character sequence to the styled\n@@ -338,1 +337,1 @@\n-            \/\/ append the possibly annotated newline, but not if it's the last line\n+            \/\/ append the possibly styled newline, but not if it's the last line\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SnippetTaglet.java","additions":15,"deletions":16,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -48,2 +48,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.parser.Style;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.text.AnnotatedText;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.StyledText;\n@@ -188,1 +187,1 @@\n-    protected abstract Content snippetTagOutput(Element element, SnippetTree snippetTag, AnnotatedText<Style> text);\n+    protected abstract Content snippetTagOutput(Element element, SnippetTree snippetTag, StyledText text);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/TagletWriter.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+\n+\/**\n+ * An action described by markup. Such an action is typically a compound built\n+ * from primitive operations of {@link StyledText}.\n+ *\n+ * <p><b>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own risk.\n+ * This code and its internal interfaces are subject to change or\n+ * deletion without notice.<\/b>\n+ *\/\n+\/\/ FIXME: uncomment \/* sealed *\/ when minimum boot version >= 17\n+public \/* sealed *\/ interface Action \/* permits AddStyle, Bookmark, Replace *\/ {\n+\n+    \/**\n+     * Performs this action.\n+     *\/\n+    void perform();\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Action.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * An action that applies an additional style to text.\n+ *\n+ * <p><b>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own risk.\n+ * This code and its internal interfaces are subject to change or\n+ * deletion without notice.<\/b>\n+ *\/\n+public final class AddStyle implements Action {\n+\n+    private final Style style;\n+    private final Pattern pattern;\n+    private final StyledText text;\n+\n+    \/**\n+     * Constructs an action that applies an additional style to regex finds in\n+     * text.\n+     *\n+     * @param style the style to add (to already existing styles)\n+     * @param pattern the regex used to search the text\n+     * @param text the text to search\n+     *\/\n+    public AddStyle(Style style, Pattern pattern, StyledText text) {\n+        this.style = style;\n+        this.pattern = pattern;\n+        this.text = text;\n+    }\n+\n+    @Override\n+    public void perform() {\n+        var singleStyle = Set.of(style);\n+        Matcher matcher = pattern.matcher(text.asCharSequence());\n+        while (matcher.find()) {\n+            int start = matcher.start();\n+            int end = matcher.end();\n+            text.subText(start, end).addStyle(singleStyle);\n+        }\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/AddStyle.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet.parser;\n+package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Attribute.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/parser\/Attribute.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet.parser;\n+package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Attributes.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/parser\/Attributes.java","status":"renamed"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+\n+\/**\n+ * An action that associates text with a name.\n+ *\n+ * <p><b>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own risk.\n+ * This code and its internal interfaces are subject to change or\n+ * deletion without notice.<\/b>\n+ *\/\n+public final class Bookmark implements Action {\n+\n+    private final String name;\n+    private final StyledText text;\n+\n+    \/**\n+     * Constructs an action that associates text with a name.\n+     *\n+     * @param name the string (key) to associate text with\n+     * @param text the text\n+     *\/\n+    public Bookmark(String name, StyledText text) {\n+        this.name = name;\n+        this.text = text;\n+    }\n+\n+    @Override\n+    public void perform() {\n+        text.subText(0, text.length()).bookmark(name);\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Bookmark.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet.parser;\n+package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/MarkupParser.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/parser\/MarkupParser.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet.parser;\n+package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/ParseException.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/parser\/ParseException.java","status":"renamed"},{"patch":"@@ -26,7 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet.parser;\n-\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.action.Action;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.action.Annotate;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.action.Bookmark;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.action.Replace;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.text.AnnotatedText;\n+package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n@@ -150,1 +144,1 @@\n-        AnnotatedText<Style> text = new AnnotatedText<>();\n+        StyledText text = new StyledText();\n@@ -250,1 +244,1 @@\n-                    Annotate a = new Annotate(new Style.Link(target.value()),\n+                    AddStyle a = new AddStyle(new Style.Link(target.value()),\n@@ -268,1 +262,1 @@\n-                    Annotate a = new Annotate(new Style.Name(typeValue),\n+                    AddStyle a = new AddStyle(new Style.Name(typeValue),\n@@ -414,1 +408,1 @@\n-    private void append(AnnotatedText<Style> text, Set<Style> style, CharSequence s) {\n+    private void append(StyledText text, Set<Style> style, CharSequence s) {\n@@ -418,1 +412,1 @@\n-    public record Result(AnnotatedText<Style> text, Queue<Action> actions) { }\n+    public record Result(StyledText text, Queue<Action> actions) { }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Parser.java","additions":6,"deletions":12,"binary":false,"changes":18,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/parser\/Parser.java","status":"renamed"},{"patch":"@@ -26,3 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet.action;\n-\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.text.AnnotatedText;\n+package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n@@ -47,1 +45,1 @@\n-    private final AnnotatedText<?> text;\n+    private final StyledText text;\n@@ -56,1 +54,1 @@\n-    public Replace(String replacement, Pattern pattern, AnnotatedText<?> text) {\n+    public Replace(String replacement, Pattern pattern, StyledText text) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Replace.java","additions":3,"deletions":5,"binary":false,"changes":8,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/action\/Replace.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet.parser;\n+package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Style.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/parser\/Style.java","status":"renamed"},{"patch":"@@ -0,0 +1,343 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+\n+\/**\n+ * A mutable sequence of individually styleable characters.\n+ *\n+ * <p><b>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own risk.\n+ * This code and its internal interfaces are subject to change or\n+ * deletion without notice.<\/b>\n+ *\/\n+public class StyledText {\n+\n+    private Map<String, StyledText> bookmarks;\n+    private StringBuilder chars;\n+    private Styles styles;\n+    private List<WeakReference<SubText>> subtexts;\n+\n+    public StyledText() {\n+        init();\n+    }\n+\n+    \/*\n+     * This method should be overridden to be no-op by a subclass that wants to\n+     * inherit the interface but not the implementation, which includes\n+     * unnecessary internal objects. If this is done, then all public methods\n+     * should be overridden too, otherwise they will not work.\n+     *\n+     * An alternative design would be to provide an interface for styled text;\n+     * but I ruled that out as unnecessarily heavyweight.\n+     *\/\n+    protected void init() {\n+        this.bookmarks = new HashMap<>();\n+        this.chars = new StringBuilder();\n+        this.styles = new Styles();\n+        this.subtexts = new ArrayList<>();\n+    }\n+\n+    \/*\n+     * For each character of this text adds the provided objects to a set of\n+     * objects associated with that character.\n+     *\/\n+    public void addStyle(Set<? extends Style> additionalStyles) {\n+        styles.add(0, length(), additionalStyles);\n+    }\n+\n+    public int length() {\n+        return chars.length();\n+    }\n+\n+    \/*\n+     * Replaces all characters of this text with the provided sequence of\n+     * characters, each of which is associated with all the provided objects.\n+     *\/\n+    public void replace(Set<? extends Style> styles, CharSequence plaintext) {\n+        replace(0, length(), styles, plaintext);\n+    }\n+\n+    \/*\n+     * A multi-purpose operation that can be used to replace, insert or delete\n+     * text. The effect on a text is as if [start, end) were deleted and\n+     * then plaintext inserted at start.\n+     *\/\n+    private void replace(int start, int end, Set<? extends Style> styles, CharSequence plaintext) {\n+        chars.replace(start, end, plaintext.toString());\n+        this.styles.delete(start, end);\n+        this.styles.insert(start, plaintext.length(), styles);\n+        \/\/ The number of subtexts is not expected to be big; hence no\n+        \/\/ optimizations are applied\n+        var iterator = subtexts.iterator();\n+        while (iterator.hasNext()) {\n+            WeakReference<SubText> ref = iterator.next();\n+            SubText txt = ref.get();\n+            if (txt == null) {\n+                iterator.remove(); \/\/ a stale ref\n+            } else {\n+                update(start, end, plaintext.length(), txt);\n+            }\n+        }\n+    }\n+\n+    \/*\n+     * Updates the text given the scope of the change to reflect text continuity.\n+     *\/\n+    private void update(int start, int end, int newLength, SubText text) {\n+        assert start <= end;\n+        assert text.start <= text.end;\n+        assert newLength >= 0;\n+        if (text.start == text.end && start == text.start) {\n+            \/\/ insertion into empty text; special-cased for simplicity\n+            text.end += newLength;\n+            return;\n+        }\n+        if (end <= text.start) { \/\/ the change is on the left-hand side of the text\n+            int diff = newLength - (end - start);\n+            text.start += diff;\n+            text.end += diff;\n+        } else if (text.end <= start) { \/\/ the change is on the right-hand side of the text\n+            \/\/ no-op; explicit \"if\" for clarity\n+        } else { \/\/ the change intersects with the text\n+            if (text.start <= start && end <= text.end) { \/\/ the change is within the text\n+                text.end += newLength - (end - start);\n+            } else {\n+                int intersectionLen = min(end, text.end) - max(start, text.start);\n+                int oldLen = text.end - text.start;\n+                if (start <= text.start) {\n+                    text.start = start + newLength;\n+                }\n+                text.end = text.start + oldLen - intersectionLen;\n+            }\n+        }\n+    }\n+\n+    private void addStyle(int start, int end, Set<? extends Style> additionalStyles) {\n+        styles.add(start, end, additionalStyles);\n+    }\n+\n+    public StyledText getBookmarkedText(String bookmark) {\n+        return bookmarks.get(Objects.requireNonNull(bookmark));\n+    }\n+\n+    \/*\n+     * Maps the provided name to this text, using a flat namespace. A flat\n+     * namespace means that this text (t), as well as any subtext derived from\n+     * either t or t's subtext, share the naming map.\n+     *\/\n+    public void bookmark(String name) {\n+        bookmark(name, 0, length());\n+    }\n+\n+    private void bookmark(String name, int start, int end) {\n+        bookmarks.put(Objects.requireNonNull(name), subText(start, end));\n+    }\n+\n+    \/*\n+     * Selects a view of the portion of this text starting from start\n+     * (inclusive) to end (exclusive).\n+     *\n+     * In contrast with java.util.List.subList, returned views provide extra\n+     * consistency: they reflect structural changes happening to the underlying\n+     * text and other views thereof.\n+     *\/\n+    public StyledText subText(int start, int end) {\n+        Objects.checkFromToIndex(start, end, length());\n+        var s = new SubText(start, end);\n+        subtexts.add(new WeakReference<>(s));\n+        return s;\n+    }\n+\n+    \/*\n+     * Returns plaintext version of this text. This method is to be used for\n+     * algorithms that accept String or CharSequence to map the result back to\n+     * this text.\n+     *\n+     * There are no extensible \"mutable string\" interface. java.lang.Appendable\n+     * does not support replacements and insertions. StringBuilder\/StringBuffer\n+     * is not extensible. Even if it were extensible, not many general-purpose\n+     * string algorithms accept it.\n+     *\/\n+    public CharSequence asCharSequence() {\n+        return chars;\n+    }\n+\n+    \/*\n+     * Provides text to the consumer efficiently. The text always calls the\n+     * consumer at least once; even if the text is empty.\n+     *\/\n+    public void consumeBy(StyledText.Consumer consumer) {\n+        consumeBy(consumer, 0, length());\n+    }\n+\n+    private void consumeBy(StyledText.Consumer consumer, int start, int end) {\n+        Objects.checkFromToIndex(start, end, length());\n+        styles.consumeBy(consumer, chars, start, end);\n+    }\n+\n+    public StyledText append(Set<? extends Style> styles, CharSequence sequence) {\n+        subText(length(), length()).replace(styles, sequence);\n+        return this;\n+    }\n+\n+    public StyledText append(StyledText fragment) {\n+        fragment.consumeBy((style, sequence) -> subText(length(), length()).replace(style, sequence));\n+        return this;\n+    }\n+\n+    @FunctionalInterface\n+    public interface Consumer {\n+\n+        void consume(Set<? extends Style> style, CharSequence sequence);\n+    }\n+\n+    \/*\n+     * A structure that stores character styles.\n+     *\/\n+    private static final class Styles {\n+\n+        \/\/ Although this structure optimizes neither memory use nor object\n+        \/\/ allocation, it is simple both to implement and reason about.\n+\n+        \/\/ list is a reference to ArrayList because this class accesses list by\n+        \/\/ index, so this is important that the list is RandomAccess, which\n+        \/\/ ArrayList is\n+        private final ArrayList<Set<Style>> list = new ArrayList<>();\n+\n+        private void delete(int fromIndex, int toIndex) {\n+            list.subList(fromIndex, toIndex).clear();\n+        }\n+\n+        private void insert(int fromIndex, int length, Set<? extends Style> s) {\n+            list.addAll(fromIndex, Collections.nCopies(length, Set.copyOf(s)));\n+        }\n+\n+        private void add(int fromIndex, int toIndex, Set<? extends Style> additional) {\n+            Set<Style> copyOfAdditional = Set.copyOf(additional);\n+            list.subList(fromIndex, toIndex).replaceAll(current -> sum(current, copyOfAdditional));\n+        }\n+\n+        private Set<Style> sum(Set<? extends Style> a, Set<Style> b) {\n+            \/\/ assumption: until there are complex texts, the most common\n+            \/\/ scenario is the one where `a` is empty while `b` is not\n+            if (a.isEmpty()) {\n+                return b;\n+            } else {\n+                Set<Style> c = new HashSet<>(a);\n+                c.addAll(b);\n+                return Set.copyOf(c);\n+            }\n+        }\n+\n+        private void consumeBy(StyledText.Consumer consumer, CharSequence seq, int start, int end) {\n+            if (start == end) {\n+                \/\/ an empty region doesn't have an associated set; special-cased\n+                \/\/ for simplicity to avoid more complicated implementation of\n+                \/\/ this method using a do-while loop\n+                consumer.consume(Set.of(), \"\");\n+            } else {\n+                for (int i = start, j = i + 1; i < end; i = j) {\n+                    var ith = list.get(i);\n+                    while (j < end && ith.equals(list.get(j))) {\n+                        j++;\n+                    }\n+                    consumer.consume(ith, seq.subSequence(i, j));\n+                }\n+            }\n+        }\n+    }\n+\n+    final class SubText extends StyledText {\n+\n+        int start, end;\n+\n+        private SubText(int start, int end) {\n+            this.start = start;\n+            this.end = end;\n+        }\n+\n+        @Override\n+        protected void init() {\n+            \/\/ no-op\n+        }\n+\n+        @Override\n+        public void addStyle(Set<? extends Style> additionalStyles) {\n+            StyledText.this.addStyle(start, end, additionalStyles);\n+        }\n+\n+        @Override\n+        public int length() {\n+            return end - start;\n+        }\n+\n+        @Override\n+        public void replace(Set<? extends Style> styles, CharSequence plaintext) {\n+            \/\/ If the \"replace\" operation affects this text's size, which it\n+            \/\/ can, then that size will be updated along with all other sizes\n+            \/\/ during the bulk \"update\" operation in tracking text instance.\n+            StyledText.this.replace(start, end, styles, plaintext);\n+        }\n+\n+        @Override\n+        public StyledText getBookmarkedText(String bookmark) {\n+            return StyledText.this.getBookmarkedText(bookmark);\n+        }\n+\n+        @Override\n+        public void bookmark(String name) {\n+            StyledText.this.bookmark(name, start, end);\n+        }\n+\n+        @Override\n+        public StyledText subText(int start, int end) {\n+            return StyledText.this.subText(this.start + start, this.start + end);\n+        }\n+\n+        @Override\n+        public CharSequence asCharSequence() {\n+            return StyledText.this.asCharSequence().subSequence(start, end);\n+        }\n+\n+        @Override\n+        public void consumeBy(StyledText.Consumer consumer) {\n+            StyledText.this.consumeBy(consumer, start, end);\n+        }\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/StyledText.java","additions":343,"deletions":0,"binary":false,"changes":343,"status":"added"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet.action;\n-\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.text.AnnotatedText;\n-\n-\/**\n- * An action described by markup. Such an action is typically a compound built\n- * from primitive operations of {@link AnnotatedText}.\n- *\n- * <p><b>This is NOT part of any supported API.\n- * If you write code that depends on this, you do so at your own risk.\n- * This code and its internal interfaces are subject to change or\n- * deletion without notice.<\/b>\n- *\/\n-\/\/ FIXME: uncomment \/* sealed *\/ when minimum boot version >= 17\n-public \/* sealed *\/ interface Action \/* permits Annotate, Bookmark, Replace *\/ {\n-\n-    \/**\n-     * Performs this action.\n-     *\/\n-    void perform();\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/action\/Action.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,81 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet.action;\n-\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.text.AnnotatedText;\n-\n-import java.util.Set;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-\/**\n- * An action that annotates text.\n- *\n- * <p><b>This is NOT part of any supported API.\n- * If you write code that depends on this, you do so at your own risk.\n- * This code and its internal interfaces are subject to change or\n- * deletion without notice.<\/b>\n- *\/\n-public final class Annotate implements Action {\n-\n-    private final Runnable action;\n-\n-    \/**\n-     * Constructs an action that annotates regex finds in text.\n-     *\n-     * @param obj the object to annotate regex finds with\n-     * @param pattern the regex used to search the text\n-     * @param text the text\n-     * @param <S> the type of text metadata\n-     *\/\n-    public <S> Annotate(S obj, Pattern pattern, AnnotatedText<S> text) {\n-        \/\/ This *constructor* is generified and the generic parameter is\n-        \/\/ captured by the Runnable to type-safely call text.annotate(obj)\n-        \/\/ later. An alternative would be to generify this *class* so as to\n-        \/\/ capture the generic parameter in this class' instance fields.\n-        \/\/ However, generifying the class would unduly force its clients to deal\n-        \/\/ with the generic parameter, whose *sole* purpose is to ensure that\n-        \/\/ the passed obj is of the type of objects that the passed text can be\n-        \/\/ annotated with.\n-        action = new Runnable() {\n-            @Override\n-            public void run() {\n-                Set<S> s = Set.of(obj);\n-                Matcher matcher = pattern.matcher(text.asCharSequence());\n-                while (matcher.find()) {\n-                    int start = matcher.start();\n-                    int end = matcher.end();\n-                    text.subText(start, end).annotate(s);\n-                }\n-            }\n-        };\n-    }\n-\n-    @Override\n-    public void perform() {\n-        action.run();\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/action\/Annotate.java","additions":0,"deletions":81,"binary":false,"changes":81,"status":"deleted"},{"patch":"@@ -1,58 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet.action;\n-\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.text.AnnotatedText;\n-\n-\/**\n- * An action that associates text with a name.\n- *\n- * <p><b>This is NOT part of any supported API.\n- * If you write code that depends on this, you do so at your own risk.\n- * This code and its internal interfaces are subject to change or\n- * deletion without notice.<\/b>\n- *\/\n-public final class Bookmark implements Action {\n-\n-    private final String name;\n-    private final AnnotatedText<?> text;\n-\n-    \/**\n-     * Constructs an action that associates text with a name.\n-     *\n-     * @param name the string (key) to associate text with\n-     * @param text the text\n-     *\/\n-    public Bookmark(String name, AnnotatedText<?> text) {\n-        this.name = name;\n-        this.text = text;\n-    }\n-\n-    @Override\n-    public void perform() {\n-        text.subText(0, text.length()).bookmark(name);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/action\/Bookmark.java","additions":0,"deletions":58,"binary":false,"changes":58,"status":"deleted"},{"patch":"@@ -1,345 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet.text;\n-\n-import java.lang.ref.WeakReference;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n-\n-import static java.lang.Math.max;\n-import static java.lang.Math.min;\n-\n-\/**\n- * A mutable sequence of characters, each of which can be associated with a set\n- * of objects. These objects can be used by clients as character metadata, such\n- * as rich text style.\n- *\n- * <p><b>This is NOT part of any supported API.\n- * If you write code that depends on this, you do so at your own risk.\n- * This code and its internal interfaces are subject to change or\n- * deletion without notice.<\/b>\n- *\/\n-public class AnnotatedText<S> {\n-\n-    private Map<String, AnnotatedText<S>> bookmarks;\n-    private StringBuilder chars;\n-    private Metadata<S> metadata;\n-    private List<WeakReference<SubText>> subtexts;\n-\n-    public AnnotatedText() {\n-        init();\n-    }\n-\n-    \/*\n-     * This method should be overridden to be no-op by a subclass that wants to\n-     * inherit the interface but not the implementation, which includes\n-     * unnecessary internal objects. If this is done, then all public methods\n-     * should be overridden too, otherwise they will not work.\n-     *\n-     * An alternative design would be to provide an interface for annotated text;\n-     * but I ruled that out as unnecessarily heavyweight.\n-     *\/\n-    protected void init() {\n-        this.bookmarks = new HashMap<>();\n-        this.chars = new StringBuilder();\n-        this.metadata = new Metadata<>();\n-        this.subtexts = new ArrayList<>();\n-    }\n-\n-    \/*\n-     * For each character of this text adds the provided objects to a set of\n-     * objects associated with that character.\n-     *\/\n-    public void annotate(Set<S> additional) {\n-        metadata.add(0, length(), additional);\n-    }\n-\n-    public int length() {\n-        return chars.length();\n-    }\n-\n-    \/*\n-     * Replaces all characters of this text with the provided sequence of\n-     * characters, each of which is associated with all the provided objects.\n-     *\/\n-    public void replace(Set<? extends S> s, CharSequence plaintext) {\n-        replace(0, length(), s, plaintext);\n-    }\n-\n-    \/*\n-     * A multi-purpose operation that can be used to replace, insert or delete\n-     * text. The effect on a text is as if [start, end) were deleted and\n-     * then plaintext inserted at start.\n-     *\/\n-    private void replace(int start, int end, Set<? extends S> s, CharSequence plaintext) {\n-        chars.replace(start, end, plaintext.toString());\n-        metadata.delete(start, end);\n-        metadata.insert(start, plaintext.length(), s);\n-        \/\/ The number of subtexts is not expected to be big; hence no\n-        \/\/ optimizations are applied\n-        var iterator = subtexts.iterator();\n-        while (iterator.hasNext()) {\n-            WeakReference<SubText> ref = iterator.next();\n-            SubText txt = ref.get();\n-            if (txt == null) {\n-                iterator.remove(); \/\/ a stale ref\n-            } else {\n-                update(start, end, plaintext.length(), txt);\n-            }\n-        }\n-    }\n-\n-    \/*\n-     * Updates the text given the scope of the change to reflect text continuity.\n-     *\/\n-    private void update(int start, int end, int newLength, SubText text) {\n-        assert start <= end;\n-        assert text.start <= text.end;\n-        assert newLength >= 0;\n-        if (text.start == text.end && start == text.start) {\n-            \/\/ insertion into empty text; special-cased for simplicity\n-            text.end += newLength;\n-            return;\n-        }\n-        if (end <= text.start) { \/\/ the change is on the left-hand side of the text\n-            int diff = newLength - (end - start);\n-            text.start += diff;\n-            text.end += diff;\n-        } else if (text.end <= start) { \/\/ the change is on the right-hand side of the text\n-            \/\/ no-op; explicit \"if\" for clarity\n-        } else { \/\/ the change intersects with the text\n-            if (text.start <= start && end <= text.end) { \/\/ the change is within the text\n-                text.end += newLength - (end - start);\n-            } else {\n-                int intersectionLen = min(end, text.end) - max(start, text.start);\n-                int oldLen = text.end - text.start;\n-                if (start <= text.start) {\n-                    text.start = start + newLength;\n-                }\n-                text.end = text.start + oldLen - intersectionLen;\n-            }\n-        }\n-    }\n-\n-    private void annotate(int start, int end, Set<S> additional) {\n-        metadata.add(start, end, additional);\n-    }\n-\n-    public AnnotatedText<S> getBookmarkedText(String bookmark) {\n-        return bookmarks.get(Objects.requireNonNull(bookmark));\n-    }\n-\n-    \/*\n-     * Maps the provided name to this text, using a flat namespace. A flat\n-     * namespace means that this text (t), as well as any subtext derived from\n-     * either t or t's subtext, share the naming map.\n-     *\/\n-    public void bookmark(String name) {\n-        bookmark(name, 0, length());\n-    }\n-\n-    private void bookmark(String name, int start, int end) {\n-        bookmarks.put(Objects.requireNonNull(name), subText(start, end));\n-    }\n-\n-    \/*\n-     * Selects a view of the portion of this text starting from start\n-     * (inclusive) to end (exclusive).\n-     *\n-     * In contrast with java.util.List.subList, returned views provide extra\n-     * consistency: they reflect structural changes happening to the underlying\n-     * text and other views thereof.\n-     *\/\n-    public AnnotatedText<S> subText(int start, int end) {\n-        Objects.checkFromToIndex(start, end, length());\n-        var s = new SubText(start, end);\n-        subtexts.add(new WeakReference<>(s));\n-        return s;\n-    }\n-\n-    \/*\n-     * Returns plaintext version of this text. This method is to be used for\n-     * algorithms that accept String or CharSequence to map the result back to\n-     * this text.\n-     *\n-     * There are no extensible \"mutable string\" interface. java.lang.Appendable\n-     * does not support replacements and insertions. StringBuilder\/StringBuffer\n-     * is not extensible. Even if it were extensible, not many general-purpose\n-     * string algorithms accept it.\n-     *\/\n-    public CharSequence asCharSequence() {\n-        return chars;\n-    }\n-\n-    \/*\n-     * Provides text to the consumer efficiently. The text always calls the\n-     * consumer at least once; even if the text is empty.\n-     *\/\n-    public void consumeBy(AnnotatedText.Consumer<? super S> consumer) {\n-        consumeBy(consumer, 0, length());\n-    }\n-\n-    private void consumeBy(AnnotatedText.Consumer<? super S> consumer, int start, int end) {\n-        Objects.checkFromToIndex(start, end, length());\n-        metadata.consumeBy(consumer, chars, start, end);\n-    }\n-\n-    public AnnotatedText<S> append(Set<? extends S> style, CharSequence sequence) {\n-        subText(length(), length()).replace(style, sequence);\n-        return this;\n-    }\n-\n-    public AnnotatedText<S> append(AnnotatedText<? extends S> fragment) {\n-        fragment.consumeBy((style, sequence) -> subText(length(), length()).replace(style, sequence));\n-        return this;\n-    }\n-\n-    @FunctionalInterface\n-    public interface Consumer<S> {\n-\n-        void consume(Set<? extends S> style, CharSequence sequence);\n-    }\n-\n-    \/*\n-     * A structure that stores character metadata.\n-     *\/\n-    private static final class Metadata<S> {\n-\n-        \/\/ Although this structure optimizes neither memory use nor object\n-        \/\/ allocation, it is simple both to implement and reason about.\n-\n-        \/\/ list is a reference to ArrayList because this class accesses list by\n-        \/\/ index, so this is important that the list is RandomAccess, which\n-        \/\/ ArrayList is\n-        private final ArrayList<Set<S>> list = new ArrayList<>();\n-\n-        private void delete(int fromIndex, int toIndex) {\n-            list.subList(fromIndex, toIndex).clear();\n-        }\n-\n-        private void insert(int fromIndex, int length, Set<? extends S> s) {\n-            list.addAll(fromIndex, Collections.nCopies(length, Set.copyOf(s)));\n-        }\n-\n-        private void add(int fromIndex, int toIndex, Set<S> additional) {\n-            var copyOfAdditional = Set.copyOf(additional);\n-            list.subList(fromIndex, toIndex).replaceAll(current -> sum(current, copyOfAdditional));\n-        }\n-\n-        private Set<S> sum(Set<S> a, Set<S> b) {\n-            \/\/ assumption: until there are complex texts, the most common\n-            \/\/ scenario is the one where `a` is empty while `b` is not\n-            if (a.isEmpty()) {\n-                return b;\n-            } else {\n-                var c = new HashSet<>(a);\n-                c.addAll(b);\n-                return Set.copyOf(c);\n-            }\n-        }\n-\n-        private void consumeBy(Consumer<? super S> consumer, CharSequence seq, int start, int end) {\n-            if (start == end) {\n-                \/\/ an empty region doesn't have an associated set; special-cased\n-                \/\/ for simplicity to avoid more complicated implementation of\n-                \/\/ this method using a do-while loop\n-                consumer.consume(Set.of(), \"\");\n-            } else {\n-                for (int i = start, j = i + 1; i < end; i = j) {\n-                    var ith = list.get(i);\n-                    while (j < end && ith.equals(list.get(j))) {\n-                        j++;\n-                    }\n-                    consumer.consume(ith, seq.subSequence(i, j));\n-                }\n-            }\n-        }\n-    }\n-\n-    final class SubText extends AnnotatedText<S> {\n-\n-        int start, end;\n-\n-        private SubText(int start, int end) {\n-            this.start = start;\n-            this.end = end;\n-        }\n-\n-        @Override\n-        protected void init() {\n-            \/\/ no-op\n-        }\n-\n-        @Override\n-        public void annotate(Set<S> style) {\n-            AnnotatedText.this.annotate(start, end, style);\n-        }\n-\n-        @Override\n-        public int length() {\n-            return end - start;\n-        }\n-\n-        @Override\n-        public void replace(Set<? extends S> s, CharSequence plaintext) {\n-            \/\/ If the \"replace\" operation affects this text's size, which it\n-            \/\/ can, then that size will be updated along with all other sizes\n-            \/\/ during the bulk \"update\" operation in tracking text instance.\n-            AnnotatedText.this.replace(start, end, s, plaintext);\n-        }\n-\n-        @Override\n-        public AnnotatedText<S> getBookmarkedText(String bookmark) {\n-            return AnnotatedText.this.getBookmarkedText(bookmark);\n-        }\n-\n-        @Override\n-        public void bookmark(String name) {\n-            AnnotatedText.this.bookmark(name, start, end);\n-        }\n-\n-        @Override\n-        public AnnotatedText<S> subText(int start, int end) {\n-            return AnnotatedText.this.subText(this.start + start, this.start + end);\n-        }\n-\n-        @Override\n-        public CharSequence asCharSequence() {\n-            return AnnotatedText.this.asCharSequence().subSequence(start, end);\n-        }\n-\n-        @Override\n-        public void consumeBy(AnnotatedText.Consumer<? super S> consumer) {\n-            AnnotatedText.this.consumeBy(consumer, start, end);\n-        }\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/text\/AnnotatedText.java","additions":0,"deletions":345,"binary":false,"changes":345,"status":"deleted"}]}