{"files":[{"patch":"@@ -52,1 +52,0 @@\n-import com.sun.source.doctree.LinkTree;\n@@ -129,10 +128,0 @@\n-    public LinkTree makeLinkTree(String sig, String label) {\n-        ReferenceTree ref = treeFactory.newReferenceTree(sig);\n-        return treeFactory.newLinkTree(ref, List.of(makeTextTree(label)));\n-    }\n-\n-    public LinkTree makeLinkPlainTree(String sig, String label) {\n-        ReferenceTree ref = treeFactory.newReferenceTree(sig);\n-        return treeFactory.newLinkPlainTree(ref, List.of(makeTextTree(label)));\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/CommentUtils.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -292,4 +292,0 @@\n-            \/\/ Unlike string literals in Java source, attribute values in\n-            \/\/ snippet markup do not use escapes. This is why indices of\n-            \/\/ characters in the regex pattern directly map to their\n-            \/\/ corresponding positions in snippet source.\n@@ -297,1 +293,0 @@\n-            assert value.equals(Pattern.compile(value).pattern()) : value;\n@@ -301,0 +296,9 @@\n+                \/\/ Unlike string literals in Java source, attribute values in\n+                \/\/ snippet markup do not use escape sequences. This is why\n+                \/\/ indices of characters in the regex pattern directly map to\n+                \/\/ their corresponding positions in snippet source. Refine\n+                \/\/ position using e.getIndex() only if that index is relevant to\n+                \/\/ the regex in the attribute value. Index might be irrelevant\n+                \/\/ because it refers to an internal representation of regex,\n+                \/\/ e.getPattern(), which might be a normalized or partial view\n+                \/\/ of the original pattern.\n@@ -302,5 +306,0 @@\n-                \/\/ Refine position using e.getIndex() only if that index is\n-                \/\/ relevant to the regex in the attribute value. Index might be\n-                \/\/ irrelevant because it refers to an internal representation of\n-                \/\/ regex, e.getPattern(), which might be a normalized or partial\n-                \/\/ view of the original pattern.\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Parser.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -246,2 +246,1 @@\n-            record TestCase(String input, String expectedError) {\n-            }\n+            record TestCase(String input, String expectedError) { }\n@@ -2147,0 +2146,84 @@\n+\n+    @Test\n+    public void testInvalidRegexDiagnostics(Path base) throws Exception {\n+\n+        record TestCase(String input, String expectedError) { }\n+\n+        \/\/ WARNING: debugging these test cases by reading .jtr files might prove\n+        \/\/ confusing. This is because of how jtharness, which is used by jtreg,\n+        \/\/ represents special symbols it encounters in standard streams. While\n+        \/\/ CR, LR and TAB are output as they are, \\ is output as \\\\ and the rest\n+        \/\/ of the escape sequences are output using the \\\\uxxxx notation. This\n+        \/\/ might affect relative symbol positioning on adjacent lines. For\n+        \/\/ example, it might be hard to judge the true (i.e. console) position\n+        \/\/ of the caret. Try using -show:System.out jtreg option to remediate\n+        \/\/ that.\n+\n+        final var testCases = List.of(\n+                new TestCase(\"\"\"\n+{@snippet :\n+hello there \/\/   @highlight   regex =\"\\t**\"\n+}\"\"\",\n+                             \"\"\"\n+error: snippet markup error: \"Dangling meta character '*'\"\n+hello there \/\/   @highlight   regex =\"\\t**\"\n+                                      \\t ^\n+\"\"\"),\n+                new TestCase(\"\"\"\n+{@snippet :\n+hello there \/\/   @highlight   regex =\"\\\\t**\"\n+}\"\"\",\n+                        \"\"\"\n+error: snippet markup error: \"Dangling meta character '*'\"\n+hello there \/\/   @highlight   regex =\"\\\\t**\"\n+                                         ^\n+\"\"\"),\n+                new TestCase(\"\"\"\n+{@snippet :\n+hello there \/\/ @highlight regex=\"\\\\.\\\\*\\\\+\\\\E\"\n+}\"\"\",\n+                             \"\"\"\n+error: snippet markup error: \"Illegal\/unsupported escape sequence\"\n+hello there \/\/ @highlight regex=\"\\\\.\\\\*\\\\+\\\\E\"\n+                                 \\s\\s\\s\\s   ^\n+\"\"\"), \/\/ use \\s to counteract shift introduced by \\\\ so as to visually align ^ right below E\n+                new TestCase(\"\"\"\n+{@snippet :\n+hello there \/\/   @highlight  type=\"italics\" regex =\"  [\"\n+}\"\"\",\n+                        \"\"\"\n+error: snippet markup error: \"Unclosed character class\"\n+hello there \/\/   @highlight  type=\"italics\" regex =\"  [\"\n+                                                      ^\n+\"\"\")\n+                );\n+\n+        List<String> inputs = testCases.stream().map(s -> s.input).toList();\n+        StringBuilder methods = new StringBuilder();\n+        forEachNumbered(inputs, (i, n) -> {\n+            methods.append(\n+                    \"\"\"\n+\n+                    \/**\n+                    %s*\/\n+                    public void case%s() {}\n+                    \"\"\".formatted(i, n));\n+        });\n+\n+        String classString =\n+                \"\"\"\n+                public class A {\n+                %s\n+                }\n+                \"\"\".formatted(methods.toString());\n+\n+        Path src = Files.createDirectories(base.resolve(\"src\"));\n+        tb.writeJavaFiles(src, classString);\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                src.resolve(\"A.java\").toString());\n+        checkExit(Exit.ERROR);\n+        checkOrder(Output.OUT, testCases.stream().map(TestCase::expectedError).toArray(String[]::new));\n+        checkNoCrashes();\n+    }\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSnippetTag\/TestSnippetTag.java","additions":85,"deletions":2,"binary":false,"changes":87,"status":"modified"}]}