{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import java.util.HexFormat;\n@@ -135,2 +136,5 @@\n-        if (iv != null && iv.length != ICV2.length) {\n-            throw new InvalidAlgorithmParameterException(\"Invalid IV length\");\n+        \/\/ allow setting an iv but if non-null, must equal to ICV2\n+        if (iv != null && !Arrays.equals(iv, ICV2)) {\n+            HexFormat hf = HexFormat.of().withUpperCase();\n+            throw new InvalidAlgorithmParameterException(\"Invalid IV, got 0x\" +\n+                    hf.formatHex(iv) + \" instead of 0x\" + hf.formatHex(ICV2));\n@@ -139,2 +143,1 @@\n-        \/\/ iv is retrieved from IvParameterSpec.getIV() which is already cloned\n-        this.iv = (iv == null? ICV2 : iv);\n+        this.iv = ICV2;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESKeyWrapPadded.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-            super(new AESKeyWrap(), new PKCS5Padding(16), -1);\n+            super(new AESKeyWrap(), new PKCS5Padding(8), -1);\n@@ -80,1 +80,1 @@\n-            super(new AESKeyWrap(), new PKCS5Padding(16), 16);\n+            super(new AESKeyWrap(), new PKCS5Padding(8), 16);\n@@ -87,1 +87,1 @@\n-            super(new AESKeyWrap(), new PKCS5Padding(16), 24);\n+            super(new AESKeyWrap(), new PKCS5Padding(8), 24);\n@@ -94,1 +94,1 @@\n-            super(new AESKeyWrap(), new PKCS5Padding(16), 32);\n+            super(new AESKeyWrap(), new PKCS5Padding(8), 32);\n@@ -233,3 +233,1 @@\n-     * Returns the block size (in bytes). i.e. 16 bytes.\n-     *\n-     * @return the block size (in bytes), i.e. 16 bytes.\n+     * @return the block size (in bytes)\n@@ -239,1 +237,1 @@\n-        return cipher.getBlockSize();\n+        return 8;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/KeyWrapCipher.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8248268 8268621\n+ * @bug 8248268 8268621 8271745\n@@ -28,1 +28,1 @@\n- *     AES\/KW\/PKCS5Padding, and AES\/KWP\/NoPadding.\n+ *     AES\/KW\/PKCS5Padding, and AES\/KWP\/NoPadding impls of SunJCE provider.\n@@ -31,0 +31,1 @@\n+import java.nio.ByteBuffer;\n@@ -33,0 +34,2 @@\n+import java.security.KeyPairGenerator;\n+import java.security.PrivateKey;\n@@ -34,0 +37,1 @@\n+import java.security.AlgorithmParameters;\n@@ -39,2 +43,2 @@\n-    private static final byte[] DATA_128 =\n-            Arrays.copyOf(\"1234567890123456789012345678901234\".getBytes(), 128);\n+    private static final byte[] DATA_32 =\n+            Arrays.copyOf(\"1234567890123456789012345678901234\".getBytes(), 32);\n@@ -42,1 +46,1 @@\n-            new SecretKeySpec(DATA_128, 0, 16, \"AES\");\n+            new SecretKeySpec(DATA_32, 0, 16, \"AES\");\n@@ -45,42 +49,48 @@\n-    private static final int MAX_KW_PKCS5PAD_LEN = 16; \/\/ 1-16\n-    private static final int MAX_KWP_PAD_LEN = 7; \/\/ 0...7\n-\n-    public static void testEnc(Cipher c, byte[] in, int inLen, int ivLen,\n-            int maxPadLen) throws Exception {\n-\n-        System.out.println(\"input len: \" + inLen);\n-        c.init(Cipher.ENCRYPT_MODE, KEY, new IvParameterSpec(in, 0, ivLen));\n-\n-        int estOutLen = c.getOutputSize(inLen);\n-\n-        byte[] out = c.doFinal(in, 0, inLen);\n-\n-        \/\/ for encryption output, the estimate should match the actual\n-        if (estOutLen != out.length) {\n-            System.out.println(\"=> estimated: \" + estOutLen);\n-            System.out.println(\"=> actual enc out length: \" + out.length);\n-            throw new RuntimeException(\"Failed enc output len check\");\n-        }\n-\n-        \/\/ encryption outout should always be multiple of 8 and at least 8-byte\n-        \/\/ longer than input\n-        if ((out.length % 8 != 0) || (out.length - inLen < 8)) {\n-            throw new RuntimeException(\"Invalid length of encrypted data: \" +\n-                out.length);\n-        }\n-\n-        c.init(Cipher.DECRYPT_MODE, KEY, new IvParameterSpec(in, 0, ivLen));\n-        estOutLen = c.getOutputSize(out.length);\n-\n-        byte[] in2 = c.doFinal(out);\n-\n-        \/\/ for decryption output, the estimate should match the actual for\n-        \/\/ AES\/KW\/NoPadding and slightly larger than the actual for the rest\n-        if (estOutLen < in2.length || (estOutLen - in2.length) > maxPadLen) {\n-            System.out.println(\"=> estimated: \" + estOutLen);\n-            System.out.println(\"=> actual dec out length: \" + in2.length);\n-            throw new RuntimeException(\"Failed dec output len check\");\n-        }\n-\n-        if (!Arrays.equals(in, 0, inLen, in2, 0, inLen)) {\n-            throw new RuntimeException(\"Failed decrypted data check\");\n+    private static final int MAX_KW_PKCS5PAD_LEN = 8; \/\/ 1-8\n+    private static final int MAX_KWP_PAD_LEN = 7; \/\/ 0-7\n+\n+    public static void testEnc(Cipher c, byte[] in, int startLen, int inc,\n+            IvParameterSpec[] ivs, int maxPadLen) throws Exception {\n+\n+        System.out.println(\"testEnc, input len=\" + startLen + \" w\/ inc=\" +\n+                inc);\n+\n+        for (IvParameterSpec iv : ivs) {\n+            System.out.print(\"\\t=> w\/ iv=\" + iv);\n+\n+            for (int inLen = startLen; inLen < in.length; inLen+=inc) {\n+                c.init(Cipher.ENCRYPT_MODE, KEY, iv);\n+\n+                int estOutLen = c.getOutputSize(inLen);\n+                System.out.println(\", inLen=\" + inLen);\n+                byte[] out = c.doFinal(in, 0, inLen);\n+\n+                \/\/ check the length of encryption output\n+                if (estOutLen != out.length || (out.length % 8 != 0) ||\n+                        (out.length - inLen < 8)) {\n+                    System.out.println(\"=> estimated: \" + estOutLen);\n+                    System.out.println(\"=> actual: \" + out.length);\n+                    throw new RuntimeException(\"Failed enc output len check\");\n+                }\n+\n+                c.init(Cipher.DECRYPT_MODE, KEY, iv);\n+                estOutLen = c.getOutputSize(out.length);\n+                byte[] recovered = new byte[estOutLen];\n+\n+                \/\/ do decryption using ByteBuffer and multi-part\n+                ByteBuffer outBB = ByteBuffer.wrap(out);\n+                ByteBuffer recoveredBB = ByteBuffer.wrap(recovered);\n+                int len = c.update(outBB, recoveredBB);\n+                len += c.doFinal(outBB, recoveredBB);\n+\n+                \/\/ check the length of decryption output\n+                if (estOutLen < len || (estOutLen - len) > maxPadLen) {\n+                    System.out.println(\"=> estimated: \" + estOutLen);\n+                    System.out.println(\"=> actual: \" + len);\n+                    throw new RuntimeException(\"Failed dec output len check\");\n+                }\n+\n+                if (!Arrays.equals(in, 0, inLen, recovered, 0, len)) {\n+                    throw new RuntimeException(\"Failed decrypted data check\");\n+                }\n+            }\n@@ -90,1 +100,1 @@\n-    public static void testWrap(Cipher c, byte[] in, int inLen, int ivLen,\n+    public static void testWrap(Cipher c, Key[] inKeys, IvParameterSpec[] ivs,\n@@ -93,27 +103,46 @@\n-        System.out.println(\"key len: \" + inLen);\n-        c.init(Cipher.WRAP_MODE, KEY, new IvParameterSpec(in, 0, ivLen));\n-\n-        int estOutLen = c.getOutputSize(inLen);\n-\n-        byte[] out = c.wrap(new SecretKeySpec(in, 0, inLen, \"Any\"));\n-\n-        \/\/ for encryption output, the estimate should match the actual\n-        if (estOutLen != out.length) {\n-            System.out.println(\"=> estimated: \" + estOutLen);\n-            System.out.println(\"=> actual wrap out length: \" + out.length);\n-            throw new RuntimeException(\"Failed wrap output len check\");\n-        }\n-\n-        \/\/ encryption outout should always be multiple of 8 and at least 8-byte\n-        \/\/ longer than input\n-        if ((out.length % 8 != 0) || (out.length - inLen < 8)) {\n-            throw new RuntimeException(\"Invalid length of encrypted data: \" +\n-                out.length);\n-        }\n-        c.init(Cipher.UNWRAP_MODE, KEY, new IvParameterSpec(in, 0, ivLen));\n-        estOutLen = c.getOutputSize(out.length);\n-\n-        Key key2 = c.unwrap(out, \"Any\", Cipher.SECRET_KEY);\n-\n-        if (!(key2 instanceof SecretKey)) {\n-            throw new RuntimeException(\"Failed unwrap output type check\");\n+        for (Key inKey : inKeys) {\n+            System.out.println(\"testWrap, key: \" + inKey);\n+            for (IvParameterSpec iv : ivs) {\n+                System.out.println(\"\\t=> w\/ iv \" + iv);\n+\n+                c.init(Cipher.WRAP_MODE, KEY, iv);\n+\n+                byte[] out = c.wrap(inKey);\n+\n+                \/\/ output should always be multiple of cipher block size\n+                if (out.length % c.getBlockSize() != 0) {\n+                    throw new RuntimeException(\"Invalid wrap len: \" +\n+                            out.length);\n+                }\n+\n+                c.init(Cipher.UNWRAP_MODE, KEY, iv);\n+\n+                \/\/ SecretKey or PrivateKey\n+                int keyType = (inKey instanceof SecretKey? Cipher.SECRET_KEY :\n+                        Cipher.PRIVATE_KEY);\n+\n+                int estOutLen = c.getOutputSize(out.length);\n+                Key key2 = c.unwrap(out, inKey.getAlgorithm(), keyType);\n+\n+                if ((keyType == Cipher.SECRET_KEY &&\n+                        !(key2 instanceof SecretKey)) ||\n+                        (keyType == Cipher.PRIVATE_KEY &&\n+                        !(key2 instanceof PrivateKey))) {\n+                    throw new RuntimeException(\"Failed unwrap type check\");\n+                }\n+\n+                byte[] in2 = key2.getEncoded();\n+                \/\/ check decryption output length\n+                if (estOutLen < in2.length ||\n+                        (estOutLen - in2.length) > maxPadLen) {\n+                    System.out.println(\"=> estimated: \" + estOutLen);\n+                    System.out.println(\"=> actual: \" + in2.length);\n+                    throw new RuntimeException(\"Failed unwrap len check\");\n+                }\n+\n+                if (!Arrays.equals(inKey.getEncoded(), in2) ||\n+                        !(inKey.getAlgorithm().equalsIgnoreCase\n+                        (key2.getAlgorithm()))) {\n+                    throw new RuntimeException(\"Failed unwrap key check\");\n+                }\n+            }\n@@ -121,0 +150,1 @@\n+    }\n@@ -122,8 +152,2 @@\n-        byte[] in2 = key2.getEncoded();\n-        \/\/ for decryption output, the estimate should match the actual for\n-        \/\/ AES\/KW\/NoPadding and slightly larger than the actual for the rest\n-        if (estOutLen < in2.length || (estOutLen - in2.length) > maxPadLen) {\n-            System.out.println(\"=> estimated: \" + estOutLen);\n-            System.out.println(\"=> actual unwrap out length: \" + in2.length);\n-            throw new RuntimeException(\"Failed unwrap output len check\");\n-        }\n+    public static void testIv(Cipher c, int defIvLen, boolean allowCustomIv)\n+            throws Exception {\n@@ -131,5 +155,2 @@\n-        if (inLen != in2.length ||\n-                !Arrays.equals(in, 0, inLen, in2, 0, inLen)) {\n-            throw new RuntimeException(\"Failed unwrap data check\");\n-        }\n-    }\n+        System.out.println(\"testIv: defIvLen = \" + defIvLen +\n+                \" allowCustomIv = \" + allowCustomIv);\n@@ -137,1 +158,0 @@\n-    public static void testIv(Cipher c) throws Exception {\n@@ -139,2 +159,2 @@\n-        Cipher c2 = Cipher.getInstance(c.getAlgorithm(), c.getProvider());\n-        if (c2.getIV() != null) {\n+        c = Cipher.getInstance(c.getAlgorithm(), c.getProvider());\n+        if (c.getIV() != null) {\n@@ -143,1 +163,3 @@\n-        if (c2.getParameters() == null) {\n+\n+        AlgorithmParameters ivParams = c.getParameters();\n+        if (ivParams == null) {\n@@ -146,3 +168,4 @@\n-\n-        c2.init(Cipher.ENCRYPT_MODE, KEY);\n-        byte[] defIv2 = c2.getIV();\n+        IvParameterSpec ivSpec =\n+                ivParams.getParameterSpec(IvParameterSpec.class);\n+        byte[] iv = ivSpec.getIV();\n+        \/\/ try through all opmodes\n@@ -150,0 +173,4 @@\n+        c.init(Cipher.DECRYPT_MODE, KEY);\n+        c.init(Cipher.WRAP_MODE, KEY);\n+        c.init(Cipher.UNWRAP_MODE, KEY);\n+\n@@ -151,1 +178,10 @@\n-        if (!Arrays.equals(defIv, defIv2)) {\n+\n+        \/\/ try again through all opmodes\n+        c.init(Cipher.ENCRYPT_MODE, KEY);\n+        c.init(Cipher.DECRYPT_MODE, KEY);\n+        c.init(Cipher.WRAP_MODE, KEY);\n+        c.init(Cipher.UNWRAP_MODE, KEY);\n+\n+        byte[] defIv2 = c.getIV();\n+        if (iv.length != defIvLen || !Arrays.equals(iv, defIv) ||\n+                !Arrays.equals(defIv, defIv2)) {\n@@ -154,0 +190,4 @@\n+        if (defIv == defIv2) {\n+            throw new RuntimeException(\"Failed getIV copy check\");\n+        }\n+\n@@ -157,1 +197,1 @@\n-                defIv.length\/2));\n+                    defIv.length\/2));\n@@ -162,9 +202,12 @@\n-        Arrays.fill(defIv, (byte) 0xFF);\n-        c.init(Cipher.ENCRYPT_MODE, KEY, new IvParameterSpec(defIv));\n-        byte[] newIv = c.getIV();\n-        if (!Arrays.equals(newIv, defIv)) {\n-            throw new RuntimeException(\"Failed set iv check\");\n-        }\n-        byte[] newIv2 = c.getIV();\n-        if (newIv == newIv2) {\n-            throw new RuntimeException(\"Failed getIV copy check\");\n+\n+        if (allowCustomIv) {\n+            Arrays.fill(defIv, (byte) 0xFF);\n+            \/\/ try through all opmodes\n+            c.init(Cipher.ENCRYPT_MODE, KEY, new IvParameterSpec(defIv));\n+            c.init(Cipher.DECRYPT_MODE, KEY, new IvParameterSpec(defIv));\n+            c.init(Cipher.WRAP_MODE, KEY, new IvParameterSpec(defIv));\n+            c.init(Cipher.UNWRAP_MODE, KEY, new IvParameterSpec(defIv));\n+\n+            if (!Arrays.equals(defIv, c.getIV())) {\n+                throw new RuntimeException(\"Failed set iv check\");\n+            }\n@@ -175,10 +218,51 @@\n-        byte[] data = DATA_128;\n-\n-        String ALGO = \"AES\/KW\/PKCS5Padding\";\n-        System.out.println(\"Testing \" + ALGO);\n-        Cipher c = Cipher.getInstance(ALGO, \"SunJCE\");\n-\n-        \/\/ test all possible pad lengths, i.e. 1 - 16\n-        for (int i = 1; i <= MAX_KW_PKCS5PAD_LEN; i++) {\n-            testEnc(c, data, data.length - i, KW_IV_LEN, MAX_KW_PKCS5PAD_LEN);\n-            testWrap(c, data, data.length - i, KW_IV_LEN, MAX_KW_PKCS5PAD_LEN);\n+        byte[] data = DATA_32;\n+\n+        SecretKey aes256 = new SecretKeySpec(DATA_32, \"AES\");\n+        SecretKey any256 = new SecretKeySpec(DATA_32, \"ANY\");\n+        PrivateKey priv = KeyPairGenerator.getInstance\n+                (\"RSA\", \"SunRsaSign\").generateKeyPair().getPrivate();\n+\n+        String[] algos = {\n+            \"AES\/KW\/PKCS5Padding\", \"AES\/KW\/NoPadding\", \"AES\/KWP\/NoPadding\"\n+        };\n+\n+        for (String a : algos) {\n+            System.out.println(\"Testing \" + a);\n+            Cipher c = Cipher.getInstance(a, \"SunJCE\");\n+\n+            int blkSize = c.getBlockSize();\n+\n+            \/\/ set the default based on AES\/KWP\/NoPadding, the other two\n+            \/\/ override as needed\n+            int startLen = data.length - blkSize;\n+            int inc = 1;\n+            IvParameterSpec[] ivs = new IvParameterSpec[] { null };\n+            int padLen = MAX_KWP_PAD_LEN;\n+            Key[] keys = new Key[] { aes256, any256, priv };\n+            int ivLen = KWP_IV_LEN;\n+            boolean allowCustomIv = false;\n+\n+            switch (a) {\n+            case \"AES\/KW\/PKCS5Padding\":\n+                ivs = new IvParameterSpec[] {\n+                        null, new IvParameterSpec(DATA_32, 0, KW_IV_LEN) };\n+                padLen = MAX_KW_PKCS5PAD_LEN;\n+                ivLen = KW_IV_LEN;\n+                allowCustomIv = true;\n+                break;\n+            case \"AES\/KW\/NoPadding\":\n+                startLen = data.length >> 1;\n+                inc = blkSize;\n+                ivs = new IvParameterSpec[] {\n+                        null, new IvParameterSpec(DATA_32, 0, KW_IV_LEN) };\n+                padLen = 0;\n+                keys = new Key[] { aes256, any256 };\n+                ivLen = KW_IV_LEN;\n+                allowCustomIv = true;\n+                break;\n+            }\n+\n+            \/\/ now test based on the configured arguments\n+            testEnc(c, data, startLen, inc, ivs, padLen);\n+            testWrap(c, keys, ivs, padLen);\n+            testIv(c, ivLen, allowCustomIv);\n@@ -186,22 +270,0 @@\n-        testIv(c);\n-\n-        ALGO = \"AES\/KW\/NoPadding\";\n-        System.out.println(\"Testing \" + ALGO);\n-        c = Cipher.getInstance(ALGO, \"SunJCE\");\n-        testEnc(c, data, data.length, KW_IV_LEN, 0);\n-        testEnc(c, data, data.length >> 1, KW_IV_LEN, 0);\n-        testWrap(c, data, data.length, KW_IV_LEN, 0);\n-        testWrap(c, data, data.length >> 1, KW_IV_LEN, 0);\n-        testIv(c);\n-\n-        ALGO = \"AES\/KWP\/NoPadding\";\n-        System.out.println(\"Testing \" + ALGO);\n-        c = Cipher.getInstance(ALGO, \"SunJCE\");\n-\n-        \/\/ test all possible pad lengths, i.e. 0 - 7\n-        for (int i = 0; i <= MAX_KWP_PAD_LEN; i++) {\n-            testEnc(c, data, data.length - i, KWP_IV_LEN, MAX_KWP_PAD_LEN);\n-            testWrap(c, data, data.length - i, KWP_IV_LEN, MAX_KWP_PAD_LEN);\n-        }\n-        testIv(c);\n-\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/KeyWrap\/TestGeneral.java","additions":200,"deletions":138,"binary":false,"changes":338,"status":"modified"}]}