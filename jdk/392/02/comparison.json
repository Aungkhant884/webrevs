{"files":[{"patch":"@@ -58,0 +58,2 @@\n+ARC_EXT\t\t= .lib\n+ARC_PRE\t\t=\n@@ -67,0 +69,1 @@\n+CXX \t= $(MINGW)-g++\n@@ -87,0 +90,2 @@\n+ARC_EXT\t\t= .a\n+ARC_PRE\t\t= lib\n@@ -88,0 +93,1 @@\n+CXX \t= g++\n@@ -99,0 +105,1 @@\n+CXX             = xlc_r\n@@ -105,0 +112,2 @@\n+ARC_EXT\t\t= .a\n+ARC_PRE\t\t= lib\n@@ -121,0 +130,2 @@\n+ARC_EXT\t\t\t= .a\n+ARC_PRE\t\t\t= lib\n@@ -122,0 +133,1 @@\n+CXX             = g++\n@@ -132,0 +144,1 @@\n+CXX\t\t= g++\n@@ -138,0 +151,2 @@\n+ARC_EXT\t\t= .lib\n+ARC_PRE\t\t=\n@@ -153,0 +168,1 @@\n+ifeq ($(LLVM),)\n@@ -162,1 +178,9 @@\n-CPPFLAGS\t+= -DLIBARCH_$(LIBARCH) -DLIBARCH=\\\"$(LIBARCH)\\\" -DLIB_EXT=\\\"$(LIB_EXT)\\\"\n+else\n+# LLVM\n+LLVMDIR\t\t= $(shell cd $(LLVM);pwd)\n+\n+CFLAGS\t\t+= -DLLVM=1\n+CPPFLAGS\t+= -I$(LLVMDIR)\/include\n+endif\n+\n+CPPFLAGS\t+= -DLIBOS_$(OS) -DLIBOS=\\\"$(OS)\\\" -DLIBARCH_$(LIBARCH) -DLIBARCH=\\\"$(LIBARCH)\\\" -DLIB_EXT=\\\"$(LIB_EXT)\\\"\n@@ -167,1 +191,1 @@\n-SOURCE\t\t= hsdis.c\n+SOURCE\t\t= hsdis.cpp\n@@ -169,0 +193,1 @@\n+ifeq ($(LLVM),)\n@@ -172,0 +197,11 @@\n+else\n+LIBRARIES\/i386 = $(patsubst -l%,%,$(shell $(LLVMDIR)\/bin\/llvm-config --libs x86 x86disassembler))\n+LIBRARIES\/amd64 = $(patsubst -l%,%,$(shell $(LLVMDIR)\/bin\/llvm-config --libs x86 x86disassembler))\n+LIBRARIES\/aarch64 = $(patsubst -l%,%,$(shell $(LLVMDIR)\/bin\/llvm-config --libs aarch64 aarch64disassembler))\n+\n+ifeq ($(LIBRARIES\/$(ARCH)),)\n+$(error \"unknown LLVM libraries for ARCH=$(ARCH))\n+endif\n+\n+LIBRARIES=$(addprefix $(LLVMDIR)\/lib\/,$(patsubst %,$(ARC_PRE)%$(ARC_EXT),$(LIBRARIES\/$(ARCH))))\n+endif\n@@ -177,0 +213,4 @@\n+ifneq ($(LLVM),)\n+DLDFLAGS+=$(shell $(LLVMDIR)\/bin\/llvm-config --system-libs)\n+endif\n+\n@@ -191,0 +231,1 @@\n+ifeq ($(LLVM),)\n@@ -196,0 +237,1 @@\n+endif\n@@ -198,1 +240,1 @@\n-\t$(CC) $(OUTFLAGS) $(CPPFLAGS) $(CFLAGS) $(SOURCE) $(DLDFLAGS) $(LIBRARIES)\n+\t$(CXX) $(OUTFLAGS) $(CPPFLAGS) $(CFLAGS) $(SOURCE) $(DLDFLAGS) $(LIBRARIES)\n","filename":"src\/utils\/hsdis\/Makefile","additions":45,"deletions":3,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1,583 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * The Universal Permissive License (UPL), Version 1.0\n- *\n- * Subject to the condition set forth below, permission is hereby granted to\n- * any person obtaining a copy of this software, associated documentation\n- * and\/or data (collectively the \"Software\"), free of charge and under any\n- * and all copyright rights in the Software, and any and all patent rights\n- * owned or freely licensable by each licensor hereunder covering either (i)\n- * the unmodified Software as contributed to or provided by such licensor,\n- * or (ii) the Larger Works (as defined below), to deal in both\n- *\n- * (a) the Software, and\n- *\n- * (b) any piece of software and\/or hardware listed in the lrgrwrks.txt file\n- * if one is included with the Software (each a \"Larger Work\" to which the\n- * Software is contributed by such licensors),\n- *\n- * without restriction, including without limitation the rights to copy,\n- * create derivative works of, display, perform, and distribute the Software\n- * and make, use, sell, offer for sale, import, export, have made, and have\n- * sold the Software and the Larger Work(s), and to sublicense the foregoing\n- * rights on either these or other terms.\n- *\n- * This license is subject to the following condition:\n- *\n- * The above copyright notice and either this complete permission notice or\n- * at a minimum a reference to the UPL must be included in all copies or\n- * substantial portions of the Software.\n- *\n- * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n- * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n- * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n- * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n- * USE OR OTHER DEALINGS IN THE SOFTWARE.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/* hsdis.c -- dump a range of addresses as native instructions\n-   This implements the plugin protocol required by the\n-   HotSpot PrintAssembly option.\n-*\/\n-\n-#include <config.h> \/* required by bfd.h *\/\n-#include <errno.h>\n-#include <inttypes.h>\n-#include <string.h>\n-\n-#include <libiberty.h>\n-#include <bfd.h>\n-#include <bfdver.h>\n-#include <dis-asm.h>\n-\n-#include \"hsdis.h\"\n-\n-#ifndef bool\n-#define bool int\n-#define true 1\n-#define false 0\n-#endif \/*bool*\/\n-\n-\/* short names for stuff in hsdis.h *\/\n-typedef decode_instructions_event_callback_ftype  event_callback_t;\n-typedef decode_instructions_printf_callback_ftype printf_callback_t;\n-\n-\/* disassemble_info.application_data object *\/\n-struct hsdis_app_data {\n-  \/* virtual address of data *\/\n-  uintptr_t start_va, end_va;\n-  \/* the instructions to be decoded *\/\n-  unsigned char* buffer;\n-  uintptr_t length;\n-  event_callback_t  event_callback;  void* event_stream;\n-  printf_callback_t printf_callback; void* printf_stream;\n-  bool losing;\n-  bool do_newline;\n-\n-  \/* the architecture being disassembled *\/\n-  const char* arch_name;\n-  const bfd_arch_info_type* arch_info;\n-\n-  \/* the disassembler we are going to use: *\/\n-  disassembler_ftype      dfn;\n-  struct disassemble_info dinfo; \/* the actual struct! *\/\n-\n-  char mach_option[64];\n-  char insn_options[256];\n-};\n-\n-static void* decode(struct hsdis_app_data* app_data, const char* options);\n-\n-#define DECL_APP_DATA(dinfo) \\\n-  struct hsdis_app_data* app_data = (struct hsdis_app_data*) (dinfo)->application_data\n-\n-#define DECL_EVENT_CALLBACK(app_data) \\\n-  event_callback_t  event_callback = (app_data)->event_callback; \\\n-  void*             event_stream   = (app_data)->event_stream\n-\n-#define DECL_PRINTF_CALLBACK(app_data) \\\n-  printf_callback_t  printf_callback = (app_data)->printf_callback; \\\n-  void*              printf_stream   = (app_data)->printf_stream\n-\n-\n-static void print_help(struct hsdis_app_data* app_data,\n-                       const char* msg, const char* arg);\n-static void setup_app_data(struct hsdis_app_data* app_data,\n-                           const char* options);\n-static const char* format_insn_close(const char* close,\n-                                     disassemble_info* dinfo,\n-                                     char* buf, size_t bufsize);\n-\n-void*\n-#ifdef DLL_ENTRY\n-  DLL_ENTRY\n-#endif\n-decode_instructions_virtual(uintptr_t start_va, uintptr_t end_va,\n-                            unsigned char* buffer, uintptr_t length,\n-                            event_callback_t  event_callback_arg,  void* event_stream_arg,\n-                            printf_callback_t printf_callback_arg, void* printf_stream_arg,\n-                            const char* options, int newline) {\n-  struct hsdis_app_data app_data;\n-  memset(&app_data, 0, sizeof(app_data));\n-  app_data.start_va    = start_va;\n-  app_data.end_va      = end_va;\n-  app_data.buffer = buffer;\n-  app_data.length = length;\n-  app_data.event_callback  = event_callback_arg;\n-  app_data.event_stream    = event_stream_arg;\n-  app_data.printf_callback = printf_callback_arg;\n-  app_data.printf_stream   = printf_stream_arg;\n-  app_data.do_newline = newline == 0 ? false : true;\n-\n-  return decode(&app_data, options);\n-}\n-\n-\/* This is the compatability interface for older version of hotspot *\/\n-void*\n-#ifdef DLL_ENTRY\n-  DLL_ENTRY\n-#endif\n-decode_instructions(void* start_pv, void* end_pv,\n-                    event_callback_t  event_callback_arg,  void* event_stream_arg,\n-                    printf_callback_t printf_callback_arg, void* printf_stream_arg,\n-                    const char* options) {\n-  return decode_instructions_virtual((uintptr_t)start_pv,\n-                                     (uintptr_t)end_pv,\n-                                     (unsigned char*)start_pv,\n-                                     (uintptr_t)end_pv - (uintptr_t)start_pv,\n-                                     event_callback_arg,\n-                                     event_stream_arg,\n-                                     printf_callback_arg,\n-                                     printf_stream_arg,\n-                                     options, false);\n-}\n-\n-static void* decode(struct hsdis_app_data* app_data, const char* options) {\n-  setup_app_data(app_data, options);\n-  char buf[128];\n-\n-  {\n-    \/* now reload everything from app_data: *\/\n-    DECL_EVENT_CALLBACK(app_data);\n-    DECL_PRINTF_CALLBACK(app_data);\n-    uintptr_t start = app_data->start_va;\n-    uintptr_t end   = app_data->end_va;\n-    uintptr_t p     = start;\n-\n-    (*event_callback)(event_stream, \"insns\", (void*)start);\n-\n-    (*event_callback)(event_stream, \"mach name='%s'\",\n-                      (void*) app_data->arch_info->printable_name);\n-    if (app_data->dinfo.bytes_per_line != 0) {\n-      (*event_callback)(event_stream, \"format bytes-per-line='%p'\/\",\n-                        (void*)(intptr_t) app_data->dinfo.bytes_per_line);\n-    }\n-\n-    while (p < end && !app_data->losing) {\n-      (*event_callback)(event_stream, \"insn\", (void*) p);\n-\n-      \/* reset certain state, so we can read it with confidence *\/\n-      app_data->dinfo.insn_info_valid    = 0;\n-      app_data->dinfo.branch_delay_insns = 0;\n-      app_data->dinfo.data_size          = 0;\n-      app_data->dinfo.insn_type          = 0;\n-\n-      int size = (*app_data->dfn)((bfd_vma) p, &app_data->dinfo);\n-\n-      if (size > 0)  p += size;\n-      else           app_data->losing = true;\n-\n-      if (!app_data->losing) {\n-        const char* insn_close = format_insn_close(\"\/insn\", &app_data->dinfo,\n-                                                   buf, sizeof(buf));\n-        (*event_callback)(event_stream, insn_close, (void*) p);\n-\n-        if (app_data->do_newline) {\n-          \/* follow each complete insn by a nice newline *\/\n-          (*printf_callback)(printf_stream, \"\\n\");\n-        }\n-      }\n-    }\n-\n-    if (app_data->losing) (*event_callback)(event_stream, \"\/insns\", (void*) p);\n-    return (void*) p;\n-  }\n-}\n-\n-\/* take the address of the function, for luck, and also test the typedef: *\/\n-const decode_func_vtype decode_func_virtual_address = &decode_instructions_virtual;\n-const decode_func_stype decode_func_address = &decode_instructions;\n-\n-static const char* format_insn_close(const char* close,\n-                                     disassemble_info* dinfo,\n-                                     char* buf, size_t bufsize) {\n-  if (!dinfo->insn_info_valid)\n-    return close;\n-  enum dis_insn_type itype = dinfo->insn_type;\n-  int dsize = dinfo->data_size, delays = dinfo->branch_delay_insns;\n-  if ((itype == dis_nonbranch && (dsize | delays) == 0)\n-      || (strlen(close) + 3*20 > bufsize))\n-    return close;\n-\n-  const char* type = \"unknown\";\n-  switch (itype) {\n-  case dis_nonbranch:   type = NULL;         break;\n-  case dis_branch:      type = \"branch\";     break;\n-  case dis_condbranch:  type = \"condbranch\"; break;\n-  case dis_jsr:         type = \"jsr\";        break;\n-  case dis_condjsr:     type = \"condjsr\";    break;\n-  case dis_dref:        type = \"dref\";       break;\n-  case dis_dref2:       type = \"dref2\";      break;\n-  case dis_noninsn:     type = \"noninsn\";    break;\n-  }\n-\n-  strcpy(buf, close);\n-  char* p = buf;\n-  if (type)    sprintf(p += strlen(p), \" type='%s'\", type);\n-  if (dsize)   sprintf(p += strlen(p), \" dsize='%d'\", dsize);\n-  if (delays)  sprintf(p += strlen(p), \" delay='%d'\", delays);\n-  return buf;\n-}\n-\n-\/* handler functions *\/\n-\n-static int\n-hsdis_read_memory_func(bfd_vma memaddr,\n-                       bfd_byte* myaddr,\n-                       unsigned int length,\n-                       struct disassemble_info* dinfo) {\n-  DECL_APP_DATA(dinfo);\n-  \/* convert the virtual address memaddr into an address within memory buffer *\/\n-  uintptr_t offset = ((uintptr_t) memaddr) - app_data->start_va;\n-  if (offset + length > app_data->length) {\n-    \/* read is out of bounds *\/\n-    return EIO;\n-  } else {\n-    memcpy(myaddr, (bfd_byte*) (app_data->buffer + offset), length);\n-    return 0;\n-  }\n-}\n-\n-static void\n-hsdis_print_address_func(bfd_vma vma, struct disassemble_info* dinfo) {\n-  \/* the actual value to print: *\/\n-  void* addr_value = (void*) (uintptr_t) vma;\n-  DECL_APP_DATA(dinfo);\n-  DECL_EVENT_CALLBACK(app_data);\n-\n-  \/* issue the event: *\/\n-  void* result =\n-    (*event_callback)(event_stream, \"addr\/\", addr_value);\n-  if (result == NULL) {\n-    \/* event declined *\/\n-    generic_print_address(vma, dinfo);\n-  }\n-}\n-\n-\n-\/* configuration *\/\n-\n-static void set_optional_callbacks(struct hsdis_app_data* app_data);\n-static void parse_caller_options(struct hsdis_app_data* app_data,\n-                                 const char* caller_options);\n-static const char* native_arch_name();\n-static enum bfd_endian native_endian();\n-static const bfd_arch_info_type* find_arch_info(const char* arch_nane);\n-static bfd* get_native_bfd(const bfd_arch_info_type* arch_info,\n-                           \/* to avoid malloc: *\/\n-                           bfd* empty_bfd, bfd_target* empty_xvec);\n-static void init_disassemble_info_from_bfd(struct disassemble_info* dinfo,\n-                                           void *stream,\n-                                           fprintf_ftype fprintf_func,\n-                                           bfd* bfd,\n-                                           char* disassembler_options);\n-static void parse_fake_insn(disassembler_ftype dfn,\n-                            struct disassemble_info* dinfo);\n-\n-static void setup_app_data(struct hsdis_app_data* app_data,\n-                           const char* caller_options) {\n-  \/* Make reasonable defaults for null callbacks.\n-     A non-null stream for a null callback is assumed to be a FILE* for output.\n-     Events are rendered as XML.\n-  *\/\n-  set_optional_callbacks(app_data);\n-\n-  \/* Look into caller_options for anything interesting. *\/\n-  if (caller_options != NULL)\n-    parse_caller_options(app_data, caller_options);\n-\n-  \/* Discover which architecture we are going to disassemble. *\/\n-  app_data->arch_name = &app_data->mach_option[0];\n-  if (app_data->arch_name[0] == '\\0')\n-    app_data->arch_name = native_arch_name();\n-  app_data->arch_info = find_arch_info(app_data->arch_name);\n-\n-  \/* Make a fake bfd to hold the arch. and byteorder info. *\/\n-  struct {\n-    bfd_target empty_xvec;\n-    bfd        empty_bfd;\n-  } buf;\n-  bfd* native_bfd = get_native_bfd(app_data->arch_info,\n-                                   \/* to avoid malloc: *\/\n-                                   &buf.empty_bfd, &buf.empty_xvec);\n-  init_disassemble_info_from_bfd(&app_data->dinfo,\n-                                 app_data->printf_stream,\n-                                 app_data->printf_callback,\n-                                 native_bfd,\n-                                 \/* On PowerPC we get warnings, if we pass empty options *\/\n-                                 (caller_options == NULL) ? NULL : app_data->insn_options);\n-\n-  \/* Finish linking together the various callback blocks. *\/\n-  app_data->dinfo.application_data = (void*) app_data;\n-  app_data->dfn = disassembler(bfd_get_arch(native_bfd),\n-                               bfd_big_endian(native_bfd),\n-                               bfd_get_mach(native_bfd),\n-                               native_bfd);\n-  app_data->dinfo.print_address_func = hsdis_print_address_func;\n-  app_data->dinfo.read_memory_func = hsdis_read_memory_func;\n-\n-  if (app_data->dfn == NULL) {\n-    const char* bad = app_data->arch_name;\n-    static bool complained;\n-    if (bad == &app_data->mach_option[0])\n-      print_help(app_data, \"bad mach=%s\", bad);\n-    else if (!complained)\n-      print_help(app_data, \"bad native mach=%s; please port hsdis to this platform\", bad);\n-    complained = true;\n-    \/* must bail out *\/\n-    app_data->losing = true;\n-    return;\n-  }\n-\n-  parse_fake_insn(app_data->dfn, &app_data->dinfo);\n-}\n-\n-\n-\/* ignore all events, return a null *\/\n-static void* null_event_callback(void* ignore_stream, const char* ignore_event, void* arg) {\n-  return NULL;\n-}\n-\n-\/* print all events as XML markup *\/\n-static void* xml_event_callback(void* stream, const char* event, void* arg) {\n-  FILE* fp = (FILE*) stream;\n-#define NS_PFX \"dis:\"\n-  if (event[0] != '\/') {\n-    \/* issue the tag, with or without a formatted argument *\/\n-    fprintf(fp, \"<\"NS_PFX);\n-    fprintf(fp, event, arg);\n-    fprintf(fp, \">\");\n-  } else {\n-    ++event;                    \/* skip slash *\/\n-    const char* argp = strchr(event, ' ');\n-    if (argp == NULL) {\n-      \/* no arguments; just issue the closing tag *\/\n-      fprintf(fp, \"<\/\"NS_PFX\"%s>\", event);\n-    } else {\n-      \/* split out the closing attributes as <dis:foo_done attr='val'\/> *\/\n-      int event_prefix = (argp - event);\n-      fprintf(fp, \"<\"NS_PFX\"%.*s_done\", event_prefix, event);\n-      fprintf(fp, argp, arg);\n-      fprintf(fp, \"\/><\/\"NS_PFX\"%.*s>\", event_prefix, event);\n-    }\n-  }\n-  return NULL;\n-}\n-\n-static void set_optional_callbacks(struct hsdis_app_data* app_data) {\n-  if (app_data->printf_callback == NULL) {\n-    int (*fprintf_callback)(FILE*, const char*, ...) = &fprintf;\n-    FILE* fprintf_stream = stdout;\n-    app_data->printf_callback = (printf_callback_t) fprintf_callback;\n-    if (app_data->printf_stream == NULL)\n-      app_data->printf_stream   = (void*)           fprintf_stream;\n-  }\n-  if (app_data->event_callback == NULL) {\n-    if (app_data->event_stream == NULL)\n-      app_data->event_callback = &null_event_callback;\n-    else\n-      app_data->event_callback = &xml_event_callback;\n-  }\n-\n-}\n-\n-static void parse_caller_options(struct hsdis_app_data* app_data, const char* caller_options) {\n-  char* iop_base = app_data->insn_options;\n-  char* iop_limit = iop_base + sizeof(app_data->insn_options) - 1;\n-  char* iop = iop_base;\n-  const char* p;\n-  for (p = caller_options; p != NULL; ) {\n-    const char* q = strchr(p, ',');\n-    size_t plen = (q == NULL) ? strlen(p) : ((q++) - p);\n-    if (plen == 4 && strncmp(p, \"help\", plen) == 0) {\n-      print_help(app_data, NULL, NULL);\n-    } else if (plen >= 5 && strncmp(p, \"mach=\", 5) == 0) {\n-      char*  mach_option = app_data->mach_option;\n-      size_t mach_size   = sizeof(app_data->mach_option);\n-      mach_size -= 1;           \/*leave room for the null*\/\n-      if (plen > mach_size)  plen = mach_size;\n-      strncpy(mach_option, p, plen);\n-      mach_option[plen] = '\\0';\n-    } else if (plen > 6 && strncmp(p, \"hsdis-\", 6) == 0) {\n-      \/\/ do not pass these to the next level\n-    } else {\n-      \/* just copy it; {i386,sparc}-dis.c might like to see it  *\/\n-      if (iop > iop_base && iop < iop_limit)  (*iop++) = ',';\n-      if (iop + plen > iop_limit)\n-        plen = iop_limit - iop;\n-      strncpy(iop, p, plen);\n-      iop += plen;\n-    }\n-    p = q;\n-  }\n-  *iop = '\\0';\n-}\n-\n-static void print_help(struct hsdis_app_data* app_data,\n-                       const char* msg, const char* arg) {\n-  DECL_PRINTF_CALLBACK(app_data);\n-  if (msg != NULL) {\n-    (*printf_callback)(printf_stream, \"hsdis: \");\n-    (*printf_callback)(printf_stream, msg, arg);\n-    (*printf_callback)(printf_stream, \"\\n\");\n-  }\n-  (*printf_callback)(printf_stream, \"hsdis output options:\\n\");\n-  if (printf_callback == (printf_callback_t) &fprintf)\n-    disassembler_usage((FILE*) printf_stream);\n-  else\n-    disassembler_usage(stderr); \/* better than nothing *\/\n-  (*printf_callback)(printf_stream, \"  mach=<arch>   select disassembly mode\\n\");\n-#if defined(LIBARCH_i386) || defined(LIBARCH_amd64)\n-  (*printf_callback)(printf_stream, \"  mach=i386     select 32-bit mode\\n\");\n-  (*printf_callback)(printf_stream, \"  mach=x86-64   select 64-bit mode\\n\");\n-  (*printf_callback)(printf_stream, \"  suffix        always print instruction suffix\\n\");\n-#endif\n-  (*printf_callback)(printf_stream, \"  help          print this message\\n\");\n-}\n-\n-\n-\/* low-level bfd and arch stuff that binutils doesn't do for us *\/\n-\n-static const bfd_arch_info_type* find_arch_info(const char* arch_name) {\n-  const bfd_arch_info_type* arch_info = bfd_scan_arch(arch_name);\n-  if (arch_info == NULL) {\n-    extern const bfd_arch_info_type bfd_default_arch_struct;\n-    arch_info = &bfd_default_arch_struct;\n-  }\n-  return arch_info;\n-}\n-\n-static const char* native_arch_name() {\n-  const char* res = NULL;\n-#ifdef LIBARCH_i386\n-  res = \"i386\";\n-#endif\n-#ifdef LIBARCH_amd64\n-  res = \"i386:x86-64\";\n-#endif\n-#if  defined(LIBARCH_ppc64) || defined(LIBARCH_ppc64le)\n-  res = \"powerpc:common64\";\n-#endif\n-#ifdef LIBARCH_arm\n-  res = \"arm\";\n-#endif\n-#ifdef LIBARCH_aarch64\n-  res = \"aarch64\";\n-#endif\n-#ifdef LIBARCH_s390x\n-  res = \"s390:64-bit\";\n-#endif\n-  if (res == NULL)\n-    res = \"architecture not set in Makefile!\";\n-  return res;\n-}\n-\n-static enum bfd_endian native_endian() {\n-  int32_t endian_test = 'x';\n-  if (*(const char*) &endian_test == 'x')\n-    return BFD_ENDIAN_LITTLE;\n-  else\n-    return BFD_ENDIAN_BIG;\n-}\n-\n-static bfd* get_native_bfd(const bfd_arch_info_type* arch_info,\n-                           bfd* empty_bfd, bfd_target* empty_xvec) {\n-  memset(empty_bfd,  0, sizeof(*empty_bfd));\n-  memset(empty_xvec, 0, sizeof(*empty_xvec));\n-  empty_xvec->flavour = bfd_target_unknown_flavour;\n-  empty_xvec->byteorder = native_endian();\n-  empty_bfd->xvec = empty_xvec;\n-  empty_bfd->arch_info = arch_info;\n-  return empty_bfd;\n-}\n-\n-static int read_zero_data_only(bfd_vma ignore_p,\n-                               bfd_byte* myaddr, unsigned int length,\n-                               struct disassemble_info *ignore_info) {\n-  memset(myaddr, 0, length);\n-  return 0;\n-}\n-static int print_to_dev_null(void* ignore_stream, const char* ignore_format, ...) {\n-  return 0;\n-}\n-\n-\/* Prime the pump by running the selected disassembler on a null input.\n-   This forces the machine-specific disassembler to divulge invariant\n-   information like bytes_per_line.\n- *\/\n-static void parse_fake_insn(disassembler_ftype dfn,\n-                            struct disassemble_info* dinfo) {\n-  typedef int (*read_memory_ftype)\n-    (bfd_vma memaddr, bfd_byte *myaddr, unsigned int length,\n-     struct disassemble_info *info);\n-  read_memory_ftype read_memory_func = dinfo->read_memory_func;\n-  fprintf_ftype     fprintf_func     = dinfo->fprintf_func;\n-\n-  dinfo->read_memory_func = &read_zero_data_only;\n-  dinfo->fprintf_func     = &print_to_dev_null;\n-  (*dfn)(0, dinfo);\n-\n-  \/* put it back *\/\n-  dinfo->read_memory_func = read_memory_func;\n-  dinfo->fprintf_func     = fprintf_func;\n-}\n-\n-static void init_disassemble_info_from_bfd(struct disassemble_info* dinfo,\n-                                           void *stream,\n-                                           fprintf_ftype fprintf_func,\n-                                           bfd* abfd,\n-                                           char* disassembler_options) {\n-  init_disassemble_info(dinfo, stream, fprintf_func);\n-\n-  dinfo->flavour = bfd_get_flavour(abfd);\n-  dinfo->arch = bfd_get_arch(abfd);\n-  dinfo->mach = bfd_get_mach(abfd);\n-  dinfo->disassembler_options = disassembler_options;\n-#if BFD_VERSION >= 234000000\n-  \/* bfd_octets_per_byte() has 2 args since binutils 2.34 *\/\n-  dinfo->octets_per_byte = bfd_octets_per_byte (abfd, NULL);\n-#else\n-  dinfo->octets_per_byte = bfd_octets_per_byte (abfd);\n-#endif\n-  dinfo->skip_zeroes = sizeof(void*) * 2;\n-  dinfo->skip_zeroes_at_end = sizeof(void*)-1;\n-  dinfo->disassembler_needs_relocs = FALSE;\n-\n-  if (bfd_big_endian(abfd))\n-    dinfo->display_endian = dinfo->endian = BFD_ENDIAN_BIG;\n-  else if (bfd_little_endian(abfd))\n-    dinfo->display_endian = dinfo->endian = BFD_ENDIAN_LITTLE;\n-  else\n-    dinfo->endian = native_endian();\n-\n-  disassemble_init_for_target(dinfo);\n-}\n","filename":"src\/utils\/hsdis\/hsdis.c","additions":0,"deletions":583,"binary":false,"changes":583,"status":"deleted"},{"patch":"@@ -0,0 +1,694 @@\n+\/*\n+ * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The Universal Permissive License (UPL), Version 1.0\n+ *\n+ * Subject to the condition set forth below, permission is hereby granted to\n+ * any person obtaining a copy of this software, associated documentation\n+ * and\/or data (collectively the \"Software\"), free of charge and under any\n+ * and all copyright rights in the Software, and any and all patent rights\n+ * owned or freely licensable by each licensor hereunder covering either (i)\n+ * the unmodified Software as contributed to or provided by such licensor,\n+ * or (ii) the Larger Works (as defined below), to deal in both\n+ *\n+ * (a) the Software, and\n+ *\n+ * (b) any piece of software and\/or hardware listed in the lrgrwrks.txt file\n+ * if one is included with the Software (each a \"Larger Work\" to which the\n+ * Software is contributed by such licensors),\n+ *\n+ * without restriction, including without limitation the rights to copy,\n+ * create derivative works of, display, perform, and distribute the Software\n+ * and make, use, sell, offer for sale, import, export, have made, and have\n+ * sold the Software and the Larger Work(s), and to sublicense the foregoing\n+ * rights on either these or other terms.\n+ *\n+ * This license is subject to the following condition:\n+ *\n+ * The above copyright notice and either this complete permission notice or\n+ * at a minimum a reference to the UPL must be included in all copies or\n+ * substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n+ * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n+ * USE OR OTHER DEALINGS IN THE SOFTWARE.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/* hsdis.c -- dump a range of addresses as native instructions\n+   This implements the plugin protocol required by the\n+   HotSpot PrintAssembly option.\n+*\/\n+\n+#define STRING2(x) #x\n+#define STRING(x) STRING2(x)\n+\n+#ifndef LLVM\n+#include <config.h> \/* required by bfd.h *\/\n+#endif\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <errno.h>\n+#include <inttypes.h>\n+#include <string.h>\n+\n+#ifndef LLVM\n+#include <libiberty.h>\n+#include <bfd.h>\n+#include <bfdver.h>\n+#include <dis-asm.h>\n+#else\n+#include <llvm-c\/Disassembler.h>\n+#include <llvm-c\/DisassemblerTypes.h>\n+#include <llvm-c\/Target.h>\n+#include <llvm-c\/TargetMachine.h>\n+#endif\n+\n+#include \"hsdis.h\"\n+\n+\/* short names for stuff in hsdis.h *\/\n+typedef decode_instructions_event_callback_ftype  event_callback_t;\n+typedef decode_instructions_printf_callback_ftype printf_callback_t;\n+\n+class hsdis_backend_base {\n+ protected:\n+  uintptr_t         _start_va;\n+  uintptr_t         _end_va;\n+  unsigned char*    _buffer;\n+  uintptr_t         _length;\n+  event_callback_t  _event_callback;\n+  void*             _event_stream;\n+  printf_callback_t _printf_callback;\n+  void*             _printf_stream;\n+  int               _do_newline;\n+\n+  bool              _losing = false;\n+  const char*       _arch_name = NULL;\n+\n+  virtual void print_help(const char* msg, const char* arg) = 0;\n+  virtual void print_insns_config() = 0;\n+  virtual size_t decode_instruction(uintptr_t p, uintptr_t start, uintptr_t end) = 0;\n+  virtual const char* format_insn_close(const char* close, char* buf, size_t bufsize) = 0;\n+\n+ private:\n+  \/* ignore all events, return a null *\/\n+  static void* null_event_callback(void* ignore_stream, const char* ignore_event, void* arg) {\n+    return NULL;\n+  }\n+\n+  \/* print all events as XML markup *\/\n+  static void* xml_event_callback(void* stream, const char* event, void* arg) {\n+    FILE* fp = (FILE*) stream;\n+#define NS_PFX \"dis:\"\n+    if (event[0] != '\/') {\n+      \/* issue the tag, with or without a formatted argument *\/\n+      fprintf(fp, \"<\" NS_PFX);\n+      fprintf(fp, event, arg);\n+      fprintf(fp, \">\");\n+    } else {\n+      ++event;                    \/* skip slash *\/\n+      const char* argp = strchr(event, ' ');\n+      if (argp == NULL) {\n+        \/* no arguments; just issue the closing tag *\/\n+        fprintf(fp, \"<\/\" NS_PFX \"%s>\", event);\n+      } else {\n+        \/* split out the closing attributes as <dis:foo_done attr='val'\/> *\/\n+        int event_prefix = (argp - event);\n+        fprintf(fp, \"<\" NS_PFX \"%.*s_done\", event_prefix, event);\n+        fprintf(fp, argp, arg);\n+        fprintf(fp, \"\/><\/\" NS_PFX \"%.*s>\", event_prefix, event);\n+      }\n+    }\n+#undef NS_PFX\n+    return NULL;\n+  }\n+\n+protected:\n+  hsdis_backend_base(uintptr_t start_va, uintptr_t end_va,\n+                     unsigned char* buffer, uintptr_t length,\n+                     event_callback_t  event_callback,  void* event_stream,\n+                     printf_callback_t printf_callback, void* printf_stream,\n+                     int do_newline) :\n+      _start_va(start_va), _end_va(end_va),\n+      _buffer(buffer), _length(length),\n+      _event_callback(event_callback), _event_stream(event_stream),\n+      _printf_callback(printf_callback), _printf_stream(printf_stream),\n+      _do_newline(do_newline)\n+  {\n+    \/* Make reasonable defaults for null callbacks.\n+      A non-null stream for a null callback is assumed to be a FILE* for output.\n+      Events are rendered as XML.\n+    *\/\n+    if (_printf_callback == NULL) {\n+      int (*fprintf_callback)(FILE*, const char*, ...) = &fprintf;\n+      FILE* fprintf_stream = stdout;\n+      _printf_callback = (printf_callback_t) fprintf_callback;\n+      if (_printf_stream == NULL)\n+        _printf_stream   = (void*)           fprintf_stream;\n+    }\n+    if (_event_callback == NULL) {\n+      if (_event_stream == NULL)\n+        _event_callback = (event_callback_t)&null_event_callback;\n+      else\n+        _event_callback = (event_callback_t)&xml_event_callback;\n+    }\n+  }\n+\n+ public:\n+  void* decode() {\n+    uintptr_t start = _start_va;\n+    uintptr_t end   = _end_va;\n+    uintptr_t p     = start;\n+\n+    (*_event_callback)(_event_stream, \"insns\", (void*)start);\n+\n+    print_insns_config();\n+\n+    while (p < end && !_losing) {\n+      (*_event_callback)(_event_stream, \"insn\", (void*) p);\n+\n+      size_t size = decode_instruction(p, start, end);\n+      if (size > 0)  p += size;\n+      else           _losing = true;\n+\n+      if (!_losing) {\n+        char buf[128];\n+        const char* insn_close = format_insn_close(\"\/insn\", buf, sizeof(buf));\n+        (*_event_callback)(_event_stream, insn_close, (void*) p);\n+\n+        if (_do_newline) {\n+          \/* follow each complete insn by a nice newline *\/\n+          (*_printf_callback)(_printf_stream, \"\\n\");\n+        }\n+      }\n+    }\n+\n+    if (_losing) (*_event_callback)(_event_stream, \"\/insns\", (void*) p);\n+    return (void*) p;\n+  }\n+};\n+\n+#ifndef LLVM\n+\n+class hsdis_backend : public hsdis_backend_base {\n+ private:\n+  disassembler_ftype        _dfn;\n+  struct disassemble_info   _dinfo;\n+  const bfd_arch_info_type* _arch_info;\n+  char                      _mach_option[64];\n+  char                      _insn_options[256];\n+\n+  void parse_caller_options(const char* options) {\n+    memset(&_mach_option, 0, sizeof(_mach_option));\n+    memset(&_insn_options, 0, sizeof(_insn_options));\n+    char* iop_base = _insn_options;\n+    char* iop_limit = iop_base + sizeof(_insn_options) - 1;\n+    char* iop = iop_base;\n+    const char* p;\n+    for (p = options; p != NULL; ) {\n+      const char* q = strchr(p, ',');\n+      size_t plen = (q == NULL) ? strlen(p) : ((q++) - p);\n+      if (plen == 4 && strncmp(p, \"help\", plen) == 0) {\n+        print_help(NULL, NULL);\n+      } else if (plen > 6 && strncmp(p, \"hsdis-\", 6) == 0) {\n+        \/\/ do not pass these to the next level\n+      } else if (plen >= 5 && strncmp(p, \"mach=\", 5) == 0) {\n+        char*  mach_option = _mach_option;\n+        size_t mach_size   = sizeof(_mach_option);\n+        mach_size -= 1;           \/*leave room for the null*\/\n+        if (plen > mach_size)  plen = mach_size;\n+        strncpy(mach_option, p, plen);\n+        mach_option[plen] = '\\0';\n+      } else {\n+        \/* just copy it; {i386,sparc}-dis.c might like to see it  *\/\n+        if (iop > iop_base && iop < iop_limit)  (*iop++) = ',';\n+        if (iop + plen > iop_limit)\n+          plen = iop_limit - iop;\n+        strncpy(iop, p, plen);\n+        iop += plen;\n+      }\n+      p = q;\n+    }\n+    *iop = '\\0';\n+  }\n+\n+  \/* configuration *\/\n+  const char* native_arch_name() {\n+    const char* res = NULL;\n+#ifdef LIBARCH_i386\n+    res = \"i386\";\n+#endif\n+#ifdef LIBARCH_amd64\n+    res = \"i386:x86-64\";\n+#endif\n+#if  defined(LIBARCH_ppc64) || defined(LIBARCH_ppc64le)\n+    res = \"powerpc:common64\";\n+#endif\n+#ifdef LIBARCH_arm\n+    res = \"arm\";\n+#endif\n+#ifdef LIBARCH_aarch64\n+    res = \"aarch64\";\n+#endif\n+#ifdef LIBARCH_s390x\n+    res = \"s390:64-bit\";\n+#endif\n+    if (res == NULL)\n+      res = \"architecture not set in Makefile!\";\n+    return res;\n+  }\n+\n+  enum bfd_endian native_endian() {\n+    int32_t endian_test = 'x';\n+    if (*(const char*) &endian_test == 'x')\n+      return BFD_ENDIAN_LITTLE;\n+    else\n+      return BFD_ENDIAN_BIG;\n+  }\n+\n+  const bfd_arch_info_type* find_arch_info(const char* arch_name) {\n+    const bfd_arch_info_type* arch_info = bfd_scan_arch(arch_name);\n+    if (arch_info == NULL) {\n+      extern const bfd_arch_info_type bfd_default_arch_struct;\n+      arch_info = &bfd_default_arch_struct;\n+    }\n+    return arch_info;\n+  }\n+\n+  bfd* get_native_bfd(const bfd_arch_info_type* arch_info,\n+                      \/* to avoid malloc: *\/\n+                      bfd* empty_bfd, bfd_target* empty_xvec) {\n+    memset(empty_bfd,  0, sizeof(*empty_bfd));\n+    memset(empty_xvec, 0, sizeof(*empty_xvec));\n+    empty_xvec->flavour = bfd_target_unknown_flavour;\n+    empty_xvec->byteorder = native_endian();\n+    empty_bfd->xvec = empty_xvec;\n+    empty_bfd->arch_info = arch_info;\n+    return empty_bfd;\n+  }\n+\n+  void init_disassemble_info_from_bfd(struct disassemble_info* dinfo,\n+                                      void *stream,\n+                                      fprintf_ftype fprintf_func,\n+                                      bfd* abfd,\n+                                      char* disassembler_options) {\n+    init_disassemble_info(dinfo, stream, fprintf_func);\n+\n+    dinfo->flavour = bfd_get_flavour(abfd);\n+    dinfo->arch = bfd_get_arch(abfd);\n+    dinfo->mach = bfd_get_mach(abfd);\n+    dinfo->disassembler_options = disassembler_options;\n+#if BFD_VERSION >= 234000000\n+    \/* bfd_octets_per_byte() has 2 args since binutils 2.34 *\/\n+    dinfo->octets_per_byte = bfd_octets_per_byte (abfd, NULL);\n+#else\n+    dinfo->octets_per_byte = bfd_octets_per_byte (abfd);\n+#endif\n+    dinfo->skip_zeroes = sizeof(void*) * 2;\n+    dinfo->skip_zeroes_at_end = sizeof(void*)-1;\n+    dinfo->disassembler_needs_relocs = FALSE;\n+\n+    if (bfd_big_endian(abfd))\n+      dinfo->display_endian = dinfo->endian = BFD_ENDIAN_BIG;\n+    else if (bfd_little_endian(abfd))\n+      dinfo->display_endian = dinfo->endian = BFD_ENDIAN_LITTLE;\n+    else\n+      dinfo->endian = native_endian();\n+\n+    disassemble_init_for_target(dinfo);\n+  }\n+\n+  \/* low-level bfd and arch stuff that binutils doesn't do for us *\/\n+\n+  static int read_zero_data_only(bfd_vma ignore_p,\n+                                 bfd_byte* myaddr, unsigned int length,\n+                                 struct disassemble_info *ignore_info) {\n+    memset(myaddr, 0, length);\n+    return 0;\n+  }\n+  static int print_to_dev_null(void* ignore_stream, const char* ignore_format, ...) {\n+    return 0;\n+  }\n+\n+  \/* Prime the pump by running the selected disassembler on a null input.\n+   * This forces the machine-specific disassembler to divulge invariant\n+   * information like bytes_per_line. *\/\n+  void parse_fake_insn(disassembler_ftype dfn,\n+                       struct disassemble_info* dinfo) {\n+    typedef int (*read_memory_ftype)\n+      (bfd_vma memaddr, bfd_byte *myaddr, unsigned int length,\n+      struct disassemble_info *info);\n+    read_memory_ftype read_memory_func = dinfo->read_memory_func;\n+    fprintf_ftype     fprintf_func     = dinfo->fprintf_func;\n+\n+    dinfo->read_memory_func = &read_zero_data_only;\n+    dinfo->fprintf_func     = &print_to_dev_null;\n+    (*dfn)(0, dinfo);\n+\n+    \/* put it back *\/\n+    dinfo->read_memory_func = read_memory_func;\n+    dinfo->fprintf_func     = fprintf_func;\n+  }\n+\n+\n+  static int hsdis_read_memory_func(bfd_vma memaddr,\n+                                    bfd_byte* myaddr,\n+                                    unsigned int length,\n+                                    struct disassemble_info* dinfo) {\n+    hsdis_backend* self = static_cast<hsdis_backend*>(dinfo->application_data);\n+    \/* convert the virtual address memaddr into an address within memory buffer *\/\n+    uintptr_t offset = ((uintptr_t) memaddr) - self->_start_va;\n+    if (offset + length > self->_length) {\n+      \/* read is out of bounds *\/\n+      return EIO;\n+    } else {\n+      memcpy(myaddr, (bfd_byte*) (self->_buffer + offset), length);\n+      return 0;\n+    }\n+  }\n+\n+  static void hsdis_print_address_func(bfd_vma vma,\n+                                       struct disassemble_info* dinfo) {\n+    hsdis_backend* self = static_cast<hsdis_backend*>(dinfo->application_data);\n+    \/* the actual value to print: *\/\n+    void* addr_value = (void*) (uintptr_t) vma;\n+\n+    \/* issue the event: *\/\n+    void* result =\n+      (*self->_event_callback)(self->_event_stream, \"addr\/\", addr_value);\n+    if (result == NULL) {\n+      \/* event declined *\/\n+      generic_print_address(vma, dinfo);\n+    }\n+  }\n+\n+ public:\n+  hsdis_backend(uintptr_t start_va, uintptr_t end_va,\n+                unsigned char* buffer, uintptr_t length,\n+                event_callback_t  event_callback,  void* event_stream,\n+                printf_callback_t printf_callback, void* printf_stream,\n+                const char* options, int newline)\n+    : hsdis_backend_base(start_va, end_va,\n+                         buffer, length,\n+                         event_callback, event_stream,\n+                         printf_callback, printf_stream,\n+                         newline) {\n+    \/* Look into _options for anything interesting. *\/\n+    if (options != NULL)\n+      parse_caller_options(options);\n+\n+    \/* Discover which architecture we are going to disassemble. *\/\n+    _arch_name = &_mach_option[0];\n+    if (_arch_name[0] == '\\0')\n+      _arch_name = native_arch_name();\n+    _arch_info = find_arch_info(_arch_name);\n+\n+    \/* Make a fake bfd to hold the arch. and byteorder info. *\/\n+    struct {\n+      bfd_target empty_xvec;\n+      bfd        empty_bfd;\n+    } buf;\n+    bfd* native_bfd = get_native_bfd(_arch_info,\n+                                    \/* to avoid malloc: *\/\n+                                    &buf.empty_bfd, &buf.empty_xvec);\n+    memset(&_dinfo, 0, sizeof(_dinfo));\n+    init_disassemble_info_from_bfd(&_dinfo,\n+                                  _printf_stream,\n+                                  _printf_callback,\n+                                  native_bfd,\n+                                  \/* On PowerPC we get warnings, if we pass empty options *\/\n+                                  (options == NULL) ? NULL : _insn_options);\n+\n+    \/* Finish linking together the various callback blocks. *\/\n+    _dinfo.application_data = (void*) this;\n+    _dfn = disassembler(bfd_get_arch(native_bfd),\n+                                bfd_big_endian(native_bfd),\n+                                bfd_get_mach(native_bfd),\n+                                native_bfd);\n+    _dinfo.print_address_func = hsdis_print_address_func;\n+    _dinfo.read_memory_func = hsdis_read_memory_func;\n+\n+    if (_dfn == NULL) {\n+      const char* bad = _arch_name;\n+      static bool complained;\n+      if (bad == &_mach_option[0])\n+        print_help(\"bad mach=%s\", bad);\n+      else if (!complained)\n+        print_help(\"bad native mach=%s; please port hsdis to this platform\", bad);\n+      complained = true;\n+      \/* must bail out *\/\n+      _losing = true;\n+      return;\n+    }\n+\n+    parse_fake_insn(_dfn, &_dinfo);\n+  }\n+\n+  ~hsdis_backend() {\n+    \/\/ do nothing\n+  }\n+\n+ protected:\n+  virtual void print_help(const char* msg, const char* arg) {\n+    if (msg != NULL) {\n+      (*_printf_callback)(_printf_stream, \"hsdis: \");\n+      (*_printf_callback)(_printf_stream, msg, arg);\n+      (*_printf_callback)(_printf_stream, \"\\n\");\n+    }\n+    (*_printf_callback)(_printf_stream, \"hsdis output options:\\n\");\n+    if (_printf_callback == (printf_callback_t) &fprintf)\n+      disassembler_usage((FILE*) _printf_stream);\n+    else\n+      disassembler_usage(stderr); \/* better than nothing *\/\n+    (*_printf_callback)(_printf_stream, \"  mach=<arch>   select disassembly mode\\n\");\n+#if defined(LIBARCH_i386) || defined(LIBARCH_amd64)\n+    (*_printf_callback)(_printf_stream, \"  mach=i386     select 32-bit mode\\n\");\n+    (*_printf_callback)(_printf_stream, \"  mach=x86-64   select 64-bit mode\\n\");\n+    (*_printf_callback)(_printf_stream, \"  suffix        always print instruction suffix\\n\");\n+#endif\n+    (*_printf_callback)(_printf_stream, \"  help          print this message\\n\");\n+  }\n+\n+  virtual void print_insns_config() {\n+    (*_event_callback)(_event_stream, \"mach name='%s'\",\n+                      (void*) _arch_info->printable_name);\n+    if (_dinfo.bytes_per_line != 0) {\n+      (*_event_callback)(_event_stream, \"format bytes-per-line='%p'\/\",\n+                        (void*)(intptr_t) _dinfo.bytes_per_line);\n+    }\n+  }\n+\n+  virtual size_t decode_instruction(uintptr_t p, uintptr_t start, uintptr_t end) {\n+    \/* reset certain state, so we can read it with confidence *\/\n+    _dinfo.insn_info_valid    = 0;\n+    _dinfo.branch_delay_insns = 0;\n+    _dinfo.data_size          = 0;\n+    _dinfo.insn_type          = (dis_insn_type)0;\n+\n+    return (*_dfn)((bfd_vma) p, &_dinfo);\n+  }\n+\n+  virtual const char* format_insn_close(const char* close, char* buf, size_t bufsize) {\n+    if (!_dinfo.insn_info_valid)\n+      return close;\n+    enum dis_insn_type itype = _dinfo.insn_type;\n+    int dsize = _dinfo.data_size, delays = _dinfo.branch_delay_insns;\n+    if ((itype == dis_nonbranch && (dsize | delays) == 0)\n+        || (strlen(close) + 3*20 > bufsize))\n+      return close;\n+\n+    const char* type = \"unknown\";\n+    switch (itype) {\n+    case dis_nonbranch:   type = NULL;         break;\n+    case dis_branch:      type = \"branch\";     break;\n+    case dis_condbranch:  type = \"condbranch\"; break;\n+    case dis_jsr:         type = \"jsr\";        break;\n+    case dis_condjsr:     type = \"condjsr\";    break;\n+    case dis_dref:        type = \"dref\";       break;\n+    case dis_dref2:       type = \"dref2\";      break;\n+    case dis_noninsn:     type = \"noninsn\";    break;\n+    }\n+\n+    strcpy(buf, close);\n+    char* p = buf;\n+    if (type)    sprintf(p += strlen(p), \" type='%s'\", type);\n+    if (dsize)   sprintf(p += strlen(p), \" dsize='%d'\", dsize);\n+    if (delays)  sprintf(p += strlen(p), \" delay='%d'\", delays);\n+    return buf;\n+  }\n+};\n+\n+#else\n+\n+class hsdis_backend : public hsdis_backend_base {\n+ private:\n+  LLVMDisasmContextRef      _dcontext = NULL;\n+  char                      _target_triple[128];\n+\n+  void parse_caller_options(const char* options) {\n+    memset(&_target_triple, 0, sizeof(_target_triple));\n+    const char* p;\n+    for (p = options; p != NULL; ) {\n+      const char* q = strchr(p, ',');\n+      size_t plen = (q == NULL) ? strlen(p) : ((q++) - p);\n+      if (plen == 4 && strncmp(p, \"help\", plen) == 0) {\n+        print_help(NULL, NULL);\n+      } else if (plen > 6 && strncmp(p, \"hsdis-\", 6) == 0) {\n+        \/\/ do not pass these to the next level\n+      } else if (plen >= 14 && strncmp(p, \"target_triple=\", 14) == 0) {\n+        char*  target_triple = _target_triple;\n+        size_t target_triple_size   = sizeof(_target_triple);\n+        target_triple_size -= 1;           \/*leave room for the null*\/\n+        if (plen > target_triple_size)  plen = target_triple_size;\n+        strncpy(target_triple, p, plen);\n+        target_triple[plen] = '\\0';\n+      }\n+      p = q;\n+    }\n+  }\n+\n+  const char* native_target_triple() {\n+#if defined(LIBOS_Linux) && defined(LIBARCH_aarch64)\n+    return \"aarch64-pc-linux-gnu\";\n+\n+#elif defined(LIBOS_Linux) && defined(LIBARCH_amd64)\n+    return \"x86_64-pc-linux-gnu\";\n+\n+#elif defined(LIBOS_Darwin) && defined(LIBARCH_aarch64)\n+    return \"aarch64-apple-darwin\";\n+\n+#elif defined(LIBOS_Darwin) && defined(LIBARCH_x86_64)\n+    return \"x86_64-apple-darwin\";\n+\n+#elif defined(LIBOS_Windows) && defined(LIBARCH_aarch64)\n+    return \"aarch64-pc-windows-msvc\";\n+\n+#elif defined(LIBOS_Windows) && defined(LIBARCH_amd64)\n+    return \"x86_64-pc-windows-msvc\";\n+\n+#else\n+    #error \"unknown platform\"\n+#endif\n+  }\n+\n+ public:\n+  hsdis_backend(uintptr_t start_va, uintptr_t end_va,\n+                unsigned char* buffer, uintptr_t length,\n+                event_callback_t  event_callback,  void* event_stream,\n+                printf_callback_t printf_callback, void* printf_stream,\n+                const char* options, int newline)\n+    : hsdis_backend_base(start_va, end_va,\n+                         buffer, length,\n+                         event_callback, event_stream,\n+                         printf_callback, printf_stream,\n+                         newline) {\n+    \/* Look into _options for anything interesting. *\/\n+    if (options != NULL)\n+      parse_caller_options(options);\n+\n+    \/* Discover which architecture we are going to disassemble. *\/\n+    _arch_name = &_target_triple[0];\n+    if (_arch_name[0] == '\\0')\n+      _arch_name = native_target_triple();\n+\n+    if (LLVMInitializeNativeTarget() != 0) {\n+      fprintf(stderr, \"failed to initialize LLVM native target\\n\");\n+    }\n+    if (LLVMInitializeNativeAsmPrinter() != 0) {\n+      fprintf(stderr, \"failed to initialize LLVM native asm printer\\n\");\n+    }\n+    if (LLVMInitializeNativeDisassembler() != 0) {\n+      fprintf(stderr, \"failed to initialize LLVM native disassembler\\n\");\n+    }\n+\n+    if ((_dcontext = LLVMCreateDisasm(_arch_name, NULL, 0, NULL, NULL)) == NULL) {\n+      const char* bad = _arch_name;\n+      static bool complained;\n+      if (bad == &_target_triple[0])\n+        print_help(\"bad target_triple=%s\", bad);\n+      else if (!complained)\n+        print_help(\"bad native target_triple=%s; please port hsdis to this platform\", bad);\n+      complained = true;\n+      \/* must bail out *\/\n+      _losing = true;\n+      return;\n+    }\n+\n+    LLVMSetDisasmOptions(_dcontext, LLVMDisassembler_Option_PrintImmHex | LLVMDisassembler_Option_AsmPrinterVariant);\n+  }\n+\n+  ~hsdis_backend() {\n+    if (_dcontext != NULL) {\n+      LLVMDisasmDispose(_dcontext);\n+    }\n+  }\n+\n+ protected:\n+  virtual void print_help(const char* msg, const char* arg) {\n+    if (msg != NULL) {\n+      (*_printf_callback)(_printf_stream, \"hsdis: \");\n+      (*_printf_callback)(_printf_stream, msg, arg);\n+      (*_printf_callback)(_printf_stream, \"\\n\");\n+    }\n+    (*_printf_callback)(_printf_stream, \"hsdis output options:\\n\");\n+    (*_printf_callback)(_printf_stream, \"  help          print this message\\n\");\n+  }\n+\n+  virtual void print_insns_config() {\n+    (*_event_callback)(_event_stream, \"target_triple name='%s'\",\n+                      (void*) _arch_name);\n+  }\n+\n+  virtual size_t decode_instruction(uintptr_t p, uintptr_t start, uintptr_t end) {\n+    char buf[128];\n+    size_t size = LLVMDisasmInstruction(_dcontext, (uint8_t*)p, (uint64_t)(end - start), (uint64_t)p, buf, sizeof(buf));\n+    if (size > 0) {\n+      _printf_callback(_printf_stream, \"%s\", buf);\n+    }\n+    return size;\n+  }\n+\n+  virtual const char* format_insn_close(const char* close, char* buf, size_t bufsize) {\n+    return close;\n+  }\n+};\n+\n+#endif\n+\n+void* decode_instructions_virtual(uintptr_t start_va, uintptr_t end_va,\n+                            unsigned char* buffer, uintptr_t length,\n+                            event_callback_t  event_callback_arg,  void* event_stream_arg,\n+                            printf_callback_t printf_callback_arg, void* printf_stream_arg,\n+                            const char* options, int newline) {\n+  return hsdis_backend(start_va, end_va,\n+                       buffer, length,\n+                       event_callback_arg, event_stream_arg,\n+                       printf_callback_arg, printf_stream_arg,\n+                       options, newline == 0 ? false : true)\n+          .decode();\n+}\n+\n+\/* This is the compatability interface for older version of hotspot *\/\n+void* decode_instructions(void* start_pv, void* end_pv,\n+                    event_callback_t  event_callback_arg,  void* event_stream_arg,\n+                    printf_callback_t printf_callback_arg, void* printf_stream_arg,\n+                    const char* options) {\n+  return decode_instructions_virtual((uintptr_t)start_pv,\n+                                     (uintptr_t)end_pv,\n+                                     (unsigned char*)start_pv,\n+                                     (uintptr_t)end_pv - (uintptr_t)start_pv,\n+                                     event_callback_arg,\n+                                     event_stream_arg,\n+                                     printf_callback_arg,\n+                                     printf_stream_arg,\n+                                     options, false);\n+}\n","filename":"src\/utils\/hsdis\/hsdis.cpp","additions":694,"deletions":0,"binary":false,"changes":694,"status":"added"},{"patch":"@@ -75,0 +75,5 @@\n+#ifdef __cplusplus\n+extern \"C\"\n+{\n+#endif\n+\n@@ -76,2 +81,2 @@\n-#ifdef DLL_EXPORT\n-  DLL_EXPORT\n+#ifdef _WIN32\n+__declspec(dllexport)\n@@ -90,2 +95,2 @@\n-#ifdef DLL_ENTRY\n-  DLL_ENTRY\n+#ifdef _WIN32\n+__declspec(dllexport)\n@@ -118,0 +123,5 @@\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n","filename":"src\/utils\/hsdis\/hsdis.h","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"}]}