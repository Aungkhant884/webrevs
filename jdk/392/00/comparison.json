{"files":[{"patch":"@@ -0,0 +1,121 @@\n+Copyright (c) 2020 Microsoft Corporation. All rights reserved.\n+DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+This code is free software; you can redistribute it and\/or modify it\n+under the terms of the GNU General Public License version 2 only, as\n+published by the Free Software Foundation.\n+\n+This code is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+version 2 for more details (a copy is included in the LICENSE file that\n+accompanied this code).\n+\n+You should have received a copy of the GNU General Public License version\n+2 along with this work; if not, write to the Free Software Foundation,\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n+\n+________________________________________________________________________\n+\n+'hsdis':  A HotSpot plugin for disassembling dynamically generated code.\n+\n+The files in this directory (Makefile, hsdis.[ch], hsdis-demo.c)\n+are built independently of the HotSpot JVM.\n+\n+To use the plugin with a JVM, you need a new version that can load it.\n+If the product mode of your JVM does not accept -XX:+PrintAssembly,\n+you do not have a version that is new enough.\n+\n+* Building Windows+Arm64\n+\n+1. cross-compile LLVM on Windows-x86_64 for Windows-Arm64\n+\n+```\n+PS> cd llvm-src\n+PS> mkdir build\n+PS> cd build\n+PS> & \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Enterprise\\VC\\Auxiliary\\Build\\vcvarsamd64_arm64.bat\"\n+PS> & 'C:\\Program Files\\CMake\\bin\\cmake.exe' .. -Thost=x64 -G \"Visual Studio 15 2017\" -A arm64 \\\n+  -DCMAKE_INSTALL_PREFIX=\"C:\\LLVM-9-arm64\" -DCMAKE_PREFIX_PATH=\"C:\\LLVM-9-arm64\" \\\n+  -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_LIBXML2=OFF -DLLVM_USE_CRT_RELEASE=MT -DLLVM_TARGETS_TO_BUILD=AArch64 \\\n+  -DLLVM_TABLEGEN=\"C:\\LLVM-9-x86_64\\bin\\llvm-tblgen.exe\" -DCMAKE_SYSTEM_VERSION=\"10.0.16299.0\" -DLLVM_TOOL_LLVM_SHLIB_BUILD=OFF\n+```\n+\n+2. cross-compile hsdis on Windows-x86_64 for Windows-Arm64\n+\n+```\n+PS> & \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Enterprise\\VC\\Auxiliary\\Build\\vcvarsamd64_arm64.bat\"\n+PS> & \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Enterprise\\VC\\Tools\\MSVC\\14.16.27023\\bin\\Hostx64\\arm64\\cl.exe\" \\\n+  -I\"C:\\LLVM-9-arm64\\include\" -I\"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\" \\\n+  -I\"C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Enterprise\\VC\\Tools\\MSVC\\14.16.27023\\include\" -D_CRT_SECURE_NO_DEPRECATE \\\n+  -D_CRT_SECURE_NO_WARNINGS -D_CRT_NONSTDC_NO_DEPRECATE -D_CRT_NONSTDC_NO_WARNINGS -D_SCL_SECURE_NO_DEPRECATE \\\n+  -D_SCL_SECURE_NO_WARNINGS -DUNICODE -D_UNICODE -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS \\\n+  -DLIBARCH_aarch64 C:\\git\\jdk~arm64\\src\\utils\\hsdis-llvm\\hsdis.c \/LD \/link -LIBPATH:\"C:\\LLVM-9-arm64\\lib\" \\\n+  -LIBPATH:\"C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Enterprise\\VC\\Tools\\MSVC\\14.16.27023\\lib\\arm64\" \\\n+  -LIBPATH:\"C:\\Program Files (x86)\\Windows Kits\\10\\Lib\\10.0.17763.0\\ucrt\\arm64\" \\\n+  -LIBPATH:\"C:\\Program Files (x86)\\Windows Kits\\10\\Lib\\10.0.17763.0\\um\\arm64\" \/NODEFAULTLIB:libcmt.lib \\\n+  C:\\LLVM-9-arm64\\lib\\LLVMAArch64Disassembler.lib C:\\LLVM-9-arm64\\lib\\LLVMMCDisassembler.lib \\\n+  C:\\LLVM-9-arm64\\lib\\LLVMAArch64CodeGen.lib C:\\LLVM-9-arm64\\lib\\LLVMGlobalISel.lib C:\\LLVM-9-arm64\\lib\\LLVMSelectionDAG.lib \\\n+  C:\\LLVM-9-arm64\\lib\\LLVMAArch64AsmParser.lib C:\\LLVM-9-arm64\\lib\\LLVMAArch64Desc.lib C:\\LLVM-9-arm64\\lib\\LLVMAArch64Utils.lib \\\n+  C:\\LLVM-9-arm64\\lib\\LLVMAArch64Info.lib C:\\LLVM-9-arm64\\lib\\LLVMAsmPrinter.lib C:\\LLVM-9-arm64\\lib\\LLVMDebugInfoDWARF.lib \\\n+  C:\\LLVM-9-arm64\\lib\\LLVMCodeGen.lib C:\\LLVM-9-arm64\\lib\\LLVMTarget.lib C:\\LLVM-9-arm64\\lib\\LLVMScalarOpts.lib \\\n+  C:\\LLVM-9-arm64\\lib\\LLVMInstCombine.lib C:\\LLVM-9-arm64\\lib\\LLVMAggressiveInstCombine.lib \\\n+  C:\\LLVM-9-arm64\\lib\\LLVMTransformUtils.lib C:\\LLVM-9-arm64\\lib\\LLVMBitWriter.lib C:\\LLVM-9-arm64\\lib\\LLVMAnalysis.lib \\\n+  C:\\LLVM-9-arm64\\lib\\LLVMProfileData.lib C:\\LLVM-9-arm64\\lib\\LLVMObject.lib C:\\LLVM-9-arm64\\lib\\LLVMMCParser.lib \\\n+  C:\\LLVM-9-arm64\\lib\\LLVMMC.lib C:\\LLVM-9-arm64\\lib\\LLVMDebugInfoCodeView.lib C:\\LLVM-9-arm64\\lib\\LLVMDebugInfoMSF.lib \\\n+  C:\\LLVM-9-arm64\\lib\\LLVMBitReader.lib C:\\LLVM-9-arm64\\lib\\LLVMCore.lib C:\\LLVM-9-arm64\\lib\\LLVMRemarks.lib \\\n+  C:\\LLVM-9-arm64\\lib\\LLVMBinaryFormat.lib C:\\LLVM-9-arm64\\lib\\LLVMBitstreamReader.lib C:\\LLVM-9-arm64\\lib\\LLVMSupport.lib \\\n+  C:\\LLVM-9-arm64\\lib\\LLVMDemangle.lib psapi.lib shell32.lib ole32.lib uuid.lib advapi32.lib msvcrt.lib\n+```\n+\n+* Building macOS-Arm64\n+\n+1. configure LLVM like so:\n+\n+```console\n+$ git clone git@github.com:llvm\/llvm-project.git\n+$ cd llvm-project\/llvm\n+$ mkdir build; cd build\n+$ cmake .. -G 'Unix Makefiles' -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_LIBXML2=OFF -DLLVM_TARGETS_TO_BUILD=AArch64\n+```\n+\n+2. change Makefile so that `LLVM_PRE` points to `llvm-project\/llvm` from the previous step\n+\n+3. `make` should build `hsdis-aarch64.dylib`\n+\n+4. `make hsdis-demo && .\/hsdis-demo` should give you a demo of its functionality\n+\n+* Installing\n+\n+Products are named like build\/$OS-$LIBARCH\/hsdis-$LIBARCH.so. You can\n+install them next to your libjvm.so inside your JRE\/JDK or alternatively\n+put it anywhere on your LD_LIBRARY_PATH. The search path in the JVM is:\n+\n+1. <home>\/lib\/<vm>\/libhsdis-<arch>.so\n+2. <home>\/lib\/<vm>\/hsdis-<arch>.so\n+3. <home>\/lib\/hsdis-<arch>.so\n+4. hsdis-<arch>.so  (using LD_LIBRARY_PATH)\n+\n+Now test:\n+\n+  export LD_LIBRARY_PATH ...\/hsdis\/build\/$OS-$LIBARCH:$LD_LIBRARY_PATH\n+  dargs='-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly'\n+  dargs=$dargs' -XX:PrintAssemblyOptions=hsdis-print-bytes'\n+  java $dargs -Xbatch CompileCommand=print,*String.hashCode HelloWorld\n+\n+If the product mode of the JVM does not accept -XX:+PrintAssembly,\n+you do not have a version new enough to use the hsdis plugin.\n+\n+* Wiki\n+\n+More information can be found in the OpenJDK HotSpot Wiki [1].\n+\n+\n+Resources:\n+\n+[1] https:\/\/wiki.openjdk.java.net\/display\/HotSpot\/PrintAssembly\n+[2] http:\/\/sourceware.org\/bugzilla\/show_bug.cgi?id=15345\n","filename":"src\/utils\/hsdis-llvm\/README","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -0,0 +1,307 @@\n+\/*\n+ * Copyright (c) 2020 Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/* hsdis.c -- dump a range of addresses as native instructions\n+   This implements the plugin protocol required by the\n+   HotSpot PrintAssembly option.\n+*\/\n+\n+#include <stdio.h>\n+#include <errno.h>\n+#include <inttypes.h>\n+#include <string.h>\n+\n+#include <llvm-c\/Disassembler.h>\n+#include <llvm-c\/DisassemblerTypes.h>\n+#include <llvm-c\/Target.h>\n+#include <llvm-c\/TargetMachine.h>\n+\n+#include \"hsdis.h\"\n+\n+#ifndef bool\n+#define bool int\n+#define true 1\n+#define false 0\n+#endif \/*bool*\/\n+\n+\/* short names for stuff in hsdis.h *\/\n+typedef decode_instructions_event_callback_ftype  event_callback_t;\n+typedef decode_instructions_printf_callback_ftype printf_callback_t;\n+\n+\/* disassemble_info.application_data object *\/\n+struct hsdis_app_data {\n+  \/* virtual address of data *\/\n+  uintptr_t start_va, end_va;\n+  \/* the instructions to be decoded *\/\n+  unsigned char* buffer;\n+  uintptr_t length;\n+  event_callback_t  event_callback;  void* event_stream;\n+  printf_callback_t printf_callback; void* printf_stream;\n+  bool losing;\n+  bool do_newline;\n+\n+  \/* the architecture being disassembled *\/\n+  const char* arch_name;\n+\n+  \/* the disassembler we are going to use: *\/\n+  LLVMDisasmContextRef dcontext; \/* the actual struct! *\/\n+\n+  char target_triple_option[128];\n+};\n+\n+static void* decode(struct hsdis_app_data* app_data, const char* options);\n+\n+#define DECL_EVENT_CALLBACK(app_data) \\\n+  event_callback_t  event_callback = (app_data)->event_callback; \\\n+  void*             event_stream   = (app_data)->event_stream\n+\n+#define DECL_PRINTF_CALLBACK(app_data) \\\n+  printf_callback_t  printf_callback = (app_data)->printf_callback; \\\n+  void*              printf_stream   = (app_data)->printf_stream\n+\n+\n+static void print_help(struct hsdis_app_data* app_data,\n+                       const char* msg, const char* arg);\n+static void setup_app_data(struct hsdis_app_data* app_data,\n+                           const char* options);\n+\n+void* decode_instructions_virtual(uintptr_t start_va, uintptr_t end_va,\n+                            unsigned char* buffer, uintptr_t length,\n+                            event_callback_t  event_callback_arg,  void* event_stream_arg,\n+                            printf_callback_t printf_callback_arg, void* printf_stream_arg,\n+                            const char* options, int newline) {\n+  struct hsdis_app_data app_data;\n+  memset(&app_data, 0, sizeof(app_data));\n+  app_data.start_va    = start_va;\n+  app_data.end_va      = end_va;\n+  app_data.buffer = buffer;\n+  app_data.length = length;\n+  app_data.event_callback  = event_callback_arg;\n+  app_data.event_stream    = event_stream_arg;\n+  app_data.printf_callback = printf_callback_arg;\n+  app_data.printf_stream   = printf_stream_arg;\n+  app_data.do_newline = newline == 0 ? false : true;\n+\n+  return decode(&app_data, options);\n+}\n+\n+\/* This is the compatability interface for older version of hotspot *\/\n+void* decode_instructions(void* start_pv, void* end_pv,\n+                    event_callback_t  event_callback_arg,  void* event_stream_arg,\n+                    printf_callback_t printf_callback_arg, void* printf_stream_arg,\n+                    const char* options) {\n+  return decode_instructions_virtual((uintptr_t)start_pv,\n+                                     (uintptr_t)end_pv,\n+                                     (unsigned char*)start_pv,\n+                                     (uintptr_t)end_pv - (uintptr_t)start_pv,\n+                                     event_callback_arg,\n+                                     event_stream_arg,\n+                                     printf_callback_arg,\n+                                     printf_stream_arg,\n+                                     options, false);\n+}\n+\n+static void* decode(struct hsdis_app_data* app_data, const char* options) {\n+  setup_app_data(app_data, options);\n+  char buf[128];\n+\n+  {\n+    \/* now reload everything from app_data: *\/\n+    DECL_EVENT_CALLBACK(app_data);\n+    DECL_PRINTF_CALLBACK(app_data);\n+    uintptr_t start = app_data->start_va;\n+    uintptr_t end   = app_data->end_va;\n+    uintptr_t p     = start;\n+\n+    (*event_callback)(event_stream, \"insns\", (void*)start);\n+\n+    (*event_callback)(event_stream, \"target_triple name='%s'\",\n+                      (void*) app_data->arch_name);\n+\n+    while (p < end && !app_data->losing) {\n+      (*event_callback)(event_stream, \"insn\", (void*) p);\n+\n+      size_t size = LLVMDisasmInstruction(app_data->dcontext, (uint8_t*)p, (uint64_t)(end - start), (uint64_t)p, buf, sizeof(buf));\n+\n+      if (size > 0)  { app_data->printf_callback(app_data->printf_stream, \"%s\", buf); p += size; }\n+      else           app_data->losing = true;\n+\n+      if (!app_data->losing) {\n+        (*event_callback)(event_stream, \"\/insn\", (void*) p);\n+\n+        if (app_data->do_newline) {\n+          \/* follow each complete insn by a nice newline *\/\n+          (*printf_callback)(printf_stream, \"\\n\");\n+        }\n+      }\n+    }\n+\n+    if (app_data->losing) (*event_callback)(event_stream, \"\/insns\", (void*) p);\n+    LLVMDisasmDispose(app_data->dcontext);\n+    return (void*) p;\n+  }\n+}\n+\n+\/* configuration *\/\n+\n+static void set_optional_callbacks(struct hsdis_app_data* app_data);\n+static void parse_caller_options(struct hsdis_app_data* app_data,\n+                                 const char* caller_options);\n+static const char* native_target_triple();\n+\n+static void setup_app_data(struct hsdis_app_data* app_data,\n+                           const char* caller_options) {\n+  \/* Make reasonable defaults for null callbacks.\n+     A non-null stream for a null callback is assumed to be a FILE* for output.\n+     Events are rendered as XML.\n+  *\/\n+  set_optional_callbacks(app_data);\n+\n+  \/* Look into caller_options for anything interesting. *\/\n+  if (caller_options != NULL)\n+    parse_caller_options(app_data, caller_options);\n+\n+  \/* Discover which architecture we are going to disassemble. *\/\n+  app_data->arch_name = &app_data->target_triple_option[0];\n+  if (app_data->arch_name[0] == '\\0')\n+    app_data->arch_name = native_target_triple();\n+\n+  if (LLVMInitializeNativeTarget() != 0) {\n+    fprintf(stderr, \"failed to initialize LLVM native target\\n\");\n+  }\n+  if (LLVMInitializeNativeAsmPrinter() != 0) {\n+    fprintf(stderr, \"failed to initialize LLVM native asm printer\\n\");\n+  }\n+  if (LLVMInitializeNativeDisassembler() != 0) {\n+    fprintf(stderr, \"failed to initialize LLVM native disassembler\\n\");\n+  }\n+\n+  if ((app_data->dcontext = LLVMCreateDisasm(app_data->arch_name, NULL, 0, NULL, NULL)) == NULL) {\n+    const char* bad = app_data->arch_name;\n+    static bool complained;\n+    if (bad == &app_data->target_triple_option[0])\n+      print_help(app_data, \"bad target_triple=%s\", bad);\n+    else if (!complained)\n+      print_help(app_data, \"bad native target_triple=%s; please port hsdis to this platform\", bad);\n+    complained = true;\n+    \/* must bail out *\/\n+    app_data->losing = true;\n+    return;\n+  }\n+\n+  LLVMSetDisasmOptions(app_data->dcontext, LLVMDisassembler_Option_PrintImmHex | LLVMDisassembler_Option_AsmPrinterVariant);\n+}\n+\n+\n+\/* ignore all events, return a null *\/\n+static void* null_event_callback(void* ignore_stream, const char* ignore_event, void* arg) {\n+  return NULL;\n+}\n+\n+\/* print all events as XML markup *\/\n+static void* xml_event_callback(void* stream, const char* event, void* arg) {\n+  FILE* fp = (FILE*) stream;\n+#define NS_PFX \"dis:\"\n+  if (event[0] != '\/') {\n+    \/* issue the tag, with or without a formatted argument *\/\n+    fprintf(fp, \"<\"NS_PFX);\n+    fprintf(fp, event, arg);\n+    fprintf(fp, \">\");\n+  } else {\n+    ++event;                    \/* skip slash *\/\n+    const char* argp = strchr(event, ' ');\n+    if (argp == NULL) {\n+      \/* no arguments; just issue the closing tag *\/\n+      fprintf(fp, \"<\/\"NS_PFX\"%s>\", event);\n+    } else {\n+      \/* split out the closing attributes as <dis:foo_done attr='val'\/> *\/\n+      int event_prefix = (argp - event);\n+      fprintf(fp, \"<\"NS_PFX\"%.*s_done\", event_prefix, event);\n+      fprintf(fp, argp, arg);\n+      fprintf(fp, \"\/><\/\"NS_PFX\"%.*s>\", event_prefix, event);\n+    }\n+  }\n+  return NULL;\n+}\n+\n+static void set_optional_callbacks(struct hsdis_app_data* app_data) {\n+  if (app_data->printf_callback == NULL) {\n+    int (*fprintf_callback)(FILE*, const char*, ...) = &fprintf;\n+    FILE* fprintf_stream = stdout;\n+    app_data->printf_callback = (printf_callback_t) fprintf_callback;\n+    if (app_data->printf_stream == NULL)\n+      app_data->printf_stream   = (void*)           fprintf_stream;\n+  }\n+  if (app_data->event_callback == NULL) {\n+    if (app_data->event_stream == NULL)\n+      app_data->event_callback = &null_event_callback;\n+    else\n+      app_data->event_callback = &xml_event_callback;\n+  }\n+\n+}\n+\n+static void parse_caller_options(struct hsdis_app_data* app_data, const char* caller_options) {\n+  const char* p;\n+  for (p = caller_options; p != NULL; ) {\n+    const char* q = strchr(p, ',');\n+    size_t plen = (q == NULL) ? strlen(p) : ((q++) - p);\n+    if (plen == 4 && strncmp(p, \"help\", plen) == 0) {\n+      print_help(app_data, NULL, NULL);\n+    } else if (plen >= 14 && strncmp(p, \"target_triple=\", 14) == 0) {\n+      char*  target_triple_option = app_data->target_triple_option;\n+      size_t mach_size   = sizeof(app_data->target_triple_option);\n+      mach_size -= 1;           \/*leave room for the null*\/\n+      if (plen > mach_size)  plen = mach_size;\n+      strncpy(target_triple_option, p, plen);\n+      target_triple_option[plen] = '\\0';\n+    } else if (plen > 6 && strncmp(p, \"hsdis-\", 6) == 0) {\n+      \/\/ do not pass these to the next level\n+    }\n+    p = q;\n+  }\n+}\n+\n+static void print_help(struct hsdis_app_data* app_data,\n+                       const char* msg, const char* arg) {\n+  DECL_PRINTF_CALLBACK(app_data);\n+  if (msg != NULL) {\n+    (*printf_callback)(printf_stream, \"hsdis: \");\n+    (*printf_callback)(printf_stream, msg, arg);\n+    (*printf_callback)(printf_stream, \"\\n\");\n+  }\n+  (*printf_callback)(printf_stream, \"hsdis output options:\\n\");\n+  (*printf_callback)(printf_stream, \"  target_triple=<target> select disassembly target triple\\n\");\n+  (*printf_callback)(printf_stream, \"  help          print this message\\n\");\n+}\n+\n+static const char* native_target_triple() {\n+#if defined(__APPLE__) && defined(__aarch64__)\n+  return \"aarch64-apple-darwin\";\n+#elif defined(_WIN32) && defined(_M_ARM64)\n+  return \"aarch64-pc-windows-msvc\";\n+#else\n+#error \"unknown platform\"\n+#endif\n+}\n","filename":"src\/utils\/hsdis-llvm\/hsdis.c","additions":307,"deletions":0,"binary":false,"changes":307,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2020 Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/* decode_instructions -- dump a range of addresses as native instructions\n+   This implements the protocol required by the HotSpot PrintAssembly option.\n+\n+   The start_va, end_va is the virtual address the region of memory to\n+   disasemble and buffer contains the instructions to decode,\n+   Disassembling instructions in the current address space is done by\n+   having start_va == buffer.\n+\n+   The option string, if not empty, is interpreted by the disassembler implementation.\n+\n+   The printf callback is 'fprintf' or any other workalike.\n+   It is called as (*printf_callback)(printf_stream, \"some format...\", some, format, args).\n+\n+   The event callback receives an event tag (a string) and an argument (a void*).\n+   It is called as (*event_callback)(event_stream, \"tag\", arg).\n+\n+   Events:\n+     <insn pc='%p'>             begin an instruction, at a given location\n+     <\/insn pc='%d'>            end an instruction, at a given location\n+     <addr value='%p'\/>         emit the symbolic value of an address\n+\n+   A tag format is one of three basic forms: \"tag\", \"\/tag\", \"tag\/\",\n+   where tag is a simple identifier, signifying (as in XML) a element start,\n+   element end, and standalone element.  (To render as XML, add angle brackets.)\n+*\/\n+#ifndef SHARED_TOOLS_HSDIS_H\n+#define SHARED_TOOLS_HSDIS_H\n+\n+#ifdef __cplusplus\n+extern \"C\"\n+{\n+#endif\n+\n+extern\n+#ifdef _WIN32\n+__declspec(dllexport)\n+#endif\n+void* decode_instructions_virtual(uintptr_t start_va, uintptr_t end_va,\n+                                  unsigned char* buffer, uintptr_t length,\n+                                  void* (*event_callback)(void*, const char*, void*),\n+                                  void* event_stream,\n+                                  int (*printf_callback)(void*, const char*, ...),\n+                                  void* printf_stream,\n+                                  const char* options,\n+                                  int newline \/* bool value for nice new line *\/);\n+\n+\/* This is the compatability interface for older versions of hotspot *\/\n+extern\n+#ifdef _WIN32\n+__declspec(dllexport)\n+#endif\n+void* decode_instructions(void* start_pv, void* end_pv,\n+                    void* (*event_callback)(void*, const char*, void*),\n+                    void* event_stream,\n+                    int   (*printf_callback)(void*, const char*, ...),\n+                    void* printf_stream,\n+                    const char* options);\n+\n+\/* convenience typedefs *\/\n+\n+typedef void* (*decode_instructions_event_callback_ftype)  (void*, const char*, void*);\n+typedef int   (*decode_instructions_printf_callback_ftype) (void*, const char*, ...);\n+typedef void* (*decode_func_vtype) (uintptr_t start_va, uintptr_t end_va,\n+                                    unsigned char* buffer, uintptr_t length,\n+                                    decode_instructions_event_callback_ftype event_callback,\n+                                    void* event_stream,\n+                                    decode_instructions_printf_callback_ftype printf_callback,\n+                                    void* printf_stream,\n+                                    const char* options,\n+                                    int newline);\n+typedef void* (*decode_func_stype) (void* start_pv, void* end_pv,\n+                                    decode_instructions_event_callback_ftype event_callback,\n+                                    void* event_stream,\n+                                    decode_instructions_printf_callback_ftype printf_callback,\n+                                    void* printf_stream,\n+                                    const char* options);\n+\n+#endif \/* SHARED_TOOLS_HSDIS_H *\/\n+\n+#ifdef __cplusplus\n+}\n+#endif\n","filename":"src\/utils\/hsdis-llvm\/hsdis.h","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"}]}