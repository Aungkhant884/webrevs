{"files":[{"patch":"@@ -414,7 +414,2 @@\n-\/\/ Assumes that only the base or the end changes.  This allows indentification\n-\/\/ of the region that is being resized.  The\n-\/\/ CardTable::resize_covered_region() is used for the normal case\n-\/\/ where the covered regions are growing or shrinking at the high end.\n-\/\/ The method resize_covered_region_by_end() is analogous to\n-\/\/ CardTable::resize_covered_region() but\n-\/\/ for regions that grow or shrink at the low end.\n+\/\/ Assumes that only the end changes (the bottom\/start stays the same). This\n+\/\/ allows identification of the region that is being resized.\n@@ -435,13 +430,0 @@\n-  int changed_region = -1;\n-  for (int j = 0; j < _cur_covered_regions; j++) {\n-    if (_covered[j].end() == new_region.end()) {\n-      changed_region = j;\n-      \/\/ This is a case where the covered region is growing or shrinking\n-      \/\/ at the start of the region.\n-      assert(changed_region != -1, \"Don't expect to add a covered region\");\n-      assert(_covered[changed_region].byte_size() != new_region.byte_size(),\n-        \"The sizes should be different here\");\n-      resize_covered_region_by_end(changed_region, new_region);\n-      return;\n-    }\n-  }\n@@ -449,1 +431,1 @@\n-  \/\/ covered region matches at the start or the end).\n+  \/\/ covered region matches at the start).\n@@ -460,232 +442,0 @@\n-void PSCardTable::resize_covered_region_by_end(int changed_region,\n-                                               MemRegion new_region) {\n-  assert(SafepointSynchronize::is_at_safepoint(),\n-    \"Only expect an expansion at the low end at a GC\");\n-  debug_only(verify_guard();)\n-#ifdef ASSERT\n-  for (int k = 0; k < _cur_covered_regions; k++) {\n-    if (_covered[k].end() == new_region.end()) {\n-      assert(changed_region == k, \"Changed region is incorrect\");\n-      break;\n-    }\n-  }\n-#endif\n-\n-  \/\/ Commit new or uncommit old pages, if necessary.\n-  if (resize_commit_uncommit(changed_region, new_region)) {\n-    \/\/ Set the new start of the committed region\n-    resize_update_committed_table(changed_region, new_region);\n-  }\n-\n-  \/\/ Update card table entries\n-  resize_update_card_table_entries(changed_region, new_region);\n-\n-  \/\/ Update the covered region\n-  resize_update_covered_table(changed_region, new_region);\n-\n-  int ind = changed_region;\n-  log_trace(gc, barrier)(\"CardTable::resize_covered_region: \");\n-  log_trace(gc, barrier)(\"    _covered[%d].start(): \" INTPTR_FORMAT \"  _covered[%d].last(): \" INTPTR_FORMAT,\n-                ind, p2i(_covered[ind].start()), ind, p2i(_covered[ind].last()));\n-  log_trace(gc, barrier)(\"    _committed[%d].start(): \" INTPTR_FORMAT \"  _committed[%d].last(): \" INTPTR_FORMAT,\n-                ind, p2i(_committed[ind].start()), ind, p2i(_committed[ind].last()));\n-  log_trace(gc, barrier)(\"    byte_for(start): \" INTPTR_FORMAT \"  byte_for(last): \" INTPTR_FORMAT,\n-                p2i(byte_for(_covered[ind].start())),  p2i(byte_for(_covered[ind].last())));\n-  log_trace(gc, barrier)(\"    addr_for(start): \" INTPTR_FORMAT \"  addr_for(last): \" INTPTR_FORMAT,\n-                p2i(addr_for((CardValue*) _committed[ind].start())), p2i(addr_for((CardValue*) _committed[ind].last())));\n-\n-  debug_only(verify_guard();)\n-}\n-\n-bool PSCardTable::resize_commit_uncommit(int changed_region,\n-                                         MemRegion new_region) {\n-  bool result = false;\n-  \/\/ Commit new or uncommit old pages, if necessary.\n-  MemRegion cur_committed = _committed[changed_region];\n-  assert(_covered[changed_region].end() == new_region.end(),\n-    \"The ends of the regions are expected to match\");\n-  \/\/ Extend the start of this _committed region to\n-  \/\/ to cover the start of any previous _committed region.\n-  \/\/ This forms overlapping regions, but never interior regions.\n-  HeapWord* min_prev_start = lowest_prev_committed_start(changed_region);\n-  if (min_prev_start < cur_committed.start()) {\n-    \/\/ Only really need to set start of \"cur_committed\" to\n-    \/\/ the new start (min_prev_start) but assertion checking code\n-    \/\/ below use cur_committed.end() so make it correct.\n-    MemRegion new_committed =\n-        MemRegion(min_prev_start, cur_committed.end());\n-    cur_committed = new_committed;\n-  }\n-#ifdef ASSERT\n-  ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();\n-  assert(cur_committed.start() == align_up(cur_committed.start(), os::vm_page_size()),\n-         \"Starts should have proper alignment\");\n-#endif\n-\n-  CardValue* new_start = byte_for(new_region.start());\n-  \/\/ Round down because this is for the start address\n-  HeapWord* new_start_aligned = align_down((HeapWord*)new_start, os::vm_page_size());\n-  \/\/ The guard page is always committed and should not be committed over.\n-  \/\/ This method is used in cases where the generation is growing toward\n-  \/\/ lower addresses but the guard region is still at the end of the\n-  \/\/ card table.  That still makes sense when looking for writes\n-  \/\/ off the end of the card table.\n-  if (new_start_aligned < cur_committed.start()) {\n-    \/\/ Expand the committed region\n-    \/\/\n-    \/\/ Case A\n-    \/\/                                          |+ guard +|\n-    \/\/                          |+ cur committed +++++++++|\n-    \/\/                  |+ new committed +++++++++++++++++|\n-    \/\/\n-    \/\/ Case B\n-    \/\/                                          |+ guard +|\n-    \/\/                        |+ cur committed +|\n-    \/\/                  |+ new committed +++++++|\n-    \/\/\n-    \/\/ These are not expected because the calculation of the\n-    \/\/ cur committed region and the new committed region\n-    \/\/ share the same end for the covered region.\n-    \/\/ Case C\n-    \/\/                                          |+ guard +|\n-    \/\/                        |+ cur committed +|\n-    \/\/                  |+ new committed +++++++++++++++++|\n-    \/\/ Case D\n-    \/\/                                          |+ guard +|\n-    \/\/                        |+ cur committed +++++++++++|\n-    \/\/                  |+ new committed +++++++|\n-\n-    HeapWord* new_end_for_commit =\n-      MIN2(cur_committed.end(), _guard_region.start());\n-    if(new_start_aligned < new_end_for_commit) {\n-      MemRegion new_committed =\n-        MemRegion(new_start_aligned, new_end_for_commit);\n-      os::commit_memory_or_exit((char*)new_committed.start(),\n-                                new_committed.byte_size(), !ExecMem,\n-                                \"card table expansion\");\n-    }\n-    result = true;\n-  } else if (new_start_aligned > cur_committed.start()) {\n-    \/\/ Shrink the committed region\n-#if 0 \/\/ uncommitting space is currently unsafe because of the interactions\n-      \/\/ of growing and shrinking regions.  One region A can uncommit space\n-      \/\/ that it owns but which is being used by another region B (maybe).\n-      \/\/ Region B has not committed the space because it was already\n-      \/\/ committed by region A.\n-    MemRegion uncommit_region = committed_unique_to_self(changed_region,\n-      MemRegion(cur_committed.start(), new_start_aligned));\n-    if (!uncommit_region.is_empty()) {\n-      if (!os::uncommit_memory((char*)uncommit_region.start(),\n-                               uncommit_region.byte_size())) {\n-        \/\/ If the uncommit fails, ignore it.  Let the\n-        \/\/ committed table resizing go even though the committed\n-        \/\/ table will over state the committed space.\n-      }\n-    }\n-#else\n-    assert(!result, \"Should be false with current workaround\");\n-#endif\n-  }\n-  assert(_committed[changed_region].end() == cur_committed.end(),\n-    \"end should not change\");\n-  return result;\n-}\n-\n-void PSCardTable::resize_update_committed_table(int changed_region,\n-                                                MemRegion new_region) {\n-\n-  CardValue* new_start = byte_for(new_region.start());\n-  \/\/ Set the new start of the committed region\n-  HeapWord* new_start_aligned = align_down((HeapWord*)new_start, os::vm_page_size());\n-  MemRegion new_committed = MemRegion(new_start_aligned,\n-                                      _committed[changed_region].end());\n-  _committed[changed_region] = new_committed;\n-  _committed[changed_region].set_start(new_start_aligned);\n-}\n-\n-void PSCardTable::resize_update_card_table_entries(int changed_region,\n-                                                   MemRegion new_region) {\n-  debug_only(verify_guard();)\n-  MemRegion original_covered = _covered[changed_region];\n-  \/\/ Initialize the card entries.  Only consider the\n-  \/\/ region covered by the card table (_whole_heap)\n-  CardValue* entry;\n-  if (new_region.start() < _whole_heap.start()) {\n-    entry = byte_for(_whole_heap.start());\n-  } else {\n-    entry = byte_for(new_region.start());\n-  }\n-  CardValue* end = byte_for(original_covered.start());\n-  \/\/ If _whole_heap starts at the original covered regions start,\n-  \/\/ this loop will not execute.\n-  while (entry < end) { *entry++ = clean_card; }\n-}\n-\n-void PSCardTable::resize_update_covered_table(int changed_region,\n-                                              MemRegion new_region) {\n-  \/\/ Update the covered region\n-  _covered[changed_region].set_start(new_region.start());\n-  _covered[changed_region].set_word_size(new_region.word_size());\n-\n-  \/\/ reorder regions.  There should only be at most 1 out\n-  \/\/ of order.\n-  for (int i = _cur_covered_regions-1 ; i > 0; i--) {\n-    if (_covered[i].start() < _covered[i-1].start()) {\n-        MemRegion covered_mr = _covered[i-1];\n-        _covered[i-1] = _covered[i];\n-        _covered[i] = covered_mr;\n-        MemRegion committed_mr = _committed[i-1];\n-      _committed[i-1] = _committed[i];\n-      _committed[i] = committed_mr;\n-      break;\n-    }\n-  }\n-#ifdef ASSERT\n-  for (int m = 0; m < _cur_covered_regions-1; m++) {\n-    assert(_covered[m].start() <= _covered[m+1].start(),\n-      \"Covered regions out of order\");\n-    assert(_committed[m].start() <= _committed[m+1].start(),\n-      \"Committed regions out of order\");\n-  }\n-#endif\n-}\n-\n-\/\/ Returns the start of any committed region that is lower than\n-\/\/ the target committed region (index ind) and that intersects the\n-\/\/ target region.  If none, return start of target region.\n-\/\/\n-\/\/      -------------\n-\/\/      |           |\n-\/\/      -------------\n-\/\/              ------------\n-\/\/              | target   |\n-\/\/              ------------\n-\/\/                               -------------\n-\/\/                               |           |\n-\/\/                               -------------\n-\/\/      ^ returns this\n-\/\/\n-\/\/      -------------\n-\/\/      |           |\n-\/\/      -------------\n-\/\/                      ------------\n-\/\/                      | target   |\n-\/\/                      ------------\n-\/\/                               -------------\n-\/\/                               |           |\n-\/\/                               -------------\n-\/\/                      ^ returns this\n-\n-HeapWord* PSCardTable::lowest_prev_committed_start(int ind) const {\n-  assert(_cur_covered_regions >= 0, \"Expecting at least on region\");\n-  HeapWord* min_start = _committed[ind].start();\n-  for (int j = 0; j < ind; j++) {\n-    HeapWord* this_start = _committed[j].start();\n-    if ((this_start < min_start) &&\n-        !(_committed[j].intersection(_committed[ind])).is_empty()) {\n-       min_start = this_start;\n-    }\n-  }\n-  return min_start;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.cpp","additions":3,"deletions":253,"binary":false,"changes":256,"status":"modified"},{"patch":"@@ -37,8 +37,0 @@\n-  \/\/ Support methods for resizing the card table.\n-  \/\/ resize_commit_uncommit() returns true if the pages were committed or\n-  \/\/ uncommitted\n-  bool resize_commit_uncommit(int changed_region, MemRegion new_region);\n-  void resize_update_card_table_entries(int changed_region,\n-                                        MemRegion new_region);\n-  void resize_update_committed_table(int changed_region, MemRegion new_region);\n-  void resize_update_covered_table(int changed_region, MemRegion new_region);\n@@ -93,6 +85,0 @@\n-  \/\/ Finds the covered region to resize based on the end address\n-  \/\/ of the covered regions.\n-  void resize_covered_region_by_end(int changed_region, MemRegion new_region);\n-  \/\/ Finds the lowest start address of a covered region that is\n-  \/\/ previous (i.e., lower index) to the covered region with index \"ind\".\n-  HeapWord* lowest_prev_committed_start(int ind) const;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.hpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"}]}