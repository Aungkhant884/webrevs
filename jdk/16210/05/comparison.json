{"files":[{"patch":"@@ -1573,1 +1573,1 @@\n-                (site.tsym != sym.owner && !sym.isInheritedIn(site.tsym, types)) ||\n+                (currentResolutionContext.lookupHelper.isInheritedIn(site, sym)) ||\n@@ -3463,0 +3463,4 @@\n+\n+        boolean isInheritedIn(Type site, Symbol sym) {\n+            return site.tsym != sym.owner && !sym.isInheritedIn(site.tsym, types);\n+        }\n@@ -3608,0 +3612,7 @@\n+\n+        @Override\n+        boolean isInheritedIn(Type site, Symbol sym) {\n+            return (types.skipTypeVars(originalSite, true) == site) ?\n+                originalSite.tsym != sym.owner && !sym.isInheritedIn(originalSite.tsym, types) :\n+                site.tsym != sym.owner && !sym.isInheritedIn(site.tsym, types);\n+        }\n@@ -3723,0 +3734,1 @@\n+            currentResolutionContext.lookupHelper = lookupHelper;\n@@ -5003,0 +5015,2 @@\n+        LookupHelper lookupHelper;\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8318160\n+ * @summary javac does not reject private method reference with type-variable receiver\n+ * @compile\/fail\/ref=PrivateMethodReferenceWithTypeVarTest.out -XDrawDiagnostics PrivateMethodReferenceWithTypeVarTest.java\n+ *\/\n+\n+import java.util.function.*;\n+\n+class PrivateMethodReferenceWithTypeVarTest {\n+    class Foo<X> {\n+        X get() { return null; }\n+    }\n+\n+    private String asString() {\n+        return \"bar\";\n+    }\n+\n+    private String asString2(Object o) {\n+        return \"bar\";\n+    }\n+\n+    static <T extends PrivateMethodReferenceWithTypeVarTest> Function<T, String> m1() {\n+        return T::asString;\n+    }\n+\n+    static <T extends PrivateMethodReferenceWithTypeVarTest> Function<T, String> m2(T t) {\n+        return t::asString2;\n+    }\n+\n+    static Function<?, String> m2(Foo<? extends PrivateMethodReferenceWithTypeVarTest> foo) {\n+        return foo.get()::asString2;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lambda\/methodReference\/PrivateMethodReferenceWithTypeVarTest.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+PrivateMethodReferenceWithTypeVarTest.java:24:16: compiler.err.invalid.mref: kindname.method, (compiler.misc.cant.resolve.location.args: kindname.method, asString, , T, (compiler.misc.location: kindname.type.variable.bound, T, null))\n+PrivateMethodReferenceWithTypeVarTest.java:28:16: compiler.err.invalid.mref: kindname.method, (compiler.misc.cant.resolve.location.args: kindname.method, asString2, , T, (compiler.misc.location: kindname.type.variable.bound, T, null))\n+PrivateMethodReferenceWithTypeVarTest.java:32:16: compiler.err.invalid.mref: kindname.method, (compiler.misc.cant.resolve.location.args: kindname.method, asString2, , java.lang.Object, (compiler.misc.location: kindname.type.variable.bound, compiler.misc.type.captureof: 1, ? extends PrivateMethodReferenceWithTypeVarTest, null))\n+3 errors\n","filename":"test\/langtools\/tools\/javac\/lambda\/methodReference\/PrivateMethodReferenceWithTypeVarTest.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"}]}