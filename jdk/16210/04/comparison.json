{"files":[{"patch":"@@ -183,1 +183,8 @@\n-        while (site.hasTag(TYPEVAR)) {\n+        return skipTypeVars(site, capture, false);\n+    }\n+\n+    \/* same as above but with an additional parameter to specify if only captured type variables should be\n+     * skipped\n+     *\/\n+    public Type skipTypeVars(Type site, boolean capture, boolean capturedOnly) {\n+        while (!capturedOnly ? site.hasTag(TYPEVAR) : site.hasTag(TYPEVAR) && ((TypeVar)site).isCaptured()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3555,1 +3555,1 @@\n-            super(referenceTree, name, types.skipTypeVars(site, true), argtypes, typeargtypes, maxPhase);\n+            super(referenceTree, name, types.skipTypeVars(site, true, true), argtypes, typeargtypes, maxPhase);\n@@ -3624,1 +3624,1 @@\n-                this.site = types.skipTypeVars(asSuperSite, true);\n+                this.site = types.skipTypeVars(asSuperSite, true, true);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8318160\n+ * @summary javac does not reject private method reference with type-variable receiver\n+ * @compile\/fail\/ref=PrivateMethodReferenceWithTypeVarTest.out -XDrawDiagnostics PrivateMethodReferenceWithTypeVarTest.java\n+ *\/\n+\n+import java.util.function.*;\n+\n+class PrivateMethodReferenceWithTypeVarTest {\n+    private String asString() {\n+        return \"bar\";\n+    }\n+\n+    private String asString2(Object o) {\n+        return \"bar\";\n+    }\n+\n+    static <T extends PrivateMethodReferenceWithTypeVarTest> Function<T, String> m1() {\n+        return T::asString;\n+    }\n+\n+    static <T extends PrivateMethodReferenceWithTypeVarTest> Function<T, String> m2(T t) {\n+        return t::asString2;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lambda\/methodReference\/PrivateMethodReferenceWithTypeVarTest.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+PrivateMethodReferenceWithTypeVarTest.java:20:16: compiler.err.invalid.mref: kindname.method, (compiler.misc.cant.resolve.location.args: kindname.method, asString, , T, (compiler.misc.location: kindname.type.variable.bound, T, null))\n+PrivateMethodReferenceWithTypeVarTest.java:24:16: compiler.err.invalid.mref: kindname.method, (compiler.misc.cant.resolve.location.args: kindname.method, asString2, , T, (compiler.misc.location: kindname.type.variable.bound, T, null))\n+2 errors\n","filename":"test\/langtools\/tools\/javac\/lambda\/methodReference\/PrivateMethodReferenceWithTypeVarTest.out","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"}]}