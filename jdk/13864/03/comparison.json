{"files":[{"patch":"@@ -1799,1 +1799,1 @@\n-      if (PhaseIdealLoop::find_predicate(r->in(i)) != nullptr) {\n+      if (PhaseIdealLoop::find_parse_predicate(r->in(i)) != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,0 +61,4 @@\n+\/\/ The success projection of a Parse Predicate is always an IfTrueNode and the uncommon projection an IfFalseNode\n+typedef IfTrueNode ParsePredicateSuccessProj;\n+typedef IfFalseNode ParsePredicateUncommonProj;\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -390,1 +390,1 @@\n-    remove_skeleton_predicate_opaq(dead);\n+    remove_template_assertion_predicate_opaq(dead);\n@@ -438,2 +438,2 @@\n-  remove_useless_nodes(_predicate_opaqs,    useful); \/\/ remove useless predicate opaque nodes\n-  remove_useless_nodes(_skeleton_predicate_opaqs, useful);\n+  remove_useless_nodes(_parse_predicate_opaqs, useful); \/\/ remove useless Parse Predicate opaque nodes\n+  remove_useless_nodes(_template_assertion_predicate_opaqs, useful); \/\/ remove useless Assertion Predicate opaque nodes\n@@ -619,2 +619,2 @@\n-                  _predicate_opaqs   (comp_arena(), 8, 0, nullptr),\n-                  _skeleton_predicate_opaqs (comp_arena(), 8, 0, nullptr),\n+                  _parse_predicate_opaqs (comp_arena(), 8, 0, nullptr),\n+                  _template_assertion_predicate_opaqs (comp_arena(), 8, 0, nullptr),\n@@ -1796,7 +1796,8 @@\n-\/\/---------------------cleanup_loop_predicates-----------------------\n-\/\/ Remove the opaque nodes that protect the predicates so that all unused\n-\/\/ checks and uncommon_traps will be eliminated from the ideal graph\n-void Compile::cleanup_loop_predicates(PhaseIterGVN &igvn) {\n-  if (predicate_count()==0) return;\n-  for (int i = predicate_count(); i > 0; i--) {\n-    Node * n = predicate_opaque1_node(i-1);\n+\/\/ Remove the opaque nodes that protect the Parse Predicates so that all unused\n+\/\/ checks and uncommon_traps will be eliminated from the ideal graph.\n+void Compile::cleanup_parse_predicates(PhaseIterGVN& igvn) const {\n+  if (parse_predicate_count() == 0) {\n+    return;\n+  }\n+  for (int i = parse_predicate_count(); i > 0; i--) {\n+    Node* n = parse_predicate_opaque1_node(i - 1);\n@@ -1806,1 +1807,1 @@\n-  assert(predicate_count()==0, \"should be clean!\");\n+  assert(parse_predicate_count() == 0, \"should be clean!\");\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -354,2 +354,2 @@\n-  GrowableArray<Node*>  _predicate_opaqs;       \/\/ List of Opaque1 nodes for the loop predicates.\n-  GrowableArray<Node*>  _skeleton_predicate_opaqs; \/\/ List of Opaque4 nodes for the loop skeleton predicates.\n+  GrowableArray<Node*>  _parse_predicate_opaqs; \/\/ List of Opaque1 nodes for the Parse Predicates.\n+  GrowableArray<Node*>  _template_assertion_predicate_opaqs; \/\/ List of Opaque4 nodes for Template Assertion Predicates.\n@@ -672,2 +672,2 @@\n-  int           predicate_count()         const { return _predicate_opaqs.length(); }\n-  int           skeleton_predicate_count() const { return _skeleton_predicate_opaqs.length(); }\n+  int           parse_predicate_count()   const { return _parse_predicate_opaqs.length(); }\n+  int           template_assertion_predicate_count() const { return _template_assertion_predicate_opaqs.length(); }\n@@ -678,2 +678,6 @@\n-  Node*         predicate_opaque1_node(int idx) const { return _predicate_opaqs.at(idx); }\n-  Node*         skeleton_predicate_opaque4_node(int idx) const { return _skeleton_predicate_opaqs.at(idx); }\n+  Node*         parse_predicate_opaque1_node(int idx) const { return _parse_predicate_opaqs.at(idx); }\n+\n+  Node* template_assertion_predicate_opaq_node(int idx) const {\n+    return _template_assertion_predicate_opaqs.at(idx);\n+  }\n+\n@@ -693,3 +697,3 @@\n-    \/\/ remove from _predicate_opaqs list also if it is there\n-    if (predicate_count() > 0) {\n-      _predicate_opaqs.remove_if_existing(n);\n+    \/\/ remove from _parse_predicate_opaqs list also if it is there\n+    if (parse_predicate_count() > 0) {\n+      _parse_predicate_opaqs.remove_if_existing(n);\n@@ -706,2 +710,2 @@\n-  void add_predicate_opaq(Node* n) {\n-    assert(!_predicate_opaqs.contains(n), \"duplicate entry in predicate opaque1\");\n+  void add_parse_predicate_opaq(Node* n) {\n+    assert(!_parse_predicate_opaqs.contains(n), \"duplicate entry in Parse Predicate opaque1 list\");\n@@ -709,1 +713,1 @@\n-    _predicate_opaqs.append(n);\n+    _parse_predicate_opaqs.append(n);\n@@ -711,3 +715,4 @@\n-  void add_skeleton_predicate_opaq(Node* n) {\n-    assert(!_skeleton_predicate_opaqs.contains(n), \"duplicate entry in skeleton predicate opaque4 list\");\n-    _skeleton_predicate_opaqs.append(n);\n+  void add_template_assertion_predicate_opaq(Node* n) {\n+    assert(!_template_assertion_predicate_opaqs.contains(n),\n+           \"duplicate entry in template assertion predicate opaque4 list\");\n+    _template_assertion_predicate_opaqs.append(n);\n@@ -715,3 +720,3 @@\n-  void remove_skeleton_predicate_opaq(Node* n) {\n-    if (skeleton_predicate_count() > 0) {\n-      _skeleton_predicate_opaqs.remove_if_existing(n);\n+  void remove_template_assertion_predicate_opaq(Node* n) {\n+    if (template_assertion_predicate_count() > 0) {\n+      _template_assertion_predicate_opaqs.remove_if_existing(n);\n@@ -739,1 +744,1 @@\n-  \/\/ remove the opaque nodes that protect the predicates so that the unused checks and\n+  \/\/ Remove the opaque nodes that protect the Parse Predicates so that the unused checks and\n@@ -741,3 +746,3 @@\n-  void cleanup_loop_predicates(PhaseIterGVN &igvn);\n-  bool is_predicate_opaq(Node* n) {\n-    return _predicate_opaqs.contains(n);\n+  void cleanup_parse_predicates(PhaseIterGVN &igvn) const;\n+  bool is_predicate_opaq(Node* n) const {\n+    return _parse_predicate_opaqs.contains(n);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":27,"deletions":22,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -3980,4 +3980,2 @@\n-\/\/----------------------------- loop predicates ---------------------------\n-\n-\/\/------------------------------add_predicate_impl----------------------------\n-void GraphKit::add_empty_predicate_impl(Deoptimization::DeoptReason reason, int nargs) {\n+\/\/ Add a Parse Predicate with an uncommon trap on the failing\/false path. Normal control will continue on the true path.\n+void GraphKit::add_parse_predicate(Deoptimization::DeoptReason reason, const int nargs) {\n@@ -3996,1 +3994,1 @@\n-    \/\/ do not generate predicate.\n+    \/\/ do not generate Parse Predicate.\n@@ -4000,1 +3998,1 @@\n-  Node *cont    = _gvn.intcon(1);\n+  Node* cont    = _gvn.intcon(1);\n@@ -4002,1 +4000,1 @@\n-  Node *bol     = _gvn.transform(new Conv2BNode(opq));\n+  Node* bol     = _gvn.transform(new Conv2BNode(opq));\n@@ -4005,1 +4003,1 @@\n-  C->add_predicate_opaq(opq);\n+  C->add_parse_predicate_opaq(opq);\n@@ -4016,5 +4014,3 @@\n-\/\/------------------------------add_predicate---------------------------------\n-void GraphKit::add_empty_predicates(int nargs) {\n-  \/\/ These loop predicates remain empty. All concrete loop predicates are inserted above the corresponding\n-  \/\/ empty loop predicate later by 'PhaseIdealLoop::create_new_if_for_predicate'. All concrete loop predicates of\n-  \/\/ a specific kind (normal, profile or limit check) share the same uncommon trap as the empty loop predicate.\n+\/\/ Add Parse Predicates which serve as placeholders to create new Runtime Predicates above them. All\n+\/\/ Runtime Predicates inside a Runtime Predicate block share the same uncommon trap as the Parse Predicate.\n+void GraphKit::add_parse_predicates(int nargs) {\n@@ -4022,1 +4018,1 @@\n-    add_empty_predicate_impl(Deoptimization::Reason_predicate, nargs);\n+    add_parse_predicate(Deoptimization::Reason_predicate, nargs);\n@@ -4025,1 +4021,1 @@\n-    add_empty_predicate_impl(Deoptimization::Reason_profile_predicate, nargs);\n+    add_parse_predicate(Deoptimization::Reason_profile_predicate, nargs);\n@@ -4027,2 +4023,2 @@\n-  \/\/ loop's limit check predicate should be near the loop.\n-  add_empty_predicate_impl(Deoptimization::Reason_loop_limit_check, nargs);\n+  \/\/ Loop Limit Check Predicate should be near the loop.\n+  add_parse_predicate(Deoptimization::Reason_loop_limit_check, nargs);\n@@ -4152,1 +4148,1 @@\n-  add_empty_predicates();\n+  add_parse_predicates();\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":14,"deletions":18,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -900,2 +900,2 @@\n-  void add_empty_predicates(int nargs = 0);\n-  void add_empty_predicate_impl(Deoptimization::DeoptReason reason, int nargs);\n+  void add_parse_predicates(int nargs = 0);\n+  void add_parse_predicate(Deoptimization::DeoptReason reason, int nargs);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -170,2 +170,2 @@\n-    \/\/ Add loop predicate.\n-    gkit->add_empty_predicates(nargs);\n+    \/\/ Add Parse Predicates.\n+    gkit->add_parse_predicates(nargs);\n","filename":"src\/hotspot\/share\/opto\/idealKit.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -245,1 +245,1 @@\n-    Node* proj = PhaseIdealLoop::find_predicate(r->in(ii));\n+    Node* proj = PhaseIdealLoop::find_parse_predicate(r->in(ii));\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,6 +43,4 @@\n- * The general idea of Loop Predication is to insert a predicate on the entry\n- * path to a loop, and raise a uncommon trap if the check of the condition fails.\n- * The condition checks are promoted from inside the loop body, and thus\n- * the checks inside the loop could be eliminated. Currently, loop predication\n- * optimization has been applied to remove array range check and loop invariant\n- * checks (such as null checks).\n+ * The general idea of Loop Predication is to hoist a check inside a loop body by inserting a Hoisted Predicate with an\n+ * uncommon trap on the entry path to the loop. The old check inside the loop can be eliminated. If the condition of the\n+ * Hoisted Predicate fails at runtime, we'll execute the uncommon trap to avoid entering the loop which misses the check.\n+ * Loop Predication can currently remove array range checks and loop invariant checks (such as null checks).\n@@ -50,7 +48,2 @@\n- * There are at least 3 kinds of predicates: a place holder inserted\n- * at parse time, the tests added by predication above the place\n- * holder (referred to as concrete predicates), skeleton predicates\n- * that are added between main loop and pre loop to protect C2 from\n- * inconsistencies in some rare cases of over unrolling. Skeleton\n- * predicates themselves are expanded and updated as unrolling\n- * proceeds. They don't compile to any code.\n+ * On top of these predicates added by Loop Predication, there are other kinds of predicates. The following list provides\n+ * a complete description of all predicates used in the C2 compiler:\n@@ -58,1 +51,162 @@\n-*\/\n+ *\n+ * There are different kinds of predicates throughout the code. We differentiate between the following predicates:\n+ *\n+ * - Regular Predicate: This term is used to refer to a Parse Predicate or a Runtime Predicate and can be used to\n+ *                      distinguish from any Assertion Predicate.\n+ * - Parse Predicate: Added during parsing to capture the current JVM state. This predicate represents a \"placeholder\"\n+ *                    above which more Runtime Predicates can be created later after parsing.\n+ *\n+ *                    There are initially three Parse Predicates for each loop:\n+ *                    - Loop Parse Predicate:             The Parse Predicate added for Loop Predicates.\n+ *                    - Profiled Loop Parse Predicate:    The Parse Predicate added for Profiled Loop Predicates.\n+ *                    - Loop Limit Check Parse Predicate: The Parse Predicate added for a Loop Limit Check Predicate.\n+ * - Runtime Predicate: This term is used to refer to a Hoisted Predicate (either a Loop Predicate or a Profiled Loop\n+ *                      Predicate) or a Loop Limit Check Predicate. These predicates will be checked at runtime while the\n+ *                      Parse and Assertion Predicates are always removed before code generation (except for Initialized\n+ *                      Assertion Predicates which are kept in debug builds while being removed in product builds).\n+ *     - Hoisted Predicate: Either a Loop Predicate or a Profiled Loop Predicate that was created during Loop Predication\n+ *                          to hoist a check out of a loop. Each Hoisted Predicate is accompanied by additional\n+ *                          Assertion Predicates.\n+ *         - Loop Predicate:     A predicate that can either hoist a loop-invariant check out of a loop or a range check\n+ *                               of the form \"a[i*scale + offset]\", where scale and offset are loop-invariant, out of a\n+ *                               counted loop. A check must be executed in each loop iteration to hoist it. Otherwise, no\n+ *                               Loop Predicate can be created. This predicate is created during Loop Predication and is\n+ *                               inserted above the Loop Parse Predicate.\n+ *         - Profiled Loop:      This predicate is very similar to a Loop Predicate but the hoisted check does not need\n+ *           Predicate           to be executed in each loop iteration. By using profiling information, only checks with\n+ *                               a high execution frequency are chosen to be replaced by a Profiled Loop Predicate. This\n+ *                               predicate is created during Loop Predication and is inserted above the Profiled Loop\n+ *                               Parse Predicate.\n+ *     - Loop Limit Check:   This predicate is created when transforming a loop to a counted loop to protect against\n+ *       Predicate           the case when adding the stride to the induction variable would cause an overflow which\n+ *                           will not satisfy the loop limit exit condition. This overflow is unexpected for further\n+ *                           counted loop optimizations and could lead to wrong results. Therefore, when this predicate\n+ *                           fails at runtime, we must trap and recompile the method without turning the loop into a\n+ *                           a counted loop to avoid these overflow problems.\n+ *                           The predicate does not replace an actual check inside the loop. This predicate can only\n+ *                           be added once above the Loop Limit Check Parse Predicate for a loop.\n+ * - Assertion Predicate: An always true predicate which will never fail (its range is already covered by an earlier\n+ *                        Hoisted Predicate or the main-loop entry guard) but is required in order to fold away a dead\n+ *                        sub loop inside which some data could be proven to be dead (by the type system) and replaced\n+ *                        by top. Without such Assertion Predicates, we could find that type ranges in Cast and ConvX2Y\n+ *                        data nodes become impossible and are replaced by top. This is an indicator that the sub loop\n+ *                        is never executed and must be dead. But there is no way for C2 to prove that the sub loop is\n+ *                        actually dead. Assertion Predicates come to the rescue to fold such seemingly dead sub loops\n+ *                        away to avoid a broken graph. Assertion Predicates are left in the graph as a sanity checks in\n+ *                        debug builds (they must never fail at runtime) while they are being removed in product builds.\n+ *                        We use special Opaque4 nodes to block some optimizations and replace the Assertion Predicates\n+ *                        later in product builds.\n+ *\n+ *                        There are two kinds of Assertion Predicates:\n+ *                        - Template Assertion Predicate:    A template for an Assertion Predicate that uses OpaqueLoop*\n+ *                                                           nodes as placeholders for the init and stride value of a loop.\n+ *                                                           This predicate does not represent an actual check, yet, and\n+ *                                                           just serves as a template to create an Initialized Assertion\n+ *                                                           Predicate for a (sub) loop.\n+ *                        - Initialized Assertion Predicate: An Assertion Predicate that represents an actual check for a\n+ *                                                           (sub) loop that was initialized by cloning a Template\n+ *                                                           Assertion Predicate. The check is always true and is covered\n+ *                                                           by an earlier check (a Hoisted Predicate or the main-loop\n+ *                                                           entry guard).\n+ *\n+ *                        Assertion Predicates are required when removing a range check from a loop. These are inserted\n+ *                        either at Loop Predication or at Range Check Elimination:\n+ *                        - Loop Predication:        A range check inside a loop is replaced by a Hoisted Predicate before\n+ *                                                   the loop. We add two additional Template Assertion Predicates from\n+ *                                                   which we can later create Initialized Assertion Predicates. One\n+ *                                                   would have been enough if the number of array accesses inside a sub\n+ *                                                   loop does not change. But when unrolling the sub loop, we are\n+ *                                                   doubling the number of array accesses - we need to cover them all.\n+ *                                                   To do that, we only need to create an Initialized Assertion Predicate\n+ *                                                   for the first, initial value and for the last value:\n+ *                                                   Let a[i] be an array access in the original, not-yet unrolled loop\n+ *                                                   with stride 1. When unrolling this loop, we double the stride\n+ *                                                   (i.e. stride 2) and have now two accesses a[i] and a[i+1]. We need\n+ *                                                   checks for both. When further unrolling this loop, we only need to\n+ *                                                   keep the checks on the first and last access (e.g. a[i] and a[i+3]\n+ *                                                   on the next unrolling step as they cover the checks in the middle\n+ *                                                   for a[i+1] and a[i+2]).\n+ *                                                   Therefore, we just need to cover:\n+ *                                                   - Initial value: a[init]\n+ *                                                   - Last value: a[init + new stride - original stride]\n+ *                                                   (We could still only use one Template Assertion Predicate to create\n+ *                                                   both Initialized Assertion Predicates from - might be worth doing\n+ *                                                   at some point).\n+ *                                                   When later splitting a loop (pre\/main\/post, peeling, unrolling),\n+ *                                                   we create two Initialized Assertion Predicates from the Template\n+ *                                                   Assertion Predicates by replacing the OpaqueLoop* nodes by actual\n+ *                                                   values. Initially (before unrolling), both Assertion Predicates are\n+ *                                                   equal. The Initialized Assertion Predicates are always true because\n+ *                                                   their range is covered by a corresponding Hoisted Predicate.\n+ *                        - Range Check Elimination: A range check is removed from the main-loop by changing the pre\n+ *                                                   and main-loop iterations. We add two additional Template Assertion\n+ *                                                   Predicates (see explanation in section above) and one Initialized\n+ *                                                   Assertion Predicate for the just removed range check. When later\n+ *                                                   unrolling the main-loop, we create two Initialized Assertion\n+ *                                                   Predicates from the Template Assertion Predicates by replacing the\n+ *                                                   OpaqueLoop* nodes by actual values for the unrolled loop.\n+ *                                                   The Initialized Assertion Predicates are always true because we will\n+ *                                                   never enter the main loop because of the changed pre- and main-loop\n+ *                                                   exit conditions.\n+ *                                                   Note that Range Check Elimination could remove additional range\n+ *                                                   checks which we were not possible to remove with Loop Predication\n+ *                                                   before (for example, because no Parse Predicates were available\n+ *                                                   before the loop to create Hoisted Predicates with).\n+ *\n+ *\n+ * In order to group predicates and refer to them throughout the code, we introduce the following additional terms:\n+ * - Regular Predicate Block: A Regular Predicate Block groups all Runtime Predicates in a Runtime Predicate Block\n+ *                            together with their dedicated Parse Predicate from which they were created (all predicates\n+ *                            share the same uncommon trap). The Runtime Predicate Block could be empty (i.e. no\n+ *                            Runtime Predicates created) and the Parse Predicate could be missing (after removing Parse\n+ *                            Predicates). There are three such Regular Predicate Blocks:\n+ *                            - Loop Predicate Block\n+ *                            - Profiled Loop Predicate Block\n+ *                            - Loop Limit Check Predicate Block\n+ * - Runtime Predicate Block: A block containing all Runtime Predicates that share the same uncommon trap (i.e. belonging\n+ *                            to a single Parse Predicate which is not included in this block). This block could be empty\n+ *                            if there were no Runtime Predicates created with the Parse Predicate below this block.\n+ *                            For the time being: We also count Assertion Predicates to this block but that will be\n+ *                            changed with the redesign of Assertion Predicates where we remove them from this block\n+ *                            (JDK-8288981).\n+ *\n+ * Initially, before applying any loop-splitting optimizations, we find the following structure after Loop Predication\n+ * (predicates inside square brackets [] do not need to exist if there are no checks to hoist):\n+ *\n+ *   [Loop Hoisted Predicate 1 + 2 Template Assertion Predicates]                 \\ Runtime       \\\n+ *   [Loop Hoisted Predicate 2 + 2 Template Assertion Predicates]                 | Predicate     |\n+ *   ...                                                                          | Block         | Loop Predicate Block\n+ *   [Loop Hoisted Predicate n + 2 Template Assertion Predicates]                 \/               |\n+ * Loop Parse Predicate                                                                           \/\n+ *\n+ *   [Profiled Loop Hoisted Predicate 1 + 2 Template Assertion Predicates]       \\ Runtime       \\\n+ *   [Profiled Loop Hoisted Predicate 2 + 2 Template Assertion Predicates]       | Predicate     | Profiled Loop\n+ *   ...                                                                         | Block         | Predicate Block\n+ *   [Profiled Loop Hoisted Predicate m + 2 Template Assertion Predicates]       \/               |\n+ * Profiled Loop Parse Predicate                                                                 \/\n+ *                                                                               \\ Runtime\n+ *   [Loop Limit Check Predicate] (at most 1)                                    \/ Predicate    \\ Loop Limit Check\n+ * Loop Limit Check Parse Predicate                                                Block        \/ Predicate Block\n+ * Loop Head\n+ *\n+ * As an example, let's look at how the predicate structure looks for the main-loop after creating pre\/main\/post loops\n+ * and applying Range Check Elimination (the order is insignificant):\n+ *\n+ * Main Loop entry (zero-trip) guard\n+ *   [For Loop Predicate 1: 2 Template + 2 Initialized Assertion Predicates]\n+ *   [For Loop Predicate 2: 2 Template + 2 Initialized Assertion Predicates]\n+ *   ...\n+ *   [For Loop Predicate n: 2 Template + 2 Initialized Assertion Predicates]\n+ *\n+ *   [For Profiled Loop Predicate 1: 2 Template + 2 Initialized Assertion Predicates]\n+ *   [For Profiled Loop Predicate 2: 2 Template + 2 Initialized Assertion Predicates]\n+ *   ...\n+ *   [For Profiled Loop Predicate m: 2 Template + 2 Initialized Assertion Predicates]\n+ *\n+ *   (after unrolling, we have 2 Initialized Assertion Predicates for the Assertion Predicates of Range Check Elimination)\n+ *   [For Range Check Elimination Check 1: 2 Templates + 1 Initialized Assertion Predicate]\n+ *   [For Range Check Elimination Check 2: 2 Templates + 1 Initialized Assertion Predicate]\n+ *   ...\n+ *   [For Range Check Elimination Check k: 2 Templates + 1 Initialized Assertion Predicate]\n+ * Main Loop Head\n+ *\/\n@@ -108,7 +262,5 @@\n-\/\/ is by default a true projection if 'if_cont_is_true_proj' is true.\n-\/\/ Otherwise, the continuation projection is set up to be the false\n-\/\/ projection. This code is also used to clone predicates to cloned loops.\n-ProjNode* PhaseIdealLoop::create_new_if_for_predicate(ProjNode* cont_proj, Node* new_entry,\n-                                                      Deoptimization::DeoptReason reason,\n-                                                      const int opcode, const bool rewire_uncommon_proj_phi_inputs,\n-                                                      const bool if_cont_is_true_proj) {\n+\/\/ is an IfTrue projection. This code is also used to clone predicates to cloned loops.\n+IfProjNode* PhaseIdealLoop::create_new_if_for_predicate(IfProjNode* cont_proj, Node* new_entry,\n+                                                        Deoptimization::DeoptReason reason,\n+                                                        const int opcode, const bool rewire_uncommon_proj_phi_inputs,\n+                                                        const bool if_cont_is_true_proj) {\n@@ -163,2 +315,2 @@\n-  Node* if_cont;\n-  Node* if_uct;\n+  IfProjNode* if_cont;\n+  IfProjNode* if_uct;\n@@ -175,1 +327,1 @@\n-    Node* tmp = if_uct; if_uct = if_cont; if_cont = tmp;\n+    IfProjNode* tmp = if_uct; if_uct = if_cont; if_cont = tmp;\n@@ -226,1 +378,1 @@\n-  return if_cont->as_Proj();\n+  return if_cont->as_IfProj();\n@@ -315,3 +467,3 @@\n-\/\/--------------------------clone_predicate-----------------------\n-ProjNode* PhaseIdealLoop::clone_predicate_to_unswitched_loop(ProjNode* predicate_proj, Node* new_entry,\n-                                                             Deoptimization::DeoptReason reason, const bool slow_loop) {\n+IfProjNode* PhaseIdealLoop::clone_parse_predicate_to_unswitched_loop(ParsePredicateSuccessProj* predicate_proj,\n+                                                                     Node* new_entry, Deoptimization::DeoptReason reason,\n+                                                                     const bool slow_loop) {\n@@ -319,2 +471,2 @@\n-  ProjNode* new_predicate_proj = create_new_if_for_predicate(predicate_proj, new_entry, reason, Op_If,\n-                                                             slow_loop);\n+  IfProjNode* new_predicate_proj = create_new_if_for_predicate(predicate_proj, new_entry, reason, Op_If,\n+                                                               slow_loop);\n@@ -327,1 +479,1 @@\n-  C->add_predicate_opaq(opq);\n+  C->add_parse_predicate_opaq(opq);\n@@ -336,4 +488,7 @@\n-\/\/ Clones skeleton predicates starting at 'old_predicate_proj' by following its control inputs and rewires the control edges of in the loop from\n-\/\/ the old predicates to the new cloned predicates.\n-void PhaseIdealLoop::clone_skeleton_predicates_to_unswitched_loop(IdealLoopTree* loop, const Node_List& old_new, Deoptimization::DeoptReason reason,\n-                                                                  ProjNode* old_predicate_proj, ProjNode* iffast_pred, ProjNode* ifslow_pred) {\n+\/\/ Clones Assertion Predicates to both unswitched loops starting at 'old_predicate_proj' by following its control inputs.\n+\/\/ It also rewires the control edges of data nodes with dependencies in the loop from the old predicates to the new\n+\/\/ cloned predicates.\n+void PhaseIdealLoop::clone_assertion_predicates_to_unswitched_loop(IdealLoopTree* loop, const Node_List& old_new,\n+                                                                   Deoptimization::DeoptReason reason,\n+                                                                   IfProjNode* old_predicate_proj, IfProjNode* iffast_pred,\n+                                                                   IfProjNode* ifslow_pred) {\n@@ -345,1 +500,1 @@\n-  get_skeleton_predicates(old_predicate_proj, list);\n+  get_assertion_predicates(old_predicate_proj, list);\n@@ -349,3 +504,3 @@\n-  ProjNode* uncommon_proj = iff->proj_out(1 - old_predicate_proj->as_Proj()->_con);\n-  \/\/ Process in reverse order such that 'create_new_if_for_predicate' can be used in 'clone_skeleton_predicate_for_unswitched_loops'\n-  \/\/ and the original order is maintained.\n+  IfProjNode* uncommon_proj = iff->proj_out(1 - old_predicate_proj->as_Proj()->_con)->as_IfProj();\n+  \/\/ Process in reverse order such that 'create_new_if_for_predicate' can be used in\n+  \/\/ 'clone_assertion_predicate_for_unswitched_loops' and the original order is maintained.\n@@ -359,4 +514,4 @@\n-    ProjNode* fast_proj = clone_skeleton_predicate_for_unswitched_loops(iff, predicate_proj, reason, iffast_pred);\n-    assert(skeleton_predicate_has_opaque(fast_proj->in(0)->as_If()), \"must find skeleton predicate for fast loop\");\n-    ProjNode* slow_proj = clone_skeleton_predicate_for_unswitched_loops(iff, predicate_proj, reason, ifslow_pred);\n-    assert(skeleton_predicate_has_opaque(slow_proj->in(0)->as_If()), \"must find skeleton predicate for slow loop\");\n+    IfProjNode* fast_proj = clone_assertion_predicate_for_unswitched_loops(iff, predicate_proj, reason, iffast_pred);\n+    assert(assertion_predicate_has_loop_opaque_node(fast_proj->in(0)->as_If()), \"must find Assertion Predicate for fast loop\");\n+    IfProjNode* slow_proj = clone_assertion_predicate_for_unswitched_loops(iff, predicate_proj, reason, ifslow_pred);\n+    assert(assertion_predicate_has_loop_opaque_node(slow_proj->in(0)->as_If()), \"must find Assertion Predicate for slow loop\");\n@@ -384,3 +539,3 @@\n-\/\/ Put all skeleton predicate projections on a list, starting at 'predicate' and going up in the tree. If 'get_opaque'\n-\/\/ is set, then the Opaque4 nodes of the skeleton predicates are put on the list instead of the projections.\n-void PhaseIdealLoop::get_skeleton_predicates(Node* predicate, Unique_Node_List& list, bool get_opaque) {\n+\/\/ Put all Assertion Predicate projections on a list, starting at 'predicate' and going up in the tree. If 'get_opaque'\n+\/\/ is set, then the Opaque4 nodes of the Assertion Predicates are put on the list instead of the projections.\n+void PhaseIdealLoop::get_assertion_predicates(Node* predicate, Unique_Node_List& list, bool get_opaque) {\n@@ -399,1 +554,1 @@\n-    if (iff->in(1)->Opcode() == Op_Opaque4 && skeleton_predicate_has_opaque(iff)) {\n+    if (iff->in(1)->Opcode() == Op_Opaque4 && assertion_predicate_has_loop_opaque_node(iff)) {\n@@ -412,1 +567,1 @@\n-\/\/ Clone a skeleton predicate for an unswitched loop. OpaqueLoopInit and OpaqueLoopStride nodes are cloned and uncommon\n+\/\/ Clone an Assertion Predicate for an unswitched loop. OpaqueLoopInit and OpaqueLoopStride nodes are cloned and uncommon\n@@ -415,5 +570,5 @@\n-ProjNode* PhaseIdealLoop::clone_skeleton_predicate_for_unswitched_loops(Node* iff, ProjNode* predicate,\n-                                                                        Deoptimization::DeoptReason reason,\n-                                                                        ProjNode* output_proj) {\n-  Node* bol = clone_skeleton_predicate_bool(iff, nullptr, nullptr, output_proj);\n-  ProjNode* proj = create_new_if_for_predicate(output_proj, nullptr, reason, iff->Opcode(),\n+IfProjNode* PhaseIdealLoop::clone_assertion_predicate_for_unswitched_loops(Node* iff, IfProjNode* predicate,\n+                                                                           Deoptimization::DeoptReason reason,\n+                                                                           IfProjNode* output_proj) {\n+  Node* bol = create_bool_from_template_assertion_predicate(iff, nullptr, nullptr, output_proj);\n+  IfProjNode* if_proj = create_new_if_for_predicate(output_proj, nullptr, reason, iff->Opcode(),\n@@ -421,4 +576,4 @@\n-  _igvn.replace_input_of(proj->in(0), 1, bol);\n-  _igvn.replace_input_of(output_proj->in(0), 0, proj);\n-  set_idom(output_proj->in(0), proj, dom_depth(proj));\n-  return proj;\n+  _igvn.replace_input_of(if_proj->in(0), 1, bol);\n+  _igvn.replace_input_of(output_proj->in(0), 0, if_proj);\n+  set_idom(output_proj->in(0), if_proj, dom_depth(if_proj));\n+  return if_proj;\n@@ -427,3 +582,3 @@\n-\/\/--------------------------clone_loop_predicates-----------------------\n-\/\/ Clone loop predicates to cloned loops when unswitching a loop.\n-void PhaseIdealLoop::clone_predicates_to_unswitched_loop(IdealLoopTree* loop, Node_List& old_new, ProjNode*& iffast_pred, ProjNode*& ifslow_pred) {\n+\/\/ Clone Parse Predicates to cloned loops when unswitching a loop.\n+void PhaseIdealLoop::clone_parse_and_assertion_predicates_to_unswitched_loop(IdealLoopTree* loop, Node_List& old_new,\n+                                                                             IfProjNode*& iffast_pred, IfProjNode*& ifslow_pred) {\n@@ -435,1 +590,1 @@\n-  ProjNode* limit_check_proj = nullptr;\n+  ParsePredicateSuccessProj* limit_check_proj = nullptr;\n@@ -438,1 +593,1 @@\n-    entry = skip_loop_predicates(entry);\n+    entry = skip_related_predicates(entry);\n@@ -440,2 +595,2 @@\n-  ProjNode* profile_predicate_proj = nullptr;\n-  ProjNode* predicate_proj = nullptr;\n+  ParsePredicateSuccessProj* profile_predicate_proj = nullptr;\n+  ParsePredicateSuccessProj* predicate_proj = nullptr;\n@@ -445,1 +600,1 @@\n-      entry = skip_loop_predicates(entry);\n+      entry = skip_related_predicates(entry);\n@@ -453,3 +608,4 @@\n-    iffast_pred = clone_predicate_to_unswitched_loop(predicate_proj, iffast_pred, Deoptimization::Reason_predicate,false);\n-    ifslow_pred = clone_predicate_to_unswitched_loop(predicate_proj, ifslow_pred, Deoptimization::Reason_predicate,true);\n-    clone_skeleton_predicates_to_unswitched_loop(loop, old_new, Deoptimization::Reason_predicate, predicate_proj, iffast_pred, ifslow_pred);\n+    iffast_pred = clone_parse_predicate_to_unswitched_loop(predicate_proj, iffast_pred, Deoptimization::Reason_predicate, false);\n+    ifslow_pred = clone_parse_predicate_to_unswitched_loop(predicate_proj, ifslow_pred, Deoptimization::Reason_predicate, true);\n+    clone_assertion_predicates_to_unswitched_loop(loop, old_new, Deoptimization::Reason_predicate, predicate_proj,\n+                                                  iffast_pred, ifslow_pred);\n@@ -457,2 +613,2 @@\n-    check_created_predicate_for_unswitching(iffast_pred);\n-    check_created_predicate_for_unswitching(ifslow_pred);\n+    check_cloned_parse_predicate_for_unswitching(iffast_pred);\n+    check_cloned_parse_predicate_for_unswitching(ifslow_pred);\n@@ -462,3 +618,4 @@\n-    iffast_pred = clone_predicate_to_unswitched_loop(profile_predicate_proj, iffast_pred,Deoptimization::Reason_profile_predicate, false);\n-    ifslow_pred = clone_predicate_to_unswitched_loop(profile_predicate_proj, ifslow_pred,Deoptimization::Reason_profile_predicate, true);\n-    clone_skeleton_predicates_to_unswitched_loop(loop, old_new, Deoptimization::Reason_profile_predicate, profile_predicate_proj, iffast_pred, ifslow_pred);\n+    iffast_pred = clone_parse_predicate_to_unswitched_loop(profile_predicate_proj, iffast_pred,Deoptimization::Reason_profile_predicate, false);\n+    ifslow_pred = clone_parse_predicate_to_unswitched_loop(profile_predicate_proj, ifslow_pred,Deoptimization::Reason_profile_predicate, true);\n+    clone_assertion_predicates_to_unswitched_loop(loop, old_new, Deoptimization::Reason_profile_predicate,\n+                                                  profile_predicate_proj, iffast_pred, ifslow_pred);\n@@ -466,2 +623,2 @@\n-    check_created_predicate_for_unswitching(iffast_pred);\n-    check_created_predicate_for_unswitching(ifslow_pred);\n+    check_cloned_parse_predicate_for_unswitching(iffast_pred);\n+    check_cloned_parse_predicate_for_unswitching(ifslow_pred);\n@@ -473,2 +630,2 @@\n-    iffast_pred = clone_predicate_to_unswitched_loop(limit_check_proj, iffast_pred,Deoptimization::Reason_loop_limit_check, false);\n-    ifslow_pred = clone_predicate_to_unswitched_loop(limit_check_proj, ifslow_pred,Deoptimization::Reason_loop_limit_check, true);\n+    iffast_pred = clone_parse_predicate_to_unswitched_loop(limit_check_proj, iffast_pred,Deoptimization::Reason_loop_limit_check, false);\n+    ifslow_pred = clone_parse_predicate_to_unswitched_loop(limit_check_proj, ifslow_pred,Deoptimization::Reason_loop_limit_check, true);\n@@ -476,2 +633,3 @@\n-    check_created_predicate_for_unswitching(iffast_pred);\n-    check_created_predicate_for_unswitching(ifslow_pred);\n+\n+    check_cloned_parse_predicate_for_unswitching(iffast_pred);\n+    check_cloned_parse_predicate_for_unswitching(ifslow_pred);\n@@ -482,1 +640,1 @@\n-void PhaseIdealLoop::check_created_predicate_for_unswitching(const Node* new_entry) {\n+void PhaseIdealLoop::check_cloned_parse_predicate_for_unswitching(const Node* new_entry) {\n@@ -491,4 +649,1 @@\n-\n-\/\/--------------------------skip_loop_predicates------------------------------\n-\/\/ Skip related predicates.\n-Node* PhaseIdealLoop::skip_loop_predicates(Node* entry) {\n+Node* PhaseIdealLoop::skip_related_predicates(Node* entry) {\n@@ -509,3 +664,3 @@\n-Node* PhaseIdealLoop::skip_all_loop_predicates(Node* entry) {\n-  Predicates predicates(entry);\n-  return predicates.skip_all();\n+Node* PhaseIdealLoop::skip_all_predicates(Node* entry) {\n+  ParsePredicates parse_predicates(entry);\n+  return parse_predicates.get_first_predicate();\n@@ -516,3 +671,3 @@\n-ProjNode* PhaseIdealLoop::next_predicate(ProjNode* predicate) {\n-  IfNode* iff = predicate->in(0)->as_If();\n-  ProjNode* uncommon_proj = iff->proj_out(1 - predicate->_con);\n+IfProjNode* PhaseIdealLoop::next_predicate(IfProjNode* predicate_proj) {\n+  IfNode* iff = predicate_proj->in(0)->as_If();\n+  ProjNode* uncommon_proj = iff->proj_out(1 - predicate_proj->_con);\n@@ -522,1 +677,1 @@\n-  if (next != nullptr && next->is_Proj() && next->in(0)->is_If()) {\n+  if (next != nullptr && next->is_IfProj() && next->in(0)->is_If()) {\n@@ -525,1 +680,1 @@\n-      return next->as_Proj();\n+      return next->as_IfProj();\n@@ -533,2 +688,2 @@\n-ProjNode* PhaseIdealLoop::find_predicate_insertion_point(Node* start_c, Deoptimization::DeoptReason reason) {\n-  if (start_c == nullptr || !start_c->is_Proj())\n+ParsePredicateSuccessProj* PhaseIdealLoop::find_predicate_insertion_point(Node* start_c, Deoptimization::DeoptReason reason) {\n+  if (start_c == nullptr || !start_c->is_IfTrue())\n@@ -536,2 +691,2 @@\n-  if (start_c->as_Proj()->is_uncommon_trap_if_pattern(reason)) {\n-    return start_c->as_Proj();\n+  if (start_c->as_IfTrue()->is_uncommon_trap_if_pattern(reason)) {\n+    return start_c->as_IfTrue();\n@@ -544,4 +699,4 @@\n-PhaseIdealLoop::Predicates::Predicates(Node* entry) {\n-  _loop_limit_check = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);\n-  if (_loop_limit_check != nullptr) {\n-    entry = skip_loop_predicates(entry);\n+PhaseIdealLoop::ParsePredicates::ParsePredicates(Node* entry) {\n+  _loop_limit_check_predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);\n+  if (_loop_limit_check_predicate != nullptr) {\n+    entry = skip_related_predicates(entry);\n@@ -550,3 +705,3 @@\n-    _profile_predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);\n-    if (_profile_predicate != nullptr) {\n-      entry = skip_loop_predicates(entry);\n+    _profiled_loop_predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);\n+    if (_profiled_loop_predicate != nullptr) {\n+      entry = skip_related_predicates(entry);\n@@ -556,3 +711,3 @@\n-    _predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);\n-    if (_predicate != nullptr) {\n-      entry = skip_loop_predicates(entry);\n+    _loop_predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);\n+    if (_loop_predicate != nullptr) {\n+      entry = skip_related_predicates(entry);\n@@ -561,1 +716,1 @@\n-  _entry_to_all_predicates = entry;\n+  _first_predicate = entry;\n@@ -564,3 +719,1 @@\n-\/\/--------------------------find_predicate------------------------------------\n-\/\/ Find a predicate\n-Node* PhaseIdealLoop::find_predicate(Node* entry) {\n+Node* PhaseIdealLoop::find_parse_predicate(Node* entry) {\n@@ -1009,1 +1162,1 @@\n-bool PhaseIdealLoop::loop_predication_should_follow_branches(IdealLoopTree *loop, ProjNode *predicate_proj, float& loop_trip_cnt) {\n+bool PhaseIdealLoop::loop_predication_should_follow_branches(IdealLoopTree* loop, IfProjNode* predicate_proj, float& loop_trip_cnt) {\n@@ -1259,4 +1412,3 @@\n-\n-bool PhaseIdealLoop::loop_predication_impl_helper(IdealLoopTree *loop, ProjNode* proj, ProjNode *predicate_proj,\n-                                                  CountedLoopNode *cl, ConNode* zero, Invariance& invar,\n-                                                  Deoptimization::DeoptReason reason) {\n+bool PhaseIdealLoop::loop_predication_impl_helper(IdealLoopTree* loop, IfProjNode* if_proj,\n+                                                  ParsePredicateSuccessProj* parse_predicate_proj, CountedLoopNode* cl,\n+                                                  ConNode* zero, Invariance& invar, Deoptimization::DeoptReason reason) {\n@@ -1264,2 +1416,2 @@\n-  ProjNode* new_predicate_proj = nullptr;\n-  IfNode*   iff  = proj->in(0)->as_If();\n+  IfProjNode* new_predicate_proj = nullptr;\n+  IfNode*   iff  = if_proj->in(0)->as_If();\n@@ -1267,1 +1419,1 @@\n-  if (!test->is_Bool()){ \/\/Conv2B, ...\n+  if (!test->is_Bool()) { \/\/Conv2B, ...\n@@ -1273,1 +1425,1 @@\n-    new_predicate_proj = create_new_if_for_predicate(predicate_proj, nullptr,\n+    new_predicate_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr,\n@@ -1279,1 +1431,1 @@\n-    \/\/ Negate test if necessary\n+    \/\/ Negate test if necessary (Parse Predicates always have IfTrue as success projection and IfFalse as uncommon trap)\n@@ -1281,1 +1433,1 @@\n-    if (proj->_con != predicate_proj->_con) {\n+    if (if_proj->is_IfFalse()) {\n@@ -1298,1 +1450,1 @@\n-  } else if (cl != nullptr && loop->is_range_check_if(iff, this, invar DEBUG_ONLY(COMMA predicate_proj))) {\n+  } else if (cl != nullptr && loop->is_range_check_if(iff, this, invar DEBUG_ONLY(COMMA parse_predicate_proj))) {\n@@ -1326,1 +1478,1 @@\n-    Node *ctrl = predicate_proj->in(0)->as_If()->in(0);\n+    Node* ctrl = parse_predicate_proj->in(0)->as_If()->in(0);\n@@ -1334,1 +1486,2 @@\n-    bool negate = (proj->_con != predicate_proj->_con);\n+    \/\/ Negate test if necessary (Parse Predicates always have IfTrue as success projection and IfFalse as uncommon trap)\n+    const bool negate = (if_proj->is_IfFalse());\n@@ -1339,1 +1492,2 @@\n-    ProjNode* lower_bound_proj = create_new_if_for_predicate(predicate_proj, nullptr, reason, overflow ? Op_If : iff->Opcode());\n+    const int if_opcode = iff->Opcode();\n+    IfProjNode* lower_bound_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason, overflow ? Op_If : if_opcode);\n@@ -1348,1 +1502,1 @@\n-    ProjNode* upper_bound_proj = create_new_if_for_predicate(predicate_proj, nullptr, reason, overflow ? Op_If : iff->Opcode());\n+    IfProjNode* upper_bound_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason, overflow ? Op_If : if_opcode);\n@@ -1358,2 +1512,2 @@\n-    new_predicate_proj = insert_initial_skeleton_predicate(iff, loop, proj, predicate_proj, upper_bound_proj, scale,\n-                                                           offset, init, limit, stride, rng, overflow, reason);\n+    new_predicate_proj = add_template_assertion_predicate(iff, loop, if_proj, parse_predicate_proj, upper_bound_proj, scale,\n+                                                          offset, init, limit, stride, rng, overflow, reason);\n@@ -1374,1 +1528,1 @@\n-  invar.map_ctrl(proj, new_predicate_proj); \/\/ so that invariance test can be appropriate\n+  invar.map_ctrl(if_proj, new_predicate_proj); \/\/ so that invariance test can be appropriate\n@@ -1377,1 +1531,1 @@\n-  dominated_by( new_predicate_proj->as_IfProj(), iff, proj->_con != new_predicate_proj->_con );\n+  dominated_by(new_predicate_proj, iff, if_proj->_con != new_predicate_proj->_con );\n@@ -1383,13 +1537,7 @@\n-\n-\/\/ After pre\/main\/post loops are created, we'll put a copy of some\n-\/\/ range checks between the pre and main loop to validate the value\n-\/\/ of the main loop induction variable. Make a copy of the predicates\n-\/\/ here with an opaque node as a place holder for the value (will be\n-\/\/ updated by PhaseIdealLoop::clone_skeleton_predicate()).\n-ProjNode* PhaseIdealLoop::insert_initial_skeleton_predicate(IfNode* iff, IdealLoopTree *loop,\n-                                                            ProjNode* proj, ProjNode *predicate_proj,\n-                                                            ProjNode* upper_bound_proj,\n-                                                            int scale, Node* offset,\n-                                                            Node* init, Node* limit, jint stride,\n-                                                            Node* rng, bool &overflow,\n-                                                            Deoptimization::DeoptReason reason) {\n+\/\/ Each newly created Hoisted Predicate is accompanied by two Template Assertion Predicates. Later, we initialize them\n+\/\/ by making a copy of them when splitting a loop into sub loops. The Assertion Predicates ensure that dead sub loops\n+\/\/ are removed properly.\n+IfProjNode* PhaseIdealLoop::add_template_assertion_predicate(IfNode* iff, IdealLoopTree* loop, IfProjNode* if_proj,\n+                                                             IfProjNode* predicate_proj, IfProjNode* upper_bound_proj,\n+                                                             int scale, Node* offset, Node* init, Node* limit, jint stride,\n+                                                             Node* rng, bool& overflow, Deoptimization::DeoptReason reason) {\n@@ -1399,1 +1547,1 @@\n-  bool negate = (proj->_con != predicate_proj->_con);\n+  bool negate = (if_proj->_con != predicate_proj->_con);\n@@ -1402,1 +1550,1 @@\n-  C->add_skeleton_predicate_opaq(opaque_bol);\n+  C->add_template_assertion_predicate_opaq(opaque_bol);\n@@ -1404,1 +1552,1 @@\n-  ProjNode* new_proj = create_new_if_for_predicate(predicate_proj, nullptr, reason, overflow ? Op_If : iff->Opcode());\n+  IfProjNode* new_proj = create_new_if_for_predicate(predicate_proj, nullptr, reason, overflow ? Op_If : iff->Opcode());\n@@ -1424,1 +1572,1 @@\n-  C->add_skeleton_predicate_opaq(opaque_bol);\n+  C->add_template_assertion_predicate_opaq(opaque_bol);\n@@ -1429,1 +1577,1 @@\n-  assert(skeleton_predicate_has_opaque(new_proj->in(0)->as_If()), \"unexpected\");\n+  assert(assertion_predicate_has_loop_opaque_node(new_proj->in(0)->as_If()), \"unexpected\");\n@@ -1466,3 +1614,3 @@\n-  ProjNode *loop_limit_proj = nullptr;\n-  ProjNode *predicate_proj = nullptr;\n-  ProjNode *profile_predicate_proj = nullptr;\n+  ParsePredicateSuccessProj* loop_limit_proj = nullptr;\n+  ParsePredicateSuccessProj* predicate_proj = nullptr;\n+  ParsePredicateSuccessProj* profile_predicate_proj = nullptr;\n@@ -1472,1 +1620,1 @@\n-    entry = skip_loop_predicates(loop_limit_proj);\n+    entry = skip_related_predicates(loop_limit_proj);\n@@ -1477,1 +1625,1 @@\n-    Node* n = skip_loop_predicates(entry);\n+    Node* n = skip_related_predicates(entry);\n@@ -1536,2 +1684,2 @@\n-      ProjNode* proj = n->as_Proj();\n-      IfNode*   iff  = proj->in(0)->as_If();\n+      IfProjNode* if_proj = n->as_IfProj();\n+      IfNode* iff = if_proj->in(0)->as_If();\n@@ -1539,1 +1687,1 @@\n-      CallStaticJavaNode* call = proj->is_uncommon_trap_if_pattern(Deoptimization::Reason_none);\n+      CallStaticJavaNode* call = if_proj->is_uncommon_trap_if_pattern(Deoptimization::Reason_none);\n@@ -1562,1 +1710,1 @@\n-        hoisted = loop_predication_impl_helper(loop, proj, predicate_proj, cl, zero, invar, Deoptimization::Reason_predicate) | hoisted;\n+        hoisted = loop_predication_impl_helper(loop, if_proj, predicate_proj, cl, zero, invar, Deoptimization::Reason_predicate) | hoisted;\n@@ -1573,3 +1721,3 @@\n-      Node* proj = if_proj_list.pop();\n-      float f = pf.to(proj);\n-      if (proj->as_Proj()->is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &&\n+      Node* if_proj = if_proj_list.pop();\n+      float f = pf.to(if_proj);\n+      if (if_proj->as_Proj()->is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &&\n@@ -1577,1 +1725,1 @@\n-        hoisted = loop_predication_impl_helper(loop, proj->as_Proj(), profile_predicate_proj, cl, zero, invar, Deoptimization::Reason_profile_predicate) | hoisted;\n+        hoisted = loop_predication_impl_helper(loop, if_proj->as_IfProj(), profile_predicate_proj, cl, zero, invar, Deoptimization::Reason_profile_predicate) | hoisted;\n@@ -1591,2 +1739,2 @@\n-      ProjNode* proj = if_proj_list_freq.at(i)->as_Proj();\n-      hoisted = loop_predication_impl_helper(loop, proj, profile_predicate_proj, cl, zero, invar, Deoptimization::Reason_profile_predicate) | hoisted;\n+      IfProjNode* if_proj = if_proj_list_freq.at(i)->as_IfProj();\n+      hoisted = loop_predication_impl_helper(loop, if_proj, profile_predicate_proj, cl, zero, invar, Deoptimization::Reason_profile_predicate) | hoisted;\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":311,"deletions":163,"binary":false,"changes":474,"status":"modified"},{"patch":"@@ -563,1 +563,1 @@\n-\/\/              loop predicate\n+\/\/                predicates\n@@ -588,1 +588,1 @@\n-\/\/               loop predicate\n+\/\/                predicates\n@@ -619,1 +619,1 @@\n-\/\/               loop predicate\n+\/\/                predicates\n@@ -656,1 +656,1 @@\n-\/\/              loop predicate\n+\/\/                predicates\n@@ -669,1 +669,1 @@\n-\/\/             | initialized skeleton predicates\n+\/\/             | Initialized Assertion Predicates\n@@ -774,1 +774,1 @@\n-  \/\/ Step 5: skeleton_predicates instantiation\n+  \/\/ Step 5: Assertion Predicates initialization\n@@ -780,9 +780,9 @@\n-    Predicates predicates(new_head->in(LoopNode::EntryControl));\n-    initialize_skeleton_predicates_for_peeled_loop(predicates.predicate(),\n-                                                   outer_loop_head, dd_outer_loop_head,\n-                                                   init, stride, outer_loop,\n-                                                   idx_before_clone, old_new);\n-    initialize_skeleton_predicates_for_peeled_loop(predicates.profile_predicate(),\n-                                                   outer_loop_head, dd_outer_loop_head,\n-                                                   init, stride, outer_loop,\n-                                                   idx_before_clone, old_new);\n+    ParsePredicates parse_predicates(new_head->in(LoopNode::EntryControl));\n+    initialize_assertion_predicates_for_peeled_loop(parse_predicates.loop_predicate(),\n+                                                    outer_loop_head, dd_outer_loop_head,\n+                                                    init, stride, outer_loop,\n+                                                    idx_before_clone, old_new);\n+    initialize_assertion_predicates_for_peeled_loop(parse_predicates.profiled_loop_predicate(),\n+                                                    outer_loop_head, dd_outer_loop_head,\n+                                                    init, stride, outer_loop,\n+                                                    idx_before_clone, old_new);\n@@ -1305,13 +1305,11 @@\n-\/\/ Make a copy of the skeleton range check predicates before the main\n-\/\/ loop and set the initial value of loop as input. After unrolling,\n-\/\/ the range of values for the induction variable in the main loop can\n-\/\/ fall outside the allowed range of values by the array access (main\n-\/\/ loop is never executed). When that happens, range check\n-\/\/ CastII\/ConvI2L nodes cause some data paths to die. For consistency,\n-\/\/ the control paths must die too but the range checks were removed by\n-\/\/ predication. The range checks that we add here guarantee that they do.\n-void PhaseIdealLoop::copy_skeleton_predicates_to_main_loop_helper(Node* predicate, Node* init, Node* stride,\n-                                                 IdealLoopTree* outer_loop, LoopNode* outer_main_head,\n-                                                 uint dd_main_head, const uint idx_before_pre_post,\n-                                                 const uint idx_after_post_before_pre, Node* zero_trip_guard_proj_main,\n-                                                 Node* zero_trip_guard_proj_post, const Node_List &old_new) {\n+\/\/ Make two copies of each Template Assertion Predicate before the pre-loop and add them to the main-loop. One remains\n+\/\/ a template while the other one is initialized with the initial value of the loop induction variable. The Initialized\n+\/\/ Assertion Predicates ensures that the main-loop is removed if some type ranges of Cast or Convert nodes become\n+\/\/ impossible and are replaced by top (i.e. a sign that the main-loop is dead).\n+void PhaseIdealLoop::copy_assertion_predicates_to_main_loop_helper(Node* predicate, Node* init, Node* stride,\n+                                                                   IdealLoopTree* outer_loop, LoopNode* outer_main_head,\n+                                                                   const uint dd_main_head, const uint idx_before_pre_post,\n+                                                                   const uint idx_after_post_before_pre,\n+                                                                   Node* zero_trip_guard_proj_main,\n+                                                                   Node* zero_trip_guard_proj_post,\n+                                                                   const Node_List &old_new) {\n@@ -1342,2 +1340,2 @@\n-        assert(skeleton_predicate_has_opaque(iff), \"unexpected\");\n-        \/\/ Clone the skeleton predicate twice and initialize one with the initial\n+        assert(assertion_predicate_has_loop_opaque_node(iff), \"unexpected\");\n+        \/\/ Clone the Assertion Predicate twice and initialize one with the initial\n@@ -1346,3 +1344,3 @@\n-        prev_proj = clone_skeleton_predicate_and_initialize(iff, opaque_init, nullptr, predicate, uncommon_proj,\n-                                                            current_proj, outer_loop, prev_proj);\n-        assert(skeleton_predicate_has_opaque(prev_proj->in(0)->as_If()), \"\");\n+        prev_proj = clone_assertion_predicate_and_initialize(iff, opaque_init, nullptr, predicate, uncommon_proj,\n+                                                             current_proj, outer_loop, prev_proj);\n+        assert(assertion_predicate_has_loop_opaque_node(prev_proj->in(0)->as_If()), \"\");\n@@ -1350,3 +1348,3 @@\n-        prev_proj = clone_skeleton_predicate_and_initialize(iff, init, stride, predicate, uncommon_proj,\n-                                                            current_proj, outer_loop, prev_proj);\n-        assert(!skeleton_predicate_has_opaque(prev_proj->in(0)->as_If()), \"\");\n+        prev_proj = clone_assertion_predicate_and_initialize(iff, init, stride, predicate, uncommon_proj,\n+                                                             current_proj, outer_loop, prev_proj);\n+        assert(!assertion_predicate_has_loop_opaque_node(prev_proj->in(0)->as_If()), \"\");\n@@ -1354,2 +1352,2 @@\n-        \/\/ Rewire any control inputs from the cloned skeleton predicates down to the main and post loop for data nodes that are part of the\n-        \/\/ main loop (and were cloned to the pre and post loop).\n+        \/\/ Rewire any control inputs from the cloned Assertion Predicates down to the main and post loop for data nodes\n+        \/\/ that are part of the main loop (and were cloned to the pre and post loop).\n@@ -1376,1 +1374,1 @@\n-        \/\/ Remove the skeleton predicate from the pre-loop\n+        \/\/ Remove the Assertion Predicate from the pre-loop\n@@ -1386,1 +1384,3 @@\n-static bool skeleton_follow_inputs(Node* n) {\n+\/\/ Is 'n' a node that can be found on the input chain of a Template Assertion Predicate bool (i.e. between a Template\n+\/\/ Assertion Predicate If node and the OpaqueLoop* nodes)?\n+static bool is_part_of_template_assertion_predicate_bool(Node* n) {\n@@ -1409,1 +1409,1 @@\n-  if (!skeleton_follow_inputs(n)) {\n+  if (!is_part_of_template_assertion_predicate_bool(n)) {\n@@ -1418,2 +1418,1 @@\n-\n-bool PhaseIdealLoop::skeleton_predicate_has_opaque(IfNode* iff) {\n+bool PhaseIdealLoop::assertion_predicate_has_loop_opaque_node(IfNode* iff) {\n@@ -1462,1 +1461,1 @@\n-    if (skeleton_follow_inputs(n)) {\n+    if (is_part_of_template_assertion_predicate_bool(n)) {\n@@ -1479,4 +1478,5 @@\n-\/\/ Clone the skeleton predicate bool for a main or unswitched loop:\n-\/\/ Main loop: Set new_init and new_stride nodes as new inputs.\n-\/\/ Unswitched loop: new_init and new_stride are both null. Clone OpaqueLoopInit and OpaqueLoopStride instead.\n-Node* PhaseIdealLoop::clone_skeleton_predicate_bool(Node* iff, Node* new_init, Node* new_stride, Node* control) {\n+\/\/ Create a new Bool node from the provided Template Assertion Predicate.\n+\/\/ Unswitched loop: new_init and new_stride are both null. Clone OpaqueLoopInit and OpaqueLoopStride.\n+\/\/ Otherwise: Replace found OpaqueLoop* nodes with new_init and new_stride, respectively.\n+Node* PhaseIdealLoop::create_bool_from_template_assertion_predicate(Node* template_assertion_predicate, Node* new_init,\n+                                                                    Node* new_stride, Node* control) {\n@@ -1484,1 +1484,3 @@\n-  to_clone.push(iff->in(1), 1);\n+  Node* opaque4 = template_assertion_predicate->in(1);\n+  assert(opaque4->Opcode() == Op_Opaque4, \"must be Opaque4\");\n+  to_clone.push(opaque4, 1);\n@@ -1498,1 +1500,1 @@\n-    if (skeleton_follow_inputs(m)) {\n+    if (is_part_of_template_assertion_predicate_bool(m)) {\n@@ -1556,5 +1558,6 @@\n-\/\/ Clone a skeleton predicate for the main loop. new_init and new_stride are set as new inputs. Since the predicates cannot fail at runtime,\n-\/\/ Halt nodes are inserted instead of uncommon traps.\n-Node* PhaseIdealLoop::clone_skeleton_predicate_and_initialize(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj,\n-                                                              Node* control, IdealLoopTree* outer_loop, Node* input_proj) {\n-  Node* result = clone_skeleton_predicate_bool(iff, new_init, new_stride, control);\n+\/\/ Clone an Assertion Predicate for the main loop. new_init and new_stride are set as new inputs. Since the predicates\n+\/\/ cannot fail at runtime, Halt nodes are inserted instead of uncommon traps.\n+Node* PhaseIdealLoop::clone_assertion_predicate_and_initialize(Node* iff, Node* new_init, Node* new_stride, Node* predicate,\n+                                                               Node* uncommon_proj, Node* control, IdealLoopTree* outer_loop,\n+                                                               Node* input_proj) {\n+  Node* result = create_bool_from_template_assertion_predicate(iff, new_init, new_stride, control);\n@@ -1569,1 +1572,1 @@\n-  \/\/ It's impossible for the predicate to fail at runtime. Use an Halt node.\n+  \/\/ It's impossible for the predicate to fail at runtime. Use a Halt node.\n@@ -1581,5 +1584,7 @@\n-void PhaseIdealLoop::copy_skeleton_predicates_to_main_loop(CountedLoopNode* pre_head, Node* init, Node* stride,\n-                                          IdealLoopTree* outer_loop, LoopNode* outer_main_head,\n-                                          uint dd_main_head, const uint idx_before_pre_post,\n-                                          const uint idx_after_post_before_pre, Node* zero_trip_guard_proj_main,\n-                                          Node* zero_trip_guard_proj_post, const Node_List &old_new) {\n+void PhaseIdealLoop::copy_assertion_predicates_to_main_loop(CountedLoopNode* pre_head, Node* init, Node* stride,\n+                                                            IdealLoopTree* outer_loop, LoopNode* outer_main_head,\n+                                                            const uint dd_main_head, const uint idx_before_pre_post,\n+                                                            const uint idx_after_post_before_pre,\n+                                                            Node* zero_trip_guard_proj_main,\n+                                                            Node* zero_trip_guard_proj_post,\n+                                                            const Node_List &old_new) {\n@@ -1591,1 +1596,1 @@\n-      entry = skip_loop_predicates(entry);\n+      entry = skip_related_predicates(entry);\n@@ -1597,1 +1602,1 @@\n-        entry = skip_loop_predicates(entry);\n+        entry = skip_related_predicates(entry);\n@@ -1601,6 +1606,6 @@\n-    copy_skeleton_predicates_to_main_loop_helper(predicate, init, stride, outer_loop, outer_main_head, dd_main_head,\n-                                                 idx_before_pre_post, idx_after_post_before_pre, zero_trip_guard_proj_main,\n-                                                 zero_trip_guard_proj_post, old_new);\n-    copy_skeleton_predicates_to_main_loop_helper(profile_predicate, init, stride, outer_loop, outer_main_head, dd_main_head,\n-                                                 idx_before_pre_post, idx_after_post_before_pre, zero_trip_guard_proj_main,\n-                                                 zero_trip_guard_proj_post, old_new);\n+    copy_assertion_predicates_to_main_loop_helper(predicate, init, stride, outer_loop, outer_main_head, dd_main_head,\n+                                                  idx_before_pre_post, idx_after_post_before_pre, zero_trip_guard_proj_main,\n+                                                  zero_trip_guard_proj_post, old_new);\n+    copy_assertion_predicates_to_main_loop_helper(profile_predicate, init, stride, outer_loop, outer_main_head, dd_main_head,\n+                                                  idx_before_pre_post, idx_after_post_before_pre, zero_trip_guard_proj_main,\n+                                                  zero_trip_guard_proj_post, old_new);\n@@ -1756,3 +1761,4 @@\n-  copy_skeleton_predicates_to_main_loop(pre_head, castii, stride, outer_loop, outer_main_head, dd_main_head,\n-                                        idx_before_pre_post, idx_after_post_before_pre, min_taken, post_head->in(1), old_new);\n-  copy_skeleton_predicates_to_post_loop(outer_main_head, post_head, post_incr, stride);\n+  copy_assertion_predicates_to_main_loop(pre_head, castii, stride, outer_loop, outer_main_head, dd_main_head,\n+                                         idx_before_pre_post, idx_after_post_before_pre, min_taken, post_head->in(1),\n+                                         old_new);\n+  copy_assertion_predicates_to_post_loop(outer_main_head, post_head, post_incr, stride);\n@@ -1881,1 +1887,1 @@\n-  copy_skeleton_predicates_to_post_loop(main_head->skip_strip_mined(), post_head, incr, main_head->stride());\n+  copy_assertion_predicates_to_post_loop(main_head->skip_strip_mined(), post_head, incr, main_head->stride());\n@@ -1928,1 +1934,1 @@\n-  copy_skeleton_predicates_to_post_loop(main_head->skip_strip_mined(), post_head, incr, main_head->stride());\n+  copy_assertion_predicates_to_post_loop(main_head->skip_strip_mined(), post_head, incr, main_head->stride());\n@@ -2045,1 +2051,4 @@\n-void PhaseIdealLoop::update_main_loop_skeleton_predicates(Node* ctrl, CountedLoopNode* loop_head, Node* init, int stride_con) {\n+\/\/ Search the Assertion Predicates added by loop predication and\/or range check elimination and update them according\n+\/\/ to the new stride.\n+void PhaseIdealLoop::update_main_loop_assertion_predicates(Node* ctrl, CountedLoopNode* loop_head, Node* init,\n+                                                           const int stride_con) {\n@@ -2052,1 +2061,0 @@\n-  \/\/ Search for skeleton predicates and update them according to the new stride\n@@ -2071,6 +2079,8 @@\n-      \/\/ Look for predicate with an Opaque1 node that can be used as a template\n-      if (!skeleton_predicate_has_opaque(iff)) {\n-        \/\/ No Opaque1 node? It's either the check for the first value\n-        \/\/ of the first iteration or the check for the last value of\n-        \/\/ the first iteration of an unrolled loop. We can't\n-        \/\/ tell. Kill it in any case.\n+      if (!assertion_predicate_has_loop_opaque_node(iff)) {\n+        \/\/ No OpaqueLoop* node? Then it's one of the two Initialized Assertion Predicates:\n+        \/\/ - For the initial access a[init]\n+        \/\/ - For the last access a[init+old_stride-orig_stride]\n+        \/\/ We could keep the one for the initial access but we do not know which one we currently have here. Just kill both.\n+        \/\/ We will create new Initialized Assertion Predicates from the Template Assertion Predicates below:\n+        \/\/ - For the initial access a[init] (same as before)\n+        \/\/ - For the last access a[init+new_stride-orig_stride] (with the new unroll stride)\n@@ -2079,4 +2089,4 @@\n-        \/\/ Add back predicates updated for the new stride.\n-        prev_proj = clone_skeleton_predicate_and_initialize(iff, init, max_value, entry, proj, ctrl, outer_loop,\n-                                                            prev_proj);\n-        assert(!skeleton_predicate_has_opaque(prev_proj->in(0)->as_If()), \"unexpected\");\n+        \/\/ Template Assertion Predicate: Clone it to create initialized version with new stride.\n+        prev_proj = clone_assertion_predicate_and_initialize(iff, init, max_value, entry, proj, ctrl, outer_loop,\n+                                                             prev_proj);\n+        assert(!assertion_predicate_has_loop_opaque_node(prev_proj->in(0)->as_If()), \"unexpected\");\n@@ -2093,3 +2103,4 @@\n-void PhaseIdealLoop::copy_skeleton_predicates_to_post_loop(LoopNode* main_loop_head, CountedLoopNode* post_loop_head, Node* init, Node* stride) {\n-  \/\/ Go over the skeleton predicates of the main loop and make a copy for the post loop with its initial iv value and\n-  \/\/ stride as inputs.\n+\/\/ Go over the Assertion Predicates of the main loop and make a copy for the post loop with its initial iv value and\n+\/\/ stride as inputs.\n+void PhaseIdealLoop::copy_assertion_predicates_to_post_loop(LoopNode* main_loop_head, CountedLoopNode* post_loop_head,\n+                                                            Node* init, Node* stride) {\n@@ -2108,4 +2119,4 @@\n-    if (iff->in(1)->Opcode() == Op_Opaque4 && skeleton_predicate_has_opaque(iff)) {\n-      prev_proj = clone_skeleton_predicate_and_initialize(iff, init, stride, ctrl, proj, post_loop_entry,\n-                                                          post_loop, prev_proj);\n-      assert(!skeleton_predicate_has_opaque(prev_proj->in(0)->as_If()), \"unexpected\");\n+    if (iff->in(1)->Opcode() == Op_Opaque4 && assertion_predicate_has_loop_opaque_node(iff)) {\n+      prev_proj = clone_assertion_predicate_and_initialize(iff, init, stride, ctrl, proj, post_loop_entry,\n+                                                           post_loop, prev_proj);\n+      assert(!assertion_predicate_has_loop_opaque_node(prev_proj->in(0)->as_If()), \"unexpected\");\n@@ -2121,9 +2132,6 @@\n-void PhaseIdealLoop::initialize_skeleton_predicates_for_peeled_loop(ProjNode* predicate,\n-                                                                    LoopNode* outer_loop_head,\n-                                                                    int dd_outer_loop_head,\n-                                                                    Node* init,\n-                                                                    Node* stride,\n-                                                                    IdealLoopTree* outer_loop,\n-                                                                    const uint idx_before_clone,\n-                                                                    const Node_List &old_new) {\n-  if (predicate == nullptr) {\n+void PhaseIdealLoop::initialize_assertion_predicates_for_peeled_loop(IfProjNode* predicate_proj, LoopNode* outer_loop_head,\n+                                                                     const int dd_outer_loop_head, Node* init,\n+                                                                     Node* stride, IdealLoopTree* outer_loop,\n+                                                                     const uint idx_before_clone,\n+                                                                     const Node_List &old_new) {\n+  if (predicate_proj == nullptr) {\n@@ -2135,3 +2143,3 @@\n-  predicate = next_predicate(predicate);\n-  while (predicate != nullptr) {\n-    IfNode* iff = predicate->in(0)->as_If();\n+  predicate_proj = next_predicate(predicate_proj);\n+  while (predicate_proj != nullptr) {\n+    IfNode* iff = predicate_proj->in(0)->as_If();\n@@ -2139,8 +2147,9 @@\n-      assert(skeleton_predicate_has_opaque(iff), \"unexpected\");\n-      ProjNode* uncommon_proj = iff->proj_out(1 - predicate->as_Proj()->_con);\n-      input_proj = clone_skeleton_predicate_and_initialize(iff, init, stride, predicate, uncommon_proj, control, outer_loop, input_proj);\n-\n-      \/\/ Rewire any control inputs from the old skeleton predicates above the peeled iteration down to the initialized\n-      \/\/ skeleton predicates above the peeled loop.\n-      for (DUIterator i = predicate->outs(); predicate->has_out(i); i++) {\n-        Node* dependent = predicate->out(i);\n+      assert(assertion_predicate_has_loop_opaque_node(iff), \"unexpected\");\n+      ProjNode* uncommon_proj = iff->proj_out(1 - predicate_proj->as_Proj()->_con);\n+      input_proj = clone_assertion_predicate_and_initialize(iff, init, stride, predicate_proj, uncommon_proj, control,\n+                                                            outer_loop, input_proj);\n+\n+      \/\/ Rewire any control inputs from the old Assertion Predicates above the peeled iteration down to the initialized\n+      \/\/ Assertion Predicates above the peeled loop.\n+      for (DUIterator i = predicate_proj->outs(); predicate_proj->has_out(i); i++) {\n+        Node* dependent = predicate_proj->out(i);\n@@ -2154,1 +2163,1 @@\n-          \/\/ We need to rewire the dependencies to the newly initialized skeleton predicates.\n+          \/\/ We need to rewire the dependencies to the newly Initialized Assertion Predicates.\n@@ -2160,1 +2169,1 @@\n-    predicate = next_predicate(predicate);\n+    predicate_proj = next_predicate(predicate_proj);\n@@ -2230,1 +2239,1 @@\n-  update_main_loop_skeleton_predicates(ctrl, loop_head, init, stride_con);\n+  update_main_loop_assertion_predicates(ctrl, loop_head, init, stride_con);\n@@ -2855,3 +2864,4 @@\n-Node* PhaseIdealLoop::add_range_check_predicate(IdealLoopTree* loop, CountedLoopNode* cl,\n-                                                Node* predicate_proj, int scale_con, Node* offset,\n-                                                Node* limit, jint stride_con, Node* value) {\n+Node* PhaseIdealLoop::add_range_check_elimination_assertion_predicate(IdealLoopTree* loop,\n+                                                                      Node* ctrl, const int scale_con,\n+                                                                      Node* offset, Node* limit, jint stride_con,\n+                                                                      Node* value) {\n@@ -2859,1 +2869,2 @@\n-  BoolNode* bol = rc_predicate(loop, predicate_proj, scale_con, offset, value, nullptr, stride_con, limit, (stride_con > 0) != (scale_con > 0), overflow, false);\n+  BoolNode* bol = rc_predicate(loop, ctrl, scale_con, offset, value, nullptr, stride_con,\n+                               limit, (stride_con > 0) != (scale_con > 0), overflow, false);\n@@ -2861,1 +2872,1 @@\n-  register_new_node(opaque_bol, predicate_proj);\n+  register_new_node(opaque_bol, ctrl);\n@@ -2864,1 +2875,1 @@\n-    new_iff = new IfNode(predicate_proj, opaque_bol, PROB_MAX, COUNT_UNKNOWN);\n+    new_iff = new IfNode(ctrl, opaque_bol, PROB_MAX, COUNT_UNKNOWN);\n@@ -2866,1 +2877,1 @@\n-    new_iff = new RangeCheckNode(predicate_proj, opaque_bol, PROB_MAX, COUNT_UNKNOWN);\n+    new_iff = new RangeCheckNode(ctrl, opaque_bol, PROB_MAX, COUNT_UNKNOWN);\n@@ -2868,1 +2879,1 @@\n-  register_control(new_iff, loop->_parent, predicate_proj);\n+  register_control(new_iff, loop->_parent, ctrl);\n@@ -2959,2 +2970,2 @@\n-  Node* predicate_proj = cl->skip_strip_mined()->in(LoopNode::EntryControl);\n-  assert(predicate_proj->is_Proj() && predicate_proj->in(0)->is_If(), \"if projection only\");\n+  Node* loop_entry = cl->skip_strip_mined()->in(LoopNode::EntryControl);\n+  assert(loop_entry->is_Proj() && loop_entry->in(0)->is_If(), \"if projection only\");\n@@ -3057,1 +3068,1 @@\n-          register_new_node(opaque_init, predicate_proj);\n+          register_new_node(opaque_init, loop_entry);\n@@ -3059,3 +3070,4 @@\n-          \/\/ predicate on first value of first iteration\n-          predicate_proj = add_range_check_predicate(loop, cl, predicate_proj, scale_con, int_offset, int_limit, stride_con, init);\n-          assert(!skeleton_predicate_has_opaque(predicate_proj->in(0)->as_If()), \"unexpected\");\n+          \/\/ Initialized Assertion Predicate for the value of the initial main-loop.\n+          loop_entry = add_range_check_elimination_assertion_predicate(loop, loop_entry, scale_con, int_offset,\n+                                                                       int_limit, stride_con, init);\n+          assert(!assertion_predicate_has_loop_opaque_node(loop_entry->in(0)->as_If()), \"unexpected\");\n@@ -3063,3 +3075,5 @@\n-          \/\/ template predicate so it can be updated on next unrolling\n-          predicate_proj = add_range_check_predicate(loop, cl, predicate_proj, scale_con, int_offset, int_limit, stride_con, opaque_init);\n-          assert(skeleton_predicate_has_opaque(predicate_proj->in(0)->as_If()), \"unexpected\");\n+          \/\/ Add two Template Assertion Predicates to create new Initialized Assertion Predicates from when either\n+          \/\/ unrolling or splitting this main-loop further.\n+          loop_entry = add_range_check_elimination_assertion_predicate(loop, loop_entry, scale_con, int_offset,\n+                                                                       int_limit, stride_con, opaque_init);\n+          assert(assertion_predicate_has_loop_opaque_node(loop_entry->in(0)->as_If()), \"unexpected\");\n@@ -3068,1 +3082,1 @@\n-          register_new_node(opaque_stride, predicate_proj);\n+          register_new_node(opaque_stride, loop_entry);\n@@ -3070,1 +3084,1 @@\n-          register_new_node(max_value, predicate_proj);\n+          register_new_node(max_value, loop_entry);\n@@ -3072,1 +3086,1 @@\n-          register_new_node(max_value, predicate_proj);\n+          register_new_node(max_value, loop_entry);\n@@ -3075,3 +3089,4 @@\n-          register_new_node(max_value, predicate_proj);\n-          predicate_proj = add_range_check_predicate(loop, cl, predicate_proj, scale_con, int_offset, int_limit, stride_con, max_value);\n-          assert(skeleton_predicate_has_opaque(predicate_proj->in(0)->as_If()), \"unexpected\");\n+          register_new_node(max_value, loop_entry);\n+          loop_entry = add_range_check_elimination_assertion_predicate(loop, loop_entry, scale_con, int_offset,\n+                                                                       int_limit, stride_con, max_value);\n+          assert(assertion_predicate_has_loop_opaque_node(loop_entry->in(0)->as_If()), \"unexpected\");\n@@ -3139,3 +3154,3 @@\n-  if (predicate_proj != cl->skip_strip_mined()->in(LoopNode::EntryControl)) {\n-    _igvn.replace_input_of(cl->skip_strip_mined(), LoopNode::EntryControl, predicate_proj);\n-    set_idom(cl->skip_strip_mined(), predicate_proj, dom_depth(cl->skip_strip_mined()));\n+  if (loop_entry != cl->skip_strip_mined()->in(LoopNode::EntryControl)) {\n+    _igvn.replace_input_of(cl->skip_strip_mined(), LoopNode::EntryControl, loop_entry);\n+    set_idom(cl->skip_strip_mined(), loop_entry, dom_depth(cl->skip_strip_mined()));\n@@ -3522,3 +3537,3 @@\n-    Node* inctrl = PhaseIdealLoop::skip_all_loop_predicates(cl->skip_predicates());\n-    if (inctrl->Opcode() == Op_IfTrue || inctrl->Opcode() == Op_IfFalse) {\n-      bool maybe_swapped = (inctrl->Opcode() == Op_IfFalse);\n+    Node* in_ctrl = PhaseIdealLoop::skip_all_predicates(cl->skip_predicates());\n+    if (in_ctrl->Opcode() == Op_IfTrue || in_ctrl->Opcode() == Op_IfFalse) {\n+      bool maybe_swapped = (in_ctrl->Opcode() == Op_IfFalse);\n@@ -3526,1 +3541,1 @@\n-      Node* iff = inctrl->in(0);\n+      Node* iff = in_ctrl->in(0);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":161,"deletions":146,"binary":false,"changes":307,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-\/\/  predicate                      predicate\n+\/\/  predicates                     predicates\n@@ -44,1 +44,1 @@\n-\/\/    endif                        predicate [clone]\n+\/\/    endif                        predicates [clone]\n@@ -128,3 +128,3 @@\n-      \/\/ Bailout if there are loop predicates from which there are additional control dependencies (i.e. from\n-      \/\/ loop entry 'entry') to previously partially peeled statements since this case is not handled and can lead\n-      \/\/ to wrong execution. Remove this bailout, once this is fixed.\n+      \/\/ Bailout if there are predicates from which there are additional control dependencies (i.e. from loop\n+      \/\/ entry 'entry') to previously partially peeled statements since this case is not handled and can lead\n+      \/\/ to a wrong execution. Remove this bailout, once this is fixed.\n@@ -157,3 +157,3 @@\n-  Node* predicate = find_predicate(entry);\n-  if (predicate == nullptr) {\n-    \/\/ No empty predicate\n+  Node* parse_predicate = find_parse_predicate(entry);\n+  if (parse_predicate == nullptr) {\n+    \/\/ No Parse Predicate.\n@@ -164,1 +164,1 @@\n-    \/\/ There is at least one empty predicate. When calling 'skip_loop_predicates' on each found empty predicate,\n+    \/\/ There is at least one Parse Predicate. When calling 'skip_related_predicates' on each found Parse Predicate,\n@@ -166,1 +166,1 @@\n-    Node* proj_before_first_empty_predicate = skip_loop_predicates(entry);\n+    Node* proj_before_first_parse_predicate = skip_related_predicates(entry);\n@@ -168,3 +168,3 @@\n-      predicate = find_predicate(proj_before_first_empty_predicate);\n-      if (predicate != nullptr) {\n-        proj_before_first_empty_predicate = skip_loop_predicates(predicate);\n+      parse_predicate = find_parse_predicate(proj_before_first_parse_predicate);\n+      if (parse_predicate != nullptr) {\n+        proj_before_first_parse_predicate = skip_related_predicates(parse_predicate);\n@@ -174,3 +174,3 @@\n-      predicate = find_predicate(proj_before_first_empty_predicate);\n-      if (predicate != nullptr) {\n-        proj_before_first_empty_predicate = skip_loop_predicates(predicate);\n+      parse_predicate = find_parse_predicate(proj_before_first_parse_predicate);\n+      if (parse_predicate != nullptr) {\n+        proj_before_first_parse_predicate = skip_related_predicates(parse_predicate);\n@@ -179,1 +179,1 @@\n-    assert(proj_true == proj_before_first_empty_predicate, \"must hold by construction if at least one predicate\");\n+    assert(proj_true == proj_before_first_parse_predicate, \"must hold by construction if at least one predicate\");\n@@ -261,1 +261,1 @@\n-  ProjNode* iffast = new IfTrueNode(iff);\n+  IfProjNode* iffast = new IfTrueNode(iff);\n@@ -263,1 +263,1 @@\n-  ProjNode* ifslow = new IfFalseNode(iff);\n+  IfProjNode* ifslow = new IfFalseNode(iff);\n@@ -273,3 +273,3 @@\n-  ProjNode* iffast_pred = iffast;\n-  ProjNode* ifslow_pred = ifslow;\n-  clone_predicates_to_unswitched_loop(loop, old_new, iffast_pred, ifslow_pred);\n+  IfProjNode* iffast_pred = iffast;\n+  IfProjNode* ifslow_pred = ifslow;\n+  clone_parse_and_assertion_predicates_to_unswitched_loop(loop, old_new, iffast_pred, ifslow_pred);\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -344,2 +344,3 @@\n-void PhaseIdealLoop::insert_loop_limit_check(ProjNode* limit_check_proj, Node* cmp_limit, Node* bol) {\n-  Node* new_predicate_proj = create_new_if_for_predicate(limit_check_proj, nullptr,\n+void PhaseIdealLoop::insert_loop_limit_check_predicate(ParsePredicateSuccessProj* loop_limit_check_parse_proj,\n+                                                       Node* cmp_limit, Node* bol) {\n+  Node* new_predicate_proj = create_new_if_for_predicate(loop_limit_check_parse_proj, nullptr,\n@@ -559,1 +560,3 @@\n-void PhaseIdealLoop::add_empty_predicate(Deoptimization::DeoptReason reason, Node* inner_head, IdealLoopTree* loop, SafePointNode* sfpt) {\n+\/\/ Add a Parse Predicate with an uncommon trap on the failing\/false path. Normal control will continue on the true path.\n+void PhaseIdealLoop::add_parse_predicate(Deoptimization::DeoptReason reason, Node* inner_head, IdealLoopTree* loop,\n+                                         SafePointNode* sfpt) {\n@@ -573,1 +576,1 @@\n-    C->add_predicate_opaq(opq);\n+    C->add_parse_predicate_opaq(opq);\n@@ -867,1 +870,1 @@\n-  \/\/ We need a safepoint to insert empty predicates for the inner loop.\n+  \/\/ We need a safepoint to insert Parse Predicates for the inner loop.\n@@ -1047,1 +1050,1 @@\n-  \/\/ of the peeled iteration to insert empty predicates. If no well\n+  \/\/ of the peeled iteration to insert Parse Predicates. If no well\n@@ -1061,1 +1064,1 @@\n-      add_empty_predicate(Deoptimization::Reason_predicate, inner_head, outer_ilt, cloned_sfpt);\n+      add_parse_predicate(Deoptimization::Reason_predicate, inner_head, outer_ilt, cloned_sfpt);\n@@ -1064,1 +1067,1 @@\n-      add_empty_predicate(Deoptimization::Reason_profile_predicate, inner_head, outer_ilt, cloned_sfpt);\n+      add_parse_predicate(Deoptimization::Reason_profile_predicate, inner_head, outer_ilt, cloned_sfpt);\n@@ -1066,1 +1069,1 @@\n-    add_empty_predicate(Deoptimization::Reason_loop_limit_check, inner_head, outer_ilt, cloned_sfpt);\n+    add_parse_predicate(Deoptimization::Reason_loop_limit_check, inner_head, outer_ilt, cloned_sfpt);\n@@ -1788,2 +1791,3 @@\n-    ProjNode *limit_check_proj = find_predicate_insertion_point(init_control, Deoptimization::Reason_loop_limit_check);\n-    if (!limit_check_proj) {\n+    ParsePredicateSuccessProj* loop_limit_check_predicate_parse_proj =\n+        find_predicate_insertion_point(init_control, Deoptimization::Reason_loop_limit_check);\n+    if (loop_limit_check_predicate_parse_proj == nullptr) {\n@@ -1801,1 +1805,1 @@\n-    IfNode* check_iff = limit_check_proj->in(0)->as_If();\n+    IfNode* check_iff = loop_limit_check_predicate_parse_proj->in(0)->as_If();\n@@ -1818,1 +1822,1 @@\n-    insert_loop_limit_check(limit_check_proj, cmp_limit, bol);\n+    insert_loop_limit_check_predicate(loop_limit_check_predicate_parse_proj, cmp_limit, bol);\n@@ -1831,2 +1835,3 @@\n-      ProjNode *limit_check_proj = find_predicate_insertion_point(init_control, Deoptimization::Reason_loop_limit_check);\n-      if (!limit_check_proj) {\n+      ParsePredicateSuccessProj* loop_limit_check_predicate_parse_proj =\n+          find_predicate_insertion_point(init_control, Deoptimization::Reason_loop_limit_check);\n+      if (loop_limit_check_predicate_parse_proj == nullptr) {\n@@ -1843,1 +1848,1 @@\n-      IfNode* check_iff = limit_check_proj->in(0)->as_If();\n+      IfNode* check_iff = loop_limit_check_predicate_parse_proj->in(0)->as_If();\n@@ -1861,1 +1866,1 @@\n-      insert_loop_limit_check(limit_check_proj, cmp_limit, bol);\n+      insert_loop_limit_check_predicate(loop_limit_check_predicate_parse_proj, cmp_limit, bol);\n@@ -3955,1 +3960,1 @@\n-    entry = PhaseIdealLoop::skip_loop_predicates(entry);\n+    entry = PhaseIdealLoop::skip_related_predicates(entry);\n@@ -3961,1 +3966,1 @@\n-      entry = PhaseIdealLoop::skip_loop_predicates(entry);\n+      entry = PhaseIdealLoop::skip_related_predicates(entry);\n@@ -4080,1 +4085,1 @@\n-      entry = skip_loop_predicates(entry);\n+      entry = skip_related_predicates(entry);\n@@ -4086,2 +4091,2 @@\n-        get_skeleton_predicates(entry, useful_predicates, true);\n-        entry = skip_loop_predicates(entry);\n+        get_assertion_predicates(entry, useful_predicates, true);\n+        entry = skip_related_predicates(entry);\n@@ -4095,1 +4100,1 @@\n-        get_skeleton_predicates(entry, useful_predicates, true);\n+        get_assertion_predicates(entry, useful_predicates, true);\n@@ -4110,1 +4115,1 @@\n-  if (C->predicate_count() == 0 && C->skeleton_predicate_count() == 0) {\n+  if (C->parse_predicate_count() == 0 && C->template_assertion_predicate_count() == 0) {\n@@ -4119,2 +4124,2 @@\n-  for (int i = C->predicate_count(); i > 0; i--) {\n-     Node* n = C->predicate_opaque1_node(i - 1);\n+  for (int i = C->parse_predicate_count(); i > 0; i--) {\n+     Node* n = C->parse_predicate_opaque1_node(i - 1);\n@@ -4127,2 +4132,2 @@\n-  for (int i = C->skeleton_predicate_count(); i > 0; i--) {\n-    Node* n = C->skeleton_predicate_opaque4_node(i - 1);\n+  for (int i = C->template_assertion_predicate_count(); i > 0; i--) {\n+    Node* n = C->template_assertion_predicate_opaq_node(i - 1);\n@@ -4528,1 +4533,1 @@\n-  if (C->has_loops() && !C->major_progress() && (C->predicate_count() > 0)) {\n+  if (C->has_loops() && !C->major_progress() && (C->parse_predicate_count() > 0)) {\n@@ -4580,2 +4585,2 @@\n-  if (!C->major_progress() && (C->predicate_count() > 0)) {\n-     C->cleanup_loop_predicates(_igvn);\n+  if (!C->major_progress() && (C->parse_predicate_count() > 0)) {\n+     C->cleanup_parse_predicates(_igvn);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":36,"deletions":31,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -943,10 +943,12 @@\n-  void copy_skeleton_predicates_to_main_loop_helper(Node* predicate, Node* init, Node* stride, IdealLoopTree* outer_loop, LoopNode* outer_main_head,\n-                                                    uint dd_main_head, const uint idx_before_pre_post, const uint idx_after_post_before_pre,\n-                                                    Node* zero_trip_guard_proj_main, Node* zero_trip_guard_proj_post, const Node_List &old_new);\n-  void copy_skeleton_predicates_to_main_loop(CountedLoopNode* pre_head, Node* init, Node* stride, IdealLoopTree* outer_loop, LoopNode* outer_main_head,\n-                                             uint dd_main_head, const uint idx_before_pre_post, const uint idx_after_post_before_pre,\n-                                             Node* zero_trip_guard_proj_main, Node* zero_trip_guard_proj_post, const Node_List &old_new);\n-  Node* clone_skeleton_predicate_and_initialize(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj, Node* control,\n-                                                IdealLoopTree* outer_loop, Node* input_proj);\n-  Node* clone_skeleton_predicate_bool(Node* iff, Node* new_init, Node* new_stride, Node* control);\n-  static bool skeleton_predicate_has_opaque(IfNode* iff);\n+  void copy_assertion_predicates_to_main_loop_helper(Node* predicate, Node* init, Node* stride, IdealLoopTree* outer_loop,\n+                                                     LoopNode* outer_main_head, uint dd_main_head,\n+                                                     uint idx_before_pre_post, uint idx_after_post_before_pre,\n+                                                     Node* zero_trip_guard_proj_main, Node* zero_trip_guard_proj_post,\n+                                                     const Node_List &old_new);\n+  void copy_assertion_predicates_to_main_loop(CountedLoopNode* pre_head, Node* init, Node* stride, IdealLoopTree* outer_loop,\n+                                              LoopNode* outer_main_head, uint dd_main_head, uint idx_before_pre_post,\n+                                              uint idx_after_post_before_pre, Node* zero_trip_guard_proj_main,\n+                                              Node* zero_trip_guard_proj_post, const Node_List& old_new);\n+  Node* clone_assertion_predicate_and_initialize(Node* iff, Node* new_init, Node* new_stride, Node* predicate,\n+                                                 Node* uncommon_proj, Node* control, IdealLoopTree* outer_loop,\n+                                                 Node* input_proj);\n@@ -955,7 +957,13 @@\n-  static void get_skeleton_predicates(Node* predicate, Unique_Node_List& list, bool get_opaque = false);\n-  void update_main_loop_skeleton_predicates(Node* ctrl, CountedLoopNode* loop_head, Node* init, int stride_con);\n-  void copy_skeleton_predicates_to_post_loop(LoopNode* main_loop_head, CountedLoopNode* post_loop_head, Node* init, Node* stride);\n-  void initialize_skeleton_predicates_for_peeled_loop(ProjNode* predicate, LoopNode* outer_loop_head, int dd_outer_loop_head,\n-                                                      Node* init, Node* stride, IdealLoopTree* outer_loop,\n-                                                      const uint idx_before_clone, const Node_List& old_new);\n-  void insert_loop_limit_check(ProjNode* limit_check_proj, Node* cmp_limit, Node* bol);\n+  Node* create_bool_from_template_assertion_predicate(Node* template_assertion_predicate, Node* new_init, Node* new_stride,\n+                                                      Node* control);\n+  static bool assertion_predicate_has_loop_opaque_node(IfNode* iff);\n+  static void get_assertion_predicates(Node* predicate, Unique_Node_List& list, bool get_opaque = false);\n+  void update_main_loop_assertion_predicates(Node* ctrl, CountedLoopNode* loop_head, Node* init, int stride_con);\n+  void copy_assertion_predicates_to_post_loop(LoopNode* main_loop_head, CountedLoopNode* post_loop_head, Node* init,\n+                                              Node* stride);\n+  void initialize_assertion_predicates_for_peeled_loop(IfProjNode* predicate_proj, LoopNode* outer_loop_head,\n+                                                       const int dd_outer_loop_head, Node* init, Node* stride,\n+                                                       IdealLoopTree* outer_loop, const uint idx_before_clone,\n+                                                       const Node_List& old_new);\n+  void insert_loop_limit_check_predicate(ParsePredicateSuccessProj* loop_limit_check_parse_proj, Node* cmp_limit,\n+                                         Node* bol);\n@@ -1220,1 +1228,1 @@\n-  void add_empty_predicate(Deoptimization::DeoptReason reason, Node* inner_head, IdealLoopTree* loop, SafePointNode* sfpt);\n+  void add_parse_predicate(Deoptimization::DeoptReason reason, Node* inner_head, IdealLoopTree* loop, SafePointNode* sfpt);\n@@ -1338,3 +1346,3 @@\n-  ProjNode* create_new_if_for_predicate(ProjNode* cont_proj, Node* new_entry, Deoptimization::DeoptReason reason,\n-                                        int opcode, bool rewire_uncommon_proj_phi_inputs = false,\n-                                        bool if_cont_is_true_proj = true);\n+  IfProjNode* create_new_if_for_predicate(IfProjNode* cont_proj, Node* new_entry, Deoptimization::DeoptReason reason,\n+                                          int opcode, bool rewire_uncommon_proj_phi_inputs = false,\n+                                          bool if_cont_is_true_proj = true);\n@@ -1355,3 +1363,3 @@\n-  static Node* skip_all_loop_predicates(Node* entry);\n-  static Node* skip_loop_predicates(Node* entry);\n-  static ProjNode* next_predicate(ProjNode* predicate);\n+  static Node* skip_all_predicates(Node* entry);\n+  static Node* skip_related_predicates(Node* entry);\n+  static IfProjNode* next_predicate(IfProjNode* predicate_proj);\n@@ -1360,4 +1368,9 @@\n-  static ProjNode* find_predicate_insertion_point(Node* start_c, Deoptimization::DeoptReason reason);\n-\n-  class Predicates {\n-  public:\n+  static ParsePredicateSuccessProj* find_predicate_insertion_point(Node* start_c, Deoptimization::DeoptReason reason);\n+\n+  class ParsePredicates {\n+   private:\n+    ParsePredicateSuccessProj* _loop_predicate = nullptr;\n+    ParsePredicateSuccessProj* _profiled_loop_predicate = nullptr;\n+    ParsePredicateSuccessProj* _loop_limit_check_predicate = nullptr;\n+    Node* _first_predicate = nullptr;\n+   public:\n@@ -1365,1 +1378,1 @@\n-    Predicates(Node* entry);\n+    ParsePredicates(Node* entry);\n@@ -1367,3 +1380,3 @@\n-    \/\/ Proj of empty loop limit check predicate\n-    ProjNode* loop_limit_check() {\n-      return _loop_limit_check;\n+    \/\/ Proj of Loop Limit Check Parse Predicate.\n+    ParsePredicateSuccessProj* loop_limit_check_predicate() {\n+      return _loop_limit_check_predicate;\n@@ -1372,3 +1385,3 @@\n-    \/\/ Proj of empty profile predicate\n-    ProjNode* profile_predicate() {\n-      return _profile_predicate;\n+    \/\/ Proj of Profile Loop Parse Predicate.\n+    ParsePredicateSuccessProj* profiled_loop_predicate() {\n+      return _profiled_loop_predicate;\n@@ -1377,3 +1390,3 @@\n-    \/\/ Proj of empty predicate\n-    ProjNode* predicate() {\n-      return _predicate;\n+    \/\/ Proj of Loop Parse Predicate.\n+    ParsePredicateSuccessProj* loop_predicate() {\n+      return _loop_predicate;\n@@ -1382,3 +1395,3 @@\n-    \/\/ First control node above all predicates\n-    Node* skip_all() {\n-      return _entry_to_all_predicates;\n+    \/\/ Proj of first Parse Predicate when walking the graph down from root.\n+    Node* get_first_predicate() {\n+      return _first_predicate;\n@@ -1386,6 +1399,0 @@\n-\n-  private:\n-    ProjNode*_loop_limit_check = nullptr;\n-    ProjNode* _profile_predicate = nullptr;\n-    ProjNode* _predicate = nullptr;\n-    Node* _entry_to_all_predicates = nullptr;\n@@ -1395,1 +1402,1 @@\n-  static Node* find_predicate(Node* entry);\n+  static Node* find_parse_predicate(Node* entry);\n@@ -1405,4 +1412,4 @@\n-  bool loop_predication_impl_helper(IdealLoopTree *loop, ProjNode* proj, ProjNode *predicate_proj,\n-                                    CountedLoopNode *cl, ConNode* zero, Invariance& invar,\n-                                    Deoptimization::DeoptReason reason);\n-  bool loop_predication_should_follow_branches(IdealLoopTree *loop, ProjNode *predicate_proj, float& loop_trip_cnt);\n+  bool loop_predication_impl_helper(IdealLoopTree* loop, IfProjNode* if_proj,\n+                                    ParsePredicateSuccessProj* parse_predicate_proj, CountedLoopNode* cl, ConNode* zero,\n+                                    Invariance& invar, Deoptimization::DeoptReason reason);\n+  bool loop_predication_should_follow_branches(IdealLoopTree* loop, IfProjNode* predicate_proj, float& loop_trip_cnt);\n@@ -1412,10 +1419,5 @@\n-  ProjNode* insert_initial_skeleton_predicate(IfNode* iff, IdealLoopTree *loop,\n-                                              ProjNode* proj, ProjNode *predicate_proj,\n-                                              ProjNode* upper_bound_proj,\n-                                              int scale, Node* offset,\n-                                              Node* init, Node* limit, jint stride,\n-                                              Node* rng, bool& overflow,\n-                                              Deoptimization::DeoptReason reason);\n-  Node* add_range_check_predicate(IdealLoopTree* loop, CountedLoopNode* cl,\n-                                  Node* predicate_proj, int scale_con, Node* offset,\n-                                  Node* limit, jint stride_con, Node* value);\n+  IfProjNode* add_template_assertion_predicate(IfNode* iff, IdealLoopTree* loop, IfProjNode* if_proj, IfProjNode* predicate_proj,\n+                                               IfProjNode* upper_bound_proj, int scale, Node* offset, Node* init, Node* limit,\n+                                               jint stride, Node* rng, bool& overflow, Deoptimization::DeoptReason reason);\n+  Node* add_range_check_elimination_assertion_predicate(IdealLoopTree* loop, Node* predicate_proj, int scale_con,\n+                                                        Node* offset, Node* limit, jint stride_con, Node* value);\n@@ -1667,10 +1669,12 @@\n-  \/\/ Clone loop predicates to slow and fast loop when unswitching a loop\n-  void clone_predicates_to_unswitched_loop(IdealLoopTree* loop, Node_List& old_new, ProjNode*& iffast_pred, ProjNode*& ifslow_pred);\n-  ProjNode* clone_predicate_to_unswitched_loop(ProjNode* predicate_proj, Node* new_entry,\n-                                               Deoptimization::DeoptReason reason, bool slow_loop);\n-  void clone_skeleton_predicates_to_unswitched_loop(IdealLoopTree* loop, const Node_List& old_new, Deoptimization::DeoptReason reason,\n-                                                    ProjNode* old_predicate_proj, ProjNode* iffast_pred, ProjNode* ifslow_pred);\n-  ProjNode* clone_skeleton_predicate_for_unswitched_loops(Node* iff, ProjNode* predicate,\n-                                                          Deoptimization::DeoptReason reason,\n-                                                          ProjNode* output_proj);\n-  static void check_created_predicate_for_unswitching(const Node* new_entry) PRODUCT_RETURN;\n+  \/\/ Clone Parse Predicates to slow and fast loop when unswitching a loop\n+  void clone_parse_and_assertion_predicates_to_unswitched_loop(IdealLoopTree* loop, Node_List& old_new,\n+                                                               IfProjNode*& iffast_pred, IfProjNode*& ifslow_pred);\n+  IfProjNode* clone_parse_predicate_to_unswitched_loop(ParsePredicateSuccessProj* predicate_proj, Node* new_entry,\n+                                                       Deoptimization::DeoptReason reason, bool slow_loop);\n+  void clone_assertion_predicates_to_unswitched_loop(IdealLoopTree* loop, const Node_List& old_new,\n+                                                     Deoptimization::DeoptReason reason, IfProjNode* old_predicate_proj,\n+                                                     IfProjNode* iffast_pred, IfProjNode* ifslow_pred);\n+  IfProjNode* clone_assertion_predicate_for_unswitched_loops(Node* iff, IfProjNode* predicate,\n+                                                             Deoptimization::DeoptReason reason,\n+                                                             IfProjNode* output_proj);\n+  static void check_cloned_parse_predicate_for_unswitching(const Node* new_entry) PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":76,"deletions":72,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -3290,1 +3290,1 @@\n-\/\/               loop predicate\n+\/\/                 predicates\n@@ -3325,1 +3325,1 @@\n-\/\/               loop predicate\n+\/\/                predicates\n@@ -3366,1 +3366,1 @@\n-\/\/               loop predicate\n+\/\/                predicates\n@@ -3410,1 +3410,1 @@\n-\/\/               loop predicate\n+\/\/                predicates\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -623,1 +623,1 @@\n-    compile->remove_skeleton_predicate_opaq(this);\n+    compile->remove_template_assertion_predicate_opaq(this);\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -678,1 +678,1 @@\n-            add_empty_predicates();\n+            add_parse_predicates();\n@@ -1698,1 +1698,1 @@\n-          \/\/ Add loop predicate for the special case when\n+          \/\/ Add Parse Predicates for the special case when\n@@ -1700,1 +1700,1 @@\n-          add_empty_predicates();\n+          add_parse_predicates();\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1583,1 +1583,1 @@\n-    add_empty_predicates();\n+    add_parse_predicates();\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,2 +104,2 @@\n-        assert(skeleton_predicate_has_opaque(m->as_If()), \"opaque node not reachable from if?\");\n-        Node* bol = clone_skeleton_predicate_bool(m, nullptr, nullptr, m->in(0));\n+        assert(assertion_predicate_has_loop_opaque_node(m->as_If()), \"opaque node not reachable from if?\");\n+        Node* bol = create_bool_from_template_assertion_predicate(m, nullptr, nullptr, m->in(0));\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1217,1 +1217,1 @@\n-  kit.add_empty_predicates();\n+  kit.add_parse_predicates();\n@@ -1302,2 +1302,2 @@\n-  \/\/ Add loop predicate first.\n-  kit.add_empty_predicates();\n+  \/\/ Add Parse Predicates first.\n+  kit.add_parse_predicates();\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}