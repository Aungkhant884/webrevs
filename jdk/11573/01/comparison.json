{"files":[{"patch":"@@ -144,1 +144,1 @@\n- * the given session (deopt) was closed. If the handshake for a given thread is processed while\n+ * the given scope (deopt) was closed. If the handshake for a given thread is processed while\n@@ -146,2 +146,2 @@\n- * class annotated with the '@Scoped' annotation), and whose local variables mention the session being\n- * closed (deopt), this method returns false, signalling that the session cannot be closed safely.\n+ * class annotated with the '@Scoped' annotation), and whose local variables mention the scope being\n+ * closed (deopt), this method returns false, signalling that the scope cannot be closed safely.\n","filename":"src\/hotspot\/share\/prims\/scopedMemoryAccess.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1635,1 +1635,1 @@\n-                        NIO_ACCESS.acquireSession(dst);\n+                        NIO_ACCESS.acquireScope(dst);\n@@ -1641,1 +1641,1 @@\n-                            NIO_ACCESS.releaseSession(dst);\n+                            NIO_ACCESS.releaseScope(dst);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1364,1 +1364,1 @@\n-            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n+            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.scopeImpl(), dstImpl.scopeImpl(),\n@@ -1368,1 +1368,1 @@\n-            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n+            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.scopeImpl(), dstImpl.scopeImpl(),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-                MemorySessionImpl.heapSession(loader);\n+                MemorySessionImpl.heapScope(loader);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -616,1 +616,1 @@\n-        static MemorySessionImpl session(ByteBuffer bb) {\n+        static MemorySessionImpl scope(ByteBuffer bb) {\n@@ -619,1 +619,1 @@\n-                    ((AbstractMemorySegmentImpl)segment).sessionImpl() : null;\n+                    ((AbstractMemorySegmentImpl)segment).scopeImpl() : null;\n@@ -642,1 +642,1 @@\n-            $rawType$ rawValue = SCOPED_MEMORY_ACCESS.get$RawType$Unaligned(session(bb),\n+            $rawType$ rawValue = SCOPED_MEMORY_ACCESS.get$RawType$Unaligned(scope(bb),\n@@ -648,1 +648,1 @@\n-            return SCOPED_MEMORY_ACCESS.get$Type$Unaligned(session(bb),\n+            return SCOPED_MEMORY_ACCESS.get$Type$Unaligned(scope(bb),\n@@ -660,1 +660,1 @@\n-            SCOPED_MEMORY_ACCESS.put$RawType$Unaligned(session(bb),\n+            SCOPED_MEMORY_ACCESS.put$RawType$Unaligned(scope(bb),\n@@ -666,1 +666,1 @@\n-            SCOPED_MEMORY_ACCESS.put$Type$Unaligned(session(bb),\n+            SCOPED_MEMORY_ACCESS.put$Type$Unaligned(scope(bb),\n@@ -679,1 +679,1 @@\n-                              SCOPED_MEMORY_ACCESS.get$RawType$Volatile(session(bb),\n+                              SCOPED_MEMORY_ACCESS.get$RawType$Volatile(scope(bb),\n@@ -688,1 +688,1 @@\n-            SCOPED_MEMORY_ACCESS.put$RawType$Volatile(session(bb),\n+            SCOPED_MEMORY_ACCESS.put$RawType$Volatile(scope(bb),\n@@ -699,1 +699,1 @@\n-                              SCOPED_MEMORY_ACCESS.get$RawType$Acquire(session(bb),\n+                              SCOPED_MEMORY_ACCESS.get$RawType$Acquire(scope(bb),\n@@ -708,1 +708,1 @@\n-            SCOPED_MEMORY_ACCESS.put$RawType$Release(session(bb),\n+            SCOPED_MEMORY_ACCESS.put$RawType$Release(scope(bb),\n@@ -719,1 +719,1 @@\n-                              SCOPED_MEMORY_ACCESS.get$RawType$Opaque(session(bb),\n+                              SCOPED_MEMORY_ACCESS.get$RawType$Opaque(scope(bb),\n@@ -728,1 +728,1 @@\n-            SCOPED_MEMORY_ACCESS.put$RawType$Opaque(session(bb),\n+            SCOPED_MEMORY_ACCESS.put$RawType$Opaque(scope(bb),\n@@ -740,1 +740,1 @@\n-            return SCOPED_MEMORY_ACCESS.compareAndSetReference(session(bb),\n+            return SCOPED_MEMORY_ACCESS.compareAndSetReference(scope(bb),\n@@ -745,1 +745,1 @@\n-            return SCOPED_MEMORY_ACCESS.compareAndSet$RawType$(session(bb),\n+            return SCOPED_MEMORY_ACCESS.compareAndSet$RawType$(scope(bb),\n@@ -757,1 +757,1 @@\n-                              SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$(session(bb),\n+                              SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$(scope(bb),\n@@ -768,1 +768,1 @@\n-                              SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Acquire(session(bb),\n+                              SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Acquire(scope(bb),\n@@ -779,1 +779,1 @@\n-                              SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Release(session(bb),\n+                              SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Release(scope(bb),\n@@ -789,1 +789,1 @@\n-            return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Plain(session(bb),\n+            return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Plain(scope(bb),\n@@ -799,1 +799,1 @@\n-            return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(session(bb),\n+            return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(scope(bb),\n@@ -809,1 +809,1 @@\n-            return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Acquire(session(bb),\n+            return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Acquire(scope(bb),\n@@ -819,1 +819,1 @@\n-            return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Release(session(bb),\n+            return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Release(scope(bb),\n@@ -831,1 +831,1 @@\n-                              SCOPED_MEMORY_ACCESS.getAndSetReference(session(bb),\n+                              SCOPED_MEMORY_ACCESS.getAndSetReference(scope(bb),\n@@ -837,1 +837,1 @@\n-                              SCOPED_MEMORY_ACCESS.getAndSet$RawType$(session(bb),\n+                              SCOPED_MEMORY_ACCESS.getAndSet$RawType$(scope(bb),\n@@ -849,1 +849,1 @@\n-                              SCOPED_MEMORY_ACCESS.getAndSet$RawType$Acquire(session(bb),\n+                              SCOPED_MEMORY_ACCESS.getAndSet$RawType$Acquire(scope(bb),\n@@ -860,1 +860,1 @@\n-                              SCOPED_MEMORY_ACCESS.getAndSet$RawType$Release(session(bb),\n+                              SCOPED_MEMORY_ACCESS.getAndSet$RawType$Release(scope(bb),\n@@ -873,1 +873,1 @@\n-                return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$(session(bb),\n+                return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$(scope(bb),\n@@ -887,1 +887,1 @@\n-                return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Acquire(session(bb),\n+                return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Acquire(scope(bb),\n@@ -901,1 +901,1 @@\n-                return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Release(session(bb),\n+                return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Release(scope(bb),\n@@ -916,1 +916,1 @@\n-                nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(session(bb), base, offset);\n+                nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(scope(bb), base, offset);\n@@ -930,1 +930,1 @@\n-                return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$(session(bb),\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$(scope(bb),\n@@ -944,1 +944,1 @@\n-                return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Release(session(bb),\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Release(scope(bb),\n@@ -958,1 +958,1 @@\n-                return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Acquire(session(bb),\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Acquire(scope(bb),\n@@ -973,1 +973,1 @@\n-                nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(session(bb), base, offset);\n+                nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(scope(bb), base, offset);\n@@ -985,1 +985,1 @@\n-                return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$(session(bb),\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$(scope(bb),\n@@ -999,1 +999,1 @@\n-                return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Release(session(bb),\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Release(scope(bb),\n@@ -1013,1 +1013,1 @@\n-                return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Acquire(session(bb),\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Acquire(scope(bb),\n@@ -1028,1 +1028,1 @@\n-                nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(session(bb), base, offset);\n+                nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(scope(bb), base, offset);\n@@ -1041,1 +1041,1 @@\n-                return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$(session(bb),\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$(scope(bb),\n@@ -1055,1 +1055,1 @@\n-                return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Release(session(bb),\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Release(scope(bb),\n@@ -1069,1 +1069,1 @@\n-                return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Acquire(session(bb),\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Acquire(scope(bb),\n@@ -1084,1 +1084,1 @@\n-                nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(session(bb), base, offset);\n+                nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(scope(bb), base, offset);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleByteArrayView.java.template","additions":41,"deletions":41,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-        $rawType$ rawValue = SCOPED_MEMORY_ACCESS.get$RawType$Unaligned(bb.sessionImpl(),\n+        $rawType$ rawValue = SCOPED_MEMORY_ACCESS.get$RawType$Unaligned(bb.scopeImpl(),\n@@ -138,1 +138,1 @@\n-        return SCOPED_MEMORY_ACCESS.get$Type$(bb.sessionImpl(),\n+        return SCOPED_MEMORY_ACCESS.get$Type$(bb.scopeImpl(),\n@@ -142,1 +142,1 @@\n-        return SCOPED_MEMORY_ACCESS.get$Type$Unaligned(bb.sessionImpl(),\n+        return SCOPED_MEMORY_ACCESS.get$Type$Unaligned(bb.scopeImpl(),\n@@ -155,1 +155,1 @@\n-        SCOPED_MEMORY_ACCESS.put$RawType$Unaligned(bb.sessionImpl(),\n+        SCOPED_MEMORY_ACCESS.put$RawType$Unaligned(bb.scopeImpl(),\n@@ -162,1 +162,1 @@\n-        SCOPED_MEMORY_ACCESS.put$Type$(bb.sessionImpl(),\n+        SCOPED_MEMORY_ACCESS.put$Type$(bb.scopeImpl(),\n@@ -167,1 +167,1 @@\n-        SCOPED_MEMORY_ACCESS.put$Type$Unaligned(bb.sessionImpl(),\n+        SCOPED_MEMORY_ACCESS.put$Type$Unaligned(bb.scopeImpl(),\n@@ -181,1 +181,1 @@\n-                          SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),\n+                          SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.scopeImpl(),\n@@ -190,1 +190,1 @@\n-        SCOPED_MEMORY_ACCESS.put$RawType$Volatile(bb.sessionImpl(),\n+        SCOPED_MEMORY_ACCESS.put$RawType$Volatile(bb.scopeImpl(),\n@@ -201,1 +201,1 @@\n-                          SCOPED_MEMORY_ACCESS.get$RawType$Acquire(bb.sessionImpl(),\n+                          SCOPED_MEMORY_ACCESS.get$RawType$Acquire(bb.scopeImpl(),\n@@ -210,1 +210,1 @@\n-        SCOPED_MEMORY_ACCESS.put$RawType$Release(bb.sessionImpl(),\n+        SCOPED_MEMORY_ACCESS.put$RawType$Release(bb.scopeImpl(),\n@@ -221,1 +221,1 @@\n-                          SCOPED_MEMORY_ACCESS.get$RawType$Opaque(bb.sessionImpl(),\n+                          SCOPED_MEMORY_ACCESS.get$RawType$Opaque(bb.scopeImpl(),\n@@ -230,1 +230,1 @@\n-        SCOPED_MEMORY_ACCESS.put$RawType$Opaque(bb.sessionImpl(),\n+        SCOPED_MEMORY_ACCESS.put$RawType$Opaque(bb.scopeImpl(),\n@@ -241,1 +241,1 @@\n-        return SCOPED_MEMORY_ACCESS.compareAndSet$RawType$(bb.sessionImpl(),\n+        return SCOPED_MEMORY_ACCESS.compareAndSet$RawType$(bb.scopeImpl(),\n@@ -252,1 +252,1 @@\n-                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$(bb.sessionImpl(),\n+                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$(bb.scopeImpl(),\n@@ -263,1 +263,1 @@\n-                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Acquire(bb.sessionImpl(),\n+                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Acquire(bb.scopeImpl(),\n@@ -274,1 +274,1 @@\n-                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Release(bb.sessionImpl(),\n+                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Release(bb.scopeImpl(),\n@@ -284,1 +284,1 @@\n-        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Plain(bb.sessionImpl(),\n+        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Plain(bb.scopeImpl(),\n@@ -294,1 +294,1 @@\n-        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),\n+        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.scopeImpl(),\n@@ -304,1 +304,1 @@\n-        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Acquire(bb.sessionImpl(),\n+        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Acquire(bb.scopeImpl(),\n@@ -314,1 +314,1 @@\n-        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Release(bb.sessionImpl(),\n+        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Release(bb.scopeImpl(),\n@@ -325,1 +325,1 @@\n-                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$(bb.sessionImpl(),\n+                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$(bb.scopeImpl(),\n@@ -336,1 +336,1 @@\n-                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$Acquire(bb.sessionImpl(),\n+                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$Acquire(bb.scopeImpl(),\n@@ -347,1 +347,1 @@\n-                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$Release(bb.sessionImpl(),\n+                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$Release(bb.scopeImpl(),\n@@ -360,1 +360,1 @@\n-            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$(bb.sessionImpl(),\n+            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$(bb.scopeImpl(),\n@@ -374,1 +374,1 @@\n-            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Acquire(bb.sessionImpl(),\n+            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Acquire(bb.scopeImpl(),\n@@ -388,1 +388,1 @@\n-            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Release(bb.sessionImpl(),\n+            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Release(bb.scopeImpl(),\n@@ -402,1 +402,1 @@\n-            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),base, offset);\n+            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.scopeImpl(),base, offset);\n@@ -404,1 +404,1 @@\n-        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),base, offset,\n+        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.scopeImpl(),base, offset,\n@@ -416,1 +416,1 @@\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$(bb.sessionImpl(),\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$(bb.scopeImpl(),\n@@ -430,1 +430,1 @@\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Release(bb.sessionImpl(),\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Release(bb.scopeImpl(),\n@@ -444,1 +444,1 @@\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Acquire(bb.sessionImpl(),\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Acquire(bb.scopeImpl(),\n@@ -458,1 +458,1 @@\n-            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),base, offset);\n+            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.scopeImpl(),base, offset);\n@@ -460,1 +460,1 @@\n-        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),base, offset,\n+        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.scopeImpl(),base, offset,\n@@ -470,1 +470,1 @@\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$(bb.sessionImpl(),\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$(bb.scopeImpl(),\n@@ -484,1 +484,1 @@\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Release(bb.sessionImpl(),\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Release(bb.scopeImpl(),\n@@ -498,1 +498,1 @@\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Acquire(bb.sessionImpl(),\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Acquire(bb.scopeImpl(),\n@@ -512,1 +512,1 @@\n-            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),base, offset);\n+            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.scopeImpl(),base, offset);\n@@ -514,1 +514,1 @@\n-        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),base, offset,\n+        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.scopeImpl(),base, offset,\n@@ -525,1 +525,1 @@\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$(bb.sessionImpl(),\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$(bb.scopeImpl(),\n@@ -539,1 +539,1 @@\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Release(bb.sessionImpl(),\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Release(bb.scopeImpl(),\n@@ -553,1 +553,1 @@\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Acquire(bb.sessionImpl(),\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Acquire(bb.scopeImpl(),\n@@ -567,1 +567,1 @@\n-            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),base, offset);\n+            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.scopeImpl(),base, offset);\n@@ -569,1 +569,1 @@\n-        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),base, offset,\n+        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.scopeImpl(),base, offset,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleSegmentView.java.template","additions":43,"deletions":43,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -764,1 +764,1 @@\n-    final MemorySessionImpl session() {\n+    final MemorySessionImpl scope() {\n@@ -766,1 +766,1 @@\n-            return ((AbstractMemorySegmentImpl)segment).sessionImpl();\n+            return ((AbstractMemorySegmentImpl)segment).scopeImpl();\n@@ -772,4 +772,4 @@\n-    final void checkSession() {\n-        MemorySessionImpl session = session();\n-        if (session != null) {\n-            session.checkValidState();\n+    final void checkScope() {\n+        MemorySessionImpl scope = scope();\n+        if (scope != null) {\n+            scope.checkValidState();\n@@ -829,2 +829,2 @@\n-                public void acquireSession(Buffer buffer) {\n-                    var scope = buffer.session();\n+                public void acquireScope(Buffer buffer) {\n+                    var scope = buffer.scope();\n@@ -837,1 +837,1 @@\n-                public void releaseSession(Buffer buffer) {\n+                public void releaseScope(Buffer buffer) {\n@@ -839,1 +839,1 @@\n-                        var scope = buffer.session();\n+                        var scope = buffer.scope();\n@@ -850,1 +850,1 @@\n-                    var scope = buffer.session();\n+                    var scope = buffer.scope();\n@@ -855,2 +855,2 @@\n-                public boolean hasSession(Buffer buffer) {\n-                    return buffer.session() != null;\n+                public boolean hasScope(Buffer buffer) {\n+                    return buffer.scope() != null;\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Buffer.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.session(), b.session(),\n+            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.scope(), b.scope(),\n@@ -66,1 +66,1 @@\n-            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.session(), b.session(),\n+            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.scope(), b.scope(),\n@@ -86,1 +86,1 @@\n-            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.session(), b.session(),\n+            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.scope(), b.scope(),\n@@ -106,1 +106,1 @@\n-            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.session(), b.session(),\n+            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.scope(), b.scope(),\n@@ -125,1 +125,1 @@\n-                i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.session(), b.session(),\n+                i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.scope(), b.scope(),\n@@ -164,1 +164,1 @@\n-            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.session(), b.session(),\n+            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.scope(), b.scope(),\n@@ -182,1 +182,1 @@\n-                i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.session(), b.session(),\n+                i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.scope(), b.scope(),\n","filename":"src\/java.base\/share\/classes\/java\/nio\/BufferMismatch.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-        $memtype$ x = SCOPED_MEMORY_ACCESS.get$Memtype$Unaligned(session(), bb.hb, byteOffset(nextGetIndex()),\n+        $memtype$ x = SCOPED_MEMORY_ACCESS.get$Memtype$Unaligned(scope(), bb.hb, byteOffset(nextGetIndex()),\n@@ -147,1 +147,1 @@\n-        $memtype$ x = SCOPED_MEMORY_ACCESS.get$Memtype$Unaligned(session(), bb.hb, byteOffset(checkIndex(i)),\n+        $memtype$ x = SCOPED_MEMORY_ACCESS.get$Memtype$Unaligned(scope(), bb.hb, byteOffset(checkIndex(i)),\n@@ -165,1 +165,1 @@\n-        SCOPED_MEMORY_ACCESS.put$Memtype$Unaligned(session(), bb.hb, byteOffset(nextPutIndex()), y,\n+        SCOPED_MEMORY_ACCESS.put$Memtype$Unaligned(scope(), bb.hb, byteOffset(nextPutIndex()), y,\n@@ -176,1 +176,1 @@\n-        SCOPED_MEMORY_ACCESS.put$Memtype$Unaligned(session(), bb.hb, byteOffset(checkIndex(i)), y,\n+        SCOPED_MEMORY_ACCESS.put$Memtype$Unaligned(scope(), bb.hb, byteOffset(checkIndex(i)), y,\n","filename":"src\/java.base\/share\/classes\/java\/nio\/ByteBufferAs-X-Buffer.java.template","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-            $memtype$ x = SCOPED_MEMORY_ACCESS.get$Memtype$Unaligned(session(), null, a, bigEndian);\n+            $memtype$ x = SCOPED_MEMORY_ACCESS.get$Memtype$Unaligned(scope(), null, a, bigEndian);\n@@ -65,1 +65,1 @@\n-            SCOPED_MEMORY_ACCESS.put$Memtype$Unaligned(session(), null, a, y, bigEndian);\n+            SCOPED_MEMORY_ACCESS.put$Memtype$Unaligned(scope(), null, a, y, bigEndian);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer-bin.java.template","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -317,4 +317,4 @@\n-        MemorySessionImpl session = session();\n-        if (session != null) {\n-            if (session.ownerThread() == null && session.isCloseable()) {\n-                throw new UnsupportedOperationException(\"ByteBuffer derived from closeable shared sessions not supported\");\n+        MemorySessionImpl scope = scope();\n+        if (scope != null) {\n+            if (scope.ownerThread() == null && scope.isCloseable()) {\n+                throw new UnsupportedOperationException(\"ByteBuffer derived from closeable shared scopes not supported\");\n@@ -322,1 +322,1 @@\n-            session.checkValidState();\n+            scope.checkValidState();\n@@ -333,1 +333,1 @@\n-            return $fromBits$($swap$(SCOPED_MEMORY_ACCESS.get$Swaptype$(session(), null, ix(nextGetIndex()))));\n+            return $fromBits$($swap$(SCOPED_MEMORY_ACCESS.get$Swaptype$(scope(), null, ix(nextGetIndex()))));\n@@ -341,1 +341,1 @@\n-            return $fromBits$($swap$(SCOPED_MEMORY_ACCESS.get$Swaptype$(session(), null, ix(checkIndex(i)))));\n+            return $fromBits$($swap$(SCOPED_MEMORY_ACCESS.get$Swaptype$(scope(), null, ix(checkIndex(i)))));\n@@ -361,1 +361,1 @@\n-            SCOPED_MEMORY_ACCESS.put$Swaptype$(session(), null, ix(nextPutIndex()), $swap$($toBits$(x)));\n+            SCOPED_MEMORY_ACCESS.put$Swaptype$(scope(), null, ix(nextPutIndex()), $swap$($toBits$(x)));\n@@ -374,1 +374,1 @@\n-            SCOPED_MEMORY_ACCESS.put$Swaptype$(session(), null, ix(checkIndex(i)), $swap$($toBits$(x)));\n+            SCOPED_MEMORY_ACCESS.put$Swaptype$(scope(), null, ix(checkIndex(i)), $swap$($toBits$(x)));\n@@ -391,2 +391,2 @@\n-            \/\/ null is passed as destination MemorySession to avoid checking session() twice\n-            SCOPED_MEMORY_ACCESS.copyMemory(session(), null, null,\n+            \/\/ null is passed as destination MemoryScope to avoid checking scope() twice\n+            SCOPED_MEMORY_ACCESS.copyMemory(scope(), null, null,\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer.java.template","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-        checkSession();\n+        checkScope();\n@@ -197,1 +197,1 @@\n-        checkSession();\n+        checkScope();\n@@ -234,1 +234,1 @@\n-        checkSession();\n+        checkScope();\n@@ -249,1 +249,1 @@\n-        checkSession();\n+        checkScope();\n@@ -259,1 +259,1 @@\n-        checkSession();\n+        checkScope();\n@@ -269,1 +269,1 @@\n-        checkSession();\n+        checkScope();\n@@ -283,1 +283,1 @@\n-        checkSession();\n+        checkScope();\n@@ -338,1 +338,1 @@\n-        return SCOPED_MEMORY_ACCESS.getCharUnaligned(session(), hb, byteOffset(nextGetIndex(2)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getCharUnaligned(scope(), hb, byteOffset(nextGetIndex(2)), bigEndian);\n@@ -342,1 +342,1 @@\n-        return SCOPED_MEMORY_ACCESS.getCharUnaligned(session(), hb, byteOffset(checkIndex(i, 2)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getCharUnaligned(scope(), hb, byteOffset(checkIndex(i, 2)), bigEndian);\n@@ -349,1 +349,1 @@\n-        SCOPED_MEMORY_ACCESS.putCharUnaligned(session(), hb, byteOffset(nextPutIndex(2)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putCharUnaligned(scope(), hb, byteOffset(nextPutIndex(2)), x, bigEndian);\n@@ -358,1 +358,1 @@\n-        SCOPED_MEMORY_ACCESS.putCharUnaligned(session(), hb, byteOffset(checkIndex(i, 2)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putCharUnaligned(scope(), hb, byteOffset(checkIndex(i, 2)), x, bigEndian);\n@@ -390,1 +390,1 @@\n-        return SCOPED_MEMORY_ACCESS.getShortUnaligned(session(), hb, byteOffset(nextGetIndex(2)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getShortUnaligned(scope(), hb, byteOffset(nextGetIndex(2)), bigEndian);\n@@ -394,1 +394,1 @@\n-        return SCOPED_MEMORY_ACCESS.getShortUnaligned(session(), hb, byteOffset(checkIndex(i, 2)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getShortUnaligned(scope(), hb, byteOffset(checkIndex(i, 2)), bigEndian);\n@@ -401,1 +401,1 @@\n-        SCOPED_MEMORY_ACCESS.putShortUnaligned(session(), hb, byteOffset(nextPutIndex(2)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putShortUnaligned(scope(), hb, byteOffset(nextPutIndex(2)), x, bigEndian);\n@@ -410,1 +410,1 @@\n-        SCOPED_MEMORY_ACCESS.putShortUnaligned(session(), hb, byteOffset(checkIndex(i, 2)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putShortUnaligned(scope(), hb, byteOffset(checkIndex(i, 2)), x, bigEndian);\n@@ -442,1 +442,1 @@\n-        return SCOPED_MEMORY_ACCESS.getIntUnaligned(session(), hb, byteOffset(nextGetIndex(4)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getIntUnaligned(scope(), hb, byteOffset(nextGetIndex(4)), bigEndian);\n@@ -446,1 +446,1 @@\n-        return SCOPED_MEMORY_ACCESS.getIntUnaligned(session(), hb, byteOffset(checkIndex(i, 4)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getIntUnaligned(scope(), hb, byteOffset(checkIndex(i, 4)), bigEndian);\n@@ -453,1 +453,1 @@\n-        SCOPED_MEMORY_ACCESS.putIntUnaligned(session(), hb, byteOffset(nextPutIndex(4)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putIntUnaligned(scope(), hb, byteOffset(nextPutIndex(4)), x, bigEndian);\n@@ -462,1 +462,1 @@\n-        SCOPED_MEMORY_ACCESS.putIntUnaligned(session(), hb, byteOffset(checkIndex(i, 4)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putIntUnaligned(scope(), hb, byteOffset(checkIndex(i, 4)), x, bigEndian);\n@@ -494,1 +494,1 @@\n-        return SCOPED_MEMORY_ACCESS.getLongUnaligned(session(), hb, byteOffset(nextGetIndex(8)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getLongUnaligned(scope(), hb, byteOffset(nextGetIndex(8)), bigEndian);\n@@ -498,1 +498,1 @@\n-        return SCOPED_MEMORY_ACCESS.getLongUnaligned(session(), hb, byteOffset(checkIndex(i, 8)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getLongUnaligned(scope(), hb, byteOffset(checkIndex(i, 8)), bigEndian);\n@@ -505,1 +505,1 @@\n-        SCOPED_MEMORY_ACCESS.putLongUnaligned(session(), hb, byteOffset(nextPutIndex(8)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putLongUnaligned(scope(), hb, byteOffset(nextPutIndex(8)), x, bigEndian);\n@@ -514,1 +514,1 @@\n-        SCOPED_MEMORY_ACCESS.putLongUnaligned(session(), hb, byteOffset(checkIndex(i, 8)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putLongUnaligned(scope(), hb, byteOffset(checkIndex(i, 8)), x, bigEndian);\n@@ -546,1 +546,1 @@\n-        int x = SCOPED_MEMORY_ACCESS.getIntUnaligned(session(), hb, byteOffset(nextGetIndex(4)), bigEndian);\n+        int x = SCOPED_MEMORY_ACCESS.getIntUnaligned(scope(), hb, byteOffset(nextGetIndex(4)), bigEndian);\n@@ -551,1 +551,1 @@\n-        int x = SCOPED_MEMORY_ACCESS.getIntUnaligned(session(), hb, byteOffset(checkIndex(i, 4)), bigEndian);\n+        int x = SCOPED_MEMORY_ACCESS.getIntUnaligned(scope(), hb, byteOffset(checkIndex(i, 4)), bigEndian);\n@@ -560,1 +560,1 @@\n-        SCOPED_MEMORY_ACCESS.putIntUnaligned(session(), hb, byteOffset(nextPutIndex(4)), y, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putIntUnaligned(scope(), hb, byteOffset(nextPutIndex(4)), y, bigEndian);\n@@ -570,1 +570,1 @@\n-        SCOPED_MEMORY_ACCESS.putIntUnaligned(session(), hb, byteOffset(checkIndex(i, 4)), y, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putIntUnaligned(scope(), hb, byteOffset(checkIndex(i, 4)), y, bigEndian);\n@@ -602,1 +602,1 @@\n-        long x = SCOPED_MEMORY_ACCESS.getLongUnaligned(session(), hb, byteOffset(nextGetIndex(8)), bigEndian);\n+        long x = SCOPED_MEMORY_ACCESS.getLongUnaligned(scope(), hb, byteOffset(nextGetIndex(8)), bigEndian);\n@@ -607,1 +607,1 @@\n-        long x = SCOPED_MEMORY_ACCESS.getLongUnaligned(session(), hb, byteOffset(checkIndex(i, 8)), bigEndian);\n+        long x = SCOPED_MEMORY_ACCESS.getLongUnaligned(scope(), hb, byteOffset(checkIndex(i, 8)), bigEndian);\n@@ -616,1 +616,1 @@\n-        SCOPED_MEMORY_ACCESS.putLongUnaligned(session(), hb, byteOffset(nextPutIndex(8)), y, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putLongUnaligned(scope(), hb, byteOffset(nextPutIndex(8)), y, bigEndian);\n@@ -626,1 +626,1 @@\n-        SCOPED_MEMORY_ACCESS.putLongUnaligned(session(), hb, byteOffset(checkIndex(i, 8)), y, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putLongUnaligned(scope(), hb, byteOffset(checkIndex(i, 8)), y, bigEndian);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Heap-X-Buffer.java.template","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -192,1 +192,1 @@\n-        return SCOPED_MEMORY_ACCESS.isLoaded(session(), address, isSync, capacity());\n+        return SCOPED_MEMORY_ACCESS.isLoaded(scope(), address, isSync, capacity());\n@@ -210,1 +210,1 @@\n-            SCOPED_MEMORY_ACCESS.load(session(), address, isSync, capacity());\n+            SCOPED_MEMORY_ACCESS.load(scope(), address, isSync, capacity());\n@@ -310,1 +310,1 @@\n-            SCOPED_MEMORY_ACCESS.force(session(), fd, address, isSync, index, length);\n+            SCOPED_MEMORY_ACCESS.force(scope(), fd, address, isSync, index, length);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/MappedByteBuffer.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -939,1 +939,1 @@\n-                            session(), null, base(), bufAddr,\n+                            scope(), null, base(), bufAddr,\n@@ -944,1 +944,1 @@\n-                            session(), null, base(), bufAddr,\n+                            scope(), null, base(), bufAddr,\n@@ -1109,1 +1109,1 @@\n-                            src.session(), session(), srcBase, srcAddr,\n+                            src.scope(), scope(), srcBase, srcAddr,\n@@ -1114,1 +1114,1 @@\n-                            src.session(), session(), srcBase, srcAddr,\n+                            src.scope(), scope(), srcBase, srcAddr,\n@@ -1329,1 +1329,1 @@\n-                            null, session(), src, srcOffset,\n+                            null, scope(), src, srcOffset,\n@@ -1334,1 +1334,1 @@\n-                            null, session(), src, srcOffset,\n+                            null, scope(), src, srcOffset,\n","filename":"src\/java.base\/share\/classes\/java\/nio\/X-Buffer.java.template","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-            NIO_ACCESS.acquireSession(buffer);\n+            NIO_ACCESS.acquireScope(buffer);\n@@ -105,1 +105,1 @@\n-                NIO_ACCESS.releaseSession(buffer);\n+                NIO_ACCESS.releaseScope(buffer);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Adler32.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-            NIO_ACCESS.acquireSession(buffer);\n+            NIO_ACCESS.acquireScope(buffer);\n@@ -104,1 +104,1 @@\n-                NIO_ACCESS.releaseSession(buffer);\n+                NIO_ACCESS.releaseScope(buffer);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/CRC32.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-            NIO_ACCESS.acquireSession(buffer);\n+            NIO_ACCESS.acquireScope(buffer);\n@@ -180,1 +180,1 @@\n-                NIO_ACCESS.releaseSession(buffer);\n+                NIO_ACCESS.releaseScope(buffer);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/CRC32C.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -341,1 +341,1 @@\n-                NIO_ACCESS.acquireSession(dictionary);\n+                NIO_ACCESS.acquireScope(dictionary);\n@@ -346,1 +346,1 @@\n-                    NIO_ACCESS.releaseSession(dictionary);\n+                    NIO_ACCESS.releaseScope(dictionary);\n@@ -592,1 +592,1 @@\n-                    NIO_ACCESS.acquireSession(input);\n+                    NIO_ACCESS.acquireScope(input);\n@@ -600,1 +600,1 @@\n-                        NIO_ACCESS.releaseSession(input);\n+                        NIO_ACCESS.releaseScope(input);\n@@ -715,1 +715,1 @@\n-                    NIO_ACCESS.acquireSession(output);\n+                    NIO_ACCESS.acquireScope(output);\n@@ -723,1 +723,1 @@\n-                        NIO_ACCESS.releaseSession(output);\n+                        NIO_ACCESS.releaseScope(output);\n@@ -737,1 +737,1 @@\n-                    NIO_ACCESS.acquireSession(input);\n+                    NIO_ACCESS.acquireScope(input);\n@@ -741,1 +741,1 @@\n-                            NIO_ACCESS.acquireSession(output);\n+                            NIO_ACCESS.acquireScope(output);\n@@ -749,1 +749,1 @@\n-                                NIO_ACCESS.releaseSession(output);\n+                                NIO_ACCESS.releaseScope(output);\n@@ -760,1 +760,1 @@\n-                        NIO_ACCESS.releaseSession(input);\n+                        NIO_ACCESS.releaseScope(input);\n@@ -766,1 +766,1 @@\n-                        NIO_ACCESS.acquireSession(output);\n+                        NIO_ACCESS.acquireScope(output);\n@@ -774,1 +774,1 @@\n-                            NIO_ACCESS.releaseSession(output);\n+                            NIO_ACCESS.releaseScope(output);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Deflater.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -263,1 +263,1 @@\n-                NIO_ACCESS.acquireSession(dictionary);\n+                NIO_ACCESS.acquireScope(dictionary);\n@@ -268,1 +268,1 @@\n-                    NIO_ACCESS.releaseSession(dictionary);\n+                    NIO_ACCESS.releaseScope(dictionary);\n@@ -388,1 +388,1 @@\n-                            NIO_ACCESS.acquireSession(input);\n+                            NIO_ACCESS.acquireScope(input);\n@@ -395,1 +395,1 @@\n-                                NIO_ACCESS.releaseSession(input);\n+                                NIO_ACCESS.releaseScope(input);\n@@ -523,1 +523,1 @@\n-                            NIO_ACCESS.acquireSession(output);\n+                            NIO_ACCESS.acquireScope(output);\n@@ -530,1 +530,1 @@\n-                                NIO_ACCESS.releaseSession(output);\n+                                NIO_ACCESS.releaseScope(output);\n@@ -548,1 +548,1 @@\n-                            NIO_ACCESS.acquireSession(input);\n+                            NIO_ACCESS.acquireScope(input);\n@@ -552,1 +552,1 @@\n-                                    NIO_ACCESS.acquireSession(output);\n+                                    NIO_ACCESS.acquireScope(output);\n@@ -559,1 +559,1 @@\n-                                        NIO_ACCESS.releaseSession(output);\n+                                        NIO_ACCESS.releaseScope(output);\n@@ -569,1 +569,1 @@\n-                                NIO_ACCESS.releaseSession(input);\n+                                NIO_ACCESS.releaseScope(input);\n@@ -575,1 +575,1 @@\n-                                NIO_ACCESS.acquireSession(output);\n+                                NIO_ACCESS.acquireScope(output);\n@@ -582,1 +582,1 @@\n-                                    NIO_ACCESS.releaseSession(output);\n+                                    NIO_ACCESS.releaseScope(output);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Inflater.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -89,2 +89,2 @@\n-     * Used by operations to make a buffer's session non-closeable\n-     * (for the duration of the operation) by acquiring the session.\n+     * Used by operations to make a buffer's scope non-closeable\n+     * (for the duration of the operation) by acquiring the scope.\n@@ -92,1 +92,1 @@\n-     * acquireSession(buffer);\n+     * acquireScope(buffer);\n@@ -96,1 +96,1 @@\n-     *     releaseSession(buffer);\n+     *     releaseScope(buffer);\n@@ -100,1 +100,1 @@\n-     * @see #releaseSession(Buffer)\n+     * @see #releaseScope(Buffer)\n@@ -102,1 +102,1 @@\n-    void acquireSession(Buffer buffer);\n+    void acquireScope(Buffer buffer);\n@@ -104,1 +104,1 @@\n-    void releaseSession(Buffer buffer);\n+    void releaseScope(Buffer buffer);\n@@ -108,1 +108,1 @@\n-    boolean hasSession(Buffer buffer);\n+    boolean hasScope(Buffer buffer);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaNioAccess.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-    final SegmentScope session;\n+    final SegmentScope scope;\n@@ -83,1 +83,1 @@\n-    AbstractMemorySegmentImpl(long length, boolean readOnly, SegmentScope session) {\n+    AbstractMemorySegmentImpl(long length, boolean readOnly, SegmentScope scope) {\n@@ -86,1 +86,1 @@\n-        this.session = session;\n+        this.scope = scope;\n@@ -89,1 +89,1 @@\n-    abstract AbstractMemorySegmentImpl dup(long offset, long size, boolean readOnly, SegmentScope session);\n+    abstract AbstractMemorySegmentImpl dup(long offset, long size, boolean readOnly, SegmentScope scope);\n@@ -95,1 +95,1 @@\n-        return dup(0, length, true, session);\n+        return dup(0, length, true, scope);\n@@ -116,1 +116,1 @@\n-        return dup(offset, newSize, readOnly, session);\n+        return dup(offset, newSize, readOnly, scope);\n@@ -144,1 +144,1 @@\n-        SCOPED_MEMORY_ACCESS.setMemory(sessionImpl(), unsafeGetBase(), unsafeGetOffset(), length, value);\n+        SCOPED_MEMORY_ACCESS.setMemory(scopeImpl(), unsafeGetBase(), unsafeGetOffset(), length, value);\n@@ -157,4 +157,4 @@\n-    public static long vectorizedMismatchLargeForBytes(MemorySessionImpl aSession, MemorySessionImpl bSession,\n-                                                        Object a, long aOffset,\n-                                                        Object b, long bOffset,\n-                                                        long length) {\n+    public static long vectorizedMismatchLargeForBytes(MemorySessionImpl aScope, MemorySessionImpl bScope,\n+                                                       Object a, long aOffset,\n+                                                       Object b, long bOffset,\n+                                                       long length) {\n@@ -172,1 +172,1 @@\n-            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(aSession, bSession,\n+            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(aScope, bScope,\n@@ -191,1 +191,1 @@\n-            \/\/session is IMMUTABLE - obtain a RO byte buffer\n+            \/\/scope is IMMUTABLE - obtain a RO byte buffer\n@@ -315,1 +315,1 @@\n-        sessionImpl().checkValidState();\n+        scopeImpl().checkValidState();\n@@ -362,1 +362,1 @@\n-        return session;\n+        return scope;\n@@ -366,2 +366,2 @@\n-    public final MemorySessionImpl sessionImpl() {\n-        return (MemorySessionImpl)session;\n+    public final MemorySessionImpl scopeImpl() {\n+        return (MemorySessionImpl) scope;\n@@ -484,1 +484,1 @@\n-        final SegmentScope bufferSession;\n+        final SegmentScope bufferScope;\n@@ -486,1 +486,1 @@\n-            bufferSession = bufferSegment.session;\n+            bufferScope = bufferSegment.scope;\n@@ -488,1 +488,1 @@\n-            bufferSession = MemorySessionImpl.heapSession(bb);\n+            bufferScope = MemorySessionImpl.heapScope(bb);\n@@ -511,1 +511,1 @@\n-            return new NativeMemorySegmentImpl(bbAddress + (pos << scaleFactor), size << scaleFactor, readOnly, bufferSession);\n+            return new NativeMemorySegmentImpl(bbAddress + (pos << scaleFactor), size << scaleFactor, readOnly, bufferScope);\n@@ -514,1 +514,1 @@\n-            return new MappedMemorySegmentImpl(bbAddress + pos, unmapper, size, readOnly, bufferSession);\n+            return new MappedMemorySegmentImpl(bbAddress + pos, unmapper, size, readOnly, bufferScope);\n@@ -560,1 +560,1 @@\n-            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n+            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.scopeImpl(), dstImpl.scopeImpl(),\n@@ -564,1 +564,1 @@\n-            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n+            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.scopeImpl(), dstImpl.scopeImpl(),\n@@ -589,1 +589,1 @@\n-            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.sessionImpl(), null,\n+            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.scopeImpl(), null,\n@@ -593,1 +593,1 @@\n-            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.sessionImpl(), null,\n+            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.scopeImpl(), null,\n@@ -618,1 +618,1 @@\n-            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(null, destImpl.sessionImpl(),\n+            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(null, destImpl.scopeImpl(),\n@@ -622,1 +622,1 @@\n-            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(null, destImpl.sessionImpl(),\n+            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(null, destImpl.scopeImpl(),\n@@ -647,1 +647,1 @@\n-            i = AbstractMemorySegmentImpl.vectorizedMismatchLargeForBytes(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n+            i = AbstractMemorySegmentImpl.vectorizedMismatchLargeForBytes(srcImpl.scopeImpl(), dstImpl.scopeImpl(),\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+\/**\n+ * A confined scope, which features an owner thread. The liveness check features an additional\n+ * confinement check - that is, calling any operation on this scope from a thread other than the\n+ * owner thread will result in an exception. Because of this restriction, checking the liveness bit\n+ * can be performed in plain mode.\n+ *\/\n+final class ConfinedScope extends MemorySessionImpl {\n+\n+    private int asyncReleaseCount = 0;\n+\n+    static final VarHandle ASYNC_RELEASE_COUNT;\n+\n+    static {\n+        try {\n+            ASYNC_RELEASE_COUNT = MethodHandles.lookup().findVarHandle(ConfinedScope.class, \"asyncReleaseCount\", int.class);\n+        } catch (Throwable ex) {\n+            throw new ExceptionInInitializerError(ex);\n+        }\n+    }\n+\n+    public ConfinedScope(Thread owner) {\n+        super(owner, new ConfinedResourceList());\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public void acquire0() {\n+        checkValidState();\n+        if (state == MAX_FORKS) {\n+            throw tooManyAcquires();\n+        }\n+        state++;\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public void release0() {\n+        if (Thread.currentThread() == owner) {\n+            state--;\n+        } else {\n+            \/\/ It is possible to end up here in two cases: this scope was kept alive by some other confined scope\n+            \/\/ which is implicitly released (in which case the release call comes from the cleaner thread). Or,\n+            \/\/ this scope might be kept alive by a shared scope, which means the release call can come from any\n+            \/\/ thread.\n+            ASYNC_RELEASE_COUNT.getAndAdd(this, 1);\n+        }\n+    }\n+\n+    void justClose() {\n+        checkValidState();\n+        int asyncCount = (int)ASYNC_RELEASE_COUNT.getVolatile(this);\n+        if ((state == 0 && asyncCount == 0)\n+                || ((state - asyncCount) == 0)) {\n+            state = CLOSED;\n+        } else {\n+            throw alreadyAcquired(state - asyncCount);\n+        }\n+    }\n+\n+    \/**\n+     * A confined resource list; no races are possible here.\n+     *\/\n+    static final class ConfinedResourceList extends ResourceList {\n+        @Override\n+        void add(ResourceCleanup cleanup) {\n+            if (fst != ResourceCleanup.CLOSED_LIST) {\n+                cleanup.next = fst;\n+                fst = cleanup;\n+            } else {\n+                throw alreadyClosed();\n+            }\n+        }\n+\n+        @Override\n+        void cleanup() {\n+            if (fst != ResourceCleanup.CLOSED_LIST) {\n+                ResourceCleanup prev = fst;\n+                fst = ResourceCleanup.CLOSED_LIST;\n+                cleanup(prev);\n+            } else {\n+                throw alreadyClosed();\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ConfinedScope.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -1,118 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.foreign;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.lang.ref.Cleaner;\n-\n-import jdk.internal.vm.annotation.ForceInline;\n-\n-\/**\n- * A confined session, which features an owner thread. The liveness check features an additional\n- * confinement check - that is, calling any operation on this session from a thread other than the\n- * owner thread will result in an exception. Because of this restriction, checking the liveness bit\n- * can be performed in plain mode.\n- *\/\n-final class ConfinedSession extends MemorySessionImpl {\n-\n-    private int asyncReleaseCount = 0;\n-\n-    static final VarHandle ASYNC_RELEASE_COUNT;\n-\n-    static {\n-        try {\n-            ASYNC_RELEASE_COUNT = MethodHandles.lookup().findVarHandle(ConfinedSession.class, \"asyncReleaseCount\", int.class);\n-        } catch (Throwable ex) {\n-            throw new ExceptionInInitializerError(ex);\n-        }\n-    }\n-\n-    public ConfinedSession(Thread owner) {\n-        super(owner, new ConfinedResourceList());\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public void acquire0() {\n-        checkValidState();\n-        if (state == MAX_FORKS) {\n-            throw tooManyAcquires();\n-        }\n-        state++;\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public void release0() {\n-        if (Thread.currentThread() == owner) {\n-            state--;\n-        } else {\n-            \/\/ It is possible to end up here in two cases: this session was kept alive by some other confined session\n-            \/\/ which is implicitly released (in which case the release call comes from the cleaner thread). Or,\n-            \/\/ this session might be kept alive by a shared session, which means the release call can come from any\n-            \/\/ thread.\n-            ASYNC_RELEASE_COUNT.getAndAdd(this, 1);\n-        }\n-    }\n-\n-    void justClose() {\n-        checkValidState();\n-        int asyncCount = (int)ASYNC_RELEASE_COUNT.getVolatile(this);\n-        if ((state == 0 && asyncCount == 0)\n-                || ((state - asyncCount) == 0)) {\n-            state = CLOSED;\n-        } else {\n-            throw alreadyAcquired(state - asyncCount);\n-        }\n-    }\n-\n-    \/**\n-     * A confined resource list; no races are possible here.\n-     *\/\n-    static final class ConfinedResourceList extends ResourceList {\n-        @Override\n-        void add(ResourceCleanup cleanup) {\n-            if (fst != ResourceCleanup.CLOSED_LIST) {\n-                cleanup.next = fst;\n-                fst = cleanup;\n-            } else {\n-                throw alreadyClosed();\n-            }\n-        }\n-\n-        @Override\n-        void cleanup() {\n-            if (fst != ResourceCleanup.CLOSED_LIST) {\n-                ResourceCleanup prev = fst;\n-                fst = ResourceCleanup.CLOSED_LIST;\n-                cleanup(prev);\n-            } else {\n-                throw alreadyClosed();\n-            }\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ConfinedSession.java","additions":0,"deletions":118,"binary":false,"changes":118,"status":"deleted"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+\/**\n+ * The global, non-closeable, shared scope. Similar to a shared scope, but its {@link #close()} method throws unconditionally.\n+ * Adding new resources to the global scope, does nothing: as the scope can never become not-alive, there is nothing to track.\n+ * Acquiring and or releasing a memory scope similarly does nothing.\n+ *\/\n+final class GlobalScope extends MemorySessionImpl {\n+\n+    final Object ref;\n+\n+    public GlobalScope(Object ref) {\n+        super(null, null);\n+        this.ref = ref;\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public void release0() {\n+        \/\/ do nothing\n+    }\n+\n+    @Override\n+    public boolean isCloseable() {\n+        return false;\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public void acquire0() {\n+        \/\/ do nothing\n+    }\n+\n+    @Override\n+    void addInternal(ResourceList.ResourceCleanup resource) {\n+        \/\/ do nothing\n+    }\n+\n+    @Override\n+    public void justClose() {\n+        throw nonCloseable();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/GlobalScope.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -1,70 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.foreign;\n-\n-import jdk.internal.vm.annotation.ForceInline;\n-\n-\/**\n- * The global, non-closeable, shared session. Similar to a shared session, but its {@link #close()} method throws unconditionally.\n- * Adding new resources to the global session, does nothing: as the session can never become not-alive, there is nothing to track.\n- * Acquiring and or releasing a memory session similarly does nothing.\n- *\/\n-final class GlobalSession extends MemorySessionImpl {\n-\n-    final Object ref;\n-\n-    public GlobalSession(Object ref) {\n-        super(null, null);\n-        this.ref = ref;\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public void release0() {\n-        \/\/ do nothing\n-    }\n-\n-    @Override\n-    public boolean isCloseable() {\n-        return false;\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public void acquire0() {\n-        \/\/ do nothing\n-    }\n-\n-    @Override\n-    void addInternal(ResourceList.ResourceCleanup resource) {\n-        \/\/ do nothing\n-    }\n-\n-    @Override\n-    public void justClose() {\n-        throw nonCloseable();\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/GlobalSession.java","additions":0,"deletions":70,"binary":false,"changes":70,"status":"deleted"},{"patch":"@@ -82,1 +82,1 @@\n-    abstract HeapMemorySegmentImpl dup(long offset, long size, boolean readOnly, SegmentScope session);\n+    abstract HeapMemorySegmentImpl dup(long offset, long size, boolean readOnly, SegmentScope scope);\n@@ -102,1 +102,1 @@\n-        OfByte dup(long offset, long size, boolean readOnly, SegmentScope session) {\n+        OfByte dup(long offset, long size, boolean readOnly, SegmentScope scope) {\n@@ -135,1 +135,1 @@\n-        OfChar dup(long offset, long size, boolean readOnly, SegmentScope session) {\n+        OfChar dup(long offset, long size, boolean readOnly, SegmentScope scope) {\n@@ -168,1 +168,1 @@\n-        OfShort dup(long offset, long size, boolean readOnly, SegmentScope session) {\n+        OfShort dup(long offset, long size, boolean readOnly, SegmentScope scope) {\n@@ -201,1 +201,1 @@\n-        OfInt dup(long offset, long size, boolean readOnly, SegmentScope session) {\n+        OfInt dup(long offset, long size, boolean readOnly, SegmentScope scope) {\n@@ -234,1 +234,1 @@\n-        OfLong dup(long offset, long size, boolean readOnly, SegmentScope session) {\n+        OfLong dup(long offset, long size, boolean readOnly, SegmentScope scope) {\n@@ -267,1 +267,1 @@\n-        OfFloat dup(long offset, long size, boolean readOnly, SegmentScope session) {\n+        OfFloat dup(long offset, long size, boolean readOnly, SegmentScope scope) {\n@@ -300,1 +300,1 @@\n-        OfDouble dup(long offset, long size, boolean readOnly, SegmentScope session) {\n+        OfDouble dup(long offset, long size, boolean readOnly, SegmentScope scope) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import sun.nio.ch.DirectBuffer;\n+\n+import java.lang.ref.Cleaner;\n+import java.lang.ref.Reference;\n+\n+\/**\n+ * This is an implicit, GC-backed memory scope. Implicit scopes cannot be closed explicitly.\n+ * While it would be possible to model an implicit scope as a non-closeable view of a shared\n+ * scope, it is better to capture the fact that an implicit scope is not just a non-closeable\n+ * view of some scope which might be closeable. This is useful e.g. in the implementations of\n+ * {@link DirectBuffer#address()}, where obtaining an address of a buffer instance associated\n+ * with a potentially closeable scope is forbidden.\n+ *\/\n+final class ImplicitScope extends SharedScope {\n+\n+    public ImplicitScope(Cleaner cleaner) {\n+        super();\n+        cleaner.register(this, resourceList);\n+    }\n+\n+    @Override\n+    public void release0() {\n+        Reference.reachabilityFence(this);\n+    }\n+\n+    @Override\n+    public void acquire0() {\n+        \/\/ do nothing\n+    }\n+\n+    @Override\n+    public boolean isCloseable() {\n+        return false;\n+    }\n+\n+    @Override\n+    public void justClose() {\n+        throw nonCloseable();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ImplicitScope.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.foreign;\n-\n-import sun.nio.ch.DirectBuffer;\n-\n-import java.lang.ref.Cleaner;\n-import java.lang.ref.Reference;\n-\n-\/**\n- * This is an implicit, GC-backed memory session. Implicit sessions cannot be closed explicitly.\n- * While it would be possible to model an implicit session as a non-closeable view of a shared\n- * session, it is better to capture the fact that an implicit session is not just a non-closeable\n- * view of some session which might be closeable. This is useful e.g. in the implementations of\n- * {@link DirectBuffer#address()}, where obtaining an address of a buffer instance associated\n- * with a potentially closeable session is forbidden.\n- *\/\n-final class ImplicitSession extends SharedSession {\n-\n-    public ImplicitSession(Cleaner cleaner) {\n-        super();\n-        cleaner.register(this, resourceList);\n-    }\n-\n-    @Override\n-    public void release0() {\n-        Reference.reachabilityFence(this);\n-    }\n-\n-    @Override\n-    public void acquire0() {\n-        \/\/ do nothing\n-    }\n-\n-    @Override\n-    public boolean isCloseable() {\n-        return false;\n-    }\n-\n-    @Override\n-    public void justClose() {\n-        throw nonCloseable();\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ImplicitSession.java","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -46,2 +46,2 @@\n-    public MappedMemorySegmentImpl(long min, UnmapperProxy unmapper, long length, boolean readOnly, SegmentScope session) {\n-        super(min, length, readOnly, session);\n+    public MappedMemorySegmentImpl(long min, UnmapperProxy unmapper, long length, boolean readOnly, SegmentScope scope) {\n+        super(min, length, readOnly, scope);\n@@ -54,1 +54,1 @@\n-                session == MemorySessionImpl.GLOBAL ? null : this);\n+                scope == MemorySessionImpl.GLOBAL ? null : this);\n@@ -58,2 +58,2 @@\n-    MappedMemorySegmentImpl dup(long offset, long size, boolean readOnly, SegmentScope session) {\n-        return new MappedMemorySegmentImpl(min + offset, unmapper, size, readOnly, session);\n+    MappedMemorySegmentImpl dup(long offset, long size, boolean readOnly, SegmentScope scope) {\n+        return new MappedMemorySegmentImpl(min + offset, unmapper, size, readOnly, scope);\n@@ -81,1 +81,1 @@\n-        SCOPED_MEMORY_ACCESS.load(sessionImpl(), min, unmapper.isSync(), length);\n+        SCOPED_MEMORY_ACCESS.load(scopeImpl(), min, unmapper.isSync(), length);\n@@ -85,1 +85,1 @@\n-        SCOPED_MEMORY_ACCESS.unload(sessionImpl(), min, unmapper.isSync(), length);\n+        SCOPED_MEMORY_ACCESS.unload(scopeImpl(), min, unmapper.isSync(), length);\n@@ -89,1 +89,1 @@\n-        return SCOPED_MEMORY_ACCESS.isLoaded(sessionImpl(), min, unmapper.isSync(), length);\n+        return SCOPED_MEMORY_ACCESS.isLoaded(scopeImpl(), min, unmapper.isSync(), length);\n@@ -93,1 +93,1 @@\n-        SCOPED_MEMORY_ACCESS.force(sessionImpl(), unmapper.fileDescriptor(), min, unmapper.isSync(), 0, length);\n+        SCOPED_MEMORY_ACCESS.force(scopeImpl(), unmapper.fileDescriptor(), min, unmapper.isSync(), 0, length);\n@@ -98,2 +98,2 @@\n-        public EmptyMappedMemorySegmentImpl(boolean readOnly, MemorySessionImpl session) {\n-            super(0, null, 0, readOnly, session);\n+        public EmptyMappedMemorySegmentImpl(boolean readOnly, MemorySessionImpl scope) {\n+            super(0, null, 0, readOnly, scope);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- * as thread confinement. A session has a liveness bit, which is updated when the session is closed\n+ * as thread confinement. A scope has a liveness bit, which is updated when the scope is closed\n@@ -45,2 +45,2 @@\n- * There are two kinds of memory session: confined memory session and shared memory session.\n- * A confined memory session has an associated owner thread that confines some operations to\n+ * There are two kinds of memory scope: confined memory scope and shared memory scope.\n+ * A confined memory scope has an associated owner thread that confines some operations to\n@@ -48,1 +48,1 @@\n- * Shared sessions do not feature an owner thread - meaning their operations can be called, in a racy\n+ * Shared scopes do not feature an owner thread - meaning their operations can be called, in a racy\n@@ -50,2 +50,2 @@\n- * shared sessions use a more sophisticated synchronization mechanism, which guarantees that no concurrent\n- * access is possible when a session is being closed (see {@link jdk.internal.misc.ScopedMemoryAccess}).\n+ * shared scopes use a more sophisticated synchronization mechanism, which guarantees that no concurrent\n+ * access is possible when a scope is being closed (see {@link jdk.internal.misc.ScopedMemoryAccess}).\n@@ -55,1 +55,1 @@\n-        permits ConfinedSession, GlobalSession, SharedSession {\n+        permits ConfinedScope, GlobalScope, SharedScope {\n@@ -63,1 +63,1 @@\n-    public static final MemorySessionImpl GLOBAL = new GlobalSession(null);\n+    public static final MemorySessionImpl GLOBAL = new GlobalScope(null);\n@@ -109,1 +109,1 @@\n-     * we register the cleanup (free\/munmap) against the session; so, if registration fails, we still have to\n+     * we register the cleanup (free\/munmap) against the scope; so, if registration fails, we still have to\n@@ -111,1 +111,1 @@\n-     * returning a segment that is already \"closed\" - which is always possible anyway (e.g. if the session\n+     * returning a segment that is already \"closed\" - which is always possible anyway (e.g. if the scope\n@@ -127,3 +127,3 @@\n-        \/\/ Note: from here on we no longer check the session state. Two cases are possible: either the resource cleanup\n-        \/\/ is added to the list when the session is still open, in which case everything works ok; or the resource\n-        \/\/ cleanup is added while the session is being closed. In this latter case, what matters is whether we have already\n+        \/\/ Note: from here on we no longer check the scope state. Two cases are possible: either the resource cleanup\n+        \/\/ is added to the list when the scope is still open, in which case everything works ok; or the resource\n+        \/\/ cleanup is added while the scope is being closed. In this latter case, what matters is whether we have already\n@@ -142,1 +142,1 @@\n-        return new ConfinedSession(thread);\n+        return new ConfinedScope(thread);\n@@ -146,1 +146,1 @@\n-        return new SharedSession();\n+        return new SharedScope();\n@@ -150,1 +150,1 @@\n-        return new ImplicitSession(cleaner);\n+        return new ImplicitScope(cleaner);\n@@ -178,3 +178,3 @@\n-    public static boolean sameOwnerThread(SegmentScope session1, SegmentScope session2) {\n-        return ((MemorySessionImpl) session1).ownerThread() ==\n-                ((MemorySessionImpl) session2).ownerThread();\n+    public static boolean sameOwnerThread(SegmentScope scope1, SegmentScope scope2) {\n+        return ((MemorySessionImpl) scope1).ownerThread() ==\n+                ((MemorySessionImpl) scope2).ownerThread();\n@@ -190,2 +190,2 @@\n-     * Returns true, if this session is still open. This method may be called in any thread.\n-     * @return {@code true} if this session is not closed yet.\n+     * Returns true, if this scope is still open. This method may be called in any thread.\n+     * @return {@code true} if this scope is not closed yet.\n@@ -199,1 +199,1 @@\n-     * relies on invariants associated with the memory session implementations (volatile access\n+     * relies on invariants associated with the memory scope implementations (volatile access\n@@ -216,3 +216,3 @@\n-     * Checks that this session is still alive (see {@link #isAlive()}).\n-     * @throws IllegalStateException if this session is already closed or if this is\n-     * a confined session and this method is called outside of the owner thread.\n+     * Checks that this scope is still alive (see {@link #isAlive()}).\n+     * @throws IllegalStateException if this scope is already closed or if this is\n+     * a confined scope and this method is called outside of the owner thread.\n@@ -238,3 +238,3 @@\n-     * Closes this session, executing any cleanup action (where provided).\n-     * @throws IllegalStateException if this session is already closed or if this is\n-     * a confined session and this method is called outside of the owner thread.\n+     * Closes this scope, executing any cleanup action (where provided).\n+     * @throws IllegalStateException if this scope is already closed or if this is\n+     * a confined scope and this method is called outside of the owner thread.\n@@ -249,2 +249,2 @@\n-    public static MemorySessionImpl heapSession(Object ref) {\n-        return new GlobalSession(ref);\n+    public static MemorySessionImpl heapScope(Object ref) {\n+        return new GlobalScope(ref);\n@@ -254,4 +254,4 @@\n-     * A list of all cleanup actions associated with a memory session. Cleanup actions are modelled as instances\n-     * of the {@link ResourceCleanup} class, and, together, form a linked list. Depending on whether a session\n-     * is shared or confined, different implementations of this class will be used, see {@link ConfinedSession.ConfinedResourceList}\n-     * and {@link SharedSession.SharedResourceList}.\n+     * A list of all cleanup actions associated with a memory scope. Cleanup actions are modelled as instances\n+     * of the {@link ResourceCleanup} class, and, together, form a linked list. Depending on whether a scope\n+     * is shared or confined, different implementations of this class will be used, see {@link ConfinedScope.ConfinedResourceList}\n+     * and {@link SharedScope.SharedResourceList}.\n@@ -304,1 +304,1 @@\n-        return new IllegalStateException(\"Session acquire limit exceeded\");\n+        return new IllegalStateException(\"Scope acquire limit exceeded\");\n@@ -308,1 +308,1 @@\n-        return new IllegalStateException(String.format(\"Session is acquired by %d clients\", acquires));\n+        return new IllegalStateException(String.format(\"Scope is acquired by %d clients\", acquires));\n@@ -320,1 +320,1 @@\n-        return new UnsupportedOperationException(\"Attempted to close a non-closeable session\");\n+        return new UnsupportedOperationException(\"Attempted to close a non-closeable scope\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":37,"deletions":37,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -55,2 +55,2 @@\n-    NativeMemorySegmentImpl(long min, long length, boolean readOnly, SegmentScope session) {\n-        super(length, readOnly, session);\n+    NativeMemorySegmentImpl(long min, long length, boolean readOnly, SegmentScope scope) {\n+        super(length, readOnly, scope);\n@@ -72,2 +72,2 @@\n-    NativeMemorySegmentImpl dup(long offset, long size, boolean readOnly, SegmentScope session) {\n-        return new NativeMemorySegmentImpl(min + offset, size, readOnly, session);\n+    NativeMemorySegmentImpl dup(long offset, long size, boolean readOnly, SegmentScope scope) {\n+        return new NativeMemorySegmentImpl(min + offset, size, readOnly, scope);\n@@ -79,1 +79,1 @@\n-                session == MemorySessionImpl.GLOBAL ? null : this);\n+                scope == MemorySessionImpl.GLOBAL ? null : this);\n@@ -104,3 +104,3 @@\n-    public static MemorySegment makeNativeSegment(long byteSize, long byteAlignment, SegmentScope session) {\n-        MemorySessionImpl sessionImpl = (MemorySessionImpl) session;\n-        sessionImpl.checkValidState();\n+    public static MemorySegment makeNativeSegment(long byteSize, long byteAlignment, SegmentScope scope) {\n+        MemorySessionImpl scopeImpl = (MemorySessionImpl) scope;\n+        scopeImpl.checkValidState();\n@@ -122,2 +122,2 @@\n-                false, session);\n-        sessionImpl.addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n+                false, scope);\n+        scopeImpl.addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n@@ -141,2 +141,2 @@\n-    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, SegmentScope session, Runnable action) {\n-        MemorySessionImpl sessionImpl = (MemorySessionImpl) session;\n+    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, SegmentScope scope, Runnable action) {\n+        MemorySessionImpl scopeImpl = (MemorySessionImpl) scope;\n@@ -144,1 +144,1 @@\n-            sessionImpl.checkValidState();\n+            scopeImpl.checkValidState();\n@@ -146,1 +146,1 @@\n-            sessionImpl.addCloseAction(action);\n+            scopeImpl.addCloseAction(action);\n@@ -148,1 +148,1 @@\n-        return new NativeMemorySegmentImpl(min, byteSize, false, session);\n+        return new NativeMemorySegmentImpl(min, byteSize, false, scope);\n@@ -152,4 +152,4 @@\n-    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, SegmentScope session) {\n-        MemorySessionImpl sessionImpl = (MemorySessionImpl) session;\n-        sessionImpl.checkValidState();\n-        return new NativeMemorySegmentImpl(min, byteSize, false, session);\n+    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, SegmentScope scope) {\n+        MemorySessionImpl scopeImpl = (MemorySessionImpl) scope;\n+        scopeImpl.checkValidState();\n+        return new NativeMemorySegmentImpl(min, byteSize, false, scope);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import java.lang.ref.Cleaner;\n+\n@@ -35,3 +35,3 @@\n- * A shared session, which can be shared across multiple threads. Closing a shared session has to ensure that\n- * (i) only one thread can successfully close a session (e.g. in a close vs. close race) and that\n- * (ii) no other thread is accessing the memory associated with this session while the segment is being\n+ * A shared scope, which can be shared across multiple threads. Closing a shared scope has to ensure that\n+ * (i) only one thread can successfully close a scope (e.g. in a close vs. close race) and that\n+ * (ii) no other thread is accessing the memory associated with this scope while the segment is being\n@@ -43,1 +43,1 @@\n-sealed class SharedSession extends MemorySessionImpl permits ImplicitSession {\n+sealed class SharedScope extends MemorySessionImpl permits ImplicitScope {\n@@ -47,1 +47,1 @@\n-    SharedSession() {\n+    SharedScope() {\n@@ -127,1 +127,1 @@\n-            \/\/ (because MemorySessionImpl::justClose ensured that this thread won the race to close the session).\n+            \/\/ (because MemorySessionImpl::justClose ensured that this thread won the race to close the scope).\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SharedScope.java","additions":7,"deletions":7,"binary":false,"changes":14,"previous_filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SharedSession.java","status":"renamed"},{"patch":"@@ -205,1 +205,1 @@\n-        private final SegmentScope session;\n+        private final SegmentScope scope;\n@@ -207,1 +207,1 @@\n-        private Context(SegmentAllocator allocator, SegmentScope session) {\n+        private Context(SegmentAllocator allocator, SegmentScope scope) {\n@@ -209,1 +209,1 @@\n-            this.session = session;\n+            this.scope = scope;\n@@ -216,2 +216,2 @@\n-        public SegmentScope session() {\n-            return session;\n+        public SegmentScope scope() {\n+            return scope;\n@@ -245,1 +245,1 @@\n-                public SegmentScope session() {\n+                public SegmentScope scope() {\n@@ -255,1 +255,1 @@\n-        public static Context ofSession() {\n+        public static Context ofScope() {\n@@ -279,1 +279,1 @@\n-            public SegmentScope session() {\n+            public SegmentScope scope() {\n@@ -681,2 +681,2 @@\n-     * Pops a 'long' from the operand stack, converts it to a 'MemorySegment', with the given size and memory session\n-     * (either the context session, or the global session), and pushes that onto the operand stack.\n+     * Pops a 'long' from the operand stack, converts it to a 'MemorySegment', with the given size and memory scope\n+     * (either the context scope, or the global scope), and pushes that onto the operand stack.\n@@ -684,1 +684,1 @@\n-    record BoxAddress(long size, boolean needsSession) implements Binding {\n+    record BoxAddress(long size, boolean needsScope) implements Binding {\n@@ -701,3 +701,3 @@\n-            SegmentScope session = needsSession ?\n-                    context.session() : SegmentScope.global();\n-            stack.push(NativeMemorySegmentImpl.makeNativeSegmentUnchecked((long) stack.pop(), size, session));\n+            SegmentScope scope = needsScope ?\n+                    context.scope() : SegmentScope.global();\n+            stack.push(NativeMemorySegmentImpl.makeNativeSegmentUnchecked((long) stack.pop(), size, scope));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-    private static final String OF_SESSION_DESC = methodType(Binding.Context.class).descriptorString();\n+    private static final String OF_SCOPE_DESC = methodType(Binding.Context.class).descriptorString();\n@@ -85,2 +85,2 @@\n-    private static final String SESSION_DESC = methodType(SegmentScope.class).descriptorString();\n-    private static final String SESSION_IMPL_DESC = methodType(MemorySessionImpl.class).descriptorString();\n+    private static final String SCOPE_DESC = methodType(SegmentScope.class).descriptorString();\n+    private static final String SCOPE_IMPL_DESC = methodType(MemorySessionImpl.class).descriptorString();\n@@ -296,2 +296,2 @@\n-        } else if (callingSequence.forUpcall() && needsSession()) {\n-            emitInvokeStatic(Binding.Context.class, \"ofSession\", OF_SESSION_DESC);\n+        } else if (callingSequence.forUpcall() && needsScope()) {\n+            emitInvokeStatic(Binding.Context.class, \"ofScope\", OF_SCOPE_DESC);\n@@ -435,1 +435,1 @@\n-    private boolean needsSession() {\n+    private boolean needsScope() {\n@@ -439,1 +439,1 @@\n-                .anyMatch(Binding.BoxAddress::needsSession);\n+                .anyMatch(Binding.BoxAddress::needsScope);\n@@ -502,1 +502,1 @@\n-        emitInvokeVirtual(AbstractMemorySegmentImpl.class, \"sessionImpl\", SESSION_IMPL_DESC);\n+        emitInvokeVirtual(AbstractMemorySegmentImpl.class, \"scopeImpl\", SCOPE_IMPL_DESC);\n@@ -561,1 +561,1 @@\n-    private void emitLoadInternalSession() {\n+    private void emitLoadInternalScope() {\n@@ -564,1 +564,1 @@\n-        emitInvokeVirtual(Binding.Context.class, \"session\", SESSION_DESC);\n+        emitInvokeVirtual(Binding.Context.class, \"scope\", SCOPE_DESC);\n@@ -582,2 +582,2 @@\n-        if (needsSession()) {\n-            emitLoadInternalSession();\n+        if (needsScope()) {\n+            emitLoadInternalScope();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -291,1 +291,1 @@\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, SegmentScope session) {\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, SegmentScope scope) {\n@@ -293,4 +293,4 @@\n-            case WIN_64 -> Windowsx64Linker.newVaList(actions, session);\n-            case SYS_V -> SysVx64Linker.newVaList(actions, session);\n-            case LINUX_AARCH_64 -> LinuxAArch64Linker.newVaList(actions, session);\n-            case MAC_OS_AARCH_64 -> MacOsAArch64Linker.newVaList(actions, session);\n+            case WIN_64 -> Windowsx64Linker.newVaList(actions, scope);\n+            case SYS_V -> SysVx64Linker.newVaList(actions, scope);\n+            case LINUX_AARCH_64 -> LinuxAArch64Linker.newVaList(actions, scope);\n+            case MAC_OS_AARCH_64 -> MacOsAArch64Linker.newVaList(actions, scope);\n@@ -300,1 +300,1 @@\n-    public static VaList newVaListOfAddress(long address, SegmentScope session) {\n+    public static VaList newVaListOfAddress(long address, SegmentScope scope) {\n@@ -302,4 +302,4 @@\n-            case WIN_64 -> Windowsx64Linker.newVaListOfAddress(address, session);\n-            case SYS_V -> SysVx64Linker.newVaListOfAddress(address, session);\n-            case LINUX_AARCH_64 -> LinuxAArch64Linker.newVaListOfAddress(address, session);\n-            case MAC_OS_AARCH_64 -> MacOsAArch64Linker.newVaListOfAddress(address, session);\n+            case WIN_64 -> Windowsx64Linker.newVaListOfAddress(address, scope);\n+            case SYS_V -> SysVx64Linker.newVaListOfAddress(address, scope);\n+            case LINUX_AARCH_64 -> LinuxAArch64Linker.newVaListOfAddress(address, scope);\n+            case MAC_OS_AARCH_64 -> MacOsAArch64Linker.newVaListOfAddress(address, scope);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-    public static MemorySegment make(ABIDescriptor abi, MethodHandle target, CallingSequence callingSequence, SegmentScope session) {\n+    public static MemorySegment make(ABIDescriptor abi, MethodHandle target, CallingSequence callingSequence, SegmentScope scope) {\n@@ -96,1 +96,1 @@\n-        return UpcallStubs.makeUpcall(entryPoint, session);\n+        return UpcallStubs.makeUpcall(entryPoint, scope);\n@@ -133,1 +133,1 @@\n-                : Binding.Context.ofSession();\n+                : Binding.Context.ofScope();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallLinker.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -53,2 +53,2 @@\n-    static MemorySegment makeUpcall(long entry, SegmentScope session) {\n-        ((MemorySessionImpl) session).addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n+    static MemorySegment makeUpcall(long entry, SegmentScope scope) {\n+        ((MemorySessionImpl) scope).addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n@@ -60,1 +60,1 @@\n-        return MemorySegment.ofAddress(entry, 0, session);\n+        return MemorySegment.ofAddress(entry, 0, scope);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallStubs.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-    public MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, SegmentScope session) {\n+    public MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, SegmentScope scope) {\n@@ -168,1 +168,1 @@\n-        return UpcallLinker.make(C, target, bindings.callingSequence, session);\n+        return UpcallLinker.make(C, target, bindings.callingSequence, scope);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,2 +68,2 @@\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, SegmentScope session) {\n-        LinuxAArch64VaList.Builder builder = LinuxAArch64VaList.builder(session);\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, SegmentScope scope) {\n+        LinuxAArch64VaList.Builder builder = LinuxAArch64VaList.builder(scope);\n@@ -74,2 +74,2 @@\n-    public static VaList newVaListOfAddress(long address, SegmentScope session) {\n-        return LinuxAArch64VaList.ofAddress(address, session);\n+    public static VaList newVaListOfAddress(long address, SegmentScope scope) {\n+        return LinuxAArch64VaList.ofAddress(address, scope);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -123,2 +123,2 @@\n-    private static LinuxAArch64VaList readFromAddress(long address, SegmentScope session) {\n-        MemorySegment segment = MemorySegment.ofAddress(address, LAYOUT.byteSize(), session);\n+    private static LinuxAArch64VaList readFromAddress(long address, SegmentScope scope) {\n+        MemorySegment segment = MemorySegment.ofAddress(address, LAYOUT.byteSize(), scope);\n@@ -126,2 +126,2 @@\n-        MemorySegment gpRegsArea = MemorySegment.ofAddress(grTop(segment).address() - MAX_GP_OFFSET, MAX_GP_OFFSET, session);\n-        MemorySegment fpRegsArea = MemorySegment.ofAddress(vrTop(segment).address() - MAX_FP_OFFSET, MAX_FP_OFFSET, session);\n+        MemorySegment gpRegsArea = MemorySegment.ofAddress(grTop(segment).address() - MAX_GP_OFFSET, MAX_GP_OFFSET, scope);\n+        MemorySegment fpRegsArea = MemorySegment.ofAddress(vrTop(segment).address() - MAX_FP_OFFSET, MAX_FP_OFFSET, scope);\n@@ -387,2 +387,2 @@\n-    static LinuxAArch64VaList.Builder builder(SegmentScope session) {\n-        return new LinuxAArch64VaList.Builder(session);\n+    static LinuxAArch64VaList.Builder builder(SegmentScope scope) {\n+        return new LinuxAArch64VaList.Builder(scope);\n@@ -391,2 +391,2 @@\n-    public static VaList ofAddress(long address, SegmentScope session) {\n-        return readFromAddress(address, session);\n+    public static VaList ofAddress(long address, SegmentScope scope) {\n+        return readFromAddress(address, scope);\n@@ -435,1 +435,1 @@\n-        private final SegmentScope session;\n+        private final SegmentScope scope;\n@@ -443,4 +443,4 @@\n-        Builder(SegmentScope session) {\n-            this.session = session;\n-            this.gpRegs = MemorySegment.allocateNative(LAYOUT_GP_REGS, session);\n-            this.fpRegs = MemorySegment.allocateNative(LAYOUT_FP_REGS, session);\n+        Builder(SegmentScope scope) {\n+            this.scope = scope;\n+            this.gpRegs = MemorySegment.allocateNative(LAYOUT_GP_REGS, scope);\n+            this.fpRegs = MemorySegment.allocateNative(LAYOUT_FP_REGS, scope);\n@@ -539,1 +539,1 @@\n-            MemorySegment vaListSegment = MemorySegment.allocateNative(LAYOUT, session);\n+            MemorySegment vaListSegment = MemorySegment.allocateNative(LAYOUT, scope);\n@@ -544,1 +544,1 @@\n-                stackArgsSegment = MemorySegment.allocateNative(stackArgsSize, 16, session);\n+                stackArgsSegment = MemorySegment.allocateNative(stackArgsSize, 16, scope);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -68,2 +68,2 @@\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, SegmentScope session) {\n-        MacOsAArch64VaList.Builder builder = MacOsAArch64VaList.builder(session);\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, SegmentScope scope) {\n+        MacOsAArch64VaList.Builder builder = MacOsAArch64VaList.builder(scope);\n@@ -74,2 +74,2 @@\n-    public static VaList newVaListOfAddress(long address, SegmentScope session) {\n-        return MacOsAArch64VaList.ofAddress(address, session);\n+    public static VaList newVaListOfAddress(long address, SegmentScope scope) {\n+        return MacOsAArch64VaList.ofAddress(address, scope);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import jdk.internal.foreign.abi.aarch64.TypeClass;\n+\n@@ -37,0 +37,1 @@\n+import jdk.internal.foreign.abi.aarch64.TypeClass;\n@@ -159,2 +160,2 @@\n-    static MacOsAArch64VaList ofAddress(long address, SegmentScope session) {\n-        MemorySegment segment = MemorySegment.ofAddress(address, Long.MAX_VALUE, session);\n+    static MacOsAArch64VaList ofAddress(long address, SegmentScope scope) {\n+        MemorySegment segment = MemorySegment.ofAddress(address, Long.MAX_VALUE, scope);\n@@ -164,2 +165,2 @@\n-    static Builder builder(SegmentScope session) {\n-        return new Builder(session);\n+    static Builder builder(SegmentScope scope) {\n+        return new Builder(scope);\n@@ -182,1 +183,1 @@\n-        private final SegmentScope session;\n+        private final SegmentScope scope;\n@@ -185,3 +186,3 @@\n-        public Builder(SegmentScope session) {\n-            ((MemorySessionImpl) session).checkValidState();\n-            this.session = session;\n+        public Builder(SegmentScope scope) {\n+            ((MemorySessionImpl) scope).checkValidState();\n+            this.scope = scope;\n@@ -228,1 +229,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(allocationSize, session);\n+            MemorySegment segment = MemorySegment.allocateNative(allocationSize, scope);\n@@ -237,1 +238,1 @@\n-                            MemorySegment copy = MemorySegment.allocateNative(arg.layout, session);\n+                            MemorySegment copy = MemorySegment.allocateNative(arg.layout, scope);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64VaList.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-    public static MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, SegmentScope session) {\n+    public static MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, SegmentScope scope) {\n@@ -142,1 +142,1 @@\n-        return UpcallLinker.make(CSysV, target, bindings.callingSequence, session);\n+        return UpcallLinker.make(CSysV, target, bindings.callingSequence, scope);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -133,2 +133,2 @@\n-    private static SysVVaList readFromAddress(long address, SegmentScope session) {\n-        MemorySegment segment = MemorySegment.ofAddress(address, LAYOUT.byteSize(), session);\n+    private static SysVVaList readFromAddress(long address, SegmentScope scope) {\n+        MemorySegment segment = MemorySegment.ofAddress(address, LAYOUT.byteSize(), scope);\n@@ -325,2 +325,2 @@\n-    static SysVVaList.Builder builder(SegmentScope session) {\n-        return new SysVVaList.Builder(session);\n+    static SysVVaList.Builder builder(SegmentScope scope) {\n+        return new SysVVaList.Builder(scope);\n@@ -329,2 +329,2 @@\n-    public static VaList ofAddress(long address, SegmentScope session) {\n-        return readFromAddress(address, session);\n+    public static VaList ofAddress(long address, SegmentScope scope) {\n+        return readFromAddress(address, scope);\n@@ -362,1 +362,1 @@\n-        private final SegmentScope session;\n+        private final SegmentScope scope;\n@@ -368,3 +368,3 @@\n-        public Builder(SegmentScope session) {\n-            this.session = session;\n-            this.reg_save_area = MemorySegment.allocateNative(LAYOUT_REG_SAVE_AREA, session);\n+        public Builder(SegmentScope scope) {\n+            this.scope = scope;\n+            this.reg_save_area = MemorySegment.allocateNative(LAYOUT_REG_SAVE_AREA, scope);\n@@ -449,1 +449,1 @@\n-            MemorySegment vaListSegment = MemorySegment.allocateNative(LAYOUT, session);\n+            MemorySegment vaListSegment = MemorySegment.allocateNative(LAYOUT, scope);\n@@ -454,1 +454,1 @@\n-                stackArgsSegment = MemorySegment.allocateNative(stackArgsSize, 16, session);\n+                stackArgsSegment = MemorySegment.allocateNative(stackArgsSize, 16, scope);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -71,2 +71,2 @@\n-    public static VaList newVaListOfAddress(long address, SegmentScope session) {\n-        return SysVVaList.ofAddress(address, session);\n+    public static VaList newVaListOfAddress(long address, SegmentScope scope) {\n+        return SysVVaList.ofAddress(address, scope);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-    public static MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, SegmentScope session) {\n+    public static MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, SegmentScope scope) {\n@@ -141,1 +141,1 @@\n-        return UpcallLinker.make(CWindows, target, bindings.callingSequence, session);\n+        return UpcallLinker.make(CWindows, target, bindings.callingSequence, scope);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -152,2 +152,2 @@\n-    static WinVaList ofAddress(long address, SegmentScope session) {\n-        return new WinVaList(MemorySegment.ofAddress(address, Long.MAX_VALUE, session));\n+    static WinVaList ofAddress(long address, SegmentScope scope) {\n+        return new WinVaList(MemorySegment.ofAddress(address, Long.MAX_VALUE, scope));\n@@ -156,2 +156,2 @@\n-    static Builder builder(SegmentScope session) {\n-        return new Builder(session);\n+    static Builder builder(SegmentScope scope) {\n+        return new Builder(scope);\n@@ -174,1 +174,1 @@\n-        private final SegmentScope session;\n+        private final SegmentScope scope;\n@@ -177,3 +177,3 @@\n-        public Builder(SegmentScope session) {\n-            ((MemorySessionImpl) session).checkValidState();\n-            this.session = session;\n+        public Builder(SegmentScope scope) {\n+            ((MemorySessionImpl) scope).checkValidState();\n+            this.scope = scope;\n@@ -219,1 +219,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(VA_SLOT_SIZE_BYTES * args.size(), session);\n+            MemorySegment segment = MemorySegment.allocateNative(VA_SLOT_SIZE_BYTES * args.size(), scope);\n@@ -228,1 +228,1 @@\n-                            MemorySegment copy = MemorySegment.allocateNative(arg.layout, session);\n+                            MemorySegment copy = MemorySegment.allocateNative(arg.layout, scope);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -71,2 +71,2 @@\n-    public static VaList newVaListOfAddress(long address, SegmentScope session) {\n-        return WinVaList.ofAddress(address, session);\n+    public static VaList newVaListOfAddress(long address, SegmentScope scope) {\n+        return WinVaList.ofAddress(address, scope);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-    public $type$ get$Type$(MemorySessionImpl session, Object base, long offset) {\n+    public $type$ get$Type$(MemorySessionImpl scope, Object base, long offset) {\n@@ -4,1 +4,1 @@\n-            return get$Type$Internal(session, base, offset);\n+            return get$Type$Internal(scope, base, offset);\n@@ -11,1 +11,1 @@\n-    private $type$ get$Type$Internal(MemorySessionImpl session, Object base, long offset) {\n+    private $type$ get$Type$Internal(MemorySessionImpl scope, Object base, long offset) {\n@@ -13,2 +13,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -18,1 +18,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -23,1 +23,1 @@\n-    public void put$Type$(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    public void put$Type$(MemorySessionImpl scope, Object base, long offset, $type$ value) {\n@@ -25,1 +25,1 @@\n-            put$Type$Internal(session, base, offset, value);\n+            put$Type$Internal(scope, base, offset, value);\n@@ -32,1 +32,1 @@\n-    private void put$Type$Internal(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    private void put$Type$Internal(MemorySessionImpl scope, Object base, long offset, $type$ value) {\n@@ -34,2 +34,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -39,1 +39,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -45,1 +45,1 @@\n-    public $type$ get$Type$Unaligned(MemorySessionImpl session, Object base, long offset, boolean be) {\n+    public $type$ get$Type$Unaligned(MemorySessionImpl scope, Object base, long offset, boolean be) {\n@@ -47,1 +47,1 @@\n-            return get$Type$UnalignedInternal(session, base, offset, be);\n+            return get$Type$UnalignedInternal(scope, base, offset, be);\n@@ -54,1 +54,1 @@\n-    private $type$ get$Type$UnalignedInternal(MemorySessionImpl session, Object base, long offset, boolean be) {\n+    private $type$ get$Type$UnalignedInternal(MemorySessionImpl scope, Object base, long offset, boolean be) {\n@@ -56,2 +56,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -61,1 +61,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -66,1 +66,1 @@\n-    public void put$Type$Unaligned(MemorySessionImpl session, Object base, long offset, $type$ value, boolean be) {\n+    public void put$Type$Unaligned(MemorySessionImpl scope, Object base, long offset, $type$ value, boolean be) {\n@@ -68,1 +68,1 @@\n-            put$Type$UnalignedInternal(session, base, offset, value, be);\n+            put$Type$UnalignedInternal(scope, base, offset, value, be);\n@@ -75,1 +75,1 @@\n-    private void put$Type$UnalignedInternal(MemorySessionImpl session, Object base, long offset, $type$ value, boolean be) {\n+    private void put$Type$UnalignedInternal(MemorySessionImpl scope, Object base, long offset, $type$ value, boolean be) {\n@@ -77,2 +77,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -82,1 +82,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -88,1 +88,1 @@\n-    public $type$ get$Type$Volatile(MemorySessionImpl session, Object base, long offset) {\n+    public $type$ get$Type$Volatile(MemorySessionImpl scope, Object base, long offset) {\n@@ -90,1 +90,1 @@\n-            return get$Type$VolatileInternal(session, base, offset);\n+            return get$Type$VolatileInternal(scope, base, offset);\n@@ -97,1 +97,1 @@\n-    private $type$ get$Type$VolatileInternal(MemorySessionImpl session, Object base, long offset) {\n+    private $type$ get$Type$VolatileInternal(MemorySessionImpl scope, Object base, long offset) {\n@@ -99,2 +99,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -104,1 +104,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -109,1 +109,1 @@\n-    public void put$Type$Volatile(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    public void put$Type$Volatile(MemorySessionImpl scope, Object base, long offset, $type$ value) {\n@@ -111,1 +111,1 @@\n-            put$Type$VolatileInternal(session, base, offset, value);\n+            put$Type$VolatileInternal(scope, base, offset, value);\n@@ -118,1 +118,1 @@\n-    private void put$Type$VolatileInternal(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    private void put$Type$VolatileInternal(MemorySessionImpl scope, Object base, long offset, $type$ value) {\n@@ -120,2 +120,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -125,1 +125,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -130,1 +130,1 @@\n-    public $type$ get$Type$Acquire(MemorySessionImpl session, Object base, long offset) {\n+    public $type$ get$Type$Acquire(MemorySessionImpl scope, Object base, long offset) {\n@@ -132,1 +132,1 @@\n-            return get$Type$AcquireInternal(session, base, offset);\n+            return get$Type$AcquireInternal(scope, base, offset);\n@@ -139,1 +139,1 @@\n-    private $type$ get$Type$AcquireInternal(MemorySessionImpl session, Object base, long offset) {\n+    private $type$ get$Type$AcquireInternal(MemorySessionImpl scope, Object base, long offset) {\n@@ -141,2 +141,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -146,1 +146,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -151,1 +151,1 @@\n-    public void put$Type$Release(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    public void put$Type$Release(MemorySessionImpl scope, Object base, long offset, $type$ value) {\n@@ -153,1 +153,1 @@\n-            put$Type$ReleaseInternal(session, base, offset, value);\n+            put$Type$ReleaseInternal(scope, base, offset, value);\n@@ -160,1 +160,1 @@\n-    private void put$Type$ReleaseInternal(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    private void put$Type$ReleaseInternal(MemorySessionImpl scope, Object base, long offset, $type$ value) {\n@@ -162,2 +162,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -167,1 +167,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -172,1 +172,1 @@\n-    public $type$ get$Type$Opaque(MemorySessionImpl session, Object base, long offset) {\n+    public $type$ get$Type$Opaque(MemorySessionImpl scope, Object base, long offset) {\n@@ -174,1 +174,1 @@\n-            return get$Type$OpaqueInternal(session, base, offset);\n+            return get$Type$OpaqueInternal(scope, base, offset);\n@@ -181,1 +181,1 @@\n-    private $type$ get$Type$OpaqueInternal(MemorySessionImpl session, Object base, long offset) {\n+    private $type$ get$Type$OpaqueInternal(MemorySessionImpl scope, Object base, long offset) {\n@@ -183,2 +183,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -188,1 +188,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -192,1 +192,1 @@\n-    public void put$Type$Opaque(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    public void put$Type$Opaque(MemorySessionImpl scope, Object base, long offset, $type$ value) {\n@@ -194,1 +194,1 @@\n-            put$Type$OpaqueInternal(session, base, offset, value);\n+            put$Type$OpaqueInternal(scope, base, offset, value);\n@@ -201,1 +201,1 @@\n-    private void put$Type$OpaqueInternal(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    private void put$Type$OpaqueInternal(MemorySessionImpl scope, Object base, long offset, $type$ value) {\n@@ -203,2 +203,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -208,1 +208,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -213,1 +213,1 @@\n-    public boolean compareAndSet$Type$(MemorySessionImpl session, Object base, long offset, $type$ expected, $type$ value) {\n+    public boolean compareAndSet$Type$(MemorySessionImpl scope, Object base, long offset, $type$ expected, $type$ value) {\n@@ -215,1 +215,1 @@\n-            return compareAndSet$Type$Internal(session, base, offset, expected, value);\n+            return compareAndSet$Type$Internal(scope, base, offset, expected, value);\n@@ -222,1 +222,1 @@\n-    private boolean compareAndSet$Type$Internal(MemorySessionImpl session, Object base, long offset, $type$ expected, $type$ value) {\n+    private boolean compareAndSet$Type$Internal(MemorySessionImpl scope, Object base, long offset, $type$ expected, $type$ value) {\n@@ -224,2 +224,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -229,1 +229,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -234,1 +234,1 @@\n-    public $type$ compareAndExchange$Type$(MemorySessionImpl session, Object base, long offset, $type$ expected, $type$ value) {\n+    public $type$ compareAndExchange$Type$(MemorySessionImpl scope, Object base, long offset, $type$ expected, $type$ value) {\n@@ -236,1 +236,1 @@\n-            return compareAndExchange$Type$Internal(session, base, offset, expected, value);\n+            return compareAndExchange$Type$Internal(scope, base, offset, expected, value);\n@@ -243,1 +243,1 @@\n-    private $type$ compareAndExchange$Type$Internal(MemorySessionImpl session, Object base, long offset, $type$ expected, $type$ value) {\n+    private $type$ compareAndExchange$Type$Internal(MemorySessionImpl scope, Object base, long offset, $type$ expected, $type$ value) {\n@@ -245,2 +245,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -250,1 +250,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -255,1 +255,1 @@\n-    public $type$ compareAndExchange$Type$Acquire(MemorySessionImpl session, Object base, long offset, $type$ expected, $type$ value) {\n+    public $type$ compareAndExchange$Type$Acquire(MemorySessionImpl scope, Object base, long offset, $type$ expected, $type$ value) {\n@@ -257,1 +257,1 @@\n-            return compareAndExchange$Type$AcquireInternal(session, base, offset, expected, value);\n+            return compareAndExchange$Type$AcquireInternal(scope, base, offset, expected, value);\n@@ -264,1 +264,1 @@\n-    private $type$ compareAndExchange$Type$AcquireInternal(MemorySessionImpl session, Object base, long offset, $type$ expected, $type$ value) {\n+    private $type$ compareAndExchange$Type$AcquireInternal(MemorySessionImpl scope, Object base, long offset, $type$ expected, $type$ value) {\n@@ -266,2 +266,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -271,1 +271,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -276,1 +276,1 @@\n-    public $type$ compareAndExchange$Type$Release(MemorySessionImpl session, Object base, long offset, $type$ expected, $type$ value) {\n+    public $type$ compareAndExchange$Type$Release(MemorySessionImpl scope, Object base, long offset, $type$ expected, $type$ value) {\n@@ -278,1 +278,1 @@\n-            return compareAndExchange$Type$ReleaseInternal(session, base, offset, expected, value);\n+            return compareAndExchange$Type$ReleaseInternal(scope, base, offset, expected, value);\n@@ -285,1 +285,1 @@\n-    private $type$ compareAndExchange$Type$ReleaseInternal(MemorySessionImpl session, Object base, long offset, $type$ expected, $type$ value) {\n+    private $type$ compareAndExchange$Type$ReleaseInternal(MemorySessionImpl scope, Object base, long offset, $type$ expected, $type$ value) {\n@@ -287,2 +287,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -292,1 +292,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -297,1 +297,1 @@\n-    public boolean weakCompareAndSet$Type$Plain(MemorySessionImpl session, Object base, long offset, $type$ expected, $type$ value) {\n+    public boolean weakCompareAndSet$Type$Plain(MemorySessionImpl scope, Object base, long offset, $type$ expected, $type$ value) {\n@@ -299,1 +299,1 @@\n-            return weakCompareAndSet$Type$PlainInternal(session, base, offset, expected, value);\n+            return weakCompareAndSet$Type$PlainInternal(scope, base, offset, expected, value);\n@@ -306,1 +306,1 @@\n-    private boolean weakCompareAndSet$Type$PlainInternal(MemorySessionImpl session, Object base, long offset, $type$ expected, $type$ value) {\n+    private boolean weakCompareAndSet$Type$PlainInternal(MemorySessionImpl scope, Object base, long offset, $type$ expected, $type$ value) {\n@@ -308,2 +308,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -313,1 +313,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -318,1 +318,1 @@\n-    public boolean weakCompareAndSet$Type$(MemorySessionImpl session, Object base, long offset, $type$ expected, $type$ value) {\n+    public boolean weakCompareAndSet$Type$(MemorySessionImpl scope, Object base, long offset, $type$ expected, $type$ value) {\n@@ -320,1 +320,1 @@\n-            return weakCompareAndSet$Type$Internal(session, base, offset, expected, value);\n+            return weakCompareAndSet$Type$Internal(scope, base, offset, expected, value);\n@@ -327,1 +327,1 @@\n-    private boolean weakCompareAndSet$Type$Internal(MemorySessionImpl session, Object base, long offset, $type$ expected, $type$ value) {\n+    private boolean weakCompareAndSet$Type$Internal(MemorySessionImpl scope, Object base, long offset, $type$ expected, $type$ value) {\n@@ -329,2 +329,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -334,1 +334,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -339,1 +339,1 @@\n-    public boolean weakCompareAndSet$Type$Acquire(MemorySessionImpl session, Object base, long offset, $type$ expected, $type$ value) {\n+    public boolean weakCompareAndSet$Type$Acquire(MemorySessionImpl scope, Object base, long offset, $type$ expected, $type$ value) {\n@@ -341,1 +341,1 @@\n-            return weakCompareAndSet$Type$AcquireInternal(session, base, offset, expected, value);\n+            return weakCompareAndSet$Type$AcquireInternal(scope, base, offset, expected, value);\n@@ -348,1 +348,1 @@\n-    private boolean weakCompareAndSet$Type$AcquireInternal(MemorySessionImpl session, Object base, long offset, $type$ expected, $type$ value) {\n+    private boolean weakCompareAndSet$Type$AcquireInternal(MemorySessionImpl scope, Object base, long offset, $type$ expected, $type$ value) {\n@@ -350,2 +350,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -355,1 +355,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -360,1 +360,1 @@\n-    public boolean weakCompareAndSet$Type$Release(MemorySessionImpl session, Object base, long offset, $type$ expected, $type$ value) {\n+    public boolean weakCompareAndSet$Type$Release(MemorySessionImpl scope, Object base, long offset, $type$ expected, $type$ value) {\n@@ -362,1 +362,1 @@\n-            return weakCompareAndSet$Type$ReleaseInternal(session, base, offset, expected, value);\n+            return weakCompareAndSet$Type$ReleaseInternal(scope, base, offset, expected, value);\n@@ -369,1 +369,1 @@\n-    private boolean weakCompareAndSet$Type$ReleaseInternal(MemorySessionImpl session, Object base, long offset, $type$ expected, $type$ value) {\n+    private boolean weakCompareAndSet$Type$ReleaseInternal(MemorySessionImpl scope, Object base, long offset, $type$ expected, $type$ value) {\n@@ -371,2 +371,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -376,1 +376,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -381,1 +381,1 @@\n-    public $type$ getAndSet$Type$(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    public $type$ getAndSet$Type$(MemorySessionImpl scope, Object base, long offset, $type$ value) {\n@@ -383,1 +383,1 @@\n-            return getAndSet$Type$Internal(session, base, offset, value);\n+            return getAndSet$Type$Internal(scope, base, offset, value);\n@@ -390,1 +390,1 @@\n-    private $type$ getAndSet$Type$Internal(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    private $type$ getAndSet$Type$Internal(MemorySessionImpl scope, Object base, long offset, $type$ value) {\n@@ -392,2 +392,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -397,1 +397,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -402,1 +402,1 @@\n-    public $type$ getAndSet$Type$Acquire(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    public $type$ getAndSet$Type$Acquire(MemorySessionImpl scope, Object base, long offset, $type$ value) {\n@@ -404,1 +404,1 @@\n-            return getAndSet$Type$AcquireInternal(session, base, offset, value);\n+            return getAndSet$Type$AcquireInternal(scope, base, offset, value);\n@@ -411,1 +411,1 @@\n-    private $type$ getAndSet$Type$AcquireInternal(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    private $type$ getAndSet$Type$AcquireInternal(MemorySessionImpl scope, Object base, long offset, $type$ value) {\n@@ -413,2 +413,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -418,1 +418,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -423,1 +423,1 @@\n-    public $type$ getAndSet$Type$Release(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    public $type$ getAndSet$Type$Release(MemorySessionImpl scope, Object base, long offset, $type$ value) {\n@@ -425,1 +425,1 @@\n-            return getAndSet$Type$ReleaseInternal(session, base, offset, value);\n+            return getAndSet$Type$ReleaseInternal(scope, base, offset, value);\n@@ -432,1 +432,1 @@\n-    private $type$ getAndSet$Type$ReleaseInternal(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    private $type$ getAndSet$Type$ReleaseInternal(MemorySessionImpl scope, Object base, long offset, $type$ value) {\n@@ -434,2 +434,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -439,1 +439,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -446,1 +446,1 @@\n-    public $type$ getAndAdd$Type$(MemorySessionImpl session, Object base, long offset, $type$ delta) {\n+    public $type$ getAndAdd$Type$(MemorySessionImpl scope, Object base, long offset, $type$ delta) {\n@@ -448,1 +448,1 @@\n-            return getAndAdd$Type$Internal(session, base, offset, delta);\n+            return getAndAdd$Type$Internal(scope, base, offset, delta);\n@@ -455,1 +455,1 @@\n-    private $type$ getAndAdd$Type$Internal(MemorySessionImpl session, Object base, long offset, $type$ delta) {\n+    private $type$ getAndAdd$Type$Internal(MemorySessionImpl scope, Object base, long offset, $type$ delta) {\n@@ -457,2 +457,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -462,1 +462,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -467,1 +467,1 @@\n-    public $type$ getAndAdd$Type$Acquire(MemorySessionImpl session, Object base, long offset, $type$ delta) {\n+    public $type$ getAndAdd$Type$Acquire(MemorySessionImpl scope, Object base, long offset, $type$ delta) {\n@@ -469,1 +469,1 @@\n-            return getAndAdd$Type$AcquireInternal(session, base, offset, delta);\n+            return getAndAdd$Type$AcquireInternal(scope, base, offset, delta);\n@@ -476,1 +476,1 @@\n-    private $type$ getAndAdd$Type$AcquireInternal(MemorySessionImpl session, Object base, long offset, $type$ delta) {\n+    private $type$ getAndAdd$Type$AcquireInternal(MemorySessionImpl scope, Object base, long offset, $type$ delta) {\n@@ -478,2 +478,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -483,1 +483,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -488,1 +488,1 @@\n-    public $type$ getAndAdd$Type$Release(MemorySessionImpl session, Object base, long offset, $type$ delta) {\n+    public $type$ getAndAdd$Type$Release(MemorySessionImpl scope, Object base, long offset, $type$ delta) {\n@@ -490,1 +490,1 @@\n-            return getAndAdd$Type$ReleaseInternal(session, base, offset, delta);\n+            return getAndAdd$Type$ReleaseInternal(scope, base, offset, delta);\n@@ -497,1 +497,1 @@\n-    private $type$ getAndAdd$Type$ReleaseInternal(MemorySessionImpl session, Object base, long offset, $type$ delta) {\n+    private $type$ getAndAdd$Type$ReleaseInternal(MemorySessionImpl scope, Object base, long offset, $type$ delta) {\n@@ -499,2 +499,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -504,1 +504,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -511,1 +511,1 @@\n-    public $type$ getAndBitwiseOr$Type$(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    public $type$ getAndBitwiseOr$Type$(MemorySessionImpl scope, Object base, long offset, $type$ value) {\n@@ -513,1 +513,1 @@\n-            return getAndBitwiseOr$Type$Internal(session, base, offset, value);\n+            return getAndBitwiseOr$Type$Internal(scope, base, offset, value);\n@@ -520,1 +520,1 @@\n-    private $type$ getAndBitwiseOr$Type$Internal(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    private $type$ getAndBitwiseOr$Type$Internal(MemorySessionImpl scope, Object base, long offset, $type$ value) {\n@@ -522,2 +522,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -527,1 +527,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -532,1 +532,1 @@\n-    public $type$ getAndBitwiseOr$Type$Acquire(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    public $type$ getAndBitwiseOr$Type$Acquire(MemorySessionImpl scope, Object base, long offset, $type$ value) {\n@@ -534,1 +534,1 @@\n-            return getAndBitwiseOr$Type$AcquireInternal(session, base, offset, value);\n+            return getAndBitwiseOr$Type$AcquireInternal(scope, base, offset, value);\n@@ -541,1 +541,1 @@\n-    private $type$ getAndBitwiseOr$Type$AcquireInternal(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    private $type$ getAndBitwiseOr$Type$AcquireInternal(MemorySessionImpl scope, Object base, long offset, $type$ value) {\n@@ -543,2 +543,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -548,1 +548,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -553,1 +553,1 @@\n-    public $type$ getAndBitwiseOr$Type$Release(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    public $type$ getAndBitwiseOr$Type$Release(MemorySessionImpl scope, Object base, long offset, $type$ value) {\n@@ -555,1 +555,1 @@\n-            return getAndBitwiseOr$Type$ReleaseInternal(session, base, offset, value);\n+            return getAndBitwiseOr$Type$ReleaseInternal(scope, base, offset, value);\n@@ -562,1 +562,1 @@\n-    private $type$ getAndBitwiseOr$Type$ReleaseInternal(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    private $type$ getAndBitwiseOr$Type$ReleaseInternal(MemorySessionImpl scope, Object base, long offset, $type$ value) {\n@@ -564,2 +564,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -569,1 +569,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -574,1 +574,1 @@\n-    public $type$ getAndBitwiseAnd$Type$(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    public $type$ getAndBitwiseAnd$Type$(MemorySessionImpl scope, Object base, long offset, $type$ value) {\n@@ -576,1 +576,1 @@\n-            return getAndBitwiseAnd$Type$Internal(session, base, offset, value);\n+            return getAndBitwiseAnd$Type$Internal(scope, base, offset, value);\n@@ -583,1 +583,1 @@\n-    private $type$ getAndBitwiseAnd$Type$Internal(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    private $type$ getAndBitwiseAnd$Type$Internal(MemorySessionImpl scope, Object base, long offset, $type$ value) {\n@@ -585,2 +585,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -590,1 +590,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -595,1 +595,1 @@\n-    public $type$ getAndBitwiseAnd$Type$Acquire(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    public $type$ getAndBitwiseAnd$Type$Acquire(MemorySessionImpl scope, Object base, long offset, $type$ value) {\n@@ -597,1 +597,1 @@\n-            return getAndBitwiseAnd$Type$AcquireInternal(session, base, offset, value);\n+            return getAndBitwiseAnd$Type$AcquireInternal(scope, base, offset, value);\n@@ -604,1 +604,1 @@\n-    private $type$ getAndBitwiseAnd$Type$AcquireInternal(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    private $type$ getAndBitwiseAnd$Type$AcquireInternal(MemorySessionImpl scope, Object base, long offset, $type$ value) {\n@@ -606,2 +606,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -611,1 +611,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -616,1 +616,1 @@\n-    public $type$ getAndBitwiseAnd$Type$Release(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    public $type$ getAndBitwiseAnd$Type$Release(MemorySessionImpl scope, Object base, long offset, $type$ value) {\n@@ -618,1 +618,1 @@\n-            return getAndBitwiseAnd$Type$ReleaseInternal(session, base, offset, value);\n+            return getAndBitwiseAnd$Type$ReleaseInternal(scope, base, offset, value);\n@@ -625,1 +625,1 @@\n-    private $type$ getAndBitwiseAnd$Type$ReleaseInternal(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    private $type$ getAndBitwiseAnd$Type$ReleaseInternal(MemorySessionImpl scope, Object base, long offset, $type$ value) {\n@@ -627,2 +627,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -632,1 +632,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -637,1 +637,1 @@\n-    public $type$ getAndBitwiseXor$Type$(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    public $type$ getAndBitwiseXor$Type$(MemorySessionImpl scope, Object base, long offset, $type$ value) {\n@@ -639,1 +639,1 @@\n-            return getAndBitwiseXor$Type$Internal(session, base, offset, value);\n+            return getAndBitwiseXor$Type$Internal(scope, base, offset, value);\n@@ -646,1 +646,1 @@\n-    private $type$ getAndBitwiseXor$Type$Internal(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    private $type$ getAndBitwiseXor$Type$Internal(MemorySessionImpl scope, Object base, long offset, $type$ value) {\n@@ -648,2 +648,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -653,1 +653,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -658,1 +658,1 @@\n-    public $type$ getAndBitwiseXor$Type$Acquire(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    public $type$ getAndBitwiseXor$Type$Acquire(MemorySessionImpl scope, Object base, long offset, $type$ value) {\n@@ -660,1 +660,1 @@\n-            return getAndBitwiseXor$Type$AcquireInternal(session, base, offset, value);\n+            return getAndBitwiseXor$Type$AcquireInternal(scope, base, offset, value);\n@@ -667,1 +667,1 @@\n-    private $type$ getAndBitwiseXor$Type$AcquireInternal(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    private $type$ getAndBitwiseXor$Type$AcquireInternal(MemorySessionImpl scope, Object base, long offset, $type$ value) {\n@@ -669,2 +669,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -674,1 +674,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -679,1 +679,1 @@\n-    public $type$ getAndBitwiseXor$Type$Release(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    public $type$ getAndBitwiseXor$Type$Release(MemorySessionImpl scope, Object base, long offset, $type$ value) {\n@@ -681,1 +681,1 @@\n-            return getAndBitwiseXor$Type$ReleaseInternal(session, base, offset, value);\n+            return getAndBitwiseXor$Type$ReleaseInternal(scope, base, offset, value);\n@@ -688,1 +688,1 @@\n-    private $type$ getAndBitwiseXor$Type$ReleaseInternal(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    private $type$ getAndBitwiseXor$Type$ReleaseInternal(MemorySessionImpl scope, Object base, long offset, $type$ value) {\n@@ -690,2 +690,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -695,1 +695,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess-bin.java.template","additions":198,"deletions":198,"binary":false,"changes":396,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n- * session concurrently. More specifically, when a thread wants to release a memory session, it should call the\n+ * scope concurrently. More specifically, when a thread wants to release a memory scope, it should call the\n@@ -61,2 +61,2 @@\n- * which are then stopped one by one. If any thread is found accessing a resource associated to the very memory session\n- * being closed, the handshake fails, and the session will not be closed.\n+ * which are then stopped one by one. If any thread is found accessing a resource associated to the very memory scope\n+ * being closed, the handshake fails, and the scope will not be closed.\n@@ -65,1 +65,1 @@\n- * validity of the session associated with that memory region - that is, a thread that wants to perform memory access will be\n+ * validity of the scope associated with that memory region - that is, a thread that wants to perform memory access will be\n@@ -69,1 +69,1 @@\n- * operations. Additionally, to make sure that the session object(s) of the memory being accessed is always\n+ * operations. Additionally, to make sure that the scope object(s) of the memory being accessed is always\n@@ -86,2 +86,2 @@\n-    public boolean closeScope(MemorySessionImpl session) {\n-        return closeScope0(session);\n+    public boolean closeScope(MemorySessionImpl scope) {\n+        return closeScope0(scope);\n@@ -90,1 +90,1 @@\n-    native boolean closeScope0(MemorySessionImpl session);\n+    native boolean closeScope0(MemorySessionImpl scope);\n@@ -124,1 +124,1 @@\n-    public void copyMemory(MemorySessionImpl srcSession, MemorySessionImpl dstSession,\n+    public void copyMemory(MemorySessionImpl srcScope, MemorySessionImpl dstScope,\n@@ -129,1 +129,1 @@\n-              copyMemoryInternal(srcSession, dstSession, srcBase, srcOffset, destBase, destOffset, bytes);\n+              copyMemoryInternal(srcScope, dstScope, srcBase, srcOffset, destBase, destOffset, bytes);\n@@ -136,1 +136,1 @@\n-    private void copyMemoryInternal(MemorySessionImpl srcSession, MemorySessionImpl dstSession,\n+    private void copyMemoryInternal(MemorySessionImpl srcScope, MemorySessionImpl dstScope,\n@@ -141,2 +141,2 @@\n-            if (srcSession != null) {\n-                srcSession.checkValidStateRaw();\n+            if (srcScope != null) {\n+                srcScope.checkValidStateRaw();\n@@ -144,2 +144,2 @@\n-            if (dstSession != null) {\n-                dstSession.checkValidStateRaw();\n+            if (dstScope != null) {\n+                dstScope.checkValidStateRaw();\n@@ -149,2 +149,2 @@\n-            Reference.reachabilityFence(srcSession);\n-            Reference.reachabilityFence(dstSession);\n+            Reference.reachabilityFence(srcScope);\n+            Reference.reachabilityFence(dstScope);\n@@ -155,1 +155,1 @@\n-    public void copySwapMemory(MemorySessionImpl srcSession, MemorySessionImpl dstSession,\n+    public void copySwapMemory(MemorySessionImpl srcScope, MemorySessionImpl dstScope,\n@@ -160,1 +160,1 @@\n-              copySwapMemoryInternal(srcSession, dstSession, srcBase, srcOffset, destBase, destOffset, bytes, elemSize);\n+              copySwapMemoryInternal(srcScope, dstScope, srcBase, srcOffset, destBase, destOffset, bytes, elemSize);\n@@ -167,1 +167,1 @@\n-    private void copySwapMemoryInternal(MemorySessionImpl srcSession, MemorySessionImpl dstSession,\n+    private void copySwapMemoryInternal(MemorySessionImpl srcScope, MemorySessionImpl dstScope,\n@@ -172,2 +172,2 @@\n-            if (srcSession != null) {\n-                srcSession.checkValidStateRaw();\n+            if (srcScope != null) {\n+                srcScope.checkValidStateRaw();\n@@ -175,2 +175,2 @@\n-            if (dstSession != null) {\n-                dstSession.checkValidStateRaw();\n+            if (dstScope != null) {\n+                dstScope.checkValidStateRaw();\n@@ -180,2 +180,2 @@\n-            Reference.reachabilityFence(srcSession);\n-            Reference.reachabilityFence(dstSession);\n+            Reference.reachabilityFence(srcScope);\n+            Reference.reachabilityFence(dstScope);\n@@ -186,1 +186,1 @@\n-    public void setMemory(MemorySessionImpl session, Object o, long offset, long bytes, byte value) {\n+    public void setMemory(MemorySessionImpl scope, Object o, long offset, long bytes, byte value) {\n@@ -188,1 +188,1 @@\n-            setMemoryInternal(session, o, offset, bytes, value);\n+            setMemoryInternal(scope, o, offset, bytes, value);\n@@ -195,1 +195,1 @@\n-    private void setMemoryInternal(MemorySessionImpl session, Object o, long offset, long bytes, byte value) {\n+    private void setMemoryInternal(MemorySessionImpl scope, Object o, long offset, long bytes, byte value) {\n@@ -197,2 +197,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -202,1 +202,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -207,1 +207,1 @@\n-    public int vectorizedMismatch(MemorySessionImpl aSession, MemorySessionImpl bSession,\n+    public int vectorizedMismatch(MemorySessionImpl aScope, MemorySessionImpl bScope,\n@@ -213,1 +213,1 @@\n-            return vectorizedMismatchInternal(aSession, bSession, a, aOffset, b, bOffset, length, log2ArrayIndexScale);\n+            return vectorizedMismatchInternal(aScope, bScope, a, aOffset, b, bOffset, length, log2ArrayIndexScale);\n@@ -220,1 +220,1 @@\n-    private int vectorizedMismatchInternal(MemorySessionImpl aSession, MemorySessionImpl bSession,\n+    private int vectorizedMismatchInternal(MemorySessionImpl aScope, MemorySessionImpl bScope,\n@@ -226,2 +226,2 @@\n-            if (aSession != null) {\n-                aSession.checkValidStateRaw();\n+            if (aScope != null) {\n+                aScope.checkValidStateRaw();\n@@ -229,2 +229,2 @@\n-            if (bSession != null) {\n-                bSession.checkValidStateRaw();\n+            if (bScope != null) {\n+                bScope.checkValidStateRaw();\n@@ -234,2 +234,2 @@\n-            Reference.reachabilityFence(aSession);\n-            Reference.reachabilityFence(bSession);\n+            Reference.reachabilityFence(aScope);\n+            Reference.reachabilityFence(bScope);\n@@ -240,1 +240,1 @@\n-    public boolean isLoaded(MemorySessionImpl session, long address, boolean isSync, long size) {\n+    public boolean isLoaded(MemorySessionImpl scope, long address, boolean isSync, long size) {\n@@ -242,1 +242,1 @@\n-            return isLoadedInternal(session, address, isSync, size);\n+            return isLoadedInternal(scope, address, isSync, size);\n@@ -249,1 +249,1 @@\n-    public boolean isLoadedInternal(MemorySessionImpl session, long address, boolean isSync, long size) {\n+    public boolean isLoadedInternal(MemorySessionImpl scope, long address, boolean isSync, long size) {\n@@ -251,2 +251,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -256,1 +256,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -261,1 +261,1 @@\n-    public void load(MemorySessionImpl session, long address, boolean isSync, long size) {\n+    public void load(MemorySessionImpl scope, long address, boolean isSync, long size) {\n@@ -263,1 +263,1 @@\n-            loadInternal(session, address, isSync, size);\n+            loadInternal(scope, address, isSync, size);\n@@ -270,1 +270,1 @@\n-    public void loadInternal(MemorySessionImpl session, long address, boolean isSync, long size) {\n+    public void loadInternal(MemorySessionImpl scope, long address, boolean isSync, long size) {\n@@ -272,2 +272,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -277,1 +277,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -282,1 +282,1 @@\n-    public void unload(MemorySessionImpl session, long address, boolean isSync, long size) {\n+    public void unload(MemorySessionImpl scope, long address, boolean isSync, long size) {\n@@ -284,1 +284,1 @@\n-            unloadInternal(session, address, isSync, size);\n+            unloadInternal(scope, address, isSync, size);\n@@ -291,1 +291,1 @@\n-    public void unloadInternal(MemorySessionImpl session, long address, boolean isSync, long size) {\n+    public void unloadInternal(MemorySessionImpl scope, long address, boolean isSync, long size) {\n@@ -293,2 +293,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -298,1 +298,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -303,1 +303,1 @@\n-    public void force(MemorySessionImpl session, FileDescriptor fd, long address, boolean isSync, long index, long length) {\n+    public void force(MemorySessionImpl scope, FileDescriptor fd, long address, boolean isSync, long index, long length) {\n@@ -305,1 +305,1 @@\n-            forceInternal(session, fd, address, isSync, index, length);\n+            forceInternal(scope, fd, address, isSync, index, length);\n@@ -312,1 +312,1 @@\n-    public void forceInternal(MemorySessionImpl session, FileDescriptor fd, long address, boolean isSync, long index, long length) {\n+    public void forceInternal(MemorySessionImpl scope, FileDescriptor fd, long address, boolean isSync, long index, long length) {\n@@ -314,2 +314,2 @@\n-            if (session != null) {\n-                session.checkValidStateRaw();\n+            if (scope != null) {\n+                scope.checkValidStateRaw();\n@@ -319,1 +319,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -339,1 +339,1 @@\n-                    msp.sessionImpl(),\n+                    msp.scopeImpl(),\n@@ -353,1 +353,1 @@\n-    V loadFromMemorySegmentScopedInternal(MemorySessionImpl session,\n+    V loadFromMemorySegmentScopedInternal(MemorySessionImpl scope,\n@@ -359,1 +359,1 @@\n-            session.checkValidStateRaw();\n+            scope.checkValidStateRaw();\n@@ -366,1 +366,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -384,1 +384,1 @@\n-                    msp.sessionImpl(),\n+                    msp.scopeImpl(),\n@@ -399,1 +399,1 @@\n-    V loadFromMemorySegmentMaskedScopedInternal(MemorySessionImpl session, Class<? extends V> vmClass,\n+    V loadFromMemorySegmentMaskedScopedInternal(MemorySessionImpl scope, Class<? extends V> vmClass,\n@@ -405,1 +405,1 @@\n-            session.checkValidStateRaw();\n+            scope.checkValidStateRaw();\n@@ -412,1 +412,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -430,1 +430,1 @@\n-                    msp.sessionImpl(),\n+                    msp.scopeImpl(),\n@@ -444,1 +444,1 @@\n-    void storeIntoMemorySegmentScopedInternal(MemorySessionImpl session,\n+    void storeIntoMemorySegmentScopedInternal(MemorySessionImpl scope,\n@@ -450,1 +450,1 @@\n-            session.checkValidStateRaw();\n+            scope.checkValidStateRaw();\n@@ -458,1 +458,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n@@ -476,1 +476,1 @@\n-                    msp.sessionImpl(),\n+                    msp.scopeImpl(),\n@@ -490,1 +490,1 @@\n-    void storeIntoMemorySegmentMaskedScopedInternal(MemorySessionImpl session,\n+    void storeIntoMemorySegmentMaskedScopedInternal(MemorySessionImpl scope,\n@@ -496,1 +496,1 @@\n-            session.checkValidStateRaw();\n+            scope.checkValidStateRaw();\n@@ -504,1 +504,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(scope);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":81,"deletions":81,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -787,1 +787,1 @@\n-        NIO_ACCESS.acquireSession(bb);\n+        NIO_ACCESS.acquireScope(bb);\n@@ -797,1 +797,1 @@\n-            NIO_ACCESS.releaseSession(bb);\n+            NIO_ACCESS.releaseScope(bb);\n@@ -942,1 +942,1 @@\n-        NIO_ACCESS.acquireSession(bb);\n+        NIO_ACCESS.acquireScope(bb);\n@@ -952,1 +952,1 @@\n-            NIO_ACCESS.releaseSession(bb);\n+            NIO_ACCESS.releaseScope(bb);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramChannelImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-    \/\/ is backed by a memory session that is explicitly closeable.\n+    \/\/ is backed by a memory scope that is explicitly closeable.\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DirectBuffer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1211,1 +1211,1 @@\n-                             SegmentScope session)\n+                             SegmentScope scope)\n@@ -1215,3 +1215,3 @@\n-        Objects.requireNonNull(session, \"Session is null\");\n-        MemorySessionImpl sessionImpl = (MemorySessionImpl) session;\n-        sessionImpl.checkValidState();\n+        Objects.requireNonNull(scope, \"Scope is null\");\n+        MemorySessionImpl scopeImpl = (MemorySessionImpl) scope;\n+        scopeImpl.checkValidState();\n@@ -1233,1 +1233,1 @@\n-                                            readOnly, session);\n+                                            readOnly, scope);\n@@ -1241,1 +1241,1 @@\n-            sessionImpl.addOrCleanupIfFail(resource);\n+            scopeImpl.addOrCleanupIfFail(resource);\n@@ -1244,1 +1244,1 @@\n-            return new MappedMemorySegmentImpl.EmptyMappedMemorySegmentImpl(readOnly, sessionImpl);\n+            return new MappedMemorySegmentImpl.EmptyMappedMemorySegmentImpl(readOnly, scopeImpl);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import jdk.internal.foreign.MemorySessionImpl;\n@@ -186,1 +185,1 @@\n-                if (NIO_ACCESS.hasSession(buf)) {\n+                if (NIO_ACCESS.hasScope(buf)) {\n@@ -398,1 +397,1 @@\n-                if (NIO_ACCESS.hasSession(buf)) {\n+                if (NIO_ACCESS.hasScope(buf)) {\n@@ -480,1 +479,1 @@\n-            throw new IllegalStateException(\"Confined session not supported\");\n+            throw new IllegalStateException(\"Confined scope not supported\");\n@@ -482,1 +481,1 @@\n-        NIO_ACCESS.acquireSession(bb);\n+        NIO_ACCESS.acquireScope(bb);\n@@ -487,1 +486,1 @@\n-            NIO_ACCESS.releaseSession(bb);\n+            NIO_ACCESS.releaseScope(bb);\n@@ -549,1 +548,1 @@\n-            return NIO_ACCESS.hasSession(bb)\n+            return NIO_ACCESS.hasScope(bb)\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/IOUtil.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n-            NIO_ACCESS.acquireSession(dst);\n+            NIO_ACCESS.acquireScope(dst);\n@@ -189,1 +189,1 @@\n-                NIO_ACCESS.releaseSession(dst);\n+                NIO_ACCESS.releaseScope(dst);\n@@ -245,1 +245,1 @@\n-            NIO_ACCESS.acquireSession(src);\n+            NIO_ACCESS.acquireScope(src);\n@@ -252,1 +252,1 @@\n-                NIO_ACCESS.releaseSession(src);\n+                NIO_ACCESS.releaseScope(src);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixUserDefinedFileAttributeView.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -712,1 +712,1 @@\n-        NIO_ACCESS.acquireSession(inBuffer);\n+        NIO_ACCESS.acquireScope(inBuffer);\n@@ -714,1 +714,1 @@\n-            NIO_ACCESS.acquireSession(outBuffer);\n+            NIO_ACCESS.acquireScope(outBuffer);\n@@ -796,1 +796,1 @@\n-                NIO_ACCESS.releaseSession(outBuffer);\n+                NIO_ACCESS.releaseScope(outBuffer);\n@@ -799,1 +799,1 @@\n-            NIO_ACCESS.releaseSession(inBuffer);\n+            NIO_ACCESS.releaseScope(inBuffer);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11AEADCipher.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -685,1 +685,1 @@\n-        NIO_ACCESS.acquireSession(inBuffer);\n+        NIO_ACCESS.acquireScope(inBuffer);\n@@ -687,1 +687,1 @@\n-            NIO_ACCESS.acquireSession(outBuffer);\n+            NIO_ACCESS.acquireScope(outBuffer);\n@@ -798,1 +798,1 @@\n-                NIO_ACCESS.releaseSession(outBuffer);\n+                NIO_ACCESS.releaseScope(outBuffer);\n@@ -801,1 +801,1 @@\n-            NIO_ACCESS.releaseSession(inBuffer);\n+            NIO_ACCESS.releaseScope(inBuffer);\n@@ -892,1 +892,1 @@\n-        NIO_ACCESS.acquireSession(outBuffer);\n+        NIO_ACCESS.acquireScope(outBuffer);\n@@ -989,1 +989,1 @@\n-            NIO_ACCESS.releaseSession(outBuffer);\n+            NIO_ACCESS.releaseScope(outBuffer);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Cipher.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -290,1 +290,1 @@\n-            NIO_ACCESS.acquireSession(byteBuffer);\n+            NIO_ACCESS.acquireScope(byteBuffer);\n@@ -294,1 +294,1 @@\n-                NIO_ACCESS.releaseSession(byteBuffer);\n+                NIO_ACCESS.releaseScope(byteBuffer);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Digest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -558,1 +558,1 @@\n-        NIO_ACCESS.acquireSession(inBuffer);\n+        NIO_ACCESS.acquireScope(inBuffer);\n@@ -560,1 +560,1 @@\n-            NIO_ACCESS.acquireSession(outBuffer);\n+            NIO_ACCESS.acquireScope(outBuffer);\n@@ -636,1 +636,1 @@\n-                NIO_ACCESS.releaseSession(outBuffer);\n+                NIO_ACCESS.releaseScope(outBuffer);\n@@ -639,1 +639,1 @@\n-            NIO_ACCESS.releaseSession(inBuffer);\n+            NIO_ACCESS.releaseScope(inBuffer);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyWrapCipher.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -258,1 +258,1 @@\n-            NIO_ACCESS.acquireSession(byteBuffer);\n+            NIO_ACCESS.acquireScope(byteBuffer);\n@@ -262,1 +262,1 @@\n-                NIO_ACCESS.releaseSession(byteBuffer);\n+                NIO_ACCESS.releaseScope(byteBuffer);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Mac.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -624,1 +624,1 @@\n-                NIO_ACCESS.acquireSession(byteBuffer);\n+                NIO_ACCESS.acquireScope(byteBuffer);\n@@ -642,1 +642,1 @@\n-                    NIO_ACCESS.releaseSession(byteBuffer);\n+                    NIO_ACCESS.releaseScope(byteBuffer);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11PSSSignature.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -588,1 +588,1 @@\n-                NIO_ACCESS.acquireSession(byteBuffer);\n+                NIO_ACCESS.acquireScope(byteBuffer);\n@@ -604,1 +604,1 @@\n-                    NIO_ACCESS.releaseSession(byteBuffer);\n+                    NIO_ACCESS.releaseScope(byteBuffer);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Signature.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3286,2 +3286,2 @@\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n+     * @throws IllegalStateException if the memory segment's scope is not alive,\n+     *         or if access occurs from a thread other than the thread owning the scope.\n@@ -3338,2 +3338,2 @@\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n+     * @throws IllegalStateException if the memory segment's scope is not alive,\n+     *         or if access occurs from a thread other than the thread owning the scope.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2969,2 +2969,2 @@\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n+     * @throws IllegalStateException if the memory segment's scope is not alive,\n+     *         or if access occurs from a thread other than the thread owning the scope.\n@@ -3026,2 +3026,2 @@\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n+     * @throws IllegalStateException if the memory segment's scope is not alive,\n+     *         or if access occurs from a thread other than the thread owning the scope.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2975,2 +2975,2 @@\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n+     * @throws IllegalStateException if the memory segment's scope is not alive,\n+     *         or if access occurs from a thread other than the thread owning the scope.\n@@ -3032,2 +3032,2 @@\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n+     * @throws IllegalStateException if the memory segment's scope is not alive,\n+     *         or if access occurs from a thread other than the thread owning the scope.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3131,2 +3131,2 @@\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n+     * @throws IllegalStateException if the memory segment's scope is not alive,\n+     *         or if access occurs from a thread other than the thread owning the scope.\n@@ -3188,2 +3188,2 @@\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n+     * @throws IllegalStateException if the memory segment's scope is not alive,\n+     *         or if access occurs from a thread other than the thread owning the scope.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3010,2 +3010,2 @@\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n+     * @throws IllegalStateException if the memory segment's scope is not alive,\n+     *         or if access occurs from a thread other than the thread owning the scope.\n@@ -3067,2 +3067,2 @@\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n+     * @throws IllegalStateException if the memory segment's scope is not alive,\n+     *         or if access occurs from a thread other than the thread owning the scope.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3280,2 +3280,2 @@\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n+     * @throws IllegalStateException if the memory segment's scope is not alive,\n+     *         or if access occurs from a thread other than the thread owning the scope.\n@@ -3337,2 +3337,2 @@\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n+     * @throws IllegalStateException if the memory segment's scope is not alive,\n+     *         or if access occurs from a thread other than the thread owning the scope.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3395,2 +3395,2 @@\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n+     * @throws IllegalStateException if the memory segment's scope is not alive,\n+     *         or if access occurs from a thread other than the thread owning the scope.\n@@ -3448,2 +3448,2 @@\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n+     * @throws IllegalStateException if the memory segment's scope is not alive,\n+     *         or if access occurs from a thread other than the thread owning the scope.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Vector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4082,2 +4082,2 @@\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n+     * @throws IllegalStateException if the memory segment's scope is not alive,\n+     *         or if access occurs from a thread other than the thread owning the scope.\n@@ -4143,2 +4143,2 @@\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n+     * @throws IllegalStateException if the memory segment's scope is not alive,\n+     *         or if access occurs from a thread other than the thread owning the scope.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -847,1 +847,1 @@\n-        NIO_ACCESS.acquireSession(bb);\n+        NIO_ACCESS.acquireScope(bb);\n@@ -855,1 +855,1 @@\n-            NIO_ACCESS.releaseSession(bb);\n+            NIO_ACCESS.releaseScope(bb);\n@@ -1041,1 +1041,1 @@\n-        NIO_ACCESS.acquireSession(bb);\n+        NIO_ACCESS.acquireScope(bb);\n@@ -1049,1 +1049,1 @@\n-            NIO_ACCESS.releaseSession(bb);\n+            NIO_ACCESS.releaseScope(bb);\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpChannelImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -590,1 +590,1 @@\n-        NIO_ACCESS.acquireSession(bb);\n+        NIO_ACCESS.acquireScope(bb);\n@@ -597,1 +597,1 @@\n-            NIO_ACCESS.releaseSession(bb);\n+            NIO_ACCESS.releaseScope(bb);\n@@ -920,1 +920,1 @@\n-        NIO_ACCESS.acquireSession(bb);\n+        NIO_ACCESS.acquireScope(bb);\n@@ -928,1 +928,1 @@\n-            NIO_ACCESS.releaseSession(bb);\n+            NIO_ACCESS.releaseScope(bb);\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpMultiChannelImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -74,2 +74,2 @@\n-    private static MemorySegment loadLibrary(SegmentScope session) {\n-        SymbolLookup lib = SymbolLookup.libraryLookup(LIB_PATH, session);\n+    private static MemorySegment loadLibrary(SegmentScope scope) {\n+        SymbolLookup lib = SymbolLookup.libraryLookup(LIB_PATH, scope);\n@@ -77,1 +77,1 @@\n-        assertEquals(addr.scope(), session);\n+        assertEquals(addr.scope(), scope);\n","filename":"test\/jdk\/java\/foreign\/LibraryLookupTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n-            handle.invokeExact(list.segment(), sessionChecker(arena));\n+            handle.invokeExact(list.segment(), scopeChecker(arena));\n@@ -166,1 +166,1 @@\n-            handle.invokeExact(segment, sessionChecker(arena));\n+            handle.invokeExact(segment, scopeChecker(arena));\n@@ -179,1 +179,1 @@\n-            handle.invokeExact(upcall, sessionChecker(arena));\n+            handle.invokeExact(upcall, scopeChecker(arena));\n@@ -183,1 +183,1 @@\n-    MemorySegment sessionChecker(Arena arena) {\n+    MemorySegment scopeChecker(Arena arena) {\n@@ -185,1 +185,1 @@\n-            MethodHandle handle = MethodHandles.lookup().findStatic(SafeFunctionAccessTest.class, \"checkSession\",\n+            MethodHandle handle = MethodHandles.lookup().findStatic(SafeFunctionAccessTest.class, \"checkScope\",\n@@ -194,1 +194,1 @@\n-    static void checkSession(Arena arena) {\n+    static void checkScope(Arena arena) {\n@@ -197,1 +197,1 @@\n-            fail(\"Session closed unexpectedly!\");\n+            fail(\"Scope closed unexpectedly!\");\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -367,1 +367,1 @@\n-        \/\/outside of session!!\n+        \/\/outside of scope!!\n@@ -374,1 +374,1 @@\n-                \/\/all get\/set buffer operation should fail because of the session check\n+                \/\/all get\/set buffer operation should fail because of the scope check\n@@ -483,1 +483,1 @@\n-    public void testBufferOnClosedSession() {\n+    public void testBufferOnClosedScope() {\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-            throw new AssertionError(); \/\/not ok, session is closed\n+            throw new AssertionError(); \/\/not ok, scope is closed\n@@ -120,1 +120,1 @@\n-            \/\/ok, should fail (session is closed)\n+            \/\/ok, should fail (scope is closed)\n@@ -152,1 +152,1 @@\n-            throw new AssertionError(); \/\/not ok, session is closed\n+            throw new AssertionError(); \/\/not ok, scope is closed\n@@ -154,1 +154,1 @@\n-            \/\/ok, should fail (session is closed)\n+            \/\/ok, should fail (scope is closed)\n@@ -224,1 +224,1 @@\n-            throw new AssertionError(); \/\/not ok, session is closed\n+            throw new AssertionError(); \/\/not ok, scope is closed\n@@ -226,1 +226,1 @@\n-            \/\/ok, should fail (session is closed)\n+            \/\/ok, should fail (scope is closed)\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccess.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,375 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.ref java.base\/jdk.internal.foreign\n+ * @run testng\/othervm TestMemoryScope\n+ *\/\n+\n+import java.lang.foreign.Arena;\n+\n+import java.lang.foreign.SegmentScope;\n+\n+import jdk.internal.foreign.MemorySessionImpl;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+import java.util.stream.IntStream;\n+\n+public class TestMemoryScope {\n+\n+    final static int N_THREADS = 100;\n+\n+    @Test\n+    public void testConfined() {\n+        AtomicInteger acc = new AtomicInteger();\n+        Arena arena = Arena.openConfined();\n+        for (int i = 0 ; i < N_THREADS ; i++) {\n+            int delta = i;\n+            addCloseAction(arena.scope(), () -> acc.addAndGet(delta));\n+        }\n+        assertEquals(acc.get(), 0);\n+\n+        arena.close();\n+        assertEquals(acc.get(), IntStream.range(0, N_THREADS).sum());\n+    }\n+\n+    @Test(dataProvider = \"sharedScopes\")\n+    public void testSharedSingleThread(ScopeSupplier scopeSupplier) {\n+        AtomicInteger acc = new AtomicInteger();\n+        SegmentScope scope = scopeSupplier.get();\n+        for (int i = 0 ; i < N_THREADS ; i++) {\n+            int delta = i;\n+            addCloseAction(scope, () -> acc.addAndGet(delta));\n+        }\n+        assertEquals(acc.get(), 0);\n+\n+        if (!ScopeSupplier.isImplicit(scope)) {\n+            ScopeSupplier.close(scope);\n+            assertEquals(acc.get(), IntStream.range(0, N_THREADS).sum());\n+        } else {\n+            scope = null;\n+            int expected = IntStream.range(0, N_THREADS).sum();\n+            while (acc.get() != expected) {\n+                kickGC();\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"sharedScopes\")\n+    public void testSharedMultiThread(ScopeSupplier scopeSupplier) {\n+        AtomicInteger acc = new AtomicInteger();\n+        List<Thread> threads = new ArrayList<>();\n+        SegmentScope scope = scopeSupplier.get();\n+        AtomicReference<SegmentScope> scopeRef = new AtomicReference<>(scope);\n+        for (int i = 0 ; i < N_THREADS ; i++) {\n+            int delta = i;\n+            Thread thread = new Thread(() -> {\n+                try {\n+                    addCloseAction(scopeRef.get(), () -> {\n+                        acc.addAndGet(delta);\n+                    });\n+                } catch (IllegalStateException ex) {\n+                    \/\/ already closed - we need to call cleanup manually\n+                    acc.addAndGet(delta);\n+                }\n+            });\n+            threads.add(thread);\n+        }\n+        assertEquals(acc.get(), 0);\n+        threads.forEach(Thread::start);\n+\n+        \/\/ if no cleaner, close - not all segments might have been added to the scope!\n+        \/\/ if cleaner, don't unset the scope - after all, the scope is kept alive by threads\n+        if (!ScopeSupplier.isImplicit(scope)) {\n+            while (true) {\n+                try {\n+                    ScopeSupplier.close(scope);\n+                    break;\n+                } catch (IllegalStateException ise) {\n+                    \/\/ scope is acquired (by add) - wait some more\n+                }\n+            }\n+        }\n+\n+        threads.forEach(t -> {\n+            try {\n+                t.join();\n+            } catch (InterruptedException ex) {\n+                fail();\n+            }\n+        });\n+\n+        if (!ScopeSupplier.isImplicit(scope)) {\n+            assertEquals(acc.get(), IntStream.range(0, N_THREADS).sum());\n+        } else {\n+            scope = null;\n+            scopeRef.set(null);\n+            int expected = IntStream.range(0, N_THREADS).sum();\n+            while (acc.get() != expected) {\n+                kickGC();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testLockSingleThread() {\n+        Arena arena = Arena.openConfined();\n+        List<Arena> handles = new ArrayList<>();\n+        for (int i = 0 ; i < N_THREADS ; i++) {\n+            Arena handle = Arena.openConfined();\n+            keepAlive(handle.scope(), arena.scope());\n+            handles.add(handle);\n+        }\n+\n+        while (true) {\n+            try {\n+                arena.close();\n+                assertEquals(handles.size(), 0);\n+                break;\n+            } catch (IllegalStateException ex) {\n+                assertTrue(handles.size() > 0);\n+                Arena handle = handles.remove(0);\n+                handle.close();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testLockSharedMultiThread() {\n+        Arena arena = Arena.openShared();\n+        AtomicInteger lockCount = new AtomicInteger();\n+        for (int i = 0 ; i < N_THREADS ; i++) {\n+            new Thread(() -> {\n+                try (Arena handle = Arena.openConfined()) {\n+                    keepAlive(handle.scope(), arena.scope());\n+                    lockCount.incrementAndGet();\n+                    waitSomeTime();\n+                    lockCount.decrementAndGet();\n+                } catch (IllegalStateException ex) {\n+                    \/\/ might be already closed - do nothing\n+                }\n+            }).start();\n+        }\n+\n+        while (true) {\n+            try {\n+                arena.close();\n+                assertEquals(lockCount.get(), 0);\n+                break;\n+            } catch (IllegalStateException ex) {\n+                waitSomeTime();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testCloseEmptyConfinedScope() {\n+        Arena.openConfined().close();\n+    }\n+\n+    @Test\n+    public void testCloseEmptySharedScope() {\n+        Arena.openShared().close();\n+    }\n+\n+    @Test\n+    public void testCloseConfinedLock() {\n+        Arena arena = Arena.openConfined();\n+        Arena handle = Arena.openConfined();\n+        keepAlive(handle.scope(), arena.scope());\n+        AtomicReference<Throwable> failure = new AtomicReference<>();\n+        Thread t = new Thread(() -> {\n+            try {\n+                handle.close();\n+            } catch (Throwable ex) {\n+                failure.set(ex);\n+            }\n+        });\n+        t.start();\n+        try {\n+            t.join();\n+            assertNotNull(failure.get());\n+            assertEquals(failure.get().getClass(), WrongThreadException.class);\n+        } catch (Throwable ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"allScopes\")\n+    public void testScopeAcquires(ScopeSupplier scopeSupplier) {\n+        SegmentScope scope = scopeSupplier.get();\n+        acquireRecursive(scope, 5);\n+        if (!ScopeSupplier.isImplicit(scope))\n+            ScopeSupplier.close(scope);\n+    }\n+\n+    private void acquireRecursive(SegmentScope scope, int acquireCount) {\n+        try (Arena arena = Arena.openConfined()) {\n+            keepAlive(arena.scope(), scope);\n+            if (acquireCount > 0) {\n+                \/\/ recursive acquire\n+                acquireRecursive(scope, acquireCount - 1);\n+            }\n+            if (!ScopeSupplier.isImplicit(scope)) {\n+                assertThrows(IllegalStateException.class, () -> ScopeSupplier.close(scope));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testConfinedScopeWithImplicitDependency() {\n+        Arena root = Arena.openConfined();\n+        \/\/ Create many implicit scopes which depend on 'root', and let them become unreachable.\n+        for (int i = 0; i < N_THREADS; i++) {\n+            keepAlive(SegmentScope.auto(), root.scope());\n+        }\n+        \/\/ Now let's keep trying to close 'root' until we succeed. This is trickier than it seems: cleanup action\n+        \/\/ might be called from another thread (the Cleaner thread), so that the confined scope lock count is updated racily.\n+        \/\/ If that happens, the loop below never terminates.\n+        while (true) {\n+            try {\n+                root.close();\n+                break; \/\/ success!\n+            } catch (IllegalStateException ex) {\n+                kickGC();\n+                for (int i = 0 ; i < N_THREADS ; i++) {  \/\/ add more races from current thread\n+                    try (Arena arena = Arena.openConfined()) {\n+                        keepAlive(arena.scope(), root.scope());\n+                        \/\/ dummy\n+                    }\n+                }\n+                \/\/ try again\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testConfinedScopeWithSharedDependency() {\n+        Arena root = Arena.openConfined();\n+        List<Thread> threads = new ArrayList<>();\n+        \/\/ Create many implicit scopes which depend on 'root', and let them become unreachable.\n+        for (int i = 0; i < N_THREADS; i++) {\n+            Arena arena = Arena.openShared(); \/\/ create scope inside same thread!\n+            keepAlive(arena.scope(), root.scope());\n+            Thread t = new Thread(arena::close); \/\/ close from another thread!\n+            threads.add(t);\n+            t.start();\n+        }\n+        for (int i = 0 ; i < N_THREADS ; i++) { \/\/ add more races from current thread\n+            try (Arena arena = Arena.openConfined()) {\n+                keepAlive(arena.scope(), root.scope());\n+                \/\/ dummy\n+            }\n+        }\n+        threads.forEach(t -> {\n+            try {\n+                t.join();\n+            } catch (InterruptedException ex) {\n+                \/\/ ok\n+            }\n+        });\n+        \/\/ Now let's close 'root'. This is trickier than it seems: releases of the confined scope happen in different\n+        \/\/ threads, so that the confined scope lock count is updated racily. If that happens, the following close will blow up.\n+        root.close();\n+    }\n+\n+    private void waitSomeTime() {\n+        try {\n+            Thread.sleep(10);\n+        } catch (InterruptedException ex) {\n+            \/\/ ignore\n+        }\n+    }\n+\n+    private void kickGC() {\n+        for (int i = 0 ; i < 100 ; i++) {\n+            byte[] b = new byte[100];\n+            System.gc();\n+            Thread.onSpinWait();\n+        }\n+    }\n+\n+    @DataProvider\n+    static Object[][] drops() {\n+        return new Object[][] {\n+                { (Supplier<Arena>) Arena::openConfined},\n+                { (Supplier<Arena>) Arena::openShared},\n+        };\n+    }\n+\n+    private void keepAlive(SegmentScope child, SegmentScope parent) {\n+        MemorySessionImpl parentImpl = (MemorySessionImpl) parent;\n+        parentImpl.acquire0();\n+        addCloseAction(child, parentImpl::release0);\n+    }\n+\n+    private void addCloseAction(SegmentScope scope, Runnable action) {\n+        MemorySessionImpl scopeImpl = (MemorySessionImpl) scope;\n+        scopeImpl.addCloseAction(action);\n+    }\n+\n+    interface ScopeSupplier extends Supplier<SegmentScope> {\n+\n+        static void close(SegmentScope scope) {\n+            ((MemorySessionImpl)scope).close();\n+        }\n+\n+        static boolean isImplicit(SegmentScope scope) {\n+            return !((MemorySessionImpl)scope).isCloseable();\n+        }\n+\n+        static ScopeSupplier ofImplicit() {\n+            return SegmentScope::auto;\n+        }\n+\n+        static ScopeSupplier ofArena(Supplier<Arena> arenaSupplier) {\n+            return () -> arenaSupplier.get().scope();\n+        }\n+    }\n+\n+    @DataProvider(name = \"sharedScopes\")\n+    static Object[][] sharedScopes() {\n+        return new Object[][] {\n+                { ScopeSupplier.ofArena(Arena::openShared) },\n+                { ScopeSupplier.ofImplicit() },\n+        };\n+    }\n+\n+    @DataProvider(name = \"allScopes\")\n+    static Object[][] allScopes() {\n+        return new Object[][] {\n+                { ScopeSupplier.ofArena(Arena::openConfined) },\n+                { ScopeSupplier.ofArena(Arena::openShared) },\n+                { ScopeSupplier.ofImplicit() },\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestMemoryScope.java","additions":375,"deletions":0,"binary":false,"changes":375,"status":"added"},{"patch":"@@ -1,375 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @enablePreview\n- * @modules java.base\/jdk.internal.ref java.base\/jdk.internal.foreign\n- * @run testng\/othervm TestMemorySession\n- *\/\n-\n-import java.lang.foreign.Arena;\n-\n-import java.lang.foreign.SegmentScope;\n-\n-import jdk.internal.foreign.MemorySessionImpl;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.function.Supplier;\n-import java.util.stream.IntStream;\n-\n-public class TestMemorySession {\n-\n-    final static int N_THREADS = 100;\n-\n-    @Test\n-    public void testConfined() {\n-        AtomicInteger acc = new AtomicInteger();\n-        Arena arena = Arena.openConfined();\n-        for (int i = 0 ; i < N_THREADS ; i++) {\n-            int delta = i;\n-            addCloseAction(arena.scope(), () -> acc.addAndGet(delta));\n-        }\n-        assertEquals(acc.get(), 0);\n-\n-        arena.close();\n-        assertEquals(acc.get(), IntStream.range(0, N_THREADS).sum());\n-    }\n-\n-    @Test(dataProvider = \"sharedSessions\")\n-    public void testSharedSingleThread(SessionSupplier sessionSupplier) {\n-        AtomicInteger acc = new AtomicInteger();\n-        SegmentScope session = sessionSupplier.get();\n-        for (int i = 0 ; i < N_THREADS ; i++) {\n-            int delta = i;\n-            addCloseAction(session, () -> acc.addAndGet(delta));\n-        }\n-        assertEquals(acc.get(), 0);\n-\n-        if (!SessionSupplier.isImplicit(session)) {\n-            SessionSupplier.close(session);\n-            assertEquals(acc.get(), IntStream.range(0, N_THREADS).sum());\n-        } else {\n-            session = null;\n-            int expected = IntStream.range(0, N_THREADS).sum();\n-            while (acc.get() != expected) {\n-                kickGC();\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"sharedSessions\")\n-    public void testSharedMultiThread(SessionSupplier sessionSupplier) {\n-        AtomicInteger acc = new AtomicInteger();\n-        List<Thread> threads = new ArrayList<>();\n-        SegmentScope session = sessionSupplier.get();\n-        AtomicReference<SegmentScope> sessionRef = new AtomicReference<>(session);\n-        for (int i = 0 ; i < N_THREADS ; i++) {\n-            int delta = i;\n-            Thread thread = new Thread(() -> {\n-                try {\n-                    addCloseAction(sessionRef.get(), () -> {\n-                        acc.addAndGet(delta);\n-                    });\n-                } catch (IllegalStateException ex) {\n-                    \/\/ already closed - we need to call cleanup manually\n-                    acc.addAndGet(delta);\n-                }\n-            });\n-            threads.add(thread);\n-        }\n-        assertEquals(acc.get(), 0);\n-        threads.forEach(Thread::start);\n-\n-        \/\/ if no cleaner, close - not all segments might have been added to the session!\n-        \/\/ if cleaner, don't unset the session - after all, the session is kept alive by threads\n-        if (!SessionSupplier.isImplicit(session)) {\n-            while (true) {\n-                try {\n-                    SessionSupplier.close(session);\n-                    break;\n-                } catch (IllegalStateException ise) {\n-                    \/\/ session is acquired (by add) - wait some more\n-                }\n-            }\n-        }\n-\n-        threads.forEach(t -> {\n-            try {\n-                t.join();\n-            } catch (InterruptedException ex) {\n-                fail();\n-            }\n-        });\n-\n-        if (!SessionSupplier.isImplicit(session)) {\n-            assertEquals(acc.get(), IntStream.range(0, N_THREADS).sum());\n-        } else {\n-            session = null;\n-            sessionRef.set(null);\n-            int expected = IntStream.range(0, N_THREADS).sum();\n-            while (acc.get() != expected) {\n-                kickGC();\n-            }\n-        }\n-    }\n-\n-    @Test\n-    public void testLockSingleThread() {\n-        Arena arena = Arena.openConfined();\n-        List<Arena> handles = new ArrayList<>();\n-        for (int i = 0 ; i < N_THREADS ; i++) {\n-            Arena handle = Arena.openConfined();\n-            keepAlive(handle.scope(), arena.scope());\n-            handles.add(handle);\n-        }\n-\n-        while (true) {\n-            try {\n-                arena.close();\n-                assertEquals(handles.size(), 0);\n-                break;\n-            } catch (IllegalStateException ex) {\n-                assertTrue(handles.size() > 0);\n-                Arena handle = handles.remove(0);\n-                handle.close();\n-            }\n-        }\n-    }\n-\n-    @Test\n-    public void testLockSharedMultiThread() {\n-        Arena arena = Arena.openShared();\n-        AtomicInteger lockCount = new AtomicInteger();\n-        for (int i = 0 ; i < N_THREADS ; i++) {\n-            new Thread(() -> {\n-                try (Arena handle = Arena.openConfined()) {\n-                    keepAlive(handle.scope(), arena.scope());\n-                    lockCount.incrementAndGet();\n-                    waitSomeTime();\n-                    lockCount.decrementAndGet();\n-                } catch (IllegalStateException ex) {\n-                    \/\/ might be already closed - do nothing\n-                }\n-            }).start();\n-        }\n-\n-        while (true) {\n-            try {\n-                arena.close();\n-                assertEquals(lockCount.get(), 0);\n-                break;\n-            } catch (IllegalStateException ex) {\n-                waitSomeTime();\n-            }\n-        }\n-    }\n-\n-    @Test\n-    public void testCloseEmptyConfinedSession() {\n-        Arena.openConfined().close();\n-    }\n-\n-    @Test\n-    public void testCloseEmptySharedSession() {\n-        Arena.openShared().close();\n-    }\n-\n-    @Test\n-    public void testCloseConfinedLock() {\n-        Arena arena = Arena.openConfined();\n-        Arena handle = Arena.openConfined();\n-        keepAlive(handle.scope(), arena.scope());\n-        AtomicReference<Throwable> failure = new AtomicReference<>();\n-        Thread t = new Thread(() -> {\n-            try {\n-                handle.close();\n-            } catch (Throwable ex) {\n-                failure.set(ex);\n-            }\n-        });\n-        t.start();\n-        try {\n-            t.join();\n-            assertNotNull(failure.get());\n-            assertEquals(failure.get().getClass(), WrongThreadException.class);\n-        } catch (Throwable ex) {\n-            throw new AssertionError(ex);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"allSessions\")\n-    public void testSessionAcquires(SessionSupplier sessionSupplier) {\n-        SegmentScope session = sessionSupplier.get();\n-        acquireRecursive(session, 5);\n-        if (!SessionSupplier.isImplicit(session))\n-            SessionSupplier.close(session);\n-    }\n-\n-    private void acquireRecursive(SegmentScope session, int acquireCount) {\n-        try (Arena arena = Arena.openConfined()) {\n-            keepAlive(arena.scope(), session);\n-            if (acquireCount > 0) {\n-                \/\/ recursive acquire\n-                acquireRecursive(session, acquireCount - 1);\n-            }\n-            if (!SessionSupplier.isImplicit(session)) {\n-                assertThrows(IllegalStateException.class, () -> SessionSupplier.close(session));\n-            }\n-        }\n-    }\n-\n-    @Test\n-    public void testConfinedSessionWithImplicitDependency() {\n-        Arena root = Arena.openConfined();\n-        \/\/ Create many implicit sessions which depend on 'root', and let them become unreachable.\n-        for (int i = 0; i < N_THREADS; i++) {\n-            keepAlive(SegmentScope.auto(), root.scope());\n-        }\n-        \/\/ Now let's keep trying to close 'root' until we succeed. This is trickier than it seems: cleanup action\n-        \/\/ might be called from another thread (the Cleaner thread), so that the confined session lock count is updated racily.\n-        \/\/ If that happens, the loop below never terminates.\n-        while (true) {\n-            try {\n-                root.close();\n-                break; \/\/ success!\n-            } catch (IllegalStateException ex) {\n-                kickGC();\n-                for (int i = 0 ; i < N_THREADS ; i++) {  \/\/ add more races from current thread\n-                    try (Arena arena = Arena.openConfined()) {\n-                        keepAlive(arena.scope(), root.scope());\n-                        \/\/ dummy\n-                    }\n-                }\n-                \/\/ try again\n-            }\n-        }\n-    }\n-\n-    @Test\n-    public void testConfinedSessionWithSharedDependency() {\n-        Arena root = Arena.openConfined();\n-        List<Thread> threads = new ArrayList<>();\n-        \/\/ Create many implicit sessions which depend on 'root', and let them become unreachable.\n-        for (int i = 0; i < N_THREADS; i++) {\n-            Arena arena = Arena.openShared(); \/\/ create session inside same thread!\n-            keepAlive(arena.scope(), root.scope());\n-            Thread t = new Thread(arena::close); \/\/ close from another thread!\n-            threads.add(t);\n-            t.start();\n-        }\n-        for (int i = 0 ; i < N_THREADS ; i++) { \/\/ add more races from current thread\n-            try (Arena arena = Arena.openConfined()) {\n-                keepAlive(arena.scope(), root.scope());\n-                \/\/ dummy\n-            }\n-        }\n-        threads.forEach(t -> {\n-            try {\n-                t.join();\n-            } catch (InterruptedException ex) {\n-                \/\/ ok\n-            }\n-        });\n-        \/\/ Now let's close 'root'. This is trickier than it seems: releases of the confined session happen in different\n-        \/\/ threads, so that the confined session lock count is updated racily. If that happens, the following close will blow up.\n-        root.close();\n-    }\n-\n-    private void waitSomeTime() {\n-        try {\n-            Thread.sleep(10);\n-        } catch (InterruptedException ex) {\n-            \/\/ ignore\n-        }\n-    }\n-\n-    private void kickGC() {\n-        for (int i = 0 ; i < 100 ; i++) {\n-            byte[] b = new byte[100];\n-            System.gc();\n-            Thread.onSpinWait();\n-        }\n-    }\n-\n-    @DataProvider\n-    static Object[][] drops() {\n-        return new Object[][] {\n-                { (Supplier<Arena>) Arena::openConfined},\n-                { (Supplier<Arena>) Arena::openShared},\n-        };\n-    }\n-\n-    private void keepAlive(SegmentScope child, SegmentScope parent) {\n-        MemorySessionImpl parentImpl = (MemorySessionImpl) parent;\n-        parentImpl.acquire0();\n-        addCloseAction(child, parentImpl::release0);\n-    }\n-\n-    private void addCloseAction(SegmentScope session, Runnable action) {\n-        MemorySessionImpl sessionImpl = (MemorySessionImpl) session;\n-        sessionImpl.addCloseAction(action);\n-    }\n-\n-    interface SessionSupplier extends Supplier<SegmentScope> {\n-\n-        static void close(SegmentScope session) {\n-            ((MemorySessionImpl)session).close();\n-        }\n-\n-        static boolean isImplicit(SegmentScope session) {\n-            return !((MemorySessionImpl)session).isCloseable();\n-        }\n-\n-        static SessionSupplier ofImplicit() {\n-            return SegmentScope::auto;\n-        }\n-\n-        static SessionSupplier ofArena(Supplier<Arena> arenaSupplier) {\n-            return () -> arenaSupplier.get().scope();\n-        }\n-    }\n-\n-    @DataProvider(name = \"sharedSessions\")\n-    static Object[][] sharedSessions() {\n-        return new Object[][] {\n-                { SessionSupplier.ofArena(Arena::openShared) },\n-                { SessionSupplier.ofImplicit() },\n-        };\n-    }\n-\n-    @DataProvider(name = \"allSessions\")\n-    static Object[][] allSessions() {\n-        return new Object[][] {\n-                { SessionSupplier.ofArena(Arena::openConfined) },\n-                { SessionSupplier.ofArena(Arena::openShared) },\n-                { SessionSupplier.ofImplicit() },\n-        };\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestMemorySession.java","additions":0,"deletions":375,"binary":false,"changes":375,"status":"deleted"},{"patch":"@@ -111,2 +111,2 @@\n-            \"java.lang.foreign.MemorySegment.MemorySession\/openConfined(java.lang.ref.Cleaner)\/0\/0\",\n-            \"java.lang.foreign.MemorySegment.MemorySession\/openShared(java.lang.ref.Cleaner)\/0\/0\",\n+            \"java.lang.foreign.MemorySegment.MemoryScope\/openConfined(java.lang.ref.Cleaner)\/0\/0\",\n+            \"java.lang.foreign.MemorySegment.MemoryScope\/openShared(java.lang.ref.Cleaner)\/0\/0\",\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -113,3 +113,3 @@\n-        \/\/ session operations\n-        ScopedOperation.ofScope(session -> MemorySegment.allocateNative(100, session), \"MemorySession::allocate\");;\n-        ScopedOperation.ofScope(session -> {\n+        \/\/ scope operations\n+        ScopedOperation.ofScope(scope -> MemorySegment.allocateNative(100, scope), \"MemoryScope::allocate\");;\n+        ScopedOperation.ofScope(scope -> {\n@@ -117,1 +117,1 @@\n-                fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 10L, session);\n+                fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 10L, scope);\n@@ -122,2 +122,2 @@\n-        ScopedOperation.ofScope(session -> VaList.make(b -> b.addVarg(JAVA_INT, 42), session), \"VaList::make\");\n-        ScopedOperation.ofScope(session -> VaList.ofAddress(42, session), \"VaList::make\");\n+        ScopedOperation.ofScope(scope -> VaList.make(b -> b.addVarg(JAVA_INT, 42), scope), \"VaList::make\");\n+        ScopedOperation.ofScope(scope -> VaList.ofAddress(42, scope), \"VaList::make\");\n@@ -182,2 +182,2 @@\n-        public X apply(SegmentScope session) {\n-            return factory.apply(session);\n+        public X apply(SegmentScope scope) {\n+            return factory.apply(scope);\n@@ -195,1 +195,1 @@\n-            scopedOperations.add(new ScopedOperation<>(session -> VaList.make(builder -> builder.addVarg(JAVA_LONG, 42), session),\n+            scopedOperations.add(new ScopedOperation<>(scope -> VaList.make(builder -> builder.addVarg(JAVA_LONG, 42), scope),\n@@ -219,2 +219,2 @@\n-            NATIVE(session -> MemorySegment.allocateNative(10, session)),\n-            MAPPED(session -> {\n+            NATIVE(scope -> MemorySegment.allocateNative(10, scope)),\n+            MAPPED(scope -> {\n@@ -222,1 +222,1 @@\n-                    return fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 10L, session);\n+                    return fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 10L, scope);\n@@ -227,1 +227,1 @@\n-            UNSAFE(session -> MemorySegment.ofAddress(0, 10, session));\n+            UNSAFE(scope -> MemorySegment.ofAddress(0, 10, scope));\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-    public void testBigAllocationInUnboundedSession() {\n+    public void testBigAllocationInUnboundedScope() {\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,2 +59,2 @@\n-            SegmentScope session = arena.scope();\n-            var segment = MemorySegment.allocateNative(0, session);\n+            SegmentScope scope = arena.scope();\n+            var segment = MemorySegment.allocateNative(0, scope);\n@@ -63,1 +63,1 @@\n-            segment = MemorySegment.allocateNative(seq, session);\n+            segment = MemorySegment.allocateNative(seq, scope);\n@@ -66,1 +66,1 @@\n-            segment = MemorySegment.allocateNative(0, 4, session);\n+            segment = MemorySegment.allocateNative(0, 4, scope);\n@@ -69,1 +69,1 @@\n-            MemorySegment rawAddress = MemorySegment.ofAddress(segment.address(), 0, session);\n+            MemorySegment rawAddress = MemorySegment.ofAddress(segment.address(), 0, scope);\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -84,2 +84,2 @@\n-    static Object[] makeArgs(SegmentScope session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n-        return makeArgs(session, ret, params, fields, checks, argChecks, List.of());\n+    static Object[] makeArgs(SegmentScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n+        return makeArgs(scope, ret, params, fields, checks, argChecks, List.of());\n@@ -88,1 +88,1 @@\n-    static Object[] makeArgs(SegmentScope session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) throws ReflectiveOperationException {\n+    static Object[] makeArgs(SegmentScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) throws ReflectiveOperationException {\n@@ -97,1 +97,1 @@\n-        args[argNum] = makeCallback(session, ret, params, fields, checks, argChecks, prefix);\n+        args[argNum] = makeCallback(scope, ret, params, fields, checks, argChecks, prefix);\n@@ -101,1 +101,1 @@\n-    static MemorySegment makeCallback(SegmentScope session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) {\n+    static MemorySegment makeCallback(SegmentScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) {\n@@ -148,1 +148,1 @@\n-        return ABI.upcallStub(mh, func, session);\n+        return ABI.upcallStub(mh, func, scope);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallBase.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -74,2 +74,2 @@\n-    static Object[] makeArgsStack(SegmentScope session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n-        return makeArgs(session, ret, params, fields, checks, argChecks, STACK_PREFIX_LAYOUTS);\n+    static Object[] makeArgsStack(SegmentScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n+        return makeArgs(scope, ret, params, fields, checks, argChecks, STACK_PREFIX_LAYOUTS);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStack.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,2 +71,2 @@\n-    static ByteBuffer segmentBufferOfSize(SegmentScope session, int size) {\n-        var segment = MemorySegment.allocateNative(size, 1, session);\n+    static ByteBuffer segmentBufferOfSize(SegmentScope scope, int size) {\n+        var segment = MemorySegment.allocateNative(size, 1, scope);\n@@ -79,1 +79,1 @@\n-    static ByteBuffer[] segmentBuffersOfSize(int len, SegmentScope session, int size) {\n+    static ByteBuffer[] segmentBuffersOfSize(int len, SegmentScope scope, int size) {\n@@ -82,1 +82,1 @@\n-            bufs[i] = segmentBufferOfSize(session, size);\n+            bufs[i] = segmentBufferOfSize(scope, size);\n@@ -88,2 +88,2 @@\n-     * where heap can be from the global session or session-less, and direct are\n-     * associated with the given session.\n+     * where heap can be from the global scope or scope-less, and direct are\n+     * associated with the given scope.\n@@ -91,1 +91,1 @@\n-    static ByteBuffer[] mixedBuffersOfSize(int len, SegmentScope session, int size) {\n+    static ByteBuffer[] mixedBuffersOfSize(int len, SegmentScope scope, int size) {\n@@ -93,1 +93,1 @@\n-        boolean atLeastOneSessionBuffer = false;\n+        boolean atLeastOneScopeBuffer = false;\n@@ -104,2 +104,2 @@\n-                    case 2 -> { atLeastOneSessionBuffer = true;\n-                                yield segmentBufferOfSize(session, size); }\n+                    case 2 -> { atLeastOneScopeBuffer = true;\n+                                yield segmentBufferOfSize(scope, size); }\n@@ -109,1 +109,1 @@\n-        } while (!atLeastOneSessionBuffer);\n+        } while (!atLeastOneScopeBuffer);\n","filename":"test\/jdk\/java\/foreign\/channels\/AbstractChannelsTest.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-    \/** Tests that confined sessions are not supported. *\/\n+    \/** Tests that confined scopes are not supported. *\/\n@@ -97,1 +97,1 @@\n-                        .assertExceptionMessage(\"Confined session not supported\");\n+                        .assertExceptionMessage(\"Confined scope not supported\");\n@@ -102,1 +102,1 @@\n-    \/** Tests that I\/O with a closed session throws a suitable exception. *\/\n+    \/** Tests that I\/O with a closed scope throws a suitable exception. *\/\n@@ -104,1 +104,1 @@\n-    public void testIOWithClosedSharedSession(Supplier<Arena> arenaSupplier, int timeout)\n+    public void testIOWithClosedSharedScope(Supplier<Arena> arenaSupplier, int timeout)\n@@ -153,1 +153,1 @@\n-    \/** Tests basic I\/O operations work with views over implicit and shared sessions. *\/\n+    \/** Tests basic I\/O operations work with views over implicit and shared scopes. *\/\n@@ -155,1 +155,1 @@\n-    public void testBasicIOWithSupportedSession(Supplier<Arena> arenaSupplier)\n+    public void testBasicIOWithSupportedScope(Supplier<Arena> arenaSupplier)\n@@ -201,1 +201,1 @@\n-    \/** Tests that a session is not closeable when there is an outstanding read operation. *\/\n+    \/** Tests that a scope is not closeable when there is an outstanding read operation. *\/\n@@ -225,1 +225,1 @@\n-                assertMessage(expectThrows(ISE, () -> drop.close()), \"Session is acquired by\");\n+                assertMessage(expectThrows(ISE, () -> drop.close()), \"Scope is acquired by\");\n@@ -228,1 +228,1 @@\n-                \/\/ in turn unlock the session and allow it to be closed.\n+                \/\/ in turn unlock the scope and allow it to be closed.\n@@ -236,1 +236,1 @@\n-    \/** Tests that a session is not closeable when there is an outstanding write operation. *\/\n+    \/** Tests that a scope is not closeable when there is an outstanding write operation. *\/\n@@ -274,1 +274,1 @@\n-            assertMessage(expectThrows(ISE, () -> drop.close()), \"Session is acquired by\");\n+            assertMessage(expectThrows(ISE, () -> drop.close()), \"Scope is acquired by\");\n@@ -281,1 +281,1 @@\n-            \/\/ in turn unlock the session and allow it to be closed.\n+            \/\/ in turn unlock the scope and allow it to be closed.\n","filename":"test\/jdk\/java\/foreign\/channels\/TestAsyncSocketChannels.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-    public void testBasicHeapIOWithGlobalSession() throws Exception {\n+    public void testBasicHeapIOWithGlobalScope() throws Exception {\n@@ -184,1 +184,1 @@\n-    public void testBasicIOWithDifferentSessions(Supplier<Arena> arenaSupplier)\n+    public void testBasicIOWithDifferentScopes(Supplier<Arena> arenaSupplier)\n","filename":"test\/jdk\/java\/foreign\/channels\/TestSocketChannels.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-                \/\/ the downcall above should not have called release on the session\n+                \/\/ the downcall above should not have called release on the scope\n","filename":"test\/jdk\/java\/foreign\/dontrelease\/TestDontRelease.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -603,1 +603,1 @@\n-            assertTrue(pointOut.scope().isAlive()); \/\/ after inner session freed\n+            assertTrue(pointOut.scope().isAlive()); \/\/ after inner scope freed\n@@ -605,1 +605,1 @@\n-        assertFalse(pointOut.scope().isAlive()); \/\/ after outer session freed\n+        assertFalse(pointOut.scope().isAlive()); \/\/ after outer scope freed\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-    public enum SessionKind {\n+    public enum ScopeKind {\n@@ -60,1 +60,1 @@\n-        SessionKind(Supplier<Arena> arenaFactory) {\n+        ScopeKind(Supplier<Arena> arenaFactory) {\n@@ -70,1 +70,1 @@\n-    public BulkMismatchAcquire.SessionKind sessionKind;\n+    public BulkMismatchAcquire.ScopeKind scopeKind;\n@@ -87,1 +87,1 @@\n-        arena = sessionKind.makeArena();\n+        arena = scopeKind.makeArena();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/BulkMismatchAcquire.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-    \/\/ they should just use deterministic deallocation (with confined session) instead, which delivers much\n+    \/\/ they should just use deterministic deallocation (with confined scope) instead, which delivers much\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNew.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-    public long segment_loop_addr_size_session() {\n+    public long segment_loop_addr_size_scope() {\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverOfAddress.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-public class MemorySessionClose {\n+public class MemoryScopeClose {\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/MemoryScopeClose.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/MemorySessionClose.java","status":"renamed"},{"patch":"@@ -151,2 +151,2 @@\n-        public RingAllocator(SegmentScope session) {\n-            this.segment = MemorySegment.allocateNative(1024, session);\n+        public RingAllocator(SegmentScope scope) {\n+            this.segment = MemorySegment.allocateNative(1024, scope);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/StrLenTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}