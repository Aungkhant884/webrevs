{"files":[{"patch":"@@ -191,0 +191,1 @@\n+  assert(!Universe::is_fully_initialized() || SafepointSynchronize::is_at_safepoint(), \"must be\");\n@@ -192,0 +193,2 @@\n+  \/\/ Request at least one eden region to ensure progress.\n+  bool after_gc = true;\n@@ -193,1 +196,2 @@\n-                             _analytics->predict_rs_length(for_young_only_phase));\n+                             _analytics->predict_rs_length(for_young_only_phase),\n+                             after_gc);\n@@ -196,1 +200,1 @@\n-void G1Policy::update_young_length_bounds(size_t pending_cards, size_t rs_length) {\n+void G1Policy::update_young_length_bounds(size_t pending_cards, size_t rs_length, bool after_gc) {\n@@ -199,1 +203,1 @@\n-  uint new_young_list_desired_length = calculate_young_desired_length(pending_cards, rs_length);\n+  uint new_young_list_desired_length = calculate_young_desired_length(pending_cards, rs_length, after_gc);\n@@ -227,2 +231,2 @@\n-\/\/ - MMU goal influencing eden to make GCs spaced apart.\n-\/\/ - a minimum one eden region length.\n+\/\/ - MMU goal influencing eden to make GCs spaced apart\n+\/\/ - if after a GC, request at least one eden region to avoid immediate full gcs\n@@ -230,5 +234,3 @@\n-\/\/ We may enter with already allocated eden and survivor regions, that may be\n-\/\/ higher than the maximum, or the above goals may result in a desired value\n-\/\/ smaller than are already allocated.\n-\/\/ The main reason is revising young length, with or without the GCLocker being\n-\/\/ active.\n+\/\/ We may enter with already allocated eden and survivor regions because there\n+\/\/ are survivor regions (after gc). Young gen revising can call this method at any\n+\/\/ time too.\n@@ -236,1 +238,5 @@\n-uint G1Policy::calculate_young_desired_length(size_t pending_cards, size_t rs_length) const {\n+\/\/ For this method it does not matter if the above goals may result in a desired\n+\/\/ value smaller than what is already allocated or what can actually be allocated.\n+\/\/ This return value is only an expectation.\n+\/\/\n+uint G1Policy::calculate_young_desired_length(size_t pending_cards, size_t rs_length, bool after_gc) const {\n@@ -243,6 +249,0 @@\n-  \/\/ Absolute minimum eden length.\n-  \/\/ Enforcing a minimum eden length helps at startup when the predictors are not\n-  \/\/ yet trained on the application to avoid unnecessary (but very short) full gcs\n-  \/\/ on very small (initial) heaps.\n-  uint const MinDesiredEdenLength = 1;\n-\n@@ -264,0 +264,4 @@\n+  \/\/ The absolute minimum young gen length (as provided by the young gen sizer) ensures\n+  \/\/ that we desire at least one young gen region.\n+  assert(absolute_min_young_length > 0, \"must be\");\n+\n@@ -280,4 +284,2 @@\n-    \/\/ Also request at least one eden region, see above for reasons.\n-    uint desired_eden_length = MAX3(desired_eden_length_by_pause,\n-                                    desired_eden_length_by_mmu,\n-                                    MinDesiredEdenLength);\n+    uint desired_eden_length = MAX2(desired_eden_length_by_pause,\n+                                    desired_eden_length_by_mmu);\n@@ -294,1 +296,14 @@\n-  log_trace(gc, ergo, heap)(\"Young desired length %u \"\n+  \/\/ After a garbage collection, make room for at least one eden region (i.e. in addition to\n+  \/\/ already allocated survivor regions).\n+  \/\/ This may make desired regions go over absolute maximum length by the heap sizer, however\n+  \/\/ the immediate full gcs after that young gc (particularly on small heaps) are worse.\n+  if (after_gc && (allocated_young_length >= desired_young_length)) {\n+   log_trace(gc, ergo, heap)(\"Young desired length: Desired young region length less than already \"\n+                              \"allocated region length, but requesting one eden region minimum. \"\n+                              \"Expanding desired young length from %u to %u.\",\n+                              desired_young_length,\n+                              allocated_young_length + 1);\n+    desired_young_length = allocated_young_length + 1;\n+  }\n+\n+  log_trace(gc, ergo, heap)(\"Young desired length %u (after gc: %s) \"\n@@ -300,3 +315,3 @@\n-                            \"desired eden length by pause %u \"\n-                            \"desired eden length by default %u\",\n-                            desired_young_length, survivor_length,\n+                            \"desired eden length by pause %u \",\n+                            desired_young_length, BOOL_TO_STR(after_gc),\n+                            survivor_length,\n@@ -305,2 +320,1 @@\n-                            desired_eden_length_by_pause,\n-                            MinDesiredEdenLength);\n+                            desired_eden_length_by_pause);\n@@ -537,1 +551,4 @@\n-  update_young_length_bounds(pending_cards, rs_length);\n+  \/\/ We are only revising young gen length to meet pause time goal, so do not request\n+  \/\/ at least one eden region for progress. At this point we actually want to run into\n+  \/\/ a GC soon if young gen is already (too) large.\n+  update_young_length_bounds(pending_cards, rs_length, false \/* need_one_eden_region *\/);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":45,"deletions":28,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -213,1 +213,2 @@\n-  \/\/ the prediction model.\n+  \/\/ the prediction model. If after_gc is set, make sure that there is one eden region\n+  \/\/ available (if there is enough space) to guarantee some progress.\n@@ -215,1 +216,1 @@\n-  void update_young_length_bounds(size_t pending_cards, size_t rs_length);\n+  void update_young_length_bounds(size_t pending_cards, size_t rs_length, bool after_gc);\n@@ -243,1 +244,1 @@\n-  uint calculate_young_desired_length(size_t pending_cards, size_t rs_length) const;\n+  uint calculate_young_desired_length(size_t pending_cards, size_t rs_length, bool after_gc) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.g1;\n+\n+\/*\n+ * @test\n+ * @bug 8297186\n+ * @requires vm.gc.G1\n+ * @library \/test\/lib\n+ * @run driver gc.g1.TestOneEdenRegionAfterGC\n+ * @summary Test that on a very small heap g1 with very little data (smaller than region size)\n+ *          will use at least one eden region after gc to avoid full gcs.\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestOneEdenRegionAfterGC {\n+  private static long YoungGenSize = 32 * 1024 * 1024;\n+\n+  private static OutputAnalyzer run() throws Exception {\n+    ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+      \"-Xbootclasspath\/a:.\",\n+      \"-Xmn\" + YoungGenSize,\n+      \"-Xmx512M\",\n+      \"-Xms512M\",\n+      \"-XX:G1HeapRegionSize=32M\",\n+      \"-XX:+UseG1GC\",\n+      \"-Xlog:gc,gc+ergo*=trace\",\n+      TestOneEdenRegionAfterGC.Allocate.class.getName(),\n+      \"\" + YoungGenSize);\n+    return new OutputAnalyzer(pb.start());\n+  }\n+\n+  public static void main(String args[]) throws Exception {\n+    OutputAnalyzer out = run();\n+\n+    out.shouldMatch(\".*Pause Young \\\\(Normal\\\\).*\");\n+    out.shouldNotMatch(\".*Pause Full.*\");\n+  }\n+\n+  public static class Allocate {\n+    public static Object dummy;\n+\n+    public static void main(String [] args) throws Exception {\n+      if (args.length != 1) {\n+        throw new IllegalArgumentException(\"Usage: <YoungGenSize>\");\n+      }\n+\n+      long youngGenSize = Long.parseLong(args[0]);\n+      triggerYoungGCs(youngGenSize);\n+    }\n+\n+    public static void triggerYoungGCs(long youngGenSize) {\n+      long approxAllocSize = 32 * 1024;\n+      long numAllocations  = 2 * youngGenSize \/ approxAllocSize;\n+\n+      for (long i = 0; i < numAllocations; i++) {\n+        dummy = new byte[(int)approxAllocSize];\n+      }\n+    }\n+  }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestOneEdenRegionAfterGC.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -51,0 +51,1 @@\n+        opts.addSuffix(\"-XX:MetaspaceSize=500M\"); \/\/ avoid heap fragmentation by avoiding metaspace-limit induced GCs\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/LotsOfClasses.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}