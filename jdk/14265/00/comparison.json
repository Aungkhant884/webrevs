{"files":[{"patch":"@@ -250,1 +250,8 @@\n-  return hr->is_obj_dead(obj, hr->parsable_bottom());\n+  if (hr->is_in_parsable_area(obj)) {\n+    \/\/ This object is in the parsable part of the heap, live unless scrubbed.\n+    return is_obj_filler(obj);\n+  } else {\n+    \/\/ From Remark until a region has been concurrently scrubbed, parts of the\n+    \/\/ region is not guaranteed to be parsable. Use the bitmap for liveness.\n+    return !concurrent_mark()->mark_bitmap()->is_marked(obj);\n+  }\n@@ -254,3 +261,2 @@\n-  if (obj == nullptr) {\n-    return false;\n-  }\n+  assert(obj != nullptr, \"precondition\");\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -227,1 +227,1 @@\n-      if (_hr->obj_in_unparsable_area(o, _hr->parsable_bottom())) {\n+      if (!_hr->is_in_parsable_area(o)) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -185,4 +185,0 @@\n-  \/\/ Returns whether the given object is dead based on the given parsable_bottom (pb).\n-  \/\/ For an object to be considered dead it must be below pb and scrubbed.\n-  bool is_obj_dead(oop obj, HeapWord* pb) const;\n-\n@@ -527,3 +523,3 @@\n-  \/\/ Determine if an object is in the parsable or the to-be-scrubbed area.\n-  inline static bool obj_in_parsable_area(const HeapWord* addr, HeapWord* pb);\n-  inline static bool obj_in_unparsable_area(oop obj, HeapWord* pb);\n+  \/\/ Determine if an address is in the parsable or the to-be-scrubbed area.\n+  inline        bool is_in_parsable_area(const void* const addr) const;\n+  inline static bool is_in_parsable_area(const void* const addr, const void* const pb);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -112,2 +112,2 @@\n-inline bool HeapRegion::obj_in_unparsable_area(oop obj, HeapWord* const pb) {\n-  return !HeapRegion::obj_in_parsable_area(cast_from_oop<HeapWord*>(obj), pb);\n+inline bool HeapRegion::is_in_parsable_area(const void* const addr) const {\n+  return is_in_parsable_area(addr, parsable_bottom());\n@@ -116,1 +116,1 @@\n-inline bool HeapRegion::obj_in_parsable_area(const HeapWord* addr, HeapWord* const pb) {\n+inline bool HeapRegion::is_in_parsable_area(const void* const addr, const void* const pb) {\n@@ -128,1 +128,1 @@\n-  if (obj_in_parsable_area(p, pb)) {\n+  if (is_in_parsable_area(p, pb)) {\n@@ -143,13 +143,0 @@\n-inline bool HeapRegion::is_obj_dead(const oop obj, HeapWord* const pb) const {\n-  assert(is_in_reserved(obj), \"Object \" PTR_FORMAT \" must be in region\", p2i(obj));\n-\n-  \/\/ From Remark until a region has been concurrently scrubbed, parts of the\n-  \/\/ region is not guaranteed to be parsable. Use the bitmap for liveness.\n-  if (obj_in_unparsable_area(obj, pb)) {\n-    return !is_marked_in_bitmap(obj);\n-  }\n-\n-  \/\/ This object is in the parsable part of the heap, live unless scrubbed.\n-  return G1CollectedHeap::is_obj_filler(obj);\n-}\n-\n@@ -453,1 +440,1 @@\n-  if (!obj_in_parsable_area(start, pb)) {\n+  if (!is_in_parsable_area(start, pb)) {\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":5,"deletions":18,"binary":false,"changes":23,"status":"modified"}]}