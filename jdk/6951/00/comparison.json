{"files":[{"patch":"@@ -2379,1 +2379,1 @@\n-C2V_VMENTRY_0(jlong, translate, (JNIEnv* env, jobject, jobject obj_handle))\n+C2V_VMENTRY_0(jlong, translate, (JNIEnv* env, jobject, jobject obj_handle, jboolean callPostTranslation))\n@@ -2430,1 +2430,3 @@\n-      if (nm == NULL) {\n+      if (result.is_null()) {\n+        \/\/ exception occurred (e.g. OOME) creating a new HotSpotNmethod\n+      } else if (nm == NULL) {\n@@ -2453,0 +2455,7 @@\n+  if (callPostTranslation) {\n+    peerEnv->call_HotSpotJVMCIRuntime_postTranslation(result, JVMCI_CHECK_0);\n+  }\n+  \/\/ Propagate any exception that occurred while creating the translated object\n+  if (peerEnv->transfer_pending_exception(thread, thisEnv)) {\n+    return 0L;\n+  }\n@@ -2793,1 +2802,1 @@\n-  {CC \"translate\",                                    CC \"(\" OBJECT \")J\",                                                                   FN_PTR(translate)},\n+  {CC \"translate\",                                    CC \"(\" OBJECT \"Z)J\",                                                                  FN_PTR(translate)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -281,14 +281,43 @@\n-void JVMCIEnv::translate_hotspot_exception_to_jni_exception(JavaThread* THREAD, const Handle& throwable) {\n-  assert(!is_hotspot(), \"must_be\");\n-  \/\/ Resolve HotSpotJVMCIRuntime class explicitly as HotSpotJVMCI::compute_offsets\n-  \/\/ may not have been called.\n-  Klass* runtimeKlass = SystemDictionary::resolve_or_fail(vmSymbols::jdk_vm_ci_hotspot_HotSpotJVMCIRuntime(), true, CHECK);\n-  JavaCallArguments jargs;\n-  jargs.push_oop(throwable);\n-  JavaValue result(T_OBJECT);\n-  JavaCalls::call_static(&result,\n-                          runtimeKlass,\n-                          vmSymbols::encodeThrowable_name(),\n-                          vmSymbols::encodeThrowable_signature(), &jargs, THREAD);\n-  if (HAS_PENDING_EXCEPTION) {\n-    JVMCIRuntime::fatal_exception(this, \"HotSpotJVMCIRuntime.encodeThrowable should not throw an exception\");\n+\/\/ Shared code for translating an exception from HotSpot to libjvmci or vice versa.\n+class ExceptionTranslation: public StackObj {\n+ protected:\n+  JVMCIEnv*  _from_env; \/\/ can be nullptr\n+  JVMCIEnv*  _to_env;   \/\/ never nullptr\n+\n+  ExceptionTranslation(JVMCIEnv* from_env, JVMCIEnv* to_env) : _from_env(from_env), _to_env(to_env) {}\n+\n+  \/\/ Encodes the exception in `_from_env` into `buffer`.\n+  \/\/ Where N is the number of bytes needed for the encoding, returns N if N >= `buffer_size`\n+  \/\/ and the encoding was written to `buffer` otherwise returns -N.\n+  virtual int encode(JavaThread* THREAD, Klass* runtimeKlass, jlong buffer, int buffer_size) = 0;\n+\n+  \/\/ Decodes the exception in `buffer` in `_to_env` and throws it.\n+  virtual void decode(JavaThread* THREAD, Klass* runtimeKlass, jlong buffer) = 0;\n+\n+ public:\n+  void doit(JavaThread* THREAD) {\n+    \/\/ Resolve HotSpotJVMCIRuntime class explicitly as HotSpotJVMCI::compute_offsets\n+    \/\/ may not have been called.\n+    Klass* runtimeKlass = SystemDictionary::resolve_or_fail(vmSymbols::jdk_vm_ci_hotspot_HotSpotJVMCIRuntime(), true, CHECK);\n+\n+    int buffer_size = 2048;\n+    while (true) {\n+      ResourceMark rm;\n+      jlong buffer = (jlong) NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, jbyte, buffer_size);\n+      int res = encode(THREAD, runtimeKlass, buffer, buffer_size);\n+      if ((_from_env != nullptr && _from_env->has_pending_exception()) || HAS_PENDING_EXCEPTION) {\n+        JVMCIRuntime::fatal_exception(_from_env, \"HotSpotJVMCIRuntime.encodeThrowable should not throw an exception\");\n+      }\n+      if (res < 0) {\n+        int required_buffer_size = -res;\n+        if (required_buffer_size > buffer_size) {\n+          buffer_size = required_buffer_size;\n+        }\n+      } else {\n+        decode(THREAD, runtimeKlass, buffer);\n+        if (!_to_env->has_pending_exception()) {\n+          JVMCIRuntime::fatal_exception(_to_env, \"HotSpotJVMCIRuntime.decodeAndThrowThrowable should throw an exception\");\n+        }\n+        return;\n+      }\n+    }\n@@ -296,0 +325,1 @@\n+};\n@@ -297,1 +327,4 @@\n-  oop encoded_throwable_string = result.get_oop();\n+\/\/ Translates an exception on the HotSpot heap to an exception on the shared library heap.\n+class HotSpotToSharedLibraryExceptionTranslation : public ExceptionTranslation {\n+ private:\n+  const Handle& _throwable;\n@@ -299,2 +332,12 @@\n-  ResourceMark rm;\n-  const char* encoded_throwable_chars = java_lang_String::as_utf8_string(encoded_throwable_string);\n+  int encode(JavaThread* THREAD, Klass* runtimeKlass, jlong buffer, int buffer_size) {\n+    JavaCallArguments jargs;\n+    jargs.push_oop(_throwable);\n+    jargs.push_long(buffer);\n+    jargs.push_int(buffer_size);\n+    JavaValue result(T_INT);\n+    JavaCalls::call_static(&result,\n+                            runtimeKlass,\n+                            vmSymbols::encodeThrowable_name(),\n+                            vmSymbols::encodeThrowable_signature(), &jargs, THREAD);\n+    return result.get_jint();\n+  }\n@@ -302,6 +345,43 @@\n-  JNIAccessMark jni(this, THREAD);\n-  jobject jni_encoded_throwable_string = jni()->NewStringUTF(encoded_throwable_chars);\n-  jthrowable jni_throwable = (jthrowable) jni()->CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),\n-                                JNIJVMCI::HotSpotJVMCIRuntime::decodeThrowable_method(),\n-                                jni_encoded_throwable_string);\n-  jni()->Throw(jni_throwable);\n+  void decode(JavaThread* THREAD, Klass* runtimeKlass, jlong buffer) {\n+    JNIAccessMark jni(_to_env, THREAD);\n+    jni()->CallStaticVoidMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),\n+                                JNIJVMCI::HotSpotJVMCIRuntime::decodeAndThrowThrowable_method(),\n+                                buffer);\n+  }\n+ public:\n+  HotSpotToSharedLibraryExceptionTranslation(JVMCIEnv* hotspot_env, JVMCIEnv* jni_env, const Handle& throwable) :\n+    ExceptionTranslation(hotspot_env, jni_env), _throwable(throwable) {}\n+};\n+\n+\/\/ Translates an exception on the shared library heap to an exception on the HotSpot heap.\n+class SharedLibraryToHotSpotExceptionTranslation : public ExceptionTranslation {\n+ private:\n+  jthrowable _throwable;\n+\n+  int encode(JavaThread* THREAD, Klass* runtimeKlass, jlong buffer, int buffer_size) {\n+    JNIAccessMark jni(_from_env, THREAD);\n+    return jni()->CallStaticIntMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),\n+                                      JNIJVMCI::HotSpotJVMCIRuntime::encodeThrowable_method(),\n+                                      _throwable, buffer, buffer_size);\n+  }\n+\n+  void decode(JavaThread* THREAD, Klass* runtimeKlass, jlong buffer) {\n+    JavaCallArguments jargs;\n+    jargs.push_long(buffer);\n+    JavaValue result(T_VOID);\n+    JavaCalls::call_static(&result,\n+                            runtimeKlass,\n+                            vmSymbols::decodeAndThrowThrowable_name(),\n+                            vmSymbols::long_void_signature(), &jargs, THREAD);\n+  }\n+ public:\n+  SharedLibraryToHotSpotExceptionTranslation(JVMCIEnv* hotspot_env, JVMCIEnv* jni_env, jthrowable throwable) :\n+    ExceptionTranslation(jni_env, hotspot_env), _throwable(throwable) {}\n+};\n+\n+void JVMCIEnv::translate_to_jni_exception(JavaThread* THREAD, const Handle& throwable, JVMCIEnv* hotspot_env, JVMCIEnv* jni_env) {\n+  HotSpotToSharedLibraryExceptionTranslation(hotspot_env, jni_env, throwable).doit(THREAD);\n+}\n+\n+void JVMCIEnv::translate_from_jni_exception(JavaThread* THREAD, jthrowable throwable, JVMCIEnv* hotspot_env, JVMCIEnv* jni_env) {\n+  SharedLibraryToHotSpotExceptionTranslation(hotspot_env, jni_env, throwable).doit(THREAD);\n@@ -310,0 +390,26 @@\n+jboolean JVMCIEnv::transfer_pending_exception(JavaThread* THREAD, JVMCIEnv* peer_env) {\n+  if (is_hotspot()) {\n+    if (HAS_PENDING_EXCEPTION) {\n+      Handle throwable = Handle(THREAD, PENDING_EXCEPTION);\n+      CLEAR_PENDING_EXCEPTION;\n+      translate_to_jni_exception(THREAD, throwable, this, peer_env);\n+      return true;\n+    }\n+  } else {\n+    jthrowable ex = nullptr;\n+    {\n+      JNIAccessMark jni(this, THREAD);\n+      ex = jni()->ExceptionOccurred();\n+      if (ex != nullptr) {\n+        jni()->ExceptionClear();\n+      }\n+    }\n+    if (ex != nullptr) {\n+      translate_from_jni_exception(THREAD, ex, peer_env, this);\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+\n@@ -321,1 +427,1 @@\n-          translate_hotspot_exception_to_jni_exception(THREAD, throwable);\n+          translate_to_jni_exception(THREAD, throwable, nullptr, this);\n@@ -804,0 +910,17 @@\n+void JVMCIEnv::call_HotSpotJVMCIRuntime_postTranslation(JVMCIObject object, JVMCIEnv* JVMCIENV) {\n+  JavaThread* THREAD = JVMCI::compilation_tick(JavaThread::current()); \/\/ For exception macros.\n+  if (is_hotspot()) {\n+    JavaCallArguments jargs;\n+    jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(object)));\n+    JavaValue result(T_VOID);\n+    JavaCalls::call_static(&result,\n+                           HotSpotJVMCI::HotSpotJVMCIRuntime::klass(),\n+                           vmSymbols::postTranslation_name(),\n+                           vmSymbols::object_void_signature(), &jargs, CHECK);\n+  } else {\n+    JNIAccessMark jni(this, THREAD);\n+    jni()->CallStaticVoidMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),\n+                                JNIJVMCI::HotSpotJVMCIRuntime::postTranslation_method(),\n+                                object.as_jobject());\n+  }\n+}\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":147,"deletions":24,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -174,5 +174,9 @@\n-  \/\/ Translates an exception on the HotSpot heap to an exception on\n-  \/\/ the shared library heap. The translation includes the stack and\n-  \/\/ causes of `throwable`. The translated exception is pending in the\n-  \/\/ shared library thread upon returning.\n-  void translate_hotspot_exception_to_jni_exception(JavaThread* THREAD, const Handle& throwable);\n+  \/\/ Translates an exception on the HotSpot heap (i.e., hotspot_env) to an exception on\n+  \/\/ the shared library heap (i.e., jni_env). The translation includes the stack and cause(s) of `throwable`.\n+  \/\/ The translated exception is pending in jni_env upon returning.\n+  static void translate_to_jni_exception(JavaThread* THREAD, const Handle& throwable, JVMCIEnv* hotspot_env, JVMCIEnv* jni_env);\n+\n+  \/\/ Translates an exception on the shared library heap (i.e., jni_env) to an exception on\n+  \/\/ the HotSpot heap (i.e., hotspot_env). The translation includes the stack and cause(s) of `throwable`.\n+  \/\/ The translated exception is pending in hotspot_env upon returning.\n+  static void translate_from_jni_exception(JavaThread* THREAD, jthrowable throwable, JVMCIEnv* hotspot_env, JVMCIEnv* jni_env);\n@@ -228,0 +232,5 @@\n+  \/\/ If this env has a pending exception, it is translated to be a pending\n+  \/\/ exception in `peer_env` and is cleared from this env. Returns true\n+  \/\/ if a pending exception was transferred, false otherwise.\n+  jboolean transfer_pending_exception(JavaThread* THREAD, JVMCIEnv* peer_env);\n+\n@@ -314,0 +323,2 @@\n+  void call_HotSpotJVMCIRuntime_postTranslation(JVMCIObject object, JVMCI_TRAPS);\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.hpp","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -352,2 +352,2 @@\n-    jvmci_method(CallStaticObjectMethod, GetStaticMethodID, call_static, JVMCIObject, HotSpotJVMCIRuntime, encodeThrowable, encodeThrowable_signature, (JVMCIObject throwable)) \\\n-    jvmci_method(CallStaticObjectMethod, GetStaticMethodID, call_static, JVMCIObject, HotSpotJVMCIRuntime, decodeThrowable, decodeThrowable_signature, (JVMCIObject encodedThrowable)) \\\n+    jvmci_method(CallStaticBooleanMethod, GetStaticMethodID, call_static, bool, HotSpotJVMCIRuntime, encodeThrowable, encodeThrowable_signature, (JVMCIObject throwable, jlong buffer, int buffer_size)) \\\n+    jvmci_method(CallStaticVoidMethod, GetStaticMethodID, call_static, void, HotSpotJVMCIRuntime, decodeAndThrowThrowable, long_void_signature, (jlong buffer)) \\\n@@ -359,0 +359,1 @@\n+    jvmci_method(CallStaticVoidMethod, GetStaticMethodID, call_static, void, HotSpotJVMCIRuntime, postTranslation, object_void_signature, (JVMCIObject object, JVMCI_TRAPS)) \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -108,3 +108,2 @@\n-  template(encodeThrowable_signature,                             \"(Ljava\/lang\/Throwable;)Ljava\/lang\/String;\")                            \\\n-  template(decodeThrowable_name,                                  \"decodeThrowable\")                                                      \\\n-  template(decodeThrowable_signature,                             \"(Ljava\/lang\/String;)Ljava\/lang\/Throwable;\")                            \\\n+  template(encodeThrowable_signature,                             \"(Ljava\/lang\/Throwable;JI)I\")                                           \\\n+  template(decodeAndThrowThrowable_name,                          \"decodeAndThrowThrowable\")                                              \\\n@@ -126,0 +125,1 @@\n+  template(postTranslation_name,                                  \"postTranslation\")                                                      \\\n","filename":"src\/hotspot\/share\/jvmci\/vmSymbols_jvmci.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -852,1 +852,1 @@\n-    native long translate(Object obj);\n+    native long translate(Object obj, boolean callPostTranslation);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n@@ -69,0 +71,1 @@\n+import jdk.vm.ci.services.Services;\n@@ -202,0 +205,6 @@\n+    \/**\n+     * Decodes the exception encoded in {@code buffer} and throws it.\n+     *\n+     * @param buffer a native byte buffer containing an exception encoded by\n+     *            {@link #encodeThrowable}\n+     *\/\n@@ -203,2 +212,6 @@\n-    static Throwable decodeThrowable(String encodedThrowable) throws Throwable {\n-        return TranslatedException.decodeThrowable(encodedThrowable);\n+    static void decodeAndThrowThrowable(long buffer) throws Throwable {\n+        Unsafe unsafe = UnsafeAccess.UNSAFE;\n+        int encodingLength = unsafe.getInt(buffer);\n+        byte[] encoding = new byte[encodingLength];\n+        unsafe.copyMemory(null, buffer + 4, encoding, Unsafe.ARRAY_BYTE_BASE_OFFSET, encodingLength);\n+        throw TranslatedException.decodeThrowable(encoding);\n@@ -207,0 +220,12 @@\n+    \/**\n+     * If {@code bufferSize} is large enough, encodes {@code throwable} into a byte array and writes\n+     * it to {@code buffer}. The encoding in {@code buffer} can be decoded by\n+     * {@link #decodeAndThrowThrowable}.\n+     *\n+     * @param throwable the exception to encode\n+     * @param buffer a native byte buffer\n+     * @param bufferSize the size of {@code buffer} in bytes\n+     * @return the number of bytes written into {@code buffer} if {@code bufferSize} is large\n+     *         enough, otherwise {@code -N} where {@code N} is the value {@code bufferSize} needs to\n+     *         be to fit the encoding\n+     *\/\n@@ -208,2 +233,10 @@\n-    static String encodeThrowable(Throwable throwable) throws Throwable {\n-        return TranslatedException.encodeThrowable(throwable);\n+    static int encodeThrowable(Throwable throwable, long buffer, int bufferSize) throws Throwable {\n+        byte[] encoding = TranslatedException.encodeThrowable(throwable);\n+        int requiredSize = 4 + encoding.length;\n+        if (bufferSize < requiredSize) {\n+            return -requiredSize;\n+        }\n+        Unsafe unsafe = UnsafeAccess.UNSAFE;\n+        unsafe.putInt(buffer, encoding.length);\n+        unsafe.copyMemory(encoding, Unsafe.ARRAY_BYTE_BASE_OFFSET, null, buffer + 4, encoding.length);\n+        return requiredSize;\n@@ -238,0 +271,4 @@\n+        ForceTranslateFailure(String.class, null, \"Forces HotSpotJVMCIRuntime.translate to throw an exception in the context \" +\n+                \"of the peer runtime. The value is a filter that can restrict the forced failure to matching translated \" +\n+                \"objects. See HotSpotJVMCIRuntime.postTranslation for more details. This option exists soley to test \" +\n+                \"correct handling of translation failure.\"),\n@@ -1183,1 +1220,82 @@\n-        return compilerToVm.translate(obj);\n+        return compilerToVm.translate(obj, Option.ForceTranslateFailure.getString() != null);\n+    }\n+\n+    private static final Pattern FORCE_TRANSLATE_FAILURE_FILTER_RE = Pattern.compile(\"(?:(method|type|nmethod)\/)?([^:]+)(?::(hotspot|native))?\");\n+\n+    \/**\n+     * Forces translation failure based on {@code translatedObject} and the value of\n+     * {@link Option#ForceTranslateFailure}. The value is zero or more filters separated by a comma.\n+     * The syntax for a filter is:\n+     *\n+     * <pre>\n+     *   Filter = [ TypeSelector \"\/\" ] Substring [ \":\" JVMCIEnvSelector ] .\n+     *   TypeSelector = \"type\" | \"method\" | \"nmethod\"\n+     *   JVMCIEnvSelector = \"native\" | \"hotspot\"\n+     * <\/pre>\n+     *\n+     * For example:\n+     *\n+     * <pre>\n+     *   -Djvmci.ForceTranslateFailure=nmethod\/StackOverflowError:native,method\/computeHash,execute\n+     * <\/pre>\n+     *\n+     * will cause failure of:\n+     * <ul>\n+     * <li>translating a {@link HotSpotNmethod} to the libjvmci heap whose fully qualified name\n+     * contains \"StackOverflowError\"<\/li>\n+     * <li>translating a {@link HotSpotResolvedJavaMethodImpl} to the libjvmci or HotSpot heap whose\n+     * fully qualified name contains \"computeHash\"<\/li>\n+     * <li>translating a {@link HotSpotNmethod}, {@link HotSpotResolvedJavaMethodImpl} or\n+     * {@link HotSpotResolvedObjectTypeImpl} to the libjvmci or HotSpot heap whose fully qualified\n+     * name contains \"execute\"<\/li>\n+     * <\/ul>\n+     *\/\n+    @VMEntryPoint\n+    static void postTranslation(Object translatedObject) {\n+        String value = Option.ForceTranslateFailure.getString();\n+        String toMatch;\n+        String type;\n+        if (translatedObject instanceof HotSpotResolvedJavaMethodImpl) {\n+            toMatch = ((HotSpotResolvedJavaMethodImpl) translatedObject).format(\"%H.%n\");\n+            type = \"method\";\n+        } else if (translatedObject instanceof HotSpotResolvedObjectTypeImpl) {\n+            toMatch = ((HotSpotResolvedObjectTypeImpl) translatedObject).toJavaName();\n+            type = \"type\";\n+        } else if (translatedObject instanceof HotSpotNmethod) {\n+            HotSpotNmethod nmethod = (HotSpotNmethod) translatedObject;\n+            if (nmethod.getMethod() != null) {\n+                toMatch = nmethod.getMethod().format(\"%H.%n\");\n+            } else {\n+                toMatch = String.valueOf(nmethod.getName());\n+            }\n+            type = \"nmethod\";\n+        } else {\n+            return;\n+        }\n+        String[] filters = value.split(\",\");\n+        for (String filter : filters) {\n+            Matcher m = FORCE_TRANSLATE_FAILURE_FILTER_RE.matcher(filter);\n+            if (!m.matches()) {\n+                throw new JVMCIError(Option.ForceTranslateFailure + \" filter does not match \" + FORCE_TRANSLATE_FAILURE_FILTER_RE + \": \" + filter);\n+            }\n+            String typeSelector = m.group(1);\n+            String substring = m.group(2);\n+            String jvmciEnvSelector = m.group(3);\n+            if (jvmciEnvSelector != null) {\n+                if (jvmciEnvSelector.equals(\"native\")) {\n+                    if (!Services.IS_IN_NATIVE_IMAGE) {\n+                        continue;\n+                    }\n+                } else {\n+                    if (Services.IS_IN_NATIVE_IMAGE) {\n+                        continue;\n+                    }\n+                }\n+            }\n+            if (typeSelector != null && !typeSelector.equals(type)) {\n+                continue;\n+            }\n+            if (toMatch.contains(substring)) {\n+                throw new JVMCIError(\"translation of \" + translatedObject + \" failed due to matching \" + Option.ForceTranslateFailure + \" filter \\\"\" + filter + \"\\\"\");\n+            }\n+        }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIRuntime.java","additions":123,"deletions":5,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -25,0 +25,5 @@\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n@@ -29,1 +34,0 @@\n-import java.util.Formatter;\n@@ -31,1 +35,4 @@\n-import java.util.Objects;\n+import java.util.zip.GZIPInputStream;\n+import java.util.zip.GZIPOutputStream;\n+\n+import jdk.vm.ci.common.JVMCIError;\n@@ -39,0 +46,20 @@\n+    \/**\n+     * The value returned by {@link #encodeThrowable(Throwable)} when encoding fails due to an\n+     * {@link OutOfMemoryError}.\n+     *\/\n+    private static final byte[] FALLBACK_ENCODED_OUTOFMEMORYERROR_BYTES;\n+\n+    \/**\n+     * The value returned by {@link #encodeThrowable(Throwable)} when encoding fails for any reason\n+     * other than {@link OutOfMemoryError}.\n+     *\/\n+    private static final byte[] FALLBACK_ENCODED_THROWABLE_BYTES;\n+    static {\n+        try {\n+            FALLBACK_ENCODED_THROWABLE_BYTES = encodeThrowable(new TranslatedException(\"error during encoding\", \"<unknown>\"), false);\n+            FALLBACK_ENCODED_OUTOFMEMORYERROR_BYTES = encodeThrowable(new OutOfMemoryError(), false);\n+        } catch (IOException e) {\n+            throw new JVMCIError(e);\n+        }\n+    }\n+\n@@ -113,14 +140,2 @@\n-    \/**\n-     * Encodes an exception message to distinguish a null message from an empty message.\n-     *\n-     * @return {@code value} with a space prepended iff {@code value != null}\n-     *\/\n-    private static String encodeMessage(String value) {\n-        return value != null ? ' ' + value : value;\n-    }\n-\n-    private static String decodeMessage(String value) {\n-        if (value.length() == 0) {\n-            return null;\n-        }\n-        return value.substring(1);\n+    private static String emptyIfNull(String value) {\n+        return value == null ? \"\" : value;\n@@ -129,2 +144,2 @@\n-    private static String encodedString(String value) {\n-        return Objects.toString(value, \"\").replace('|', '_');\n+    private static String emptyAsNull(String value) {\n+        return value.isEmpty() ? null : value;\n@@ -134,8 +149,2 @@\n-     * Encodes {@code throwable} including its stack and causes as a string. The encoding format of\n-     * a single exception is:\n-     *\n-     * <pre>\n-     * <exception class name> '|' <exception message> '|' <stack size> '|' [ <classLoader> '|' <module> '|' <moduleVersion> '|' <class> '|' <method> '|' <file> '|' <line> '|' ]*\n-     * <\/pre>\n-     *\n-     * Each exception is encoded before the exception it causes.\n+     * Encodes {@code throwable} including its stack and causes as a {@linkplain GZIPOutputStream\n+     * compressed} byte array that can be decoded by {@link #decodeThrowable}.\n@@ -144,1 +153,1 @@\n-    static String encodeThrowable(Throwable throwable) throws Throwable {\n+    static byte[] encodeThrowable(Throwable throwable) throws Throwable {\n@@ -146,1 +155,11 @@\n-            Formatter enc = new Formatter();\n+            return encodeThrowable(throwable, true);\n+        } catch (OutOfMemoryError e) {\n+            return FALLBACK_ENCODED_OUTOFMEMORYERROR_BYTES;\n+        } catch (Throwable e) {\n+            return FALLBACK_ENCODED_THROWABLE_BYTES;\n+        }\n+    }\n+\n+    private static byte[] encodeThrowable(Throwable throwable, boolean withCauseAndStack) throws IOException {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        try (DataOutputStream dos = new DataOutputStream(new GZIPOutputStream(baos))) {\n@@ -150,0 +169,3 @@\n+                if (!withCauseAndStack) {\n+                    break;\n+                }\n@@ -156,2 +178,3 @@\n-                enc.format(\"%s|%s|\", current.getClass().getName(), encodedString(encodeMessage(current.getMessage())));\n-                StackTraceElement[] stackTrace = current.getStackTrace();\n+                dos.writeUTF(current.getClass().getName());\n+                dos.writeUTF(emptyIfNull(current.getMessage()));\n+                StackTraceElement[] stackTrace = withCauseAndStack ? current.getStackTrace() : null;\n@@ -161,1 +184,1 @@\n-                enc.format(\"%d|\", stackTrace.length);\n+                dos.writeInt(stackTrace.length);\n@@ -165,4 +188,7 @@\n-                        enc.format(\"%s|%s|%s|%s|%s|%s|%d|\", encodedString(frame.getClassLoaderName()),\n-                                encodedString(frame.getModuleName()), encodedString(frame.getModuleVersion()),\n-                                frame.getClassName(), frame.getMethodName(),\n-                                encodedString(frame.getFileName()), frame.getLineNumber());\n+                        dos.writeUTF(emptyIfNull(frame.getClassLoaderName()));\n+                        dos.writeUTF(emptyIfNull(frame.getModuleName()));\n+                        dos.writeUTF(emptyIfNull(frame.getModuleVersion()));\n+                        dos.writeUTF(emptyIfNull(frame.getClassName()));\n+                        dos.writeUTF(emptyIfNull(frame.getMethodName()));\n+                        dos.writeUTF(emptyIfNull(frame.getFileName()));\n+                        dos.writeInt(frame.getLineNumber());\n@@ -172,9 +198,0 @@\n-            return enc.toString();\n-        } catch (Throwable e) {\n-            assert printStackTrace(e);\n-            try {\n-                return e.getClass().getName() + \"|\" + encodedString(e.getMessage()) + \"|0|\";\n-            } catch (Throwable e2) {\n-                assert printStackTrace(e2);\n-                return \"java.lang.Throwable|too many errors during encoding|0|\";\n-            }\n@@ -182,0 +199,1 @@\n+        return baos.toByteArray();\n@@ -186,2 +204,2 @@\n-     * below the frame of the first method in {@link CompilerToVM}. The chopped frames are specific\n-     * to the implementation of {@link HotSpotJVMCIRuntime#decodeThrowable(String)}.\n+     * below the frame of the first method in {@link CompilerToVM}. The chopped frames are for the\n+     * VM call to {@link HotSpotJVMCIRuntime#decodeAndThrowThrowable}.\n@@ -189,1 +207,1 @@\n-    private static StackTraceElement[] getStackTraceSuffix() {\n+    private static StackTraceElement[] getMyStackTrace() {\n@@ -209,4 +227,2 @@\n-    static Throwable decodeThrowable(String encodedThrowable) {\n-        try {\n-            int i = 0;\n-            String[] parts = encodedThrowable.split(\"\\\\|\");\n+    static Throwable decodeThrowable(byte[] encodedThrowable) {\n+        try (DataInputStream dis = new DataInputStream(new GZIPInputStream(new ByteArrayInputStream(encodedThrowable)))) {\n@@ -215,3 +231,4 @@\n-            while (i != parts.length) {\n-                String exceptionClassName = parts[i++];\n-                String exceptionMessage = decodeMessage(parts[i++]);\n+            StackTraceElement[] myStack = getMyStackTrace();\n+            while (dis.available() != 0) {\n+                String exceptionClassName = dis.readUTF();\n+                String exceptionMessage = emptyAsNull(dis.readUTF());\n@@ -219,4 +236,4 @@\n-                int stackTraceDepth = Integer.parseInt(parts[i++]);\n-\n-                StackTraceElement[] suffix = getStackTraceSuffix();\n-                StackTraceElement[] stackTrace = new StackTraceElement[stackTraceDepth + suffix.length];\n+                int stackTraceDepth = dis.readInt();\n+                StackTraceElement[] stackTrace = new StackTraceElement[stackTraceDepth + myStack.length];\n+                int stackTraceIndex = 0;\n+                int myStackIndex = 0;\n@@ -224,18 +241,21 @@\n-                    String classLoaderName = parts[i++];\n-                    String moduleName = parts[i++];\n-                    String moduleVersion = parts[i++];\n-                    String className = parts[i++];\n-                    String methodName = parts[i++];\n-                    String fileName = parts[i++];\n-                    int lineNumber = Integer.parseInt(parts[i++]);\n-                    if (classLoaderName.isEmpty()) {\n-                        classLoaderName = null;\n-                    }\n-                    if (moduleName.isEmpty()) {\n-                        moduleName = null;\n-                    }\n-                    if (moduleVersion.isEmpty()) {\n-                        moduleVersion = null;\n-                    }\n-                    if (fileName.isEmpty()) {\n-                        fileName = null;\n+                    String classLoaderName = emptyAsNull(dis.readUTF());\n+                    String moduleName = emptyAsNull(dis.readUTF());\n+                    String moduleVersion = emptyAsNull(dis.readUTF());\n+                    String className = emptyAsNull(dis.readUTF());\n+                    String methodName = emptyAsNull(dis.readUTF());\n+                    String fileName = emptyAsNull(dis.readUTF());\n+                    int lineNumber = dis.readInt();\n+                    StackTraceElement ste = new StackTraceElement(classLoaderName, moduleName, moduleVersion, className, methodName, fileName, lineNumber);\n+\n+                    if (ste.isNativeMethod()) {\n+                        \/\/ Best effort attempt to weave stack traces from two heaps into\n+                        \/\/ a single stack trace using native method frames as stitching points.\n+                        \/\/ This is not 100% reliable as there's no guarantee that native method\n+                        \/\/ frames only exist for calls between HotSpot and libjvmci.\n+                        while (myStackIndex < myStack.length) {\n+                            StackTraceElement suffixSTE = myStack[myStackIndex++];\n+                            if (suffixSTE.isNativeMethod()) {\n+                                break;\n+                            }\n+                            stackTrace[stackTraceIndex++] = suffixSTE;\n+                        }\n@@ -243,1 +263,4 @@\n-                    stackTrace[j] = new StackTraceElement(classLoaderName, moduleName, moduleVersion, className, methodName, fileName, lineNumber);\n+                    stackTrace[stackTraceIndex++] = ste;\n+                }\n+                while (myStackIndex < myStack.length) {\n+                    stackTrace[stackTraceIndex++] = myStack[myStackIndex++];\n@@ -245,1 +268,0 @@\n-                System.arraycopy(suffix, 0, stackTrace, stackTraceDepth, suffix.length);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/TranslatedException.java","additions":100,"deletions":78,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n- * @modules jdk.internal.vm.ci\/jdk.vm.ci.hotspot:open\n+ * @modules jdk.internal.vm.ci\/jdk.vm.ci.hotspot:+open\n+ *          java.base\/jdk.internal.misc\n@@ -44,0 +45,3 @@\n+import jdk.internal.misc.Unsafe;\n+import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;\n+\n@@ -59,1 +63,1 @@\n-        Method decode = translatedExceptionClass.getDeclaredMethod(\"decodeThrowable\", String.class);\n+        Method decode = translatedExceptionClass.getDeclaredMethod(\"decodeThrowable\", byte[].class);\n@@ -67,1 +71,1 @@\n-        String encoding = (String) encode.invoke(null, throwable);\n+        byte[] encoding = (byte[]) encode.invoke(null, throwable);\n@@ -72,0 +76,39 @@\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public void encodeDecodeTest2() throws Exception {\n+        Unsafe unsafe = Unsafe.getUnsafe();\n+        int bufferSize = 512;\n+        long buffer = 0L;\n+        while (true) {\n+            buffer = unsafe.allocateMemory(bufferSize);\n+            try {\n+                Throwable throwable = new ExceptionInInitializerError(new InvocationTargetException(new Untranslatable(\"test exception\", new NullPointerException()), \"invoke\"));\n+                for (int i = 0; i < 10; i++) {\n+                    throwable = new ExceptionInInitializerError(new InvocationTargetException(new RuntimeException(String.valueOf(i), throwable), \"invoke\"));\n+                }\n+\n+                Method encode = HotSpotJVMCIRuntime.class.getDeclaredMethod(\"encodeThrowable\", Throwable.class, long.class, int.class);\n+                Method decode = HotSpotJVMCIRuntime.class.getDeclaredMethod(\"decodeAndThrowThrowable\", long.class);\n+                encode.setAccessible(true);\n+                decode.setAccessible(true);\n+\n+                int res = (Integer) encode.invoke(null, throwable, buffer, bufferSize);\n+\n+                if (res < 0) {\n+                    bufferSize = -res;\n+                } else {\n+                    try {\n+                        decode.invoke(null, buffer);\n+                        throw new AssertionError(\"expected decodeAndThrowThrowable to throw an exception\");\n+                    } catch (InvocationTargetException e) {\n+                        Throwable decoded = e.getCause();\n+                        assertThrowableEquals(throwable, decoded);\n+                    }\n+                    return;\n+                }\n+            } finally {\n+                unsafe.freeMemory(buffer);\n+            }\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/TestTranslatedException.java","additions":46,"deletions":3,"binary":false,"changes":49,"status":"modified"}]}