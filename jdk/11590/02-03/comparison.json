{"files":[{"patch":"@@ -75,23 +75,0 @@\n-    protected SessionTicketExtension.StatelessKey getKey(int id) {\n-        return serverCache.getKey(id);\n-    }\n-\n-    protected SessionTicketExtension.StatelessKey getKey() {\n-        SessionTicketExtension.StatelessKey ssk = serverCache.getKey();\n-        if (ssk != null && !ssk.isExpired()) {\n-            return ssk;\n-        }\n-        synchronized (serverCache) {\n-            \/\/ If the current key is no longer expired, it was already\n-            \/\/ updated by a concurrent request, and we can return.\n-            ssk = serverCache.getKey();\n-            if (ssk != null && !ssk.isExpired()) {\n-                return ssk;\n-            }\n-            int newID = serverCache.getCurrentKeyID() + 1;\n-            ssk = new SessionTicketExtension.StatelessKey(getSecureRandom(), newID);\n-            serverCache.insertNewSessionKey(newID, ssk);\n-            return ssk;\n-        }\n-    }\n-\n@@ -133,1 +110,1 @@\n-        int keyID = secureRandom.nextInt();\n+        secureRandom.nextInt();\n@@ -137,2 +114,0 @@\n-        \/\/ Use the \"priming output\" to initialize the FC 5077 session ticket key name\n-        serverCache.initCurrentKeyID(keyID);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLContextImpl.java","additions":1,"deletions":26,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.security.SecureRandom;\n@@ -76,3 +75,4 @@\n-    private int currentKeyID;           \/\/ RFC 5077 session ticket key name\n-    private final Map<Integer,          \/\/ Maps session keys to session state\n-            SessionTicketExtension.StatelessKey> keyHashMap = new ConcurrentHashMap<>();\n+    \/\/ The current session ticket encryption key ID (only used in server context)\n+    private int currentKeyID;\n+    \/\/ Session ticket encryption keys and IDs map (only used in server context)\n+    private final Map<Integer, SessionTicketExtension.StatelessKey> keyHashMap;\n@@ -91,0 +91,8 @@\n+        if (server) {\n+            keyHashMap = new ConcurrentHashMap<>();\n+            \/\/ Should be \"randomly generated\" according to RFC 5077,\n+            \/\/ but doesn't necessarily has to be a true random number.\n+            currentKeyID = this.hashCode();\n+        } else {\n+            keyHashMap = null;\n+        }\n@@ -181,11 +189,1 @@\n-    \/\/ Package-private, used only from SSLContextImpl::engineInit() to initialie currentKeyID.\n-    void initCurrentKeyID(int keyID) {\n-        currentKeyID = keyID;\n-    }\n-\n-    \/\/ Package-private, used only from SSLContextImpl::getKey() to create a new session key.\n-    int getCurrentKeyID() {\n-        return currentKeyID;\n-    }\n-\n-    private void cleanupSessionKeys() {\n+    private void cleanupStatelessKeys() {\n@@ -208,10 +206,1 @@\n-    \/\/ Every time we insert a new session key we check for and delete invalid keys.\n-    \/\/ Package-private, used only from SSLContextImpl::getKey() to create a new session key.\n-    void insertNewSessionKey(int newID, SessionTicketExtension.StatelessKey ssk) {\n-        assert newID != currentKeyID : \"Must use a new ID for a new session key!\";\n-        keyHashMap.put(Integer.valueOf(newID), ssk);\n-        currentKeyID = newID;\n-        cleanupSessionKeys();\n-    }\n-\n-    \/\/ Package-private, used only from SSLContextImpl::getKey().\n+    \/\/ Package-private, used only from SessionTicketExtension.KeyState::getCurrentKey.\n@@ -219,1 +208,19 @@\n-        return keyHashMap.get(currentKeyID);\n+        SessionTicketExtension.StatelessKey ssk = keyHashMap.get(currentKeyID);\n+        if (ssk != null && !ssk.isExpired()) {\n+            return ssk;\n+        }\n+        synchronized (this) {\n+            \/\/ If the current key is no longer expired, it was already\n+            \/\/ updated by a concurrent request, and we can return.\n+            ssk = keyHashMap.get(currentKeyID);\n+            if (ssk != null && !ssk.isExpired()) {\n+                return ssk;\n+            }\n+            int newID = currentKeyID + 1;\n+            ssk = new SessionTicketExtension.StatelessKey(newID);\n+            keyHashMap.put(Integer.valueOf(newID), ssk);\n+            currentKeyID = newID;\n+        }\n+        \/\/ Check for and delete invalid keys every time we create a new stateless key.\n+        cleanupStatelessKeys();\n+        return ssk;\n@@ -222,1 +229,1 @@\n-    \/\/ Package-private, used only from SSLContextImpl::getKey(int id).\n+    \/\/ Package-private, used only from SessionTicketExtension.KeyState::getKey.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionContextImpl.java","additions":34,"deletions":27,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-        StatelessKey(SecureRandom secRand, int num) {\n+        StatelessKey(int num) {\n@@ -123,1 +123,1 @@\n-                kg.init(KEYLEN, secRand);\n+                kg.init(KEYLEN);\n@@ -149,1 +149,3 @@\n-            StatelessKey ssk = hc.sslContext.getKey(num);\n+            SSLSessionContextImpl serverCache =\n+                (SSLSessionContextImpl)hc.sslContext.engineGetServerSessionContext();\n+            StatelessKey ssk = serverCache.getKey(num);\n@@ -151,1 +153,1 @@\n-            if (ssk == null || ssk.isInvalid(hc.sslContext.engineGetServerSessionContext())) {\n+            if (ssk == null || ssk.isInvalid(serverCache)) {\n@@ -159,1 +161,3 @@\n-            return hc.sslContext.getKey();\n+            SSLSessionContextImpl serverCache =\n+                (SSLSessionContextImpl)hc.sslContext.engineGetServerSessionContext();\n+            return serverCache.getKey();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SessionTicketExtension.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"}]}