{"files":[{"patch":"@@ -33,1 +33,0 @@\n-import java.util.concurrent.ConcurrentHashMap;\n@@ -75,28 +74,0 @@\n-    private int currentKeyID = new SecureRandom().nextInt();\n-    private final Map<Integer,\n-            SessionTicketExtension.StatelessKey> keyHashMap = new ConcurrentHashMap<>();\n-\n-    private void cleanupSessionKeys() {\n-        for (Map.Entry<Integer, SessionTicketExtension.StatelessKey> entry : keyHashMap.entrySet()) {\n-            SessionTicketExtension.StatelessKey k = entry.getValue();\n-            if (k.isInvalid(this)) {\n-                try {\n-                    k.key.destroy();\n-                } catch (Exception e) {\n-                    \/\/ Suppress\n-                }\n-                keyHashMap.remove(entry.getKey());\n-            }\n-        }\n-    }\n-\n-    protected void addSessionKey(SessionTicketExtension.StatelessKey key) {\n-        int newID = key.num;\n-        keyHashMap.put(Integer.valueOf(newID), key);\n-        currentKeyID = newID;\n-        cleanupSessionKeys();\n-    }\n-\n-    protected int getID() {\n-        return currentKeyID;\n-    }\n@@ -105,1 +76,1 @@\n-        return keyHashMap.get(id);\n+        return serverCache.getKey(id);\n@@ -109,1 +80,16 @@\n-        return keyHashMap.get(currentKeyID);\n+        SessionTicketExtension.StatelessKey ssk = serverCache.getKey();\n+        if (ssk != null && !ssk.isExpired()) {\n+            return ssk;\n+        }\n+        synchronized (serverCache) {\n+            \/\/ If the current key is no longer expired, it was already\n+            \/\/ updated by a concurrent request, and we can return.\n+            ssk = serverCache.getKey();\n+            if (ssk != null && !ssk.isExpired()) {\n+                return ssk;\n+            }\n+            int newID = serverCache.getCurrentKeyID() + 1;\n+            ssk = new SessionTicketExtension.StatelessKey(getSecureRandom(), newID);\n+            serverCache.insertNewSessionKey(newID, ssk);\n+            return ssk;\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLContextImpl.java","additions":17,"deletions":31,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.security.SecureRandom;\n@@ -32,0 +33,2 @@\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -72,0 +75,5 @@\n+    private int currentKeyID = new SecureRandom().nextInt();\n+                                        \/\/ RFC 5077 session ticket key name\n+    private final Map<Integer,          \/\/ Maps session keys to session state\n+            SessionTicketExtension.StatelessKey> keyHashMap = new ConcurrentHashMap<>();\n+\n@@ -173,0 +181,37 @@\n+    \/\/ package-private, used only by SSLContextImpl\n+    int getCurrentKeyID() {\n+        return currentKeyID;\n+    }\n+\n+    private void cleanupSessionKeys() {\n+        for (Map.Entry<Integer, SessionTicketExtension.StatelessKey> entry : keyHashMap.entrySet()) {\n+            SessionTicketExtension.StatelessKey k = entry.getValue();\n+            if (k.isInvalid(this)) {\n+                try {\n+                    k.key.destroy();\n+                } catch (Exception e) {\n+                    \/\/ Suppress\n+                }\n+                keyHashMap.remove(entry.getKey());\n+            }\n+        }\n+    }\n+\n+    \/\/ Every time we insert a new session key we check for and delete invalid keys.\n+    \/\/ package-private, used only by SSLContextImpl\n+    void insertNewSessionKey(int newID, SessionTicketExtension.StatelessKey ssk) {\n+        keyHashMap.put(Integer.valueOf(newID), ssk);\n+        currentKeyID = newID;\n+        cleanupSessionKeys();\n+    }\n+\n+    \/\/ package-private, used only by SSLContextImpl\n+    SessionTicketExtension.StatelessKey getKey() {\n+        return keyHashMap.get(currentKeyID);\n+    }\n+\n+    \/\/ package-private, used only by SSLContextImpl\n+    SessionTicketExtension.StatelessKey getKey(int id) {\n+        return keyHashMap.get(id);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionContextImpl.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import javax.net.ssl.SSLSessionContext;\n@@ -117,1 +118,2 @@\n-        private StatelessKey(SSLContextImpl sslContext, int num) {\n+        \/\/ package-private, used only by SSLContextImpl\n+        StatelessKey(SecureRandom secRand, int num) {\n@@ -121,1 +123,1 @@\n-                kg.init(KEYLEN, sslContext.getSecureRandom());\n+                kg.init(KEYLEN, secRand);\n@@ -131,20 +133,0 @@\n-        \/\/ This methods gets called when there's no current, valid key\n-        \/\/ in sslContext. It locks sslContext while it creates a new key\n-        \/\/ and adds it to the sslContex with a new key ID.\n-        \/\/ Adding a new key to sslContex will also cleanup invalid keys\n-        \/\/ from the sslContex.\n-        static StatelessKey getNextKey(SSLContextImpl sslContext) {\n-            synchronized (sslContext) {\n-                \/\/ If the current key is no longer expired, it was already\n-                \/\/ updated by a previous operation, and we can return.\n-                StatelessKey ssk = sslContext.getKey();\n-                if (ssk != null && !ssk.isExpired()) {\n-                    return ssk;\n-                }\n-                int nextID = sslContext.getID() + 1;\n-                ssk = new StatelessKey(sslContext, nextID);\n-                sslContext.addSessionKey(ssk);\n-                return ssk;\n-            }\n-        }\n-\n@@ -157,2 +139,2 @@\n-        boolean isInvalid(SSLContextImpl sslContext) {\n-            int sessionTimeout = sslContext.engineGetServerSessionContext().getSessionTimeout() * 1000;\n+        boolean isInvalid(SSLSessionContext sslSessionContext) {\n+            int sessionTimeout = sslSessionContext.getSessionTimeout() * 1000;\n@@ -169,1 +151,1 @@\n-            if (ssk == null || ssk.isInvalid(hc.sslContext)) {\n+            if (ssk == null || ssk.isInvalid(hc.sslContext.engineGetServerSessionContext())) {\n@@ -177,6 +159,1 @@\n-            StatelessKey ssk = hc.sslContext.getKey();\n-\n-            if (ssk != null && !ssk.isExpired()) {\n-                return ssk;\n-            }\n-            return StatelessKey.getNextKey(hc.sslContext);\n+            return hc.sslContext.getKey();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SessionTicketExtension.java","additions":8,"deletions":31,"binary":false,"changes":39,"status":"modified"}]}