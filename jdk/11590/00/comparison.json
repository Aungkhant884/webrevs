{"files":[{"patch":"@@ -33,0 +33,1 @@\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -74,2 +75,3 @@\n-    final HashMap<Integer,\n-            SessionTicketExtension.StatelessKey> keyHashMap = new HashMap<>();\n+    private int currentKeyID = new SecureRandom().nextInt();\n+    private final Map<Integer,\n+            SessionTicketExtension.StatelessKey> keyHashMap = new ConcurrentHashMap<>();\n@@ -77,0 +79,32 @@\n+    private void cleanupSessionKeys() {\n+        for (Map.Entry<Integer, SessionTicketExtension.StatelessKey> entry : keyHashMap.entrySet()) {\n+            SessionTicketExtension.StatelessKey k = entry.getValue();\n+            if (k.isInvalid(this)) {\n+                try {\n+                    k.key.destroy();\n+                } catch (Exception e) {\n+                    \/\/ Suppress\n+                }\n+                keyHashMap.remove(entry.getKey());\n+            }\n+        }\n+    }\n+\n+    protected void addSessionKey(SessionTicketExtension.StatelessKey key) {\n+        int newID = key.num;\n+        keyHashMap.put(Integer.valueOf(newID), key);\n+        currentKeyID = newID;\n+        cleanupSessionKeys();\n+    }\n+\n+    protected int getID() {\n+        return currentKeyID;\n+    }\n+\n+    protected SessionTicketExtension.StatelessKey getKey(int id) {\n+        return keyHashMap.get(id);\n+    }\n+\n+    protected SessionTicketExtension.StatelessKey getKey() {\n+        return keyHashMap.get(currentKeyID);\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLContextImpl.java","additions":36,"deletions":2,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -77,1 +77,0 @@\n-    private static int currentKeyID = new SecureRandom().nextInt();\n@@ -118,1 +117,1 @@\n-        StatelessKey(HandshakeContext hc, int newNum) {\n+        private StatelessKey(SSLContextImpl sslContext, int num) {\n@@ -122,1 +121,1 @@\n-                kg.init(KEYLEN, hc.sslContext.getSecureRandom());\n+                kg.init(KEYLEN, sslContext.getSecureRandom());\n@@ -129,2 +128,21 @@\n-            num = newNum;\n-            hc.sslContext.keyHashMap.put(Integer.valueOf(num), this);\n+            this.num = num;\n+        }\n+\n+        \/\/ This methods gets called when there's no current, valid key\n+        \/\/ in sslContext. It locks sslContext while it creates a new key\n+        \/\/ and adds it to the sslContex with a new key ID.\n+        \/\/ Adding a new key to sslContex will also cleanup invalid keys\n+        \/\/ from the sslContex.\n+        static StatelessKey getNextKey(SSLContextImpl sslContext) {\n+            synchronized (sslContext) {\n+                \/\/ If the current key is no longer expired, it was already\n+                \/\/ updated by a previous operation, and we can return.\n+                StatelessKey ssk = sslContext.getKey();\n+                if (ssk != null && !ssk.isExpired()) {\n+                    return ssk;\n+                }\n+                int nextID = sslContext.getID() + 1;\n+                ssk = new StatelessKey(sslContext, nextID);\n+                sslContext.addSessionKey(ssk);\n+                return ssk;\n+            }\n@@ -139,1 +157,2 @@\n-        boolean isInvalid(long sessionTimeout) {\n+        boolean isInvalid(SSLContextImpl sslContext) {\n+            int sessionTimeout = sslContext.engineGetServerSessionContext().getSessionTimeout() * 1000;\n@@ -148,1 +167,1 @@\n-            StatelessKey ssk = hc.sslContext.keyHashMap.get(num);\n+            StatelessKey ssk = hc.sslContext.getKey(num);\n@@ -150,1 +169,1 @@\n-            if (ssk == null || ssk.isInvalid(getSessionTimeout(hc))) {\n+            if (ssk == null || ssk.isInvalid(hc.sslContext)) {\n@@ -158,1 +177,1 @@\n-            StatelessKey ssk = hc.sslContext.keyHashMap.get(currentKeyID);\n+            StatelessKey ssk = hc.sslContext.getKey();\n@@ -163,58 +182,1 @@\n-            return nextKey(hc);\n-        }\n-\n-        \/\/ This method locks when the first getCurrentKey() finds it to be too\n-        \/\/ old and create a new key to replace the current key.  After the new\n-        \/\/ key established, the lock can be released so following\n-        \/\/ operations will start using the new key.\n-        \/\/ The first operation will take a longer code path by generating the\n-        \/\/ next key and cleaning up old keys.\n-        private static StatelessKey nextKey(HandshakeContext hc) {\n-            StatelessKey ssk;\n-\n-            synchronized (hc.sslContext.keyHashMap) {\n-                \/\/ If the current key is no longer expired, it was already\n-                \/\/ updated by a previous operation, and we can return.\n-                ssk = hc.sslContext.keyHashMap.get(currentKeyID);\n-                if (ssk != null && !ssk.isExpired()) {\n-                    return ssk;\n-                }\n-                int newNum;\n-                if (currentKeyID == Integer.MAX_VALUE) {\n-                    newNum = 0;\n-                } else {\n-                    newNum = currentKeyID + 1;\n-                }\n-                \/\/ Get new key\n-                ssk = new StatelessKey(hc, newNum);\n-                currentKeyID = newNum;\n-                \/\/ Release lock since the new key is ready to be used.\n-            }\n-\n-            \/\/ Clean up any old keys, then return the current key\n-            cleanup(hc);\n-            return ssk;\n-        }\n-\n-        \/\/ Deletes any invalid SessionStateKeys.\n-        static void cleanup(HandshakeContext hc) {\n-            int sessionTimeout = getSessionTimeout(hc);\n-\n-            StatelessKey ks;\n-            for (Object o : hc.sslContext.keyHashMap.keySet().toArray()) {\n-                Integer i = (Integer)o;\n-                ks = hc.sslContext.keyHashMap.get(i);\n-                if (ks.isInvalid(sessionTimeout)) {\n-                    try {\n-                        ks.key.destroy();\n-                    } catch (Exception e) {\n-                        \/\/ Suppress\n-                    }\n-                    hc.sslContext.keyHashMap.remove(i);\n-                }\n-            }\n-        }\n-\n-        static int getSessionTimeout(HandshakeContext hc) {\n-            return hc.sslContext.engineGetServerSessionContext().\n-                    getSessionTimeout() * 1000;\n+            return StatelessKey.getNextKey(hc.sslContext);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SessionTicketExtension.java","additions":29,"deletions":67,"binary":false,"changes":96,"status":"modified"}]}