{"files":[{"patch":"@@ -74,2 +74,0 @@\n-    final HashMap<Integer,\n-            SessionTicketExtension.StatelessKey> keyHashMap = new HashMap<>();\n@@ -77,0 +75,22 @@\n+    protected SessionTicketExtension.StatelessKey getKey(int id) {\n+        return serverCache.getKey(id);\n+    }\n+\n+    protected SessionTicketExtension.StatelessKey getKey() {\n+        SessionTicketExtension.StatelessKey ssk = serverCache.getKey();\n+        if (ssk != null && !ssk.isExpired()) {\n+            return ssk;\n+        }\n+        synchronized (serverCache) {\n+            \/\/ If the current key is no longer expired, it was already\n+            \/\/ updated by a concurrent request, and we can return.\n+            ssk = serverCache.getKey();\n+            if (ssk != null && !ssk.isExpired()) {\n+                return ssk;\n+            }\n+            int newID = serverCache.getCurrentKeyID() + 1;\n+            ssk = new SessionTicketExtension.StatelessKey(getSecureRandom(), newID);\n+            serverCache.insertNewSessionKey(newID, ssk);\n+            return ssk;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLContextImpl.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.security.SecureRandom;\n@@ -32,0 +33,2 @@\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -72,0 +75,5 @@\n+    private int currentKeyID = new SecureRandom().nextInt();\n+                                        \/\/ RFC 5077 session ticket key name\n+    private final Map<Integer,          \/\/ Maps session keys to session state\n+            SessionTicketExtension.StatelessKey> keyHashMap = new ConcurrentHashMap<>();\n+\n@@ -173,0 +181,37 @@\n+    \/\/ package-private, used only by SSLContextImpl\n+    int getCurrentKeyID() {\n+        return currentKeyID;\n+    }\n+\n+    private void cleanupSessionKeys() {\n+        for (Map.Entry<Integer, SessionTicketExtension.StatelessKey> entry : keyHashMap.entrySet()) {\n+            SessionTicketExtension.StatelessKey k = entry.getValue();\n+            if (k.isInvalid(this)) {\n+                try {\n+                    k.key.destroy();\n+                } catch (Exception e) {\n+                    \/\/ Suppress\n+                }\n+                keyHashMap.remove(entry.getKey());\n+            }\n+        }\n+    }\n+\n+    \/\/ Every time we insert a new session key we check for and delete invalid keys.\n+    \/\/ package-private, used only by SSLContextImpl\n+    void insertNewSessionKey(int newID, SessionTicketExtension.StatelessKey ssk) {\n+        keyHashMap.put(Integer.valueOf(newID), ssk);\n+        currentKeyID = newID;\n+        cleanupSessionKeys();\n+    }\n+\n+    \/\/ package-private, used only by SSLContextImpl\n+    SessionTicketExtension.StatelessKey getKey() {\n+        return keyHashMap.get(currentKeyID);\n+    }\n+\n+    \/\/ package-private, used only by SSLContextImpl\n+    SessionTicketExtension.StatelessKey getKey(int id) {\n+        return keyHashMap.get(id);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionContextImpl.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import javax.net.ssl.SSLSessionContext;\n@@ -77,1 +78,0 @@\n-    private static int currentKeyID = new SecureRandom().nextInt();\n@@ -118,1 +118,2 @@\n-        StatelessKey(HandshakeContext hc, int newNum) {\n+        \/\/ package-private, used only by SSLContextImpl\n+        StatelessKey(SecureRandom secRand, int num) {\n@@ -122,1 +123,1 @@\n-                kg.init(KEYLEN, hc.sslContext.getSecureRandom());\n+                kg.init(KEYLEN, secRand);\n@@ -129,2 +130,1 @@\n-            num = newNum;\n-            hc.sslContext.keyHashMap.put(Integer.valueOf(num), this);\n+            this.num = num;\n@@ -139,1 +139,2 @@\n-        boolean isInvalid(long sessionTimeout) {\n+        boolean isInvalid(SSLSessionContext sslSessionContext) {\n+            int sessionTimeout = sslSessionContext.getSessionTimeout() * 1000;\n@@ -148,1 +149,1 @@\n-            StatelessKey ssk = hc.sslContext.keyHashMap.get(num);\n+            StatelessKey ssk = hc.sslContext.getKey(num);\n@@ -150,1 +151,1 @@\n-            if (ssk == null || ssk.isInvalid(getSessionTimeout(hc))) {\n+            if (ssk == null || ssk.isInvalid(hc.sslContext.engineGetServerSessionContext())) {\n@@ -158,63 +159,1 @@\n-            StatelessKey ssk = hc.sslContext.keyHashMap.get(currentKeyID);\n-\n-            if (ssk != null && !ssk.isExpired()) {\n-                return ssk;\n-            }\n-            return nextKey(hc);\n-        }\n-\n-        \/\/ This method locks when the first getCurrentKey() finds it to be too\n-        \/\/ old and create a new key to replace the current key.  After the new\n-        \/\/ key established, the lock can be released so following\n-        \/\/ operations will start using the new key.\n-        \/\/ The first operation will take a longer code path by generating the\n-        \/\/ next key and cleaning up old keys.\n-        private static StatelessKey nextKey(HandshakeContext hc) {\n-            StatelessKey ssk;\n-\n-            synchronized (hc.sslContext.keyHashMap) {\n-                \/\/ If the current key is no longer expired, it was already\n-                \/\/ updated by a previous operation, and we can return.\n-                ssk = hc.sslContext.keyHashMap.get(currentKeyID);\n-                if (ssk != null && !ssk.isExpired()) {\n-                    return ssk;\n-                }\n-                int newNum;\n-                if (currentKeyID == Integer.MAX_VALUE) {\n-                    newNum = 0;\n-                } else {\n-                    newNum = currentKeyID + 1;\n-                }\n-                \/\/ Get new key\n-                ssk = new StatelessKey(hc, newNum);\n-                currentKeyID = newNum;\n-                \/\/ Release lock since the new key is ready to be used.\n-            }\n-\n-            \/\/ Clean up any old keys, then return the current key\n-            cleanup(hc);\n-            return ssk;\n-        }\n-\n-        \/\/ Deletes any invalid SessionStateKeys.\n-        static void cleanup(HandshakeContext hc) {\n-            int sessionTimeout = getSessionTimeout(hc);\n-\n-            StatelessKey ks;\n-            for (Object o : hc.sslContext.keyHashMap.keySet().toArray()) {\n-                Integer i = (Integer)o;\n-                ks = hc.sslContext.keyHashMap.get(i);\n-                if (ks.isInvalid(sessionTimeout)) {\n-                    try {\n-                        ks.key.destroy();\n-                    } catch (Exception e) {\n-                        \/\/ Suppress\n-                    }\n-                    hc.sslContext.keyHashMap.remove(i);\n-                }\n-            }\n-        }\n-\n-        static int getSessionTimeout(HandshakeContext hc) {\n-            return hc.sslContext.engineGetServerSessionContext().\n-                    getSessionTimeout() * 1000;\n+            return hc.sslContext.getKey();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SessionTicketExtension.java","additions":10,"deletions":71,"binary":false,"changes":81,"status":"modified"}]}