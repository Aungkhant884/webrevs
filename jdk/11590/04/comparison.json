{"files":[{"patch":"@@ -74,3 +74,0 @@\n-    final HashMap<Integer,\n-            SessionTicketExtension.StatelessKey> keyHashMap = new HashMap<>();\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLContextImpl.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Iterator;\n@@ -32,0 +33,3 @@\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -72,0 +76,5 @@\n+    \/\/ The current session ticket encryption key ID (only used in server context)\n+    private int currentKeyID;\n+    \/\/ Session ticket encryption keys and IDs map (only used in server context)\n+    private final Map<Integer, SessionTicketExtension.StatelessKey> keyHashMap;\n+\n@@ -83,0 +92,8 @@\n+        if (server) {\n+            keyHashMap = new ConcurrentHashMap<>();\n+            \/\/ Should be \"randomly generated\" according to RFC 5077,\n+            \/\/ but doesn't necessarily has to be a true random number.\n+            currentKeyID = new Random(System.nanoTime()).nextInt();\n+        } else {\n+            keyHashMap = Map.of();\n+        }\n@@ -173,0 +190,45 @@\n+    private void cleanupStatelessKeys() {\n+        Iterator<Map.Entry<Integer, SessionTicketExtension.StatelessKey>> it =\n+            keyHashMap.entrySet().iterator();\n+        while (it.hasNext()) {\n+            Map.Entry<Integer, SessionTicketExtension.StatelessKey> entry = it.next();\n+            SessionTicketExtension.StatelessKey k = entry.getValue();\n+            if (k.isInvalid(this)) {\n+                it.remove();\n+                try {\n+                    k.key.destroy();\n+                } catch (Exception e) {\n+                    \/\/ Suppress\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Package-private, used only from SessionTicketExtension.KeyState::getCurrentKey.\n+    SessionTicketExtension.StatelessKey getKey(HandshakeContext hc) {\n+        SessionTicketExtension.StatelessKey ssk = keyHashMap.get(currentKeyID);\n+        if (ssk != null && !ssk.isExpired()) {\n+            return ssk;\n+        }\n+        synchronized (this) {\n+            \/\/ If the current key is no longer expired, it was already\n+            \/\/ updated by a concurrent request, and we can return.\n+            ssk = keyHashMap.get(currentKeyID);\n+            if (ssk != null && !ssk.isExpired()) {\n+                return ssk;\n+            }\n+            int newID = currentKeyID + 1;\n+            ssk = new SessionTicketExtension.StatelessKey(hc, newID);\n+            keyHashMap.put(Integer.valueOf(newID), ssk);\n+            currentKeyID = newID;\n+        }\n+        \/\/ Check for and delete invalid keys every time we create a new stateless key.\n+        cleanupStatelessKeys();\n+        return ssk;\n+    }\n+\n+    \/\/ Package-private, used only from SessionTicketExtension.KeyState::getKey.\n+    SessionTicketExtension.StatelessKey getKey(int id) {\n+        return keyHashMap.get(id);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionContextImpl.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import javax.net.ssl.SSLSessionContext;\n@@ -77,1 +78,0 @@\n-    private static int currentKeyID = new SecureRandom().nextInt();\n@@ -118,1 +118,2 @@\n-        StatelessKey(HandshakeContext hc, int newNum) {\n+        \/\/ package-private, used only by SSLContextImpl\n+        StatelessKey(HandshakeContext hc, int num) {\n@@ -129,2 +130,1 @@\n-            num = newNum;\n-            hc.sslContext.keyHashMap.put(Integer.valueOf(num), this);\n+            this.num = num;\n@@ -139,1 +139,2 @@\n-        boolean isInvalid(long sessionTimeout) {\n+        boolean isInvalid(SSLSessionContext sslSessionContext) {\n+            int sessionTimeout = sslSessionContext.getSessionTimeout() * 1000;\n@@ -148,1 +149,3 @@\n-            StatelessKey ssk = hc.sslContext.keyHashMap.get(num);\n+            SSLSessionContextImpl serverCache =\n+                (SSLSessionContextImpl)hc.sslContext.engineGetServerSessionContext();\n+            StatelessKey ssk = serverCache.getKey(num);\n@@ -150,1 +153,1 @@\n-            if (ssk == null || ssk.isInvalid(getSessionTimeout(hc))) {\n+            if (ssk == null || ssk.isInvalid(serverCache)) {\n@@ -158,63 +161,3 @@\n-            StatelessKey ssk = hc.sslContext.keyHashMap.get(currentKeyID);\n-\n-            if (ssk != null && !ssk.isExpired()) {\n-                return ssk;\n-            }\n-            return nextKey(hc);\n-        }\n-\n-        \/\/ This method locks when the first getCurrentKey() finds it to be too\n-        \/\/ old and create a new key to replace the current key.  After the new\n-        \/\/ key established, the lock can be released so following\n-        \/\/ operations will start using the new key.\n-        \/\/ The first operation will take a longer code path by generating the\n-        \/\/ next key and cleaning up old keys.\n-        private static StatelessKey nextKey(HandshakeContext hc) {\n-            StatelessKey ssk;\n-\n-            synchronized (hc.sslContext.keyHashMap) {\n-                \/\/ If the current key is no longer expired, it was already\n-                \/\/ updated by a previous operation, and we can return.\n-                ssk = hc.sslContext.keyHashMap.get(currentKeyID);\n-                if (ssk != null && !ssk.isExpired()) {\n-                    return ssk;\n-                }\n-                int newNum;\n-                if (currentKeyID == Integer.MAX_VALUE) {\n-                    newNum = 0;\n-                } else {\n-                    newNum = currentKeyID + 1;\n-                }\n-                \/\/ Get new key\n-                ssk = new StatelessKey(hc, newNum);\n-                currentKeyID = newNum;\n-                \/\/ Release lock since the new key is ready to be used.\n-            }\n-\n-            \/\/ Clean up any old keys, then return the current key\n-            cleanup(hc);\n-            return ssk;\n-        }\n-\n-        \/\/ Deletes any invalid SessionStateKeys.\n-        static void cleanup(HandshakeContext hc) {\n-            int sessionTimeout = getSessionTimeout(hc);\n-\n-            StatelessKey ks;\n-            for (Object o : hc.sslContext.keyHashMap.keySet().toArray()) {\n-                Integer i = (Integer)o;\n-                ks = hc.sslContext.keyHashMap.get(i);\n-                if (ks.isInvalid(sessionTimeout)) {\n-                    try {\n-                        ks.key.destroy();\n-                    } catch (Exception e) {\n-                        \/\/ Suppress\n-                    }\n-                    hc.sslContext.keyHashMap.remove(i);\n-                }\n-            }\n-        }\n-\n-        static int getSessionTimeout(HandshakeContext hc) {\n-            return hc.sslContext.engineGetServerSessionContext().\n-                    getSessionTimeout() * 1000;\n+            SSLSessionContextImpl serverCache =\n+                (SSLSessionContextImpl)hc.sslContext.engineGetServerSessionContext();\n+            return serverCache.getKey(hc);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SessionTicketExtension.java","additions":13,"deletions":70,"binary":false,"changes":83,"status":"modified"}]}