{"files":[{"patch":"@@ -2720,2 +2720,4 @@\n-void G1CollectedHeap::start_concurrent_cycle(bool is_mark_cycle) {\n-  _cm->post_concurrent_start(is_mark_cycle);\n+void G1CollectedHeap::start_concurrent_cycle(bool concurrent_operation_is_full_mark) {\n+  assert(!_cm_thread->in_progress(), \"Can not start concurrent operation while in progress\");\n+\n+  _cm->post_concurrent_start(concurrent_operation_is_full_mark);\n@@ -2724,3 +2726,4 @@\n-  if (!_cm_thread->in_progress()) {\n-    _cm_thread->set_started(is_mark_cycle);\n-    CGC_lock->notify();\n+  if (concurrent_operation_is_full_mark) {\n+    _cm_thread->start_full_mark();\n+  } else {\n+    _cm_thread->start_undo_mark();\n@@ -2728,0 +2731,1 @@\n+  CGC_lock->notify();\n@@ -2984,1 +2988,1 @@\n-  bool concurrent_operation_is_mark_cycle = false;\n+  bool concurrent_operation_is_full_mark = false;\n@@ -3061,6 +3065,0 @@\n-        \/\/ Refine the type of a concurrent mark operation now that we did the\n-        \/\/ evacuation, eventually aborting it.\n-        concurrent_operation_is_mark_cycle =\n-          should_start_concurrent_mark_operation &&\n-          ((gc_cause() != GCCause::_g1_humongous_allocation) || policy()->need_to_start_conc_mark(\"Revise\"));\n-\n@@ -3073,0 +3071,4 @@\n+        \/\/ Refine the type of a concurrent mark operation now that we did the\n+        \/\/ evacuation, eventually aborting it.\n+        concurrent_operation_is_full_mark = policy()->concurrent_operation_is_full_mark(\"Revise IHOP\");\n+\n@@ -3075,1 +3077,1 @@\n-        policy()->record_collection_pause_end(pause_time_ms, concurrent_operation_is_mark_cycle);\n+        policy()->record_collection_pause_end(pause_time_ms, concurrent_operation_is_full_mark);\n@@ -3117,1 +3119,1 @@\n-    \/\/ CAUTION: after the start_concurrent_mark() call below, the concurrent marking\n+    \/\/ CAUTION: after the start_concurrent_cycle() call below, the concurrent marking\n@@ -3122,1 +3124,1 @@\n-    start_concurrent_cycle(concurrent_operation_is_mark_cycle \/* full_mark *\/);\n+    start_concurrent_cycle(concurrent_operation_is_full_mark);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":17,"deletions":15,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -749,4 +749,2 @@\n-  \/\/ Start a concurrent cycle. If is_mark_cycle is true, do a\n-  \/\/ full mark cycle, otherwise only do concurrent mark undo\n-  \/\/ processing. That is, clear the bitmap only.\n-  void start_concurrent_cycle(bool is_mark_cycle);\n+  \/\/ Start a concurrent cycle.\n+  void start_concurrent_cycle(bool concurrent_operation_is_full_mark);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -610,1 +610,1 @@\n-        assert(_cm == NULL || _cm->cm_thread()->during_cycle(), \"invariant\");\n+        assert(_cm == NULL || _cm->cm_thread()->in_progress(), \"invariant\");\n@@ -659,1 +659,1 @@\n-  guarantee(cm_thread()->during_cycle(), \"invariant\");\n+  guarantee(cm_thread()->in_progress(), \"invariant\");\n@@ -670,1 +670,1 @@\n-  guarantee(cm_thread()->during_cycle(), \"invariant\");\n+  guarantee(cm_thread()->in_progress(), \"invariant\");\n@@ -703,2 +703,2 @@\n-void G1ConcurrentMark::post_concurrent_start(bool is_mark_cycle) {\n-  if (!is_mark_cycle) {\n+void G1ConcurrentMark::post_concurrent_start(bool concurrent_operation_is_full_mark) {\n+  if (!concurrent_operation_is_full_mark) {\n@@ -1965,1 +1965,1 @@\n-  if (!cm_thread()->during_cycle() || _has_aborted) {\n+  if (!cm_thread()->in_progress() || _has_aborted) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -548,1 +548,1 @@\n-  void post_concurrent_start(bool is_mark_cycle);\n+  void post_concurrent_start(bool concurrent_operation_is_full_mark);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,25 +59,0 @@\n-void G1ConcurrentMarkThread::set_idle() {\n-  assert(_state != StartMark && _state != StartUndo, \"must not be starting a new cycle\");\n-  _state = Idle;\n-}\n-\n-void G1ConcurrentMarkThread::set_started(bool mark_cycle) {\n-  assert(_state == Idle, \"cycle in progress\");\n-  _state = mark_cycle ? StartMark : StartUndo;\n-}\n-\n-void G1ConcurrentMarkThread::set_in_progress() {\n-  assert(_state == StartMark || _state == StartUndo, \"must be starting a cycle\");\n-  _state = InProgress;\n-}\n-\n-bool G1ConcurrentMarkThread::idle() const { return _state == Idle; }\n-\n-bool G1ConcurrentMarkThread::started() const {\n-  return _state == StartMark || _state == StartUndo;\n-}\n-\n-bool G1ConcurrentMarkThread::in_progress() const {\n-  return _state == InProgress;\n-}\n-\n@@ -163,2 +138,2 @@\n-  Command cmd;\n-  while ((cmd = wait_for_next_cycle()) != Terminate) {\n+  while (wait_for_next_cycle()) {\n+    assert(in_progress(), \"must be\");\n@@ -168,1 +143,1 @@\n-                                                   cmd == MarkCycle ? \"Mark\" : \"Undo\"));\n+                                                   _state == FullMark ? \"Mark\" : \"Undo\"));\n@@ -172,1 +147,1 @@\n-    if (cmd == MarkCycle) {\n+    if (_state == FullMark) {\n@@ -175,1 +150,1 @@\n-      assert(cmd == UndoCycle, \"Must be command to undo concurrent start but is %d\", cmd);\n+      assert(_state == UndoMark, \"Must do undo mark but is %d\", _state);\n@@ -179,1 +154,1 @@\n-    concurrent_cycle_end(cmd == MarkCycle && !_cm->has_aborted());\n+    concurrent_cycle_end(_state == FullMark && !_cm->has_aborted());\n@@ -191,1 +166,1 @@\n-G1ConcurrentMarkThread::Command G1ConcurrentMarkThread::wait_for_next_cycle() {\n+bool G1ConcurrentMarkThread::wait_for_next_cycle() {\n@@ -195,1 +170,1 @@\n-  while (!started() && !should_terminate()) {\n+  while (!in_progress() && !should_terminate()) {\n@@ -199,15 +174,1 @@\n-  Command result;\n-  if (should_terminate()) {\n-    result = Terminate;\n-  } else if (_state == StartMark) {\n-    result = MarkCycle;\n-  } else {\n-    assert(_state == StartUndo, \"must be\");\n-    result = UndoCycle;\n-  }\n-\n-  if (started()) {\n-    set_in_progress();\n-  }\n-\n-  return result;\n+  return !should_terminate();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkThread.cpp","additions":9,"deletions":48,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -45,3 +45,2 @@\n-    StartMark,\n-    StartUndo,\n-    InProgress\n+    FullMark,\n+    UndoMark\n@@ -52,5 +51,0 @@\n-  enum Command : uint {\n-    Terminate,  \/\/ Terminate the thread.\n-    MarkCycle,  \/\/ Start a (full) marking cycle\n-    UndoCycle   \/\/ Start an undo cycle, i.e. undo a concurrent mark start pause.\n-  };\n@@ -58,1 +52,1 @@\n-  Command wait_for_next_cycle();\n+  bool wait_for_next_cycle();\n@@ -107,1 +101,2 @@\n-  void set_started(bool mark_cycle);\n+  void start_full_mark();\n+  void start_undo_mark();\n@@ -111,3 +106,0 @@\n-  bool started() const;\n-  bool in_progress() const;\n-\n@@ -118,5 +110,2 @@\n-  \/\/ cleared). While during_cycle() is true we will not start another cycle\n-  \/\/ so that cycles do not overlap. We cannot use just in_progress()\n-  \/\/ as the CM thread might take some time to wake up before noticing\n-  \/\/ that started() is set and set in_progress().\n-  bool during_cycle() const { return !idle(); }\n+  \/\/ cleared).\n+  bool in_progress() const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkThread.hpp","additions":7,"deletions":18,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -41,0 +41,21 @@\n+inline void G1ConcurrentMarkThread::set_idle() {\n+  assert(_state == FullMark || _state == UndoMark, \"must not be starting a new cycle\");\n+  _state = Idle;\n+}\n+\n+inline void G1ConcurrentMarkThread::start_full_mark() {\n+  assert(_state == Idle, \"cycle in progress\");\n+  _state = FullMark;\n+}\n+\n+inline void G1ConcurrentMarkThread::start_undo_mark() {\n+  assert(_state == Idle, \"cycle in progress\");\n+  _state = UndoMark;\n+}\n+\n+inline bool G1ConcurrentMarkThread::idle() const { return _state == Idle; }\n+\n+inline bool G1ConcurrentMarkThread::in_progress() const {\n+  return !idle();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkThread.inline.hpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-void G1HeterogeneousHeapPolicy::record_collection_pause_end(double pause_time_ms, bool start_concurrent_mark_cycle) {\n-  G1Policy::record_collection_pause_end(pause_time_ms, start_concurrent_mark_cycle);\n+void G1HeterogeneousHeapPolicy::record_collection_pause_end(double pause_time_ms, bool concurrent_operation_is_full_mark) {\n+  G1Policy::record_collection_pause_end(pause_time_ms, concurrent_operation_is_full_mark);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeterogeneousHeapPolicy.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-  virtual void record_collection_pause_end(double pause_time_ms, bool start_concurrent_mark_cycle);\n+  virtual void record_collection_pause_end(double pause_time_ms, bool concurrent_operation_is_full_mark);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeterogeneousHeapPolicy.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -455,1 +455,1 @@\n-  collector_state()->set_initiate_conc_mark_if_possible(need_to_start_conc_mark(\"end of Full GC\", 0));\n+  collector_state()->set_initiate_conc_mark_if_possible(need_to_start_conc_mark(\"end of Full GC\"));\n@@ -594,1 +594,1 @@\n-  return _g1h->concurrent_mark()->cm_thread()->during_cycle() || collector_state()->in_young_gc_before_mixed();\n+  return _g1h->concurrent_mark()->cm_thread()->in_progress() || collector_state()->in_young_gc_before_mixed();\n@@ -615,1 +615,0 @@\n-\n@@ -619,0 +618,5 @@\n+bool G1Policy::concurrent_operation_is_full_mark(const char* msg) {\n+  return collector_state()->in_concurrent_start_gc() &&\n+    ((_g1h->gc_cause() != GCCause::_g1_humongous_allocation) || need_to_start_conc_mark(msg));\n+}\n+\n@@ -634,1 +638,1 @@\n-void G1Policy::record_collection_pause_end(double pause_time_ms, bool start_concurrent_mark_cycle) {\n+void G1Policy::record_collection_pause_end(double pause_time_ms, bool concurrent_operation_is_full_mark) {\n@@ -784,1 +788,1 @@\n-    if (!start_concurrent_mark_cycle) {\n+    if (!concurrent_operation_is_full_mark) {\n@@ -787,1 +791,1 @@\n-    collector_state()->set_mark_or_rebuild_in_progress(start_concurrent_mark_cycle);\n+    collector_state()->set_mark_or_rebuild_in_progress(concurrent_operation_is_full_mark);\n@@ -1031,1 +1035,1 @@\n-  bool during_cycle = _g1h->concurrent_mark()->cm_thread()->during_cycle();\n+  bool during_cycle = _g1h->concurrent_mark()->cm_thread()->in_progress();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -322,0 +322,2 @@\n+  bool concurrent_operation_is_full_mark(const char* msg = NULL);\n+\n@@ -326,1 +328,1 @@\n-  virtual void record_collection_pause_end(double pause_time_ms, bool start_concurrent_mark_cycle);\n+  virtual void record_collection_pause_end(double pause_time_ms, bool concurrent_operation_is_full_mark);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-  if (g1h->concurrent_mark()->cm_thread()->during_cycle()) {\n+  if (g1h->concurrent_mark()->cm_thread()->in_progress()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ServiceThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-#include \"gc\/g1\/g1ConcurrentMarkThread.hpp\"\n+#include \"gc\/g1\/g1ConcurrentMarkThread.inline.hpp\"\n@@ -475,1 +475,1 @@\n-    return g1h->concurrent_mark()->cm_thread()->during_cycle();\n+    return g1h->concurrent_mark()->cm_thread()->in_progress();\n@@ -483,1 +483,1 @@\n-    if (!g1h->concurrent_mark()->cm_thread()->during_cycle()) {\n+    if (!g1h->concurrent_mark()->cm_thread()->in_progress()) {\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}