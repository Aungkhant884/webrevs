{"files":[{"patch":"@@ -853,1 +853,1 @@\n-                                           word_size)) {\n+                                        word_size)) {\n@@ -2719,1 +2719,3 @@\n-void G1CollectedHeap::do_concurrent_mark() {\n+void G1CollectedHeap::start_concurrent_cycle(bool is_mark_cycle) {\n+  _cm->post_concurrent_start(is_mark_cycle);\n+\n@@ -2722,1 +2724,1 @@\n-    _cm_thread->set_started();\n+    _cm_thread->set_started(is_mark_cycle);\n@@ -2977,7 +2979,5 @@\n-  \/\/ Record whether this pause is a concurrent start. When the current\n-  \/\/ thread has completed its logging output and it's safe to signal\n-  \/\/ the CM thread, the flag's value in the policy has been reset.\n-  bool should_start_conc_mark = collector_state()->in_concurrent_start_gc();\n-  if (should_start_conc_mark) {\n-    _cm->gc_tracer_cm()->set_gc_cause(gc_cause());\n-  }\n+  \/\/ Record whether this pause may need to trigger a concurrent operation. Later,\n+  \/\/ when we signal the G1ConcurrentMarkThread, the collector state has already\n+  \/\/ been reset for the next pause.\n+  bool should_start_concurrent_mark_operation = collector_state()->in_concurrent_start_gc();\n+  bool concurrent_operation_is_mark_cycle = false;\n@@ -3060,9 +3060,5 @@\n-        if (should_start_conc_mark) {\n-          \/\/ We have to do this before we notify the CM threads that\n-          \/\/ they can start working to make sure that all the\n-          \/\/ appropriate initialization is done on the CM object.\n-          concurrent_mark()->post_concurrent_start();\n-          \/\/ Note that we don't actually trigger the CM thread at\n-          \/\/ this point. We do that later when we're sure that\n-          \/\/ the current thread has completed its logging output.\n-        }\n+        \/\/ Refine the type of a concurrent mark operation now that we did the\n+        \/\/ evacuation, eventually aborting it.\n+        concurrent_operation_is_mark_cycle =\n+          should_start_concurrent_mark_operation &&\n+          ((gc_cause() != GCCause::_g1_humongous_allocation) || policy()->need_to_start_conc_mark(\"Revise\"));\n@@ -3078,1 +3074,1 @@\n-        policy()->record_collection_pause_end(pause_time_ms);\n+        policy()->record_collection_pause_end(pause_time_ms, concurrent_operation_is_mark_cycle);\n@@ -3119,2 +3115,2 @@\n-  if (should_start_conc_mark) {\n-    \/\/ CAUTION: after the doConcurrentMark() call below, the concurrent marking\n+  if (should_start_concurrent_mark_operation) {\n+    \/\/ CAUTION: after the start_concurrent_mark() call below, the concurrent marking\n@@ -3125,1 +3121,1 @@\n-    do_concurrent_mark();\n+    start_concurrent_cycle(concurrent_operation_is_mark_cycle \/* full_mark *\/);\n@@ -3735,1 +3731,1 @@\n-    concurrent_mark()->pre_concurrent_start();\n+    concurrent_mark()->pre_concurrent_start(gc_cause());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":20,"deletions":24,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -749,0 +749,5 @@\n+  \/\/ Start a concurrent cycle. If is_mark_cycle is true, do a\n+  \/\/ full mark cycle, otherwise only do concurrent mark undo\n+  \/\/ processing. That is, clear the bitmap only.\n+  void start_concurrent_cycle(bool is_mark_cycle);\n+\n@@ -1309,10 +1314,0 @@\n-  \/\/ *** Stuff related to concurrent marking.  It's not clear to me that so\n-  \/\/ many of these need to be public.\n-\n-  \/\/ The functions below are helper functions that a subclass of\n-  \/\/ \"CollectedHeap\" can use in the implementation of its virtual\n-  \/\/ functions.\n-  \/\/ This performs a concurrent marking of the live objects in a\n-  \/\/ bitmap off to the side.\n-  void do_concurrent_mark();\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -686,1 +686,1 @@\n-void G1ConcurrentMark::pre_concurrent_start() {\n+void G1ConcurrentMark::pre_concurrent_start(GCCause::Cause cause) {\n@@ -697,0 +697,2 @@\n+\n+  _gc_tracer_cm->set_gc_cause(cause);\n@@ -700,1 +702,5 @@\n-void G1ConcurrentMark::post_concurrent_start() {\n+void G1ConcurrentMark::post_concurrent_start(bool is_mark_cycle) {\n+  if (!is_mark_cycle) {\n+    root_regions()->cancel_scan();\n+    return;\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/shared\/gcCause.hpp\"\n@@ -39,0 +40,1 @@\n+#include \"utilities\/numberSeq.hpp\"\n@@ -308,1 +310,1 @@\n-  G1CMRootMemRegions         _root_regions;\n+  G1CMRootMemRegions      _root_regions;\n@@ -545,2 +547,2 @@\n-  void pre_concurrent_start();\n-  void post_concurrent_start();\n+  void pre_concurrent_start(GCCause::Cause cause);\n+  void post_concurrent_start(bool is_mark_cycle);\n@@ -597,1 +599,0 @@\n-  G1OldTracer* gc_tracer_cm() const { return _gc_tracer_cm; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -58,0 +59,25 @@\n+void G1ConcurrentMarkThread::set_idle() {\n+  assert(_state != StartMark && _state != StartUndo, \"must not be starting a new cycle\");\n+  _state = Idle;\n+}\n+\n+void G1ConcurrentMarkThread::set_started(bool mark_cycle) {\n+  assert(_state == Idle, \"cycle in progress\");\n+  _state = mark_cycle ? StartMark : StartUndo;\n+}\n+\n+void G1ConcurrentMarkThread::set_in_progress() {\n+  assert(_state == StartMark || _state == StartUndo, \"must be starting a cycle\");\n+  _state = InProgress;\n+}\n+\n+bool G1ConcurrentMarkThread::idle() const { return _state == Idle; }\n+\n+bool G1ConcurrentMarkThread::started() const {\n+  return _state == StartMark || _state == StartUndo;\n+}\n+\n+bool G1ConcurrentMarkThread::in_progress() const {\n+  return _state == InProgress;\n+}\n+\n@@ -137,1 +163,2 @@\n-  while (wait_for_next_cycle()) {\n+  Command cmd;\n+  while ((cmd = wait_for_next_cycle()) != Terminate) {\n@@ -140,1 +167,2 @@\n-    GCTraceConcTime(Info, gc) tt(\"Concurrent Cycle\");\n+    GCTraceConcTime(Info, gc) tt(FormatBuffer<128>(\"Concurrent %s Cycle\",\n+                                                   cmd == MarkCycle ? \"Mark\" : \"Undo\"));\n@@ -143,2 +171,9 @@\n-    full_concurrent_cycle_do();\n-    concurrent_cycle_end();\n+\n+    if (cmd == MarkCycle) {\n+      concurrent_mark_cycle_do();\n+    } else {\n+      assert(cmd == UndoCycle, \"Must be command to undo concurrent start but is %d\", cmd);\n+      concurrent_undo_cycle_do();\n+    }\n+\n+    concurrent_cycle_end(cmd == MarkCycle && !_cm->has_aborted());\n@@ -156,1 +191,1 @@\n-bool G1ConcurrentMarkThread::wait_for_next_cycle() {\n+G1ConcurrentMarkThread::Command G1ConcurrentMarkThread::wait_for_next_cycle() {\n@@ -164,0 +199,10 @@\n+  Command result;\n+  if (should_terminate()) {\n+    result = Terminate;\n+  } else if (_state == StartMark) {\n+    result = MarkCycle;\n+  } else {\n+    assert(_state == StartUndo, \"must be\");\n+    result = UndoCycle;\n+  }\n+\n@@ -168,1 +213,1 @@\n-  return !should_terminate();\n+  return result;\n@@ -272,1 +317,1 @@\n-void G1ConcurrentMarkThread::full_concurrent_cycle_do() {\n+void G1ConcurrentMarkThread::concurrent_mark_cycle_do() {\n@@ -312,1 +357,13 @@\n-void G1ConcurrentMarkThread::concurrent_cycle_end() {\n+void G1ConcurrentMarkThread::concurrent_undo_cycle_do() {\n+  HandleMark hm(Thread::current());\n+  ResourceMark rm;\n+\n+  \/\/ We can (and should) abort if there has been a concurrent cycle abort for\n+  \/\/ some reason.\n+  if (_cm->has_aborted()) { return; }\n+\n+  \/\/ Phase 1: Clear bitmap for next mark.\n+  phase_clear_bitmap_for_next_mark();\n+}\n+\n+void G1ConcurrentMarkThread::concurrent_cycle_end(bool mark_cycle_completed) {\n@@ -319,1 +376,1 @@\n-                                                                  !_cm->has_aborted());\n+                                                                  mark_cycle_completed \/* heap_examined *\/);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkThread.cpp","additions":66,"deletions":9,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-  enum ServiceState {\n+  enum ServiceState : uint {\n@@ -45,1 +45,2 @@\n-    Started,\n+    StartMark,\n+    StartUndo,\n@@ -51,2 +52,7 @@\n-  \/\/ Wait for next cycle. Returns false if the service should be stopped.\n-  bool wait_for_next_cycle();\n+  enum Command : uint {\n+    Terminate,  \/\/ Terminate the thread.\n+    MarkCycle,  \/\/ Start a (full) marking cycle\n+    UndoCycle   \/\/ Start an undo cycle, i.e. undo a concurrent mark start pause.\n+  };\n+  \/\/ Wait for next cycle. Returns the command passed over.\n+  Command wait_for_next_cycle();\n@@ -77,2 +83,4 @@\n-  void full_concurrent_cycle_do();\n-  void concurrent_cycle_end();\n+  void concurrent_mark_cycle_do();\n+  void concurrent_undo_cycle_do();\n+\n+  void concurrent_cycle_end(bool mark_cycle_completed);\n@@ -96,1 +104,5 @@\n-  G1ConcurrentMark* cm()   { return _cm; }\n+  G1ConcurrentMark* cm() { return _cm; }\n+\n+  void set_idle();\n+  void set_started(bool mark_cycle);\n+  void set_in_progress();\n@@ -98,6 +110,3 @@\n-  void set_idle()          { assert(_state != Started, \"must not be starting a new cycle\"); _state = Idle; }\n-  bool idle()              { return _state == Idle; }\n-  void set_started()       { assert(_state == Idle, \"cycle in progress\"); _state = Started; }\n-  bool started()           { return _state == Started; }\n-  void set_in_progress()   { assert(_state == Started, \"must be starting a cycle\"); _state = InProgress; }\n-  bool in_progress()       { return _state == InProgress; }\n+  bool idle() const;\n+  bool started() const;\n+  bool in_progress() const;\n@@ -105,1 +114,1 @@\n-  \/\/ Returns true from the moment a marking cycle is\n+  \/\/ Returns true from the moment a concurrent cycle is\n@@ -113,1 +122,1 @@\n-  bool during_cycle()      { return !idle(); }\n+  bool during_cycle() const { return !idle(); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkThread.hpp","additions":24,"deletions":15,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-void G1HeterogeneousHeapPolicy::record_collection_pause_end(double pause_time_ms) {\n-  G1Policy::record_collection_pause_end(pause_time_ms);\n+void G1HeterogeneousHeapPolicy::record_collection_pause_end(double pause_time_ms, bool start_concurrent_mark_cycle) {\n+  G1Policy::record_collection_pause_end(pause_time_ms, start_concurrent_mark_cycle);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeterogeneousHeapPolicy.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-  virtual void record_collection_pause_end(double pause_time_ms);\n+  virtual void record_collection_pause_end(double pause_time_ms, bool start_concurrent_mark_cycle);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeterogeneousHeapPolicy.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -667,1 +667,1 @@\n-void G1Policy::record_concurrent_mark_init_end(double mark_init_elapsed_time_ms) {\n+void G1Policy::record_concurrent_mark_init_end() {\n@@ -752,1 +752,1 @@\n-void G1Policy::record_collection_pause_end(double pause_time_ms) {\n+void G1Policy::record_collection_pause_end(double pause_time_ms, bool start_concurrent_mark_cycle) {\n@@ -764,1 +764,1 @@\n-    record_concurrent_mark_init_end(0.0);\n+    record_concurrent_mark_init_end();\n@@ -904,1 +904,4 @@\n-    collector_state()->set_mark_or_rebuild_in_progress(true);\n+    if (!start_concurrent_mark_cycle) {\n+      abort_time_to_mixed_tracking();\n+    }\n+    collector_state()->set_mark_or_rebuild_in_progress(start_concurrent_mark_cycle);\n@@ -928,1 +931,1 @@\n-    _concurrent_start_to_mixed.reset();\n+    abort_time_to_mixed_tracking();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -324,1 +324,1 @@\n-  virtual void record_collection_pause_end(double pause_time_ms);\n+  virtual void record_collection_pause_end(double pause_time_ms, bool start_concurrent_mark_cycle);\n@@ -331,1 +331,1 @@\n-  void record_concurrent_mark_init_end(double mark_init_elapsed_time_ms);\n+  void record_concurrent_mark_init_end();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.g1;\n+\n+\/*\n+ * @test TestHumongousConcurrentStartUndo\n+ * @summary Tests an alternating sequence of Concurrent Mark and Concurrent Undo\n+ * cycles.\n+ * reclaim heap occupancy falls below the IHOP value.\n+ * @requires vm.gc.G1\n+ * @library \/test\/lib \/testlibrary \/\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ *             sun.hotspot.WhiteBox$WhiteBoxPermission\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                   gc.g1.TestHumongousConcurrentStartUndo\n+ *\/\n+\n+import gc.testlibrary.Helpers;\n+\n+import sun.hotspot.WhiteBox;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.util.Queue;\n+import java.util.concurrent.ArrayBlockingQueue;\n+\n+public class TestHumongousConcurrentStartUndo {\n+    \/\/ Heap sizes < 224 MB are increased to 224 MB if vm_page_size == 64K to\n+    \/\/ fulfill alignment constraints.\n+    private static final int HeapSize                       = 224; \/\/ MB\n+    private static final int HeapRegionSize                 = 1;   \/\/ MB\n+    private static final int InitiatingHeapOccupancyPercent = 50;  \/\/ %\n+    private static final int YoungSize                      = HeapSize \/ 8;\n+\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+            \"-Xbootclasspath\/a:.\",\n+            \"-XX:+UseG1GC\",\n+            \"-Xms\" + HeapSize + \"m\",\n+            \"-Xmx\" + HeapSize + \"m\",\n+            \"-Xmn\" + YoungSize + \"m\",\n+            \"-XX:G1HeapRegionSize=\" + HeapRegionSize + \"m\",\n+            \"-XX:InitiatingHeapOccupancyPercent=\" + InitiatingHeapOccupancyPercent,\n+            \"-XX:-G1UseAdaptiveIHOP\",\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-XX:+WhiteBoxAPI\",\n+            \"-Xlog:gc*\",\n+            EdenObjectAllocatorWithHumongousAllocation.class.getName());\n+\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldContain(\"Pause Young (Concurrent Start) (G1 Humongous Allocation)\");\n+        output.shouldContain(\"Concurrent Undo Cycle\");\n+        output.shouldContain(\"Concurrent Mark Cycle\");\n+        output.shouldHaveExitValue(0);\n+        System.out.println(output.getStdout());\n+    }\n+\n+    static class EdenObjectAllocatorWithHumongousAllocation {\n+        private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n+        private static void allocateHumongous(int num, int objSize, Queue keeper) {\n+            for (int i = 1; i <= num; i++) {\n+                if (i % 10 == 0) {\n+                    System.out.println(\"Allocating humongous object \" + i + \"\/\" + num +\n+                                       \" of size \" + objSize + \" bytes\");\n+                }\n+                byte[] e = new byte[objSize];\n+                if (!keeper.offer(e)) {\n+                    keeper.remove();\n+                    keeper.offer(e);\n+                }\n+            }\n+        }\n+\n+        public static void main(String [] args) throws Exception {\n+            final int M = 1024 * 1024;\n+            \/\/ Make humongous object size 75% of region size\n+            final int humongousObjectSize =\n+                (int)(HeapRegionSize * M * 0.75);\n+\n+            \/\/ Number of objects to allocate to go above IHOP\n+            final int humongousObjectAllocations =\n+                (int)(((HeapSize - YoungSize) * 80 \/ 100.0) \/ HeapRegionSize);\n+\n+            ArrayBlockingQueue a;\n+            for (int iterate = 0; iterate < 3; iterate++) {\n+                WHITE_BOX.fullGC();\n+\n+                a = new ArrayBlockingQueue(1);\n+                allocateHumongous(humongousObjectAllocations, humongousObjectSize, a);\n+                Helpers.waitTillCMCFinished(WHITE_BOX, 1);\n+                a = null;\n+\n+                a = new ArrayBlockingQueue(humongousObjectAllocations);\n+                allocateHumongous(humongousObjectAllocations, humongousObjectSize, a);\n+                Helpers.waitTillCMCFinished(WHITE_BOX, 1);\n+                a = null;\n+\n+                allocateHumongous(1, humongousObjectSize, new ArrayBlockingQueue(1));\n+                Helpers.waitTillCMCFinished(WHITE_BOX, 1);\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestHumongousConcurrentStartUndo.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jfr.event.gc.detailed;\n-\n-\/**\n- * @test\n- * @key randomness\n- * @summary Test allocates humongous objects with G1 GC. Objects\n- * considered humongous when it allocates equals or more than one region. As\n- * we're passing the size of byte array we need adjust it that entire structure\n- * fits exactly to one region, if not - G1 will allocate another almost empty\n- * region as a continue of humongous. Thus we will exhaust memory very fast and\n- * test will fail with OOME.\n- * @requires vm.hasJFR\n- * @requires vm.gc == \"null\" | vm.gc == \"G1\"\n- * @library \/test\/lib \/test\/jdk\n- * @run main\/othervm -XX:+UseG1GC -XX:MaxNewSize=5m -Xmx256m -XX:G1HeapRegionSize=1048576 jdk.jfr.event.gc.detailed.TestStressBigAllocationGCEventsWithG1 1048544\n- *\/\n-public class TestStressBigAllocationGCEventsWithG1 {\n-\n-    public static void main(String[] args) throws Exception {\n-        new StressAllocationGCEvents().run(args);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/jfr\/TestStressBigAllocationGCEventsWithG1.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"}]}