{"files":[{"patch":"@@ -29,1 +29,2 @@\n-#include \"ci\/ciUtilities.hpp\"\n+#include \"ci\/ciUtilities.inline.hpp\"\n+#include \"memory\/universe.hpp\"\n@@ -106,0 +107,1 @@\n+\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+  _transitive_interfaces = NULL;\n@@ -732,0 +733,25 @@\n+GrowableArray<ciInstanceKlass*>* ciInstanceKlass::transitive_interfaces() const{\n+  if (_transitive_interfaces == NULL) {\n+    const_cast<ciInstanceKlass*>(this)->compute_transitive_interfaces();\n+  }\n+  return _transitive_interfaces;\n+}\n+\n+void ciInstanceKlass::compute_transitive_interfaces() {\n+  GUARDED_VM_ENTRY(\n+          InstanceKlass* ik = get_instanceKlass();\n+          Array<InstanceKlass*>* interfaces = ik->transitive_interfaces();\n+          Arena* arena = CURRENT_ENV->arena();\n+          int len = interfaces->length() + (is_interface() ? 1 : 0);\n+          GrowableArray<ciInstanceKlass*>* transitive_interfaces = new(arena)GrowableArray<ciInstanceKlass*>(arena, len,\n+                                                                                                             0, NULL);\n+          for (int i = 0; i < interfaces->length(); i++) {\n+            transitive_interfaces->append(CURRENT_ENV->get_instance_klass(interfaces->at(i)));\n+          }\n+          if (is_interface()) {\n+            transitive_interfaces->append(this);\n+          }\n+          _transitive_interfaces = transitive_interfaces;\n+  );\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+  GrowableArray<ciInstanceKlass*>* _transitive_interfaces;\n@@ -82,0 +83,1 @@\n+  void compute_transitive_interfaces();\n@@ -295,0 +297,1 @@\n+  GrowableArray<ciInstanceKlass*>* transitive_interfaces() const;\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -170,0 +170,1 @@\n+        obj->as_instance_klass()->transitive_interfaces();\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -310,0 +310,3 @@\n+    Node* hook = new Node(1);\n+    hook->init_req(0, dest_offset);\n+\n@@ -311,0 +314,3 @@\n+\n+    hook->destruct(phase);\n+\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -374,24 +374,0 @@\n-\/\/=============================================================================\n-\/\/------------------------------Identity---------------------------------------\n-\/\/ If input is already higher or equal to cast type, then this is an identity.\n-Node* CheckCastPPNode::Identity(PhaseGVN* phase) {\n-  Node* dom = dominating_cast(phase, phase);\n-  if (dom != NULL) {\n-    return dom;\n-  }\n-  if (_dependency != RegularDependency) {\n-    return this;\n-  }\n-  const Type* t = phase->type(in(1));\n-  if (EnableVectorReboxing && in(1)->Opcode() == Op_VectorBox) {\n-    if (t->higher_equal_speculative(phase->type(this))) {\n-      return in(1);\n-    }\n-  } else if (t == phase->type(this)) {\n-    \/\/ Toned down to rescue meeting at a Phi 3 different oops all implementing\n-    \/\/ the same interface.\n-    return in(1);\n-  }\n-  return this;\n-}\n-\n@@ -406,2 +382,6 @@\n-  const TypePtr *in_type   = inn->isa_ptr();\n-  const TypePtr *my_type   = _type->isa_ptr();\n+  if (inn->isa_oopptr() && _type->isa_oopptr()) {\n+    return ConstraintCastNode::Value(phase);\n+  }\n+\n+  const TypePtr *in_type = inn->isa_ptr();\n+  const TypePtr *my_type = _type->isa_ptr();\n@@ -409,2 +389,2 @@\n-  if( in_type != NULL && my_type != NULL ) {\n-    TypePtr::PTR   in_ptr    = in_type->ptr();\n+  if (in_type != NULL && my_type != NULL) {\n+    TypePtr::PTR in_ptr = in_type->ptr();\n@@ -413,12 +393,2 @@\n-    } else if (in_ptr == TypePtr::Constant) {\n-      if (my_type->isa_rawptr()) {\n-        result = my_type;\n-      } else {\n-        const TypeOopPtr *jptr = my_type->isa_oopptr();\n-        assert(jptr, \"\");\n-        result = !in_type->higher_equal(_type)\n-          ? my_type->cast_to_ptr_type(TypePtr::NotNull)\n-          : in_type;\n-      }\n-    } else {\n-      result =  my_type->cast_to_ptr_type( my_type->join_ptr(in_ptr) );\n+    } else if (in_ptr != TypePtr::Constant) {\n+      result =  my_type->cast_to_ptr_type(my_type->join_ptr(in_ptr));\n@@ -428,55 +398,1 @@\n-  \/\/ This is the code from TypePtr::xmeet() that prevents us from\n-  \/\/ having 2 ways to represent the same type. We have to replicate it\n-  \/\/ here because we don't go through meet\/join.\n-  if (result->remove_speculative() == result->speculative()) {\n-    result = result->remove_speculative();\n-  }\n-\n-  \/\/ Same as above: because we don't go through meet\/join, remove the\n-  \/\/ speculative type if we know we won't use it.\n-  return result->cleanup_speculative();\n-\n-  \/\/ JOIN NOT DONE HERE BECAUSE OF INTERFACE ISSUES.\n-  \/\/ FIX THIS (DO THE JOIN) WHEN UNION TYPES APPEAR!\n-\n-  \/\/\n-  \/\/ Remove this code after overnight run indicates no performance\n-  \/\/ loss from not performing JOIN at CheckCastPPNode\n-  \/\/\n-  \/\/ const TypeInstPtr *in_oop = in->isa_instptr();\n-  \/\/ const TypeInstPtr *my_oop = _type->isa_instptr();\n-  \/\/ \/\/ If either input is an 'interface', return destination type\n-  \/\/ assert (in_oop == NULL || in_oop->klass() != NULL, \"\");\n-  \/\/ assert (my_oop == NULL || my_oop->klass() != NULL, \"\");\n-  \/\/ if( (in_oop && in_oop->klass()->is_interface())\n-  \/\/   ||(my_oop && my_oop->klass()->is_interface()) ) {\n-  \/\/   TypePtr::PTR  in_ptr = in->isa_ptr() ? in->is_ptr()->_ptr : TypePtr::BotPTR;\n-  \/\/   \/\/ Preserve cast away nullness for interfaces\n-  \/\/   if( in_ptr == TypePtr::NotNull && my_oop && my_oop->_ptr == TypePtr::BotPTR ) {\n-  \/\/     return my_oop->cast_to_ptr_type(TypePtr::NotNull);\n-  \/\/   }\n-  \/\/   return _type;\n-  \/\/ }\n-  \/\/\n-  \/\/ \/\/ Neither the input nor the destination type is an interface,\n-  \/\/\n-  \/\/ \/\/ history: JOIN used to cause weird corner case bugs\n-  \/\/ \/\/          return (in == TypeOopPtr::NULL_PTR) ? in : _type;\n-  \/\/ \/\/ JOIN picks up NotNull in common instance-of\/check-cast idioms, both oops.\n-  \/\/ \/\/ JOIN does not preserve NotNull in other cases, e.g. RawPtr vs InstPtr\n-  \/\/ const Type *join = in->join(_type);\n-  \/\/ \/\/ Check if join preserved NotNull'ness for pointers\n-  \/\/ if( join->isa_ptr() && _type->isa_ptr() ) {\n-  \/\/   TypePtr::PTR join_ptr = join->is_ptr()->_ptr;\n-  \/\/   TypePtr::PTR type_ptr = _type->is_ptr()->_ptr;\n-  \/\/   \/\/ If there isn't any NotNull'ness to preserve\n-  \/\/   \/\/ OR if join preserved NotNull'ness then return it\n-  \/\/   if( type_ptr == TypePtr::BotPTR  || type_ptr == TypePtr::Null ||\n-  \/\/       join_ptr == TypePtr::NotNull || join_ptr == TypePtr::Constant ) {\n-  \/\/     return join;\n-  \/\/   }\n-  \/\/   \/\/ ELSE return same old type as before\n-  \/\/   return _type;\n-  \/\/ }\n-  \/\/ \/\/ Not joining two pointers\n-  \/\/ return join;\n+  return result;\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":11,"deletions":95,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -182,1 +182,0 @@\n-  virtual Node* Identity(PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1184,16 +1184,0 @@\n-  \/\/ Until we have harmony between classes and interfaces in the type\n-  \/\/ lattice, we must tread carefully around phis which implicitly\n-  \/\/ convert the one to the other.\n-  const TypePtr* ttp = _type->make_ptr();\n-  const TypeInstPtr* ttip = (ttp != NULL) ? ttp->isa_instptr() : NULL;\n-  const TypeInstKlassPtr* ttkp = (ttp != NULL) ? ttp->isa_instklassptr() : NULL;\n-  bool is_intf = false;\n-  if (ttip != NULL) {\n-    if (ttip->is_interface())\n-      is_intf = true;\n-  }\n-  if (ttkp != NULL) {\n-    if (ttkp->is_interface())\n-      is_intf = true;\n-  }\n-\n@@ -1206,14 +1190,0 @@\n-      \/\/ We assume that each input of an interface-valued Phi is a true\n-      \/\/ subtype of that interface.  This might not be true of the meet\n-      \/\/ of all the input types.  The lattice is not distributive in\n-      \/\/ such cases.  Ward off asserts in type.cpp by refusing to do\n-      \/\/ meets between interfaces and proper classes.\n-      const TypePtr* tip = ti->make_ptr();\n-      const TypeInstPtr* tiip = (tip != NULL) ? tip->isa_instptr() : NULL;\n-      if (tiip) {\n-        bool ti_is_intf = false;\n-        if (tiip->is_interface())\n-          ti_is_intf = true;\n-        if (is_intf != ti_is_intf)\n-          { t = _type; break; }\n-      }\n@@ -1243,25 +1213,3 @@\n-\n-    \/\/ Check for evil case of 't' being a class and '_type' expecting an\n-    \/\/ interface.  This can happen because the bytecodes do not contain\n-    \/\/ enough type info to distinguish a Java-level interface variable\n-    \/\/ from a Java-level object variable.  If we meet 2 classes which\n-    \/\/ both implement interface I, but their meet is at 'j\/l\/O' which\n-    \/\/ doesn't implement I, we have no way to tell if the result should\n-    \/\/ be 'I' or 'j\/l\/O'.  Thus we'll pick 'j\/l\/O'.  If this then flows\n-    \/\/ into a Phi which \"knows\" it's an Interface type we'll have to\n-    \/\/ uplift the type.\n-    if (!t->empty() && ttip && ttip->is_interface()) {\n-      assert(ft == _type, \"\"); \/\/ Uplift to interface\n-    } else if (!t->empty() && ttkp && ttkp->is_interface()) {\n-      assert(ft == _type, \"\"); \/\/ Uplift to interface\n-    } else {\n-      \/\/ We also have to handle 'evil cases' of interface- vs. class-arrays\n-      Type::get_arrays_base_elements(jt, _type, NULL, &ttip);\n-      if (!t->empty() && ttip != NULL && ttip->is_interface()) {\n-          assert(ft == _type, \"\");   \/\/ Uplift to array of interface\n-      } else {\n-        \/\/ Otherwise it's something stupid like non-overlapping int ranges\n-        \/\/ found on dying counted loops.\n-        assert(ft == Type::TOP, \"\"); \/\/ Canonical empty value\n-      }\n-    }\n+    \/\/ Otherwise it's something stupid like non-overlapping int ranges\n+    \/\/ found on dying counted loops.\n+    assert(ft == Type::TOP, \"\"); \/\/ Canonical empty value\n@@ -1272,25 +1220,0 @@\n-    \/\/ If we have an interface-typed Phi and we narrow to a class type, the join\n-    \/\/ should report back the class.  However, if we have a J\/L\/Object\n-    \/\/ class-typed Phi and an interface flows in, it's possible that the meet &\n-    \/\/ join report an interface back out.  This isn't possible but happens\n-    \/\/ because the type system doesn't interact well with interfaces.\n-    const TypePtr *jtp = jt->make_ptr();\n-    const TypeInstPtr *jtip = (jtp != NULL) ? jtp->isa_instptr() : NULL;\n-    const TypeInstKlassPtr *jtkp = (jtp != NULL) ? jtp->isa_instklassptr() : NULL;\n-    if (jtip && ttip) {\n-      if (jtip->is_interface() &&\n-          !ttip->is_interface()) {\n-        assert(ft == ttip->cast_to_ptr_type(jtip->ptr()) ||\n-               ft->isa_narrowoop() && ft->make_ptr() == ttip->cast_to_ptr_type(jtip->ptr()), \"\");\n-        jt = ft;\n-      }\n-    }\n-    if (jtkp && ttkp) {\n-      if (jtkp->is_interface() &&\n-          !jtkp->klass_is_exact() && \/\/ Keep exact interface klass (6894807)\n-          ttkp->is_loaded() && !ttkp->is_interface()) {\n-        assert(ft == ttkp->cast_to_ptr_type(jtkp->ptr()) ||\n-               ft->isa_narrowklass() && ft->make_ptr() == ttkp->cast_to_ptr_type(jtkp->ptr()), \"\");\n-        jt = ft;\n-      }\n-    }\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":3,"deletions":80,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -4363,2 +4363,2 @@\n-Compile::SubTypeCheckResult Compile::static_subtype_check(const TypeKlassPtr* superk, const TypeKlassPtr* subk) {\n-  if (StressReflectiveCode) {\n+Compile::SubTypeCheckResult Compile::static_subtype_check(const TypeKlassPtr* superk, const TypeKlassPtr* subk, bool skip) {\n+  if (skip) {\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1181,1 +1181,1 @@\n-  SubTypeCheckResult static_subtype_check(const TypeKlassPtr* superk, const TypeKlassPtr* subk);\n+  SubTypeCheckResult static_subtype_check(const TypeKlassPtr* superk, const TypeKlassPtr* subk, bool skip = StressReflectiveCode);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -600,1 +600,1 @@\n-    Node* cls_node = makecon(TypeKlassPtr::make(receiver_constraint));\n+    Node* cls_node = makecon(TypeKlassPtr::make(receiver_constraint, Type::trust_interfaces));\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2185,1 +2185,1 @@\n-    const TypeKlassPtr* tklass = TypeKlassPtr::make(exact_kls);\n+    const TypeKlassPtr* tklass = TypeKlassPtr::make(exact_kls, Type::trust_interfaces);\n@@ -2639,1 +2639,1 @@\n-  gvn.transform(cmp);\n+  cmp = gvn.transform(cmp);\n@@ -2847,1 +2847,1 @@\n-  const TypeKlassPtr* tklass = TypeKlassPtr::make(klass);\n+  const TypeKlassPtr* tklass = TypeKlassPtr::make(klass, Type::trust_interfaces);\n@@ -2876,1 +2876,1 @@\n-  const TypeKlassPtr* tklass = TypeKlassPtr::make(klass);\n+  const TypeKlassPtr* tklass = TypeKlassPtr::make(klass, Type::trust_interfaces)->try_improve();\n@@ -2999,1 +2999,1 @@\n-        C->static_subtype_check(require_klass, TypeKlassPtr::make(exact_kls)) == Compile::SSC_always_true) {\n+        C->static_subtype_check(require_klass, TypeKlassPtr::make(exact_kls, Type::trust_interfaces)) == Compile::SSC_always_true) {\n@@ -3185,2 +3185,2 @@\n-  const TypeKlassPtr *tk = _gvn.type(superklass)->is_klassptr();\n-  const Type *toop = tk->cast_to_exactness(false)->as_instance_type();\n+  const TypeKlassPtr *tk = _gvn.type(superklass)->is_klassptr()->try_improve();\n+  const TypeOopPtr *toop = tk->cast_to_exactness(false)->as_instance_type();\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -503,3 +503,1 @@\n-      if ((toop != NULL && toop->is_interface()) || (tkls != NULL && tkls->is_interface())) {\n-        s2.print(\"  Interface:\");\n-      } else if (toop) {\n+      if (toop) {\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3670,1 +3670,1 @@\n-      int static_res = C->static_subtype_check(TypeKlassPtr::make(tm->as_klass()), tp->as_klass_type());\n+      int static_res = C->static_subtype_check(TypeKlassPtr::make(tm->as_klass(), Type::trust_interfaces), tp->as_klass_type());\n@@ -7238,1 +7238,1 @@\n-  const TypeOopPtr* xtype = aklass->as_instance_type()->cast_to_ptr_type(TypePtr::NotNull);\n+  const TypeOopPtr* xtype = aklass->cast_to_exactness(false)->as_instance_type()->cast_to_ptr_type(TypePtr::NotNull);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1731,0 +1731,8 @@\n+\n+  bool clone_cmp_down(Node* n, const Node* blk1, const Node* blk2);\n+\n+  void process_load_klass_helper(const Node* n, Node* cmp, int i);\n+\n+  bool process_cmp_loadklass(Node* n, const Node* blk1, const Node* blk2);\n+\n+  bool at_relevant_ctrl(Node* n, const Node* blk1, const Node* blk2);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2015,1 +2015,1 @@\n-  if (tkls != NULL && !StressReflectiveCode) {\n+  if (tkls != NULL) {\n@@ -2035,1 +2035,1 @@\n-        return ss ? TypeKlassPtr::make(ss) : TypePtr::NULL_PTR;\n+        return ss ? TypeKlassPtr::make(ss, Type::trust_interfaces) : TypePtr::NULL_PTR;\n@@ -2066,1 +2066,1 @@\n-          return ss ? TypeKlassPtr::make(ss) : TypePtr::NULL_PTR;\n+          return ss ? TypeKlassPtr::make(ss, Type::trust_interfaces) : TypePtr::NULL_PTR;\n@@ -2326,1 +2326,1 @@\n-          return TypeKlassPtr::make(ciArrayKlass::make(t));\n+          return TypeKlassPtr::make(ciArrayKlass::make(t), Type::trust_interfaces);\n@@ -2333,1 +2333,1 @@\n-        return TypeKlassPtr::make(t->as_klass());\n+        return TypeKlassPtr::make(t->as_klass(), Type::trust_interfaces);\n@@ -2371,1 +2371,1 @@\n-      return sup ? TypeKlassPtr::make(sup) : TypePtr::NULL_PTR;\n+      return sup ? TypeKlassPtr::make(sup, Type::trust_interfaces) : TypePtr::NULL_PTR;\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -737,1 +737,0 @@\n-  dump();\n@@ -2557,4 +2556,1 @@\n-    ciKlass*           klass = toop ? toop->instance_klass() : (tkls ? tkls->instance_klass() : NULL );\n-    if (klass && klass->is_loaded() && ((toop && toop->is_interface()) || (tkls && tkls->is_interface()))) {\n-      st->print(\"  Interface:\");\n-    } else if (toop) {\n+    if (toop) {\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1200,1 +1200,1 @@\n-    const Type* holder_type = TypeInstPtr::make(TypePtr::BotPTR, callee_holder);\n+    const Type* holder_type = TypeInstPtr::make(TypePtr::BotPTR, callee_holder, Type::trust_interfaces);\n@@ -1213,1 +1213,1 @@\n-      Node* holder_klass = _gvn.makecon(TypeKlassPtr::make(callee_holder));\n+      Node* holder_klass = _gvn.makecon(TypeKlassPtr::make(callee_holder, Type::trust_interfaces));\n@@ -2133,1 +2133,1 @@\n-  Node* holder = makecon(TypeKlassPtr::make(method()->holder()));\n+  Node* holder = makecon(TypeKlassPtr::make(method()->holder(), Type::trust_interfaces));\n@@ -2212,21 +2212,0 @@\n-    const TypeInstPtr *tr = phi->bottom_type()->isa_instptr();\n-    if (tr && tr->is_loaded() &&\n-        tr->is_interface()) {\n-      const TypeInstPtr *tp = value->bottom_type()->isa_instptr();\n-      if (tp && tp->is_loaded() &&\n-          !tp->is_interface()) {\n-        \/\/ sharpen the type eagerly; this eases certain assert checking\n-        if (tp->higher_equal(TypeInstPtr::NOTNULL))\n-          tr = tr->join_speculative(TypeInstPtr::NOTNULL)->is_instptr();\n-        value = _gvn.transform(new CheckCastPPNode(0, value, tr));\n-      }\n-    } else {\n-      \/\/ Also handle returns of oop-arrays to an arrays-of-interface return\n-      const TypeInstPtr* phi_tip;\n-      const TypeInstPtr* val_tip;\n-      Type::get_arrays_base_elements(phi->bottom_type(), value->bottom_type(), &phi_tip, &val_tip);\n-      if (phi_tip != NULL && phi_tip->is_loaded() && phi_tip->is_interface() &&\n-          val_tip != NULL && val_tip->is_loaded() && !val_tip->is_interface()) {\n-        value = _gvn.transform(new CheckCastPPNode(0, value, phi->bottom_type()));\n-      }\n-    }\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":3,"deletions":24,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -280,1 +280,1 @@\n-  const TypeKlassPtr* array_klass_type = TypeKlassPtr::make(array_klass);\n+  const TypeKlassPtr* array_klass_type = TypeKlassPtr::make(array_klass, Type::trust_interfaces);\n@@ -302,1 +302,1 @@\n-  Node* array = new_array(makecon(TypeKlassPtr::make(array_klass)), length, nargs);\n+  Node* array = new_array(makecon(TypeKlassPtr::make(array_klass, Type::trust_interfaces)), length, nargs);\n@@ -388,1 +388,1 @@\n-                          makecon(TypeKlassPtr::make(array_klass)),\n+                          makecon(TypeKlassPtr::make(array_klass, Type::trust_interfaces)),\n@@ -410,1 +410,1 @@\n-                          makecon(TypeKlassPtr::make(array_klass)),\n+                          makecon(TypeKlassPtr::make(array_klass, Type::trust_interfaces)),\n@@ -417,1 +417,1 @@\n-  const Type* type = TypeOopPtr::make_from_klass_raw(array_klass);\n+  const Type* type = TypeOopPtr::make_from_klass_raw(array_klass, Type::trust_interfaces);\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-  Node* res = gen_checkcast(obj, makecon(TypeKlassPtr::make(klass)));\n+  Node* res = gen_checkcast(obj, makecon(TypeKlassPtr::make(klass, Type::trust_interfaces)));\n@@ -132,1 +132,1 @@\n-  Node* res = gen_instanceof(peek(), makecon(TypeKlassPtr::make(klass)), true);\n+  Node* res = gen_instanceof(peek(), makecon(TypeKlassPtr::make(klass, Type::trust_interfaces)), true);\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+#include \"opto\/addnode.hpp\"\n+#include \"opto\/node.hpp\"\n@@ -72,1 +74,1 @@\n-  if( get_ctrl(n) != blk1 && get_ctrl(n) != blk2 )\n+  if (!at_relevant_ctrl(n, blk1,blk2))\n@@ -86,0 +88,4 @@\n+  if (process_cmp_loadklass(n, blk1, blk2)) {\n+    return true;\n+  }\n+\n@@ -88,0 +94,219 @@\n+  if (clone_cmp_down(n, blk1, blk2)) {\n+    return true;\n+  }\n+\n+  if (subgraph_has_opaque(n)) {\n+    Unique_Node_List wq;\n+    wq.push(n);\n+    for (uint i = 0; i < wq.size(); i++) {\n+      Node* m = wq.at(i);\n+      if (m->is_If()) {\n+        assert(skeleton_predicate_has_opaque(m->as_If()), \"opaque node not reachable from if?\");\n+        Node* bol = clone_skeleton_predicate_bool(m, NULL, NULL, m->in(0));\n+        _igvn.replace_input_of(m, 1, bol);\n+      } else {\n+        assert(!m->is_CFG(), \"not CFG expected\");\n+        for (DUIterator_Fast jmax, j = m->fast_outs(jmax); j < jmax; j++) {\n+          Node* u = m->fast_out(j);\n+          wq.push(u);\n+        }\n+      }\n+    }\n+  }\n+\n+  if (n->Opcode() == Op_OpaqueZeroTripGuard) {\n+    \/\/ If this Opaque1 is part of the zero trip guard for a loop:\n+    \/\/ 1- it can't be shared\n+    \/\/ 2- the zero trip guard can't be the if that's being split\n+    \/\/ As a consequence, this node could be assigned control anywhere between its current control and the zero trip guard.\n+    \/\/ Move it down to get it out of the way of split if and avoid breaking the zero trip guard shape.\n+    Node* cmp = n->unique_out();\n+    assert(cmp->Opcode() == Op_CmpI, \"bad zero trip guard shape\");\n+    Node* bol = cmp->unique_out();\n+    assert(bol->Opcode() == Op_Bool, \"bad zero trip guard shape\");\n+    Node* iff = bol->unique_out();\n+    assert(iff->Opcode() == Op_If, \"bad zero trip guard shape\");\n+    set_ctrl(n, iff->in(0));\n+    set_ctrl(cmp, iff->in(0));\n+    set_ctrl(bol, iff->in(0));\n+    return true;\n+  }\n+\n+  \/\/ See if splitting-up a Store.  Any anti-dep loads must go up as\n+  \/\/ well.  An anti-dep load might be in the wrong block, because in\n+  \/\/ this particular layout\/schedule we ignored anti-deps and allow\n+  \/\/ memory to be alive twice.  This only works if we do the same\n+  \/\/ operations on anti-dep loads as we do their killing stores.\n+  if( n->is_Store() && n->in(MemNode::Memory)->in(0) == n->in(0) ) {\n+    \/\/ Get store's memory slice\n+    int alias_idx = C->get_alias_index(_igvn.type(n->in(MemNode::Address))->is_ptr());\n+\n+    \/\/ Get memory-phi anti-dep loads will be using\n+    Node *memphi = n->in(MemNode::Memory);\n+    assert( memphi->is_Phi(), \"\" );\n+    \/\/ Hoist any anti-dep load to the splitting block;\n+    \/\/ it will then \"split-up\".\n+    for (DUIterator_Fast imax,i = memphi->fast_outs(imax); i < imax; i++) {\n+      Node *load = memphi->fast_out(i);\n+      if( load->is_Load() && alias_idx == C->get_alias_index(_igvn.type(load->in(MemNode::Address))->is_ptr()) )\n+        set_ctrl(load,blk1);\n+    }\n+  }\n+\n+  \/\/ Found some other Node; must clone it up\n+#ifndef PRODUCT\n+  if( PrintOpto && VerifyLoopOptimizations ) {\n+    tty->print(\"Cloning up: \");\n+    n->dump();\n+  }\n+#endif\n+\n+  \/\/ ConvI2L may have type information on it which becomes invalid if\n+  \/\/ it moves up in the graph so change any clones so widen the type\n+  \/\/ to TypeLong::INT when pushing it up.\n+  const Type* rtype = NULL;\n+  if (n->Opcode() == Op_ConvI2L && n->bottom_type() != TypeLong::INT) {\n+    rtype = TypeLong::INT;\n+  }\n+\n+  \/\/ Now actually split-up this guy.  One copy per control path merging.\n+  Node *phi = PhiNode::make_blank(blk1, n);\n+  for( uint j = 1; j < blk1->req(); j++ ) {\n+    Node *x = n->clone();\n+    \/\/ Widen the type of the ConvI2L when pushing up.\n+    if (rtype != NULL) x->as_Type()->set_type(rtype);\n+    if( n->in(0) && n->in(0) == blk1 )\n+      x->set_req( 0, blk1->in(j) );\n+    for( uint i = 1; i < n->req(); i++ ) {\n+      Node *m = n->in(i);\n+      if( get_ctrl(m) == blk1 ) {\n+        assert( m->in(0) == blk1, \"\" );\n+        x->set_req( i, m->in(j) );\n+      }\n+    }\n+    register_new_node( x, blk1->in(j) );\n+    phi->init_req( j, x );\n+  }\n+  \/\/ Announce phi to optimizer\n+  register_new_node(phi, blk1);\n+\n+  \/\/ Remove cloned-up value from optimizer; use phi instead\n+  _igvn.replace_node( n, phi );\n+\n+  \/\/ (There used to be a self-recursive call to split_up() here,\n+  \/\/ but it is not needed.  All necessary forward walking is done\n+  \/\/ by do_split_if() below.)\n+\n+  return true;\n+}\n+\n+\/\/ Look for a (If .. (Bool(CmpP (LoadKlass .. (AddP obj ..)) ..))) and clone all of it down.\n+\/\/ There's likely a CheckCastPP on one of the branches of the If, with obj as input.\n+\/\/ If the (LoadKlass .. (AddP obj ..)) is not cloned down, then split if transforms this to: (If .. (Bool(CmpP phi1 ..)))\n+\/\/ and the CheckCastPP to (CheckCastPP phi2). It's possible then that phi2 is transformed to a CheckCastPP\n+\/\/ (through PhiNode::Ideal) and that that CheckCastPP is replaced by another narrower CheckCastPP at the same control\n+\/\/ (through ConstraintCastNode::Identity). That could cause the CheckCastPP at the If to become top while (CmpP phi1)\n+\/\/ wouldn't constant fold because it's using a different data path. Cloning the whole subgraph down guarantees both the\n+\/\/ AddP and CheckCastPP have the same obj input after split if.\n+bool PhaseIdealLoop::process_cmp_loadklass(Node* n, const Node* blk1, const Node* blk2) {\n+  if (n->Opcode() == Op_AddP && at_relevant_ctrl(n, blk1, blk2)) {\n+    Node_List cmp_nodes;\n+    uint old = C->unique();\n+    for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+      Node* u1 = n->fast_out(i);\n+      if (u1->Opcode() == Op_LoadNKlass && at_relevant_ctrl(u1, blk1, blk2)) {\n+        for (DUIterator_Fast jmax, j = u1->fast_outs(jmax); j < jmax; j++) {\n+          Node* u2 = u1->fast_out(j);\n+          if (u2->Opcode() == Op_DecodeNKlass && at_relevant_ctrl(u2, blk1, blk2)) {\n+            for (DUIterator k = u2->outs(); u2->has_out(k); k++) {\n+              Node* u3 = u2->out(k);\n+              if (at_relevant_ctrl(u3, blk1, blk2) && clone_cmp_down(u3, blk1, blk2)) {\n+                --k;\n+              }\n+            }\n+            for (DUIterator_Fast kmax, k = u2->fast_outs(kmax); k < kmax; k++) {\n+              Node* u3 = u2->fast_out(k);\n+              if (u3->_idx >= old) {\n+                cmp_nodes.push(u3);\n+              }\n+            }\n+          }\n+        }\n+      } else if (u1->Opcode() == Op_LoadKlass && at_relevant_ctrl(u1, blk1, blk2)) {\n+        for (DUIterator j = u1->outs(); u1->has_out(j); j++) {\n+          Node* u2 = u1->out(j);\n+          if (at_relevant_ctrl(u2, blk1, blk2) && clone_cmp_down(u2, blk1, blk2)) {\n+            --j;\n+\n+          }\n+        }\n+        for (DUIterator_Fast kmax, k = u1->fast_outs(kmax); k < kmax; k++) {\n+          Node* u2 = u1->fast_out(k);\n+          if (u2->_idx >= old) {\n+            cmp_nodes.push(u2);\n+          }\n+        }\n+      }\n+    }\n+\n+    for (uint i = 0; i < cmp_nodes.size(); ++i) {\n+      Node* cmp = cmp_nodes.at(i);\n+      process_load_klass_helper(n, cmp, 1);\n+      process_load_klass_helper(n, cmp, 2);\n+    }\n+    if (n->outcnt() == 0) {\n+      assert(n->is_dead(), \"\");\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool PhaseIdealLoop::at_relevant_ctrl(Node* n, const Node* blk1, const Node* blk2) {\n+  return ctrl_or_self(n) == blk1 || ctrl_or_self(n) == blk2;\n+}\n+\n+void PhaseIdealLoop::process_load_klass_helper(const Node* n, Node* cmp, int i) {\n+  Node* decode = cmp->in(i);\n+  if (decode->Opcode() == Op_DecodeNKlass) {\n+    Node* loadklass = decode->in(1);\n+    if (loadklass->Opcode() == Op_LoadNKlass) {\n+      Node* addp = loadklass->in(MemNode::Address);\n+      if (addp == n) {\n+        Node* ctrl = get_ctrl(cmp);\n+        Node* decode_clone = decode->clone();\n+        Node* loadklass_clone = loadklass->clone();\n+        Node* addp_clone = addp->clone();\n+        register_new_node(decode_clone, ctrl);\n+        register_new_node(loadklass_clone, ctrl);\n+        register_new_node(addp_clone, ctrl);\n+        _igvn.replace_input_of(cmp, i, decode_clone);\n+        _igvn.replace_input_of(decode_clone, 1, loadklass_clone);\n+        _igvn.replace_input_of(loadklass_clone, MemNode::Address, addp_clone);\n+        if (decode->outcnt() == 0) {\n+          _igvn.remove_dead_node(decode);\n+        }\n+      }\n+    }\n+  } else {\n+    Node* loadklass = cmp->in(i);\n+    if (loadklass->Opcode() == Op_LoadKlass) {\n+      Node* addp = loadklass->in(MemNode::Address);\n+      if (addp == n) {\n+        Node* ctrl = get_ctrl(cmp);\n+        Node* loadklass_clone = loadklass->clone();\n+        Node* addp_clone = addp->clone();\n+        register_new_node(loadklass_clone, ctrl);\n+        register_new_node(addp_clone, ctrl);\n+        _igvn.replace_input_of(cmp, i, loadklass_clone);\n+        _igvn.replace_input_of(loadklass_clone, MemNode::Address, addp_clone);\n+        if (loadklass->outcnt() == 0) {\n+          _igvn.remove_dead_node(loadklass);\n+        }\n+      }\n+    }\n+\n+  }\n+}\n+\n+bool PhaseIdealLoop::clone_cmp_down(Node* n, const Node* blk1, const Node* blk2) {\n@@ -97,1 +322,1 @@\n-    if( !(n->outcnt() == 1 && n->unique_out()->is_Bool() &&\n+    if (!(n->outcnt() == 1 && n->unique_out()->is_Bool() &&\n@@ -99,7 +324,5 @@\n-          (get_ctrl(bol) == blk1 ||\n-           get_ctrl(bol) == blk2) &&\n-          bol->outcnt() == 1 &&\n-          bol->unique_out()->is_CMove() &&\n-          (cmov = bol->unique_out()->as_CMove()) &&\n-          (get_ctrl(cmov) == blk1 ||\n-           get_ctrl(cmov) == blk2) ) ) {\n+          (at_relevant_ctrl(bol, blk1, blk2) &&\n+           bol->outcnt() == 1 &&\n+           bol->unique_out()->is_CMove() &&\n+           (cmov = bol->unique_out()->as_CMove()) &&\n+           at_relevant_ctrl(cmov, blk1, blk2)))) {\n@@ -140,1 +363,1 @@\n-          if (get_ctrl(bol) == blk1 || get_ctrl(bol) == blk2) {\n+          if (at_relevant_ctrl(bol, blk1, blk2)) {\n@@ -200,1 +423,1 @@\n-      _igvn.remove_dead_node( n );\n+      _igvn.remove_dead_node(n );\n@@ -205,103 +428,1 @@\n-  if (subgraph_has_opaque(n)) {\n-    Unique_Node_List wq;\n-    wq.push(n);\n-    for (uint i = 0; i < wq.size(); i++) {\n-      Node* m = wq.at(i);\n-      if (m->is_If()) {\n-        assert(skeleton_predicate_has_opaque(m->as_If()), \"opaque node not reachable from if?\");\n-        Node* bol = clone_skeleton_predicate_bool(m, NULL, NULL, m->in(0));\n-        _igvn.replace_input_of(m, 1, bol);\n-      } else {\n-        assert(!m->is_CFG(), \"not CFG expected\");\n-        for (DUIterator_Fast jmax, j = m->fast_outs(jmax); j < jmax; j++) {\n-          Node* u = m->fast_out(j);\n-          wq.push(u);\n-        }\n-      }\n-    }\n-  }\n-\n-  if (n->Opcode() == Op_OpaqueZeroTripGuard) {\n-    \/\/ If this Opaque1 is part of the zero trip guard for a loop:\n-    \/\/ 1- it can't be shared\n-    \/\/ 2- the zero trip guard can't be the if that's being split\n-    \/\/ As a consequence, this node could be assigned control anywhere between its current control and the zero trip guard.\n-    \/\/ Move it down to get it out of the way of split if and avoid breaking the zero trip guard shape.\n-    Node* cmp = n->unique_out();\n-    assert(cmp->Opcode() == Op_CmpI, \"bad zero trip guard shape\");\n-    Node* bol = cmp->unique_out();\n-    assert(bol->Opcode() == Op_Bool, \"bad zero trip guard shape\");\n-    Node* iff = bol->unique_out();\n-    assert(iff->Opcode() == Op_If, \"bad zero trip guard shape\");\n-    set_ctrl(n, iff->in(0));\n-    set_ctrl(cmp, iff->in(0));\n-    set_ctrl(bol, iff->in(0));\n-    return true;\n-  }\n-\n-  \/\/ See if splitting-up a Store.  Any anti-dep loads must go up as\n-  \/\/ well.  An anti-dep load might be in the wrong block, because in\n-  \/\/ this particular layout\/schedule we ignored anti-deps and allow\n-  \/\/ memory to be alive twice.  This only works if we do the same\n-  \/\/ operations on anti-dep loads as we do their killing stores.\n-  if( n->is_Store() && n->in(MemNode::Memory)->in(0) == n->in(0) ) {\n-    \/\/ Get store's memory slice\n-    int alias_idx = C->get_alias_index(_igvn.type(n->in(MemNode::Address))->is_ptr());\n-\n-    \/\/ Get memory-phi anti-dep loads will be using\n-    Node *memphi = n->in(MemNode::Memory);\n-    assert( memphi->is_Phi(), \"\" );\n-    \/\/ Hoist any anti-dep load to the splitting block;\n-    \/\/ it will then \"split-up\".\n-    for (DUIterator_Fast imax,i = memphi->fast_outs(imax); i < imax; i++) {\n-      Node *load = memphi->fast_out(i);\n-      if( load->is_Load() && alias_idx == C->get_alias_index(_igvn.type(load->in(MemNode::Address))->is_ptr()) )\n-        set_ctrl(load,blk1);\n-    }\n-  }\n-\n-  \/\/ Found some other Node; must clone it up\n-#ifndef PRODUCT\n-  if( PrintOpto && VerifyLoopOptimizations ) {\n-    tty->print(\"Cloning up: \");\n-    n->dump();\n-  }\n-#endif\n-\n-  \/\/ ConvI2L may have type information on it which becomes invalid if\n-  \/\/ it moves up in the graph so change any clones so widen the type\n-  \/\/ to TypeLong::INT when pushing it up.\n-  const Type* rtype = NULL;\n-  if (n->Opcode() == Op_ConvI2L && n->bottom_type() != TypeLong::INT) {\n-    rtype = TypeLong::INT;\n-  }\n-\n-  \/\/ Now actually split-up this guy.  One copy per control path merging.\n-  Node *phi = PhiNode::make_blank(blk1, n);\n-  for( uint j = 1; j < blk1->req(); j++ ) {\n-    Node *x = n->clone();\n-    \/\/ Widen the type of the ConvI2L when pushing up.\n-    if (rtype != NULL) x->as_Type()->set_type(rtype);\n-    if( n->in(0) && n->in(0) == blk1 )\n-      x->set_req( 0, blk1->in(j) );\n-    for( uint i = 1; i < n->req(); i++ ) {\n-      Node *m = n->in(i);\n-      if( get_ctrl(m) == blk1 ) {\n-        assert( m->in(0) == blk1, \"\" );\n-        x->set_req( i, m->in(j) );\n-      }\n-    }\n-    register_new_node( x, blk1->in(j) );\n-    phi->init_req( j, x );\n-  }\n-  \/\/ Announce phi to optimizer\n-  register_new_node(phi, blk1);\n-\n-  \/\/ Remove cloned-up value from optimizer; use phi instead\n-  _igvn.replace_node( n, phi );\n-\n-  \/\/ (There used to be a self-recursive call to split_up() here,\n-  \/\/ but it is not needed.  All necessary forward walking is done\n-  \/\/ by do_split_if() below.)\n-\n-  return true;\n+  return false;\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":235,"deletions":114,"binary":false,"changes":349,"status":"modified"},{"patch":"@@ -1041,1 +1041,1 @@\n-  return phase->makecon(TypeKlassPtr::make(mirror_type->as_klass()));\n+  return phase->makecon(TypeKlassPtr::make(mirror_type->as_klass(), Type::trust_interfaces));\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-    switch (Compile::current()->static_subtype_check(superk, subk)) {\n+    switch (Compile::current()->static_subtype_check(superk, subk, false)) {\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,0 +123,2 @@\n+const TypePtr::InterfaceSet* TypeAryPtr::_array_interfaces = NULL;\n+const TypePtr::InterfaceSet* TypeAryKlassPtr::_array_interfaces = NULL;\n@@ -137,1 +139,1 @@\n-const Type* Type::get_const_type(ciType* type) {\n+const Type* Type::get_const_type(ciType* type, InterfaceHandling interface_handling) {\n@@ -143,1 +145,1 @@\n-    return TypeOopPtr::make_from_klass(type->as_klass());\n+    return TypeOopPtr::make_from_klass(type->as_klass(), interface_handling);\n@@ -569,0 +571,6 @@\n+  GrowableArray<ciInstanceKlass*> array_interfaces;\n+  array_interfaces.push(current->env()->Cloneable_klass());\n+  array_interfaces.push(current->env()->Serializable_klass());\n+  TypeAryPtr::_array_interfaces = new TypePtr::InterfaceSet(&array_interfaces);\n+  TypeAryKlassPtr::_array_interfaces = TypeAryPtr::_array_interfaces;\n+\n@@ -781,45 +789,0 @@\n-\/\/----------------------interface_vs_oop---------------------------------------\n-#ifdef ASSERT\n-bool Type::interface_vs_oop_helper(const Type *t) const {\n-  bool result = false;\n-\n-  const TypePtr* this_ptr = this->make_ptr(); \/\/ In case it is narrow_oop\n-  const TypePtr*    t_ptr =    t->make_ptr();\n-  if( this_ptr == NULL || t_ptr == NULL )\n-    return result;\n-\n-  const TypeInstPtr* this_inst = this_ptr->isa_instptr();\n-  const TypeInstPtr*    t_inst =    t_ptr->isa_instptr();\n-  if( this_inst && this_inst->is_loaded() && t_inst && t_inst->is_loaded() ) {\n-    bool this_interface = this_inst->is_interface();\n-    bool    t_interface =    t_inst->is_interface();\n-    result = this_interface ^ t_interface;\n-  }\n-\n-  return result;\n-}\n-\n-bool Type::interface_vs_oop(const Type *t) const {\n-  if (interface_vs_oop_helper(t)) {\n-    return true;\n-  }\n-  \/\/ Now check the speculative parts as well\n-  const TypePtr* this_spec = isa_ptr() != NULL ? is_ptr()->speculative() : NULL;\n-  const TypePtr* t_spec = t->isa_ptr() != NULL ? t->is_ptr()->speculative() : NULL;\n-  if (this_spec != NULL && t_spec != NULL) {\n-    if (this_spec->interface_vs_oop_helper(t_spec)) {\n-      return true;\n-    }\n-    return false;\n-  }\n-  if (this_spec != NULL && this_spec->interface_vs_oop_helper(t)) {\n-    return true;\n-  }\n-  if (t_spec != NULL && interface_vs_oop_helper(t_spec)) {\n-    return true;\n-  }\n-  return false;\n-}\n-\n-#endif\n-\n@@ -845,1 +808,1 @@\n-  if (!interface_vs_oop(t) && (t2t != t->_dual || t2this != this->_dual)) {\n+  if (t2t != t->_dual || t2this != this->_dual) {\n@@ -2023,1 +1986,1 @@\n-const TypeTuple *TypeTuple::make_range(ciSignature* sig) {\n+const TypeTuple *TypeTuple::make_range(ciSignature* sig, InterfaceHandling interface_handling) {\n@@ -2044,1 +2007,1 @@\n-    field_array[TypeFunc::Parms] = get_const_type(return_type);\n+    field_array[TypeFunc::Parms] = get_const_type(return_type, interface_handling);\n@@ -2055,1 +2018,1 @@\n-const TypeTuple *TypeTuple::make_domain(ciInstanceKlass* recv, ciSignature* sig) {\n+const TypeTuple *TypeTuple::make_domain(ciInstanceKlass* recv, ciSignature* sig, InterfaceHandling interface_handling) {\n@@ -2064,1 +2027,1 @@\n-    field_array[pos++] = get_const_type(recv)->join_speculative(TypePtr::NOTNULL);\n+    field_array[pos++] = get_const_type(recv, interface_handling)->join_speculative(TypePtr::NOTNULL);\n@@ -2086,1 +2049,1 @@\n-      field_array[pos++] = get_const_type(type);\n+      field_array[pos++] = get_const_type(type, interface_handling);\n@@ -2317,15 +2280,0 @@\n-\/\/----------------------interface_vs_oop---------------------------------------\n-#ifdef ASSERT\n-bool TypeAry::interface_vs_oop(const Type *t) const {\n-  const TypeAry* t_ary = t->is_ary();\n-  if (t_ary) {\n-    const TypePtr* this_ptr = _elem->make_ptr(); \/\/ In case we have narrow_oops\n-    const TypePtr*    t_ptr = t_ary->_elem->make_ptr();\n-    if(this_ptr != NULL && t_ptr != NULL) {\n-      return this_ptr->interface_vs_oop(t_ptr);\n-    }\n-  }\n-  return false;\n-}\n-#endif\n-\n@@ -2369,3 +2317,1 @@\n-  ciKlass* tklass = toop->klass();\n-  if (tklass == NULL)       return false;  \/\/ unloaded class\n-  if (!tklass->is_loaded()) return false;  \/\/ unloaded class\n+  if (!toop->is_loaded())   return false;  \/\/ unloaded class\n@@ -2378,1 +2324,1 @@\n-    return tklass->as_instance_klass()->is_final();\n+    return tinst->instance_klass()->is_final();\n@@ -3170,0 +3116,229 @@\n+TypePtr::InterfaceSet::InterfaceSet()\n+        : _list(Compile::current()->type_arena(), 0, 0, NULL),\n+          _hash_computed(0), _exact_klass_computed(0), _is_loaded_computed(0) {\n+}\n+\n+TypePtr::InterfaceSet::InterfaceSet(GrowableArray<ciInstanceKlass*>* interfaces)\n+        : _list(Compile::current()->type_arena(), interfaces->length(), 0, NULL),\n+          _hash_computed(0), _exact_klass_computed(0), _is_loaded_computed(0) {\n+  for (int i = 0; i < interfaces->length(); i++) {\n+    add(interfaces->at(i));\n+  }\n+}\n+\n+\n+int TypePtr::InterfaceSet::compare(ciKlass* const& k1, ciKlass* const& k2) {\n+  if ((intptr_t)k1 < (intptr_t)k2) {\n+    return -1;\n+  } else if ((intptr_t)k1 > (intptr_t)k2) {\n+    return 1;\n+  }\n+  return 0;\n+}\n+\n+void TypePtr::InterfaceSet::add(ciKlass* interface) {\n+  assert(interface->is_interface(), \"for interfaces only\");\n+  _list.insert_sorted<compare>(interface);\n+  verify();\n+}\n+\n+void TypePtr::InterfaceSet::raw_add(ciKlass* interface) {\n+  assert(interface->is_interface(), \"for interfaces only\");\n+  _list.push(interface);\n+}\n+\n+bool TypePtr::InterfaceSet::eq(const InterfaceSet& other) const {\n+  if (_list.length() != other._list.length()) {\n+    return false;\n+  }\n+  for (int i = 0; i < _list.length(); i++) {\n+    ciKlass* k1 = _list.at(i);\n+    ciKlass* k2 = other._list.at(i);\n+    if (!k1->equals(k2)) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+int TypePtr::InterfaceSet::hash() const {\n+  if (_hash_computed) {\n+    return _hash;\n+  }\n+  const_cast<InterfaceSet*>(this)->compute_hash();\n+  assert(_hash_computed, \"should be computed now\");\n+  return _hash;\n+}\n+\n+void TypePtr::InterfaceSet::compute_hash() {\n+  int hash = 0;\n+  for (int i = 0; i < _list.length(); i++) {\n+    ciKlass* k = _list.at(i);\n+    hash += (jint)k->hash();\n+  }\n+  _hash_computed = 1;\n+  _hash = hash;\n+}\n+\n+static int compare_interfaces(ciKlass** k1, ciKlass** k2) {\n+  return (int)((*k1)->ident() - (*k2)->ident());\n+}\n+\n+void TypePtr::InterfaceSet::dump(outputStream *st) const {\n+  if (_list.length() == 0) {\n+    return;\n+  }\n+  ResourceMark rm;\n+  st->print(\" (\");\n+  GrowableArray<ciKlass*> interfaces;\n+  interfaces.appendAll(&_list);\n+  \/\/ Sort the interfaces so they are listed in the same order from one run to the other of the same compilation\n+  interfaces.sort(compare_interfaces);\n+  for (int i = 0; i < interfaces.length(); i++) {\n+    if (i > 0) {\n+      st->print(\",\");\n+    }\n+    ciKlass* k = interfaces.at(i);\n+    k->print_name_on(st);\n+  }\n+  st->print(\")\");\n+}\n+\n+void TypePtr::InterfaceSet::verify() const {\n+#ifdef DEBUG\n+  for (int i = 1; i < _list.length(); i++) {\n+    ciKlass* k1 = _list.at(i-1);\n+    ciKlass* k2 = _list.at(i);\n+    assert(compare(k2, k1) > 0, \"should be ordered\");\n+    assert(k1 != k2, \"no duplicate\");\n+  }\n+#endif\n+}\n+\n+TypePtr::InterfaceSet TypeOopPtr::InterfaceSet::union_with(const InterfaceSet& other) const {\n+  InterfaceSet result;\n+  int i = 0;\n+  int j = 0;\n+  while (i < _list.length() || j < other._list.length()) {\n+    while (i < _list.length() &&\n+           (j >= other._list.length() ||\n+            compare(_list.at(i), other._list.at(j)) < 0)) {\n+      result.raw_add(_list.at(i));\n+      i++;\n+    }\n+    while (j < other._list.length() &&\n+           (i >= _list.length() ||\n+            compare(other._list.at(j), _list.at(i)) < 0)) {\n+      result.raw_add(other._list.at(j));\n+      j++;\n+    }\n+    if (i < _list.length() &&\n+        j < other._list.length() &&\n+        _list.at(i) == other._list.at(j)) {\n+      result.raw_add(_list.at(i));\n+      i++;\n+      j++;\n+    }\n+  }\n+  result.verify();\n+#ifdef DEBUG\n+  for (int i = 0; i < _list.length(); i++) {\n+    assert(result.contains(_list.at(i)), \"missing\");\n+  }\n+  for (int i = 0; i < other._list.length(); i++) {\n+    assert(result.contains(other._list.at(i)), \"missing\");\n+  }\n+  for (int i = 0; i < result._list.length(); i++) {\n+    assert(_list.contains(result._list.at(i)) || other._list.contains(result._list.at(i)), \"missing\");\n+  }\n+#endif\n+  return result;\n+}\n+\n+TypePtr::InterfaceSet TypeOopPtr::InterfaceSet::intersection_with(const InterfaceSet& other) const {\n+  InterfaceSet result;\n+  int i = 0;\n+  int j = 0;\n+  while (i < _list.length() || j < other._list.length()) {\n+    while (i < _list.length() &&\n+           (j >= other._list.length() ||\n+            compare(_list.at(i), other._list.at(j)) < 0)) {\n+      i++;\n+    }\n+    while (j < other._list.length() &&\n+           (i >= _list.length() ||\n+            compare(other._list.at(j), _list.at(i)) < 0)) {\n+      j++;\n+    }\n+    if (i < _list.length() &&\n+        j < other._list.length() &&\n+        _list.at(i) == other._list.at(j)) {\n+      result.raw_add(_list.at(i));\n+      i++;\n+      j++;\n+    }\n+  }\n+  result.verify();\n+#ifdef DEBUG\n+  for (int i = 0; i < _list.length(); i++) {\n+    assert(!other._list.contains(_list.at(i)) || result.contains(_list.at(i)), \"missing\");\n+  }\n+  for (int i = 0; i < other._list.length(); i++) {\n+    assert(!_list.contains(other._list.at(i)) || result.contains(other._list.at(i)), \"missing\");\n+  }\n+  for (int i = 0; i < result._list.length(); i++) {\n+    assert(_list.contains(result._list.at(i)) && other._list.contains(result._list.at(i)), \"missing\");\n+  }\n+#endif\n+  return result;\n+}\n+\n+\/\/ Is there a single ciKlass* that can represent the interface set?\n+ciKlass* TypePtr::InterfaceSet::exact_klass() const {\n+  if (_exact_klass_computed) {\n+    return _exact_klass;\n+  }\n+  const_cast<InterfaceSet*>(this)->compute_exact_klass();\n+  assert(_exact_klass_computed, \"should be computed now\");\n+  return _exact_klass;\n+}\n+\n+void TypePtr::InterfaceSet::compute_exact_klass() {\n+  if (_list.length() == 0) {\n+    _exact_klass_computed = 1;\n+    _exact_klass = NULL;\n+    return;\n+  }\n+  ciKlass* res = NULL;\n+  for (int i = 0; i < _list.length(); i++) {\n+    ciKlass* interface = _list.at(i);\n+    if (eq(interfaces(interface, false, true, false, trust_interfaces))) {\n+      assert(res == NULL, \"\");\n+      res = _list.at(i);\n+    }\n+  }\n+  _exact_klass_computed = 1;\n+  _exact_klass = res;\n+}\n+\n+bool TypePtr::InterfaceSet::is_loaded() const {\n+  if (_is_loaded_computed) {\n+    return _is_loaded;\n+  }\n+  const_cast<InterfaceSet*>(this)->compute_is_loaded();\n+  assert(_is_loaded_computed, \"should be computed now\");\n+  return _is_loaded;\n+}\n+\n+void TypePtr::InterfaceSet::compute_is_loaded() {\n+  _is_loaded_computed = 1;\n+  for (int i = 0; i < _list.length(); i++) {\n+    ciKlass* interface = _list.at(i);\n+    if (!interface->is_loaded()) {\n+      _is_loaded = false;\n+      return;\n+    }\n+  }\n+  _is_loaded = true;\n+}\n+\n@@ -3171,1 +3346,1 @@\n-TypeOopPtr::TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset,\n+TypeOopPtr::TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, const InterfaceSet& interfaces, bool xk, ciObject* o, int offset,\n@@ -3175,0 +3350,1 @@\n+    _interfaces(interfaces),\n@@ -3222,1 +3398,1 @@\n-            _is_ptr_to_narrowoop = UseCompressedOops && is_reference_type(basic_elem_type);\n+            _is_ptr_to_narrowoop = UseCompressedOops && ::is_reference_type(basic_elem_type);\n@@ -3232,1 +3408,1 @@\n-            _is_ptr_to_narrowoop = UseCompressedOops && is_reference_type(basic_elem_type);\n+            _is_ptr_to_narrowoop = UseCompressedOops && ::is_reference_type(basic_elem_type);\n@@ -3255,1 +3431,1 @@\n-  return (TypeOopPtr*)(new TypeOopPtr(OopPtr, ptr, k, xk, o, offset, instance_id, speculative, inline_depth))->hashcons();\n+  return (TypeOopPtr*)(new TypeOopPtr(OopPtr, ptr, k, InterfaceSet(), xk, o, offset, instance_id, speculative, inline_depth))->hashcons();\n@@ -3368,1 +3544,1 @@\n-  return new TypeOopPtr(_base, dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());\n+  return new TypeOopPtr(_base, dual_ptr(), klass(), _interfaces, klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());\n@@ -3373,1 +3549,1 @@\n-const TypeOopPtr* TypeOopPtr::make_from_klass_common(ciKlass *klass, bool klass_change, bool try_for_exact) {\n+const TypeOopPtr* TypeOopPtr::make_from_klass_common(ciKlass* klass, bool klass_change, bool try_for_exact, InterfaceHandling interface_handling) {\n@@ -3400,1 +3576,2 @@\n-    return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, 0);\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(klass, true, true, false, interface_handling);\n+    return TypeInstPtr::make(TypePtr::BotPTR, klass, interfaces, klass_is_exact, NULL, 0);\n@@ -3403,1 +3580,2 @@\n-    const TypeOopPtr *etype = TypeOopPtr::make_from_klass_common(klass->as_obj_array_klass()->element_klass(), false, try_for_exact);\n+    ciKlass* eklass = klass->as_obj_array_klass()->element_klass();\n+    const TypeOopPtr *etype = TypeOopPtr::make_from_klass_common(eklass, try_for_exact, false, interface_handling);\n@@ -3409,1 +3587,1 @@\n-    const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, xk, 0);\n+    const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, NULL, xk, 0);\n@@ -3443,1 +3621,1 @@\n-      TypeOopPtr::make_from_klass_raw(klass->as_obj_array_klass()->element_klass());\n+      TypeOopPtr::make_from_klass_raw(klass->as_obj_array_klass()->element_klass(), trust_interfaces);\n@@ -3501,21 +3679,0 @@\n-    \/\/ Check for evil case of 'this' being a class and 'kills' expecting an\n-    \/\/ interface.  This can happen because the bytecodes do not contain\n-    \/\/ enough type info to distinguish a Java-level interface variable\n-    \/\/ from a Java-level object variable.  If we meet 2 classes which\n-    \/\/ both implement interface I, but their meet is at 'j\/l\/O' which\n-    \/\/ doesn't implement I, we have no way to tell if the result should\n-    \/\/ be 'I' or 'j\/l\/O'.  Thus we'll pick 'j\/l\/O'.  If this then flows\n-    \/\/ into a Phi which \"knows\" it's an Interface type we'll have to\n-    \/\/ uplift the type.\n-    if (!empty()) {\n-      if (ktip != NULL && ktip->is_loaded() && ktip->klass()->is_interface()) {\n-        return kills;           \/\/ Uplift to interface\n-      }\n-      \/\/ Also check for evil cases of 'this' being a class array\n-      \/\/ and 'kills' expecting an array of interfaces.\n-      Type::get_arrays_base_elements(ft, kills, NULL, &ktip);\n-      if (ktip != NULL && ktip->is_loaded() && ktip->klass()->is_interface()) {\n-        return kills;           \/\/ Uplift to array of interface\n-      }\n-    }\n-\n@@ -3525,12 +3682,0 @@\n-  \/\/ If we have an interface-typed Phi or cast and we narrow to a class type,\n-  \/\/ the join should report back the class.  However, if we have a J\/L\/Object\n-  \/\/ class-typed Phi and an interface flows in, it's possible that the meet &\n-  \/\/ join report an interface back out.  This isn't possible but happens\n-  \/\/ because the type system doesn't interact well with interfaces.\n-  if (ftip != NULL && ktip != NULL &&\n-      ftip->is_loaded() &&  ftip->klass()->is_interface() &&\n-      ktip->is_loaded() && !ktip->klass()->is_interface()) {\n-    assert(!ftip->klass_is_exact(), \"interface could not be exact\");\n-    return ktip->cast_to_ptr_type(ftip->ptr());\n-  }\n-\n@@ -3595,1 +3740,1 @@\n-const TypePtr *TypeOopPtr::add_offset(intptr_t offset) const {\n+const TypePtr* TypeOopPtr::add_offset(intptr_t offset) const {\n@@ -3662,0 +3807,12 @@\n+\n+TypePtr::InterfaceSet TypeOopPtr::meet_interfaces(const TypeOopPtr* other) const {\n+  if (above_centerline(_ptr) && above_centerline(other->_ptr)) {\n+    return _interfaces.union_with(other->_interfaces);\n+  } else if (above_centerline(_ptr) && !above_centerline(other->_ptr)) {\n+    return other->_interfaces;\n+  } else if (above_centerline(other->_ptr) && !above_centerline(_ptr)) {\n+    return _interfaces;\n+  }\n+  return _interfaces.intersection_with(other->_interfaces);\n+}\n+\n@@ -3686,0 +3843,1 @@\n+\/\/ Is there a single ciKlass* that can represent that type?\n@@ -3687,1 +3845,12 @@\n-  return _klass;\n+  if (_interfaces.empty()) {\n+    return _klass;\n+  }\n+  if (_klass != ciEnv::current()->Object_klass()) {\n+    ciKlass* k = _klass;\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n+    if (_interfaces.eq(interfaces)) {\n+      return _klass;\n+    }\n+    return NULL;\n+  }\n+  return _interfaces.exact_klass();\n@@ -3691,1 +3860,1 @@\n-TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, int off,\n+TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, bool xk, ciObject* o, int off,\n@@ -3693,4 +3862,5 @@\n-  : TypeOopPtr(InstPtr, ptr, k, xk, o, off, instance_id, speculative, inline_depth) {\n-   assert(k != NULL &&\n-          (k->is_loaded() || o == NULL),\n-          \"cannot have constants with non-loaded klass\");\n+  : TypeOopPtr(InstPtr, ptr, k, interfaces, xk, o, off, instance_id, speculative, inline_depth) {\n+  assert(k == NULL || !k->is_loaded() || !k->is_interface(), \"no interface here\");\n+  assert(k != NULL &&\n+         (k->is_loaded() || o == NULL),\n+         \"cannot have constants with non-loaded klass\");\n@@ -3702,0 +3872,1 @@\n+                                     const InterfaceSet& interfaces,\n@@ -3722,0 +3893,1 @@\n+    assert(!ik->is_interface(), \"no interface here\");\n@@ -3727,1 +3899,1 @@\n-    (TypeInstPtr*)(new TypeInstPtr(ptr, k, xk, o ,offset, instance_id, speculative, inline_depth))->hashcons();\n+    (TypeInstPtr*)(new TypeInstPtr(ptr, k, interfaces, xk, o ,offset, instance_id, speculative, inline_depth))->hashcons();\n@@ -3732,0 +3904,33 @@\n+TypePtr::InterfaceSet TypePtr::interfaces(ciKlass*& k, bool klass, bool interface, bool array, InterfaceHandling interface_handling) {\n+  if (k->is_instance_klass()) {\n+    if (k->is_loaded()) {\n+      if (k->is_interface() && interface_handling == ignore_interfaces) {\n+        assert(interface, \"no interface expected\");\n+        k = ciEnv::current()->Object_klass();\n+        InterfaceSet interfaces;\n+        return interfaces;\n+      }\n+      GrowableArray<ciInstanceKlass *> *k_interfaces = k->as_instance_klass()->transitive_interfaces();\n+      InterfaceSet interfaces(k_interfaces);\n+      if (k->is_interface()) {\n+        assert(interface, \"no interface expected\");\n+        k = ciEnv::current()->Object_klass();\n+      } else {\n+        assert(klass, \"no instance klass expected\");\n+      }\n+      return interfaces;\n+    }\n+    InterfaceSet interfaces;\n+    return interfaces;\n+  }\n+  assert(array, \"no array expected\");\n+  assert(k->is_array_klass(), \"Not an array?\");\n+  ciType* e = k->as_array_klass()->base_element_type();\n+  if (e->is_loaded() && e->is_instance_klass() && e->as_instance_klass()->is_interface()) {\n+    if (interface_handling == ignore_interfaces) {\n+      k = ciObjArrayKlass::make(ciEnv::current()->Object_klass(), k->as_array_klass()->dimension());\n+    }\n+  }\n+  return *TypeAryPtr::_array_interfaces;\n+}\n+\n@@ -3760,1 +3965,1 @@\n-  return make(ptr, klass(), klass_is_exact(), ptr == Constant ? const_oop() : NULL, _offset, _instance_id, _speculative, _inline_depth);\n+  return make(ptr, klass(), _interfaces, klass_is_exact(), ptr == Constant ? const_oop() : NULL, _offset, _instance_id, _speculative, _inline_depth);\n@@ -3770,2 +3975,2 @@\n-  if( ik->is_interface() )              return this;  \/\/ cannot set xk\n-  return make(ptr(), klass(), klass_is_exact, const_oop(), _offset, _instance_id, _speculative, _inline_depth);\n+  assert(!ik->is_interface(), \"no interface here\");\n+  return make(ptr(), klass(), _interfaces, klass_is_exact, const_oop(), _offset, _instance_id, _speculative, _inline_depth);\n@@ -3777,1 +3982,1 @@\n-  return make(_ptr, klass(), _klass_is_exact, const_oop(), _offset, instance_id, _speculative, _inline_depth);\n+  return make(_ptr, klass(),  _interfaces, _klass_is_exact, const_oop(), _offset, instance_id, _speculative, _inline_depth);\n@@ -3783,35 +3988,31 @@\n-const TypeInstPtr *TypeInstPtr::xmeet_unloaded(const TypeInstPtr *tinst) const {\n-    int off = meet_offset(tinst->offset());\n-    PTR ptr = meet_ptr(tinst->ptr());\n-    int instance_id = meet_instance_id(tinst->instance_id());\n-    const TypePtr* speculative = xmeet_speculative(tinst);\n-    int depth = meet_inline_depth(tinst->inline_depth());\n-\n-    const TypeInstPtr *loaded    = is_loaded() ? this  : tinst;\n-    const TypeInstPtr *unloaded  = is_loaded() ? tinst : this;\n-    if( loaded->klass()->equals(ciEnv::current()->Object_klass()) ) {\n-      \/\/\n-      \/\/ Meet unloaded class with java\/lang\/Object\n-      \/\/\n-      \/\/ Meet\n-      \/\/          |                     Unloaded Class\n-      \/\/  Object  |   TOP    |   AnyNull | Constant |   NotNull |  BOTTOM   |\n-      \/\/  ===================================================================\n-      \/\/   TOP    | ..........................Unloaded......................|\n-      \/\/  AnyNull |  U-AN    |................Unloaded......................|\n-      \/\/ Constant | ... O-NN .................................. |   O-BOT   |\n-      \/\/  NotNull | ... O-NN .................................. |   O-BOT   |\n-      \/\/  BOTTOM  | ........................Object-BOTTOM ..................|\n-      \/\/\n-      assert(loaded->ptr() != TypePtr::Null, \"insanity check\");\n-      \/\/\n-      if(      loaded->ptr() == TypePtr::TopPTR ) { return unloaded; }\n-      else if (loaded->ptr() == TypePtr::AnyNull) { return TypeInstPtr::make(ptr, unloaded->klass(), false, NULL, off, instance_id, speculative, depth); }\n-      else if (loaded->ptr() == TypePtr::BotPTR ) { return TypeInstPtr::BOTTOM; }\n-      else if (loaded->ptr() == TypePtr::Constant || loaded->ptr() == TypePtr::NotNull) {\n-        if (unloaded->ptr() == TypePtr::BotPTR  ) { return TypeInstPtr::BOTTOM;  }\n-        else                                      { return TypeInstPtr::NOTNULL; }\n-      }\n-      else if( unloaded->ptr() == TypePtr::TopPTR )  { return unloaded; }\n-\n-      return unloaded->cast_to_ptr_type(TypePtr::AnyNull)->is_instptr();\n+const TypeInstPtr *TypeInstPtr::xmeet_unloaded(const TypeInstPtr *tinst, const InterfaceSet& interfaces) const {\n+  int off = meet_offset(tinst->offset());\n+  PTR ptr = meet_ptr(tinst->ptr());\n+  int instance_id = meet_instance_id(tinst->instance_id());\n+  const TypePtr* speculative = xmeet_speculative(tinst);\n+  int depth = meet_inline_depth(tinst->inline_depth());\n+\n+  const TypeInstPtr *loaded    = is_loaded() ? this  : tinst;\n+  const TypeInstPtr *unloaded  = is_loaded() ? tinst : this;\n+  if( loaded->klass()->equals(ciEnv::current()->Object_klass()) ) {\n+    \/\/\n+    \/\/ Meet unloaded class with java\/lang\/Object\n+    \/\/\n+    \/\/ Meet\n+    \/\/          |                     Unloaded Class\n+    \/\/  Object  |   TOP    |   AnyNull | Constant |   NotNull |  BOTTOM   |\n+    \/\/  ===================================================================\n+    \/\/   TOP    | ..........................Unloaded......................|\n+    \/\/  AnyNull |  U-AN    |................Unloaded......................|\n+    \/\/ Constant | ... O-NN .................................. |   O-BOT   |\n+    \/\/  NotNull | ... O-NN .................................. |   O-BOT   |\n+    \/\/  BOTTOM  | ........................Object-BOTTOM ..................|\n+    \/\/\n+    assert(loaded->ptr() != TypePtr::Null, \"insanity check\");\n+    \/\/\n+    if (loaded->ptr() == TypePtr::TopPTR)        { return unloaded; }\n+    else if (loaded->ptr() == TypePtr::AnyNull)  { return make(ptr, unloaded->klass(), interfaces, false, NULL, off, instance_id, speculative, depth); }\n+    else if (loaded->ptr() == TypePtr::BotPTR)   { return TypeInstPtr::BOTTOM; }\n+    else if (loaded->ptr() == TypePtr::Constant || loaded->ptr() == TypePtr::NotNull) {\n+      if (unloaded->ptr() == TypePtr::BotPTR)    { return TypeInstPtr::BOTTOM;  }\n+      else                                       { return TypeInstPtr::NOTNULL; }\n@@ -3819,0 +4020,1 @@\n+    else if (unloaded->ptr() == TypePtr::TopPTR) { return unloaded; }\n@@ -3820,6 +4022,9 @@\n-    \/\/ Both are unloaded, not the same class, not Object\n-    \/\/ Or meet unloaded with a different loaded class, not java\/lang\/Object\n-    if( ptr != TypePtr::BotPTR ) {\n-      return TypeInstPtr::NOTNULL;\n-    }\n-    return TypeInstPtr::BOTTOM;\n+    return unloaded->cast_to_ptr_type(TypePtr::AnyNull)->is_instptr();\n+  }\n+\n+  \/\/ Both are unloaded, not the same class, not Object\n+  \/\/ Or meet unloaded with a different loaded class, not java\/lang\/Object\n+  if (ptr != TypePtr::BotPTR) {\n+    return TypeInstPtr::NOTNULL;\n+  }\n+  return TypeInstPtr::BOTTOM;\n@@ -3878,1 +4083,1 @@\n-      return make(ptr, klass(), klass_is_exact(),\n+      return make(ptr, klass(), _interfaces, klass_is_exact(),\n@@ -3906,1 +4111,1 @@\n-      return make(ptr, klass(), klass_is_exact(),\n+      return make(ptr, klass(), _interfaces, klass_is_exact(),\n@@ -3940,0 +4145,2 @@\n+    InterfaceSet interfaces = meet_interfaces(tinst);\n+\n@@ -3942,2 +4149,0 @@\n-    bool tinst_xk = tinst->klass_is_exact();\n-    bool this_xk  = klass_is_exact();\n@@ -3948,1 +4153,2 @@\n-    MeetResult kind = meet_instptr(ptr, this_klass, tinst_klass, this_xk, tinst_xk, this->_ptr, tinst->_ptr, res_klass, res_xk);\n+    MeetResult kind = meet_instptr(ptr, interfaces, this, tinst, res_klass, res_xk);\n+\n@@ -3951,1 +4157,1 @@\n-      const TypeInstPtr* unloaded_meet = xmeet_unloaded(tinst);\n+      const TypeInstPtr* unloaded_meet = xmeet_unloaded(tinst, interfaces);\n@@ -3988,1 +4194,1 @@\n-      res = make(ptr, res_klass, res_xk, o, off, instance_id, speculative, depth);\n+      res = make(ptr, res_klass, interfaces, res_xk, o, off, instance_id, speculative, depth);\n@@ -3999,4 +4205,10 @@\n-TypePtr::MeetResult TypePtr::meet_instptr(PTR &ptr, ciKlass* this_klass, ciKlass* tinst_klass, bool this_xk, bool tinst_xk,\n-                                          PTR this_ptr,\n-                                          PTR tinst_ptr, ciKlass*&res_klass, bool &res_xk) {\n-\n+template<class T> TypePtr::MeetResult TypePtr::meet_instptr(PTR& ptr, InterfaceSet& interfaces, const T* this_type, const T* other_type,\n+                      ciKlass*& res_klass, bool& res_xk) {\n+  ciKlass* this_klass = this_type->klass();\n+  ciKlass* other_klass = other_type->klass();\n+  bool this_xk = this_type->klass_is_exact();\n+  bool other_xk = other_type->klass_is_exact();\n+  PTR this_ptr = this_type->ptr();\n+  PTR other_ptr = other_type->ptr();\n+  InterfaceSet this_interfaces = this_type->interfaces();\n+  InterfaceSet other_interfaces = other_type->interfaces();\n@@ -4007,1 +4219,1 @@\n-  if (ptr != Constant && this_klass->equals(tinst_klass) && this_xk == tinst_xk) {\n+  if (ptr != Constant && this_klass->equals(other_klass) && this_xk == other_xk) {\n@@ -4014,1 +4226,1 @@\n-  if (!tinst_klass->is_loaded() || !this_klass->is_loaded()) {\n+  if (!other_klass->is_loaded() || !this_klass->is_loaded()) {\n@@ -4018,41 +4230,0 @@\n-  \/\/ Handle mixing oops and interfaces first.\n-  if (this_klass->is_interface() && !(tinst_klass->is_interface() ||\n-                                      tinst_klass == ciEnv::current()->Object_klass())) {\n-    ciKlass *tmp = tinst_klass; \/\/ Swap interface around\n-    tinst_klass = this_klass;\n-    this_klass = tmp;\n-    bool tmp2 = tinst_xk;\n-    tinst_xk = this_xk;\n-    this_xk = tmp2;\n-  }\n-  if (tinst_klass->is_interface() &&\n-      !(this_klass->is_interface() ||\n-        \/\/ Treat java\/lang\/Object as an honorary interface,\n-        \/\/ because we need a bottom for the interface hierarchy.\n-        this_klass == ciEnv::current()->Object_klass())) {\n-    \/\/ Oop meets interface!\n-\n-    \/\/ See if the oop subtypes (implements) interface.\n-    if (this_klass->is_subtype_of(tinst_klass)) {\n-      \/\/ Oop indeed subtypes.  Now keep oop or interface depending\n-      \/\/ on whether we are both above the centerline or either is\n-      \/\/ below the centerline.  If we are on the centerline\n-      \/\/ (e.g., Constant vs. AnyNull interface), use the constant.\n-      res_klass  = below_centerline(ptr) ? tinst_klass : this_klass;\n-      \/\/ If we are keeping this_klass, keep its exactness too.\n-      res_xk = below_centerline(ptr) ? tinst_xk    : this_xk;\n-      return SUBTYPE;\n-    } else {                  \/\/ Does not implement, fall to Object\n-      \/\/ Oop does not implement interface, so mixing falls to Object\n-      \/\/ just like the verifier does (if both are above the\n-      \/\/ centerline fall to interface)\n-      res_klass = above_centerline(ptr) ? tinst_klass : ciEnv::current()->Object_klass();\n-      res_xk = above_centerline(ptr) ? tinst_xk : false;\n-      \/\/ Watch out for Constant vs. AnyNull interface.\n-      if (ptr == Constant)  ptr = NotNull;   \/\/ forget it was a constant\n-      return NOT_SUBTYPE;\n-    }\n-  }\n-\n-  \/\/ Either oop vs oop or interface vs interface or interface vs Object\n-\n@@ -4084,1 +4255,1 @@\n-  ciKlass *subtype = NULL;\n+  const T* subtype = NULL;\n@@ -4086,5 +4257,7 @@\n-  if (tinst_klass->equals(this_klass)) {\n-    subtype = this_klass;\n-    subtype_exact = below_centerline(ptr) ? (this_xk && tinst_xk) : (this_xk || tinst_xk);\n-  } else if (!tinst_xk && this_klass->is_subtype_of(tinst_klass)) {\n-    subtype = this_klass;     \/\/ Pick subtyping class\n+  InterfaceSet subtype_interfaces;\n+\n+  if (this_type->is_same_java_type_as(other_type)) {\n+    subtype = this_type;\n+    subtype_exact = below_centerline(ptr) ? (this_xk && other_xk) : (this_xk || other_xk);\n+  } else if (!other_xk && this_type->is_meet_subtype_of(other_type)) {\n+    subtype = this_type;     \/\/ Pick subtyping class\n@@ -4092,3 +4265,3 @@\n-  } else if (!this_xk && tinst_klass->is_subtype_of(this_klass)) {\n-    subtype = tinst_klass;    \/\/ Pick subtyping class\n-    subtype_exact = tinst_xk;\n+  } else if(!this_xk && other_type->is_meet_subtype_of(this_type)) {\n+    subtype = other_type;    \/\/ Pick subtyping class\n+    subtype_exact = other_xk;\n@@ -4099,8 +4272,8 @@\n-      this_klass = tinst_klass = subtype;\n-      this_xk = tinst_xk = subtype_exact;\n-    } else if (above_centerline(this_ptr) && !above_centerline(tinst_ptr)) {\n-      this_klass = tinst_klass; \/\/ tinst is down; keep down man\n-      this_xk = tinst_xk;\n-    } else if (above_centerline(tinst_ptr) && !above_centerline(this_ptr)) {\n-      tinst_klass = this_klass; \/\/ this is down; keep down man\n-      tinst_xk = this_xk;\n+      this_type = other_type = subtype;\n+      this_xk = other_xk = subtype_exact;\n+    } else if (above_centerline(this_ptr) && !above_centerline(other_ptr)) {\n+      this_type = other_type; \/\/ tinst is down; keep down man\n+      this_xk = other_xk;\n+    } else if (above_centerline(other_ptr) && !above_centerline(this_ptr)) {\n+      other_type = this_type; \/\/ this is down; keep down man\n+      other_xk = this_xk;\n@@ -4113,1 +4286,1 @@\n-  if (tinst_klass->equals(this_klass)) {\n+  if (this_type->is_same_java_type_as(other_type)) {\n@@ -4117,1 +4290,1 @@\n-    res_klass = this_klass;\n+    res_klass = this_type->klass();\n@@ -4128,0 +4301,2 @@\n+  interfaces = this_interfaces.intersection_with(other_interfaces);\n+\n@@ -4129,1 +4304,1 @@\n-  ciKlass* k = this_klass->least_common_ancestor(tinst_klass);\n+  ciKlass* k = this_klass->least_common_ancestor(other_klass);\n@@ -4137,1 +4312,0 @@\n-\n@@ -4154,1 +4328,1 @@\n-  return new TypeInstPtr(dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());\n+  return new TypeInstPtr(dual_ptr(), klass(), _interfaces, klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());\n@@ -4163,0 +4337,1 @@\n+    _interfaces.eq(p->_interfaces) &&\n@@ -4169,1 +4344,1 @@\n-  int hash = java_add((jint)klass()->hash(), (jint)TypeOopPtr::hash());\n+  int hash = java_add(java_add((jint)klass()->hash(), (jint)TypeOopPtr::hash()), _interfaces.hash());\n@@ -4174,20 +4349,1 @@\n-  if (!is_loaded() || !other->is_loaded()) {\n-    return false;\n-  }\n-  if (!other->isa_instptr()) {\n-    return false;\n-  }\n-\n-  if (!other_exact) {\n-    return false;\n-  }\n-\n-  if (other->klass()->equals(ciEnv::current()->Object_klass())) {\n-    return true;\n-  }\n-\n-  if (!this_exact && klass()->is_interface()) {\n-    return false;\n-  }\n-\n-  return _klass->is_subtype_of(other->klass());\n+  return TypePtr::is_java_subtype_of_helper_for_instance(this, other, this_exact, other_exact);\n@@ -4196,8 +4352,3 @@\n-bool TypeInstPtr::is_same_java_type_as(const TypeOopPtr* other) const {\n-  if (!is_loaded() || !other->is_loaded()) {\n-    return false;\n-  }\n-  if (!other->isa_instptr()) {\n-    return false;\n-  }\n-  return _klass->equals(other->_klass);\n+\n+bool TypeInstPtr::is_same_java_type_as_helper(const TypeOopPtr* other) const {\n+  return TypePtr::is_same_java_type_as_helper_for_instance(this, other);\n@@ -4207,27 +4358,1 @@\n-  if (!is_loaded() || !other->is_loaded()) {\n-    return true;\n-  }\n-\n-  if (other->isa_aryptr()) {\n-    return !this_exact && (_klass->equals(ciEnv::current()->Object_klass()) || _klass->is_interface());\n-  }\n-\n-  if ((_klass->is_interface() && !this_exact) || (other->klass()->is_interface() \/*&& !other_exact*\/)) {\n-    return true;\n-  }\n-\n-  assert(other->isa_instptr(), \"unsupported\");\n-\n-  if (this_exact && other_exact) {\n-    return is_java_subtype_of(other);\n-  }\n-\n-  if (!_klass->is_subtype_of(other->_klass) && !other->_klass->is_subtype_of(_klass)) {\n-    return false;\n-  }\n-\n-  if (this_exact) {\n-    return _klass->is_subtype_of(other->_klass);\n-  }\n-\n-  return true;\n+  return TypePtr::maybe_java_subtype_of_helper_for_instance(this, other, this_exact, other_exact);\n@@ -4243,0 +4368,1 @@\n+  _interfaces.dump(st);\n@@ -4292,1 +4418,1 @@\n-  return make(_ptr, klass(), klass_is_exact(), const_oop(), xadd_offset(offset),\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), xadd_offset(offset),\n@@ -4297,1 +4423,1 @@\n-  return make(_ptr, klass(), klass_is_exact(), const_oop(), offset,\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), offset,\n@@ -4306,1 +4432,1 @@\n-  return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset,\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset,\n@@ -4310,1 +4436,1 @@\n-const TypePtr *TypeInstPtr::with_inline_depth(int depth) const {\n+const TypePtr* TypeInstPtr::with_inline_depth(int depth) const {\n@@ -4314,1 +4440,1 @@\n-  return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, _instance_id, _speculative, depth);\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset, _instance_id, _speculative, depth);\n@@ -4317,1 +4443,1 @@\n-const TypePtr *TypeInstPtr::with_instance_id(int instance_id) const {\n+const TypePtr* TypeInstPtr::with_instance_id(int instance_id) const {\n@@ -4319,1 +4445,1 @@\n-  return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, instance_id, _speculative, _inline_depth);\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset, instance_id, _speculative, _inline_depth);\n@@ -4325,5 +4451,59 @@\n-  if (try_for_exact && !xk && !ik->has_subklass() && !ik->is_final() && !ik->is_interface()) {\n-    Compile* C = Compile::current();\n-    Dependencies* deps = C->dependencies();\n-    deps->assert_leaf_type(ik);\n-    xk = true;\n+  if (try_for_exact && !xk && !ik->has_subklass() && !ik->is_final()) {\n+    ciKlass* k = ik;\n+    TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n+    assert(k == ik, \"\");\n+    if (interfaces.eq(_interfaces)) {\n+      Compile *C = Compile::current();\n+      Dependencies* deps = C->dependencies();\n+      deps->assert_leaf_type(ik);\n+      xk = true;\n+    }\n+  }\n+  return TypeInstKlassPtr::make(xk ? TypePtr::Constant : TypePtr::NotNull, klass(), _interfaces, 0);\n+}\n+\n+template <class T1, class T2> bool TypePtr::is_meet_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_xk, bool other_xk) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+\n+  if (!this_one->is_instance_type(other)) {\n+    return false;\n+  }\n+\n+  if (other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.empty()) {\n+    return true;\n+  }\n+\n+  return this_one->klass()->is_subtype_of(other->klass()) &&\n+         (!this_xk || this_one->_interfaces.contains(other->_interfaces));\n+}\n+\n+\n+bool TypeInstPtr::is_meet_subtype_of_helper(const TypeOopPtr *other, bool this_xk, bool other_xk) const {\n+  return TypePtr::is_meet_subtype_of_helper_for_instance(this, other, this_xk, other_xk);\n+}\n+\n+template <class T1, class T2>  bool TypePtr::is_meet_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_xk, bool other_xk) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+  if (other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.empty()) {\n+    return true;\n+  }\n+\n+  if (this_one->is_instance_type(other)) {\n+    return other->klass() == ciEnv::current()->Object_klass() && this_one->_interfaces.contains(other->_interfaces);\n+  }\n+\n+  int dummy;\n+  bool this_top_or_bottom = (this_one->base_element_type(dummy) == Type::TOP || this_one->base_element_type(dummy) == Type::BOTTOM);\n+  if (this_top_or_bottom) {\n+    return false;\n+  }\n+\n+  const T1* other_ary = this_one->is_array_type(other);\n+  const TypePtr* other_elem = other_ary->elem()->make_ptr();\n+  const TypePtr* this_elem = this_one->elem()->make_ptr();\n+  if (other_elem != NULL && this_elem != NULL) {\n+    return this_one->is_reference_type(this_elem)->is_meet_subtype_of_helper(this_one->is_reference_type(other_elem), this_xk, other_xk);\n+  }\n+\n+  if (other_elem == NULL && this_elem == NULL) {\n+    return this_one->_klass->is_subtype_of(other->_klass);\n@@ -4331,1 +4511,14 @@\n-  return TypeInstKlassPtr::make(xk ? TypePtr::Constant : TypePtr::NotNull, klass(), 0);\n+\n+  return false;\n+}\n+\n+bool TypeAryPtr::is_meet_subtype_of_helper(const TypeOopPtr *other, bool this_xk, bool other_xk) const {\n+  return TypePtr::is_meet_subtype_of_helper_for_array(this, other, this_xk, other_xk);\n+}\n+\n+bool TypeInstKlassPtr::is_meet_subtype_of_helper(const TypeKlassPtr *other, bool this_xk, bool other_xk) const {\n+  return TypePtr::is_meet_subtype_of_helper_for_instance(this, other, this_xk, other_xk);\n+}\n+\n+bool TypeAryKlassPtr::is_meet_subtype_of_helper(const TypeKlassPtr *other, bool this_xk, bool other_xk) const {\n+  return TypePtr::is_meet_subtype_of_helper_for_array(this, other, this_xk, other_xk);\n@@ -4354,0 +4547,4 @@\n+  if (k != NULL && k->is_loaded() && k->is_obj_array_klass() &&\n+      k->as_obj_array_klass()->base_element_klass()->is_interface()) {\n+    k = NULL;\n+  }\n@@ -4366,0 +4563,4 @@\n+  if (k != NULL && k->is_loaded() && k->is_obj_array_klass() &&\n+      k->as_obj_array_klass()->base_element_klass()->is_interface()) {\n+    k = NULL;\n+  }\n@@ -4393,1 +4594,1 @@\n-  if (!is_java_primitive(etype) && !is_reference_type(etype)) {\n+  if (!is_java_primitive(etype) && !::is_reference_type(etype)) {\n@@ -4501,22 +4702,1 @@\n-  if (other->klass() == ciEnv::current()->Object_klass() && other_exact) {\n-    return true;\n-  }\n-\n-  if (!is_loaded() || !other->is_loaded() || other->klass() == NULL || klass() == NULL) {\n-    return false;\n-  }\n-  if (other->isa_instptr()) {\n-    return _klass->is_subtype_of(other->_klass) && other_exact;\n-  }\n-  if (klass() == NULL) {\n-    return false;\n-  }\n-  assert(other->isa_aryptr(), \"\");\n-  const TypeAryPtr* other_ary = other->isa_aryptr();\n-  if (other_ary->elem()->make_oopptr() && elem()->make_oopptr()) {\n-    return elem()->make_oopptr()->is_java_subtype_of_helper(other_ary->elem()->make_oopptr(), this_exact, other_exact);\n-  }\n-  if (!other_ary->elem()->make_oopptr() && !elem()->make_oopptr()) {\n-    return _klass->is_subtype_of(other->_klass);\n-  }\n-  return false;\n+  return TypePtr::is_java_subtype_of_helper_for_array(this, other, this_exact, other_exact);\n@@ -4525,13 +4705,2 @@\n-bool TypeAryPtr::is_same_java_type_as(const TypeOopPtr* other) const {\n-  if (!other->isa_aryptr() ||\n-      !is_loaded() || !other->is_loaded() || klass() == NULL || other->klass() == NULL) {\n-    return false;\n-  }\n-  const TypeAryPtr* other_ary = other->isa_aryptr();\n-  if (other_ary->elem()->make_oopptr() && elem()->make_oopptr()) {\n-    return elem()->make_oopptr()->is_same_java_type_as(other_ary->elem()->make_oopptr());\n-  }\n-  if (!other_ary->elem()->make_oopptr() && !elem()->make_oopptr()) {\n-    return _klass->equals(other->_klass);\n-  }\n-  return false;\n+bool TypeAryPtr::is_same_java_type_as_helper(const TypeOopPtr* other) const {\n+  return TypePtr::is_same_java_type_as_helper_for_array(this, other);\n@@ -4541,25 +4710,1 @@\n-  if (other->klass() == ciEnv::current()->Object_klass()) {\n-    return true;\n-  }\n-\n-  if (!is_loaded() || !other->is_loaded() || klass() == NULL || other->klass() == NULL) {\n-    return true;\n-  }\n-  if (other->isa_instptr()) {\n-    return (!other_exact && other->_klass->is_interface()) || _klass->is_subtype_of(other->_klass);\n-  }\n-  assert(other->isa_aryptr(), \"\");\n-\n-  if (this_exact && other_exact) {\n-    return is_java_subtype_of(other);\n-  }\n-\n-  const TypeAryPtr* other_ary = other->isa_aryptr();\n-  if (other_ary->elem()->make_oopptr() && elem()->make_oopptr()) {\n-    return elem()->make_oopptr()->maybe_java_subtype_of_helper(other_ary->elem()->make_oopptr(), this_exact,\n-                                                               other_exact);\n-  }\n-  if (!other_ary->elem()->make_oopptr() && !elem()->make_oopptr()) {\n-    return _klass->is_subtype_of(other->_klass);\n-  }\n-  return false;\n+  return TypePtr::maybe_java_subtype_of_helper_for_array(this, other, this_exact, other_exact);\n@@ -4660,1 +4805,1 @@\n-    if (meet_aryptr(ptr, elem, this->klass(), tap->klass(), this->klass_is_exact(), tap->klass_is_exact(), this->ptr(), tap->ptr(), res_klass, res_xk) == NOT_SUBTYPE) {\n+    if (meet_aryptr(ptr, elem, this, tap, res_klass, res_xk) == NOT_SUBTYPE) {\n@@ -4690,0 +4835,4 @@\n+    InterfaceSet interfaces = meet_interfaces(tp);\n+    InterfaceSet tp_interfaces = tp->_interfaces;\n+    InterfaceSet this_interfaces = _interfaces;\n+\n@@ -4696,2 +4845,2 @@\n-      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact()) {\n-        return make(ptr, _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);\n+      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces.contains(tp_interfaces) && !tp->klass_is_exact()) {\n+        return TypeAryPtr::make(ptr, _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);\n@@ -4702,1 +4851,2 @@\n-        return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), false, NULL,offset, instance_id, speculative, depth);\n+        interfaces = this_interfaces.intersection_with(tp_interfaces);\n+        return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, false, NULL,offset, instance_id, speculative, depth);\n@@ -4714,1 +4864,1 @@\n-        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact()) {\n+        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces.contains(tp_interfaces) && !tp->klass_is_exact()) {\n@@ -4728,1 +4878,2 @@\n-      return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), false, NULL, offset, instance_id, speculative, depth);\n+      interfaces = this_interfaces.intersection_with(tp_interfaces);\n+      return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, false, NULL, offset, instance_id, speculative, depth);\n@@ -4737,1 +4888,11 @@\n-TypePtr::MeetResult TypePtr::meet_aryptr(PTR& ptr, const Type*& elem, ciKlass* this_klass, ciKlass* tap_klass, bool this_xk, bool tap_xk, PTR this_ptr, PTR tap_ptr, ciKlass*& res_klass, bool& res_xk) {\n+template<class T> TypePtr::MeetResult TypePtr::meet_aryptr(PTR& ptr, const Type*& elem, const T* this_ary,\n+                                                           const T* other_ary, ciKlass*& res_klass, bool& res_xk) {\n+  int dummy;\n+  bool this_top_or_bottom = (this_ary->base_element_type(dummy) == Type::TOP || this_ary->base_element_type(dummy) == Type::BOTTOM);\n+  bool other_top_or_bottom = (other_ary->base_element_type(dummy) == Type::TOP || other_ary->base_element_type(dummy) == Type::BOTTOM);\n+  ciKlass* this_klass = this_ary->klass();\n+  ciKlass* other_klass = other_ary->klass();\n+  bool this_xk = this_ary->klass_is_exact();\n+  bool other_xk = other_ary->klass_is_exact();\n+  PTR this_ptr = this_ary->ptr();\n+  PTR other_ptr = other_ary->ptr();\n@@ -4743,3 +4904,3 @@\n-    if (this_klass == NULL)\n-      res_klass = tap_klass;\n-    else if (tap_klass == NULL || tap_klass == this_klass) {\n+    if (this_top_or_bottom)\n+      res_klass = other_klass;\n+    else if (other_top_or_bottom || other_klass == this_klass) {\n@@ -4754,1 +4915,1 @@\n-  } else \/\/ Non integral arrays.\n+  } else {\/\/ Non integral arrays.\n@@ -4757,1 +4918,1 @@\n-    if ((above_centerline(ptr) || ptr == Constant) && this_klass != tap_klass &&\n+    if ((above_centerline(ptr) || ptr == Constant) && !this_ary->is_same_java_type_as(other_ary) &&\n@@ -4759,1 +4920,1 @@\n-        tap_klass != NULL  && this_klass != NULL   &&\n+        !this_top_or_bottom && !other_top_or_bottom &&\n@@ -4761,1 +4922,1 @@\n-        ((tap_xk && this_xk) ||\n+        ((other_xk && this_xk) ||\n@@ -4763,1 +4924,1 @@\n-         (tap_xk && !tap_klass->is_subtype_of(this_klass)) ||\n+         (other_xk && !other_ary->is_meet_subtype_of(this_ary)) ||\n@@ -4765,1 +4926,1 @@\n-         (this_xk && !this_klass->is_subtype_of(tap_klass)))) {\n+         (this_xk && !this_ary->is_meet_subtype_of(other_ary)))) {\n@@ -4773,0 +4934,1 @@\n+  }\n@@ -4775,1 +4937,1 @@\n-  switch (tap_ptr) {\n+  switch (other_ptr) {\n@@ -4782,1 +4944,1 @@\n-        res_xk = (tap_xk || this_xk);\n+        res_xk = (other_xk || this_xk);\n@@ -4792,1 +4954,1 @@\n-        res_xk = this_xk && (this_klass == tap_klass);\n+        res_xk = this_xk && (this_ary->is_same_java_type_as(other_ary) || (this_top_or_bottom && other_top_or_bottom));\n@@ -4800,1 +4962,1 @@\n-        res_xk = tap_xk;\n+        res_xk = other_xk;\n@@ -4802,2 +4964,2 @@\n-        res_xk = (tap_xk && this_xk) &&\n-          (this_klass == tap_klass); \/\/ Only precise for identical arrays\n+        res_xk = (other_xk && this_xk) &&\n+                 (this_ary->is_same_java_type_as(other_ary) || (this_top_or_bottom && other_top_or_bottom)); \/\/ Only precise for identical arrays\n@@ -4821,11 +4983,0 @@\n-\/\/----------------------interface_vs_oop---------------------------------------\n-#ifdef ASSERT\n-bool TypeAryPtr::interface_vs_oop(const Type *t) const {\n-  const TypeAryPtr* t_aryptr = t->isa_aryptr();\n-  if (t_aryptr) {\n-    return _ary->interface_vs_oop(t_aryptr->_ary);\n-  }\n-  return false;\n-}\n-#endif\n-\n@@ -4836,0 +4987,2 @@\n+  _interfaces.dump(st);\n+\n@@ -4888,1 +5041,1 @@\n-const TypePtr *TypeAryPtr::add_offset(intptr_t offset) const {\n+const TypePtr* TypeAryPtr::add_offset(intptr_t offset) const {\n@@ -4908,1 +5061,1 @@\n-const TypePtr *TypeAryPtr::with_inline_depth(int depth) const {\n+const TypePtr* TypeAryPtr::with_inline_depth(int depth) const {\n@@ -4915,1 +5068,1 @@\n-const TypePtr *TypeAryPtr::with_instance_id(int instance_id) const {\n+const TypePtr* TypeAryPtr::with_instance_id(int instance_id) const {\n@@ -5100,1 +5253,1 @@\n-const TypePtr *TypeMetadataPtr::add_offset( intptr_t offset ) const {\n+const TypePtr* TypeMetadataPtr::add_offset( intptr_t offset ) const {\n@@ -5275,1 +5428,1 @@\n-const TypeKlassPtr* TypeKlassPtr::make(ciKlass *klass) {\n+const TypeKlassPtr* TypeKlassPtr::make(ciKlass *klass, InterfaceHandling interface_handling) {\n@@ -5277,1 +5430,1 @@\n-    return TypeInstKlassPtr::make(klass);\n+    return TypeInstKlassPtr::make(klass, interface_handling);\n@@ -5279,1 +5432,1 @@\n-  return TypeAryKlassPtr::make(klass);\n+  return TypeAryKlassPtr::make(klass, interface_handling);\n@@ -5282,1 +5435,1 @@\n-const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* klass, int offset) {\n+const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* klass, int offset, InterfaceHandling interface_handling) {\n@@ -5284,1 +5437,2 @@\n-    return TypeInstKlassPtr::make(ptr, klass, offset);\n+    const InterfaceSet interfaces = TypePtr::interfaces(klass, true, true, false, interface_handling);\n+    return TypeInstKlassPtr::make(ptr, klass, interfaces, offset);\n@@ -5286,1 +5440,1 @@\n-  return TypeAryKlassPtr::make(ptr, klass, offset);\n+  return TypeAryKlassPtr::make(ptr, klass, offset, interface_handling);\n@@ -5291,2 +5445,4 @@\n-TypeKlassPtr::TypeKlassPtr(TYPES t, PTR ptr, ciKlass* klass, int offset)\n-  : TypePtr(t, ptr, offset), _klass(klass) {\n+TypeKlassPtr::TypeKlassPtr(TYPES t, PTR ptr, ciKlass* klass, const InterfaceSet& interfaces, int offset)\n+  : TypePtr(t, ptr, offset), _klass(klass), _interfaces(interfaces) {\n+  assert(klass == NULL || !klass->is_loaded() || (klass->is_instance_klass() && !klass->is_interface()) ||\n+         klass->is_type_array_klass() || !klass->as_obj_array_klass()->base_element_klass()->is_interface(), \"no interface here\");\n@@ -5295,0 +5451,1 @@\n+\/\/ Is there a single ciKlass* that can represent that type?\n@@ -5296,1 +5453,12 @@\n-  return _klass;\n+  assert(_klass->is_instance_klass() && !_klass->is_interface(), \"No interface\");\n+  if (_interfaces.empty()) {\n+    return _klass;\n+  }\n+  if (_klass != ciEnv::current()->Object_klass()) {\n+    ciKlass* k = _klass;\n+    if (_interfaces.eq(TypePtr::interfaces(k, true, false, true, ignore_interfaces))) {\n+      return _klass;\n+    }\n+    return NULL;\n+  }\n+  return _interfaces.exact_klass();\n@@ -5304,0 +5472,1 @@\n+    _interfaces.eq(p->_interfaces) &&\n@@ -5310,1 +5479,1 @@\n-  return TypePtr::hash();\n+  return java_add((jint)TypePtr::hash(), _interfaces.hash());\n@@ -5331,3 +5500,0 @@\n-    if (!empty() && ktkp != NULL && ktkp->klass()->is_loaded() && ktkp->klass()->is_interface())\n-      return kills;             \/\/ Uplift to interface\n-\n@@ -5337,9 +5503,0 @@\n-  \/\/ Interface klass type could be exact in opposite to interface type,\n-  \/\/ return it here instead of incorrect Constant ptr J\/L\/Object (6894807).\n-  if (ftkp != NULL && ktkp != NULL &&\n-      ftkp->is_loaded() &&  ftkp->klass()->is_interface() &&\n-      !ftkp->klass_is_exact() && \/\/ Keep exact interface klass\n-      ktkp->is_loaded() && !ktkp->klass()->is_interface()) {\n-    return ktkp->cast_to_ptr_type(ftkp->ptr());\n-  }\n-\n@@ -5349,0 +5506,11 @@\n+TypePtr::InterfaceSet TypeKlassPtr::meet_interfaces(const TypeKlassPtr* other) const {\n+  if (above_centerline(_ptr) && above_centerline(other->_ptr)) {\n+    return _interfaces.union_with(other->_interfaces);\n+  } else if (above_centerline(_ptr) && !above_centerline(other->_ptr)) {\n+    return other->_interfaces;\n+  } else if (above_centerline(other->_ptr) && !above_centerline(_ptr)) {\n+    return _interfaces;\n+  }\n+  return _interfaces.intersection_with(other->_interfaces);\n+}\n+\n@@ -5386,0 +5554,1 @@\n+      _interfaces.dump(st);\n@@ -5426,1 +5595,1 @@\n-const TypeInstKlassPtr *TypeInstKlassPtr::make(PTR ptr, ciKlass* k, int offset) {\n+const TypeInstKlassPtr *TypeInstKlassPtr::make(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, int offset) {\n@@ -5428,1 +5597,1 @@\n-    (TypeInstKlassPtr*)(new TypeInstKlassPtr(ptr, k, offset))->hashcons();\n+    (TypeInstKlassPtr*)(new TypeInstKlassPtr(ptr, k, interfaces, offset))->hashcons();\n@@ -5435,2 +5604,2 @@\n-const TypePtr *TypeInstKlassPtr::add_offset( intptr_t offset ) const {\n-  return make( _ptr, klass(), xadd_offset(offset) );\n+const TypePtr* TypeInstKlassPtr::add_offset( intptr_t offset ) const {\n+  return make( _ptr, klass(), _interfaces, xadd_offset(offset) );\n@@ -5440,1 +5609,1 @@\n-  return make(_ptr, klass(), offset);\n+  return make(_ptr, klass(), _interfaces, offset);\n@@ -5447,1 +5616,1 @@\n-  return make(ptr, _klass, _offset);\n+  return make(ptr, _klass, _interfaces, _offset);\n@@ -5463,1 +5632,1 @@\n-  return make(klass_is_exact ? Constant : NotNull, k, _offset);\n+  return make(klass_is_exact ? Constant : NotNull, k, _interfaces, _offset);\n@@ -5478,0 +5647,1 @@\n+  TypePtr::InterfaceSet interfaces = _interfaces;\n@@ -5486,3 +5656,8 @@\n-        deps->assert_abstract_with_unique_concrete_subtype(ik, sub);\n-        k = ik = sub;\n-        xk = sub->is_final();\n+        ciKlass* sub_k = sub;\n+        TypePtr::InterfaceSet sub_interfaces = TypePtr::interfaces(sub_k, true, false, false, ignore_interfaces);\n+        assert(sub_k == sub, \"\");\n+        if (sub_interfaces.eq(_interfaces)) {\n+          deps->assert_abstract_with_unique_concrete_subtype(ik, sub);\n+          k = ik = sub;\n+          xk = sub->is_final();\n+        }\n@@ -5492,1 +5667,1 @@\n-  return TypeInstPtr::make(TypePtr::BotPTR, k, xk, NULL, 0);\n+  return TypeInstPtr::make(TypePtr::BotPTR, k, interfaces, xk, NULL, 0);\n@@ -5533,1 +5708,1 @@\n-      return make( ptr, klass(), offset );\n+      return make( ptr, klass(), _interfaces, offset );\n@@ -5568,4 +5743,1 @@\n-    ciKlass* tkls_klass = tkls->klass();\n-    ciKlass* this_klass  = klass();\n-    bool tkls_xk = tkls->klass_is_exact();\n-    bool this_xk  = klass_is_exact();\n+    InterfaceSet interfaces = meet_interfaces(tkls);\n@@ -5575,1 +5747,1 @@\n-    switch(meet_instptr(ptr, this_klass, tkls_klass, this_xk, tkls_xk, this->_ptr, tkls->_ptr, res_klass, res_xk)) {\n+    switch(meet_instptr(ptr, interfaces, this, tkls, res_klass, res_xk)) {\n@@ -5583,2 +5755,2 @@\n-        const Type* res1 = make(ptr, res_klass, off);\n-        return res1;\n+        const Type* res = make(ptr, res_klass, interfaces, off);\n+        return res;\n@@ -5594,0 +5766,3 @@\n+    InterfaceSet interfaces = meet_interfaces(tp);\n+    InterfaceSet tp_interfaces = tp->_interfaces;\n+    InterfaceSet this_interfaces = _interfaces;\n@@ -5601,1 +5776,1 @@\n-      if (klass()->equals(ciEnv::current()->Object_klass()) && !klass_is_exact()) {\n+      if (klass()->equals(ciEnv::current()->Object_klass()) && tp_interfaces.contains(this_interfaces) && !klass_is_exact()) {\n@@ -5606,1 +5781,2 @@\n-        return make(ptr, ciEnv::current()->Object_klass(), offset);\n+        interfaces = _interfaces.intersection_with(tp->_interfaces);\n+        return make(ptr, ciEnv::current()->Object_klass(), interfaces, offset);\n@@ -5618,1 +5794,1 @@\n-        if (klass()->equals(ciEnv::current()->Object_klass())) {\n+        if (klass()->equals(ciEnv::current()->Object_klass()) && tp_interfaces.contains(this_interfaces) && !klass_is_exact()) {\n@@ -5628,1 +5804,2 @@\n-      return make(ptr, ciEnv::current()->Object_klass(), offset);\n+      interfaces = this_interfaces.intersection_with(tp_interfaces);\n+      return make(ptr, ciEnv::current()->Object_klass(), interfaces, offset);\n@@ -5640,1 +5817,1 @@\n-  return new TypeInstKlassPtr(dual_ptr(), klass(), dual_offset());\n+  return new TypeInstKlassPtr(dual_ptr(), klass(), _interfaces, dual_offset());\n@@ -5643,2 +5820,3 @@\n-bool TypeInstKlassPtr::is_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n-  if (!is_loaded() || !other->is_loaded()) {\n+template <class T1, class T2> bool TypePtr::is_java_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_exact, bool other_exact) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+  if (!this_one->is_loaded() || !other->is_loaded()) {\n@@ -5647,1 +5825,1 @@\n-  if (!other->isa_instklassptr()) {\n+  if (!this_one->is_instance_type(other)) {\n@@ -5655,1 +5833,1 @@\n-  if (other->_klass->equals(ciEnv::current()->Object_klass())) {\n+  if (other->klass()->equals(ciEnv::current()->Object_klass()) && other->_interfaces.empty()) {\n@@ -5659,3 +5837,2 @@\n-  if (!this_exact && klass()->is_interface()) {\n-    return false;\n-  }\n+  return this_one->_klass->is_subtype_of(other->_klass) && this_one->_interfaces.contains(other->_interfaces);\n+}\n@@ -5663,1 +5840,2 @@\n-  return _klass->is_subtype_of(other->_klass);\n+bool TypeInstKlassPtr::is_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n+  return TypePtr::is_java_subtype_of_helper_for_instance(this, other, this_exact, other_exact);\n@@ -5666,2 +5844,3 @@\n-bool TypeInstKlassPtr::is_same_java_type_as(const TypeKlassPtr* other) const {\n-  if (!is_loaded() || !other->is_loaded()) {\n+template <class T1, class T2> bool TypePtr::is_same_java_type_as_helper_for_instance(const T1* this_one, const T2* other) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+  if (!this_one->is_loaded() || !other->is_loaded()) {\n@@ -5670,1 +5849,1 @@\n-  if (!other->isa_instklassptr()) {\n+  if (!this_one->is_instance_type(other)) {\n@@ -5673,1 +5852,1 @@\n-  return _klass->equals(other->_klass);\n+  return this_one->_klass->equals(other->_klass) && this_one->_interfaces.eq(other->_interfaces);\n@@ -5676,4 +5855,3 @@\n-bool TypeInstKlassPtr::maybe_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n-  if (!is_loaded() || !other->is_loaded()) {\n-    return true;\n-  }\n+bool TypeInstKlassPtr::is_same_java_type_as_helper(const TypeKlassPtr* other) const {\n+  return TypePtr::is_same_java_type_as_helper_for_instance(this, other);\n+}\n@@ -5681,2 +5859,4 @@\n-  if (other->isa_aryklassptr()) {\n-    return !this_exact && (_klass->equals(ciEnv::current()->Object_klass()) || _klass->is_interface());\n+template <class T1, class T2> bool TypePtr::maybe_java_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_exact, bool other_exact) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+  if (!this_one->is_loaded() || !other->is_loaded()) {\n+    return true;\n@@ -5685,2 +5865,2 @@\n-  if ((_klass->is_interface() && !this_exact) || (other->klass()->is_interface() \/*&& !other_exact*\/)) {\n-    return true;\n+  if (this_one->is_array_type(other)) {\n+    return !this_exact && this_one->_klass->equals(ciEnv::current()->Object_klass())  && other->_interfaces.contains(this_one->_interfaces);\n@@ -5689,1 +5869,1 @@\n-  assert(other->isa_instklassptr(), \"unsupported\");\n+  assert(this_one->is_instance_type(other), \"unsupported\");\n@@ -5692,1 +5872,1 @@\n-    return is_java_subtype_of(other);\n+    return this_one->is_java_subtype_of(other);\n@@ -5695,1 +5875,1 @@\n-  if (!_klass->is_subtype_of(other->_klass) && !other->_klass->is_subtype_of(_klass)) {\n+  if (!this_one->_klass->is_subtype_of(other->_klass) && !other->_klass->is_subtype_of(this_one->_klass)) {\n@@ -5700,1 +5880,1 @@\n-    return _klass->is_subtype_of(other->_klass);\n+    return this_one->_klass->is_subtype_of(other->_klass) && this_one->_interfaces.contains(other->_interfaces);\n@@ -5706,0 +5886,36 @@\n+bool TypeInstKlassPtr::maybe_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n+  return TypePtr::maybe_java_subtype_of_helper_for_instance(this, other, this_exact, other_exact);\n+}\n+\n+const TypeKlassPtr* TypeInstKlassPtr::try_improve() const {\n+  if (!UseUniqueSubclasses) {\n+    return this;\n+  }\n+  ciKlass* k = klass();\n+  Compile* C = Compile::current();\n+  Dependencies* deps = C->dependencies();\n+  assert((deps != NULL) == (C->method() != NULL && C->method()->code_size() > 0), \"sanity\");\n+  TypePtr::InterfaceSet interfaces = _interfaces;\n+  if (k->is_loaded()) {\n+    ciInstanceKlass* ik = k->as_instance_klass();\n+    bool klass_is_exact = ik->is_final();\n+    if (!klass_is_exact &&\n+        deps != NULL) {\n+      ciInstanceKlass* sub = ik->unique_concrete_subklass();\n+      if (sub != NULL) {\n+        ciKlass *sub_k = sub;\n+        TypePtr::InterfaceSet sub_interfaces = TypePtr::interfaces(sub_k, true, false, false, ignore_interfaces);\n+        assert(sub_k == sub, \"\");\n+        if (sub_interfaces.eq(_interfaces)) {\n+          deps->assert_abstract_with_unique_concrete_subtype(ik, sub);\n+          k = ik = sub;\n+          klass_is_exact = sub->is_final();\n+          return TypeKlassPtr::make(klass_is_exact ? Constant : _ptr, k, _offset);\n+        }\n+      }\n+    }\n+  }\n+  return this;\n+}\n+\n+\n@@ -5710,2 +5926,2 @@\n-const TypeAryKlassPtr *TypeAryKlassPtr::make(PTR ptr, ciKlass* klass, int offset) {\n-  if (klass->is_obj_array_klass()) {\n+const TypeAryKlassPtr *TypeAryKlassPtr::make(PTR ptr, ciKlass* k, int offset, InterfaceHandling interface_handling) {\n+  if (k->is_obj_array_klass()) {\n@@ -5713,2 +5929,2 @@\n-    ciKlass* eklass = klass->as_obj_array_klass()->element_klass();\n-    const TypeKlassPtr *etype = TypeKlassPtr::make(eklass)->cast_to_exactness(false);\n+    ciKlass* eklass = k->as_obj_array_klass()->element_klass();\n+    const TypeKlassPtr *etype = TypeKlassPtr::make(eklass, interface_handling)->cast_to_exactness(false);\n@@ -5716,1 +5932,1 @@\n-  } else if (klass->is_type_array_klass()) {\n+  } else if (k->is_type_array_klass()) {\n@@ -5718,2 +5934,2 @@\n-    const Type* etype = get_const_basic_type(klass->as_type_array_klass()->element_type());\n-    return TypeAryKlassPtr::make(ptr, etype, klass, offset);\n+    const Type* etype = get_const_basic_type(k->as_type_array_klass()->element_type());\n+    return TypeAryKlassPtr::make(ptr, etype, k, offset);\n@@ -5726,2 +5942,2 @@\n-const TypeAryKlassPtr* TypeAryKlassPtr::make(ciKlass* klass) {\n-  return TypeAryKlassPtr::make(Constant, klass, 0);\n+const TypeAryKlassPtr* TypeAryKlassPtr::make(ciKlass* klass, InterfaceHandling interface_handling) {\n+  return TypeAryKlassPtr::make(Constant, klass, 0, interface_handling);\n@@ -5759,2 +5975,1 @@\n-    \/\/ Compute array klass from element klass\n-    k_ary = ciObjArrayKlass::make(tinst->klass());\n+    \/\/ Leave k_ary at NULL.\n@@ -5762,5 +5977,1 @@\n-    \/\/ Compute array klass from element klass\n-    ciKlass* k_elem = tary->klass();\n-    \/\/ If element type is something like bottom[], k_elem will be null.\n-    if (k_elem != NULL)\n-      k_ary = ciObjArrayKlass::make(k_elem);\n+    \/\/ Leave k_ary at NULL.\n@@ -5824,5 +6035,0 @@\n-    if (UseCompressedOops && k_ary != NULL && k_ary->is_obj_array_klass() &&\n-        _offset != 0 && _offset != arrayOopDesc::length_offset_in_bytes() &&\n-        _offset != arrayOopDesc::klass_offset_in_bytes()) {\n-      ((TypeAryPtr*)this)->_is_ptr_to_narrowoop = true;\n-    }\n@@ -5833,0 +6039,1 @@\n+\/\/ Is there a single ciKlass* that can represent that type?\n@@ -5858,1 +6065,1 @@\n-const TypePtr *TypeAryKlassPtr::add_offset(intptr_t offset) const {\n+const TypePtr* TypeAryKlassPtr::add_offset(intptr_t offset) const {\n@@ -5988,1 +6195,1 @@\n-    meet_aryptr(ptr, elem, this->klass(), tap->klass(), this->klass_is_exact(), tap->klass_is_exact(), this->ptr(), tap->ptr(), res_klass, res_xk);\n+    meet_aryptr(ptr, elem, this, tap, res_klass, res_xk);\n@@ -5996,0 +6203,3 @@\n+    InterfaceSet interfaces = meet_interfaces(tp);\n+    InterfaceSet tp_interfaces = tp->_interfaces;\n+    InterfaceSet this_interfaces = _interfaces;\n@@ -6003,1 +6213,1 @@\n-      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact()) {\n+      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces.intersection_with(tp_interfaces).eq(tp_interfaces) && !tp->klass_is_exact()) {\n@@ -6008,1 +6218,2 @@\n-        return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), offset);\n+        interfaces = this_interfaces.intersection_with(tp->_interfaces);\n+        return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, offset);\n@@ -6020,1 +6231,1 @@\n-        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact()) {\n+        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces.intersection_with(tp_interfaces).eq(tp_interfaces) && !tp->klass_is_exact()) {\n@@ -6029,1 +6240,2 @@\n-      return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), offset);\n+      interfaces = this_interfaces.intersection_with(tp_interfaces);\n+      return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, offset);\n@@ -6038,2 +6250,4 @@\n-bool TypeAryKlassPtr::is_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n-  if (other->klass() == ciEnv::current()->Object_klass() && other_exact) {\n+template <class T1, class T2> bool TypePtr::is_java_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_exact, bool other_exact) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+\n+  if (other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.empty() && other_exact) {\n@@ -6043,1 +6257,4 @@\n-  if (!is_loaded() || !other->is_loaded() || other->klass() == NULL || klass() == NULL) {\n+  int dummy;\n+  bool this_top_or_bottom = (this_one->base_element_type(dummy) == Type::TOP || this_one->base_element_type(dummy) == Type::BOTTOM);\n+\n+  if (!this_one->is_loaded() || !other->is_loaded() || this_top_or_bottom) {\n@@ -6046,2 +6263,3 @@\n-  if (other->isa_instklassptr()) {\n-    return _klass->is_subtype_of(other->_klass) && other_exact;\n+\n+  if (this_one->is_instance_type(other)) {\n+    return other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.intersection_with(this_one->_interfaces).eq(other->_interfaces) && other_exact;\n@@ -6049,1 +6267,5 @@\n-  if (klass() == NULL) {\n+\n+  assert(this_one->is_array_type(other), \"\");\n+  const T1* other_ary = this_one->is_array_type(other);\n+  bool other_top_or_bottom = (other_ary->base_element_type(dummy) == Type::TOP || other_ary->base_element_type(dummy) == Type::BOTTOM);\n+  if (other_top_or_bottom) {\n@@ -6052,4 +6274,5 @@\n-  assert(other->isa_aryklassptr(), \"\");\n-  const TypeAryKlassPtr* other_ary = other->isa_aryklassptr();\n-  if (other_ary->_elem->isa_klassptr() && _elem->isa_klassptr()) {\n-    return _elem->is_klassptr()->is_java_subtype_of_helper(other_ary->_elem->is_klassptr(), this_exact, other_exact);\n+\n+  const TypePtr* other_elem = other_ary->elem()->make_ptr();\n+  const TypePtr* this_elem = this_one->elem()->make_ptr();\n+  if (this_elem != NULL && other_elem != NULL) {\n+    return this_one->is_reference_type(this_elem)->is_java_subtype_of_helper(this_one->is_reference_type(other_elem), this_exact, other_exact);\n@@ -6057,2 +6280,2 @@\n-  if (!other_ary->_elem->isa_klassptr() && !_elem->isa_klassptr()) {\n-    return _klass->is_subtype_of(other->_klass);\n+  if (this_elem == NULL && other_elem == NULL) {\n+    return this_one->_klass->is_subtype_of(other->_klass);\n@@ -6063,3 +6286,18 @@\n-bool TypeAryKlassPtr::is_same_java_type_as(const TypeKlassPtr* other) const {\n-  if (!other->isa_aryklassptr() ||\n-      !is_loaded() || !other->is_loaded() || klass() == NULL || other->klass() == NULL) {\n+bool TypeAryKlassPtr::is_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n+  return TypePtr::is_java_subtype_of_helper_for_array(this, other, this_exact, other_exact);\n+}\n+\n+template <class T1, class T2> bool TypePtr::is_same_java_type_as_helper_for_array(const T1* this_one, const T2* other) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+\n+  int dummy;\n+  bool this_top_or_bottom = (this_one->base_element_type(dummy) == Type::TOP || this_one->base_element_type(dummy) == Type::BOTTOM);\n+\n+  if (!this_one->is_array_type(other) ||\n+      !this_one->is_loaded() || !other->is_loaded() || this_top_or_bottom) {\n+    return false;\n+  }\n+  const T1* other_ary = this_one->is_array_type(other);\n+  bool other_top_or_bottom = (other_ary->base_element_type(dummy) == Type::TOP || other_ary->base_element_type(dummy) == Type::BOTTOM);\n+\n+  if (other_top_or_bottom) {\n@@ -6068,3 +6306,5 @@\n-  const TypeAryKlassPtr* other_ary = other->isa_aryklassptr();\n-  if (other_ary->_elem->isa_klassptr() && _elem->isa_klassptr()) {\n-    return _elem->is_klassptr()->is_same_java_type_as(other_ary->_elem->is_klassptr());\n+\n+  const TypePtr* other_elem = other_ary->elem()->make_ptr();\n+  const TypePtr* this_elem = this_one->elem()->make_ptr();\n+  if (other_elem != NULL && this_elem != NULL) {\n+    return this_one->is_reference_type(this_elem)->is_same_java_type_as(this_one->is_reference_type(other_elem));\n@@ -6072,2 +6312,3 @@\n-  if (!other_ary->_elem->isa_klassptr() && !_elem->isa_klassptr()) {\n-    return _klass->equals(other->_klass);\n+  if (other_elem == NULL && this_elem == NULL) {\n+    assert(this_one->_klass != NULL && other->_klass != NULL, \"\");\n+    return this_one->_klass->equals(other->_klass);\n@@ -6078,2 +6319,7 @@\n-bool TypeAryKlassPtr::maybe_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n-  if (other->klass() == ciEnv::current()->Object_klass()) {\n+bool TypeAryKlassPtr::is_same_java_type_as_helper(const TypeKlassPtr* other) const {\n+  return TypePtr::is_same_java_type_as_helper_for_array(this, other);\n+}\n+\n+template <class T1, class T2> bool TypePtr::maybe_java_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_exact, bool other_exact) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+  if (other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.empty() && other_exact) {\n@@ -6082,1 +6328,3 @@\n-  if (!is_loaded() || !other->is_loaded() || klass() == NULL || other->klass() == NULL) {\n+  int dummy;\n+  bool this_top_or_bottom = (this_one->base_element_type(dummy) == Type::TOP || this_one->base_element_type(dummy) == Type::BOTTOM);\n+  if (!this_one->is_loaded() || !other->is_loaded() || this_top_or_bottom) {\n@@ -6085,2 +6333,2 @@\n-  if (other->isa_instklassptr()) {\n-    return (!other_exact && other->_klass->is_interface()) || _klass->is_subtype_of(other->_klass);\n+  if (this_one->is_instance_type(other)) {\n+    return other->_klass->equals(ciEnv::current()->Object_klass()) && other->_interfaces.intersection_with(this_one->_interfaces).eq(other->_interfaces);\n@@ -6088,1 +6336,1 @@\n-  assert(other->isa_aryklassptr(), \"\");\n+  assert(this_one->is_array_type(other), \"\");\n@@ -6090,0 +6338,5 @@\n+  const T1* other_ary = this_one->is_array_type(other);\n+  bool other_top_or_bottom = (other_ary->base_element_type(dummy) == Type::TOP || other_ary->base_element_type(dummy) == Type::BOTTOM);\n+  if (other_top_or_bottom) {\n+    return true;\n+  }\n@@ -6091,1 +6344,1 @@\n-    return is_java_subtype_of(other);\n+    return this_one->is_java_subtype_of(other);\n@@ -6094,3 +6347,4 @@\n-  const TypeAryKlassPtr* other_ary = other->isa_aryklassptr();\n-  if (other_ary->_elem->isa_klassptr() && _elem->isa_klassptr()) {\n-    return _elem->is_klassptr()->maybe_java_subtype_of_helper(other_ary->_elem->is_klassptr(), this_exact, other_exact);\n+  const TypePtr* this_elem = this_one->elem()->make_ptr();\n+  const TypePtr* other_elem = other_ary->elem()->make_ptr();\n+  if (other_elem != NULL && this_elem != NULL) {\n+    return this_one->is_reference_type(this_elem)->maybe_java_subtype_of_helper(this_one->is_reference_type(other_elem), this_exact, other_exact);\n@@ -6098,2 +6352,2 @@\n-  if (!other_ary->_elem->isa_klassptr() && !_elem->isa_klassptr()) {\n-    return _klass->is_subtype_of(other->_klass);\n+  if (other_elem == NULL && this_elem == NULL) {\n+    return this_one->_klass->is_subtype_of(other->_klass);\n@@ -6104,0 +6358,4 @@\n+bool TypeAryKlassPtr::maybe_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n+  return TypePtr::maybe_java_subtype_of_helper_for_array(this, other, this_exact, other_exact);\n+}\n+\n@@ -6110,1 +6368,1 @@\n-\/\/------------------------------get_con----------------------------------------\n+\/\/ Is there a single ciKlass* that can represent that type?\n@@ -6130,5 +6388,1 @@\n-    k = elem()->is_klassptr()->klass();\n-    if (k != NULL) {\n-      k = ciObjArrayKlass::make(k);\n-      ((TypeAryKlassPtr*)this)->_klass = k;\n-    }\n+    \/\/ leave NULL\n@@ -6139,0 +6393,1 @@\n+    ((TypeAryKlassPtr*)this)->_klass = k;\n@@ -6154,0 +6409,1 @@\n+      _interfaces.dump(st);\n@@ -6202,1 +6458,1 @@\n-    domain = TypeTuple::make_domain(NULL, method->signature());\n+    domain = TypeTuple::make_domain(NULL, method->signature(), ignore_interfaces);\n@@ -6204,1 +6460,1 @@\n-    domain = TypeTuple::make_domain(method->holder(), method->signature());\n+    domain = TypeTuple::make_domain(method->holder(), method->signature(), ignore_interfaces);\n@@ -6206,1 +6462,1 @@\n-  const TypeTuple *range  = TypeTuple::make_range(method->signature());\n+  const TypeTuple *range  = TypeTuple::make_range(method->signature(), ignore_interfaces);\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":805,"deletions":549,"binary":false,"changes":1354,"status":"modified"},{"patch":"@@ -171,4 +171,0 @@\n-#ifdef ASSERT\n-  \/\/ One type is interface, the other is oop\n-  virtual bool interface_vs_oop_helper(const Type *t) const;\n-#endif\n@@ -263,1 +259,0 @@\n-  \/\/ Currently, it also works around limitations involving interface types.\n@@ -273,5 +268,0 @@\n-#ifdef ASSERT\n-  \/\/ One type is interface, the other is oop\n-  virtual bool interface_vs_oop(const Type *t) const;\n-#endif\n-\n@@ -407,0 +397,4 @@\n+  enum InterfaceHandling {\n+      trust_interfaces,\n+      ignore_interfaces\n+  };\n@@ -408,1 +402,1 @@\n-  static const Type* get_const_type(ciType* type);\n+  static const Type* get_const_type(ciType* type, InterfaceHandling interface_handling = ignore_interfaces);\n@@ -727,2 +721,2 @@\n-  static const TypeTuple *make_range(ciSignature *sig);\n-  static const TypeTuple *make_domain(ciInstanceKlass* recv, ciSignature *sig);\n+  static const TypeTuple *make_range(ciSignature *sig, InterfaceHandling interface_handling = ignore_interfaces);\n+  static const TypeTuple *make_domain(ciInstanceKlass* recv, ciSignature *sig, InterfaceHandling interface_handling);\n@@ -779,4 +773,0 @@\n-#ifdef ASSERT\n-  \/\/ One type is interface, the other is oop\n-  virtual bool interface_vs_oop(const Type *t) const;\n-#endif\n@@ -888,0 +878,46 @@\n+  friend class Type;\n+protected:\n+  class InterfaceSet {\n+  private:\n+    GrowableArray<ciKlass*> _list;\n+    void raw_add(ciKlass* interface);\n+    void add(ciKlass* interface);\n+    void verify() const;\n+    int _hash_computed:1;\n+    int _exact_klass_computed:1;\n+    int _is_loaded_computed:1;\n+    int _hash;\n+    ciKlass* _exact_klass;\n+    bool _is_loaded;\n+    void compute_hash();\n+    void compute_exact_klass();\n+  public:\n+    InterfaceSet();\n+    InterfaceSet(GrowableArray<ciInstanceKlass*>* interfaces);\n+    bool eq(const InterfaceSet& other) const;\n+    int hash() const;\n+    void dump(outputStream *st) const;\n+    InterfaceSet union_with(const InterfaceSet& other) const;\n+    InterfaceSet intersection_with(const InterfaceSet& other) const;\n+    bool contains(const InterfaceSet& other) const {\n+      return intersection_with(other).eq(other);\n+    }\n+    bool empty() const { return _list.length() == 0; }\n+\n+    inline void* operator new(size_t x) throw() {\n+      Compile* compile = Compile::current();\n+      return compile->type_arena()->AmallocWords(x);\n+    }\n+    inline void operator delete( void* ptr ) {\n+      ShouldNotReachHere();\n+    }\n+    ciKlass* exact_klass() const;\n+    bool is_loaded() const;\n+\n+    static int compare(ciKlass* const &, ciKlass* const & k2);\n+\n+    void compute_is_loaded();\n+  };\n+\n+  static InterfaceSet interfaces(ciKlass*& k, bool klass, bool interface, bool array, InterfaceHandling interface_handling);\n+\n@@ -946,6 +982,14 @@\n-  static MeetResult\n-  meet_instptr(PTR &ptr, ciKlass* this_klass, ciKlass* tinst_klass, bool this_xk, bool tinst_xk, PTR this_ptr,\n-               PTR tinst_ptr, ciKlass*&res_klass, bool &res_xk);\n-  static MeetResult\n-  meet_aryptr(PTR& ptr, const Type*& elem, ciKlass* this_klass, ciKlass* tap_klass, bool this_xk, bool tap_xk, PTR this_ptr, PTR tap_ptr, ciKlass*& res_klass, bool& res_xk);\n-\n+  template<class T> static TypePtr::MeetResult meet_instptr(PTR& ptr, InterfaceSet& interfaces, const T* this_type,\n+                                                            const T* other_type, ciKlass*& res_klass, bool& res_xk);\n+\n+  template<class T> static MeetResult meet_aryptr(PTR& ptr, const Type*& elem, const T* this_ary, const T* other_ary,\n+                                                  ciKlass*& res_klass, bool& res_xk);\n+\n+  template <class T1, class T2> static bool is_java_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_exact, bool other_exact);\n+  template <class T1, class T2> static bool is_same_java_type_as_helper_for_instance(const T1* this_one, const T2* other);\n+  template <class T1, class T2> static bool maybe_java_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_exact, bool other_exact);\n+  template <class T1, class T2> static bool is_java_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_exact, bool other_exact);\n+  template <class T1, class T2> static bool is_same_java_type_as_helper_for_array(const T1* this_one, const T2* other);\n+  template <class T1, class T2> static bool maybe_java_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_exact, bool other_exact);\n+  template <class T1, class T2> static bool is_meet_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_xk, bool other_xk);\n+  template <class T1, class T2> static bool is_meet_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_xk, bool other_xk);\n@@ -1060,1 +1104,1 @@\n-  TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset, int instance_id,\n+ TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, const InterfaceSet& interfaces, bool xk, ciObject* o, int offset, int instance_id,\n@@ -1076,0 +1120,3 @@\n+\n+  const InterfaceSet _interfaces;\n+\n@@ -1087,1 +1134,1 @@\n-  static const TypeOopPtr* make_from_klass_common(ciKlass* klass, bool klass_change, bool try_for_exact);\n+  static const TypeOopPtr* make_from_klass_common(ciKlass* klass, bool klass_change, bool try_for_exact, InterfaceHandling interface_handling);\n@@ -1092,0 +1139,2 @@\n+  InterfaceSet meet_interfaces(const TypeOopPtr* other) const;\n+\n@@ -1103,1 +1152,9 @@\n-  virtual bool is_same_java_type_as(const TypeOopPtr* other) const { ShouldNotReachHere(); return false; }\n+\n+  bool is_same_java_type_as(const TypePtr* other) const {\n+    return is_same_java_type_as_helper(other->is_oopptr());\n+  }\n+\n+  virtual bool is_same_java_type_as_helper(const TypeOopPtr* other) const {\n+    ShouldNotReachHere(); return false;\n+  }\n+\n@@ -1114,2 +1171,2 @@\n-  static const TypeOopPtr* make_from_klass(ciKlass* klass) {\n-    return make_from_klass_common(klass, true, false);\n+  static const TypeOopPtr* make_from_klass(ciKlass* klass, InterfaceHandling interface_handling = ignore_interfaces) {\n+    return make_from_klass_common(klass, true, false, interface_handling);\n@@ -1119,2 +1176,2 @@\n-  static const TypeOopPtr* make_from_klass_unique(ciKlass* klass) {\n-    return make_from_klass_common(klass, true, true);\n+  static const TypeOopPtr* make_from_klass_unique(ciKlass* klass, InterfaceHandling interface_handling= ignore_interfaces) {\n+    return make_from_klass_common(klass, true, true, interface_handling);\n@@ -1124,2 +1181,2 @@\n-  static const TypeOopPtr* make_from_klass_raw(ciKlass* klass) {\n-    return make_from_klass_common(klass, false, false);\n+  static const TypeOopPtr* make_from_klass_raw(ciKlass* klass, InterfaceHandling interface_handling = ignore_interfaces) {\n+    return make_from_klass_common(klass, false, false, interface_handling);\n@@ -1144,2 +1201,2 @@\n-  virtual bool  is_loaded() const { return klass()->is_loaded(); }\n-  bool klass_is_exact()    const { return _klass_is_exact; }\n+  virtual bool  is_loaded() const { return klass()->is_loaded() && _interfaces.is_loaded(); }\n+  virtual bool klass_is_exact()    const { return _klass_is_exact; }\n@@ -1187,0 +1244,24 @@\n+private:\n+  virtual bool is_meet_subtype_of(const TypePtr* other) const {\n+    return is_meet_subtype_of_helper(other->is_oopptr(), klass_is_exact(), other->is_oopptr()->klass_is_exact());\n+  }\n+\n+  virtual bool is_meet_subtype_of_helper(const TypeOopPtr* other, bool this_xk, bool other_xk) const {\n+    ShouldNotReachHere(); return false;\n+  }\n+\n+  virtual const InterfaceSet interfaces() const {\n+    return _interfaces;\n+  };\n+\n+  const TypeOopPtr* is_reference_type(const Type* other) const {\n+    return other->isa_oopptr();\n+  }\n+\n+  const TypeAryPtr* is_array_type(const TypeOopPtr* other) const {\n+    return other->isa_aryptr();\n+  }\n+\n+  const TypeInstPtr* is_instance_type(const TypeOopPtr* other) const {\n+    return other->isa_instptr();\n+  }\n@@ -1193,1 +1274,1 @@\n-  TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset, int instance_id,\n+  TypeInstPtr(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, bool xk, ciObject* o, int offset, int instance_id,\n@@ -1204,3 +1285,1 @@\n-    if (klass()->is_loaded() && klass()->is_interface()) {\n-      return Compile::current()->env()->Object_klass();\n-    }\n+    assert(!(klass()->is_loaded() && klass()->is_interface()), \"\");\n@@ -1210,1 +1289,1 @@\n-  bool is_same_java_type_as(const TypeOopPtr* other) const;\n+  bool is_same_java_type_as_helper(const TypeOopPtr* other) const;\n@@ -1216,1 +1295,3 @@\n-    return make(TypePtr::Constant, o->klass(), true, o, 0, InstanceBot);\n+    ciKlass* k = o->klass();\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n+    return make(TypePtr::Constant, k, interfaces, true, o, 0, InstanceBot);\n@@ -1220,1 +1301,3 @@\n-    return make(TypePtr::Constant, o->klass(), true, o, offset, InstanceBot);\n+    ciKlass* k = o->klass();\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n+    return make(TypePtr::Constant, k, interfaces, true, o, offset, InstanceBot);\n@@ -1224,2 +1307,3 @@\n-  static const TypeInstPtr *make(PTR ptr, ciKlass* klass) {\n-    return make(ptr, klass, false, NULL, 0, InstanceBot);\n+  static const TypeInstPtr *make(PTR ptr, ciKlass* klass, InterfaceHandling interface_handling = ignore_interfaces) {\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(klass, true, true, false, interface_handling);\n+    return make(ptr, klass, interfaces, false, NULL, 0, InstanceBot);\n@@ -1230,1 +1314,2 @@\n-    return make(ptr, klass, true, NULL, 0, InstanceBot);\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(klass, true, false, false, ignore_interfaces);\n+    return make(ptr, klass, interfaces, true, NULL, 0, InstanceBot);\n@@ -1235,1 +1320,2 @@\n-    return make(ptr, klass, false, NULL, offset, InstanceBot);\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(klass, true, false, false, ignore_interfaces);\n+    return make(ptr, klass, interfaces, false, NULL, offset, InstanceBot);\n@@ -1238,2 +1324,1 @@\n-  \/\/ Make a pointer to an oop.\n-  static const TypeInstPtr *make(PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset,\n+  static const TypeInstPtr *make(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, bool xk, ciObject* o, int offset,\n@@ -1244,0 +1329,5 @@\n+  static const TypeInstPtr *make(PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset, int instance_id = InstanceBot) {\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n+    return make(ptr, k, interfaces, xk, o, offset, instance_id);\n+  }\n+\n@@ -1268,1 +1358,1 @@\n-  virtual const TypeInstPtr *xmeet_unloaded( const TypeInstPtr *t ) const;\n+  virtual const TypeInstPtr *xmeet_unloaded(const TypeInstPtr *t, const InterfaceSet& interfaces) const;\n@@ -1273,2 +1363,0 @@\n-  bool is_interface() const { return is_loaded() && klass()->is_interface(); }\n-\n@@ -1284,0 +1372,8 @@\n+\n+private:\n+  virtual bool is_meet_subtype_of_helper(const TypeOopPtr* other, bool this_xk, bool other_xk) const;\n+\n+  virtual bool is_meet_same_type_as(const TypePtr* other) const {\n+    return _klass->equals(other->is_instptr()->_klass) && _interfaces.eq(other->is_instptr()->_interfaces);\n+  }\n+\n@@ -1289,0 +1385,3 @@\n+  friend class Type;\n+  friend class TypePtr;\n+\n@@ -1292,1 +1391,1 @@\n-    : TypeOopPtr(AryPtr,ptr,k,xk,o,offset, instance_id, speculative, inline_depth),\n+    : TypeOopPtr(AryPtr,ptr,k,*_array_interfaces,xk,o,offset, instance_id, speculative, inline_depth),\n@@ -1296,14 +1395,7 @@\n-#ifdef ASSERT\n-    if (k != NULL) {\n-      \/\/ Verify that specified klass and TypeAryPtr::klass() follow the same rules.\n-      ciKlass* ck = compute_klass(true);\n-      if (k != ck) {\n-        this->dump(); tty->cr();\n-        tty->print(\" k: \");\n-        k->print(); tty->cr();\n-        tty->print(\"ck: \");\n-        if (ck != NULL) ck->print();\n-        else tty->print(\"<NULL>\");\n-        tty->cr();\n-        assert(false, \"unexpected TypeAryPtr::_klass\");\n-      }\n+    int dummy;\n+    bool top_or_bottom = (base_element_type(dummy) == Type::TOP || base_element_type(dummy) == Type::BOTTOM);\n+\n+    if (UseCompressedOops && (elem()->make_oopptr() != NULL && !top_or_bottom) &&\n+        _offset != 0 && _offset != arrayOopDesc::length_offset_in_bytes() &&\n+        _offset != arrayOopDesc::klass_offset_in_bytes()) {\n+      _is_ptr_to_narrowoop = true;\n@@ -1311,1 +1403,1 @@\n-#endif\n+\n@@ -1320,0 +1412,3 @@\n+  \/\/ A pointer to delay allocation to Type::Initialize_shared()\n+\n+  static const InterfaceSet* _array_interfaces;\n@@ -1321,0 +1416,1 @@\n+  \/\/ Only guaranteed non null for array of basic types\n@@ -1325,1 +1421,1 @@\n-  bool is_same_java_type_as(const TypeOopPtr* other) const;\n+  bool is_same_java_type_as_helper(const TypeOopPtr* other) const;\n@@ -1402,4 +1498,0 @@\n-#ifdef ASSERT\n-  \/\/ One type is interface, the other is oop\n-  virtual bool interface_vs_oop(const Type *t) const;\n-#endif\n@@ -1409,0 +1501,2 @@\n+private:\n+  virtual bool is_meet_subtype_of_helper(const TypeOopPtr* other, bool this_xk, bool other_xk) const;\n@@ -1456,0 +1550,1 @@\n+  friend class TypePtr;\n@@ -1457,1 +1552,1 @@\n-  TypeKlassPtr(TYPES t, PTR ptr, ciKlass* klass, int offset);\n+  TypeKlassPtr(TYPES t, PTR ptr, ciKlass* klass, const InterfaceSet& interfaces, int offset);\n@@ -1469,1 +1564,2 @@\n-\n+  const InterfaceSet _interfaces;\n+  InterfaceSet meet_interfaces(const TypeKlassPtr* other) const;\n@@ -1479,0 +1575,4 @@\n+  bool is_same_java_type_as(const TypePtr* other) const {\n+    return is_same_java_type_as_helper(other->is_klassptr());\n+  }\n+\n@@ -1482,1 +1582,1 @@\n-  virtual bool is_same_java_type_as(const TypeKlassPtr* other) const { ShouldNotReachHere(); return false; }\n+  virtual bool is_same_java_type_as_helper(const TypeKlassPtr* other) const { ShouldNotReachHere(); return false; }\n@@ -1488,0 +1588,1 @@\n+  virtual bool klass_is_exact()    const { return _ptr == Constant; }\n@@ -1489,4 +1590,2 @@\n-  bool klass_is_exact()    const { return _ptr == Constant; }\n-\n-  static const TypeKlassPtr* make(ciKlass* klass);\n-  static const TypeKlassPtr *make(PTR ptr, ciKlass* klass, int offset);\n+  static const TypeKlassPtr* make(ciKlass* klass, InterfaceHandling interface_handling = ignore_interfaces);\n+  static const TypeKlassPtr *make(PTR ptr, ciKlass* klass, int offset, InterfaceHandling interface_handling = ignore_interfaces);\n@@ -1511,0 +1610,2 @@\n+  virtual const TypeKlassPtr* try_improve() const { return this; }\n+\n@@ -1514,0 +1615,24 @@\n+private:\n+  virtual bool is_meet_subtype_of(const TypePtr* other) const {\n+    return is_meet_subtype_of_helper(other->is_klassptr(), klass_is_exact(), other->is_klassptr()->klass_is_exact());\n+  }\n+\n+  virtual bool is_meet_subtype_of_helper(const TypeKlassPtr* other, bool this_xk, bool other_xk) const {\n+    ShouldNotReachHere(); return false;\n+  }\n+\n+  virtual const InterfaceSet interfaces() const {\n+    return _interfaces;\n+  };\n+\n+  const TypeKlassPtr* is_reference_type(const Type* other) const {\n+    return other->isa_klassptr();\n+  }\n+\n+  const TypeAryKlassPtr* is_array_type(const TypeKlassPtr* other) const {\n+    return other->isa_aryklassptr();\n+  }\n+\n+  const TypeInstKlassPtr* is_instance_type(const TypeKlassPtr* other) const {\n+    return other->isa_instklassptr();\n+  }\n@@ -1519,2 +1644,3 @@\n-  TypeInstKlassPtr(PTR ptr, ciKlass* klass, int offset)\n-    : TypeKlassPtr(InstKlassPtr, ptr, klass, offset) {\n+  TypeInstKlassPtr(PTR ptr, ciKlass* klass, const InterfaceSet& interfaces, int offset)\n+    : TypeKlassPtr(InstKlassPtr, ptr, klass, interfaces, offset) {\n+    assert(klass->is_instance_klass() && (!klass->is_loaded() || !klass->is_interface()), \"\");\n@@ -1528,3 +1654,1 @@\n-    if (klass()->is_interface()) {\n-      return Compile::current()->env()->Object_klass();\n-    }\n+    assert(!klass()->is_interface(), \"\");\n@@ -1534,1 +1658,1 @@\n-  bool is_same_java_type_as(const TypeKlassPtr* other) const;\n+  bool is_same_java_type_as_helper(const TypeKlassPtr* other) const;\n@@ -1538,2 +1662,9 @@\n-  static const TypeInstKlassPtr *make(ciKlass* k) {\n-    return make(TypePtr::Constant, k, 0);\n+  static const TypeInstKlassPtr *make(ciKlass* k, InterfaceHandling interface_handling) {\n+    InterfaceSet interfaces = TypePtr::interfaces(k, true, true, false, interface_handling);\n+    return make(TypePtr::Constant, k, interfaces, 0);\n+  }\n+  static const TypeInstKlassPtr* make(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, int offset);\n+\n+  static const TypeInstKlassPtr* make(PTR ptr, ciKlass* k, int offset) {\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n+    return make(ptr, k, interfaces, offset);\n@@ -1541,1 +1672,0 @@\n-  static const TypeInstKlassPtr *make(PTR ptr, ciKlass* k, int offset);\n@@ -1557,1 +1687,1 @@\n-  bool is_interface() const { return klass()->is_interface(); }\n+  virtual const TypeKlassPtr* try_improve() const;\n@@ -1562,0 +1692,2 @@\n+private:\n+  virtual bool is_meet_subtype_of_helper(const TypeKlassPtr* other, bool this_xk, bool other_xk) const;\n@@ -1567,0 +1699,3 @@\n+  friend class Type;\n+  friend class TypePtr;\n+\n@@ -1569,0 +1704,1 @@\n+  static const InterfaceSet* _array_interfaces;\n@@ -1570,1 +1706,2 @@\n-    : TypeKlassPtr(AryKlassPtr, ptr, klass, offset), _elem(elem) {\n+    : TypeKlassPtr(AryKlassPtr, ptr, klass, *_array_interfaces, offset), _elem(elem) {\n+    assert(klass == NULL || klass->is_type_array_klass() || !klass->as_obj_array_klass()->base_element_klass()->is_interface(), \"\");\n@@ -1574,0 +1711,1 @@\n+  \/\/ Only guaranteed non null for array of basic types\n@@ -1583,1 +1721,1 @@\n-  static const TypeAryKlassPtr *make(PTR ptr, ciKlass* k, int offset);\n+  static const TypeAryKlassPtr *make(PTR ptr, ciKlass* k, int offset, InterfaceHandling interface_handling);\n@@ -1585,1 +1723,1 @@\n-  bool is_same_java_type_as(const TypeKlassPtr* other) const;\n+  bool is_same_java_type_as_helper(const TypeKlassPtr* other) const;\n@@ -1592,1 +1730,1 @@\n-  static const TypeAryKlassPtr* make(ciKlass* klass);\n+  static const TypeAryKlassPtr* make(ciKlass* klass, InterfaceHandling interface_handling);\n@@ -1619,0 +1757,2 @@\n+private:\n+  virtual bool is_meet_subtype_of_helper(const TypeKlassPtr* other, bool this_xk, bool other_xk) const;\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":232,"deletions":92,"binary":false,"changes":324,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-        t.runTest(methodObjClassCast,  true,  svalue);\n+        t.runTest(methodObjClassCast,  false,  svalue);\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/klass\/CastNullCheckDroppingsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,208 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8297345\n+ * @summary C2: SIGSEGV in PhaseIdealLoop::push_pinned_nodes_thru_region\n+ *\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation\n+ *                   -XX:CompileOnly=TestCheckCastPPBecomesTOP::test1 -XX:LoopMaxUnroll=0\n+ *                   -XX:CompileCommand=dontinline,TestCheckCastPPBecomesTOP::notInlined -XX:+UseParallelGC TestCheckCastPPBecomesTOP\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation\n+ *                   -XX:CompileOnly=TestCheckCastPPBecomesTOP::test1 -XX:LoopMaxUnroll=0\n+ *                   -XX:CompileCommand=dontinline,TestCheckCastPPBecomesTOP::notInlined -XX:+UseParallelGC -XX:-UseCompressedClassPointers TestCheckCastPPBecomesTOP\n+ *\n+ *\/\n+\n+public class TestCheckCastPPBecomesTOP {\n+    private static I field;\n+    private static I field2;\n+    private static I field3;\n+    private static volatile int barrier;\n+\n+    public static void main(String[] args) {\n+        A a = new A();\n+        B b = new B();\n+        for (int i = 0; i < 100_000; i++) {\n+            test1Helper3(5);\n+            field2 = field = a;\n+            test1Helper1(b, 100, 100);\n+            test1Helper1(b, 100, 100);\n+            test1Helper1(b, 100, 100);\n+            field2 = field = b;\n+            test1Helper1(b, 100, 100);\n+            test1Helper1(b, 100, 100);\n+\n+            field2 = field = a;\n+            test1Helper1(b, 10, 100);\n+            test1Helper1(b, 10, 100);\n+            test1Helper1(b, 10, 100);\n+            field2 = field = b;\n+            test1Helper1(b, 10, 100);\n+            test1Helper1(b, 10, 100);\n+\n+            field2 = field = a;\n+            test1Helper1(b, 10, 10);\n+            test1Helper1(b, 10, 10);\n+            test1Helper1(b, 10, 10);\n+            field2 = field = b;\n+            test1Helper1(b, 10, 10);\n+            test1Helper1(b, 10, 10);\n+\n+            field2 = field = a;\n+            test1Helper2(b, true);\n+            field2 = field = b;\n+            test1Helper2(b, true);\n+\n+            test1(false);\n+        }\n+   }\n+\n+\n+    private static void test1(boolean flag1) {\n+        I f = field;\n+        if (f == null) {\n+        }\n+        test1Helper3(10);\n+        test1Helper2(f, flag1);\n+\n+            for (int j = 0; j < 10; j++) {\n+                for (int k = 0; k < 10; k++) {\n+                    for (int l = 0; l < 10; l++) {\n+\n+                    }\n+                }\n+            }\n+    }\n+\n+    private static void test1Helper3(int stop) {\n+        int i;\n+        for (i = 0; i < stop; i++) {\n+\n+        }\n+        if (i != 10) {\n+            barrier = 0x42;\n+        }\n+    }\n+\n+\n+    private static void test1Helper2(I f2, boolean flag1) {\n+        if (flag1) {\n+            if (f2 == null) {\n+\n+            }\n+            int i;\n+            for (i = 0; i < 10; i++) {\n+            }\n+            int j;\n+            for (j = 0; j < 10; j++) {\n+                for (int k = 0; k < 10; k++) {\n+\n+                }\n+            }\n+            test1Helper1(f2, i, j);\n+        }\n+    }\n+\n+    private static void test1Helper1(I f2, int i, int j) {\n+        I f1 = field;\n+        if (f1 == null) {\n+\n+        }\n+        I f3 = field2;\n+        if (f3 == null) {\n+        }\n+        field2 = f3;\n+        field = f1;\n+        if (i == 10) {\n+            if (j == 10) {\n+                f1.m1();\n+            } else {\n+                f1 = f3;\n+            }\n+            f3.m2(f1);\n+        } else {\n+            f1 = f3;\n+        }\n+        I f4 = field2;\n+        field = f1;\n+        f4.m3(f1, f2);\n+        I f5 = field;\n+        barrier = 0x42;\n+        f5.m4(f2);\n+    }\n+\n+    private static void notInlined(Object o1, Object o2) {\n+\n+    }\n+\n+    interface I {\n+        void m1();\n+        void m2(I f);\n+        void m3(I f1, I f2);\n+\n+        void m4(I f2);\n+    }\n+\n+    static class A implements I {\n+        public void m1() {\n+\n+        }\n+\n+        public void m2(I f) {\n+            f.m1();\n+        }\n+\n+        public void m3(I f1, I f2) {\n+            f1.m1();\n+            f2.m1();\n+        }\n+\n+        public void m4(I f2) {\n+            notInlined(this, f2);\n+            field3 = this;\n+        }\n+    }\n+\n+    static class B implements I {\n+        public void m1() {\n+\n+        }\n+\n+        public void m2(I f) {\n+            f.m1();\n+        }\n+\n+        public void m3(I f1, I f2) {\n+            f1.m1();\n+            f2.m1();\n+        }\n+\n+        public void m4(I f2) {\n+            notInlined(this, f2);\n+            field3 = this;\n+        }\n+\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/types\/TestCheckCastPPBecomesTOP.java","additions":208,"deletions":0,"binary":false,"changes":208,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8297556\n+ * @summary Parse::check_interpreter_type fails with assert \"must constrain OSR typestate\"\n+ *\n+ * @run main\/othervm -Xbatch -XX:-TieredCompilation -XX:CompileOnly=TestExactArrayOfBasicType::test TestExactArrayOfBasicType\n+ *\n+ *\/\n+\n+\n+public class TestExactArrayOfBasicType {\n+    public static void test() {\n+        int[][][][][] array = new int[1][2][3][4][5];\n+\n+        for (int i = 0; i < 50_000; ++i) {\n+            array[0] = new int[0][1][2][3];\n+        }\n+    }\n+\n+    public static void main(String args[]) {\n+        test();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/types\/TestExactArrayOfBasicType.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"}]}