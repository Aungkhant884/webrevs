{"files":[{"patch":"@@ -29,1 +29,0 @@\n-import java.io.ObjectStreamClass.WeakClassKey;\n@@ -33,1 +32,0 @@\n-import java.lang.ref.ReferenceQueue;\n@@ -46,4 +44,0 @@\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n-\n-import static java.io.ObjectStreamClass.processQueue;\n@@ -285,6 +279,7 @@\n-        static final ConcurrentMap<WeakClassKey,Boolean> subclassAudits =\n-            new ConcurrentHashMap<>();\n-\n-        \/** queue for WeakReferences to audited subclasses *\/\n-        static final ReferenceQueue<Class<?>> subclassAuditsQueue =\n-            new ReferenceQueue<>();\n+        static final ClassValue<Boolean> subclassAudits =\n+            new ClassValue<>() {\n+                @Override\n+                protected Boolean computeValue(Class<?> type) {\n+                    return auditSubclass(type);\n+                }\n+            };\n@@ -1633,7 +1628,2 @@\n-        processQueue(Caches.subclassAuditsQueue, Caches.subclassAudits);\n-        WeakClassKey key = new WeakClassKey(cl, Caches.subclassAuditsQueue);\n-        Boolean result = Caches.subclassAudits.get(key);\n-        if (result == null) {\n-            result = auditSubclass(cl);\n-            Caches.subclassAudits.putIfAbsent(key, result);\n-        }\n+        Boolean result = Caches.subclassAudits.get(cl);\n+        assert result != null;\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":9,"deletions":19,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.io.ObjectStreamClass.WeakClassKey;\n-import java.lang.ref.ReferenceQueue;\n@@ -36,3 +34,0 @@\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n-import static java.io.ObjectStreamClass.processQueue;\n@@ -179,6 +174,7 @@\n-        static final ConcurrentMap<WeakClassKey,Boolean> subclassAudits =\n-            new ConcurrentHashMap<>();\n-\n-        \/** queue for WeakReferences to audited subclasses *\/\n-        static final ReferenceQueue<Class<?>> subclassAuditsQueue =\n-            new ReferenceQueue<>();\n+        static final ClassValue<Boolean> subclassAudits =\n+            new ClassValue<>() {\n+                @Override\n+                protected Boolean computeValue(Class<?> type) {\n+                    return auditSubclass(type);\n+                }\n+            };\n@@ -1070,7 +1066,2 @@\n-        processQueue(Caches.subclassAuditsQueue, Caches.subclassAudits);\n-        WeakClassKey key = new WeakClassKey(cl, Caches.subclassAuditsQueue);\n-        Boolean result = Caches.subclassAudits.get(key);\n-        if (result == null) {\n-            result = auditSubclass(cl);\n-            Caches.subclassAudits.putIfAbsent(key, result);\n-        }\n+        Boolean result = Caches.subclassAudits.get(cl);\n+        assert result != null;\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectOutputStream.java","additions":9,"deletions":18,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -31,4 +31,0 @@\n-import java.lang.ref.Reference;\n-import java.lang.ref.ReferenceQueue;\n-import java.lang.ref.SoftReference;\n-import java.lang.ref.WeakReference;\n@@ -62,1 +58,0 @@\n-import java.util.concurrent.ConcurrentMap;\n@@ -111,2 +106,7 @@\n-        static final ConcurrentMap<WeakClassKey,Reference<?>> localDescs =\n-            new ConcurrentHashMap<>();\n+        static final ClassValue<ObjectStreamClass> localDescs =\n+            new ClassValue<>() {\n+                @Override\n+                protected ObjectStreamClass computeValue(Class<?> type) {\n+                    return new ObjectStreamClass(type);\n+                }\n+            };\n@@ -115,9 +115,7 @@\n-        static final ConcurrentMap<FieldReflectorKey,Reference<?>> reflectors =\n-            new ConcurrentHashMap<>();\n-\n-        \/** queue for WeakReferences to local classes *\/\n-        private static final ReferenceQueue<Class<?>> localDescsQueue =\n-            new ReferenceQueue<>();\n-        \/** queue for WeakReferences to field reflectors keys *\/\n-        private static final ReferenceQueue<Class<?>> reflectorsQueue =\n-            new ReferenceQueue<>();\n+        static final ClassValue<Map<FieldReflectorKey, FieldReflector>> reflectors =\n+            new ClassValue<>() {\n+                @Override\n+                protected Map<FieldReflectorKey, FieldReflector> computeValue(Class<?> type) {\n+                    return new ConcurrentHashMap<>();\n+                }\n+            };\n@@ -365,130 +363,1 @@\n-        processQueue(Caches.localDescsQueue, Caches.localDescs);\n-        WeakClassKey key = new WeakClassKey(cl, Caches.localDescsQueue);\n-        Reference<?> ref = Caches.localDescs.get(key);\n-        Object entry = null;\n-        if (ref != null) {\n-            entry = ref.get();\n-        }\n-        EntryFuture future = null;\n-        if (entry == null) {\n-            EntryFuture newEntry = new EntryFuture();\n-            Reference<?> newRef = new SoftReference<>(newEntry);\n-            do {\n-                if (ref != null) {\n-                    Caches.localDescs.remove(key, ref);\n-                }\n-                ref = Caches.localDescs.putIfAbsent(key, newRef);\n-                if (ref != null) {\n-                    entry = ref.get();\n-                }\n-            } while (ref != null && entry == null);\n-            if (entry == null) {\n-                future = newEntry;\n-            }\n-        }\n-\n-        if (entry instanceof ObjectStreamClass) {  \/\/ check common case first\n-            return (ObjectStreamClass) entry;\n-        }\n-        if (entry instanceof EntryFuture) {\n-            future = (EntryFuture) entry;\n-            if (future.getOwner() == Thread.currentThread()) {\n-                \/*\n-                 * Handle nested call situation described by 4803747: waiting\n-                 * for future value to be set by a lookup() call further up the\n-                 * stack will result in deadlock, so calculate and set the\n-                 * future value here instead.\n-                 *\/\n-                entry = null;\n-            } else {\n-                entry = future.get();\n-            }\n-        }\n-        if (entry == null) {\n-            try {\n-                entry = new ObjectStreamClass(cl);\n-            } catch (Throwable th) {\n-                entry = th;\n-            }\n-            if (future.set(entry)) {\n-                Caches.localDescs.put(key, new SoftReference<>(entry));\n-            } else {\n-                \/\/ nested lookup call already set future\n-                entry = future.get();\n-            }\n-        }\n-\n-        if (entry instanceof ObjectStreamClass) {\n-            return (ObjectStreamClass) entry;\n-        } else if (entry instanceof RuntimeException) {\n-            throw (RuntimeException) entry;\n-        } else if (entry instanceof Error) {\n-            throw (Error) entry;\n-        } else {\n-            throw new InternalError(\"unexpected entry: \" + entry);\n-        }\n-    }\n-\n-    \/**\n-     * Placeholder used in class descriptor and field reflector lookup tables\n-     * for an entry in the process of being initialized.  (Internal) callers\n-     * which receive an EntryFuture belonging to another thread as the result\n-     * of a lookup should call the get() method of the EntryFuture; this will\n-     * return the actual entry once it is ready for use and has been set().  To\n-     * conserve objects, EntryFutures synchronize on themselves.\n-     *\/\n-    private static class EntryFuture {\n-\n-        private static final Object unset = new Object();\n-        private final Thread owner = Thread.currentThread();\n-        private Object entry = unset;\n-\n-        \/**\n-         * Attempts to set the value contained by this EntryFuture.  If the\n-         * EntryFuture's value has not been set already, then the value is\n-         * saved, any callers blocked in the get() method are notified, and\n-         * true is returned.  If the value has already been set, then no saving\n-         * or notification occurs, and false is returned.\n-         *\/\n-        synchronized boolean set(Object entry) {\n-            if (this.entry != unset) {\n-                return false;\n-            }\n-            this.entry = entry;\n-            notifyAll();\n-            return true;\n-        }\n-\n-        \/**\n-         * Returns the value contained by this EntryFuture, blocking if\n-         * necessary until a value is set.\n-         *\/\n-        @SuppressWarnings(\"removal\")\n-        synchronized Object get() {\n-            boolean interrupted = false;\n-            while (entry == unset) {\n-                try {\n-                    wait();\n-                } catch (InterruptedException ex) {\n-                    interrupted = true;\n-                }\n-            }\n-            if (interrupted) {\n-                AccessController.doPrivileged(\n-                    new PrivilegedAction<>() {\n-                        public Void run() {\n-                            Thread.currentThread().interrupt();\n-                            return null;\n-                        }\n-                    }\n-                );\n-            }\n-            return entry;\n-        }\n-\n-        \/**\n-         * Returns the thread that created this EntryFuture.\n-         *\/\n-        Thread getOwner() {\n-            return owner;\n-        }\n+        return Caches.localDescs.get(cl);\n@@ -2251,24 +2120,9 @@\n-            localDesc.cl : null;\n-        processQueue(Caches.reflectorsQueue, Caches.reflectors);\n-        FieldReflectorKey key = new FieldReflectorKey(cl, fields,\n-                                                      Caches.reflectorsQueue);\n-        Reference<?> ref = Caches.reflectors.get(key);\n-        Object entry = null;\n-        if (ref != null) {\n-            entry = ref.get();\n-        }\n-        EntryFuture future = null;\n-        if (entry == null) {\n-            EntryFuture newEntry = new EntryFuture();\n-            Reference<?> newRef = new SoftReference<>(newEntry);\n-            do {\n-                if (ref != null) {\n-                    Caches.reflectors.remove(key, ref);\n-                }\n-                ref = Caches.reflectors.putIfAbsent(key, newRef);\n-                if (ref != null) {\n-                    entry = ref.get();\n-                }\n-            } while (ref != null && entry == null);\n-            if (entry == null) {\n-                future = newEntry;\n+            localDesc.cl : Void.class;\n+        var clReflectors = Caches.reflectors.get(cl);\n+        var key = new FieldReflectorKey(fields);\n+        var reflector = clReflectors.get(key);\n+        if (reflector == null) {\n+            reflector = new FieldReflector(matchFields(fields, localDesc));\n+            var oldReflector = clReflectors.putIfAbsent(key, reflector);\n+            if (oldReflector != null) {\n+                reflector = oldReflector;\n@@ -2277,26 +2131,1 @@\n-\n-        if (entry instanceof FieldReflector) {  \/\/ check common case first\n-            return (FieldReflector) entry;\n-        } else if (entry instanceof EntryFuture) {\n-            entry = ((EntryFuture) entry).get();\n-        } else if (entry == null) {\n-            try {\n-                entry = new FieldReflector(matchFields(fields, localDesc));\n-            } catch (Throwable th) {\n-                entry = th;\n-            }\n-            future.set(entry);\n-            Caches.reflectors.put(key, new SoftReference<>(entry));\n-        }\n-\n-        if (entry instanceof FieldReflector) {\n-            return (FieldReflector) entry;\n-        } else if (entry instanceof InvalidClassException) {\n-            throw (InvalidClassException) entry;\n-        } else if (entry instanceof RuntimeException) {\n-            throw (RuntimeException) entry;\n-        } else if (entry instanceof Error) {\n-            throw (Error) entry;\n-        } else {\n-            throw new InternalError(\"unexpected entry: \" + entry);\n-        }\n+        return reflector;\n@@ -2307,1 +2136,1 @@\n-     * refer to the same class and equivalent field formats.\n+     * refer to equivalent field formats.\n@@ -2309,1 +2138,1 @@\n-    private static class FieldReflectorKey extends WeakReference<Class<?>> {\n+    private static class FieldReflectorKey {\n@@ -2313,1 +2142,0 @@\n-        private final boolean nullClass;\n@@ -2315,2 +2143,1 @@\n-        FieldReflectorKey(Class<?> cl, ObjectStreamField[] fields,\n-                          ReferenceQueue<Class<?>> queue)\n+        FieldReflectorKey(ObjectStreamField[] fields)\n@@ -2318,2 +2145,0 @@\n-            super(cl, queue);\n-            nullClass = (cl == null);\n@@ -2326,1 +2151,1 @@\n-            hash = System.identityHashCode(cl) + Arrays.hashCode(sigs);\n+            hash = Arrays.hashCode(sigs);\n@@ -2334,13 +2159,3 @@\n-            if (obj == this) {\n-                return true;\n-            }\n-\n-            if (obj instanceof FieldReflectorKey other) {\n-                Class<?> referent;\n-                return (nullClass ? other.nullClass\n-                                  : ((referent = get()) != null) &&\n-                                    (other.refersTo(referent))) &&\n-                        Arrays.equals(sigs, other.sigs);\n-            } else {\n-                return false;\n-            }\n+            return obj == this ||\n+                   obj instanceof FieldReflectorKey other &&\n+                   Arrays.equals(sigs, other.sigs);\n@@ -2410,62 +2225,0 @@\n-    \/**\n-     * Removes from the specified map any keys that have been enqueued\n-     * on the specified reference queue.\n-     *\/\n-    static void processQueue(ReferenceQueue<Class<?>> queue,\n-                             ConcurrentMap<? extends\n-                             WeakReference<Class<?>>, ?> map)\n-    {\n-        Reference<? extends Class<?>> ref;\n-        while((ref = queue.poll()) != null) {\n-            map.remove(ref);\n-        }\n-    }\n-\n-    \/**\n-     *  Weak key for Class objects.\n-     *\n-     **\/\n-    static class WeakClassKey extends WeakReference<Class<?>> {\n-        \/**\n-         * saved value of the referent's identity hash code, to maintain\n-         * a consistent hash code after the referent has been cleared\n-         *\/\n-        private final int hash;\n-\n-        \/**\n-         * Create a new WeakClassKey to the given object, registered\n-         * with a queue.\n-         *\/\n-        WeakClassKey(Class<?> cl, ReferenceQueue<Class<?>> refQueue) {\n-            super(cl, refQueue);\n-            hash = System.identityHashCode(cl);\n-        }\n-\n-        \/**\n-         * Returns the identity hash code of the original referent.\n-         *\/\n-        public int hashCode() {\n-            return hash;\n-        }\n-\n-        \/**\n-         * Returns true if the given object is this identical\n-         * WeakClassKey instance, or, if this object's referent has not\n-         * been cleared, if the given object is another WeakClassKey\n-         * instance with the identical non-null referent as this one.\n-         *\/\n-        public boolean equals(Object obj) {\n-            if (obj == this) {\n-                return true;\n-            }\n-\n-            if (obj instanceof WeakClassKey) {\n-                Class<?> referent = get();\n-                return (referent != null) &&\n-                        (((WeakClassKey) obj).refersTo(referent));\n-            } else {\n-                return false;\n-            }\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":32,"deletions":279,"binary":false,"changes":311,"status":"modified"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.ref.WeakReference;\n+import java.lang.reflect.Constructor;\n+import java.io.ByteArrayOutputStream;\n+import java.io.InputStream;\n+import java.io.ObjectStreamClass;\n+import java.io.ObjectStreamField;\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+import jdk.test.lib.util.ForceGC;\n+\n+\/* @test\n+ * @bug 8277072\n+ * @library \/test\/lib\/\n+ * @build jdk.test.lib.util.ForceGC\n+ * @summary ObjectStreamClass caches keep ClassLoaders alive\n+ * @run testng TestOSCClassLoaderLeak\n+ *\/\n+public class TestOSCClassLoaderLeak {\n+\n+    @Test\n+    public void run() throws Exception {\n+        TestClassLoader myOwnClassLoader = new TestClassLoader();\n+        Class<?> loadClass = myOwnClassLoader.loadClass(\"ObjectStreamClass_MemoryLeakExample\");\n+        Constructor con = loadClass.getConstructor();\n+        con.setAccessible(true);\n+        Object objectStreamClass_MemoryLeakExample = con.newInstance();\n+        objectStreamClass_MemoryLeakExample.toString();\n+\n+        WeakReference<Object> myOwnClassLoaderWeakReference = new WeakReference<>(myOwnClassLoader);\n+        assertNotNull(myOwnClassLoaderWeakReference.get());\n+        objectStreamClass_MemoryLeakExample = null;\n+        myOwnClassLoader = null;\n+        loadClass = null;\n+        con = null;\n+        assertNotNull(myOwnClassLoaderWeakReference.get());\n+\n+        ForceGC gc = new ForceGC();\n+        assertTrue(gc.await(() -> myOwnClassLoaderWeakReference.get() == null));\n+    }\n+}\n+\n+class ObjectStreamClass_MemoryLeakExample {\n+    private static final ObjectStreamField[] fields = ObjectStreamClass.lookup(TestClass.class).getFields();\n+    public ObjectStreamClass_MemoryLeakExample() {\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return Arrays.toString(fields);\n+    }\n+}\n+\n+class TestClassLoader extends ClassLoader {\n+\n+    @Override\n+    public Class<?> loadClass(String name) throws ClassNotFoundException {\n+        if (name.equals(\"TestClass\") || name.equals(\"ObjectStreamClass_MemoryLeakExample\")) {\n+            byte[] bt = loadClassData(name);\n+            return defineClass(name, bt, 0, bt.length);\n+        } else {\n+            return super.loadClass(name);\n+        }\n+    }\n+\n+    private static byte[] loadClassData(String className) {\n+        ByteArrayOutputStream byteSt = new ByteArrayOutputStream();\n+        try (InputStream is = TestClassLoader.class.getClassLoader().getResourceAsStream(className.replace(\".\", \"\/\") + \".class\")) {\n+            int len = 0;\n+            while ((len = is.read()) != -1) {\n+                byteSt.write(len);\n+            }\n+        } catch (java.io.IOException e) {\n+            e.printStackTrace();\n+        }\n+        return byteSt.toByteArray();\n+    }\n+}\n+\n+class TestClass implements Serializable {\n+    public String x;\n+}\n","filename":"test\/jdk\/java\/io\/ObjectStreamClass\/TestOSCClassLoaderLeak.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"}]}