{"files":[{"patch":"@@ -38,0 +38,3 @@\n+size_t PSCardTable::stripe_size_in_words;\n+size_t PSCardTable::large_obj_arr_min_words;\n+\n@@ -139,1 +142,2 @@\n-\/\/ resides on are considered dirty.\n+\/\/ resides on are considered dirty except for large object arrays. The card marks\n+\/\/ of objArrays are precise which allows scanning of just the dirty parts.\n@@ -142,1 +146,2 @@\n-                                                         CardValue* const end_card) {\n+                                                         CardValue* const end_card,\n+                                                         objArrayOop const large_obj_array) {\n@@ -156,0 +161,5 @@\n+    if (large_obj_array == cast_to_oop(obj_addr)) {\n+      \/\/ We scan dirty parts of large objArrays precisely, so return immediately.\n+      assert(i_card <= end_card, \"inv\");\n+      return i_card;\n+    }\n@@ -185,0 +195,1 @@\n+    assert(!obj->is_objArray() || obj->size() < large_obj_arr_min_words, \"inv\");\n@@ -192,0 +203,10 @@\n+void PSCardTable::prepare_scavenge(int active_workers, size_t old_gen_used_words) {\n+  const int stripe_count_per_worker = 100;\n+  int stripe_count = active_workers * stripe_count_per_worker;\n+  size_t sz = MAX2(old_gen_used_words \/ stripe_count, 128 * (size_t)_card_size_in_words);\n+  stripe_size_in_words = align_up(sz, _card_size_in_words);\n+  large_obj_arr_min_words = 2 * stripe_size_in_words + 1;\n+  log_trace(gc, scavenge)(\"stripe count:%d stripe size:\" SIZE_FORMAT \"K\",\n+                          stripe_count, (stripe_size_in_words * HeapWordSize) \/ K);\n+}\n+\n@@ -229,0 +250,3 @@\n+\/\/\n+\/\/ Large objArrays are also distributed across threads by stripes, except for\n+\/\/ the last 2 stripes which are scanned by the thread owning the second-to-last stripe.\n@@ -236,2 +260,0 @@\n-  const size_t num_cards_in_stripe = 128;\n-  const size_t stripe_size_in_words = num_cards_in_stripe * _card_size_in_words;\n@@ -247,1 +269,1 @@\n-    \/\/ Process a stripe iff it contains any obj-start\n+    \/\/ Stripes without an object start may either contain a large object, or a part of a large objArray; the latter must be handled specially, the former is handled by the owner of the stripe where that large object starts.\n@@ -249,0 +271,2 @@\n+      \/\/ Scan middle and end of large arrays\n+      scavenge_large_array_stripe(start_array, pm, cur_stripe_addr, cur_stripe_end_addr, space_top);\n@@ -256,0 +280,1 @@\n+    \/\/ 4. range of large objArray elements can be scanned: [first_obj_addr, cur_stripe_end_addr)\n@@ -261,0 +286,1 @@\n+    objArrayOop large_arr = nullptr;\n@@ -280,1 +306,22 @@\n-      HeapWord* obj_end_addr = obj_addr + cast_to_oop(obj_addr)->size();\n+      size_t obj_sz = cast_to_oop(obj_addr)->size();\n+      HeapWord* obj_end_addr = obj_addr + obj_sz;\n+      \/\/ Scan the elements of a large array to the stripe end.\n+      if (obj_sz >= large_obj_arr_min_words && cast_to_oop(obj_addr)->is_objArray()) {\n+        if (first_obj_addr >= cur_stripe_end_addr) {\n+          \/\/ Nothing to scan according to constraints given above.\n+          \/\/ We reach here only for the last stripe below space_top where\n+          \/\/ object_starts_in_range() returns true if space_top is not aligned to\n+          \/\/ _card_size and an object starts there.\n+          assert(first_obj_addr == space_top, \"assumption\");\n+          assert(cur_stripe_end_addr == space_top, \"assumption\");\n+          \/\/ This stripe accomodates the end of a large array. It is scanned by the\n+          \/\/ thread owning the previous stripe.\n+          continue;\n+        }\n+        \/\/ Reaching here we know that the large array starts in this stripe.\n+        \/\/ If it starts here then its end has to be in a following stripe.\n+        assert(obj_addr >= cur_stripe_addr &&\n+               obj_end_addr >= cur_stripe_end_addr, \"overlapping work\");\n+        obj_end_addr = cur_stripe_end_addr;\n+        large_arr = objArrayOop(cast_to_oop(obj_addr));\n+      }\n@@ -296,1 +343,1 @@\n-      dirty_r = find_first_clean_card(start_array, dirty_l, iter_limit_r);\n+      dirty_r = find_first_clean_card(start_array, dirty_l, iter_limit_r, large_arr);\n@@ -309,1 +356,1 @@\n-      \/\/ Process this non-empty dirty chunk in two steps:\n+      \/\/ Process this non-empty dirty chunk in three steps:\n@@ -318,0 +365,1 @@\n+        \/\/    Exclude the large array if one begins in the stripe\n@@ -322,1 +370,3 @@\n-                               cur_stripe_end_addr);\n+                               large_arr != nullptr ?\n+                                   cast_from_oop<HeapWord*>(large_arr) :\n+                                   cur_stripe_end_addr);\n@@ -326,0 +376,80 @@\n+\n+      if (large_arr != nullptr && addr_for(dirty_r) >= cast_from_oop<HeapWord*>(large_arr)) {\n+        \/\/ 3. Scan the large array elements in [dirty_l, cur_stripe_end_addr).\n+        \/\/    Note: scanning just dirty chunks can be very slow if dirty and\n+        \/\/    clean cards are alternating therefore we don't do it.\n+        HeapWord* arr_l = addr_for(dirty_l);\n+\n+        HeapWord* arr_r = cur_stripe_end_addr;\n+\n+        pm->push_array_region(large_arr, arr_l, arr_r);\n+        \/\/ We're done with this stripe. Continue in the next slice.\n+        break;\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ Partially scan a large object array in the given stripe.\n+\/\/ Scan to end if it is in the next stripe.\n+void PSCardTable::scavenge_large_array_stripe(ObjectStartArray* start_array,\n+                                              PSPromotionManager* pm,\n+                                              HeapWord* stripe_addr,\n+                                              HeapWord* stripe_end_addr,\n+                                              HeapWord* space_top) {\n+  HeapWord* large_arr_addr = start_array->object_start(stripe_addr);\n+\n+  size_t arr_sz;\n+  if (large_arr_addr == nullptr ||\n+      !cast_to_oop(large_arr_addr)->is_objArray() ||\n+      (arr_sz = cast_to_oop(large_arr_addr)->size()) < large_obj_arr_min_words)\n+    return;\n+\n+  objArrayOop large_arr = objArrayOop(cast_to_oop(large_arr_addr));\n+  HeapWord* arr_end_addr = large_arr_addr + arr_sz;\n+\n+  if (arr_end_addr <= stripe_end_addr) {\n+    \/\/ The end chunk is scanned together with the chunk in the previous stripe.\n+    assert(large_obj_arr_min_words > 2 * stripe_size_in_words, \"2nd last chunk must cover stripe\");\n+    return;\n+  }\n+\n+  \/\/ Constraints:\n+  \/\/ 1. range of cards checked for being dirty or clean: [iter_limit_l, iter_limit_r)\n+  \/\/ 2. range of cards can be cleared: [clear_limit_l, clear_limit_r)\n+  \/\/ 3. range of large objArray elements can be scanned: [stripe_addr, scan_limit_r)\n+\n+  CardValue* iter_limit_l = byte_for(stripe_addr);\n+  CardValue* iter_limit_r = byte_for(stripe_end_addr - 1) + 1;\n+  CardValue* clear_limit_l = byte_for(stripe_addr);\n+  CardValue* clear_limit_r = byte_for(stripe_end_addr);\n+\n+  HeapWord* scan_limit_r = stripe_end_addr;\n+  HeapWord* next_stripe = stripe_end_addr;\n+  HeapWord* next_stripe_end = MIN2(next_stripe + stripe_size_in_words, space_top);\n+\n+  \/\/ Scan to end if it is in the following stripe.\n+  if (arr_end_addr > next_stripe && arr_end_addr <= next_stripe_end) {\n+    clear_limit_r = byte_for(arr_end_addr);\n+    iter_limit_r = byte_for(arr_end_addr - 1) + 1;\n+    scan_limit_r = arr_end_addr;\n+  }\n+\n+  \/\/ Process array elements on the first dirty card to scan_limit_r.\n+  \/\/ Note: scanning just dirty chunks can be very slow if dirty and\n+  \/\/ clean cards are alternating therefore we don't do it.\n+  CardValue* dirty_l = find_first_dirty_card(iter_limit_l, iter_limit_r);\n+\n+  if (dirty_l < iter_limit_r) {\n+    \/\/ The processing is done in two steps:\n+    {\n+      \/\/ 1. Clear cards in [dirty_l, clear_limit_r) subject to [clear_limit_l, clear_limit_r) constraint.\n+      clear_cards(MAX2(dirty_l, clear_limit_l),\n+                  clear_limit_r);\n+    }\n+\n+    {\n+      \/\/ 2. Scan elements in [dirty_l, scan_limit_r)\n+      HeapWord* left = addr_for(dirty_l);\n+      HeapWord* right = scan_limit_r;\n+      pm->push_array_region(large_arr, left, right);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.cpp","additions":139,"deletions":9,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -45,0 +45,3 @@\n+  static size_t stripe_size_in_words;\n+  static size_t large_obj_arr_min_words;\n+\n@@ -50,1 +53,2 @@\n-                                   CardValue* const end_card);\n+                                   CardValue* const end_card,\n+                                   objArrayOop const large_obj_array);\n@@ -65,0 +69,1 @@\n+  void prepare_scavenge(int active_workers, size_t old_gen_used_words);\n@@ -71,0 +76,5 @@\n+  void scavenge_large_array_stripe(ObjectStartArray* start_array,\n+                                   PSPromotionManager* pm,\n+                                   HeapWord* stripe_addr,\n+                                   HeapWord* stripe_end_addr,\n+                                   HeapWord* space_top);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.hpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -357,0 +357,6 @@\n+\n+void PSPromotionManager::push_array_region(objArrayOop arr, HeapWord* left, HeapWord* right) {\n+  PSPushContentsClosure pcc(this);\n+  arr->oop_oop_iterate_bounded(&pcc, MemRegion(left, right));\n+  drain_stacks_cond_depth();\n+}\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -180,0 +180,1 @@\n+  void push_array_region(objArrayOop arr, HeapWord* left, HeapWord* right);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -304,0 +304,2 @@\n+    PSCardTable* card_table = ParallelScavengeHeap::heap()->card_table();\n+    card_table->prepare_scavenge(active_workers, old_gen->object_space()->used_in_words());\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -115,0 +115,3 @@\n+  \/\/ Iterate over oop elements within mr, and metadata.\n+  template <typename OopClosureType>\n+  inline void oop_oop_iterate_bounded(OopClosureType* closure, MemRegion mr);\n","filename":"src\/hotspot\/share\/oops\/objArrayOop.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"oops\/objArrayKlass.inline.hpp\"\n@@ -54,0 +55,8 @@\n+template <typename OopClosureType>\n+void objArrayOopDesc::oop_oop_iterate_bounded(OopClosureType* closure, MemRegion mr) {\n+  if (UseCompressedOops) {\n+    ((ObjArrayKlass*)klass())->oop_oop_iterate_bounded<narrowOop>(this, closure, mr);\n+  } else {\n+    ((ObjArrayKlass*)klass())->oop_oop_iterate_bounded<oop>(this, closure, mr);\n+  }\n+}\n","filename":"src\/hotspot\/share\/oops\/objArrayOop.inline.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"}]}