{"files":[{"patch":"@@ -38,2 +38,0 @@\n-size_t PSCardTable::stripe_size_in_words;\n-\n@@ -206,22 +204,0 @@\n-void PSCardTable::prepare_scavenge(int active_workers, size_t old_gen_used_words) {\n-  \/\/ For parallel scanning of large object arrays the size of stripes is\n-  \/\/ increased inversely to the number of threads. Especially with just 2\n-  \/\/ threads the cost of work partitioning is otherwise too high. It cannot be\n-  \/\/ amortized by just 2 threads when scanning very large arrays.\n-  \/\/ We limit the stripe size to a maximum of 1M (with 512b cards) if there are\n-  \/\/ more than 8 active worker threads because we want to make sure that large\n-  \/\/ arrays of only a few megabytes are also scanned in parallel. This prevents\n-  \/\/ regressions due to cache thrashing caused by work stealing.\n-  const size_t stripe_min_size_in_words = 128 * card_size_in_words(); \/\/ 64K by default\n-  const size_t stripe_max_size_in_words = 16 * stripe_min_size_in_words;\n-  const int stripe_count_per_worker = 100;\n-  int stripe_count = active_workers * stripe_count_per_worker;\n-  size_t sz = MAX2(old_gen_used_words \/ stripe_count, stripe_min_size_in_words);\n-  if (active_workers >= 8 && sz > stripe_max_size_in_words) {\n-    sz = stripe_max_size_in_words;\n-  }\n-  stripe_size_in_words = align_up(sz, card_size_in_words());\n-  log_trace(gc, scavenge)(\"stripe size:\" SIZE_FORMAT \"K\",\n-                          (stripe_size_in_words * HeapWordSize) \/ K);\n-}\n-\n@@ -277,0 +253,1 @@\n+  const size_t stripe_size_in_words = num_cards_in_stripe * _card_size_in_words;\n@@ -281,0 +258,18 @@\n+  \/\/ Cache object start information from previous stripe to avoid expensive and\n+  \/\/ repetitive start array queries.\n+  struct StartCache {\n+      HeapWord* obj_start;\n+      HeapWord* obj_end;\n+      DEBUG_ONLY(HeapWord* prev_query);\n+      StartCache() : obj_start(nullptr), obj_end(nullptr) DEBUG_ONLY(COMMA prev_query(nullptr)) {}\n+      HeapWord* object_start(HeapWord* addr, ObjectStartArray* start_array) {\n+        assert(prev_query == nullptr || prev_query <= addr, \"inv\");\n+        if (addr >= obj_end) {\n+          obj_start = start_array->object_start(addr);\n+          obj_end = obj_start + cast_to_oop(obj_start)->size();\n+        }\n+        DEBUG_ONLY(prev_query = addr);\n+        return obj_start;\n+      }\n+  } start_cache;\n+\n@@ -290,1 +285,1 @@\n-      oop large_obj = cast_to_oop(start_array->object_start(cur_stripe_addr));\n+      oop large_obj = cast_to_oop(start_cache.object_start(cur_stripe_addr, start_array));\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.cpp","additions":20,"deletions":25,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  static size_t stripe_size_in_words;\n+  static size_t const num_cards_in_stripe = 128;\n@@ -48,0 +48,1 @@\n+    const size_t stripe_size_in_words = num_cards_in_stripe * _card_size_in_words;\n@@ -74,1 +75,0 @@\n-  void prepare_scavenge(int active_workers, size_t old_gen_used_words);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -304,2 +304,0 @@\n-    PSCardTable* card_table = ParallelScavengeHeap::heap()->card_table();\n-    card_table->prepare_scavenge(active_workers, old_gen->object_space()->used_in_words());\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}