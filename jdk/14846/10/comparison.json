{"files":[{"patch":"@@ -38,0 +38,2 @@\n+size_t PSCardTable::stripe_size_in_words;\n+\n@@ -137,0 +139,11 @@\n+\/\/ postcondition: ret is a clean card or end_card\n+CardTable::CardValue* PSCardTable::find_first_clean_card(CardValue* const start_card,\n+                                                         CardValue* const end_card) {\n+  for (CardValue* i_card = start_card; i_card < end_card; ++i_card) {\n+    if (*i_card == PSCardTable::clean_card_val()) {\n+      return i_card;\n+    }\n+  }\n+  return end_card;\n+}\n+\n@@ -185,0 +198,1 @@\n+    assert(!obj->is_objArray() || !is_large_obj_array(obj), \"single threaded scanning of large array\");\n@@ -192,0 +206,22 @@\n+void PSCardTable::prepare_scavenge(int active_workers, size_t old_gen_used_words) {\n+  \/\/ For parallel scanning of large object arrays the size of stripes is\n+  \/\/ increased inversely to the number of threads. Especially with just 2\n+  \/\/ threads the cost of work partitioning is otherwise too high. It cannot be\n+  \/\/ amortized by just 2 threads when scanning very large arrays.\n+  \/\/ We limit the stripe size to a maximum of 1M (with 512b cards) if there are\n+  \/\/ more than 8 active worker threads because we want to make sure that large\n+  \/\/ arrays of only a few megabytes are also scanned in parallel. This prevents\n+  \/\/ regressions due to cache thrashing caused by work stealing.\n+  const size_t stripe_min_size_in_words = 128 * card_size_in_words(); \/\/ 64K by default\n+  const size_t stripe_max_size_in_words = 16 * stripe_min_size_in_words;\n+  const int stripe_count_per_worker = 100;\n+  int stripe_count = active_workers * stripe_count_per_worker;\n+  size_t sz = MAX2(old_gen_used_words \/ stripe_count, stripe_min_size_in_words);\n+  if (active_workers >= 8 && sz > stripe_max_size_in_words) {\n+    sz = stripe_max_size_in_words;\n+  }\n+  stripe_size_in_words = align_up(sz, card_size_in_words());\n+  log_trace(gc, scavenge)(\"stripe size:\" SIZE_FORMAT \"K\",\n+                          (stripe_size_in_words * HeapWordSize) \/ K);\n+}\n+\n@@ -229,0 +265,5 @@\n+\/\/\n+\/\/ Objects starting in a stripe are scanned completely and exclusively by the\n+\/\/ stripe owner even if they extend beyond the stripe end. Large object\n+\/\/ arrays are an exception to this rule. A thread scans only array elements on\n+\/\/ its stripe.\n@@ -236,2 +277,0 @@\n-  const size_t num_cards_in_stripe = 128;\n-  const size_t stripe_size_in_words = num_cards_in_stripe * _card_size_in_words;\n@@ -247,1 +286,0 @@\n-    \/\/ Process a stripe iff it contains any obj-start\n@@ -249,0 +287,8 @@\n+      \/\/ No object start means nothing to do. Except if the large object that\n+      \/\/ covers the stripe is a large object array. In that case we scavenge its\n+      \/\/ elements on the stripe.\n+      oop large_obj = cast_to_oop(start_array->object_start(cur_stripe_addr));\n+      if (is_large_obj_array(large_obj)) {\n+        scavenge_large_array_contents(objArrayOop(large_obj), pm, cur_stripe_addr, cur_stripe_end_addr,\n+                                      space_top, false \/* first_card_already_cleared *\/);\n+      }\n@@ -252,0 +298,2 @@\n+    \/\/ Process objects starting in this stripe.\n+\n@@ -256,0 +304,2 @@\n+    \/\/ 4. range of large objArray elements to be scanned: [cur_stripe_addr, cur_stripe_end_addr)\n+    \/\/    limited to dirty cards.\n@@ -264,0 +314,1 @@\n+    oop first_obj = cast_to_oop(first_obj_addr);\n@@ -265,2 +316,10 @@\n-      \/\/ this obj belongs to previous stripe; can't clear any cards it occupies\n-      first_obj_addr += cast_to_oop(first_obj_addr)->size();\n+      \/\/ This obj belongs to previous stripe unless it is a large object\n+      \/\/ array. In that case we must scan its elements on this stripe.\n+      if (is_large_obj_array(first_obj)) {\n+        scavenge_large_array_contents(objArrayOop(first_obj), pm, cur_stripe_addr, cur_stripe_end_addr,\n+                                      space_top, false \/* first_card_already_cleared *\/);\n+      }\n+      \/\/ Continue with the first object that actually starts here.\n+      \/\/ We don't clear the starting card if it is shared with previous\n+      \/\/ objects. They might be scanned by the owner of the previous stripe.\n+      first_obj_addr += first_obj->size();\n@@ -277,0 +336,2 @@\n+    objArrayOop large_arr = nullptr;\n+    bool large_arr_cleared_first_card = false;\n@@ -281,3 +342,18 @@\n-      assert(obj_end_addr >= cur_stripe_end_addr, \"inv\");\n-      clear_limit_r = byte_for(obj_end_addr);\n-      iter_limit_r = byte_for(obj_end_addr - 1) + 1;\n+      if (is_large_obj_array(cast_to_oop(obj_addr))) {\n+        if (obj_addr < cur_stripe_addr) {\n+          \/\/ Scanned above already.\n+          assert(obj_addr == start_array->object_start(cur_stripe_addr), \"assumption\");\n+          continue;\n+        }\n+        \/\/ This is a large object array. We scan its elements on this stripe\n+        \/\/ after scanning the objects before it. The first card of the large\n+        \/\/ array will be cleared if it is not exclusive to it.\n+        large_arr = objArrayOop(cast_to_oop(obj_addr));\n+        large_arr_cleared_first_card =\n+            !is_card_aligned(obj_addr) && *byte_for(obj_addr) != PSCardTable::clean_card_val();\n+        clear_limit_r = iter_limit_r = byte_for(obj_addr - 1) + 1;\n+      } else {\n+        assert(obj_end_addr >= cur_stripe_end_addr, \"inv\");\n+        clear_limit_r = byte_for(obj_end_addr);\n+        iter_limit_r = byte_for(obj_end_addr - 1) + 1;\n+      }\n@@ -318,0 +394,1 @@\n+        \/\/    Exclude the large array if one begins in the stripe\n@@ -322,1 +399,3 @@\n-                               cur_stripe_end_addr);\n+                               large_arr != nullptr ?\n+                                   cast_from_oop<HeapWord*>(large_arr) :\n+                                   cur_stripe_end_addr);\n@@ -327,0 +406,82 @@\n+\n+    if (large_arr != nullptr) {\n+      scavenge_large_array_contents(large_arr, pm, cur_stripe_addr, cur_stripe_end_addr,\n+                                    space_top, large_arr_cleared_first_card);\n+    }\n+  }\n+}\n+\n+void PSCardTable::scavenge_large_array_contents(objArrayOop large_arr,\n+                                                PSPromotionManager* pm,\n+                                                HeapWord* stripe_addr,\n+                                                HeapWord* stripe_end_addr,\n+                                                HeapWord* space_top,\n+                                                bool first_card_already_cleared) {\n+  HeapWord* arr_addr = cast_from_oop<HeapWord*>(large_arr);\n+  HeapWord* arr_end_addr = arr_addr + large_arr->size();\n+\n+  \/\/ Constraints:\n+  \/\/ 1. range of cards checked for being dirty or clean: [iter_limit_l, iter_limit_r)\n+  \/\/ 2. range of cards can be cleared: [clear_limit_l, clear_limit_r)\n+  \/\/ 3. range of large objArray elements can be scanned: [stripe_addr, stripe_end_addr)\n+  \/\/    limited to dirty cards.\n+\n+  CardValue* iter_limit_l = byte_for(stripe_addr);\n+  CardValue* iter_limit_r = byte_for(stripe_end_addr - 1) + 1;\n+  CardValue* clear_limit_l = byte_for(stripe_addr);\n+  CardValue* clear_limit_r = byte_for(stripe_end_addr);\n+  assert(is_card_aligned(stripe_addr), \"assumption\");\n+  assert(is_card_aligned(stripe_end_addr) || stripe_end_addr == space_top, \"assumption\");\n+\n+  \/\/ Adjust left limits if the array starts in the stripe.\n+  \/\/ Also scan its first card if it was cleared already.\n+  if (stripe_addr <= arr_addr) {\n+    if (first_card_already_cleared) {\n+      assert(!is_card_aligned(arr_addr), \"first card is not shared with other objects\");\n+      clear_limit_l = iter_limit_l = byte_for(arr_addr) + 1;\n+      pm->push_objArray_contents(large_arr, arr_addr, align_up(arr_addr, card_size_in_words() * HeapWordSize));\n+    } else {\n+      iter_limit_l = byte_for(arr_addr);\n+      clear_limit_l = byte_for(arr_addr - 1) + 1;\n+    }\n+  }\n+\n+  \/\/ Adjust right limits if the array ends in the stripe\n+  if (arr_end_addr <= stripe_end_addr) {\n+    clear_limit_r = byte_for(arr_end_addr);\n+    iter_limit_r = byte_for(arr_end_addr - 1) + 1;\n+  }\n+\n+  \/\/ Process dirty chunks, i.e. consecutive dirty cards [dirty_l, dirty_r),\n+  \/\/ chunk by chunk inside [iter_limit_l, iter_limit_r).\n+  CardValue* dirty_l;\n+  CardValue* dirty_r;\n+\n+  for (CardValue* cur_card = iter_limit_l; cur_card < iter_limit_r; cur_card = dirty_r + 1) {\n+    dirty_l = find_first_dirty_card(cur_card, iter_limit_r);\n+    dirty_r = find_first_clean_card(dirty_l, iter_limit_r);\n+    assert(dirty_l <= dirty_r, \"inv\");\n+\n+    \/\/ empty\n+    if (dirty_l == dirty_r) {\n+      assert(dirty_r == iter_limit_r, \"no more dirty cards in this stripe\");\n+      break;\n+    }\n+\n+    assert(*dirty_l != clean_card, \"inv\");\n+    assert(*dirty_r == clean_card || dirty_r >= clear_limit_r,\n+           \"clean card or belonging to next stripe\");\n+\n+    \/\/ Process this non-empty dirty chunk in two steps:\n+    {\n+      \/\/ 1. Clear card in [dirty_l, dirty_r) subject to [clear_limit_l, clear_limit_r) constraint\n+      clear_cards(MAX2(dirty_l, clear_limit_l),\n+                  MIN2(dirty_r, clear_limit_r));\n+    }\n+\n+    {\n+      \/\/ 2. Scan elements in [dirty_l, dirty_r)\n+      HeapWord* left = addr_for(dirty_l);\n+      HeapWord* right = addr_for(dirty_r);\n+      pm->push_objArray_contents(large_arr, left, right);\n+    }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.cpp","additions":170,"deletions":9,"binary":false,"changes":179,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"oops\/oop.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n@@ -45,0 +45,6 @@\n+  static size_t stripe_size_in_words;\n+\n+  static bool is_large_obj_array(oop obj) {\n+    return obj->is_objArray() && obj->size() >= stripe_size_in_words;\n+  }\n+\n@@ -48,0 +54,3 @@\n+  CardValue* find_first_clean_card(CardValue* const start_card,\n+                                   CardValue* const end_card);\n+  \/\/ All cards of an object following a dirty card are considered dirty too.\n@@ -65,0 +74,1 @@\n+  void prepare_scavenge(int active_workers, size_t old_gen_used_words);\n@@ -71,0 +81,7 @@\n+  \/\/ Scavenge the elements of a large object array on dirty cards of the stripe.\n+  void scavenge_large_array_contents(objArrayOop large_arr,\n+                                     PSPromotionManager* pm,\n+                                     HeapWord* stripe_addr,\n+                                     HeapWord* stripe_end_addr,\n+                                     HeapWord* space_top,\n+                                     bool first_card_already_cleared);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.hpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -357,0 +357,6 @@\n+\n+void PSPromotionManager::push_objArray_contents(objArrayOop arr, HeapWord* left, HeapWord* right) {\n+  PSPushContentsClosure pcc(this);\n+  arr->oop_oop_iterate_bounded(&pcc, MemRegion(left, right));\n+  drain_stacks_cond_depth();\n+}\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -180,0 +180,1 @@\n+  void push_objArray_contents(objArrayOop arr, HeapWord* left, HeapWord* right);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -304,0 +304,2 @@\n+    PSCardTable* card_table = ParallelScavengeHeap::heap()->card_table();\n+    card_table->prepare_scavenge(active_workers, old_gen->object_space()->used_in_words());\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -115,0 +115,3 @@\n+  \/\/ Iterate over oop elements within mr, and metadata.\n+  template <typename OopClosureType>\n+  inline void oop_oop_iterate_bounded(OopClosureType* closure, MemRegion mr);\n","filename":"src\/hotspot\/share\/oops\/objArrayOop.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"oops\/objArrayKlass.inline.hpp\"\n@@ -54,0 +55,8 @@\n+template <typename OopClosureType>\n+void objArrayOopDesc::oop_oop_iterate_bounded(OopClosureType* closure, MemRegion mr) {\n+  if (UseCompressedOops) {\n+    ((ObjArrayKlass*)klass())->oop_oop_iterate_bounded<narrowOop>(this, closure, mr);\n+  } else {\n+    ((ObjArrayKlass*)klass())->oop_oop_iterate_bounded<oop>(this, closure, mr);\n+  }\n+}\n","filename":"src\/hotspot\/share\/oops\/objArrayOop.inline.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"}]}