{"files":[{"patch":"@@ -159,3 +159,2 @@\n-    \/\/ Find the final obj on the prev dirty card.\n-    HeapWord* obj_addr = start_array->object_start(addr_for(i_card)-1);\n-    if (large_obj_array == cast_to_oop(obj_addr)) {\n+    HeapWord* i_card_addr = addr_for(i_card);\n+    if (large_obj_array != nullptr && i_card_addr >= cast_from_oop<HeapWord*>(large_obj_array)) {\n@@ -166,0 +165,2 @@\n+    \/\/ Find the final obj on the prev dirty card.\n+    HeapWord* obj_addr = start_array->object_start(i_card_addr-1);\n@@ -280,1 +281,2 @@\n-    \/\/ 4. range of large objArray elements can be scanned: [first_obj_addr, cur_stripe_end_addr)\n+    \/\/ 4. range of large objArray elements to be scanned: [first_obj_addr, cur_stripe_end_addr)\n+    \/\/    limited to dirty regions\n@@ -363,1 +365,1 @@\n-      {\n+      if (large_arr == nullptr || addr_for(dirty_l) < cast_from_oop<HeapWord*>(large_arr)) {\n@@ -378,3 +380,1 @@\n-        \/\/ 3. Scan the large array elements in [dirty_l, cur_stripe_end_addr).\n-        \/\/    Note: scanning just dirty chunks can be very slow if dirty and\n-        \/\/    clean cards are alternating therefore we don't do it.\n+        \/\/ 3. Scan the large array elements in [dirty_l, dirty_r) subject to [large_arr, cur_stripe_end_addr)\n@@ -383,1 +383,2 @@\n-        HeapWord* arr_r = cur_stripe_end_addr;\n+        HeapWord* arr_r = MIN2(addr_for(dirty_r),\n+                               cur_stripe_end_addr);\n@@ -386,2 +387,0 @@\n-        \/\/ We're done with this stripe. Continue in the next slice.\n-        break;\n@@ -417,5 +416,0 @@\n-  \/\/ Constraints:\n-  \/\/ 1. range of cards checked for being dirty or clean: [iter_limit_l, iter_limit_r)\n-  \/\/ 2. range of cards can be cleared: [clear_limit_l, clear_limit_r)\n-  \/\/ 3. range of large objArray elements can be scanned: [stripe_addr, scan_limit_r)\n-\n@@ -438,4 +432,19 @@\n-  \/\/ Process array elements on the first dirty card to scan_limit_r.\n-  \/\/ Note: scanning just dirty chunks can be very slow if dirty and\n-  \/\/ clean cards are alternating therefore we don't do it.\n-  CardValue* dirty_l = find_first_dirty_card(iter_limit_l, iter_limit_r);\n+  \/\/ Process dirty chunks, i.e. consecutive dirty cards [dirty_l, dirty_r),\n+  \/\/ chunk by chunk inside [iter_limit_l, iter_limit_r).\n+  CardValue* dirty_l;\n+  CardValue* dirty_r;\n+\n+  for (CardValue* cur_card = iter_limit_l; cur_card < iter_limit_r; cur_card = dirty_r + 1) {\n+    dirty_l = find_first_dirty_card(cur_card, iter_limit_r);\n+    dirty_r = find_first_clean_card(start_array, dirty_l, iter_limit_r, large_arr);\n+    assert(dirty_l <= dirty_r, \"inv\");\n+\n+    \/\/ empty\n+    if (dirty_l == dirty_r) {\n+      assert(dirty_r == iter_limit_r, \"no more dirty cards in this stripe\");\n+      break;\n+    }\n+\n+    assert(*dirty_l != clean_card, \"inv\");\n+    assert(*dirty_r == clean_card || dirty_r >= clear_limit_r,\n+           \"clean card or belonging to next stripe\");\n@@ -443,2 +452,1 @@\n-  if (dirty_l < iter_limit_r) {\n-    \/\/ The processing is done in two steps:\n+    \/\/ Process this non-empty dirty chunk in two steps:\n@@ -446,1 +454,1 @@\n-      \/\/ 1. Clear cards in [dirty_l, clear_limit_r) subject to [clear_limit_l, clear_limit_r) constraint.\n+      \/\/ 1. Clear card in [dirty_l, dirty_r) subject to [clear_limit_l, clear_limit_r) constraint\n@@ -448,1 +456,1 @@\n-                  clear_limit_r);\n+                  MIN2(dirty_r, clear_limit_r));\n@@ -452,1 +460,1 @@\n-      \/\/ 2. Scan elements in [dirty_l, scan_limit_r)\n+      \/\/ 2. Scan elements in [dirty_l, dirty_r)\n@@ -454,1 +462,1 @@\n-      HeapWord* right = scan_limit_r;\n+      HeapWord* right = MIN2(addr_for(dirty_r), scan_limit_r);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.cpp","additions":34,"deletions":26,"binary":false,"changes":60,"status":"modified"}]}