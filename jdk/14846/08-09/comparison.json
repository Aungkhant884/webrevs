{"files":[{"patch":"@@ -196,1 +196,1 @@\n-    assert(!obj->is_objArray() || obj->size() < large_obj_arr_min_words, \"inv\");\n+    assert(!obj->is_objArray() || !is_large_obj_array(obj), \"single threaded scanning of large array\");\n@@ -252,2 +252,5 @@\n-\/\/ Large objArrays are also distributed across threads by stripes, except for\n-\/\/ the last 2 stripes which are scanned by the thread owning the second-to-last stripe.\n+\/\/ Objects starting in a stripe are scanned completely and exclusively by the\n+\/\/ stripe owning thread even if they extend beyond the stripe end. Large object\n+\/\/ arrays are an exception to this rule. A thread scans only the part of a large\n+\/\/ object array on its stripe except for the last 2 stripes which are scanned by\n+\/\/ the thread owning the second-to-last stripe.\n@@ -270,1 +273,0 @@\n-    \/\/ Stripes without an object start may either contain a large object, or a part of a large objArray; the latter must be handled specially, the former is handled by the owner of the stripe where that large object starts.\n@@ -272,2 +274,8 @@\n-      \/\/ Scan middle and end of large arrays\n-      scavenge_large_array_stripe(start_array, pm, cur_stripe_addr, cur_stripe_end_addr, space_top);\n+      \/\/ No object start means nothing to do. Except if the large object that\n+      \/\/ covers the stripe is a large object array. In that case we scavenge its\n+      \/\/ elements on the stripe.\n+      oop large_obj = cast_to_oop(start_array->object_start(cur_stripe_addr));\n+      if (is_large_obj_array(large_obj)) {\n+        scavenge_large_array_stripe(objArrayOop(large_obj), start_array, pm,\n+                                                cur_stripe_addr, cur_stripe_end_addr, space_top);\n+      }\n@@ -277,0 +285,2 @@\n+    \/\/ Process objects starting in this stripe.\n+\n@@ -282,1 +292,1 @@\n-    \/\/    limited to dirty regions\n+    \/\/    limited to dirty cards.\n@@ -386,1 +396,1 @@\n-        pm->push_array_region(large_arr, arr_l, arr_r);\n+        pm->push_objArray_contents(large_arr, arr_l, arr_r);\n@@ -392,3 +402,2 @@\n-\/\/ Partially scan a large object array in the given stripe.\n-\/\/ Scan to end if it is in the next stripe.\n-void PSCardTable::scavenge_large_array_stripe(ObjectStartArray* start_array,\n+void PSCardTable::scavenge_large_array_stripe(objArrayOop large_arr,\n+                                              ObjectStartArray* start_array,\n@@ -399,11 +408,1 @@\n-  HeapWord* large_arr_addr = start_array->object_start(stripe_addr);\n-\n-  size_t arr_sz;\n-  if (large_arr_addr == nullptr ||\n-      !cast_to_oop(large_arr_addr)->is_objArray() ||\n-      (arr_sz = cast_to_oop(large_arr_addr)->size()) < large_obj_arr_min_words)\n-    return;\n-\n-  objArrayOop large_arr = objArrayOop(cast_to_oop(large_arr_addr));\n-  HeapWord* arr_end_addr = large_arr_addr + arr_sz;\n-\n+  HeapWord* arr_end_addr = cast_from_oop<HeapWord*>(large_arr) + large_arr->size();\n@@ -411,1 +410,1 @@\n-    \/\/ The end chunk is scanned together with the chunk in the previous stripe.\n+    \/\/ The stripe is scanned together with the chunk in the previous stripe.\n@@ -416,0 +415,6 @@\n+  \/\/ Constraints:\n+  \/\/ 1. range of cards checked for being dirty or clean: [iter_limit_l, iter_limit_r)\n+  \/\/ 2. range of cards can be cleared: [clear_limit_l, clear_limit_r)\n+  \/\/ 3. range of large objArray elements can be scanned: [stripe_addr, scan_limit_r)\n+  \/\/    limited to dirty cards.\n+\n@@ -463,1 +468,1 @@\n-      pm->push_array_region(large_arr, left, right);\n+      pm->push_objArray_contents(large_arr, left, right);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.cpp","additions":29,"deletions":24,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"oops\/oop.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n@@ -48,0 +48,4 @@\n+  static bool is_large_obj_array(oop obj) {\n+    return obj->is_objArray() && obj->size() >= large_obj_arr_min_words;\n+  }\n+\n@@ -76,1 +80,4 @@\n-  void scavenge_large_array_stripe(ObjectStartArray* start_array,\n+  \/\/ Scavenge the elements of a large object array on dirty cards of the stripe.\n+  \/\/ Scan to end if it is in the next stripe.\n+  void scavenge_large_array_stripe(objArrayOop large_arr,\n+                                   ObjectStartArray* start_array,\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.hpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -358,1 +358,1 @@\n-void PSPromotionManager::push_array_region(objArrayOop arr, HeapWord* left, HeapWord* right) {\n+void PSPromotionManager::push_objArray_contents(objArrayOop arr, HeapWord* left, HeapWord* right) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-  void push_array_region(objArrayOop arr, HeapWord* left, HeapWord* right);\n+  void push_objArray_contents(objArrayOop arr, HeapWord* left, HeapWord* right);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}