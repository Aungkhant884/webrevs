{"files":[{"patch":"@@ -36,0 +36,1 @@\n+#include \"utilities\/spinYield.hpp\"\n@@ -215,2 +216,5 @@\n-void PSCardTable::pre_scavenge(uint active_workers) {\n-  _scavenge_phase1_active_workers = active_workers;\n+void PSCardTable::pre_scavenge(HeapWord* old_gen_bottom, uint active_workers) {\n+  _pre_scavenge_active_workers = active_workers;\n+  _pre_scavenge_current_goal_active_workers = active_workers;\n+  _pre_scavenge_current_goal = old_gen_bottom + _pre_scavenge_sync_interval;\n+  _pre_scavenge_completed_top = nullptr;\n@@ -330,0 +334,44 @@\n+\/\/ Propagate imprecise card marks from object start to the stripes an object extends to.\n+\/\/ Pre-scavenging and scavenging can overlap.\n+void PSCardTable::pre_scavenge_parallel(ObjectStartArray* start_array,\n+                                                 HeapWord* old_gen_bottom,\n+                                                 HeapWord* old_gen_top,\n+                                                 uint stripe_index,\n+                                                 uint n_stripes) {\n+  const uint active_workers = n_stripes;\n+  const size_t num_cards_in_slice = num_cards_in_stripe * n_stripes;\n+  CardValue* cur_card = byte_for(old_gen_bottom) + stripe_index * num_cards_in_stripe;\n+  CardValue* const end_card = byte_for(old_gen_top - 1) + 1;\n+  HeapWord* signaled_goal = nullptr;\n+  ObjStartCache start_cache(start_array);\n+\n+  for ( \/* empty *\/ ; cur_card < end_card; cur_card += num_cards_in_slice) {\n+    HeapWord* stripe_addr = addr_for(cur_card);\n+    if (!is_dirty(cur_card)) {\n+      HeapWord* first_obj_addr = start_cache.object_start(stripe_addr);\n+      if (first_obj_addr < stripe_addr) {\n+        oop first_obj = cast_to_oop(first_obj_addr);\n+        if (!first_obj->is_array() && is_dirty(byte_for(first_obj_addr))) {\n+          \/\/ Potentially imprecisely marked dirty.\n+          \/\/ Mark first card of stripe dirty too.\n+          *cur_card = dirty_card_val();\n+        }\n+      }\n+    }\n+    \/\/ Synchronization with already scavenging threads.\n+    if (signaled_goal < _pre_scavenge_current_goal && _pre_scavenge_current_goal <= stripe_addr) {\n+      signaled_goal = (HeapWord*) _pre_scavenge_current_goal;\n+      Atomic::dec(&_pre_scavenge_current_goal_active_workers);\n+      if (_pre_scavenge_current_goal_active_workers == 0) {\n+        \/\/ We're the last one to reach the current goal.\n+        \/\/ Set completed top.\n+        _pre_scavenge_completed_top = _pre_scavenge_current_goal;\n+        \/\/ Set next goal.\n+        _pre_scavenge_current_goal_active_workers = n_stripes;\n+        Atomic::add(&_pre_scavenge_current_goal, _pre_scavenge_sync_interval);\n+      }\n+    }\n+  }\n+  Atomic::dec(&_pre_scavenge_active_workers);\n+}\n+\n@@ -377,28 +425,2 @@\n-  \/\/ Propagate imprecise marks from object start to the stripes the object extends to.\n-  {\n-    const size_t num_cards_in_slice = num_cards_in_stripe * n_stripes;\n-    CardValue* cur_card = byte_for(old_gen_bottom) + stripe_index * num_cards_in_stripe;\n-    CardValue* const space_top_card = byte_for(old_gen_top);\n-\n-    ObjStartCache start_cache(start_array);\n-    for ( \/* empty *\/ ; cur_card < space_top_card; cur_card += num_cards_in_slice) {\n-      if (!is_dirty(cur_card)) {\n-        HeapWord* stripe_addr = addr_for(cur_card);\n-        HeapWord* first_obj_addr = start_cache.object_start(stripe_addr);\n-        if (first_obj_addr < stripe_addr) {\n-          oop first_obj = cast_to_oop(first_obj_addr);\n-          if (!first_obj->is_array() && is_dirty(byte_for(first_obj_addr))) {\n-            \/\/ Potentially imprecisely marked dirty.\n-            \/\/ Mark first card of stripe dirty too.\n-            *cur_card = dirty_card_val();\n-          }\n-        }\n-      }\n-    }\n-\n-    \/\/ Synchronize with co-worker threads.\n-    Atomic::dec(&_scavenge_phase1_active_workers);\n-    while(_scavenge_phase1_active_workers > 0) {\n-      os::naked_short_sleep(0);\n-    }\n-  }\n+  \/\/ Prepare scavenge\n+  pre_scavenge_parallel(start_array, old_gen_bottom, old_gen_top, stripe_index, n_stripes);\n@@ -409,0 +431,1 @@\n+  bool pre_scavenge_complete = false;\n@@ -414,0 +437,10 @@\n+    \/\/ Sync with concurrent pre-scavenge.\n+    if (!pre_scavenge_complete) {\n+      SpinYield spin;\n+      while (Atomic::load_acquire(&_pre_scavenge_active_workers) != 0 &&\n+             cur_stripe_addr > Atomic::load_acquire(&_pre_scavenge_completed_top)) {\n+        spin.wait();\n+      }\n+      pre_scavenge_complete = Atomic::load_acquire(&_pre_scavenge_active_workers) == 0;\n+    }\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.cpp","additions":63,"deletions":30,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -40,1 +40,9 @@\n-  volatile int _scavenge_phase1_active_workers;\n+  \/\/ Pre-scavenge support.\n+  \/\/ The pre-scavenge phase can overlap with scavenging.\n+  static size_t constexpr _pre_scavenge_sync_interval = 1*G;\n+  volatile HeapWord* _pre_scavenge_current_goal;\n+  volatile int _pre_scavenge_current_goal_active_workers;\n+  \/\/ A stripe is ready for scavenge if it's start is not higher then this.\n+  volatile HeapWord* _pre_scavenge_completed_top;\n+  \/\/ All stripes are ready for scavenge if all threads have completed pre-scavenge.\n+  volatile int _pre_scavenge_active_workers;\n@@ -82,1 +90,5 @@\n-  PSCardTable(MemRegion whole_heap) : CardTable(whole_heap), _scavenge_phase1_active_workers(0) {}\n+  PSCardTable(MemRegion whole_heap) : CardTable(whole_heap),\n+                                      _pre_scavenge_current_goal(nullptr),\n+                                      _pre_scavenge_current_goal_active_workers(0),\n+                                      _pre_scavenge_completed_top(nullptr),\n+                                      _pre_scavenge_active_workers(0) {}\n@@ -87,1 +99,1 @@\n-  void pre_scavenge(uint active_workers);\n+  void pre_scavenge(HeapWord* old_gen_bottom, uint active_workers);\n@@ -90,0 +102,9 @@\n+\n+  \/\/ Propagate imprecise card marks from object start to the stripes an object extends to.\n+  \/\/ Pre-scavenging and scavenging can overlap.\n+  void pre_scavenge_parallel(ObjectStartArray* start_array,\n+                             HeapWord* old_gen_bottom,\n+                             HeapWord* old_gen_top,\n+                             uint stripe_index,\n+                             uint n_stripes);\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.hpp","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -306,1 +306,1 @@\n-      card_table->pre_scavenge(active_workers);\n+      card_table->pre_scavenge(_old_gen->object_space()->bottom(), active_workers);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}