{"files":[{"patch":"@@ -280,2 +280,1 @@\n-    \/\/ 4. range of large objArray elements to be scanned: [first_obj_addr, cur_stripe_end_addr)\n-    \/\/    limited to dirty regions\n+    \/\/ 4. range of large objArray elements can be scanned: [first_obj_addr, cur_stripe_end_addr)\n@@ -379,1 +378,3 @@\n-        \/\/ 3. Scan the large array elements in [dirty_l, dirty_r) subject to [large_arr, cur_stripe_end_addr)\n+        \/\/ 3. Scan the large array elements in [dirty_l, cur_stripe_end_addr).\n+        \/\/    Note: scanning just dirty chunks can be very slow if dirty and\n+        \/\/    clean cards are alternating therefore we don't do it.\n@@ -382,2 +383,1 @@\n-        HeapWord* arr_r = MIN2(addr_for(dirty_r),\n-                               cur_stripe_end_addr);\n+        HeapWord* arr_r = cur_stripe_end_addr;\n@@ -386,0 +386,2 @@\n+        \/\/ We're done with this stripe. Continue in the next slice.\n+        break;\n@@ -415,0 +417,5 @@\n+  \/\/ Constraints:\n+  \/\/ 1. range of cards checked for being dirty or clean: [iter_limit_l, iter_limit_r)\n+  \/\/ 2. range of cards can be cleared: [clear_limit_l, clear_limit_r)\n+  \/\/ 3. range of large objArray elements can be scanned: [stripe_addr, scan_limit_r)\n+\n@@ -431,19 +438,4 @@\n-  \/\/ Process dirty chunks, i.e. consecutive dirty cards [dirty_l, dirty_r),\n-  \/\/ chunk by chunk inside [iter_limit_l, iter_limit_r).\n-  CardValue* dirty_l;\n-  CardValue* dirty_r;\n-\n-  for (CardValue* cur_card = iter_limit_l; cur_card < iter_limit_r; cur_card = dirty_r + 1) {\n-    dirty_l = find_first_dirty_card(cur_card, iter_limit_r);\n-    dirty_r = find_first_clean_card(start_array, dirty_l, iter_limit_r, large_arr);\n-    assert(dirty_l <= dirty_r, \"inv\");\n-\n-    \/\/ empty\n-    if (dirty_l == dirty_r) {\n-      assert(dirty_r == iter_limit_r, \"no more dirty cards in this stripe\");\n-      break;\n-    }\n-\n-    assert(*dirty_l != clean_card, \"inv\");\n-    assert(*dirty_r == clean_card || dirty_r >= clear_limit_r,\n-           \"clean card or belonging to next stripe\");\n+  \/\/ Process array elements on the first dirty card to scan_limit_r.\n+  \/\/ Note: scanning just dirty chunks can be very slow if dirty and\n+  \/\/ clean cards are alternating therefore we don't do it.\n+  CardValue* dirty_l = find_first_dirty_card(iter_limit_l, iter_limit_r);\n@@ -451,1 +443,2 @@\n-    \/\/ Process this non-empty dirty chunk in two steps:\n+  if (dirty_l < iter_limit_r) {\n+    \/\/ The processing is done in two steps:\n@@ -453,1 +446,1 @@\n-      \/\/ 1. Clear card in [dirty_l, dirty_r) subject to [clear_limit_l, clear_limit_r) constraint\n+      \/\/ 1. Clear cards in [dirty_l, clear_limit_r) subject to [clear_limit_l, clear_limit_r) constraint.\n@@ -455,1 +448,1 @@\n-                  MIN2(dirty_r, clear_limit_r));\n+                  clear_limit_r);\n@@ -459,1 +452,1 @@\n-      \/\/ 2. Scan elements in [dirty_l, dirty_r)\n+      \/\/ 2. Scan elements in [dirty_l, scan_limit_r)\n@@ -461,1 +454,1 @@\n-      HeapWord* right = MIN2(addr_for(dirty_r), scan_limit_r);\n+      HeapWord* right = scan_limit_r;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.cpp","additions":22,"deletions":29,"binary":false,"changes":51,"status":"modified"}]}