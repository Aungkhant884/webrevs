{"files":[{"patch":"@@ -39,1 +39,0 @@\n-size_t PSCardTable::large_obj_arr_min_words;\n@@ -140,0 +139,11 @@\n+\/\/ postcondition: ret is a clean card or end_card\n+CardTable::CardValue* PSCardTable::find_first_clean_card(CardValue* const start_card,\n+                                                         CardValue* const end_card) {\n+  for (CardValue* i_card = start_card; i_card < end_card; ++i_card) {\n+    if (*i_card == PSCardTable::clean_card_val()) {\n+      return i_card;\n+    }\n+  }\n+  return end_card;\n+}\n+\n@@ -142,2 +152,1 @@\n-\/\/ resides on are considered dirty except for large object arrays. The card marks\n-\/\/ of objArrays are precise which allows scanning of just the dirty parts.\n+\/\/ resides on are considered dirty.\n@@ -146,2 +155,1 @@\n-                                                         CardValue* const end_card,\n-                                                         objArrayOop const large_obj_array) {\n+                                                         CardValue* const end_card) {\n@@ -159,6 +167,0 @@\n-    HeapWord* i_card_addr = addr_for(i_card);\n-    if (large_obj_array != nullptr && i_card_addr >= cast_from_oop<HeapWord*>(large_obj_array)) {\n-      \/\/ We scan dirty parts of large objArrays precisely, so return immediately.\n-      assert(i_card <= end_card, \"inv\");\n-      return i_card;\n-    }\n@@ -166,1 +168,1 @@\n-    HeapWord* obj_addr = start_array->object_start(i_card_addr-1);\n+    HeapWord* obj_addr = start_array->object_start(addr_for(i_card)-1);\n@@ -205,0 +207,10 @@\n+  \/\/ For parallel scanning of large object arrays the size of stripes is\n+  \/\/ increased inversely to the number of threads. Especially with just 2\n+  \/\/ threads the cost of work partitioning is otherwise too high. It cannot be\n+  \/\/ amortized by just 2 threads when scanning very large arrays.\n+  \/\/ We limit the stripe size to a maximum of 1M (with 512b cards) if there are\n+  \/\/ more than 8 active worker threads because we want to make sure that large\n+  \/\/ arrays of only a few megabytes are also scanned in parallel. This prevents\n+  \/\/ regressions due to cache thrashing caused by work stealing.\n+  const size_t stripe_min_size_in_words = 128 * card_size_in_words(); \/\/ 64K by default\n+  const size_t stripe_max_size_in_words = 16 * stripe_min_size_in_words;\n@@ -207,5 +219,7 @@\n-  size_t sz = MAX2(old_gen_used_words \/ stripe_count, 128 * (size_t)_card_size_in_words);\n-  stripe_size_in_words = align_up(sz, _card_size_in_words);\n-  large_obj_arr_min_words = 2 * stripe_size_in_words + 1;\n-  log_trace(gc, scavenge)(\"stripe count:%d stripe size:\" SIZE_FORMAT \"K\",\n-                          stripe_count, (stripe_size_in_words * HeapWordSize) \/ K);\n+  size_t sz = MAX2(old_gen_used_words \/ stripe_count, stripe_min_size_in_words);\n+  if (active_workers >= 8 && sz > stripe_max_size_in_words) {\n+    sz = stripe_max_size_in_words;\n+  }\n+  stripe_size_in_words = align_up(sz, card_size_in_words());\n+  log_trace(gc, scavenge)(\"stripe size:\" SIZE_FORMAT \"K\",\n+                          (stripe_size_in_words * HeapWordSize) \/ K);\n@@ -253,4 +267,3 @@\n-\/\/ stripe owning thread even if they extend beyond the stripe end. Large object\n-\/\/ arrays are an exception to this rule. A thread scans only the part of a large\n-\/\/ object array on its stripe except for the last 2 stripes which are scanned by\n-\/\/ the thread owning the second-to-last stripe.\n+\/\/ stripe owner even if they extend beyond the stripe end. Large object\n+\/\/ arrays are an exception to this rule. A thread scans only array elements on\n+\/\/ its stripe.\n@@ -279,2 +292,2 @@\n-        scavenge_large_array_stripe(objArrayOop(large_obj), start_array, pm,\n-                                                cur_stripe_addr, cur_stripe_end_addr, space_top);\n+        scavenge_large_array_contents(objArrayOop(large_obj), pm, cur_stripe_addr, cur_stripe_end_addr,\n+                                      space_top, false \/* first_card_already_cleared *\/);\n@@ -291,1 +304,1 @@\n-    \/\/ 4. range of large objArray elements to be scanned: [first_obj_addr, cur_stripe_end_addr)\n+    \/\/ 4. range of large objArray elements to be scanned: [cur_stripe_addr, cur_stripe_end_addr)\n@@ -298,1 +311,0 @@\n-    objArrayOop large_arr = nullptr;\n@@ -302,0 +314,1 @@\n+    oop first_obj = cast_to_oop(first_obj_addr);\n@@ -303,2 +316,10 @@\n-      \/\/ this obj belongs to previous stripe; can't clear any cards it occupies\n-      first_obj_addr += cast_to_oop(first_obj_addr)->size();\n+      \/\/ This obj belongs to previous stripe unless it is a large object\n+      \/\/ array. In that case we must scan its elements on this stripe.\n+      if (is_large_obj_array(first_obj)) {\n+        scavenge_large_array_contents(objArrayOop(first_obj), pm, cur_stripe_addr, cur_stripe_end_addr,\n+                                      space_top, false \/* first_card_already_cleared *\/);\n+      }\n+      \/\/ Continue with the first object that actually starts here.\n+      \/\/ We don't clear the starting card if it is shared with previous\n+      \/\/ objects. They might be scanned by the owner of the previous stripe.\n+      first_obj_addr += first_obj->size();\n@@ -315,0 +336,2 @@\n+    objArrayOop large_arr = nullptr;\n+    bool large_arr_cleared_first_card = false;\n@@ -318,13 +341,5 @@\n-      size_t obj_sz = cast_to_oop(obj_addr)->size();\n-      HeapWord* obj_end_addr = obj_addr + obj_sz;\n-      \/\/ Scan the elements of a large array to the stripe end.\n-      if (obj_sz >= large_obj_arr_min_words && cast_to_oop(obj_addr)->is_objArray()) {\n-        if (first_obj_addr >= cur_stripe_end_addr) {\n-          \/\/ Nothing to scan according to constraints given above.\n-          \/\/ We reach here only for the last stripe below space_top where\n-          \/\/ object_starts_in_range() returns true if space_top is not aligned to\n-          \/\/ _card_size and an object starts there.\n-          assert(first_obj_addr == space_top, \"assumption\");\n-          assert(cur_stripe_end_addr == space_top, \"assumption\");\n-          \/\/ This stripe accomodates the end of a large array. It is scanned by the\n-          \/\/ thread owning the previous stripe.\n+      HeapWord* obj_end_addr = obj_addr + cast_to_oop(obj_addr)->size();\n+      if (is_large_obj_array(cast_to_oop(obj_addr))) {\n+        if (obj_addr < cur_stripe_addr) {\n+          \/\/ Scanned above already.\n+          assert(obj_addr == start_array->object_start(cur_stripe_addr), \"assumption\");\n@@ -333,5 +348,3 @@\n-        \/\/ Reaching here we know that the large array starts in this stripe.\n-        \/\/ If it starts here then its end has to be in a following stripe.\n-        assert(obj_addr >= cur_stripe_addr &&\n-               obj_end_addr >= cur_stripe_end_addr, \"overlapping work\");\n-        obj_end_addr = cur_stripe_end_addr;\n+        \/\/ This is a large object array. We scan its elements on this stripe\n+        \/\/ after scanning the objects before it. The first card of the large\n+        \/\/ array will be cleared if it is not exclusive to it.\n@@ -339,0 +352,7 @@\n+        large_arr_cleared_first_card =\n+            !is_card_aligned(obj_addr) && *byte_for(obj_addr) != PSCardTable::clean_card_val();\n+        clear_limit_r = iter_limit_r = byte_for(obj_addr - 1) + 1;\n+      } else {\n+        assert(obj_end_addr >= cur_stripe_end_addr, \"inv\");\n+        clear_limit_r = byte_for(obj_end_addr);\n+        iter_limit_r = byte_for(obj_end_addr - 1) + 1;\n@@ -340,3 +360,0 @@\n-      assert(obj_end_addr >= cur_stripe_end_addr, \"inv\");\n-      clear_limit_r = byte_for(obj_end_addr);\n-      iter_limit_r = byte_for(obj_end_addr - 1) + 1;\n@@ -355,1 +372,1 @@\n-      dirty_r = find_first_clean_card(start_array, dirty_l, iter_limit_r, large_arr);\n+      dirty_r = find_first_clean_card(start_array, dirty_l, iter_limit_r);\n@@ -368,1 +385,1 @@\n-      \/\/ Process this non-empty dirty chunk in three steps:\n+      \/\/ Process this non-empty dirty chunk in two steps:\n@@ -375,1 +392,1 @@\n-      if (large_arr == nullptr || addr_for(dirty_l) < cast_from_oop<HeapWord*>(large_arr)) {\n+      {\n@@ -388,0 +405,1 @@\n+    }\n@@ -389,9 +407,3 @@\n-      if (large_arr != nullptr && addr_for(dirty_r) >= cast_from_oop<HeapWord*>(large_arr)) {\n-        \/\/ 3. Scan the large array elements in [dirty_l, dirty_r) subject to [large_arr, cur_stripe_end_addr)\n-        HeapWord* arr_l = addr_for(dirty_l);\n-\n-        HeapWord* arr_r = MIN2(addr_for(dirty_r),\n-                               cur_stripe_end_addr);\n-\n-        pm->push_objArray_contents(large_arr, arr_l, arr_r);\n-      }\n+    if (large_arr != nullptr) {\n+      scavenge_large_array_contents(large_arr, pm, cur_stripe_addr, cur_stripe_end_addr,\n+                                    space_top, large_arr_cleared_first_card);\n@@ -402,12 +414,8 @@\n-void PSCardTable::scavenge_large_array_stripe(objArrayOop large_arr,\n-                                              ObjectStartArray* start_array,\n-                                              PSPromotionManager* pm,\n-                                              HeapWord* stripe_addr,\n-                                              HeapWord* stripe_end_addr,\n-                                              HeapWord* space_top) {\n-  HeapWord* arr_end_addr = cast_from_oop<HeapWord*>(large_arr) + large_arr->size();\n-  if (arr_end_addr <= stripe_end_addr) {\n-    \/\/ The stripe is scanned together with the chunk in the previous stripe.\n-    assert(large_obj_arr_min_words > 2 * stripe_size_in_words, \"2nd last chunk must cover stripe\");\n-    return;\n-  }\n+void PSCardTable::scavenge_large_array_contents(objArrayOop large_arr,\n+                                                PSPromotionManager* pm,\n+                                                HeapWord* stripe_addr,\n+                                                HeapWord* stripe_end_addr,\n+                                                HeapWord* space_top,\n+                                                bool first_card_already_cleared) {\n+  HeapWord* arr_addr = cast_from_oop<HeapWord*>(large_arr);\n+  HeapWord* arr_end_addr = arr_addr + large_arr->size();\n@@ -418,1 +426,1 @@\n-  \/\/ 3. range of large objArray elements can be scanned: [stripe_addr, scan_limit_r)\n+  \/\/ 3. range of large objArray elements can be scanned: [stripe_addr, stripe_end_addr)\n@@ -425,0 +433,15 @@\n+  assert(is_card_aligned(stripe_addr), \"assumption\");\n+  assert(is_card_aligned(stripe_end_addr) || stripe_end_addr == space_top, \"assumption\");\n+\n+  \/\/ Adjust left limits if the array starts in the stripe.\n+  \/\/ Also scan its first card if it was cleared already.\n+  if (stripe_addr <= arr_addr) {\n+    if (first_card_already_cleared) {\n+      assert(!is_card_aligned(arr_addr), \"first card is not shared with other objects\");\n+      clear_limit_l = iter_limit_l = byte_for(arr_addr) + 1;\n+      pm->push_objArray_contents(large_arr, arr_addr, align_up(arr_addr, card_size_in_words() * HeapWordSize));\n+    } else {\n+      iter_limit_l = byte_for(arr_addr);\n+      clear_limit_l = byte_for(arr_addr - 1) + 1;\n+    }\n+  }\n@@ -426,6 +449,2 @@\n-  HeapWord* scan_limit_r = stripe_end_addr;\n-  HeapWord* next_stripe = stripe_end_addr;\n-  HeapWord* next_stripe_end = MIN2(next_stripe + stripe_size_in_words, space_top);\n-\n-  \/\/ Scan to end if it is in the following stripe.\n-  if (arr_end_addr > next_stripe && arr_end_addr <= next_stripe_end) {\n+  \/\/ Adjust right limits if the array ends in the stripe\n+  if (arr_end_addr <= stripe_end_addr) {\n@@ -434,1 +453,0 @@\n-    scan_limit_r = arr_end_addr;\n@@ -444,1 +462,1 @@\n-    dirty_r = find_first_clean_card(start_array, dirty_l, iter_limit_r, large_arr);\n+    dirty_r = find_first_clean_card(dirty_l, iter_limit_r);\n@@ -467,1 +485,1 @@\n-      HeapWord* right = MIN2(addr_for(dirty_r), scan_limit_r);\n+      HeapWord* right = addr_for(dirty_r);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.cpp","additions":100,"deletions":82,"binary":false,"changes":182,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-  static size_t large_obj_arr_min_words;\n@@ -49,1 +48,1 @@\n-    return obj->is_objArray() && obj->size() >= large_obj_arr_min_words;\n+    return obj->is_objArray() && obj->size() >= stripe_size_in_words;\n@@ -55,0 +54,3 @@\n+  CardValue* find_first_clean_card(CardValue* const start_card,\n+                                   CardValue* const end_card);\n+  \/\/ All cards of an object following a dirty card are considered dirty too.\n@@ -57,2 +59,1 @@\n-                                   CardValue* const end_card,\n-                                   objArrayOop const large_obj_array);\n+                                   CardValue* const end_card);\n@@ -81,7 +82,6 @@\n-  \/\/ Scan to end if it is in the next stripe.\n-  void scavenge_large_array_stripe(objArrayOop large_arr,\n-                                   ObjectStartArray* start_array,\n-                                   PSPromotionManager* pm,\n-                                   HeapWord* stripe_addr,\n-                                   HeapWord* stripe_end_addr,\n-                                   HeapWord* space_top);\n+  void scavenge_large_array_contents(objArrayOop large_arr,\n+                                     PSPromotionManager* pm,\n+                                     HeapWord* stripe_addr,\n+                                     HeapWord* stripe_end_addr,\n+                                     HeapWord* space_top,\n+                                     bool first_card_already_cleared);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"}]}