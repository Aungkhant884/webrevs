{"files":[{"patch":"@@ -139,1 +139,2 @@\n-\/\/ resides on are considered dirty.\n+\/\/ resides on are considered dirty except for large object arrays. The card marks\n+\/\/ of objArrays are precise which allows scanning of just the dirty parts.\n@@ -142,1 +143,2 @@\n-                                                         CardValue* const end_card) {\n+                                                         CardValue* const end_card,\n+                                                         objArrayOop const large_obj_array) {\n@@ -156,0 +158,5 @@\n+    if (large_obj_array == cast_to_oop(obj_addr)) {\n+      \/\/ We scan dirty parts of large objArrays precisely, so return immediately.\n+      assert(i_card <= end_card, \"inv\");\n+      return i_card;\n+    }\n@@ -185,0 +192,1 @@\n+    assert(!obj->is_objArray() || obj->size() < large_obj_arr_min_words(), \"inv\");\n@@ -229,0 +237,3 @@\n+\/\/\n+\/\/ Large objArrays are also distributed across threads by stripes, except for\n+\/\/ the last 2 stripes which are scanned by the thread owning the second-to-last stripe.\n@@ -236,1 +247,0 @@\n-  const size_t num_cards_in_stripe = 128;\n@@ -247,1 +257,1 @@\n-    \/\/ Process a stripe iff it contains any obj-start\n+    \/\/ Stripes without an object start may either contain a large object, or a part of a large objArray; the latter must be handled specially, the former is handled by the owner of the stripe where that large object starts.\n@@ -249,0 +259,2 @@\n+      \/\/ Scan middle and end of large arrays\n+      scavenge_large_array_stripe(start_array, pm, cur_stripe_addr, cur_stripe_end_addr, space_top);\n@@ -256,0 +268,2 @@\n+    \/\/ 4. range of large objArray elements to be scanned: [first_obj_addr, cur_stripe_end_addr)\n+    \/\/    limited to dirty regions\n@@ -261,0 +275,1 @@\n+    objArrayOop large_arr = nullptr;\n@@ -280,1 +295,22 @@\n-      HeapWord* obj_end_addr = obj_addr + cast_to_oop(obj_addr)->size();\n+      size_t obj_sz = cast_to_oop(obj_addr)->size();\n+      HeapWord* obj_end_addr = obj_addr + obj_sz;\n+      \/\/ Scan the elements of a large array to the stripe end.\n+      if (obj_sz >= large_obj_arr_min_words() && cast_to_oop(obj_addr)->is_objArray()) {\n+        if (first_obj_addr >= cur_stripe_end_addr) {\n+          \/\/ Nothing to scan according to constraints given above.\n+          \/\/ We reach here only for the last stripe below space_top where\n+          \/\/ object_starts_in_range() returns true if space_top is not aligned to\n+          \/\/ _card_size and an object starts there.\n+          assert(first_obj_addr == space_top, \"assumption\");\n+          assert(cur_stripe_end_addr == space_top, \"assumption\");\n+          \/\/ This stripe accomodates the end of a large array. It is scanned by the\n+          \/\/ thread owning the previous stripe.\n+          continue;\n+        }\n+        \/\/ Reaching here we know that the large array starts in this stripe.\n+        \/\/ If it starts here then its end has to be in a following stripe.\n+        assert(obj_addr >= cur_stripe_addr &&\n+               obj_end_addr >= cur_stripe_end_addr, \"overlapping work\");\n+        obj_end_addr = cur_stripe_end_addr;\n+        large_arr = objArrayOop(cast_to_oop(obj_addr));\n+      }\n@@ -296,1 +332,1 @@\n-      dirty_r = find_first_clean_card(start_array, dirty_l, iter_limit_r);\n+      dirty_r = find_first_clean_card(start_array, dirty_l, iter_limit_r, large_arr);\n@@ -309,1 +345,1 @@\n-      \/\/ Process this non-empty dirty chunk in two steps:\n+      \/\/ Process this non-empty dirty chunk in three steps:\n@@ -318,0 +354,1 @@\n+        \/\/    Exclude the large array if one begins in the stripe\n@@ -322,1 +359,3 @@\n-                               cur_stripe_end_addr);\n+                               large_arr != nullptr ?\n+                                   cast_from_oop<HeapWord*>(large_arr) :\n+                                   cur_stripe_end_addr);\n@@ -326,0 +365,88 @@\n+\n+      if (large_arr != nullptr && addr_for(dirty_r) >= cast_from_oop<HeapWord*>(large_arr)) {\n+        \/\/ 3. Scan the large array elements in [dirty_l, dirty_r) subject to [large_arr, cur_stripe_end_addr)\n+        HeapWord* arr_l = addr_for(dirty_l);\n+\n+        HeapWord* arr_r = MIN2(addr_for(dirty_r),\n+                               cur_stripe_end_addr);\n+\n+        pm->push_array_region(large_arr, arr_l, arr_r);\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ Partially scan a large object array in the given stripe.\n+\/\/ Scan to end if it is in the next stripe.\n+void PSCardTable::scavenge_large_array_stripe(ObjectStartArray* start_array,\n+                                              PSPromotionManager* pm,\n+                                              HeapWord* stripe_addr,\n+                                              HeapWord* stripe_end_addr,\n+                                              HeapWord* space_top) {\n+  const size_t stripe_size_in_words = num_cards_in_stripe * _card_size_in_words;\n+\n+  HeapWord* large_arr_addr = start_array->object_start(stripe_addr);\n+\n+  size_t arr_sz;\n+  if (large_arr_addr == nullptr ||\n+      !cast_to_oop(large_arr_addr)->is_objArray() ||\n+      (arr_sz = cast_to_oop(large_arr_addr)->size()) < large_obj_arr_min_words())\n+    return;\n+\n+  objArrayOop large_arr = objArrayOop(cast_to_oop(large_arr_addr));\n+  HeapWord* arr_end_addr = large_arr_addr + arr_sz;\n+\n+  if (arr_end_addr <= stripe_end_addr) {\n+    \/\/ The end chunk is scanned together with the chunk in the previous stripe.\n+    assert(large_obj_arr_min_words() > 2 * stripe_size_in_words, \"2nd last chunk must cover stripe\");\n+    return;\n+  }\n+\n+  CardValue* iter_limit_l = byte_for(stripe_addr);\n+  CardValue* iter_limit_r = byte_for(stripe_end_addr - 1) + 1;\n+  CardValue* clear_limit_l = byte_for(stripe_addr);\n+  CardValue* clear_limit_r = byte_for(stripe_end_addr);\n+\n+  HeapWord* scan_limit_r = stripe_end_addr;\n+  HeapWord* next_stripe = stripe_end_addr;\n+  HeapWord* next_stripe_end = MIN2(next_stripe + stripe_size_in_words, space_top);\n+\n+  \/\/ Scan to end if it is in the following stripe.\n+  if (arr_end_addr > next_stripe && arr_end_addr <= next_stripe_end) {\n+    clear_limit_r = byte_for(arr_end_addr);\n+    iter_limit_r = byte_for(arr_end_addr - 1) + 1;\n+    scan_limit_r = arr_end_addr;\n+  }\n+\n+  \/\/ Process dirty chunks, i.e. consecutive dirty cards [dirty_l, dirty_r),\n+  \/\/ chunk by chunk inside [iter_limit_l, iter_limit_r).\n+  CardValue* dirty_l;\n+  CardValue* dirty_r;\n+\n+  for (CardValue* cur_card = iter_limit_l; cur_card < iter_limit_r; cur_card = dirty_r + 1) {\n+    dirty_l = find_first_dirty_card(cur_card, iter_limit_r);\n+    dirty_r = find_first_clean_card(start_array, dirty_l, iter_limit_r, large_arr);\n+    assert(dirty_l <= dirty_r, \"inv\");\n+\n+    \/\/ empty\n+    if (dirty_l == dirty_r) {\n+      assert(dirty_r == iter_limit_r, \"no more dirty cards in this stripe\");\n+      break;\n+    }\n+\n+    assert(*dirty_l != clean_card, \"inv\");\n+    assert(*dirty_r == clean_card || dirty_r >= clear_limit_r,\n+           \"clean card or belonging to next stripe\");\n+\n+    \/\/ Process this non-empty dirty chunk in two steps:\n+    {\n+      \/\/ 1. Clear card in [dirty_l, dirty_r) subject to [clear_limit_l, clear_limit_r) constraint\n+      clear_cards(MAX2(dirty_l, clear_limit_l),\n+                  MIN2(dirty_r, clear_limit_r));\n+    }\n+\n+    {\n+      \/\/ 2. Scan elements in [dirty_l, dirty_r)\n+      HeapWord* left = addr_for(dirty_l);\n+      HeapWord* right = MIN2(addr_for(dirty_r), scan_limit_r);\n+      pm->push_array_region(large_arr, left, right);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.cpp","additions":135,"deletions":8,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -45,0 +45,3 @@\n+  static const size_t num_cards_in_stripe = 128;\n+  static size_t large_obj_arr_min_words() { return 2 * num_cards_in_stripe * _card_size_in_words + 1; }\n+\n@@ -50,1 +53,2 @@\n-                                   CardValue* const end_card);\n+                                   CardValue* const end_card,\n+                                   objArrayOop const large_obj_array);\n@@ -71,0 +75,5 @@\n+  void scavenge_large_array_stripe(ObjectStartArray* start_array,\n+                                   PSPromotionManager* pm,\n+                                   HeapWord* stripe_addr,\n+                                   HeapWord* stripe_end_addr,\n+                                   HeapWord* space_top);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -360,0 +360,6 @@\n+\n+void PSPromotionManager::push_array_region(objArrayOop arr, HeapWord* left, HeapWord* right) {\n+  PSPushContentsClosure pcc(this);\n+  arr->oop_oop_iterate_bounded(&pcc, MemRegion(left, right));\n+  drain_stacks_cond_depth();\n+}\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -180,0 +180,1 @@\n+  void push_array_region(objArrayOop arr, HeapWord* left, HeapWord* right);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -121,0 +121,8 @@\n+template <typename OopClosureType>\n+void objArrayOopDesc::oop_oop_iterate_bounded(OopClosureType* closure, MemRegion mr) {\n+  if (UseCompressedOops) {\n+    ((ObjArrayKlass*)klass())->oop_oop_iterate_bounded<narrowOop>(this, closure, mr);\n+  } else {\n+    ((ObjArrayKlass*)klass())->oop_oop_iterate_bounded<oop>(this, closure, mr);\n+  }\n+}\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.inline.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -115,0 +115,3 @@\n+  \/\/ Iterate over oop elements within mr, and metadata.\n+  template <typename OopClosureType>\n+  inline void oop_oop_iterate_bounded(OopClosureType* closure, MemRegion mr);\n","filename":"src\/hotspot\/share\/oops\/objArrayOop.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}