{"files":[{"patch":"@@ -38,0 +38,3 @@\n+size_t PSCardTable::stripe_size_in_words;\n+size_t PSCardTable::large_obj_arr_min_words;\n+\n@@ -139,1 +142,2 @@\n-\/\/ resides on are considered dirty.\n+\/\/ resides on are considered dirty except for large object arrays. The card marks\n+\/\/ of objArrays are precise which allows scanning of just the dirty parts.\n@@ -142,1 +146,2 @@\n-                                                         CardValue* const end_card) {\n+                                                         CardValue* const end_card,\n+                                                         objArrayOop const large_obj_array) {\n@@ -154,0 +159,6 @@\n+    HeapWord* i_card_addr = addr_for(i_card);\n+    if (large_obj_array != nullptr && i_card_addr >= cast_from_oop<HeapWord*>(large_obj_array)) {\n+      \/\/ We scan dirty parts of large objArrays precisely, so return immediately.\n+      assert(i_card <= end_card, \"inv\");\n+      return i_card;\n+    }\n@@ -155,1 +166,1 @@\n-    HeapWord* obj_addr = start_array->object_start(addr_for(i_card)-1);\n+    HeapWord* obj_addr = start_array->object_start(i_card_addr-1);\n@@ -185,0 +196,1 @@\n+    assert(!obj->is_objArray() || !is_large_obj_array(obj), \"single threaded scanning of large array\");\n@@ -192,0 +204,10 @@\n+void PSCardTable::prepare_scavenge(int active_workers, size_t old_gen_used_words) {\n+  const int stripe_count_per_worker = 100;\n+  int stripe_count = active_workers * stripe_count_per_worker;\n+  size_t sz = MAX2(old_gen_used_words \/ stripe_count, 128 * (size_t)_card_size_in_words);\n+  stripe_size_in_words = align_up(sz, _card_size_in_words);\n+  large_obj_arr_min_words = 2 * stripe_size_in_words + 1;\n+  log_trace(gc, scavenge)(\"stripe count:%d stripe size:\" SIZE_FORMAT \"K\",\n+                          stripe_count, (stripe_size_in_words * HeapWordSize) \/ K);\n+}\n+\n@@ -229,0 +251,6 @@\n+\/\/\n+\/\/ Objects starting in a stripe are scanned completely and exclusively by the\n+\/\/ stripe owning thread even if they extend beyond the stripe end. Large object\n+\/\/ arrays are an exception to this rule. A thread scans only the part of a large\n+\/\/ object array on its stripe except for the last 2 stripes which are scanned by\n+\/\/ the thread owning the second-to-last stripe.\n@@ -236,2 +264,0 @@\n-  const size_t num_cards_in_stripe = 128;\n-  const size_t stripe_size_in_words = num_cards_in_stripe * _card_size_in_words;\n@@ -247,1 +273,0 @@\n-    \/\/ Process a stripe iff it contains any obj-start\n@@ -249,0 +274,8 @@\n+      \/\/ No object start means nothing to do. Except if the large object that\n+      \/\/ covers the stripe is a large object array. In that case we scavenge its\n+      \/\/ elements on the stripe.\n+      oop large_obj = cast_to_oop(start_array->object_start(cur_stripe_addr));\n+      if (is_large_obj_array(large_obj)) {\n+        scavenge_large_array_stripe(objArrayOop(large_obj), start_array, pm,\n+                                                cur_stripe_addr, cur_stripe_end_addr, space_top);\n+      }\n@@ -252,0 +285,2 @@\n+    \/\/ Process objects starting in this stripe.\n+\n@@ -256,0 +291,2 @@\n+    \/\/ 4. range of large objArray elements to be scanned: [first_obj_addr, cur_stripe_end_addr)\n+    \/\/    limited to dirty cards.\n@@ -261,0 +298,1 @@\n+    objArrayOop large_arr = nullptr;\n@@ -280,1 +318,22 @@\n-      HeapWord* obj_end_addr = obj_addr + cast_to_oop(obj_addr)->size();\n+      size_t obj_sz = cast_to_oop(obj_addr)->size();\n+      HeapWord* obj_end_addr = obj_addr + obj_sz;\n+      \/\/ Scan the elements of a large array to the stripe end.\n+      if (obj_sz >= large_obj_arr_min_words && cast_to_oop(obj_addr)->is_objArray()) {\n+        if (first_obj_addr >= cur_stripe_end_addr) {\n+          \/\/ Nothing to scan according to constraints given above.\n+          \/\/ We reach here only for the last stripe below space_top where\n+          \/\/ object_starts_in_range() returns true if space_top is not aligned to\n+          \/\/ _card_size and an object starts there.\n+          assert(first_obj_addr == space_top, \"assumption\");\n+          assert(cur_stripe_end_addr == space_top, \"assumption\");\n+          \/\/ This stripe accomodates the end of a large array. It is scanned by the\n+          \/\/ thread owning the previous stripe.\n+          continue;\n+        }\n+        \/\/ Reaching here we know that the large array starts in this stripe.\n+        \/\/ If it starts here then its end has to be in a following stripe.\n+        assert(obj_addr >= cur_stripe_addr &&\n+               obj_end_addr >= cur_stripe_end_addr, \"overlapping work\");\n+        obj_end_addr = cur_stripe_end_addr;\n+        large_arr = objArrayOop(cast_to_oop(obj_addr));\n+      }\n@@ -296,1 +355,1 @@\n-      dirty_r = find_first_clean_card(start_array, dirty_l, iter_limit_r);\n+      dirty_r = find_first_clean_card(start_array, dirty_l, iter_limit_r, large_arr);\n@@ -309,1 +368,1 @@\n-      \/\/ Process this non-empty dirty chunk in two steps:\n+      \/\/ Process this non-empty dirty chunk in three steps:\n@@ -316,1 +375,1 @@\n-      {\n+      if (large_arr == nullptr || addr_for(dirty_l) < cast_from_oop<HeapWord*>(large_arr)) {\n@@ -318,0 +377,1 @@\n+        \/\/    Exclude the large array if one begins in the stripe\n@@ -322,1 +382,3 @@\n-                               cur_stripe_end_addr);\n+                               large_arr != nullptr ?\n+                                   cast_from_oop<HeapWord*>(large_arr) :\n+                                   cur_stripe_end_addr);\n@@ -326,0 +388,81 @@\n+\n+      if (large_arr != nullptr && addr_for(dirty_r) >= cast_from_oop<HeapWord*>(large_arr)) {\n+        \/\/ 3. Scan the large array elements in [dirty_l, dirty_r) subject to [large_arr, cur_stripe_end_addr)\n+        HeapWord* arr_l = addr_for(dirty_l);\n+\n+        HeapWord* arr_r = MIN2(addr_for(dirty_r),\n+                               cur_stripe_end_addr);\n+\n+        pm->push_objArray_contents(large_arr, arr_l, arr_r);\n+      }\n+    }\n+  }\n+}\n+\n+void PSCardTable::scavenge_large_array_stripe(objArrayOop large_arr,\n+                                              ObjectStartArray* start_array,\n+                                              PSPromotionManager* pm,\n+                                              HeapWord* stripe_addr,\n+                                              HeapWord* stripe_end_addr,\n+                                              HeapWord* space_top) {\n+  HeapWord* arr_end_addr = cast_from_oop<HeapWord*>(large_arr) + large_arr->size();\n+  if (arr_end_addr <= stripe_end_addr) {\n+    \/\/ The stripe is scanned together with the chunk in the previous stripe.\n+    assert(large_obj_arr_min_words > 2 * stripe_size_in_words, \"2nd last chunk must cover stripe\");\n+    return;\n+  }\n+\n+  \/\/ Constraints:\n+  \/\/ 1. range of cards checked for being dirty or clean: [iter_limit_l, iter_limit_r)\n+  \/\/ 2. range of cards can be cleared: [clear_limit_l, clear_limit_r)\n+  \/\/ 3. range of large objArray elements can be scanned: [stripe_addr, scan_limit_r)\n+  \/\/    limited to dirty cards.\n+\n+  CardValue* iter_limit_l = byte_for(stripe_addr);\n+  CardValue* iter_limit_r = byte_for(stripe_end_addr - 1) + 1;\n+  CardValue* clear_limit_l = byte_for(stripe_addr);\n+  CardValue* clear_limit_r = byte_for(stripe_end_addr);\n+\n+  HeapWord* scan_limit_r = stripe_end_addr;\n+  HeapWord* next_stripe = stripe_end_addr;\n+  HeapWord* next_stripe_end = MIN2(next_stripe + stripe_size_in_words, space_top);\n+\n+  \/\/ Scan to end if it is in the following stripe.\n+  if (arr_end_addr > next_stripe && arr_end_addr <= next_stripe_end) {\n+    clear_limit_r = byte_for(arr_end_addr);\n+    iter_limit_r = byte_for(arr_end_addr - 1) + 1;\n+    scan_limit_r = arr_end_addr;\n+  }\n+\n+  \/\/ Process dirty chunks, i.e. consecutive dirty cards [dirty_l, dirty_r),\n+  \/\/ chunk by chunk inside [iter_limit_l, iter_limit_r).\n+  CardValue* dirty_l;\n+  CardValue* dirty_r;\n+\n+  for (CardValue* cur_card = iter_limit_l; cur_card < iter_limit_r; cur_card = dirty_r + 1) {\n+    dirty_l = find_first_dirty_card(cur_card, iter_limit_r);\n+    dirty_r = find_first_clean_card(start_array, dirty_l, iter_limit_r, large_arr);\n+    assert(dirty_l <= dirty_r, \"inv\");\n+\n+    \/\/ empty\n+    if (dirty_l == dirty_r) {\n+      assert(dirty_r == iter_limit_r, \"no more dirty cards in this stripe\");\n+      break;\n+    }\n+\n+    assert(*dirty_l != clean_card, \"inv\");\n+    assert(*dirty_r == clean_card || dirty_r >= clear_limit_r,\n+           \"clean card or belonging to next stripe\");\n+\n+    \/\/ Process this non-empty dirty chunk in two steps:\n+    {\n+      \/\/ 1. Clear card in [dirty_l, dirty_r) subject to [clear_limit_l, clear_limit_r) constraint\n+      clear_cards(MAX2(dirty_l, clear_limit_l),\n+                  MIN2(dirty_r, clear_limit_r));\n+    }\n+\n+    {\n+      \/\/ 2. Scan elements in [dirty_l, dirty_r)\n+      HeapWord* left = addr_for(dirty_l);\n+      HeapWord* right = MIN2(addr_for(dirty_r), scan_limit_r);\n+      pm->push_objArray_contents(large_arr, left, right);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.cpp","additions":154,"deletions":11,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"oops\/oop.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n@@ -45,0 +45,7 @@\n+  static size_t stripe_size_in_words;\n+  static size_t large_obj_arr_min_words;\n+\n+  static bool is_large_obj_array(oop obj) {\n+    return obj->is_objArray() && obj->size() >= large_obj_arr_min_words;\n+  }\n+\n@@ -50,1 +57,2 @@\n-                                   CardValue* const end_card);\n+                                   CardValue* const end_card,\n+                                   objArrayOop const large_obj_array);\n@@ -65,0 +73,1 @@\n+  void prepare_scavenge(int active_workers, size_t old_gen_used_words);\n@@ -71,0 +80,8 @@\n+  \/\/ Scavenge the elements of a large object array on dirty cards of the stripe.\n+  \/\/ Scan to end if it is in the next stripe.\n+  void scavenge_large_array_stripe(objArrayOop large_arr,\n+                                   ObjectStartArray* start_array,\n+                                   PSPromotionManager* pm,\n+                                   HeapWord* stripe_addr,\n+                                   HeapWord* stripe_end_addr,\n+                                   HeapWord* space_top);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.hpp","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -357,0 +357,6 @@\n+\n+void PSPromotionManager::push_objArray_contents(objArrayOop arr, HeapWord* left, HeapWord* right) {\n+  PSPushContentsClosure pcc(this);\n+  arr->oop_oop_iterate_bounded(&pcc, MemRegion(left, right));\n+  drain_stacks_cond_depth();\n+}\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -180,0 +180,1 @@\n+  void push_objArray_contents(objArrayOop arr, HeapWord* left, HeapWord* right);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -304,0 +304,2 @@\n+    PSCardTable* card_table = ParallelScavengeHeap::heap()->card_table();\n+    card_table->prepare_scavenge(active_workers, old_gen->object_space()->used_in_words());\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -115,0 +115,3 @@\n+  \/\/ Iterate over oop elements within mr, and metadata.\n+  template <typename OopClosureType>\n+  inline void oop_oop_iterate_bounded(OopClosureType* closure, MemRegion mr);\n","filename":"src\/hotspot\/share\/oops\/objArrayOop.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"oops\/objArrayKlass.inline.hpp\"\n@@ -54,0 +55,8 @@\n+template <typename OopClosureType>\n+void objArrayOopDesc::oop_oop_iterate_bounded(OopClosureType* closure, MemRegion mr) {\n+  if (UseCompressedOops) {\n+    ((ObjArrayKlass*)klass())->oop_oop_iterate_bounded<narrowOop>(this, closure, mr);\n+  } else {\n+    ((ObjArrayKlass*)klass())->oop_oop_iterate_bounded<oop>(this, closure, mr);\n+  }\n+}\n","filename":"src\/hotspot\/share\/oops\/objArrayOop.inline.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"}]}