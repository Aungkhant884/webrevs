{"files":[{"patch":"@@ -127,54 +127,0 @@\n-\/\/ postcondition: ret is a dirty card or end_card\n-CardTable::CardValue* PSCardTable::find_first_dirty_card(CardValue* const start_card,\n-                                                         CardValue* const end_card) {\n-  for (CardValue* i_card = start_card; i_card < end_card; ++i_card) {\n-    if (is_dirty(i_card)) {\n-      return i_card;\n-    }\n-  }\n-  return end_card;\n-}\n-\n-\/\/ postcondition: ret is a clean card or end_card\n-\/\/ Note: if a part of an object is on a dirty card, all cards this object\n-\/\/ resides on are considered dirty.\n-template <typename T>\n-CardTable::CardValue* PSCardTable::find_first_clean_card(T start_cache,\n-                                                         CardValue* const start_card,\n-                                                         CardValue* const end_card) {\n-  assert(start_card == end_card ||\n-         *start_card != PSCardTable::clean_card_val(), \"precondition\");\n-  \/\/ Skip the first dirty card.\n-  CardValue* i_card = start_card + 1;\n-  while (i_card < end_card) {\n-    if (*i_card != PSCardTable::clean_card_val()) {\n-      i_card++;\n-      continue;\n-    }\n-    assert(i_card - 1 >= start_card, \"inv\");\n-    assert(*(i_card - 1) != PSCardTable::clean_card_val(), \"prev card must be dirty\");\n-    \/\/ Find the final obj on the prev dirty card.\n-    HeapWord* obj_addr = start_cache.object_start(addr_for(i_card)-1);\n-    if (cast_to_oop(obj_addr)->is_objArray()) {\n-      \/\/ Object arrays are precisely marked.\n-      return i_card;\n-    }\n-    HeapWord* obj_end_addr = obj_addr + cast_to_oop(obj_addr)->size();\n-    CardValue* final_card_by_obj = byte_for(obj_end_addr - 1);\n-    if (final_card_by_obj <= i_card) {\n-      return i_card;\n-    }\n-    \/\/ This final obj extends beyond i_card. Check if it extends beyond end_card.\n-    if (final_card_by_obj >= end_card) {\n-      return end_card;\n-    }\n-    \/\/ Check if this new card is dirty.\n-    if (*final_card_by_obj == PSCardTable::clean_card_val()) {\n-      return final_card_by_obj;\n-    }\n-    \/\/ This new card is dirty, continuing the search...\n-    i_card = final_card_by_obj + 1;\n-  }\n-  return end_card;\n-}\n-\n@@ -195,24 +141,0 @@\n-\/\/ ObjectStartArray queries can get expensive if the start is far.  The\n-\/\/ information can be cached if iterating monotonically from lower to higher\n-\/\/ addresses. This is vital with parallel processing of large objects.\n-class ObjStartCache : public StackObj {\n-    HeapWord* _obj_start;\n-    HeapWord* _obj_end;\n-    ObjectStartArray* _start_array;\n-    DEBUG_ONLY(HeapWord* _prev_query);\n-  public:\n-    ObjStartCache(ObjectStartArray* start_array) : _obj_start(nullptr), _obj_end(nullptr),\n-                                                   _start_array(start_array)\n-                                                   DEBUG_ONLY(COMMA _prev_query(nullptr)) {}\n-    HeapWord* object_start(HeapWord* addr) {\n-      assert(_prev_query <= addr, \"precondition\");\n-      DEBUG_ONLY(_prev_query = addr);\n-      if (addr >= _obj_end) {\n-        _obj_start = _start_array->object_start(addr);\n-        _obj_end = _obj_start + cast_to_oop(_obj_start)->size();\n-      }\n-      assert(_obj_start != nullptr, \"postcondition\");\n-      return _obj_start;\n-    }\n-};\n-\n@@ -226,16 +148,10 @@\n-void PSCardTable::clear_cards(CardValue* const start, CardValue* const end) {\n-  for (CardValue* i_card = start; i_card < end; ++i_card) {\n-    *i_card = clean_card_val();\n-  }\n-}\n-\n-\/\/ Find cards within [start, end) marked dirty, clear corresponding parts of the\n-\/\/ card table and scan objects on dirty cards.\n-\/\/ Scanning of objects is limited to [start, end) of a stripe. This way the\n-\/\/ scanning of objects crossing stripe boundaries is distributed. For this the\n-\/\/ dirty marks of imprecisely marked non-array objects are propagated\n-\/\/ pre-scavenge to the stripes they extend to.\n-\/\/ Except for the limitation to the [start, end) stripe non-array objects are scanned completely.\n-\/\/ Object arrays are marked precisely. Therefore the scanning is limited to dirty cards.\n-template <typename T>\n-void PSCardTable::process_range(T& start_cache,\n+\/\/ Scavenge objects on dirty cards of the given stripe [start, end). Accesses to\n+\/\/ the card table and scavenging is strictly limited to the stripe. The work on\n+\/\/ objects covering multiple stripes is shared among the worker threads owning the\n+\/\/ stripes.  To support this the card table is preprocessed before\n+\/\/ scavenge. Imprecise dirty marks of non-objArrays are copied from start stripes\n+\/\/ to all stripes (if any) they extend to.\n+\/\/ A copy of card table entries corresponding to the stripe called \"shadow\" table\n+\/\/ is used to separate card reading, clearing and redirtying.\n+template <typename Func>\n+void PSCardTable::process_range(Func&& object_start,\n@@ -248,7 +164,0 @@\n-  \/\/ end might not be card-aligned\n-  CardValue* itr_limit_r = byte_for(end - 1) + 1;\n-  CardValue* clr_limit_r = byte_for(end);\n-\n-  CardValue* dirty_l;\n-  CardValue* dirty_r;\n-\n@@ -273,3 +182,8 @@\n-  for (CardValue* cur_card = byte_for(start); cur_card < itr_limit_r; cur_card = dirty_r + 1) {\n-    dirty_l = find_first_dirty_card(cur_card, itr_limit_r);\n-    dirty_r = find_first_clean_card(start_cache, dirty_l, itr_limit_r);\n+  StripeShadowTable sct(this, MemRegion(start, end));\n+\n+  \/\/ end might not be card-aligned\n+  const CardValue* end_card = sct.card_for(end - 1) + 1;\n+\n+  for (HeapWord* i_addr = start; i_addr < end; \/* empty *\/) {\n+    const CardValue* dirty_l = sct.find_first_dirty_card(sct.card_for(i_addr), end_card);\n+    const CardValue* dirty_r = sct.find_first_clean_card(dirty_l, end_card);\n@@ -280,1 +194,1 @@\n-      assert(dirty_r == itr_limit_r, \"inv\");\n+      assert(dirty_r == end_card, \"inv\");\n@@ -285,5 +199,2 @@\n-    HeapWord* addr_l = addr_for(dirty_l);\n-    HeapWord* addr_r = MIN2(addr_for(dirty_r), end);\n-\n-    \/\/ Clear the cards before scanning.\n-    clear_cards(dirty_l, MIN2(dirty_r, clr_limit_r));\n+    HeapWord* addr_l = sct.addr_for(dirty_l);\n+    HeapWord* addr_r = MIN2(sct.addr_for(dirty_r), end);\n@@ -292,1 +203,1 @@\n-    Obj obj(start_cache.object_start(addr_l));\n+    Obj obj(object_start(addr_l));\n@@ -294,10 +205,2 @@\n-    \/\/ Scan non-objArray reaching into stripe and into [addr_l, addr_r).\n-    if (!obj.is_obj_array && obj.addr < start) {\n-      scan_obj_with_limit(pm, obj.obj, start, MIN2(obj.end_addr, end));\n-      if (obj.end_addr >= addr_r) {\n-        \/\/ Last object in [addr_l, addr_r)\n-        continue;\n-      }\n-      \/\/ move to next obj inside this dirty chunk\n-      obj.next();\n-    }\n+    while (true) {\n+      assert(obj.addr < addr_r, \"inv\");\n@@ -305,4 +208,0 @@\n-    \/\/ Scan objects overlapping [addr_l, addr_r).\n-    \/\/ Non-objArrays are known to start within the stripe. They are scanned completely.\n-    \/\/ Scanning of objArrays is limited to the dirty chunk [addr_l, addr_r).\n-    while (obj.end_addr < addr_r) {\n@@ -310,1 +209,1 @@\n-        \/\/ precisely marked\n+        \/\/ precise-marked\n@@ -313,3 +212,17 @@\n-        assert(obj.addr >= start, \"handled before\");\n-        \/\/ scan whole obj\n-        scan_obj(pm, obj.obj);\n+        if (obj.addr < addr_l) {\n+          if (sct.is_any_dirty(sct.card_for(MAX2(obj.addr, start)), dirty_l)) {\n+            \/\/ already scanned\n+          } else {\n+            \/\/ treat it as semi-precise-marked, [addr_l, obj-end)\n+            scan_obj_with_limit(pm, obj.obj, addr_l, MIN2(obj.end_addr, end));\n+          }\n+        } else {\n+          \/\/ obj-start is dirty\n+          if (obj.end_addr <= end) {\n+            \/\/ scan whole obj if it does not extend beyond the stripe end\n+            scan_obj(pm, obj.obj);\n+          } else {\n+            \/\/ otherwise scan limit the scan\n+            scan_obj_with_limit(pm, obj.obj, addr_l, end);\n+          }\n+        }\n@@ -318,3 +231,4 @@\n-      \/\/ move to next obj\n-      obj.next();\n-    }\n+      if (obj.end_addr >= addr_r) {\n+        i_addr = obj.is_obj_array ? addr_r : obj.end_addr;\n+        break;\n+      }\n@@ -322,8 +236,2 @@\n-    \/\/ Scan object that extends beyond [addr_l, addr_r) and maybe even beyond the stripe.\n-    assert(obj.addr < addr_r, \"inv\");\n-    if (obj.is_obj_array) {\n-      \/\/ precise-marked\n-      scan_obj_with_limit(pm, obj.obj, addr_l, addr_r);\n-    } else {\n-      assert(obj.addr >= start, \"handled before\");\n-      scan_obj_with_limit(pm, obj.obj, obj.addr, MIN2(obj.end_addr, end));\n+      \/\/ move to next obj inside this dirty chunk\n+      obj.next();\n@@ -339,5 +247,6 @@\n-void PSCardTable::pre_scavenge_parallel(ObjectStartArray* start_array,\n-                                                 HeapWord* old_gen_bottom,\n-                                                 HeapWord* old_gen_top,\n-                                                 uint stripe_index,\n-                                                 uint n_stripes) {\n+template <typename Func>\n+void PSCardTable::pre_scavenge_parallel(Func&& object_start,\n+                                        HeapWord* old_gen_bottom,\n+                                        HeapWord* old_gen_top,\n+                                        uint stripe_index,\n+                                        uint n_stripes) {\n@@ -349,1 +258,0 @@\n-  ObjStartCache start_cache(start_array);\n@@ -354,1 +262,1 @@\n-      HeapWord* first_obj_addr = start_cache.object_start(stripe_addr);\n+      HeapWord* first_obj_addr = object_start(stripe_addr);\n@@ -425,0 +333,21 @@\n+  struct {\n+    HeapWord* start_addr;\n+    HeapWord* end_addr;\n+    DEBUG_ONLY(HeapWord* _prev_query);\n+  } cached_obj {nullptr, old_gen_bottom DEBUG_ONLY(COMMA nullptr)};\n+\n+  auto object_start = [&] (HeapWord* addr) {\n+    assert(cached_obj._prev_query <= addr, \"precondition\");\n+    DEBUG_ONLY(cached_obj._prev_query = addr);\n+    if (addr < cached_obj.end_addr) {\n+      assert(cached_obj.start_addr != nullptr, \"inv\");\n+      return cached_obj.start_addr;\n+    }\n+    HeapWord* result = start_array->object_start(addr);\n+\n+    cached_obj.start_addr = result;\n+    cached_obj.end_addr = result + cast_to_oop(result)->size();\n+\n+    return result;\n+  };\n+\n@@ -429,1 +358,4 @@\n-  pre_scavenge_parallel(start_array, old_gen_bottom, old_gen_top, stripe_index, n_stripes);\n+  pre_scavenge_parallel(object_start, old_gen_bottom, old_gen_top, stripe_index, n_stripes);\n+\n+  \/\/ Reset cached object\n+  cached_obj = {nullptr, old_gen_bottom DEBUG_ONLY(COMMA nullptr)};\n@@ -433,1 +365,0 @@\n-  ObjStartCache start_cache(start_array);\n@@ -450,1 +381,1 @@\n-    process_range(start_cache, pm, stripe_l, stripe_r);\n+    process_range(object_start, pm, stripe_l, stripe_r);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.cpp","additions":81,"deletions":150,"binary":false,"changes":231,"status":"modified"},{"patch":"@@ -40,0 +40,64 @@\n+  class StripeShadowTable {\n+    CardValue _table[num_cards_in_stripe];\n+    const CardValue* _table_base;\n+#ifdef ASSERT\n+    const CardValue* _table_end;\n+#endif\n+\n+   public:\n+    StripeShadowTable(PSCardTable* pst, MemRegion stripe) :\n+      _table_base(_table - (uintptr_t(stripe.start()) >> _card_shift))\n+#ifdef ASSERT\n+      , _table_end((const CardValue*)(uintptr_t(_table) + (align_up(stripe.byte_size(), _card_size) >> _card_shift)))\n+#endif\n+    {\n+      \/\/ Old gen top is not card aligned.\n+      size_t copy_length = align_up(stripe.byte_size(), _card_size) >> _card_shift;\n+      size_t clear_length = align_down(stripe.byte_size(), _card_size) >> _card_shift;\n+      memcpy(_table, pst->byte_for(stripe.start()), copy_length);\n+      memset(pst->byte_for(stripe.start()), clean_card_val(), clear_length);\n+    }\n+\n+    HeapWord* addr_for(const CardValue* const card) {\n+      assert(card >= _table && card <= _table_end, \"out of bounds\");\n+      return (HeapWord*) ((card - _table_base) << _card_shift);\n+    }\n+\n+    const CardValue* card_for(HeapWord* addr) {\n+      return &_table_base[uintptr_t(addr) >> _card_shift];\n+    }\n+\n+    bool is_dirty(const CardValue* const card) {\n+      return !is_clean(card);\n+    }\n+\n+    bool is_any_dirty(const CardValue* const start, const CardValue* const end) {\n+      return find_first_dirty_card(start, end) != end;\n+    }\n+\n+    bool is_clean(const CardValue* const card) {\n+      assert(card >= _table && card < _table_end, \"out of bounds\");\n+      return *card == PSCardTable::clean_card_val();\n+    }\n+\n+    const CardValue* find_first_dirty_card(const CardValue* const start,\n+                                           const CardValue* const end) {\n+      for (const CardValue* i = start; i < end; ++i) {\n+        if (!is_clean(i)) {\n+          return i;\n+        }\n+      }\n+      return end;\n+    }\n+\n+    const CardValue* find_first_clean_card(const CardValue* const start,\n+                                           const CardValue* const end) {\n+      for (const CardValue* i = start; i < end; ++i) {\n+        if (is_clean(i)) {\n+          return i;\n+        }\n+      }\n+      return end;\n+    }\n+  };\n+\n@@ -58,2 +122,2 @@\n-  template <typename T>\n-  void process_range(T& start_cache,\n+  template <typename Func>\n+  void process_range(Func&& object_start,\n@@ -71,8 +135,0 @@\n-  CardValue* find_first_dirty_card(CardValue* const start_card,\n-                                   CardValue* const end_card);\n-\n-  template <typename T>\n-  CardValue* find_first_clean_card(T start_cache,\n-                                   CardValue* const start_card,\n-                                   CardValue* const end_card);\n-\n@@ -87,2 +143,0 @@\n-  void clear_cards(CardValue* const start, CardValue* const end);\n-\n@@ -105,1 +159,2 @@\n-  void pre_scavenge_parallel(ObjectStartArray* start_array,\n+  template <typename Func>\n+  void pre_scavenge_parallel(Func&& object_start,\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.hpp","additions":68,"deletions":13,"binary":false,"changes":81,"status":"modified"}]}