{"files":[{"patch":"@@ -131,2 +131,4 @@\n-  prefetch_write(start);\n-  pm->push_contents_bounded(obj, start, end);\n+  if (!obj->is_typeArray()) {\n+    prefetch_write(start);\n+    pm->push_contents_bounded(obj, start, end);\n+  }\n@@ -139,0 +141,65 @@\n+class StripeShadowCardTable {\n+  typedef CardTable::CardValue CardValue;\n+\n+  const uint _card_shift;\n+  const uint _card_size;\n+  CardValue _table[PSCardTable::num_cards_in_stripe];\n+  const CardValue* _table_base;\n+\n+public:\n+  StripeShadowCardTable(PSCardTable* pst, HeapWord* const start, HeapWord* const end) :\n+    _card_shift(CardTable::card_shift()),\n+    _card_size(CardTable::card_size()),\n+    _table_base(_table - (uintptr_t(start) >> _card_shift)) {\n+    \/\/ The end of the last stripe may not be card aligned as it is equal to old\n+    \/\/ gen top at scavenge start. We must not clear the card containing old gen\n+    \/\/ top if it is not card aligned because then there are likely promoted\n+    \/\/ objects on the same card and it could be marked dirty because of\n+    \/\/ them. That's why clear_length is aligned down.\n+    size_t stripe_byte_size = pointer_delta(end, start) * HeapWordSize;\n+    size_t copy_length = align_up(stripe_byte_size, _card_size) >> _card_shift;\n+    size_t clear_length = align_down(stripe_byte_size, _card_size) >> _card_shift;\n+    CardValue* stripe_start_card = pst->byte_for(start);\n+    memcpy(_table, stripe_start_card, copy_length);\n+    memset(stripe_start_card, CardTable::clean_card_val(), clear_length);\n+  }\n+\n+  HeapWord* addr_for(const CardValue* const card) {\n+    assert(card >= _table && card <=  &_table[PSCardTable::num_cards_in_stripe], \"out of bounds\");\n+    return (HeapWord*) ((card - _table_base) << _card_shift);\n+  }\n+\n+  const CardValue* card_for(HeapWord* addr) {\n+    return &_table_base[uintptr_t(addr) >> _card_shift];\n+  }\n+\n+  bool is_dirty(const CardValue* const card) {\n+    return !is_clean(card);\n+  }\n+\n+  bool is_clean(const CardValue* const card) {\n+    assert(card >= _table && card <  &_table[PSCardTable::num_cards_in_stripe], \"out of bounds\");\n+    return *card == PSCardTable::clean_card_val();\n+  }\n+\n+  const CardValue* find_first_dirty_card(const CardValue* const start,\n+                                         const CardValue* const end) {\n+    for (const CardValue* i = start; i < end; ++i) {\n+      if (is_dirty(i)) {\n+        return i;\n+      }\n+    }\n+    return end;\n+  }\n+\n+  const CardValue* find_first_clean_card(const CardValue* const start,\n+                                         const CardValue* const end) {\n+    for (const CardValue* i = start; i < end; ++i) {\n+      if (is_clean(i)) {\n+        return i;\n+      }\n+    }\n+    return end;\n+  }\n+};\n+\n@@ -155,1 +222,1 @@\n-  StripeShadowTable sct(this, MemRegion(start, end));\n+  StripeShadowCardTable sct(this, start, end);\n@@ -226,10 +293,17 @@\n-    if (!is_dirty(cur_card)) {\n-      HeapWord* first_obj_addr = object_start(stripe_addr);\n-      if (first_obj_addr < stripe_addr) {\n-        oop first_obj = cast_to_oop(first_obj_addr);\n-        if (!first_obj->is_array() && is_dirty(byte_for(first_obj_addr))) {\n-          \/\/ Potentially imprecisely marked dirty.\n-          \/\/ Mark first card of stripe dirty too.\n-          *cur_card = dirty_card_val();\n-        }\n-      }\n+    if (is_dirty(cur_card)) {\n+      \/\/ The first card of this stripe is already dirty, no need to see if the\n+      \/\/ reaching-in object is a potentially imprecisely marked non-array\n+      \/\/ object.\n+      continue;\n+    }\n+    HeapWord* first_obj_addr = object_start(stripe_addr);\n+    if (first_obj_addr == stripe_addr) {\n+      \/\/ No object reaching into this stripe.\n+      continue;\n+    }\n+    oop first_obj = cast_to_oop(first_obj_addr);\n+    if (!first_obj->is_array() && is_dirty(byte_for(first_obj_addr))) {\n+      \/\/ Found a non-array object reaching into the stripe that has\n+      \/\/ potentially been marked imprecisely.  Mark first card of the stripe\n+      \/\/ dirty so it will be processed later.\n+      *cur_card = dirty_card_val();\n@@ -237,7 +311,0 @@\n-  }\n-\n-  \/\/ Sync with other workers\n-  Atomic::dec(&_preprocessing_active_workers);\n-  SpinYield spin_yield;\n-  while (Atomic::load_acquire(&_preprocessing_active_workers) > 0) {\n-    spin_yield.wait();\n@@ -309,3 +376,0 @@\n-  const size_t stripe_size_in_words = num_cards_in_stripe * _card_size_in_words;\n-  const size_t slice_size_in_words = stripe_size_in_words * n_stripes;\n-\n@@ -315,2 +379,6 @@\n-  \/\/ Reset cached object\n-  cached_obj = {nullptr, old_gen_bottom};\n+  \/\/ Sync with other workers\n+  Atomic::dec(&_preprocessing_active_workers);\n+  SpinYield spin_yield;\n+  while (Atomic::load_acquire(&_preprocessing_active_workers) > 0) {\n+    spin_yield.wait();\n+  }\n@@ -319,0 +387,3 @@\n+  cached_obj = {nullptr, old_gen_bottom};\n+  const size_t stripe_size_in_words = num_cards_in_stripe * _card_size_in_words;\n+  const size_t slice_size_in_words = stripe_size_in_words * n_stripes;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.cpp","additions":96,"deletions":25,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+  friend class StripeShadowCardTable;\n@@ -39,53 +40,0 @@\n-  class StripeShadowTable {\n-    CardValue _table[num_cards_in_stripe];\n-    const CardValue* _table_base;\n-\n-  public:\n-    StripeShadowTable(PSCardTable* pst, MemRegion stripe) :\n-      _table_base(_table - (uintptr_t(stripe.start()) >> _card_shift)) {\n-      \/\/ Old gen top may not be card aligned.\n-      size_t copy_length = align_up(stripe.byte_size(), _card_size) >> _card_shift;\n-      size_t clear_length = align_down(stripe.byte_size(), _card_size) >> _card_shift;\n-      memcpy(_table, pst->byte_for(stripe.start()), copy_length);\n-      memset(pst->byte_for(stripe.start()), clean_card_val(), clear_length);\n-    }\n-\n-    HeapWord* addr_for(const CardValue* const card) {\n-      assert(card >= _table && card <=  &_table[num_cards_in_stripe], \"out of bounds\");\n-      return (HeapWord*) ((card - _table_base) << _card_shift);\n-    }\n-\n-    const CardValue* card_for(HeapWord* addr) {\n-      return &_table_base[uintptr_t(addr) >> _card_shift];\n-    }\n-\n-    bool is_dirty(const CardValue* const card) {\n-      return !is_clean(card);\n-    }\n-\n-    bool is_clean(const CardValue* const card) {\n-      assert(card >= _table && card <  &_table[num_cards_in_stripe], \"out of bounds\");\n-      return *card == PSCardTable::clean_card_val();\n-    }\n-\n-    const CardValue* find_first_dirty_card(const CardValue* const start,\n-                                           const CardValue* const end) {\n-      for (const CardValue* i = start; i < end; ++i) {\n-        if (is_dirty(i)) {\n-          return i;\n-        }\n-      }\n-      return end;\n-    }\n-\n-    const CardValue* find_first_clean_card(const CardValue* const start,\n-                                           const CardValue* const end) {\n-      for (const CardValue* i = start; i < end; ++i) {\n-        if (is_clean(i)) {\n-          return i;\n-        }\n-      }\n-      return end;\n-    }\n-  };\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.hpp","additions":1,"deletions":53,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -135,4 +135,2 @@\n-  if (!obj->klass()->is_typeArray_klass()) {\n-    PSPushContentsClosure pcc(this);\n-    obj->oop_iterate(&pcc, MemRegion(left, right));\n-  }\n+  PSPushContentsClosure pcc(this);\n+  obj->oop_iterate(&pcc, MemRegion(left, right));\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"}]}