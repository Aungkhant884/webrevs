{"files":[{"patch":"@@ -130,12 +130,1 @@\n-    if (*i_card != PSCardTable::clean_card_val()) {\n-      return i_card;\n-    }\n-  }\n-  return end_card;\n-}\n-\n-\/\/ postcondition: ret is a clean card or end_card\n-CardTable::CardValue* PSCardTable::find_first_clean_card(CardValue* const start_card,\n-                                                         CardValue* const end_card) {\n-  for (CardValue* i_card = start_card; i_card < end_card; ++i_card) {\n-    if (*i_card == PSCardTable::clean_card_val()) {\n+    if (is_dirty(i_card)) {\n@@ -151,1 +140,2 @@\n-CardTable::CardValue* PSCardTable::find_first_clean_card(ObjectStartArray* const start_array,\n+template <typename T>\n+CardTable::CardValue* PSCardTable::find_first_clean_card(T start_cache,\n@@ -166,1 +156,5 @@\n-    HeapWord* obj_addr = start_array->object_start(addr_for(i_card)-1);\n+    HeapWord* obj_addr = start_cache.object_start(addr_for(i_card)-1);\n+    if (cast_to_oop(obj_addr)->is_objArray()) {\n+      \/\/ Object arrays are precisely marked.\n+      return i_card;\n+    }\n@@ -169,2 +163,1 @@\n-    assert(final_card_by_obj < end_card, \"inv\");\n-    if (final_card_by_obj <= i_card) {\n+    if (final_card_by_obj <= i_card || final_card_by_obj >= end_card) {\n@@ -173,1 +166,2 @@\n-    \/\/ This final obj extends beyond i_card, check if this new card is dirty.\n+    \/\/ This final obj extends beyond i_card but not beyond end_card.\n+    \/\/ Check if this new card is dirty.\n@@ -183,0 +177,63 @@\n+void PSCardTable::scan_obj(PSPromotionManager* pm,\n+                           oop obj) {\n+  prefetch_write(obj);\n+  pm->push_contents(obj);\n+}\n+\n+void PSCardTable::scan_obj_with_limit(PSPromotionManager* pm,\n+                                      oop obj,\n+                                      HeapWord* start,\n+                                      HeapWord* end) {\n+  prefetch_write(start);\n+  pm->push_contents_bounded(obj, start, end);\n+}\n+\n+\/\/ ObjectStartArray queries can get expensive if the start is far.  The\n+\/\/ information can be cached if iterating monotonically from lower to higher\n+\/\/ addresses. This is vital with parallel processing of large objects.\n+class ObjStartCache : public StackObj {\n+    HeapWord* _obj_start;\n+    HeapWord* _obj_end;\n+    ObjectStartArray* _start_array;\n+    DEBUG_ONLY(HeapWord* _prev_query);\n+  public:\n+    ObjStartCache(ObjectStartArray* start_array) : _obj_start(nullptr), _obj_end(nullptr),\n+                                                   _start_array(start_array)\n+                                                   DEBUG_ONLY(COMMA _prev_query(nullptr)) {}\n+    HeapWord* object_start(HeapWord* addr) {\n+      assert(_prev_query <= addr, \"precondition\");\n+      DEBUG_ONLY(_prev_query = addr);\n+      if (addr >= _obj_end) {\n+        _obj_start = _start_array->object_start(addr);\n+        _obj_end = _obj_start + cast_to_oop(_obj_start)->size();\n+      }\n+      assert(_obj_start != nullptr, \"postcondition\");\n+      return _obj_start;\n+    }\n+};\n+\n+void PSCardTable::pre_scavenge(MutableSpace* old_gen, ObjectStartArray* start_array) {\n+  CardValue* cur_card = byte_for(old_gen->bottom());\n+  CardValue* const end_card = byte_for(old_gen->top() - 1) + 1;\n+\n+  \/\/ Propagate imprecise marks from object start to the stripes the object extends to.\n+  for ( \/* empty *\/ ; cur_card < end_card; cur_card += num_cards_in_stripe) {\n+    if (!is_dirty(cur_card)) {\n+      HeapWord* stripe_addr = addr_for(cur_card);\n+      HeapWord* first_obj_addr = start_array->object_start(stripe_addr);\n+      if (first_obj_addr < stripe_addr) {\n+        oop first_obj = cast_to_oop(first_obj_addr);\n+        if (first_obj->is_array()) {\n+          \/\/ Arrays are either precisely or never marked. Skip over them.\n+          HeapWord* end = first_obj_addr + first_obj->size();\n+          cur_card = align_down(byte_for(end), num_cards_in_stripe);\n+        } else if (is_dirty(byte_for(first_obj_addr))) {\n+          \/\/ Potentially imprecisely marked dirty.\n+          \/\/ Mark first card of stripe dirty too.\n+          *cur_card = dirty_card_val();\n+        }\n+      }\n+    }\n+  }\n+}\n+\n@@ -185,1 +242,1 @@\n-    *i_card = clean_card;\n+    *i_card = clean_card_val();\n@@ -189,11 +246,102 @@\n-void PSCardTable::scan_objects_in_range(PSPromotionManager* pm,\n-                                        HeapWord* start,\n-                                        HeapWord* end) {\n-  HeapWord* obj_addr = start;\n-  while (obj_addr < end) {\n-    oop obj = cast_to_oop(obj_addr);\n-    assert(oopDesc::is_oop(obj), \"inv\");\n-    assert(!obj->is_objArray() || !is_large_obj_array(obj), \"single threaded scanning of large array\");\n-    prefetch_write(obj_addr);\n-    pm->push_contents(obj);\n-    obj_addr += obj->size();\n+\/\/ Find cards within [start, end) marked dirty, clear corresponding parts of the\n+\/\/ card table and scan objects on dirty cards.\n+\/\/ Scanning of objects is limited to [start, end) of a stripe. This way the\n+\/\/ scanning of objects crossing stripe boundaries is distributed. For this the\n+\/\/ dirty marks of imprecisely marked non-array objects are propagated\n+\/\/ pre-scavenge to the stripes they extend to.\n+\/\/ Except for the limitation to the [start, end) stripe non-array objects are scanned completely.\n+\/\/ Object arrays are marked precisely. Therefore the scanning is limited to dirty cards.\n+template <typename T>\n+void PSCardTable::process_range(T& start_cache,\n+                                PSPromotionManager* pm,\n+                                HeapWord* const start,\n+                                HeapWord* const end) {\n+  assert(start < end, \"precondition\");\n+  assert(is_card_aligned(start), \"precondition\");\n+\n+  \/\/ end might not be card-aligned\n+  CardValue* itr_limit_r = byte_for(end - 1) + 1;\n+  CardValue* clr_limit_r = byte_for(end);\n+\n+  CardValue* dirty_l;\n+  CardValue* dirty_r;\n+\n+  \/\/ Helper struct to keep the following code compact.\n+  struct Obj {\n+    HeapWord* addr;\n+    oop obj;\n+    bool is_obj_array;\n+    HeapWord* end_addr;\n+    Obj(HeapWord* o_addr) : addr(o_addr),\n+                            obj(cast_to_oop(o_addr)),\n+                            is_obj_array(obj->is_objArray()),\n+                            end_addr(addr + obj->size()) {}\n+    void next() {\n+      addr = end_addr;\n+      obj = cast_to_oop(addr);\n+      is_obj_array = obj->is_objArray();\n+      end_addr = addr + obj->size();\n+    }\n+  };\n+\n+  for (CardValue* cur_card = byte_for(start); cur_card < itr_limit_r; cur_card = dirty_r + 1) {\n+    dirty_l = find_first_dirty_card(cur_card, itr_limit_r);\n+    dirty_r = find_first_clean_card(start_cache, dirty_l, itr_limit_r);\n+\n+    assert(dirty_l <= dirty_r, \"inv\");\n+\n+    if (dirty_l == dirty_r) {\n+      assert(dirty_r == itr_limit_r, \"inv\");\n+      break;\n+    }\n+\n+    \/\/ Located a non-empty dirty chunk [dirty_l, dirty_r)\n+    HeapWord* addr_l = addr_for(dirty_l);\n+    HeapWord* addr_r = MIN2(addr_for(dirty_r), end);\n+\n+    \/\/ Clear the cards before scanning.\n+    clear_cards(dirty_l, MIN2(dirty_r, clr_limit_r));\n+\n+    \/\/ Scan objects overlapping [addr_l, addr_r) limited to [start, end)\n+    Obj obj(start_cache.object_start(addr_l));\n+\n+    \/\/ Scan non-objArray reaching into stripe and into [addr_l, addr_r).\n+    if (!obj.is_obj_array && obj.addr < start) {\n+      scan_obj_with_limit(pm, obj.obj, start, MIN2(obj.end_addr, end));\n+      if (obj.end_addr >= addr_r) {\n+        \/\/ Last object in [addr_l, addr_r)\n+        continue;\n+      }\n+      \/\/ move to next obj inside this dirty chunk\n+      obj.next();\n+    }\n+\n+    \/\/ Scan objects overlapping [addr_l, addr_r).\n+    \/\/ Non-objArrays are known to start within the stripe. They are scanned completely.\n+    \/\/ Scanning of objArrays is limited to the dirty chunk [addr_l, addr_r).\n+    while (obj.end_addr < addr_r) {\n+      if (obj.is_obj_array) {\n+        \/\/ precisely marked\n+        scan_obj_with_limit(pm, obj.obj, addr_l, addr_r);\n+      } else {\n+        assert(obj.addr >= start, \"handled before\");\n+        \/\/ scan whole obj\n+        scan_obj(pm, obj.obj);\n+      }\n+\n+      \/\/ move to next obj\n+      obj.next();\n+    }\n+\n+    \/\/ Scan object that extends beyond [addr_l, addr_r) and maybe even beyond the stripe.\n+    assert(obj.addr < addr_r, \"inv\");\n+    if (obj.is_obj_array) {\n+      \/\/ precise-marked\n+      scan_obj_with_limit(pm, obj.obj, addr_l, addr_r);\n+    } else {\n+      assert(obj.addr >= start, \"handled before\");\n+      scan_obj_with_limit(pm, obj.obj, obj.addr, MIN2(obj.end_addr, end));\n+    }\n+\n+    \/\/ Finished a dirty chunk\n+    pm->drain_stacks_cond_depth();\n@@ -201,1 +349,0 @@\n-  pm->drain_stacks_cond_depth();\n@@ -241,5 +388,0 @@\n-\/\/\n-\/\/ Objects starting in a stripe are scanned completely and exclusively by the\n-\/\/ stripe owner even if they extend beyond the stripe end. Large object\n-\/\/ arrays are an exception to this rule. A thread scans only array elements on\n-\/\/ its stripe.\n@@ -248,2 +390,2 @@\n-                                             MutableSpace* sp,\n-                                             HeapWord* space_top,\n+                                             HeapWord* old_gen_bottom,\n+                                             HeapWord* old_gen_top,\n@@ -253,0 +395,2 @@\n+  ObjStartCache start_cache(start_array);\n+\n@@ -256,136 +400,1 @@\n-  HeapWord* cur_stripe_addr = sp->bottom() + stripe_index * stripe_size_in_words;\n-\n-  \/\/ Cache object start information from previous stripe to avoid expensive and\n-  \/\/ repetitive start array queries.\n-  struct StartCache {\n-      HeapWord* obj_start;\n-      HeapWord* obj_end;\n-      DEBUG_ONLY(HeapWord* prev_query);\n-      StartCache() : obj_start(nullptr), obj_end(nullptr) DEBUG_ONLY(COMMA prev_query(nullptr)) {}\n-      HeapWord* object_start(HeapWord* addr, ObjectStartArray* start_array) {\n-        assert(prev_query == nullptr || prev_query <= addr, \"inv\");\n-        if (addr >= obj_end) {\n-          obj_start = start_array->object_start(addr);\n-          obj_end = obj_start + cast_to_oop(obj_start)->size();\n-        }\n-        DEBUG_ONLY(prev_query = addr);\n-        return obj_start;\n-      }\n-  } start_cache;\n-\n-  for (\/* empty *\/; cur_stripe_addr < space_top; cur_stripe_addr += slice_size_in_words) {\n-    \/\/ exclusive\n-    HeapWord* const cur_stripe_end_addr = MIN2(cur_stripe_addr + stripe_size_in_words,\n-                                               space_top);\n-\n-    if (!start_array->object_starts_in_range(cur_stripe_addr, cur_stripe_end_addr)) {\n-      \/\/ No object start means nothing to do. Except if the large object that\n-      \/\/ covers the stripe is a large object array. In that case we scavenge its\n-      \/\/ elements on the stripe.\n-      oop large_obj = cast_to_oop(start_cache.object_start(cur_stripe_addr, start_array));\n-      if (is_large_obj_array(large_obj)) {\n-        scavenge_large_array_contents(objArrayOop(large_obj), pm, cur_stripe_addr, cur_stripe_end_addr,\n-                                      space_top, false \/* first_card_already_cleared *\/);\n-      }\n-      continue;\n-    }\n-\n-    \/\/ Process objects starting in this stripe.\n-\n-    \/\/ Constraints:\n-    \/\/ 1. range of cards checked for being dirty or clean: [iter_limit_l, iter_limit_r)\n-    \/\/ 2. range of cards can be cleared: [clear_limit_l, clear_limit_r)\n-    \/\/ 3. range of objs (obj-start) can be scanned: [first_obj_addr, cur_stripe_end_addr)\n-    \/\/ 4. range of large objArray elements to be scanned: [cur_stripe_addr, cur_stripe_end_addr)\n-    \/\/    limited to dirty cards.\n-\n-    CardValue* iter_limit_l;\n-    CardValue* iter_limit_r;\n-    CardValue* clear_limit_l;\n-    CardValue* clear_limit_r;\n-\n-    \/\/ Identify left ends and the first obj-start inside this stripe.\n-    HeapWord* first_obj_addr = start_array->object_start(cur_stripe_addr);\n-    oop first_obj = cast_to_oop(first_obj_addr);\n-    if (first_obj_addr < cur_stripe_addr) {\n-      \/\/ This obj belongs to previous stripe unless it is a large object\n-      \/\/ array. In that case we must scan its elements on this stripe.\n-      if (is_large_obj_array(first_obj)) {\n-        scavenge_large_array_contents(objArrayOop(first_obj), pm, cur_stripe_addr, cur_stripe_end_addr,\n-                                      space_top, false \/* first_card_already_cleared *\/);\n-      }\n-      \/\/ Continue with the first object that actually starts here.\n-      \/\/ We don't clear the starting card if it is shared with previous\n-      \/\/ objects. They might be scanned by the owner of the previous stripe.\n-      first_obj_addr += first_obj->size();\n-      clear_limit_l = byte_for(first_obj_addr - 1) + 1;\n-      iter_limit_l = byte_for(first_obj_addr);\n-    } else {\n-      assert(first_obj_addr == cur_stripe_addr, \"inv\");\n-      iter_limit_l = clear_limit_l = byte_for(cur_stripe_addr);\n-    }\n-\n-    assert(cur_stripe_addr <= first_obj_addr, \"inside this stripe\");\n-    assert(first_obj_addr <= cur_stripe_end_addr, \"can be empty\");\n-\n-    objArrayOop large_arr = nullptr;\n-    bool large_arr_cleared_first_card = false;\n-    {\n-      \/\/ Identify right ends.\n-      HeapWord* obj_addr = start_array->object_start(cur_stripe_end_addr - 1);\n-      HeapWord* obj_end_addr = obj_addr + cast_to_oop(obj_addr)->size();\n-      if (is_large_obj_array(cast_to_oop(obj_addr))) {\n-        if (obj_addr < cur_stripe_addr) {\n-          \/\/ Scanned above already.\n-          assert(obj_addr == start_array->object_start(cur_stripe_addr), \"assumption\");\n-          continue;\n-        }\n-        \/\/ This is a large object array. We scan its elements on this stripe\n-        \/\/ after scanning the objects before it. The first card of the large\n-        \/\/ array will be cleared if it is not exclusive to it.\n-        large_arr = objArrayOop(cast_to_oop(obj_addr));\n-        large_arr_cleared_first_card =\n-            !is_card_aligned(obj_addr) && *byte_for(obj_addr) != PSCardTable::clean_card_val();\n-        clear_limit_r = iter_limit_r = byte_for(obj_addr - 1) + 1;\n-      } else {\n-        assert(obj_end_addr >= cur_stripe_end_addr, \"inv\");\n-        clear_limit_r = byte_for(obj_end_addr);\n-        iter_limit_r = byte_for(obj_end_addr - 1) + 1;\n-      }\n-    }\n-\n-    assert(iter_limit_l <= clear_limit_l &&\n-           clear_limit_r <= iter_limit_r, \"clear cards only if we iterate over them\");\n-\n-    \/\/ Process dirty chunks, i.e. consecutive dirty cards [dirty_l, dirty_r),\n-    \/\/ chunk by chunk inside [iter_limit_l, iter_limit_r).\n-    CardValue* dirty_l;\n-    CardValue* dirty_r;\n-\n-    for (CardValue* cur_card = iter_limit_l; cur_card < iter_limit_r; cur_card = dirty_r + 1) {\n-      dirty_l = find_first_dirty_card(cur_card, iter_limit_r);\n-      dirty_r = find_first_clean_card(start_array, dirty_l, iter_limit_r);\n-      assert(dirty_l <= dirty_r, \"inv\");\n-\n-      \/\/ empty\n-      if (dirty_l == dirty_r) {\n-        assert(dirty_r == iter_limit_r, \"no more dirty cards in this stripe\");\n-        break;\n-      }\n-\n-      assert(*dirty_l != clean_card, \"inv\");\n-      assert(*dirty_r == clean_card || dirty_r >= clear_limit_r,\n-             \"clean card or belonging to next stripe\");\n-\n-      \/\/ Process this non-empty dirty chunk in two steps:\n-      {\n-        \/\/ 1. Clear card in [dirty_l, dirty_r) subject to [clear_limit_l, clear_limit_r) constraint\n-        clear_cards(MAX2(dirty_l, clear_limit_l),\n-                    MIN2(dirty_r, clear_limit_r));\n-      }\n-\n-      {\n-        \/\/ 2. Scan objs in [dirty_l, dirty_r) subject to [first_obj_addr, cur_stripe_end_addr) constraint\n-        \/\/    Exclude the large array if one begins in the stripe\n-        HeapWord* obj_l = MAX2(start_array->object_start(addr_for(dirty_l)),\n-                               first_obj_addr);\n+  HeapWord* cur_stripe_addr = old_gen_bottom + stripe_index * stripe_size_in_words;\n@@ -393,4 +402,4 @@\n-        HeapWord* obj_r = MIN2(addr_for(dirty_r),\n-                               large_arr != nullptr ?\n-                                   cast_from_oop<HeapWord*>(large_arr) :\n-                                   cur_stripe_end_addr);\n+  for (\/* empty *\/; cur_stripe_addr < old_gen_top; cur_stripe_addr += slice_size_in_words) {\n+    HeapWord* const stripe_l = cur_stripe_addr;\n+    HeapWord* const stripe_r = MIN2(cur_stripe_addr + stripe_size_in_words,\n+                                    old_gen_top);\n@@ -398,85 +407,1 @@\n-        scan_objects_in_range(pm, obj_l, obj_r);\n-      }\n-    }\n-\n-    if (large_arr != nullptr) {\n-      scavenge_large_array_contents(large_arr, pm, cur_stripe_addr, cur_stripe_end_addr,\n-                                    space_top, large_arr_cleared_first_card);\n-    }\n-  }\n-}\n-\n-void PSCardTable::scavenge_large_array_contents(objArrayOop large_arr,\n-                                                PSPromotionManager* pm,\n-                                                HeapWord* stripe_addr,\n-                                                HeapWord* stripe_end_addr,\n-                                                HeapWord* space_top,\n-                                                bool first_card_already_cleared) {\n-  HeapWord* arr_addr = cast_from_oop<HeapWord*>(large_arr);\n-  HeapWord* arr_end_addr = arr_addr + large_arr->size();\n-\n-  \/\/ Constraints:\n-  \/\/ 1. range of cards checked for being dirty or clean: [iter_limit_l, iter_limit_r)\n-  \/\/ 2. range of cards can be cleared: [clear_limit_l, clear_limit_r)\n-  \/\/ 3. range of large objArray elements can be scanned: [stripe_addr, stripe_end_addr)\n-  \/\/    limited to dirty cards.\n-\n-  CardValue* iter_limit_l = byte_for(stripe_addr);\n-  CardValue* iter_limit_r = byte_for(stripe_end_addr - 1) + 1;\n-  CardValue* clear_limit_l = byte_for(stripe_addr);\n-  CardValue* clear_limit_r = byte_for(stripe_end_addr);\n-  assert(is_card_aligned(stripe_addr), \"assumption\");\n-  assert(is_card_aligned(stripe_end_addr) || stripe_end_addr == space_top, \"assumption\");\n-\n-  \/\/ Adjust left limits if the array starts in the stripe.\n-  \/\/ Also scan its first card if it was cleared already.\n-  if (stripe_addr <= arr_addr) {\n-    if (first_card_already_cleared) {\n-      assert(!is_card_aligned(arr_addr), \"first card is not shared with other objects\");\n-      clear_limit_l = iter_limit_l = byte_for(arr_addr) + 1;\n-      pm->push_objArray_contents(large_arr, arr_addr, align_up(arr_addr, card_size_in_words() * HeapWordSize));\n-    } else {\n-      iter_limit_l = byte_for(arr_addr);\n-      clear_limit_l = byte_for(arr_addr - 1) + 1;\n-    }\n-  }\n-\n-  \/\/ Adjust right limits if the array ends in the stripe\n-  if (arr_end_addr <= stripe_end_addr) {\n-    clear_limit_r = byte_for(arr_end_addr);\n-    iter_limit_r = byte_for(arr_end_addr - 1) + 1;\n-  }\n-\n-  \/\/ Process dirty chunks, i.e. consecutive dirty cards [dirty_l, dirty_r),\n-  \/\/ chunk by chunk inside [iter_limit_l, iter_limit_r).\n-  CardValue* dirty_l;\n-  CardValue* dirty_r;\n-\n-  for (CardValue* cur_card = iter_limit_l; cur_card < iter_limit_r; cur_card = dirty_r + 1) {\n-    dirty_l = find_first_dirty_card(cur_card, iter_limit_r);\n-    dirty_r = find_first_clean_card(dirty_l, iter_limit_r);\n-    assert(dirty_l <= dirty_r, \"inv\");\n-\n-    \/\/ empty\n-    if (dirty_l == dirty_r) {\n-      assert(dirty_r == iter_limit_r, \"no more dirty cards in this stripe\");\n-      break;\n-    }\n-\n-    assert(*dirty_l != clean_card, \"inv\");\n-    assert(*dirty_r == clean_card || dirty_r >= clear_limit_r,\n-           \"clean card or belonging to next stripe\");\n-\n-    \/\/ Process this non-empty dirty chunk in two steps:\n-    {\n-      \/\/ 1. Clear card in [dirty_l, dirty_r) subject to [clear_limit_l, clear_limit_r) constraint\n-      clear_cards(MAX2(dirty_l, clear_limit_l),\n-                  MIN2(dirty_r, clear_limit_r));\n-    }\n-\n-    {\n-      \/\/ 2. Scan elements in [dirty_l, dirty_r)\n-      HeapWord* left = addr_for(dirty_l);\n-      HeapWord* right = addr_for(dirty_r);\n-      pm->push_objArray_contents(large_arr, left, right);\n-    }\n+    process_range(start_cache, pm, stripe_l, stripe_r);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.cpp","additions":187,"deletions":262,"binary":false,"changes":449,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"oops\/oop.inline.hpp\"\n+#include \"oops\/oop.hpp\"\n@@ -37,0 +37,16 @@\n+  static constexpr size_t num_cards_in_stripe = 128;\n+  static_assert(num_cards_in_stripe >= 1, \"progress\");\n+\n+  bool is_dirty(CardValue* card) {\n+    return !is_clean(card);\n+  }\n+\n+  bool is_clean(CardValue* card) {\n+    return *card == clean_card_val();\n+  }\n+\n+  template <typename T>\n+  void process_range(T& start_cache,\n+                     PSPromotionManager* pm,\n+                     HeapWord* const start,\n+                     HeapWord* const end);\n@@ -45,7 +61,0 @@\n-  static size_t const num_cards_in_stripe = 128;\n-\n-  static bool is_large_obj_array(oop obj) {\n-    const size_t stripe_size_in_words = num_cards_in_stripe * _card_size_in_words;\n-    return obj->is_objArray() && obj->size() >= stripe_size_in_words;\n-  }\n-\n@@ -55,4 +64,2 @@\n-  CardValue* find_first_clean_card(CardValue* const start_card,\n-                                   CardValue* const end_card);\n-  \/\/ All cards of an object following a dirty card are considered dirty too.\n-  CardValue* find_first_clean_card(ObjectStartArray* start_array,\n+  template <typename T>\n+  CardValue* find_first_clean_card(T start_cache,\n@@ -62,1 +69,2 @@\n-  void clear_cards(CardValue* const start, CardValue* const end);\n+  void scan_obj(PSPromotionManager* pm,\n+                oop obj);\n@@ -64,3 +72,6 @@\n-  void scan_objects_in_range(PSPromotionManager* pm,\n-                             HeapWord* start,\n-                             HeapWord* end);\n+  void scan_obj_with_limit(PSPromotionManager* pm,\n+                           oop obj,\n+                           HeapWord* start,\n+                           HeapWord* end);\n+\n+  void clear_cards(CardValue* const start, CardValue* const end);\n@@ -74,0 +85,2 @@\n+  void pre_scavenge(MutableSpace* old_gen, ObjectStartArray* start_array);\n+\n@@ -76,2 +89,2 @@\n-                                  MutableSpace* sp,\n-                                  HeapWord* space_top,\n+                                  HeapWord* old_gen_bottom,\n+                                  HeapWord* old_gen_top,\n@@ -81,7 +94,0 @@\n-  \/\/ Scavenge the elements of a large object array on dirty cards of the stripe.\n-  void scavenge_large_array_contents(objArrayOop large_arr,\n-                                     PSPromotionManager* pm,\n-                                     HeapWord* stripe_addr,\n-                                     HeapWord* stripe_end_addr,\n-                                     HeapWord* space_top,\n-                                     bool first_card_already_cleared);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.hpp","additions":31,"deletions":25,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -357,6 +357,0 @@\n-\n-void PSPromotionManager::push_objArray_contents(objArrayOop arr, HeapWord* left, HeapWord* right) {\n-  PSPushContentsClosure pcc(this);\n-  arr->oop_oop_iterate_bounded(&pcc, MemRegion(left, right));\n-  drain_stacks_cond_depth();\n-}\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-  void push_objArray_contents(objArrayOop arr, HeapWord* left, HeapWord* right);\n+  void push_contents_bounded(oop obj, HeapWord* left, HeapWord* right);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -134,0 +134,7 @@\n+inline void PSPromotionManager::push_contents_bounded(oop obj, HeapWord* left, HeapWord* right) {\n+  if (!obj->klass()->is_typeArray_klass()) {\n+    PSPushContentsClosure pcc(this);\n+    obj->oop_iterate(&pcc, MemRegion(left, right));\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -90,1 +90,0 @@\n-  PSScavengeRootsClosure roots_closure(pm);\n@@ -304,0 +303,5 @@\n+\n+    if (!_is_old_gen_empty) {\n+      PSCardTable* card_table = ParallelScavengeHeap::heap()->card_table();\n+      card_table->pre_scavenge(_old_gen->object_space(), _old_gen->start_array());\n+    }\n@@ -317,0 +321,1 @@\n+        \/\/ The top of the old gen changes during scavenge when objects are promoted.\n@@ -318,1 +323,1 @@\n-                                               _old_gen->object_space(),\n+                                               _old_gen->object_space()->bottom(),\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -115,3 +115,0 @@\n-  \/\/ Iterate over oop elements within mr, and metadata.\n-  template <typename OopClosureType>\n-  inline void oop_oop_iterate_bounded(OopClosureType* closure, MemRegion mr);\n","filename":"src\/hotspot\/share\/oops\/objArrayOop.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"oops\/objArrayKlass.inline.hpp\"\n@@ -55,8 +54,0 @@\n-template <typename OopClosureType>\n-void objArrayOopDesc::oop_oop_iterate_bounded(OopClosureType* closure, MemRegion mr) {\n-  if (UseCompressedOops) {\n-    ((ObjArrayKlass*)klass())->oop_oop_iterate_bounded<narrowOop>(this, closure, mr);\n-  } else {\n-    ((ObjArrayKlass*)klass())->oop_oop_iterate_bounded<oop>(this, closure, mr);\n-  }\n-}\n","filename":"src\/hotspot\/share\/oops\/objArrayOop.inline.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"}]}